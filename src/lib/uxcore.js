/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ((function(modules) {
	// Check all modules for deduplicated modules
	for(var i in modules) {
		if(Object.prototype.hasOwnProperty.call(modules, i)) {
			switch(typeof modules[i]) {
			case "function": break;
			case "object":
				// Module can be created from a template
				modules[i] = (function(_m) {
					var args = _m.slice(1), fn = modules[_m[0]];
					return function (a,b,c) {
						fn.apply(this, [a,b,c].concat(args));
					};
				}(modules[i]));
				break;
			default:
				// Module is a copy of another module
				modules[i] = modules[modules[i]];
				break;
			}
		}
	}
	return modules;
}([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	window["Uxcore"] = {
	  "Alert": __webpack_require__(1),
	  "Button": __webpack_require__(6),
	  "Calendar": __webpack_require__(9),
	  "CheckboxGroup": __webpack_require__(215),
	  "Collapse": __webpack_require__(219),
	  "Const": __webpack_require__(222),
	  "Crumb": __webpack_require__(224),
	  "Dialog": __webpack_require__(227),
	  "Dropdown": __webpack_require__(276),
	  "Form": __webpack_require__(328),
	  "Formatter": __webpack_require__(154),
	  "Grid": __webpack_require__(501),
	  "Layout": __webpack_require__(508),
	  "Mention": __webpack_require__(514),
	  "Menu": __webpack_require__(521),
	  "MultiSelect": __webpack_require__(567),
	  "Pagination": __webpack_require__(572),
	  "Popover": __webpack_require__(578),
	  "Progress": __webpack_require__(632),
	  "Radiogroup": __webpack_require__(352),
	  "Select2": __webpack_require__(356),
	  "Steps": __webpack_require__(636),
	  "Table": __webpack_require__(639),
	  "Tabs": __webpack_require__(677),
	  "Tinymce": __webpack_require__(495),
	  "Tooltip": __webpack_require__(156),
	  "Totop": __webpack_require__(696),
	  "Transfer": __webpack_require__(698),
	  "Tree": __webpack_require__(644),
	  "Uploader": __webpack_require__(701),
	  "Validator": __webpack_require__(338),
	  "Message": __webpack_require__(712),
	  "Pickable": __webpack_require__(742),
	  "PrimaryNav": __webpack_require__(744)
		};

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Alert Component for uxcore
	 * @author eternaslky
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

		module.exports = __webpack_require__(2);

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	/**
	 * Alert Component for uxcore
	 * @author eternaslky
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);
	var classnames = __webpack_require__(5);

	var Alert = function (_React$Component) {
	    _inherits(Alert, _React$Component);

	    function Alert(props) {
	        _classCallCheck(this, Alert);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.state = {
	            closed: false
	        };
	        return _this;
	    }

	    Alert.prototype.toggleShow = function toggleShow() {
	        this.setState({
	            closed: !this.state.closed
	        });
	    };

	    Alert.prototype.handleClose = function handleClose(e) {

	        this.setState({
	            closed: true
	        });
	        this.props.onClose.call(this, e);
	    };

	    Alert.prototype.renderContent = function renderContent() {
	        var _classnames;

	        var me = this;
	        var iconMap = {
	            message: 'information',
	            error: 'error',
	            warning: 'caution',
	            success: 'success',
	            question: 'query',
	            stop: 'prohibition',
	            wait: 'wait'
	        };
	        var _me$props = me.props;
	        var prefixCls = _me$props.prefixCls;
	        var iconPrefixCls = _me$props.iconPrefixCls;
	        var type = _me$props.type;
	        var closable = _me$props.closable;
	        var description = _me$props.description;
	        var hasContainer = _me$props.hasContainer;
	        var className = _me$props.className;

	        var iconType = type;
	        if (iconPrefixCls == 'kuma-icon') {
	            iconType = iconMap[iconType];
	        }
	        // 保证 className 加在最外层容器上
	        return React.createElement('p', { className: classnames((_classnames = {}, _classnames[prefixCls + ' ' + prefixCls + '-' + type] = true, _classnames[className] = !!className && !closable && !description && !hasContainer, _classnames)) }, React.createElement('i', { className: prefixCls + '-icon ' + iconPrefixCls + ' ' + iconPrefixCls + '-' + iconType }), React.createElement('span', null, me.props.message));
	    };

	    Alert.prototype.renderDes = function renderDes() {
	        var me = this;
	        var _me$props2 = me.props;
	        var description = _me$props2.description;
	        var prefixCls = _me$props2.prefixCls;

	        if (!!description) {
	            return React.createElement('p', { className: prefixCls + ' ' + prefixCls + '-follow' }, description);
	        }
	    };

	    Alert.prototype.renderClose = function renderClose() {
	        var me = this;
	        var _me$props3 = me.props;
	        var prefixCls = _me$props3.prefixCls;
	        var iconPrefixCls = _me$props3.iconPrefixCls;

	        if (me.props.closable) {
	            if (me.props.closeText) {
	                return React.createElement('span', { className: prefixCls + '-close', onClick: me.handleClose.bind(me) }, me.props.closeText);
	            } else {
	                return React.createElement('i', { className: prefixCls + '-close ' + iconPrefixCls + ' ' + iconPrefixCls + '-close', onClick: me.handleClose.bind(me) });
	            }
	        }
	    };

	    Alert.prototype.render = function render() {
	        var me = this;
	        var _me$props4 = me.props;
	        var prefixCls = _me$props4.prefixCls;
	        var type = _me$props4.type;
	        var closable = _me$props4.closable;
	        var hasContainer = _me$props4.hasContainer;
	        var description = _me$props4.description;
	        var className = _me$props4.className;
	        var size = _me$props4.size;

	        var html = void 0;
	        var content = me.renderContent();
	        if (hasContainer || closable || !!description) {
	            var _classnames2;

	            html = React.createElement('div', { className: classnames((_classnames2 = {}, _classnames2[prefixCls + '-container ' + prefixCls + '-container-' + type] = true, _classnames2[prefixCls + '-container-closable'] = closable, _classnames2[className] = !!className, _classnames2[prefixCls + '-size-large'] = size === 'large', _classnames2)) }, content, me.renderDes(), me.renderClose());
	        } else {
	            html = content;
	        }
	        return this.state.closed ? null : html;
	    };

	    return Alert;
	}(React.Component);

	Alert.defaultProps = {
	    prefixCls: 'kuma-alert',
	    iconPrefixCls: 'kuma-icon',
	    type: 'message',
	    onClose: function onClose() {},
	    hasContainer: false,
	    size: 'normal'
	};

	// http://facebook.github.io/react/docs/reusable-components.html
	Alert.propTypes = {
	    prefixCls: React.PropTypes.string,
	    iconPrefixCls: React.PropTypes.string,
	    type: React.PropTypes.oneOf(['message', 'error', 'warning', 'success', 'question', 'stop', 'wait']),
	    closable: React.PropTypes.bool,
	    hasContainer: React.PropTypes.bool,
	    closeText: React.PropTypes.oneOfType([React.PropTypes.element, React.PropTypes.string]),
	    message: React.PropTypes.oneOfType([React.PropTypes.element, React.PropTypes.string]),
	    description: React.PropTypes.oneOfType([React.PropTypes.element, React.PropTypes.string]),
	    onClose: React.PropTypes.func,
	    size: React.PropTypes.oneOf(['normal', 'large'])

	};

	Alert.displayName = "Alert";

	module.exports = Alert;

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = window.React;

/***/ },
/* 4 */
/***/ function(module, exports) {

	module.exports = window.ReactDOM || window.React;

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	  Copyright (c) 2016 Jed Watson.
	  Licensed under the MIT License (MIT), see
	  http://jedwatson.github.io/classnames
	*/
	/* global define */

	(function () {
		'use strict';

		var hasOwn = {}.hasOwnProperty;

		function classNames () {
			var classes = [];

			for (var i = 0; i < arguments.length; i++) {
				var arg = arguments[i];
				if (!arg) continue;

				var argType = typeof arg;

				if (argType === 'string' || argType === 'number') {
					classes.push(arg);
				} else if (Array.isArray(arg)) {
					classes.push(classNames.apply(null, arg));
				} else if (argType === 'object') {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				}
			}

			return classes.join(' ');
		}

		if (typeof module !== 'undefined' && module.exports) {
			module.exports = classNames;
		} else if (true) {
			// register as 'classnames', consistent with npm package name
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return classNames;
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
			window.classNames = classNames;
		}
	}());


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _Button = __webpack_require__(7);

	var _Button2 = _interopRequireDefault(_Button);

	var _ButtonGroup = __webpack_require__(8);

	var _ButtonGroup2 = _interopRequireDefault(_ButtonGroup);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}

	/**
	 * Button Component for uxcore
	 * @author
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	_Button2["default"].ButtonGroup = _ButtonGroup2["default"];
	module.exports = _Button2["default"];

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _extends = Object.assign || function (target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];for (var key in source) {
				if (Object.prototype.hasOwnProperty.call(source, key)) {
					target[key] = source[key];
				}
			}
		}return target;
	};

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(4);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _classnames = __webpack_require__(5);

	var _classnames2 = _interopRequireDefault(_classnames);

	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : { "default": obj };
	}

	function _classCallCheck(instance, Constructor) {
		if (!(instance instanceof Constructor)) {
			throw new TypeError("Cannot call a class as a function");
		}
	}

	function _possibleConstructorReturn(self, call) {
		if (!self) {
			throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		}return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
		if (typeof superClass !== "function" && superClass !== null) {
			throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
		}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var sizeMap = {
		small: 'sm',
		medium: '',
		large: 'lg'
	},
	    typeMap = {
		primary: 'primary',
		secondary: 'secondary',
		outline: 'outline',
		disabled: 'disabled'
	},
	    clsPrefix = 'kuma-button';

	var Button = function (_React$Component) {
		_inherits(Button, _React$Component);

		function Button(props) {
			_classCallCheck(this, Button);

			return _possibleConstructorReturn(this, _React$Component.call(this, props));
		}

		Button.prototype.render = function render() {
			var props = this.props;
			var type = props.disabled ? 'disabled' : props.type;
			var clsObj = {};
			if (props.className) {
				clsObj[props.className] = true;
			}
			if (sizeMap[props.size]) {
				clsObj[clsPrefix + '-' + sizeMap[props.size]] = true;
			}
			var className = (0, _classnames2["default"])(clsPrefix, clsPrefix + '-' + typeMap[type], clsObj);
			var propEvents = {};
			Object.keys(props).forEach(function (key) {
				if (key.indexOf('on') === 0) {
					propEvents[key] = props[key];
				}
			});
			return _react2["default"].createElement('button', _extends({ className: className, disabled: props.disabled }, propEvents), props.children);
		};

		return Button;
	}(_react2["default"].Component);

	Button.displayName = 'uxcore-button';
	Button.propTypes = {
		size: _react2["default"].PropTypes.oneOf(Object.keys(sizeMap)),
		type: _react2["default"].PropTypes.oneOf(Object.keys(typeMap)),
		disabled: _react2["default"].PropTypes.oneOf(['disabled', true, false]),
		className: _react2["default"].PropTypes.string
	};
	Button.defaultProps = {
		size: 'medium',
		type: 'primary',
		disabled: false,
		className: ''
	};

		module.exports = Button;

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(4);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _classnames = __webpack_require__(5);

	var _classnames2 = _interopRequireDefault(_classnames);

	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : { "default": obj };
	}

	function _classCallCheck(instance, Constructor) {
		if (!(instance instanceof Constructor)) {
			throw new TypeError("Cannot call a class as a function");
		}
	}

	function _possibleConstructorReturn(self, call) {
		if (!self) {
			throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		}return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
		if (typeof superClass !== "function" && superClass !== null) {
			throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
		}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var ButtonGroup = function (_React$Component) {
		_inherits(ButtonGroup, _React$Component);

		function ButtonGroup(props) {
			_classCallCheck(this, ButtonGroup);

			return _possibleConstructorReturn(this, _React$Component.call(this, props));
		}

		ButtonGroup.prototype.render = function render() {
			return _react2["default"].createElement('div', { className: 'kuma-button-group' }, this.props.children);
		};

		return ButtonGroup;
	}(_react2["default"].Component);

	ButtonGroup.displayName = 'ButtonGroup';
	ButtonGroup.propTypes = {};
	ButtonGroup.defaultProps = {};

	module.exports = ButtonGroup;

/***/ },
/* 9 */
[746, 10],
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var RcCalendar = __webpack_require__(11);
	var GregorianCalendar = __webpack_require__(12);
	var DateTimeFormat = __webpack_require__(42);
	var Datepicker = __webpack_require__(58);
	var RcMonthCalendar = __webpack_require__(86);
	var RcYearCalendar = __webpack_require__(87);
	var TimePicker = __webpack_require__(88);
	var util = __webpack_require__(153);
	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var defaultValueLocale = {};
	var CalendarLocale = {};
	var TimePickerLocale = {};
	defaultValueLocale['zh-cn'] = __webpack_require__(209);
	defaultValueLocale['en-us'] = __webpack_require__(15);
	CalendarLocale['zh-cn'] = __webpack_require__(210);
	CalendarLocale['en-us'] = __webpack_require__(56);
	TimePickerLocale['zh-cn'] = __webpack_require__(212);
	TimePickerLocale['en-us'] = __webpack_require__(139);

	function getGregorianCalendarDate(date, locale) {
	    defaultValueLocale[locale].timezoneOffset = -new Date().getTimezoneOffset();
	    var value = new GregorianCalendar(defaultValueLocale[locale]);
	    value.setTime(new Date(date).valueOf());
	    return value;
	}

	function getCalendarContainer() {
	    var c = document.createElement('div');
	    c.className = 'uxcore';
	    document.body.appendChild(c);
	    return c;
	}

	var Calendar = function (_React$Component) {
	    _inherits(Calendar, _React$Component);

	    function Calendar(props) {
	        _classCallCheck(this, Calendar);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.state = {};
	        return _this;
	    }

	    Calendar.prototype.componentWillMount = function componentWillMount() {
	        var me = this;
	        me.TimePickerElement = React.createElement(TimePicker, { prefixCls: 'kuma-time-picker', locale: TimePickerLocale[me.props.locale] });
	    };

	    Calendar.prototype.render = function render() {
	        var _this2 = this;

	        var me = this;
	        var p = me.props;
	        var formatter = new DateTimeFormat(p.format);
	        var calendarOptions = {
	            className: p.className,
	            style: p.style,
	            contentRender: p.contentRender,
	            disabledDate: p.disabledDate,
	            showWeekNumber: p.showWeekNumber,
	            showToday: p.showToday,
	            timePicker: p.showTime ? me.TimePickerElement : null,
	            showDateInput: p.showDateInput,
	            locale: CalendarLocale[p.locale],
	            prefixCls: 'kuma-calendar'
	        };
	        var pickerOptions = {
	            disabled: p.disabled,
	            formatter: formatter,
	            transitionName: p.transitionName,
	            adjustOrientOnCalendarOverflow: false,
	            prefixCls: 'kuma-calendar-picker',
	            placement: 'bottomLeft',
	            getCalendarContainer: getCalendarContainer
	        };

	        if (p.value) {
	            var value = getGregorianCalendarDate(p.value, p.locale);
	            pickerOptions.value = calendarOptions.defaultValue = value;
	        } else {
	            pickerOptions.value = calendarOptions.defaultValue = null;
	        }

	        if (p.defaultValue) {
	            var value = getGregorianCalendarDate(p.defaultValue, p.locale);
	            calendarOptions.defaultValue = value;
	            pickerOptions.defaultValue = value;
	        } else {
	            var value = getGregorianCalendarDate(new Date().getTime(), p.locale);
	            calendarOptions.defaultValue = value;
	        }
	        if (p.hasTrigger) {
	            pickerOptions.trigger = React.createElement('i', { className: 'kuma-icon kuma-icon-calender' });
	        }

	        var calendar = React.createElement(RcCalendar, calendarOptions);

	        function _onChange(v) {
	            var date = v.getTime();
	            var value = getGregorianCalendarDate(date, p.locale);
	            this.props.onSelect(new Date(date), formatter.format(value));
	        }

	        return React.createElement(Datepicker, _extends({
	            calendar: calendar,
	            onChange: _onChange.bind(me)
	        }, pickerOptions), function (_ref) {
	            var value = _ref.value;

	            return React.createElement('input', { value: value && formatter.format(value), readOnly: true, disabled: me.props.disabled, placeholder: _this2.props.placeholder, className: 'kuma-calendar-picker-input kuma-input' });
	        });
	    };

	    return Calendar;
	}(React.Component);

	Calendar.displayName = 'Calendar';
	Calendar.defaultProps = {
	    format: 'yyyy-MM-dd',
	    placeholder: '请选择日期',
	    onSelect: function onSelect() {},
	    locale: 'zh-cn',
	    showDateInput: false,
	    hasTrigger: false
	};
	Calendar.propTypes = {
	    format: React.PropTypes.string,
	    placeholder: React.PropTypes.string,
	    onSelect: React.PropTypes.func,
	    locale: React.PropTypes.string,
	    hasTrigger: React.PropTypes.bool
	};

	var MonthCalendar = function (_React$Component2) {
	    _inherits(MonthCalendar, _React$Component2);

	    function MonthCalendar(props) {
	        _classCallCheck(this, MonthCalendar);

	        var _this3 = _possibleConstructorReturn(this, _React$Component2.call(this, props));

	        _this3.state = {};
	        return _this3;
	    }

	    MonthCalendar.prototype.render = function render() {
	        var _this4 = this;

	        var me = this;
	        var p = me.props;
	        var formatter = new DateTimeFormat(p.format);
	        var calendarOptions = {
	            className: p.className,
	            style: p.style,
	            locale: CalendarLocale[p.locale],
	            orient: ['top', 'left'],
	            prefixCls: 'kuma-calendar'
	        };
	        var pickerOptions = {
	            disabled: p.disabled,
	            transitionName: p.transitionName,
	            formatter: formatter,
	            adjustOrientOnCalendarOverflow: false,
	            prefixCls: 'kuma-calendar-picker',
	            getCalendarContainer: getCalendarContainer
	        };

	        if (p.value) {
	            var value = getGregorianCalendarDate(p.value, p.locale);
	            pickerOptions.value = calendarOptions.defaultValue = value;
	        } else {
	            pickerOptions.value = calendarOptions.defaultValue = null;
	        }

	        if (p.defaultValue) {
	            var value = getGregorianCalendarDate(p.defaultValue, p.locale);
	            calendarOptions.defaultValue = value;
	        }
	        var calendar = React.createElement(RcMonthCalendar, calendarOptions);

	        function _onChange(v) {
	            var date = v.getTime();
	            var value = getGregorianCalendarDate(date, p.locale);
	            this.props.onSelect(new Date(date), formatter.format(value));
	        }

	        return React.createElement(Datepicker, _extends({
	            calendar: calendar,
	            onChange: _onChange.bind(me)
	        }, pickerOptions), function (_ref2) {
	            var value = _ref2.value;

	            return React.createElement('input', { readOnly: true, value: value && formatter.format(value), disabled: me.props.disabled, placeholder: _this4.props.placeholder, className: 'kuma-calendar-picker-input kuma-input' });
	        });
	    };

	    return MonthCalendar;
	}(React.Component);

	MonthCalendar.displayName = 'MonthCalendar';
	MonthCalendar.defaultProps = {
	    format: 'yyyy-MM',
	    placeholder: '请选择月份',
	    onSelect: function onSelect() {},
	    locale: 'zh-cn'
	};
	MonthCalendar.propTypes = {
	    format: React.PropTypes.string,
	    placeholder: React.PropTypes.string,
	    onSelect: React.PropTypes.func,
	    locale: React.PropTypes.string
	};

	var YearCalendar = function (_React$Component3) {
	    _inherits(YearCalendar, _React$Component3);

	    function YearCalendar(props) {
	        _classCallCheck(this, YearCalendar);

	        var _this5 = _possibleConstructorReturn(this, _React$Component3.call(this, props));

	        _this5.state = {};
	        return _this5;
	    }

	    YearCalendar.prototype.render = function render() {
	        var _this6 = this;

	        var me = this;
	        var p = me.props;
	        var formatter = new DateTimeFormat(p.format);
	        var calendarOptions = {
	            className: p.className,
	            style: p.style,
	            locale: CalendarLocale[p.locale],
	            orient: ['top', 'left'],
	            prefixCls: 'kuma-calendar'
	        };
	        var pickerOptions = {
	            disabled: p.disabled,
	            formatter: formatter,
	            transitionName: p.transitionName,
	            adjustOrientOnCalendarOverflow: false,
	            prefixCls: 'kuma-calendar-picker',
	            getCalendarContainer: getCalendarContainer
	        };

	        if (p.value) {
	            var value = getGregorianCalendarDate(p.value, p.locale);
	            pickerOptions.value = calendarOptions.defaultValue = value;
	        } else {
	            pickerOptions.value = calendarOptions.defaultValue = null;
	        }

	        if (p.defaultValue) {
	            var value = getGregorianCalendarDate(p.defaultValue, p.locale);
	            calendarOptions.defaultValue = value;
	        }
	        var calendar = React.createElement(RcYearCalendar, calendarOptions);

	        function _onChange(v) {
	            var date = v.getTime();
	            var value = getGregorianCalendarDate(date, p.locale);
	            this.props.onSelect(new Date(date), formatter.format(value));
	        }

	        return React.createElement(Datepicker, _extends({
	            calendar: calendar,
	            onChange: _onChange.bind(me)
	        }, pickerOptions), function (_ref3) {
	            var value = _ref3.value;

	            return React.createElement('input', { value: value && formatter.format(value), readOnly: true, disabled: me.props.disabled, placeholder: _this6.props.placeholder, className: 'kuma-calendar-picker-input kuma-input' });
	        });
	    };

	    return YearCalendar;
	}(React.Component);

	YearCalendar.displayName = 'YearCalendar';
	YearCalendar.defaultProps = {
	    format: 'yyyy',
	    placeholder: '请选择年份',
	    onSelect: function onSelect() {},
	    locale: 'zh-cn'
	};
	YearCalendar.propTypes = {
	    format: React.PropTypes.string,
	    placeholder: React.PropTypes.string,
	    onSelect: React.PropTypes.func,
	    locale: React.PropTypes.string
	};

	Calendar.MonthCalendar = MonthCalendar;
	Calendar.YearCalendar = YearCalendar;
	Calendar.CalendarPanel = RcCalendar;
	Calendar.util = util;

	module.exports = Calendar;

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _gregorianCalendar = __webpack_require__(12);

	var _gregorianCalendar2 = _interopRequireDefault(_gregorianCalendar);

	var _rcUtil = __webpack_require__(16);

	var _DateTable = __webpack_require__(37);

	var _DateTable2 = _interopRequireDefault(_DateTable);

	var _CalendarHeader = __webpack_require__(46);

	var _CalendarHeader2 = _interopRequireDefault(_CalendarHeader);

	var _CalendarFooter = __webpack_require__(51);

	var _CalendarFooter2 = _interopRequireDefault(_CalendarFooter);

	var _CalendarMixin = __webpack_require__(54);

	var _CalendarMixin2 = _interopRequireDefault(_CalendarMixin);

	var _CommonMixin = __webpack_require__(55);

	var _CommonMixin2 = _interopRequireDefault(_CommonMixin);

	var _DateInput = __webpack_require__(57);

	var _DateInput2 = _interopRequireDefault(_DateInput);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}

	function noop() {} // customized rc-calendar https://github.com/react-component/calendar/blob/master/src/Calendar.jsx

	function goStartMonth() {
	  var next = this.state.value.clone();
	  next.setDayOfMonth(1);
	  this.setValue(next);
	}

	function goEndMonth() {
	  var next = this.state.value.clone();
	  next.setDayOfMonth(next.getActualMaximum(_gregorianCalendar2["default"].MONTH));
	  this.setValue(next);
	}

	function goMonth(direction) {
	  var next = this.state.value.clone();
	  next.addMonth(direction);
	  this.setValue(next);
	}

	function goYear(direction) {
	  var next = this.state.value.clone();
	  next.addYear(direction);
	  this.setValue(next);
	}

	function goWeek(direction) {
	  var next = this.state.value.clone();
	  next.addWeekOfYear(direction);
	  this.setValue(next);
	}

	function goDay(direction) {
	  var next = this.state.value.clone();
	  next.addDayOfMonth(direction);
	  this.setValue(next);
	}

	var Calendar = _react2["default"].createClass({
	  displayName: 'Calendar',

	  propTypes: {
	    disabledDate: _react.PropTypes.func,
	    disabledTime: _react.PropTypes.any,
	    value: _react.PropTypes.object,
	    selectedValue: _react.PropTypes.object,
	    defaultValue: _react.PropTypes.object,
	    className: _react.PropTypes.string,
	    locale: _react.PropTypes.object,
	    showWeekNumber: _react.PropTypes.bool,
	    style: _react.PropTypes.object,
	    showToday: _react.PropTypes.bool,
	    showDateInput: _react.PropTypes.bool,
	    visible: _react.PropTypes.bool,
	    onSelect: _react.PropTypes.func,
	    onOk: _react.PropTypes.func,
	    showOk: _react.PropTypes.bool,
	    prefixCls: _react.PropTypes.string,
	    onKeyDown: _react.PropTypes.func,
	    timePicker: _react.PropTypes.element,
	    dateInputPlaceholder: _react.PropTypes.any,
	    onClear: _react.PropTypes.func,
	    onChange: _react.PropTypes.func
	  },

	  mixins: [_CommonMixin2["default"], _CalendarMixin2["default"]],

	  getDefaultProps: function getDefaultProps() {
	    return {
	      showToday: true,
	      showDateInput: true,
	      timePicker: null,
	      onOk: noop
	    };
	  },
	  getInitialState: function getInitialState() {
	    // bind methods
	    this.nextMonth = goMonth.bind(this, 1);
	    this.previousMonth = goMonth.bind(this, -1);
	    this.nextYear = goYear.bind(this, 1);
	    this.previousYear = goYear.bind(this, -1);
	    return {};
	  },
	  onKeyDown: function onKeyDown(event) {
	    if (event.target.nodeName.toLowerCase() === 'input') {
	      return undefined;
	    }
	    var keyCode = event.keyCode;
	    // mac
	    var ctrlKey = event.ctrlKey || event.metaKey;
	    switch (keyCode) {
	      case _rcUtil.KeyCode.DOWN:
	        goWeek.call(this, 1);
	        event.preventDefault();
	        return 1;
	      case _rcUtil.KeyCode.UP:
	        goWeek.call(this, -1);
	        event.preventDefault();
	        return 1;
	      case _rcUtil.KeyCode.LEFT:
	        if (ctrlKey) {
	          this.previousYear();
	        } else {
	          goDay.call(this, -1);
	        }
	        event.preventDefault();
	        return 1;
	      case _rcUtil.KeyCode.RIGHT:
	        if (ctrlKey) {
	          this.nextYear();
	        } else {
	          goDay.call(this, 1);
	        }
	        event.preventDefault();
	        return 1;
	      case _rcUtil.KeyCode.HOME:
	        goStartMonth.call(this);
	        event.preventDefault();
	        return 1;
	      case _rcUtil.KeyCode.END:
	        goEndMonth.call(this);
	        event.preventDefault();
	        return 1;
	      case _rcUtil.KeyCode.PAGE_DOWN:
	        this.nextMonth();
	        event.preventDefault();
	        return 1;
	      case _rcUtil.KeyCode.PAGE_UP:
	        this.previousMonth();
	        event.preventDefault();
	        return 1;
	      case _rcUtil.KeyCode.ENTER:
	        this.onSelect(this.state.value);
	        event.preventDefault();
	        return 1;
	      default:
	        this.props.onKeyDown(event);
	        return 1;
	    }
	  },
	  onClear: function onClear() {
	    this.onSelect(null);
	    this.props.onClear();
	  },
	  onOk: function onOk() {
	    var selectedValue = this.state.selectedValue;

	    if (this.isAllowedDate(selectedValue)) {
	      this.props.onOk(selectedValue);
	    }
	  },
	  onDateInputChange: function onDateInputChange(value) {
	    this.onSelect(value, {
	      source: 'dateInput'
	    });
	  },
	  onDateTableSelect: function onDateTableSelect(value) {
	    this.onSelect(value);
	  },
	  chooseToday: function chooseToday() {
	    var today = this.state.value.clone();
	    today.setTime(Date.now());
	    this.onSelect(today);
	  },
	  render: function render() {
	    var props = this.props;
	    var locale = props.locale;
	    var prefixCls = props.prefixCls;
	    var disabledDate = props.disabledDate;
	    var dateInputPlaceholder = props.dateInputPlaceholder;
	    var timePicker = props.timePicker;
	    var disabledTime = props.disabledTime;

	    var state = this.state;
	    var value = state.value;
	    var selectedValue = state.selectedValue;

	    var dateInputElement = props.showDateInput ? _react2["default"].createElement(_DateInput2["default"], {
	      formatter: this.getFormatter(),
	      key: 'date-input',
	      timePicker: timePicker,
	      gregorianCalendarLocale: value.locale,
	      locale: locale,
	      placeholder: dateInputPlaceholder,
	      showClear: true,
	      disabledTime: disabledTime,
	      disabledDate: disabledDate,
	      onClear: this.onClear,
	      prefixCls: prefixCls,
	      selectedValue: selectedValue,
	      onChange: this.onDateInputChange
	    }) : null;
	    var children = [dateInputElement, _react2["default"].createElement('div', {
	      key: 'date-panel',
	      className: prefixCls + '-date-panel'
	    }, _react2["default"].createElement(_CalendarHeader2["default"], {
	      locale: locale,
	      onValueChange: this.setValue,
	      value: value,
	      prefixCls: prefixCls
	    }), _react2["default"].createElement('div', { className: prefixCls + '-calendar-body' }, _react2["default"].createElement(_DateTable2["default"], {
	      locale: locale,
	      value: value,
	      selectedValue: selectedValue,
	      prefixCls: prefixCls,
	      dateRender: props.dateRender,
	      contentRender: props.contentRender,
	      onSelect: this.onDateTableSelect,
	      disabledDate: disabledDate,
	      showWeekNumber: props.showWeekNumber
	    })), _react2["default"].createElement(_CalendarFooter2["default"], {
	      showOk: props.showOk,
	      locale: locale,
	      prefixCls: prefixCls,
	      showToday: props.showToday,
	      disabledTime: disabledTime,
	      gregorianCalendarLocale: value.locale,
	      showDateInput: props.showDateInput,
	      timePicker: timePicker,
	      selectedValue: selectedValue,
	      value: value,
	      disabledDate: disabledDate,
	      onOk: this.onOk,
	      onSelect: this.onSelect,
	      onToday: this.chooseToday
	    }))];

	    return this.renderRoot({
	      children: children,
	      className: props.showWeekNumber ? prefixCls + '-week-number' : ''
	    });
	  }
	});

	exports["default"] = Calendar;
	module.exports = exports['default'];

/***/ },
/* 12 */
[747, 13, 15, 14],
/* 13 */
[748, 14],
/* 14 */
/***/ function(module, exports) {

	/*
	 * @ignore
	 * const for gregorian date
	 * @author yiminghe@gmail.com
	 */

	"use strict";

	module.exports = {
	  /*
	   * Enum indicating sunday
	   * @type Number
	   * @member Date.Gregorian
	   */
	  SUNDAY: 0,
	  /*
	   * Enum indicating monday
	   * @type Number
	   * @member Date.Gregorian
	   */
	  MONDAY: 1,
	  /*
	   * Enum indicating tuesday
	   * @type Number
	   * @member Date.Gregorian
	   */
	  TUESDAY: 2,
	  /*
	   * Enum indicating wednesday
	   * @type Number
	   * @member Date.Gregorian
	   */
	  WEDNESDAY: 3,
	  /*
	   * Enum indicating thursday
	   * @type Number
	   * @member Date.Gregorian
	   */
	  THURSDAY: 4,
	  /*
	   * Enum indicating friday
	   * @type Number
	   * @member Date.Gregorian
	   */
	  FRIDAY: 5,
	  /*
	   * Enum indicating saturday
	   * @type Number
	   * @member Date.Gregorian
	   */
	  SATURDAY: 6,
	  /*
	   * Enum indicating january
	   * @type Number
	   * @member Date.Gregorian
	   */
	  JANUARY: 0,
	  /*
	   * Enum indicating february
	   * @type Number
	   * @member Date.Gregorian
	   */
	  FEBRUARY: 1,
	  /*
	   * Enum indicating march
	   * @type Number
	   * @member Date.Gregorian
	   */
	  MARCH: 2,
	  /*
	   * Enum indicating april
	   * @type Number
	   * @member Date.Gregorian
	   */
	  APRIL: 3,
	  /*
	   * Enum indicating may
	   * @type Number
	   * @member Date.Gregorian
	   */
	  MAY: 4,
	  /*
	   * Enum indicating june
	   * @type Number
	   * @member Date.Gregorian
	   */
	  JUNE: 5,
	  /*
	   * Enum indicating july
	   * @type Number
	   * @member Date.Gregorian
	   */
	  JULY: 6,
	  /*
	   * Enum indicating august
	   * @type Number
	   * @member Date.Gregorian
	   */
	  AUGUST: 7,
	  /*
	   * Enum indicating september
	   * @type Number
	   * @member Date.Gregorian
	   */
	  SEPTEMBER: 8,
	  /*
	   * Enum indicating october
	   * @type Number
	   * @member Date.Gregorian
	   */
	  OCTOBER: 9,
	  /*
	   * Enum indicating november
	   * @type Number
	   * @member Date.Gregorian
	   */
	  NOVEMBER: 10,
	  /*
	   * Enum indicating december
	   * @type Number
	   * @member Date.Gregorian
	   */
	  DECEMBER: 11
		};

/***/ },
/* 15 */
/***/ function(module, exports) {

	/*
	 * en-us locale
	 * @ignore
	 * @author yiminghe@gmail.com
	 */
	"use strict";

	module.exports = {
	  // in minutes
	  timezoneOffset: -8 * 60,
	  firstDayOfWeek: 0,
	  minimalDaysInFirstWeek: 1
		};

/***/ },
/* 16 */
[749, 17, 18, 20, 21, 22, 23, 28, 29, 34, 35, 36],
/* 17 */
/***/ function(module, exports) {

	'use strict';

	var seed = 0;
	module.exports = function guid() {
	  return Date.now() + '_' + seed++;
		};

/***/ },
/* 18 */
[750, 19],
/* 19 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	/**
	 * Module exports.
	 */

	module.exports = deprecate;

	/**
	 * Mark that a method should not be used.
	 * Returns a modified function which warns once by default.
	 *
	 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
	 *
	 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
	 * will throw an Error when invoked.
	 *
	 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
	 * will invoke `console.trace()` instead of `console.error()`.
	 *
	 * @param {Function} fn - the function to deprecate
	 * @param {String} msg - the string to print to the console when `fn` is invoked
	 * @returns {Function} a new "deprecated" version of `fn`
	 * @api public
	 */

	function deprecate(fn, msg) {
	  if (config('noDeprecation')) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (config('throwDeprecation')) {
	        throw new Error(msg);
	      } else if (config('traceDeprecation')) {
	        console.trace(msg);
	      } else {
	        console.warn(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	}

	/**
	 * Checks `localStorage` for boolean values for the given `name`.
	 *
	 * @param {String} name
	 * @returns {Boolean}
	 * @api private
	 */

	function config(name) {
	  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
	  try {
	    if (!global.localStorage) return false;
	  } catch (_) {
	    return false;
	  }
	  var val = global.localStorage[name];
	  if (null == val) return false;
	  return String(val).toLowerCase() === 'true';
		}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 20 */
[751, 19],
/* 21 */
/***/ function(module, exports) {

	/**
	 * @ignore
	 * some key-codes definition and utils from closure-library
	 * @author yiminghe@gmail.com
	 */

	'use strict';

	var KeyCode = {
	  /**
	   * MAC_ENTER
	   */
	  MAC_ENTER: 3,
	  /**
	   * BACKSPACE
	   */
	  BACKSPACE: 8,
	  /**
	   * TAB
	   */
	  TAB: 9,
	  /**
	   * NUMLOCK on FF/Safari Mac
	   */
	  NUM_CENTER: 12, // NUMLOCK on FF/Safari Mac
	  /**
	   * ENTER
	   */
	  ENTER: 13,
	  /**
	   * SHIFT
	   */
	  SHIFT: 16,
	  /**
	   * CTRL
	   */
	  CTRL: 17,
	  /**
	   * ALT
	   */
	  ALT: 18,
	  /**
	   * PAUSE
	   */
	  PAUSE: 19,
	  /**
	   * CAPS_LOCK
	   */
	  CAPS_LOCK: 20,
	  /**
	   * ESC
	   */
	  ESC: 27,
	  /**
	   * SPACE
	   */
	  SPACE: 32,
	  /**
	   * PAGE_UP
	   */
	  PAGE_UP: 33, // also NUM_NORTH_EAST
	  /**
	   * PAGE_DOWN
	   */
	  PAGE_DOWN: 34, // also NUM_SOUTH_EAST
	  /**
	   * END
	   */
	  END: 35, // also NUM_SOUTH_WEST
	  /**
	   * HOME
	   */
	  HOME: 36, // also NUM_NORTH_WEST
	  /**
	   * LEFT
	   */
	  LEFT: 37, // also NUM_WEST
	  /**
	   * UP
	   */
	  UP: 38, // also NUM_NORTH
	  /**
	   * RIGHT
	   */
	  RIGHT: 39, // also NUM_EAST
	  /**
	   * DOWN
	   */
	  DOWN: 40, // also NUM_SOUTH
	  /**
	   * PRINT_SCREEN
	   */
	  PRINT_SCREEN: 44,
	  /**
	   * INSERT
	   */
	  INSERT: 45, // also NUM_INSERT
	  /**
	   * DELETE
	   */
	  DELETE: 46, // also NUM_DELETE
	  /**
	   * ZERO
	   */
	  ZERO: 48,
	  /**
	   * ONE
	   */
	  ONE: 49,
	  /**
	   * TWO
	   */
	  TWO: 50,
	  /**
	   * THREE
	   */
	  THREE: 51,
	  /**
	   * FOUR
	   */
	  FOUR: 52,
	  /**
	   * FIVE
	   */
	  FIVE: 53,
	  /**
	   * SIX
	   */
	  SIX: 54,
	  /**
	   * SEVEN
	   */
	  SEVEN: 55,
	  /**
	   * EIGHT
	   */
	  EIGHT: 56,
	  /**
	   * NINE
	   */
	  NINE: 57,
	  /**
	   * QUESTION_MARK
	   */
	  QUESTION_MARK: 63, // needs localization
	  /**
	   * A
	   */
	  A: 65,
	  /**
	   * B
	   */
	  B: 66,
	  /**
	   * C
	   */
	  C: 67,
	  /**
	   * D
	   */
	  D: 68,
	  /**
	   * E
	   */
	  E: 69,
	  /**
	   * F
	   */
	  F: 70,
	  /**
	   * G
	   */
	  G: 71,
	  /**
	   * H
	   */
	  H: 72,
	  /**
	   * I
	   */
	  I: 73,
	  /**
	   * J
	   */
	  J: 74,
	  /**
	   * K
	   */
	  K: 75,
	  /**
	   * L
	   */
	  L: 76,
	  /**
	   * M
	   */
	  M: 77,
	  /**
	   * N
	   */
	  N: 78,
	  /**
	   * O
	   */
	  O: 79,
	  /**
	   * P
	   */
	  P: 80,
	  /**
	   * Q
	   */
	  Q: 81,
	  /**
	   * R
	   */
	  R: 82,
	  /**
	   * S
	   */
	  S: 83,
	  /**
	   * T
	   */
	  T: 84,
	  /**
	   * U
	   */
	  U: 85,
	  /**
	   * V
	   */
	  V: 86,
	  /**
	   * W
	   */
	  W: 87,
	  /**
	   * X
	   */
	  X: 88,
	  /**
	   * Y
	   */
	  Y: 89,
	  /**
	   * Z
	   */
	  Z: 90,
	  /**
	   * META
	   */
	  META: 91, // WIN_KEY_LEFT
	  /**
	   * WIN_KEY_RIGHT
	   */
	  WIN_KEY_RIGHT: 92,
	  /**
	   * CONTEXT_MENU
	   */
	  CONTEXT_MENU: 93,
	  /**
	   * NUM_ZERO
	   */
	  NUM_ZERO: 96,
	  /**
	   * NUM_ONE
	   */
	  NUM_ONE: 97,
	  /**
	   * NUM_TWO
	   */
	  NUM_TWO: 98,
	  /**
	   * NUM_THREE
	   */
	  NUM_THREE: 99,
	  /**
	   * NUM_FOUR
	   */
	  NUM_FOUR: 100,
	  /**
	   * NUM_FIVE
	   */
	  NUM_FIVE: 101,
	  /**
	   * NUM_SIX
	   */
	  NUM_SIX: 102,
	  /**
	   * NUM_SEVEN
	   */
	  NUM_SEVEN: 103,
	  /**
	   * NUM_EIGHT
	   */
	  NUM_EIGHT: 104,
	  /**
	   * NUM_NINE
	   */
	  NUM_NINE: 105,
	  /**
	   * NUM_MULTIPLY
	   */
	  NUM_MULTIPLY: 106,
	  /**
	   * NUM_PLUS
	   */
	  NUM_PLUS: 107,
	  /**
	   * NUM_MINUS
	   */
	  NUM_MINUS: 109,
	  /**
	   * NUM_PERIOD
	   */
	  NUM_PERIOD: 110,
	  /**
	   * NUM_DIVISION
	   */
	  NUM_DIVISION: 111,
	  /**
	   * F1
	   */
	  F1: 112,
	  /**
	   * F2
	   */
	  F2: 113,
	  /**
	   * F3
	   */
	  F3: 114,
	  /**
	   * F4
	   */
	  F4: 115,
	  /**
	   * F5
	   */
	  F5: 116,
	  /**
	   * F6
	   */
	  F6: 117,
	  /**
	   * F7
	   */
	  F7: 118,
	  /**
	   * F8
	   */
	  F8: 119,
	  /**
	   * F9
	   */
	  F9: 120,
	  /**
	   * F10
	   */
	  F10: 121,
	  /**
	   * F11
	   */
	  F11: 122,
	  /**
	   * F12
	   */
	  F12: 123,
	  /**
	   * NUMLOCK
	   */
	  NUMLOCK: 144,
	  /**
	   * SEMICOLON
	   */
	  SEMICOLON: 186, // needs localization
	  /**
	   * DASH
	   */
	  DASH: 189, // needs localization
	  /**
	   * EQUALS
	   */
	  EQUALS: 187, // needs localization
	  /**
	   * COMMA
	   */
	  COMMA: 188, // needs localization
	  /**
	   * PERIOD
	   */
	  PERIOD: 190, // needs localization
	  /**
	   * SLASH
	   */
	  SLASH: 191, // needs localization
	  /**
	   * APOSTROPHE
	   */
	  APOSTROPHE: 192, // needs localization
	  /**
	   * SINGLE_QUOTE
	   */
	  SINGLE_QUOTE: 222, // needs localization
	  /**
	   * OPEN_SQUARE_BRACKET
	   */
	  OPEN_SQUARE_BRACKET: 219, // needs localization
	  /**
	   * BACKSLASH
	   */
	  BACKSLASH: 220, // needs localization
	  /**
	   * CLOSE_SQUARE_BRACKET
	   */
	  CLOSE_SQUARE_BRACKET: 221, // needs localization
	  /**
	   * WIN_KEY
	   */
	  WIN_KEY: 224,
	  /**
	   * MAC_FF_META
	   */
	  MAC_FF_META: 224, // Firefox (Gecko) fires this for the meta key instead of 91
	  /**
	   * WIN_IME
	   */
	  WIN_IME: 229
	};

	/*
	 whether text and modified key is entered at the same time.
	 */
	KeyCode.isTextModifyingKeyEvent = function isTextModifyingKeyEvent(e) {
	  var keyCode = e.keyCode;
	  if (e.altKey && !e.ctrlKey || e.metaKey ||
	  // Function keys don't generate text
	  keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) {
	    return false;
	  }

	  // The following keys are quite harmless, even in combination with
	  // CTRL, ALT or SHIFT.
	  switch (keyCode) {
	    case KeyCode.ALT:
	    case KeyCode.CAPS_LOCK:
	    case KeyCode.CONTEXT_MENU:
	    case KeyCode.CTRL:
	    case KeyCode.DOWN:
	    case KeyCode.END:
	    case KeyCode.ESC:
	    case KeyCode.HOME:
	    case KeyCode.INSERT:
	    case KeyCode.LEFT:
	    case KeyCode.MAC_FF_META:
	    case KeyCode.META:
	    case KeyCode.NUMLOCK:
	    case KeyCode.NUM_CENTER:
	    case KeyCode.PAGE_DOWN:
	    case KeyCode.PAGE_UP:
	    case KeyCode.PAUSE:
	    case KeyCode.PRINT_SCREEN:
	    case KeyCode.RIGHT:
	    case KeyCode.SHIFT:
	    case KeyCode.UP:
	    case KeyCode.WIN_KEY:
	    case KeyCode.WIN_KEY_RIGHT:
	      return false;
	    default:
	      return true;
	  }
	};

	/*
	 whether character is entered.
	 */
	KeyCode.isCharacterKey = function isCharacterKey(keyCode) {
	  if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) {
	    return true;
	  }

	  if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) {
	    return true;
	  }

	  if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) {
	    return true;
	  }

	  // Safari sends zero key code for non-latin characters.
	  if (window.navigation.userAgent.indexOf('WebKit') !== -1 && keyCode === 0) {
	    return true;
	  }

	  switch (keyCode) {
	    case KeyCode.SPACE:
	    case KeyCode.QUESTION_MARK:
	    case KeyCode.NUM_PLUS:
	    case KeyCode.NUM_MINUS:
	    case KeyCode.NUM_PERIOD:
	    case KeyCode.NUM_DIVISION:
	    case KeyCode.SEMICOLON:
	    case KeyCode.DASH:
	    case KeyCode.EQUALS:
	    case KeyCode.COMMA:
	    case KeyCode.PERIOD:
	    case KeyCode.SLASH:
	    case KeyCode.APOSTROPHE:
	    case KeyCode.SINGLE_QUOTE:
	    case KeyCode.OPEN_SQUARE_BRACKET:
	    case KeyCode.BACKSLASH:
	    case KeyCode.CLOSE_SQUARE_BRACKET:
	      return true;
	    default:
	      return false;
	  }
	};

		module.exports = KeyCode;

/***/ },
/* 22 */
[752, 23],
/* 23 */
[753, 24],
/* 24 */
[754, 25, 26, 27],
/* 25 */
/***/ function(module, exports) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	/**
	 * lodash 3.9.1 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/** `Object#toString` result references. */
	var funcTag = '[object Function]';

	/** Used to detect host constructors (Safari > 5). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/**
	 * Checks if `value` is object-like.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 */
	function isObjectLike(value) {
	  return !!value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';
	}

	/** Used for native method references. */
	var objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var fnToString = Function.prototype.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' + fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = object == null ? undefined : object[key];
	  return isNative(value) ? value : undefined;
	}

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in older versions of Chrome and Safari which return 'function' for regexes
	  // and Safari 8 equivalents which return 'object' for typed array constructors.
	  return isObject(value) && objToString.call(value) == funcTag;
	}

	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is a native function.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
	 * @example
	 *
	 * _.isNative(Array.prototype.push);
	 * // => true
	 *
	 * _.isNative(_);
	 * // => false
	 */
	function isNative(value) {
	  if (value == null) {
	    return false;
	  }
	  if (isFunction(value)) {
	    return reIsNative.test(fnToString.call(value));
	  }
	  return isObjectLike(value) && reIsHostCtor.test(value);
	}

		module.exports = getNative;

/***/ },
/* 26 */
/***/ function(module, exports) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	/**
	 * lodash 3.0.8 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new function.
	 */
	function baseProperty(key) {
	  return function (object) {
	    return object == null ? undefined : object[key];
	  };
	}

	/**
	 * Gets the "length" property value of `object`.
	 *
	 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
	 * that affects Safari on at least iOS 8.1-8.3 ARM64.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {*} Returns the "length" value.
	 */
	var getLength = baseProperty('length');

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	function isArguments(value) {
	  // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.
	  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
	}

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(getLength(value)) && !isFunction(value);
	}

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object, else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 8 which returns 'object' for typed array and weak map constructors,
	  // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
	  var tag = isObject(value) ? objectToString.call(value) : '';
	  return tag == funcTag || tag == genTag;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This function is loosely based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';
	}

		module.exports = isArguments;

/***/ },
/* 27 */
/***/ function(module, exports) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	/**
	 * lodash 3.0.4 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/** `Object#toString` result references. */
	var arrayTag = '[object Array]',
	    funcTag = '[object Function]';

	/** Used to detect host constructors (Safari > 5). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/**
	 * Checks if `value` is object-like.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 */
	function isObjectLike(value) {
	  return !!value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';
	}

	/** Used for native method references. */
	var objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var fnToString = Function.prototype.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' + fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

	/* Native method references for those with the same name as other `lodash` methods. */
	var nativeIsArray = getNative(Array, 'isArray');

	/**
	 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
	 * of an array-like value.
	 */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = object == null ? undefined : object[key];
	  return isNative(value) ? value : undefined;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 */
	function isLength(value) {
	  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(function() { return arguments; }());
	 * // => false
	 */
	var isArray = nativeIsArray || function (value) {
	  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
	};

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in older versions of Chrome and Safari which return 'function' for regexes
	  // and Safari 8 equivalents which return 'object' for typed array constructors.
	  return isObject(value) && objToString.call(value) == funcTag;
	}

	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is a native function.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
	 * @example
	 *
	 * _.isNative(Array.prototype.push);
	 * // => true
	 *
	 * _.isNative(_);
	 * // => false
	 */
	function isNative(value) {
	  if (value == null) {
	    return false;
	  }
	  if (isFunction(value)) {
	    return reIsNative.test(fnToString.call(value));
	  }
	  return isObjectLike(value) && reIsHostCtor.test(value);
	}

		module.exports = isArray;

/***/ },
/* 28 */
/***/ function(module, exports) {

	/**
	 * Safe chained function
	 *
	 * Will only create a new function if needed,
	 * otherwise will pass back existing functions or null.
	 *
	 * @returns {function|null}
	 */
	"use strict";

	function createChainedFunction() {
	  var args = arguments;
	  return function chainedFunction() {
	    for (var i = 0; i < args.length; i++) {
	      if (args[i] && args[i].apply) {
	        args[i].apply(this, arguments);
	      }
	    }
	  };
	}

		module.exports = createChainedFunction;

/***/ },
/* 29 */
[755, 30],
/* 30 */
[756, 31],
/* 31 */
[757, 32, 33],
/* 32 */
/***/ function(module, exports) {

	/**
	 * @ignore
	 * base event object for custom and dom event.
	 * @author yiminghe@gmail.com
	 */

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	function returnFalse() {
	  return false;
	}

	function returnTrue() {
	  return true;
	}

	function EventBaseObject() {
	  this.timeStamp = Date.now();
	  this.target = undefined;
	  this.currentTarget = undefined;
	}

	EventBaseObject.prototype = {
	  isEventObject: 1,

	  constructor: EventBaseObject,

	  isDefaultPrevented: returnFalse,

	  isPropagationStopped: returnFalse,

	  isImmediatePropagationStopped: returnFalse,

	  preventDefault: function preventDefault() {
	    this.isDefaultPrevented = returnTrue;
	  },

	  stopPropagation: function stopPropagation() {
	    this.isPropagationStopped = returnTrue;
	  },

	  stopImmediatePropagation: function stopImmediatePropagation() {
	    this.isImmediatePropagationStopped = returnTrue;
	    // fixed 1.2
	    // call stopPropagation implicitly
	    this.stopPropagation();
	  },

	  halt: function halt(immediate) {
	    if (immediate) {
	      this.stopImmediatePropagation();
	    } else {
	      this.stopPropagation();
	    }
	    this.preventDefault();
	  }
	};

	exports["default"] = EventBaseObject;
	module.exports = exports["default"];

/***/ },
/* 33 */
/***/ function(module, exports) {

	/* eslint-disable no-unused-vars */
	'use strict';

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	module.exports = Object.assign || function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (Object.getOwnPropertySymbols) {
				symbols = Object.getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
		};

/***/ },
/* 34 */
/***/ function(module, exports) {

	"use strict";

	module.exports = function contains(root, n) {
	  var node = n;
	  while (node) {
	    if (node === root) {
	      return true;
	    }
	    node = node.parentNode;
	  }

	  return false;
		};

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var React = __webpack_require__(3);

	module.exports = function toArray(children) {
	  var ret = [];
	  React.Children.forEach(children, function each(c) {
	    ret.push(c);
	  });
	  return ret;
		};

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var React = __webpack_require__(3);

	function mirror(o) {
	  return o;
	}

	module.exports = function mapSelf(children) {
	  // return ReactFragment
	  return React.Children.map(children, mirror);
		};

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	exports.__esModule = true;

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _DateTHead = __webpack_require__(38);

	var _DateTHead2 = _interopRequireDefault(_DateTHead);

	var _DateTBody = __webpack_require__(40);

	var _DateTBody2 = _interopRequireDefault(_DateTBody);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _possibleConstructorReturn(self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	} // customized rc-calendar https://github.com/react-component/calendar/blob/master/

	var DateTable = function (_React$Component) {
	  _inherits(DateTable, _React$Component);

	  function DateTable() {
	    _classCallCheck(this, DateTable);

	    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
	  }

	  DateTable.prototype.render = function render() {
	    var props = this.props;
	    var prefixCls = props.prefixCls;
	    return _react2["default"].createElement('table', { className: prefixCls + '-table', cellSpacing: '0', role: 'grid' }, _react2["default"].createElement(_DateTHead2["default"], props), _react2["default"].createElement(_DateTBody2["default"], props));
	  };

	  return DateTable;
	}(_react2["default"].Component);

	exports["default"] = DateTable;
	module.exports = exports['default'];

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _DateConstants = __webpack_require__(39);

	var _DateConstants2 = _interopRequireDefault(_DateConstants);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _possibleConstructorReturn(self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var DateTHead = function (_React$Component) {
	  _inherits(DateTHead, _React$Component);

	  function DateTHead() {
	    _classCallCheck(this, DateTHead);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(DateTHead).apply(this, arguments));
	  }

	  _createClass(DateTHead, [{
	    key: 'render',
	    value: function render() {
	      var props = this.props;
	      var value = props.value;
	      var locale = props.locale;
	      var prefixCls = props.prefixCls;
	      var veryShortWeekdays = [];
	      var weekDays = [];
	      var firstDayOfWeek = value.getFirstDayOfWeek();
	      var showWeekNumberEl = undefined;

	      for (var dateColIndex = 0; dateColIndex < _DateConstants2["default"].DATE_COL_COUNT; dateColIndex++) {
	        var index = (firstDayOfWeek + dateColIndex) % _DateConstants2["default"].DATE_COL_COUNT;
	        veryShortWeekdays[dateColIndex] = locale.format.veryShortWeekdays[index];
	        weekDays[dateColIndex] = locale.format.weekdays[index];
	      }

	      if (props.showWeekNumber) {
	        showWeekNumberEl = _react2["default"].createElement('th', {
	          role: 'columnheader',
	          className: prefixCls + '-column-header ' + prefixCls + '-week-number-header'
	        }, _react2["default"].createElement('span', { className: prefixCls + '-column-header-inner' }, 'x'));
	      }
	      var weekDaysEls = weekDays.map(function (day, xindex) {
	        return _react2["default"].createElement('th', {
	          key: xindex,
	          role: 'columnheader',
	          title: day,
	          className: prefixCls + '-column-header'
	        }, _react2["default"].createElement('span', { className: prefixCls + '-column-header-inner' }, veryShortWeekdays[xindex]));
	      });
	      return _react2["default"].createElement('thead', null, _react2["default"].createElement('tr', { role: 'row' }, showWeekNumberEl, weekDaysEls));
	    }
	  }]);

	  return DateTHead;
	}(_react2["default"].Component);

	exports["default"] = DateTHead;
	module.exports = exports['default'];

/***/ },
/* 39 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports["default"] = {
	  DATE_ROW_COUNT: 6,
	  DATE_COL_COUNT: 7
	};
		module.exports = exports['default'];

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _DateConstants = __webpack_require__(39);

	var _DateConstants2 = _interopRequireDefault(_DateConstants);

	var _util = __webpack_require__(41);

	var _classnames2 = __webpack_require__(5);

	var _classnames3 = _interopRequireDefault(_classnames2);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}

	// customized rc-calendar https://github.com/react-component/calendar/blob/master/

	function isSameDay(one, two) {
	  return one && two && one.compareToDay(two) === 0;
	}

	function beforeCurrentMonthYear(current, today) {
	  if (current.getYear() < today.getYear()) {
	    return 1;
	  }
	  return current.getYear() === today.getYear() && current.getMonth() < today.getMonth();
	}

	function afterCurrentMonthYear(current, today) {
	  if (current.getYear() > today.getYear()) {
	    return 1;
	  }
	  return current.getYear() === today.getYear() && current.getMonth() > today.getMonth();
	}

	function getIdFromDate(date) {
	  return 'rc-calendar-' + date.getYear() + '-' + date.getMonth() + '-' + date.getDayOfMonth();
	}

	function noop() {}

	function handleDayClick(current) {
	  this.props.onSelect(current);
	}

	function handleCellMouseEnter(current) {
	  this.props.onDayHover(current);
	}

	var DateTBody = _react2["default"].createClass({
	  displayName: 'DateTBody',

	  propTypes: {
	    contentRender: _react.PropTypes.func,
	    dateRender: _react.PropTypes.func,
	    disabledDate: _react.PropTypes.func,
	    prefixCls: _react.PropTypes.string,
	    selectedValue: _react.PropTypes.object,
	    value: _react.PropTypes.object,
	    showWeekNumber: _react.PropTypes.bool
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      onDayHover: noop
	    };
	  },
	  render: function render() {
	    var props = this.props;
	    var contentRender = props.contentRender;
	    var prefixCls = props.prefixCls;
	    var selectedValue = props.selectedValue;
	    var value = props.value;
	    var showWeekNumber = props.showWeekNumber;
	    var dateRender = props.dateRender;
	    var disabledDate = props.disabledDate;

	    var iIndex = undefined;
	    var jIndex = undefined;
	    var current = undefined;
	    var dateTable = [];
	    var today = value.clone();
	    var cellClass = prefixCls + '-cell';
	    var weekNumberCellClass = prefixCls + '-week-number-cell';
	    var dateClass = prefixCls + '-date';
	    var todayClass = prefixCls + '-today';
	    var selectedClass = prefixCls + '-selected-day';
	    var inRangeClass = prefixCls + '-in-range-cell';
	    var lastMonthDayClass = prefixCls + '-last-month-cell';
	    var nextMonthDayClass = prefixCls + '-next-month-btn-day';
	    var disabledClass = prefixCls + '-disabled-cell';
	    var firstDisableClass = prefixCls + '-disabled-cell-first-of-row';
	    var lastDisableClass = prefixCls + '-disabled-cell-last-of-row';
	    today.setTime(Date.now());
	    var month1 = value.clone();
	    month1.set(value.getYear(), value.getMonth(), 1);
	    var day = month1.getDayOfWeek();
	    var lastMonthDiffDay = (day + 7 - value.getFirstDayOfWeek()) % 7;
	    // calculate last month
	    var lastMonth1 = month1.clone();
	    lastMonth1.addDayOfMonth(0 - lastMonthDiffDay);
	    var passed = 0;
	    for (iIndex = 0; iIndex < _DateConstants2["default"].DATE_ROW_COUNT; iIndex++) {
	      for (jIndex = 0; jIndex < _DateConstants2["default"].DATE_COL_COUNT; jIndex++) {
	        current = lastMonth1;
	        if (passed) {
	          current = current.clone();
	          current.addDayOfMonth(passed);
	        }
	        dateTable.push(current);
	        passed++;
	      }
	    }
	    var tableHtml = [];
	    passed = 0;
	    for (iIndex = 0; iIndex < _DateConstants2["default"].DATE_ROW_COUNT; iIndex++) {
	      var weekNumberCell = undefined;
	      var dateCells = [];
	      if (showWeekNumber) {
	        weekNumberCell = _react2["default"].createElement('td', {
	          key: dateTable[passed].getWeekOfYear(),
	          role: 'gridcell',
	          className: weekNumberCellClass
	        }, dateTable[passed].getWeekOfYear());
	      }
	      for (jIndex = 0; jIndex < _DateConstants2["default"].DATE_COL_COUNT; jIndex++) {
	        var next = null;
	        var last = null;
	        current = dateTable[passed];
	        if (jIndex < _DateConstants2["default"].DATE_COL_COUNT - 1) {
	          next = dateTable[passed + 1];
	        }
	        if (jIndex > 0) {
	          last = dateTable[passed - 1];
	        }
	        var cls = cellClass;
	        var disabled = false;
	        var selected = false;

	        if (isSameDay(current, today)) {
	          cls += ' ' + todayClass;
	        }

	        var isBeforeCurrentMonthYear = beforeCurrentMonthYear(current, value);
	        var isAfterCurrentMonthYear = afterCurrentMonthYear(current, value);

	        if (selectedValue && Array.isArray(selectedValue)) {
	          if (!isBeforeCurrentMonthYear && !isAfterCurrentMonthYear) {
	            var startValue = selectedValue[0];
	            var endValue = selectedValue[1];
	            if (startValue) {
	              if (isSameDay(current, startValue)) {
	                selected = true;
	              }
	            }
	            if (startValue && endValue) {
	              if (isSameDay(current, endValue) && !selectedValue.hovering) {
	                selected = true;
	              } else if (current.compareToDay(startValue) > 0 && current.compareToDay(endValue) < 0) {
	                cls += ' ' + inRangeClass;
	              }
	            }
	          }
	        } else if (isSameDay(current, selectedValue)) {
	          selected = true;
	        }
	        if (isBeforeCurrentMonthYear) {
	          cls += ' ' + lastMonthDayClass;
	        }
	        if (isAfterCurrentMonthYear) {
	          cls += ' ' + nextMonthDayClass;
	        }

	        if (disabledDate) {
	          if (disabledDate(current, value)) {
	            disabled = true;

	            if (!last || !disabledDate(last, value)) {
	              cls += ' ' + firstDisableClass;
	            }

	            if (!next || !disabledDate(next, value)) {
	              cls += ' ' + lastDisableClass;
	            }
	          }
	        }

	        if (selected) {
	          cls += ' ' + selectedClass;
	        }

	        if (disabled) {
	          cls += ' ' + disabledClass;
	        }

	        var dateHtml = undefined;
	        if (dateRender) {
	          dateHtml = dateRender(current, value);
	        } else {
	          var _classnames;

	          var content = contentRender ? contentRender(current, value) : current.getDayOfMonth();
	          var dayOfWeek = current.getDayOfWeek();
	          dateHtml = _react2["default"].createElement('div', {
	            key: getIdFromDate(current),
	            className: (0, _classnames3["default"])((_classnames = {}, _classnames[dateClass] = true, _classnames.weekend = dayOfWeek == 0 || dayOfWeek == 6, _classnames)),
	            'aria-selected': selected,
	            'aria-disabled': disabled
	          }, content);
	        }

	        dateCells.push(_react2["default"].createElement('td', {
	          key: passed,
	          onClick: disabled ? noop : handleDayClick.bind(this, current),
	          onMouseEnter: disabled ? noop : handleCellMouseEnter.bind(this, current),
	          role: 'gridcell',
	          title: (0, _util.getTitleString)(current), className: cls
	        }, dateHtml));

	        passed++;
	      }
	      tableHtml.push(_react2["default"].createElement('tr', {
	        key: iIndex,
	        role: 'row'
	      }, weekNumberCell, dateCells));
	    }
	    return _react2["default"].createElement('tbody', { className: prefixCls + 'tbody' }, tableHtml);
	  }
	});

	exports["default"] = DateTBody;
	module.exports = exports['default'];

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};

	exports.getTodayTime = getTodayTime;
	exports.getTitleString = getTitleString;
	exports.getTodayTimeStr = getTodayTimeStr;
	exports.getFormatter = getFormatter;
	exports.syncTime = syncTime;
	exports.getTimeConfig = getTimeConfig;
	exports.isTimeValidByConfig = isTimeValidByConfig;
	exports.isTimeValid = isTimeValid;
	exports.isAllowedDate = isAllowedDate;

	var _gregorianCalendarFormat = __webpack_require__(42);

	var _gregorianCalendarFormat2 = _interopRequireDefault(_gregorianCalendarFormat);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}

	var defaultDisabledTime = {
	  disabledHours: function disabledHours() {
	    return [];
	  },
	  disabledMinutes: function disabledMinutes() {
	    return [];
	  },
	  disabledSeconds: function disabledSeconds() {
	    return [];
	  }
	};

	function getTodayTime(value) {
	  var today = value.clone();
	  today.setTime(Date.now());
	  return today;
	}

	function getTitleString(value) {
	  return value.getYear() + '-' + (value.getMonth() + 1) + '-' + value.getDayOfMonth();
	}

	function getTodayTimeStr(value) {
	  var today = getTodayTime(value);
	  return getTitleString(today);
	}

	function getFormatter(format, locale) {
	  if (typeof format === 'string') {
	    return new _gregorianCalendarFormat2["default"](format, locale.format);
	  }
	  return format;
	}

	function syncTime(from, to) {
	  to.setHourOfDay(from.getHourOfDay());
	  to.setMinutes(from.getMinutes());
	  to.setSeconds(from.getSeconds());
	}

	function getTimeConfig(value, disabledTime) {
	  var disabledTimeConfig = disabledTime ? disabledTime(value) : {};
	  disabledTimeConfig = _extends({}, defaultDisabledTime, disabledTimeConfig);
	  return disabledTimeConfig;
	}

	function isTimeValidByConfig(value, disabledTimeConfig) {
	  var invalidTime = false;
	  if (value) {
	    var hour = value.getHourOfDay();
	    var minutes = value.getMinutes();
	    var seconds = value.getSeconds();
	    var disabledHours = disabledTimeConfig.disabledHours();
	    if (disabledHours.indexOf(hour) === -1) {
	      var disabledMinutes = disabledTimeConfig.disabledMinutes(hour);
	      if (disabledMinutes.indexOf(minutes) === -1) {
	        var disabledSeconds = disabledTimeConfig.disabledSeconds(hour, minutes);
	        invalidTime = disabledSeconds.indexOf(seconds) !== -1;
	      } else {
	        invalidTime = true;
	      }
	    } else {
	      invalidTime = true;
	    }
	  }
	  return !invalidTime;
	}

	function isTimeValid(value, disabledTime) {
	  var disabledTimeConfig = getTimeConfig(value, disabledTime);
	  return isTimeValidByConfig(value, disabledTimeConfig);
	}

	function isAllowedDate(value, disabledDate, disabledTime) {
	  if (disabledDate) {
	    if (disabledDate(value)) {
	      return false;
	    }
	  }
	  if (disabledTime) {
	    if (!isTimeValid(value, disabledTime)) {
	      return false;
	    }
	  }
	  return true;
		}

/***/ },
/* 42 */
[758, 12, 43, 44],
/* 43 */
/***/ function(module, exports) {

	'use strict';

	module.exports = {
	  eras: ['BC', 'AD'],
	  months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
	  shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
	  weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
	  shortWeekdays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
	  veryShortWeekdays: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
	  ampms: ['AM', 'PM'],
	  datePatterns: ['EEEE, MMMM d, yyyy', 'MMMM d, yyyy', 'MMM d, yyyy', 'M/d/yy'],
	  timePatterns: ['h:mm:ss a \'GMT\'Z', 'h:mm:ss a', 'h:mm:ss a', 'h:mm a'],
	  dateTimePattern: '{date} {time}'
		};

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */

	'use strict';

	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */

	var warning = function warning() {};

	if (process.env.NODE_ENV !== 'production') {
	  warning = function warning(condition, format, args) {
	    var len = arguments.length;
	    args = new Array(len > 2 ? len - 2 : 0);
	    for (var key = 2; key < len; key++) {
	      args[key - 2] = arguments[key];
	    }
	    if (format === undefined) {
	      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }

	    if (format.length < 10 || /^[s\W]*$/.test(format)) {
	      throw new Error('The warning format should be able to uniquely identify this ' + 'warning. Please, use a more descriptive format than: ' + format);
	    }

	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    }
	  };
	}

		module.exports = warning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(45)))

/***/ },
/* 45 */
/***/ function(module, exports) {

	// shim for using process in browser

	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _MonthPanel = __webpack_require__(47);

	var _MonthPanel2 = _interopRequireDefault(_MonthPanel);

	var _index = __webpack_require__(41);

	var _YearPanel = __webpack_require__(48);

	var _YearPanel2 = _interopRequireDefault(_YearPanel);

	var _rcUtil = __webpack_require__(16);

	var _rcUtil2 = _interopRequireDefault(_rcUtil);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}

	var toFragment = _rcUtil2["default"].Children.mapSelf;

	function goMonth(direction) {
	  var next = this.props.value.clone();
	  next.addMonth(direction);
	  this.props.onValueChange(next);
	}

	function goYear(direction) {
	  var next = this.props.value.clone();
	  next.addYear(direction);
	  this.props.onValueChange(next);
	}

	var CalendarHeader = _react2["default"].createClass({
	  displayName: 'CalendarHeader',

	  propTypes: {
	    enablePrev: _react.PropTypes.any,
	    enableNext: _react.PropTypes.any,
	    prefixCls: _react.PropTypes.string,
	    locale: _react.PropTypes.object,
	    value: _react.PropTypes.object,
	    onValueChange: _react.PropTypes.func
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      enableNext: 1,
	      enablePrev: 1
	    };
	  },
	  getInitialState: function getInitialState() {
	    var props = this.props;
	    this.yearFormatter = (0, _index.getFormatter)(props.locale.yearFormat, props.locale);
	    this.monthFormatter = (0, _index.getFormatter)(props.locale.monthFormat, props.locale);
	    this.nextMonth = goMonth.bind(this, 1);
	    this.previousMonth = goMonth.bind(this, -1);
	    this.nextYear = goYear.bind(this, 1);
	    this.previousYear = goYear.bind(this, -1);
	    return {};
	  },
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    var locale = this.props.locale;
	    var nextLocale = nextProps.locale;

	    if (nextLocale !== locale) {
	      this.yearFormatter = (0, _index.getFormatter)(nextLocale.yearFormat, nextLocale);
	      this.monthFormatter = (0, _index.getFormatter)(nextLocale.monthFormat, nextLocale);
	    }
	  },
	  onSelect: function onSelect(value) {
	    this.setState({
	      showMonthPanel: 0,
	      showYearPanel: 0
	    });
	    this.props.onValueChange(value);
	  },
	  getMonthYearElement: function getMonthYearElement() {
	    var props = this.props;
	    var prefixCls = props.prefixCls;
	    var locale = props.locale;
	    var value = this.props.value;
	    var monthBeforeYear = locale.monthBeforeYear;
	    var selectClassName = prefixCls + '-' + (monthBeforeYear ? 'my-select' : 'ym-select');
	    var year = _react2["default"].createElement('a', {
	      className: prefixCls + '-year-select',
	      role: 'button',
	      onClick: this.showYearPanel,
	      title: locale.monthSelect
	    }, this.yearFormatter.format(value));
	    var month = _react2["default"].createElement('a', {
	      className: prefixCls + '-month-select',
	      role: 'button',
	      onClick: this.showMonthPanel,
	      title: locale.monthSelect
	    }, this.monthFormatter.format(value));
	    var my = [];
	    if (monthBeforeYear) {
	      my = [month, year];
	    } else {
	      my = [year, month];
	    }
	    return _react2["default"].createElement('span', { className: selectClassName }, toFragment(my));
	  },
	  showIf: function showIf(condition, el) {
	    return condition ? el : null;
	  },
	  showMonthPanel: function showMonthPanel() {
	    this.setState({
	      showMonthPanel: 1,
	      showYearPanel: 0
	    });
	  },
	  showYearPanel: function showYearPanel() {
	    this.setState({
	      showMonthPanel: 0,
	      showYearPanel: 1
	    });
	  },
	  render: function render() {
	    var props = this.props;
	    var enableNext = props.enableNext;
	    var enablePrev = props.enablePrev;
	    var prefixCls = props.prefixCls;
	    var locale = props.locale;
	    var value = props.value;

	    var state = this.state;
	    var PanelClass = null;
	    if (state.showMonthPanel) {
	      PanelClass = _MonthPanel2["default"];
	    } else if (state.showYearPanel) {
	      PanelClass = _YearPanel2["default"];
	    }
	    var panel = undefined;
	    if (PanelClass) {
	      panel = _react2["default"].createElement(PanelClass, {
	        locale: locale,
	        defaultValue: value,
	        rootPrefixCls: prefixCls,
	        onSelect: this.onSelect
	      });
	    }
	    return _react2["default"].createElement('div', { className: prefixCls + '-header' }, _react2["default"].createElement('div', { style: { position: 'relative' } }, this.showIf(enablePrev, _react2["default"].createElement('a', {
	      className: prefixCls + '-prev-year-btn',
	      role: 'button',
	      onClick: this.previousYear,
	      title: locale.previousYear
	    }, '«')), this.showIf(enablePrev, _react2["default"].createElement('a', {
	      className: prefixCls + '-prev-month-btn',
	      role: 'button',
	      onClick: this.previousMonth,
	      title: locale.previousMonth
	    }, '‹')), this.getMonthYearElement(), this.showIf(enableNext, _react2["default"].createElement('a', {
	      className: prefixCls + '-next-month-btn',
	      onClick: this.nextMonth,
	      title: locale.nextMonth
	    }, '›')), this.showIf(enableNext, _react2["default"].createElement('a', {
	      className: prefixCls + '-next-year-btn',
	      onClick: this.nextYear,
	      title: locale.nextYear
	    }, '»'))), panel);
	  }
	});

	exports["default"] = CalendarHeader;
	module.exports = exports['default'];

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _YearPanel = __webpack_require__(48);

	var _YearPanel2 = _interopRequireDefault(_YearPanel);

	var _MonthTable = __webpack_require__(50);

	var _MonthTable2 = _interopRequireDefault(_MonthTable);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}

	function goYear(direction) {
	  var next = this.state.value.clone();
	  next.addYear(direction);
	  this.setAndChangeValue(next);
	}

	function noop() {}

	var MonthPanel = _react2["default"].createClass({
	  displayName: 'MonthPanel',

	  propTypes: {
	    onChange: _react.PropTypes.func,
	    disabledDate: _react.PropTypes.func,
	    onSelect: _react.PropTypes.func
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      onChange: noop,
	      onSelect: noop
	    };
	  },
	  getInitialState: function getInitialState() {
	    var props = this.props;
	    // bind methods
	    this.nextYear = goYear.bind(this, 1);
	    this.previousYear = goYear.bind(this, -1);
	    this.prefixCls = props.rootPrefixCls + '-month-panel';
	    return {
	      value: props.value || props.defaultValue
	    };
	  },
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    if ('value' in nextProps) {
	      this.setState({
	        value: nextProps.value
	      });
	    }
	  },
	  onYearPanelSelect: function onYearPanelSelect(current) {
	    this.setState({
	      showYearPanel: 0
	    });
	    this.setAndChangeValue(current);
	  },
	  setAndChangeValue: function setAndChangeValue(value) {
	    this.setValue(value);
	    this.props.onChange(value);
	  },
	  setAndSelectValue: function setAndSelectValue(value) {
	    this.setValue(value);
	    this.props.onSelect(value);
	  },
	  setValue: function setValue(value) {
	    if (!('value' in this.props)) {
	      this.setState({
	        value: value
	      });
	    }
	  },
	  showYearPanel: function showYearPanel() {
	    this.setState({
	      showYearPanel: 1
	    });
	  },
	  render: function render() {
	    var props = this.props;
	    var value = this.state.value;
	    var locale = props.locale;
	    var year = value.getYear();
	    var prefixCls = this.prefixCls;
	    var yearPanel = undefined;
	    if (this.state.showYearPanel) {
	      yearPanel = _react2["default"].createElement(_YearPanel2["default"], {
	        locale: locale,
	        value: value,
	        rootPrefixCls: props.rootPrefixCls,
	        onSelect: this.onYearPanelSelect
	      });
	    }
	    return _react2["default"].createElement('div', { className: prefixCls, style: props.style }, _react2["default"].createElement('div', null, _react2["default"].createElement('div', { className: prefixCls + '-header' }, _react2["default"].createElement('a', {
	      className: prefixCls + '-prev-year-btn',
	      role: 'button',
	      onClick: this.previousYear,
	      title: locale.previousYear
	    }, '«'), _react2["default"].createElement('a', {
	      className: prefixCls + '-year-select',
	      role: 'button',
	      onClick: this.showYearPanel,
	      title: locale.yearSelect
	    }, _react2["default"].createElement('span', { className: prefixCls + '-year-select-content' }, year), _react2["default"].createElement('span', { className: prefixCls + '-year-select-arrow' }, 'x')), _react2["default"].createElement('a', {
	      className: prefixCls + '-next-year-btn',
	      role: 'button',
	      onClick: this.nextYear,
	      title: locale.nextYear
	    }, '»')), _react2["default"].createElement('div', { className: prefixCls + '-body' }, _react2["default"].createElement(_MonthTable2["default"], {
	      disabledDate: props.disabledDate,
	      onSelect: this.setAndSelectValue,
	      locale: locale,
	      value: value,
	      prefixCls: prefixCls
	    }))), yearPanel);
	  }
	});

	exports["default"] = MonthPanel;
	module.exports = exports['default'];

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _classnames = __webpack_require__(5);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _DecadePanel = __webpack_require__(49);

	var _DecadePanel2 = _interopRequireDefault(_DecadePanel);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	  } else {
	    obj[key] = value;
	  }return obj;
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _possibleConstructorReturn(self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var ROW = 4;
	var COL = 3;

	function goYear(direction) {
	  var value = this.state.value.clone();
	  value.addYear(direction);
	  this.setState({
	    value: value
	  });
	}

	function chooseYear(year) {
	  var value = this.state.value.clone();
	  value.setYear(year);
	  value.rollSetMonth(this.state.value.getMonth());
	  this.props.onSelect(value);
	}

	var YearPanel = function (_React$Component) {
	  _inherits(YearPanel, _React$Component);

	  function YearPanel(props) {
	    _classCallCheck(this, YearPanel);

	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(YearPanel).call(this, props));

	    _this.prefixCls = props.rootPrefixCls + '-year-panel';
	    _this.state = {
	      value: props.value || props.defaultValue
	    };
	    _this.nextDecade = goYear.bind(_this, 10);
	    _this.previousDecade = goYear.bind(_this, -10);
	    ['showDecadePanel', 'onDecadePanelSelect'].forEach(function (method) {
	      _this[method] = _this[method].bind(_this);
	    });
	    return _this;
	  }

	  _createClass(YearPanel, [{
	    key: 'onDecadePanelSelect',
	    value: function onDecadePanelSelect(current) {
	      this.setState({
	        value: current,
	        showDecadePanel: 0
	      });
	    }
	  }, {
	    key: 'getYears',
	    value: function getYears() {
	      var value = this.state.value;
	      var currentYear = value.getYear();
	      var startYear = parseInt(currentYear / 10, 10) * 10;
	      var previousYear = startYear - 1;
	      var endYear = startYear + 9;
	      var years = [];
	      var index = 0;
	      for (var rowIndex = 0; rowIndex < ROW; rowIndex++) {
	        years[rowIndex] = [];
	        for (var colIndex = 0; colIndex < COL; colIndex++) {
	          var year = previousYear + index;
	          var content = undefined;
	          if (year < startYear) {
	            content = '';
	          } else if (year > endYear) {
	            content = '';
	          } else {
	            content = String(year);
	          }
	          years[rowIndex][colIndex] = {
	            content: content,
	            year: year,
	            title: content
	          };
	          index++;
	        }
	      }
	      return years;
	    }
	  }, {
	    key: 'showDecadePanel',
	    value: function showDecadePanel() {
	      this.setState({
	        showDecadePanel: 1
	      });
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this2 = this;

	      var props = this.props;
	      var value = this.state.value;
	      var locale = props.locale;
	      var years = this.getYears();
	      var currentYear = value.getYear();
	      var startYear = parseInt(currentYear / 10, 10) * 10;
	      var endYear = startYear + 9;
	      var prefixCls = this.prefixCls;

	      var yeasEls = years.map(function (row, index) {
	        var tds = row.map(function (yearData) {
	          var _classNameMap;

	          var classNameMap = (_classNameMap = {}, _defineProperty(_classNameMap, prefixCls + '-cell', 1), _defineProperty(_classNameMap, prefixCls + '-selected-cell', yearData.year === currentYear), _defineProperty(_classNameMap, prefixCls + '-last-decade-cell', yearData.year < startYear), _defineProperty(_classNameMap, prefixCls + '-next-decade-cell', yearData.year > endYear), _classNameMap);
	          var clickHandler = undefined;
	          if (yearData.year < startYear) {
	            clickHandler = _this2.previousDecade;
	          } else if (yearData.year > endYear) {
	            clickHandler = _this2.nextDecade;
	          } else {
	            clickHandler = chooseYear.bind(_this2, yearData.year);
	          }
	          return _react2["default"].createElement('td', {
	            role: 'gridcell',
	            title: yearData.title,
	            key: yearData.content,
	            onClick: clickHandler,
	            className: (0, _classnames2["default"])(classNameMap)
	          }, _react2["default"].createElement('a', {
	            className: prefixCls + '-year'
	          }, yearData.content));
	        });
	        return _react2["default"].createElement('tr', { key: index, role: 'row' }, tds);
	      });

	      var decadePanel = undefined;
	      if (this.state.showDecadePanel) {
	        decadePanel = _react2["default"].createElement(_DecadePanel2["default"], {
	          locale: locale,
	          value: value,
	          rootPrefixCls: props.rootPrefixCls,
	          onSelect: this.onDecadePanelSelect
	        });
	      }

	      return _react2["default"].createElement('div', { className: this.prefixCls }, _react2["default"].createElement('div', null, _react2["default"].createElement('div', { className: prefixCls + '-header' }, _react2["default"].createElement('a', {
	        className: prefixCls + '-prev-decade-btn',
	        role: 'button',
	        onClick: this.previousDecade,
	        title: locale.previousDecade
	      }, '«'), _react2["default"].createElement('a', {
	        className: prefixCls + '-decade-select',
	        role: 'button',
	        onClick: this.showDecadePanel,
	        title: locale.decadeSelect
	      }, _react2["default"].createElement('span', { className: prefixCls + '-decade-select-content' }, startYear, '-', endYear), _react2["default"].createElement('span', { className: prefixCls + '-decade-select-arrow' }, 'x')), _react2["default"].createElement('a', {
	        className: prefixCls + '-next-decade-btn',
	        role: 'button',
	        onClick: this.nextDecade,
	        title: locale.nextDecade
	      }, '»')), _react2["default"].createElement('div', { className: prefixCls + '-body' }, _react2["default"].createElement('table', { className: prefixCls + '-table', cellSpacing: '0', role: 'grid' }, _react2["default"].createElement('tbody', { className: prefixCls + '-tbody' }, yeasEls)))), decadePanel);
	    }
	  }]);

	  return YearPanel;
	}(_react2["default"].Component);

	exports["default"] = YearPanel;

	YearPanel.propTypes = {
	  rootPrefixCls: _react.PropTypes.string,
	  value: _react.PropTypes.object,
	  defaultValue: _react.PropTypes.object
	};

	YearPanel.defaultProps = {
	  onSelect: function onSelect() {}
	};
		module.exports = exports['default'];

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _classnames = __webpack_require__(5);

	var _classnames2 = _interopRequireDefault(_classnames);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	  } else {
	    obj[key] = value;
	  }return obj;
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _possibleConstructorReturn(self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var ROW = 4;
	var COL = 3;

	function goYear(direction) {
	  var next = this.state.value.clone();
	  next.addYear(direction);
	  this.setState({
	    value: next
	  });
	}

	function chooseDecade(year, event) {
	  var next = this.state.value.clone();
	  next.setYear(year);
	  next.rollSetMonth(this.state.value.getMonth());
	  this.props.onSelect(next);
	  event.preventDefault();
	}

	var DecadePanel = function (_React$Component) {
	  _inherits(DecadePanel, _React$Component);

	  function DecadePanel(props) {
	    _classCallCheck(this, DecadePanel);

	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(DecadePanel).call(this, props));

	    _this.state = {
	      value: props.value || props.defaultValue
	    };

	    // bind methods
	    _this.prefixCls = props.rootPrefixCls + '-decade-panel';
	    _this.nextCentury = goYear.bind(_this, 100);
	    _this.previousCentury = goYear.bind(_this, -100);
	    return _this;
	  }

	  _createClass(DecadePanel, [{
	    key: 'render',
	    value: function render() {
	      var _this2 = this;

	      var value = this.state.value;
	      var locale = this.props.locale;
	      var currentYear = value.getYear();
	      var startYear = parseInt(currentYear / 100, 10) * 100;
	      var preYear = startYear - 10;
	      var endYear = startYear + 99;
	      var decades = [];
	      var index = 0;
	      var prefixCls = this.prefixCls;

	      for (var rowIndex = 0; rowIndex < ROW; rowIndex++) {
	        decades[rowIndex] = [];
	        for (var colIndex = 0; colIndex < COL; colIndex++) {
	          var startDecade = preYear + index * 10;
	          var endDecade = preYear + index * 10 + 9;
	          decades[rowIndex][colIndex] = {
	            startDecade: startDecade,
	            endDecade: endDecade
	          };
	          index++;
	        }
	      }

	      var decadesEls = decades.map(function (row, decadeIndex) {
	        var tds = row.map(function (decadeData) {
	          var _classNameMap;

	          var dStartDecade = decadeData.startDecade;
	          var dEndDecade = decadeData.endDecade;
	          var isLast = dStartDecade < startYear;
	          var isNext = dEndDecade > endYear;
	          var classNameMap = (_classNameMap = {}, _defineProperty(_classNameMap, prefixCls + '-cell', 1), _defineProperty(_classNameMap, prefixCls + '-selected-cell', dStartDecade <= currentYear && currentYear <= dEndDecade), _defineProperty(_classNameMap, prefixCls + '-last-century-cell', isLast), _defineProperty(_classNameMap, prefixCls + '-next-century-cell', isNext), _classNameMap);
	          var content = undefined;
	          var clickHandler = undefined;
	          if (isLast) {
	            clickHandler = _this2.previousCentury;
	          } else if (isNext) {
	            clickHandler = _this2.nextCentury;
	          } else {
	            content = dStartDecade + '-' + dEndDecade;
	            clickHandler = chooseDecade.bind(_this2, dStartDecade);
	          }
	          return _react2["default"].createElement('td', {
	            key: dStartDecade,
	            onClick: clickHandler,
	            role: 'gridcell',
	            className: (0, _classnames2["default"])(classNameMap)
	          }, _react2["default"].createElement('a', {
	            className: prefixCls + '-decade'
	          }, content));
	        });
	        return _react2["default"].createElement('tr', { key: decadeIndex, role: 'row' }, tds);
	      });

	      return _react2["default"].createElement('div', { className: this.prefixCls }, _react2["default"].createElement('div', { className: prefixCls + '-header' }, _react2["default"].createElement('a', {
	        className: prefixCls + '-prev-century-btn',
	        role: 'button',
	        onClick: this.previousCentury,
	        title: locale.previousCentury
	      }, '«'), _react2["default"].createElement('div', { className: prefixCls + '-century' }, startYear, '-', endYear), _react2["default"].createElement('a', {
	        className: prefixCls + '-next-century-btn',
	        role: 'button',
	        onClick: this.nextCentury,
	        title: locale.nextCentury
	      }, '»')), _react2["default"].createElement('div', { className: prefixCls + '-body' }, _react2["default"].createElement('table', { className: prefixCls + '-table', cellSpacing: '0', role: 'grid' }, _react2["default"].createElement('tbody', { className: prefixCls + '-tbody' }, decadesEls))));
	    }
	  }]);

	  return DecadePanel;
	}(_react2["default"].Component);

	exports["default"] = DecadePanel;

	DecadePanel.propTypes = {
	  locale: _react.PropTypes.object,
	  value: _react.PropTypes.object,
	  defaultValue: _react.PropTypes.object,
	  rootPrefixCls: _react.PropTypes.string
	};

	DecadePanel.defaultProps = {
	  onSelect: function onSelect() {}
	};
		module.exports = exports['default'];

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _classnames = __webpack_require__(5);

	var _classnames2 = _interopRequireDefault(_classnames);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	  } else {
	    obj[key] = value;
	  }return obj;
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _possibleConstructorReturn(self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var ROW = 4;
	var COL = 3;

	function chooseMonth(month) {
	  var next = this.state.value.clone();
	  next.rollSetMonth(month);
	  this.setAndSelectValue(next);
	}

	function noop() {}

	var MonthTable = function (_Component) {
	  _inherits(MonthTable, _Component);

	  function MonthTable(props) {
	    _classCallCheck(this, MonthTable);

	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(MonthTable).call(this, props));

	    _this.state = {
	      value: props.value
	    };
	    return _this;
	  }

	  _createClass(MonthTable, [{
	    key: 'componentWillReceiveProps',
	    value: function componentWillReceiveProps(nextProps) {
	      if ('value' in nextProps) {
	        this.setState({
	          value: nextProps.value
	        });
	      }
	    }
	  }, {
	    key: 'getMonths',
	    value: function getMonths() {
	      var props = this.props;
	      var value = this.state.value;
	      var current = value.clone();
	      var locale = props.locale;
	      var months = [];
	      var shortMonths = locale.format.shortMonths;
	      var index = 0;
	      for (var rowIndex = 0; rowIndex < ROW; rowIndex++) {
	        months[rowIndex] = [];
	        for (var colIndex = 0; colIndex < COL; colIndex++) {
	          current.rollSetMonth(index);
	          months[rowIndex][colIndex] = {
	            value: index,
	            content: shortMonths[index],
	            title: shortMonths[index]
	          };
	          index++;
	        }
	      }
	      return months;
	    }
	  }, {
	    key: 'setAndSelectValue',
	    value: function setAndSelectValue(value) {
	      this.setState({
	        value: value
	      });
	      this.props.onSelect(value);
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this2 = this;

	      var props = this.props;
	      var value = this.state.value;
	      var today = value.clone();
	      today.setTime(Date.now());
	      var months = this.getMonths();
	      var currentMonth = value.getMonth();
	      var prefixCls = props.prefixCls;
	      var locale = props.locale;
	      var contentRender = props.contentRender;
	      var cellRender = props.cellRender;

	      var monthsEls = months.map(function (month, index) {
	        var tds = month.map(function (monthData) {
	          var _classNameMap;

	          var disabled = false;
	          if (props.disabledDate) {
	            var testValue = value.clone();
	            testValue.rollSetMonth(monthData.value);
	            disabled = props.disabledDate(testValue);
	          }
	          var classNameMap = (_classNameMap = {}, _defineProperty(_classNameMap, prefixCls + '-cell', 1), _defineProperty(_classNameMap, prefixCls + '-cell-disabled', disabled), _defineProperty(_classNameMap, prefixCls + '-selected-cell', monthData.value === currentMonth), _defineProperty(_classNameMap, prefixCls + '-current-cell', today.getYear() === value.getYear() && monthData.value === today.getMonth()), _classNameMap);
	          var cellEl = undefined;
	          if (cellRender) {
	            var currentValue = value.clone();
	            currentValue.rollSetMonth(monthData.value);
	            cellEl = cellRender(currentValue, locale);
	          } else {
	            var content = undefined;
	            if (contentRender) {
	              var _currentValue = value.clone();
	              _currentValue.rollSetMonth(monthData.value);
	              content = contentRender(_currentValue, locale);
	            } else {
	              content = monthData.content;
	            }
	            cellEl = _react2["default"].createElement('div', { className: prefixCls + '-month' }, content);
	          }
	          return _react2["default"].createElement('td', {
	            role: 'gridcell',
	            key: monthData.value,
	            onClick: disabled ? null : chooseMonth.bind(_this2, monthData.value),
	            title: monthData.title,
	            className: (0, _classnames2["default"])(classNameMap)
	          }, cellEl);
	        });
	        return _react2["default"].createElement('tr', { key: index, role: 'row' }, tds);
	      });

	      return _react2["default"].createElement('table', { className: prefixCls + '-table', cellSpacing: '0', role: 'grid' }, _react2["default"].createElement('tbody', { className: prefixCls + '-tbody' }, monthsEls));
	    }
	  }]);

	  return MonthTable;
	}(_react.Component);

	MonthTable.defaultProps = {
	  onSelect: noop
	};
	MonthTable.propTypes = {
	  onSelect: _react.PropTypes.func,
	  cellRender: _react.PropTypes.func,
	  prefixCls: _react.PropTypes.string,
	  value: _react.PropTypes.object
	};
	exports["default"] = MonthTable;
	module.exports = exports['default'];

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(4);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _rcUtil = __webpack_require__(16);

	var _rcUtil2 = _interopRequireDefault(_rcUtil);

	var _TodayButton = __webpack_require__(52);

	var _TodayButton2 = _interopRequireDefault(_TodayButton);

	var _OkButton = __webpack_require__(53);

	var _OkButton2 = _interopRequireDefault(_OkButton);

	var _index = __webpack_require__(41);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}

	var toFragment = _rcUtil2["default"].Children.mapSelf;

	var CalendarFooter = _react2["default"].createClass({
	  displayName: 'CalendarFooter',

	  propTypes: {
	    prefixCls: _react.PropTypes.string,
	    showDateInput: _react.PropTypes.bool,
	    disabledTime: _react.PropTypes.any,
	    gregorianCalendarLocale: _react.PropTypes.object,
	    selectedValue: _react.PropTypes.any,
	    showOk: _react.PropTypes.bool,
	    onSelect: _react.PropTypes.func,
	    value: _react.PropTypes.object,
	    defaultValue: _react.PropTypes.object
	  },

	  onSelect: function onSelect(value) {
	    this.props.onSelect(value);
	  },
	  getRootDOMNode: function getRootDOMNode() {
	    return _reactDom2["default"].findDOMNode(this);
	  },
	  render: function render() {
	    var props = this.props;
	    var value = props.value;
	    var prefixCls = props.prefixCls;
	    var showDateInput = props.showDateInput;
	    var disabledTime = props.disabledTime;
	    var gregorianCalendarLocale = props.gregorianCalendarLocale;
	    var selectedValue = props.selectedValue;
	    var showOk = props.showOk;

	    var timePicker = !showDateInput && props.timePicker || null;
	    var disabledTimeConfig = disabledTime && timePicker ? (0, _index.getTimeConfig)(selectedValue, disabledTime) : null;
	    var footerEl = null;
	    if (props.showToday || timePicker) {
	      var nowEl = undefined;
	      if (props.showToday) {
	        nowEl = _react2["default"].createElement(_TodayButton2["default"], _extends({}, props, { value: value }));
	      }
	      var okBtn = undefined;
	      if (showOk === true || showOk !== false && !!props.timePicker) {
	        okBtn = _react2["default"].createElement(_OkButton2["default"], props);
	      }
	      var footerBtn = undefined;
	      if (nowEl || okBtn) {
	        footerBtn = _react2["default"].createElement('span', { className: prefixCls + '-footer-btn' }, toFragment([nowEl, okBtn]));
	      }
	      if (timePicker) {
	        timePicker = _react2["default"].cloneElement(timePicker, _extends({
	          onChange: this.onSelect,
	          allowEmpty: false,
	          gregorianCalendarLocale: gregorianCalendarLocale
	        }, disabledTimeConfig, {
	          getPopupContainer: this.getRootDOMNode,
	          value: selectedValue
	        }));
	      }
	      footerEl = _react2["default"].createElement('div', { className: prefixCls + '-footer' }, timePicker, footerBtn);
	    }

	    return footerEl;
	  }
	});

	exports["default"] = CalendarFooter;
	module.exports = exports['default'];

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports["default"] = TodayButton;

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _util = __webpack_require__(41);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}

	function TodayButton(_ref) {
	  var prefixCls = _ref.prefixCls;
	  var locale = _ref.locale;
	  var value = _ref.value;
	  var timePicker = _ref.timePicker;
	  var disabledDate = _ref.disabledDate;
	  var disabledTime = _ref.disabledTime;
	  var onToday = _ref.onToday;

	  var disabledToday = false;
	  var localeNow = locale.today;
	  if (timePicker) {
	    localeNow = locale.now || locale.today;
	  }
	  var disabledTodayClass = '';
	  if (disabledDate) {
	    disabledToday = !(0, _util.isAllowedDate)((0, _util.getTodayTime)(value), disabledDate, disabledTime);
	    if (disabledToday) {
	      disabledTodayClass = prefixCls + '-today-btn-disabled';
	    }
	  }
	  return _react2["default"].createElement('a', {
	    className: prefixCls + '-today-btn ' + disabledTodayClass,
	    role: 'button',
	    onClick: disabledToday ? null : onToday,
	    title: (0, _util.getTodayTimeStr)(value)
	  }, localeNow);
	}
		module.exports = exports['default'];

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports["default"] = OkButton;

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}

	function OkButton(_ref) {
	  var prefixCls = _ref.prefixCls;
	  var locale = _ref.locale;
	  var okDisabled = _ref.okDisabled;
	  var onOk = _ref.onOk;

	  var className = prefixCls + "-ok-btn";
	  if (okDisabled) {
	    className += " " + prefixCls + "-ok-btn-disabled";
	  }
	  return _react2["default"].createElement("a", {
	    className: className,
	    role: "button",
	    onClick: okDisabled ? null : onOk
	  }, locale.ok);
	}
		module.exports = exports['default'];

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _classnames = __webpack_require__(5);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _gregorianCalendar = __webpack_require__(12);

	var _gregorianCalendar2 = _interopRequireDefault(_gregorianCalendar);

	var _index = __webpack_require__(41);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	  } else {
	    obj[key] = value;
	  }return obj;
	}

	function noop() {}

	function getNow() {
	  var value = new _gregorianCalendar2["default"]();
	  value.setTime(Date.now());
	  return value;
	}

	function getNowByCurrentStateValue(value) {
	  var ret = undefined;
	  if (value) {
	    ret = value.clone();
	    ret.setTime(Date.now());
	  } else {
	    ret = getNow();
	  }
	  return ret;
	}

	var CalendarMixin = {
	  propTypes: {
	    value: _react.PropTypes.object,
	    defaultValue: _react.PropTypes.object,
	    onKeyDown: _react.PropTypes.func
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      onKeyDown: noop
	    };
	  },
	  getInitialState: function getInitialState() {
	    var props = this.props;
	    var value = props.value || props.defaultValue || getNow();
	    return {
	      value: value,
	      selectedValue: props.selectedValue || props.defaultSelectedValue
	    };
	  },
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    var value = nextProps.value;
	    var selectedValue = nextProps.selectedValue;

	    if ('value' in nextProps) {
	      value = value || nextProps.defaultValue || getNowByCurrentStateValue(this.state.value);
	      this.setState({
	        value: value
	      });
	    }
	    if ('selectedValue' in nextProps) {
	      this.setState({
	        selectedValue: selectedValue
	      });
	    }
	  },
	  onSelect: function onSelect(value, cause) {
	    if (value) {
	      this.setValue(value);
	    }
	    this.setSelectedValue(value, cause);
	  },
	  renderRoot: function renderRoot(newProps) {
	    var _className;

	    var props = this.props;
	    var prefixCls = props.prefixCls;

	    var className = (_className = {}, _defineProperty(_className, prefixCls, 1), _defineProperty(_className, prefixCls + '-hidden', !props.visible), _defineProperty(_className, props.className, !!props.className), _defineProperty(_className, newProps.className, !!newProps.className), _className);

	    return _react2["default"].createElement('div', {
	      className: '' + (0, _classnames2["default"])(className),
	      style: this.props.style,
	      tabIndex: '0', onKeyDown: this.onKeyDown
	    }, newProps.children);
	  },
	  setSelectedValue: function setSelectedValue(selectedValue, cause) {
	    if (this.isAllowedDate(selectedValue)) {
	      if (!('selectedValue' in this.props)) {
	        this.setState({
	          selectedValue: selectedValue
	        });
	      }
	      this.props.onSelect(selectedValue, cause);
	    }
	  },
	  setValue: function setValue(value) {
	    var originalValue = this.state.value;
	    if (!('value' in this.props)) {
	      this.setState({
	        value: value
	      });
	    }
	    if (originalValue && value && originalValue.getTime() !== value.getTime() || !originalValue && value || originalValue && !value) {
	      this.props.onChange(value);
	    }
	  },
	  isAllowedDate: function isAllowedDate(value) {
	    var disabledDate = this.props.disabledDate;
	    var disabledTime = this.props.disabledTime;
	    return (0, _index.isAllowedDate)(value, disabledDate, disabledTime);
	  }
	};

	exports["default"] = CalendarMixin;
	module.exports = exports['default'];

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(3);

	var _en_US = __webpack_require__(56);

	var _en_US2 = _interopRequireDefault(_en_US);

	var _index = __webpack_require__(41);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}

	function noop() {}

	exports["default"] = {
	  propTypes: {
	    className: _react.PropTypes.string,
	    locale: _react.PropTypes.object,
	    style: _react.PropTypes.object,
	    visible: _react.PropTypes.bool,
	    onSelect: _react.PropTypes.func,
	    prefixCls: _react.PropTypes.string,
	    onChange: _react.PropTypes.func,
	    onOk: _react.PropTypes.func
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      locale: _en_US2["default"],
	      style: {},
	      visible: true,
	      prefixCls: 'rc-calendar',
	      formatter: 'yyyy-MM-dd',
	      className: '',
	      onSelect: noop,
	      onChange: noop,
	      onClear: noop
	    };
	  },
	  shouldComponentUpdate: function shouldComponentUpdate(nextProps) {
	    return this.props.visible || nextProps.visible;
	  },
	  getFormatter: function getFormatter() {
	    var formatter = this.props.formatter;
	    var locale = this.props.locale;
	    if (this.normalFormatter && formatter === this.lastFormatter) {
	      return this.normalFormatter;
	    }
	    this.normalFormatter = (0, _index.getFormatter)(formatter, locale);
	    this.lastFormatter = formatter;
	    return this.normalFormatter;
	  }
	};
		module.exports = exports['default'];

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _en_US = __webpack_require__(43);

	var _en_US2 = _interopRequireDefault(_en_US);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}

	exports["default"] = {
	  today: 'Today',
	  now: 'Now',
	  ok: 'Ok',
	  clear: 'Clear',
	  month: 'Month',
	  year: 'Year',
	  monthSelect: 'Choose a month',
	  yearSelect: 'Choose a year',
	  decadeSelect: 'Choose a decade',
	  yearFormat: 'yyyy',
	  dateFormat: 'M/d/yyyy',
	  monthFormat: 'MMMM',
	  monthBeforeYear: true,
	  previousMonth: 'Previous month (PageUp)',
	  nextMonth: 'Next month (PageDown)',
	  previousYear: 'Last year (Control + left)',
	  nextYear: 'Next year (Control + right)',
	  previousDecade: 'Last decade',
	  nextDecade: 'Next decade',
	  previousCentury: 'Last century',
	  nextCentury: 'Next century',
	  format: _en_US2["default"]
	};
		module.exports = exports['default'];

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(4);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _index = __webpack_require__(41);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}

	function copyTime(target, source) {
	  if (source) {
	    target.setHourOfDay(source.getHourOfDay());
	    target.setMinutes(source.getMinutes());
	    target.setSeconds(source.getSeconds());
	  }
	  return target;
	}

	var DateInput = _react2["default"].createClass({
	  displayName: 'DateInput',

	  propTypes: {
	    prefixCls: _react.PropTypes.string,
	    timePicker: _react.PropTypes.object,
	    disabledTime: _react.PropTypes.any,
	    formatter: _react.PropTypes.object,
	    locale: _react.PropTypes.object,
	    gregorianCalendarLocale: _react.PropTypes.object,
	    disabledDate: _react.PropTypes.func,
	    onChange: _react.PropTypes.func,
	    onClear: _react.PropTypes.func,
	    placeholder: _react.PropTypes.string,
	    onSelect: _react.PropTypes.func,
	    selectedValue: _react.PropTypes.object
	  },

	  getInitialState: function getInitialState() {
	    var selectedValue = this.props.selectedValue;
	    return {
	      str: selectedValue && this.props.formatter.format(selectedValue) || '',
	      invalid: false
	    };
	  },
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    // when popup show, click body will call this, bug!
	    var selectedValue = nextProps.selectedValue;
	    this.setState({
	      str: selectedValue && nextProps.formatter.format(selectedValue) || '',
	      invalid: false
	    });
	  },
	  onInputChange: function onInputChange(event) {
	    var str = event.target.value;
	    this.setState({
	      str: str
	    });
	    var value = undefined;
	    var _props = this.props;
	    var disabledDate = _props.disabledDate;
	    var formatter = _props.formatter;
	    var gregorianCalendarLocale = _props.gregorianCalendarLocale;
	    var onChange = _props.onChange;

	    if (str) {
	      try {
	        value = copyTime(formatter.parse(str, {
	          locale: gregorianCalendarLocale,
	          obeyCount: true
	        }), this.props.selectedValue);
	      } catch (ex) {
	        this.setState({
	          invalid: true
	        });
	        return;
	      }
	      if (value && (!disabledDate || !disabledDate(value))) {
	        var originalValue = this.props.selectedValue;
	        if (originalValue && value) {
	          if (originalValue.getTime() !== value.getTime()) {
	            onChange(value);
	          }
	        } else if (originalValue !== value) {
	          onChange(value);
	        }
	      } else {
	        this.setState({
	          invalid: true
	        });
	        return;
	      }
	    } else {
	      onChange(null);
	    }
	    this.setState({
	      invalid: false
	    });
	  },
	  onClear: function onClear() {
	    this.setState({
	      str: ''
	    });
	    this.props.onClear(null);
	  },
	  getRootDOMNode: function getRootDOMNode() {
	    return _reactDom2["default"].findDOMNode(this);
	  },
	  render: function render() {
	    var props = this.props;
	    var _state = this.state;
	    var invalid = _state.invalid;
	    var str = _state.str;
	    var selectedValue = props.selectedValue;
	    var locale = props.locale;
	    var prefixCls = props.prefixCls;
	    var placeholder = props.placeholder;
	    var onChange = props.onChange;
	    var timePicker = props.timePicker;
	    var disabledTime = props.disabledTime;
	    var gregorianCalendarLocale = props.gregorianCalendarLocale;

	    var invalidClass = invalid ? prefixCls + '-input-invalid' : '';
	    var disabledTimeConfig = disabledTime && timePicker ? (0, _index.getTimeConfig)(selectedValue, disabledTime) : null;
	    return _react2["default"].createElement('div', { className: prefixCls + '-input-wrap' }, _react2["default"].createElement('div', { className: prefixCls + '-time-picker-wrap' }, timePicker ? _react2["default"].cloneElement(timePicker, _extends({
	      showClear: false,
	      allowEmpty: false,
	      getPopupContainer: this.getRootDOMNode,
	      gregorianCalendarLocale: gregorianCalendarLocale,
	      value: selectedValue,
	      onChange: onChange
	    }, disabledTimeConfig)) : null), _react2["default"].createElement('div', { className: prefixCls + '-date-input-wrap' }, _react2["default"].createElement('input', {
	      className: prefixCls + '-input  ' + invalidClass,
	      value: str,
	      placeholder: placeholder,
	      onChange: this.onInputChange
	    })), props.showClear ? _react2["default"].createElement('a', {
	      className: prefixCls + '-clear-btn',
	      role: 'button',
	      title: locale.clear,
	      onClick: this.onClear
	    }) : null);
	  }
	});

	exports["default"] = DateInput;
	module.exports = exports['default'];

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(4);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _rcUtil = __webpack_require__(16);

	var _placements = __webpack_require__(59);

	var _placements2 = _interopRequireDefault(_placements);

	var _rcTrigger = __webpack_require__(60);

	var _rcTrigger2 = _interopRequireDefault(_rcTrigger);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}

	function noop() {}

	function refFn(field, component) {
	  this[field] = component;
	}

	var Picker = _react2["default"].createClass({
	  displayName: 'Picker',

	  propTypes: {
	    animation: _react.PropTypes.oneOfType([_react.PropTypes.func, _react.PropTypes.string]),
	    disabled: _react.PropTypes.bool,
	    transitionName: _react.PropTypes.string,
	    onChange: _react.PropTypes.func,
	    onOpen: _react.PropTypes.func,
	    onClose: _react.PropTypes.func,
	    children: _react.PropTypes.func,
	    getCalendarContainer: _react.PropTypes.func,
	    calendar: _react.PropTypes.element,
	    style: _react.PropTypes.object,
	    open: _react.PropTypes.bool,
	    defaultOpen: _react.PropTypes.bool,
	    prefixCls: _react.PropTypes.string,
	    placement: _react.PropTypes.any,
	    value: _react.PropTypes.oneOfType([_react.PropTypes.object, _react.PropTypes.array]),
	    defaultValue: _react.PropTypes.oneOfType([_react.PropTypes.object, _react.PropTypes.array]),
	    align: _react.PropTypes.object
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      prefixCls: 'rc-calendar-picker',
	      style: {},
	      align: {},
	      placement: 'bottomLeft',
	      defaultOpen: false,
	      onChange: noop,
	      onOpen: noop,
	      onClose: noop
	    };
	  },
	  getInitialState: function getInitialState() {
	    var props = this.props;
	    var open = undefined;
	    if ('open' in props) {
	      open = props.open;
	    } else {
	      open = props.defaultOpen;
	    }
	    var value = props.value || props.defaultValue;
	    this.saveCalendarRef = refFn.bind(this, 'calendarInstance');
	    return {
	      open: open,
	      value: value
	    };
	  },
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    var value = nextProps.value;
	    var open = nextProps.open;

	    if ('value' in nextProps) {
	      this.setState({
	        value: value
	      });
	    }
	    if (open !== undefined) {
	      this.setState({
	        open: open
	      });
	    }
	  },
	  onCalendarKeyDown: function onCalendarKeyDown(event) {
	    if (event.keyCode === _rcUtil.KeyCode.ESC) {
	      event.stopPropagation();
	      this.close(this.focus);
	    }
	  },
	  onCalendarSelect: function onCalendarSelect(value) {
	    var cause = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    var props = this.props;
	    if (!('value' in props)) {
	      this.setState({
	        value: value
	      });
	    }
	    if (!props.calendar.props.timePicker && cause.source !== 'dateInput') {
	      this.close(this.focus);
	    }
	    props.onChange(value);
	  },
	  onCalendarOk: function onCalendarOk() {
	    this.close(this.focus);
	  },
	  onCalendarClear: function onCalendarClear() {
	    this.close(this.focus);
	  },
	  onVisibleChange: function onVisibleChange(open) {
	    var _this = this;

	    this.setOpen(open, function () {
	      if (open) {
	        _reactDom2["default"].findDOMNode(_this.calendarInstance).focus();
	      }
	    });
	  },
	  getCalendarElement: function getCalendarElement() {
	    var props = this.props;
	    var state = this.state;
	    var calendarProp = props.calendar;
	    var value = state.value;

	    var defaultValue = undefined;
	    // RangeCalendar
	    if (Array.isArray(value)) {
	      defaultValue = value[0];
	    } else {
	      defaultValue = value;
	    }
	    var extraProps = {
	      ref: this.saveCalendarRef,
	      defaultValue: defaultValue || calendarProp.props.defaultValue,
	      defaultSelectedValue: value,
	      onKeyDown: this.onCalendarKeyDown,
	      onOk: (0, _rcUtil.createChainedFunction)(calendarProp.props.onOk, this.onCalendarOk),
	      onSelect: (0, _rcUtil.createChainedFunction)(calendarProp.props.onSelect, this.onCalendarSelect),
	      onClear: (0, _rcUtil.createChainedFunction)(calendarProp.props.onClear, this.onCalendarClear)
	    };

	    return _react2["default"].cloneElement(calendarProp, extraProps);
	  },
	  setOpen: function setOpen(open, callback) {
	    var _props = this.props;
	    var onOpen = _props.onOpen;
	    var onClose = _props.onClose;

	    if (this.state.open !== open) {
	      this.setState({
	        open: open
	      }, callback);
	      var event = {
	        open: open
	      };
	      if (open) {
	        onOpen(event);
	      } else {
	        onClose(event);
	      }
	    }
	  },
	  open: function open(callback) {
	    this.setOpen(true, callback);
	  },
	  close: function close(callback) {
	    this.setOpen(false, callback);
	  },
	  focus: function focus() {
	    if (!this.state.open) {
	      _reactDom2["default"].findDOMNode(this).focus();
	    }
	  },
	  render: function render() {
	    var props = this.props;
	    var prefixCls = props.prefixCls;
	    var placement = props.placement;
	    var style = props.style;
	    var getCalendarContainer = props.getCalendarContainer;
	    var align = props.align;
	    var animation = props.animation;
	    var disabled = props.disabled;
	    var transitionName = props.transitionName;
	    var children = props.children;

	    var state = this.state;
	    return _react2["default"].createElement(_rcTrigger2["default"], {
	      popup: this.getCalendarElement(),
	      popupAlign: align,
	      builtinPlacements: _placements2["default"],
	      popupPlacement: placement,
	      action: disabled ? [] : ['click'],
	      destroyPopupOnHide: true,
	      getPopupContainer: getCalendarContainer,
	      popupStyle: style,
	      popupAnimation: animation,
	      popupTransitionName: transitionName,
	      popupVisible: state.open,
	      onPopupVisibleChange: this.onVisibleChange,
	      prefixCls: prefixCls
	    }, children(state, props));
	  }
	});

	exports["default"] = Picker;
	module.exports = exports['default'];

/***/ },
/* 59 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var autoAdjustOverflow = {
	  adjustX: 1,
	  adjustY: 1
	};

	var targetOffset = [0, 0];

	var placements = {
	  bottomLeft: {
	    points: ['tl', 'tl'],
	    overflow: autoAdjustOverflow,
	    offset: [0, -3],
	    targetOffset: targetOffset
	  },
	  bottomRight: {
	    points: ['tr', 'tr'],
	    overflow: autoAdjustOverflow,
	    offset: [0, -3],
	    targetOffset: targetOffset
	  },
	  topRight: {
	    points: ['br', 'br'],
	    overflow: autoAdjustOverflow,
	    offset: [0, 3],
	    targetOffset: targetOffset
	  },
	  topLeft: {
	    points: ['bl', 'bl'],
	    overflow: autoAdjustOverflow,
	    offset: [0, 3],
	    targetOffset: targetOffset
	  }
	};

	exports["default"] = placements;
	module.exports = exports['default'];

/***/ },
/* 60 */
[759, 61],
/* 61 */
[760, 16, 62, 85],
/* 62 */
[761, 63, 74, 83, 84],
/* 63 */
[762, 64],
/* 64 */
[763, 65, 16, 73],
/* 65 */
[764, 66, 67, 68, 69, 70, 71],
/* 66 */
/***/ function(module, exports) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;

	var getComputedStyleX = undefined;

	function css(el, name, v) {
	  var value = v;
	  if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
	    for (var i in name) {
	      if (name.hasOwnProperty(i)) {
	        css(el, i, name[i]);
	      }
	    }
	    return undefined;
	  }
	  if (typeof value !== 'undefined') {
	    if (typeof value === 'number') {
	      value = value + 'px';
	    }
	    el.style[name] = value;
	    return undefined;
	  }
	  return getComputedStyleX(el, name);
	}

	function getClientPosition(elem) {
	  var box = undefined;
	  var x = undefined;
	  var y = undefined;
	  var doc = elem.ownerDocument;
	  var body = doc.body;
	  var docElem = doc && doc.documentElement;
	  // 根据 GBS 最新数据，A-Grade Browsers 都已支持 getBoundingClientRect 方法，不用再考虑传统的实现方式
	  box = elem.getBoundingClientRect();

	  // 注：jQuery 还考虑减去 docElem.clientLeft/clientTop
	  // 但测试发现，这样反而会导致当 html 和 body 有边距/边框样式时，获取的值不正确
	  // 此外，ie6 会忽略 html 的 margin 值，幸运地是没有谁会去设置 html 的 margin

	  x = box.left;
	  y = box.top;

	  // In IE, most of the time, 2 extra pixels are added to the top and left
	  // due to the implicit 2-pixel inset border.  In IE6/7 quirks mode and
	  // IE6 standards mode, this border can be overridden by setting the
	  // document element's border to zero -- thus, we cannot rely on the
	  // offset always being 2 pixels.

	  // In quirks mode, the offset can be determined by querying the body's
	  // clientLeft/clientTop, but in standards mode, it is found by querying
	  // the document element's clientLeft/clientTop.  Since we already called
	  // getClientBoundingRect we have already forced a reflow, so it is not
	  // too expensive just to query them all.

	  // ie 下应该减去窗口的边框吧，毕竟默认 absolute 都是相对窗口定位的
	  // 窗口边框标准是设 documentElement ,quirks 时设置 body
	  // 最好禁止在 body 和 html 上边框 ，但 ie < 9 html 默认有 2px ，减去
	  // 但是非 ie 不可能设置窗口边框，body html 也不是窗口 ,ie 可以通过 html,body 设置
	  // 标准 ie 下 docElem.clientTop 就是 border-top
	  // ie7 html 即窗口边框改变不了。永远为 2
	  // 但标准 firefox/chrome/ie9 下 docElem.clientTop 是窗口边框，即使设了 border-top 也为 0

	  x -= docElem.clientLeft || body.clientLeft || 0;
	  y -= docElem.clientTop || body.clientTop || 0;

	  return { left: x, top: y };
	}

	function getScroll(w, top) {
	  var ret = w['page' + (top ? 'Y' : 'X') + 'Offset'];
	  var method = 'scroll' + (top ? 'Top' : 'Left');
	  if (typeof ret !== 'number') {
	    var d = w.document;
	    // ie6,7,8 standard mode
	    ret = d.documentElement[method];
	    if (typeof ret !== 'number') {
	      // quirks mode
	      ret = d.body[method];
	    }
	  }
	  return ret;
	}

	function getScrollLeft(w) {
	  return getScroll(w);
	}

	function getScrollTop(w) {
	  return getScroll(w, true);
	}

	function getOffset(el) {
	  var pos = getClientPosition(el);
	  var doc = el.ownerDocument;
	  var w = doc.defaultView || doc.parentWindow;
	  pos.left += getScrollLeft(w);
	  pos.top += getScrollTop(w);
	  return pos;
	}
	function _getComputedStyle(elem, name, cs) {
	  var computedStyle = cs;
	  var val = '';
	  var d = elem.ownerDocument;
	  computedStyle = computedStyle || d.defaultView.getComputedStyle(elem, null);

	  // https://github.com/kissyteam/kissy/issues/61
	  if (computedStyle) {
	    val = computedStyle.getPropertyValue(name) || computedStyle[name];
	  }

	  return val;
	}

	var _RE_NUM_NO_PX = new RegExp('^(' + RE_NUM + ')(?!px)[a-z%]+$', 'i');
	var RE_POS = /^(top|right|bottom|left)$/;
	var CURRENT_STYLE = 'currentStyle';
	var RUNTIME_STYLE = 'runtimeStyle';
	var LEFT = 'left';
	var PX = 'px';

	function _getComputedStyleIE(elem, name) {
	  // currentStyle maybe null
	  // http://msdn.microsoft.com/en-us/library/ms535231.aspx
	  var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name];

	  // 当 width/height 设置为百分比时，通过 pixelLeft 方式转换的 width/height 值
	  // 一开始就处理了! CUSTOM_STYLE.height,CUSTOM_STYLE.width ,cssHook 解决@2011-08-19
	  // 在 ie 下不对，需要直接用 offset 方式
	  // borderWidth 等值也有问题，但考虑到 borderWidth 设为百分比的概率很小，这里就不考虑了

	  // From the awesome hack by Dean Edwards
	  // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
	  // If we're not dealing with a regular pixel number
	  // but a number that has a weird ending, we need to convert it to pixels
	  // exclude left right for relativity
	  if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name)) {
	    // Remember the original values
	    var style = elem.style;
	    var left = style[LEFT];
	    var rsLeft = elem[RUNTIME_STYLE][LEFT];

	    // prevent flashing of content
	    elem[RUNTIME_STYLE][LEFT] = elem[CURRENT_STYLE][LEFT];

	    // Put in the new values to get a computed value out
	    style[LEFT] = name === 'fontSize' ? '1em' : ret || 0;
	    ret = style.pixelLeft + PX;

	    // Revert the changed values
	    style[LEFT] = left;

	    elem[RUNTIME_STYLE][LEFT] = rsLeft;
	  }
	  return ret === '' ? 'auto' : ret;
	}

	if (typeof window !== 'undefined') {
	  getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;
	}

	function getOffsetDirection(dir, option) {
	  if (dir === 'left') {
	    return option.useCssRight ? 'right' : dir;
	  }
	  return option.useCssBottom ? 'bottom' : dir;
	}

	function oppositeOffsetDirection(dir) {
	  if (dir === 'left') {
	    return 'right';
	  } else if (dir === 'right') {
	    return 'left';
	  } else if (dir === 'top') {
	    return 'bottom';
	  } else if (dir === 'bottom') {
	    return 'top';
	  }
	}

	// 设置 elem 相对 elem.ownerDocument 的坐标
	function setOffset(elem, offset, option) {
	  // set position first, in-case top/left are set even on static elem
	  if (css(elem, 'position') === 'static') {
	    elem.style.position = 'relative';
	  }
	  var presetH = -999;
	  var presetV = -999;
	  var horizontalProperty = getOffsetDirection('left', option);
	  var verticalProperty = getOffsetDirection('top', option);
	  var oppositeHorizontalProperty = oppositeOffsetDirection(horizontalProperty);
	  var oppositeVerticalProperty = oppositeOffsetDirection(verticalProperty);

	  if (horizontalProperty !== 'left') {
	    presetH = 999;
	  }

	  if (verticalProperty !== 'top') {
	    presetV = 999;
	  }

	  if ('left' in offset) {
	    elem.style[oppositeHorizontalProperty] = '';
	    elem.style[horizontalProperty] = presetH + 'px';
	  }
	  if ('top' in offset) {
	    elem.style[oppositeVerticalProperty] = '';
	    elem.style[verticalProperty] = presetV + 'px';
	  }
	  var old = getOffset(elem);
	  var ret = {};
	  var key = undefined;
	  for (key in offset) {
	    if (offset.hasOwnProperty(key)) {
	      var dir = getOffsetDirection(key, option);
	      var preset = key === 'left' ? presetH : presetV;
	      if (dir === key) {
	        ret[dir] = preset + offset[key] - old[key];
	      } else {
	        ret[dir] = preset + old[key] - offset[key];
	      }
	    }
	  }
	  css(elem, ret);
	}

	function each(arr, fn) {
	  for (var i = 0; i < arr.length; i++) {
	    fn(arr[i]);
	  }
	}

	function isBorderBoxFn(elem) {
	  return getComputedStyleX(elem, 'boxSizing') === 'border-box';
	}

	var BOX_MODELS = ['margin', 'border', 'padding'];
	var CONTENT_INDEX = -1;
	var PADDING_INDEX = 2;
	var BORDER_INDEX = 1;
	var MARGIN_INDEX = 0;

	function swap(elem, options, callback) {
	  var old = {};
	  var style = elem.style;
	  var name = undefined;

	  // Remember the old values, and insert the new ones
	  for (name in options) {
	    if (options.hasOwnProperty(name)) {
	      old[name] = style[name];
	      style[name] = options[name];
	    }
	  }

	  callback.call(elem);

	  // Revert the old values
	  for (name in options) {
	    if (options.hasOwnProperty(name)) {
	      style[name] = old[name];
	    }
	  }
	}

	function getPBMWidth(elem, props, which) {
	  var value = 0;
	  var prop = undefined;
	  var j = undefined;
	  var i = undefined;
	  for (j = 0; j < props.length; j++) {
	    prop = props[j];
	    if (prop) {
	      for (i = 0; i < which.length; i++) {
	        var cssProp = undefined;
	        if (prop === 'border') {
	          cssProp = prop + which[i] + 'Width';
	        } else {
	          cssProp = prop + which[i];
	        }
	        value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
	      }
	    }
	  }
	  return value;
	}

	/**
	 * A crude way of determining if an object is a window
	 * @member util
	 */
	function isWindow(obj) {
	  // must use == for ie8
	  /* eslint eqeqeq:0 */
	  return obj !== null && obj !== undefined && obj == obj.window;
	}

	var domUtils = {};

	each(['Width', 'Height'], function (name) {
	  domUtils['doc' + name] = function (refWin) {
	    var d = refWin.document;
	    return Math.max(
	    // firefox chrome documentElement.scrollHeight< body.scrollHeight
	    // ie standard mode : documentElement.scrollHeight> body.scrollHeight
	    d.documentElement['scroll' + name],
	    // quirks : documentElement.scrollHeight 最大等于可视窗口多一点？
	    d.body['scroll' + name], domUtils['viewport' + name](d));
	  };

	  domUtils['viewport' + name] = function (win) {
	    // pc browser includes scrollbar in window.innerWidth
	    var prop = 'client' + name;
	    var doc = win.document;
	    var body = doc.body;
	    var documentElement = doc.documentElement;
	    var documentElementProp = documentElement[prop];
	    // 标准模式取 documentElement
	    // backcompat 取 body
	    return doc.compatMode === 'CSS1Compat' && documentElementProp || body && body[prop] || documentElementProp;
	  };
	});

	/*
	 得到元素的大小信息
	 @param elem
	 @param name
	 @param {String} [extra]  'padding' : (css width) + padding
	 'border' : (css width) + padding + border
	 'margin' : (css width) + padding + border + margin
	 */
	function getWH(elem, name, ex) {
	  var extra = ex;
	  if (isWindow(elem)) {
	    return name === 'width' ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
	  } else if (elem.nodeType === 9) {
	    return name === 'width' ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
	  }
	  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];
	  var borderBoxValue = name === 'width' ? elem.offsetWidth : elem.offsetHeight;
	  var computedStyle = getComputedStyleX(elem);
	  var isBorderBox = isBorderBoxFn(elem, computedStyle);
	  var cssBoxValue = 0;
	  if (borderBoxValue === null || borderBoxValue === undefined || borderBoxValue <= 0) {
	    borderBoxValue = undefined;
	    // Fall back to computed then un computed css if necessary
	    cssBoxValue = getComputedStyleX(elem, name);
	    if (cssBoxValue === null || cssBoxValue === undefined || Number(cssBoxValue) < 0) {
	      cssBoxValue = elem.style[name] || 0;
	    }
	    // Normalize '', auto, and prepare for extra
	    cssBoxValue = parseFloat(cssBoxValue) || 0;
	  }
	  if (extra === undefined) {
	    extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
	  }
	  var borderBoxValueOrIsBorderBox = borderBoxValue !== undefined || isBorderBox;
	  var val = borderBoxValue || cssBoxValue;
	  if (extra === CONTENT_INDEX) {
	    if (borderBoxValueOrIsBorderBox) {
	      return val - getPBMWidth(elem, ['border', 'padding'], which, computedStyle);
	    }
	    return cssBoxValue;
	  } else if (borderBoxValueOrIsBorderBox) {
	    if (extra === BORDER_INDEX) {
	      return val;
	    }
	    return val + (extra === PADDING_INDEX ? -getPBMWidth(elem, ['border'], which, computedStyle) : getPBMWidth(elem, ['margin'], which, computedStyle));
	  }
	  return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which, computedStyle);
	}

	var cssShow = { position: 'absolute', visibility: 'hidden', display: 'block' };

	// fix #119 : https://github.com/kissyteam/kissy/issues/119
	function getWHIgnoreDisplay() {
	  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  var val = undefined;
	  var elem = args[0];
	  // in case elem is window
	  // elem.offsetWidth === undefined
	  if (elem.offsetWidth !== 0) {
	    val = getWH.apply(undefined, args);
	  } else {
	    swap(elem, cssShow, function () {
	      val = getWH.apply(undefined, args);
	    });
	  }
	  return val;
	}

	each(['width', 'height'], function (name) {
	  var first = name.charAt(0).toUpperCase() + name.slice(1);
	  domUtils['outer' + first] = function (el, includeMargin) {
	    return el && getWHIgnoreDisplay(el, name, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
	  };
	  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];

	  domUtils[name] = function (elem, v) {
	    var val = v;
	    if (val !== undefined) {
	      if (elem) {
	        var computedStyle = getComputedStyleX(elem);
	        var isBorderBox = isBorderBoxFn(elem);
	        if (isBorderBox) {
	          val += getPBMWidth(elem, ['padding', 'border'], which, computedStyle);
	        }
	        return css(elem, name, val);
	      }
	      return undefined;
	    }
	    return elem && getWHIgnoreDisplay(elem, name, CONTENT_INDEX);
	  };
	});

	function mix(to, from) {
	  for (var i in from) {
	    if (from.hasOwnProperty(i)) {
	      to[i] = from[i];
	    }
	  }
	  return to;
	}

	var utils = {
	  getWindow: function getWindow(node) {
	    if (node && node.document && node.setTimeout) {
	      return node;
	    }
	    var doc = node.ownerDocument || node;
	    return doc.defaultView || doc.parentWindow;
	  },
	  offset: function offset(el, value, option) {
	    if (typeof value !== 'undefined') {
	      setOffset(el, value, option || {});
	    } else {
	      return getOffset(el);
	    }
	  },
	  isWindow: isWindow,
	  each: each,
	  css: css,
	  clone: function clone(obj) {
	    var i = undefined;
	    var ret = {};
	    for (i in obj) {
	      if (obj.hasOwnProperty(i)) {
	        ret[i] = obj[i];
	      }
	    }
	    var overflow = obj.overflow;
	    if (overflow) {
	      for (i in obj) {
	        if (obj.hasOwnProperty(i)) {
	          ret.overflow[i] = obj.overflow[i];
	        }
	      }
	    }
	    return ret;
	  },
	  mix: mix,
	  getWindowScrollLeft: function getWindowScrollLeft(w) {
	    return getScrollLeft(w);
	  },
	  getWindowScrollTop: function getWindowScrollTop(w) {
	    return getScrollTop(w);
	  },
	  merge: function merge() {
	    var ret = {};

	    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	      args[_key2] = arguments[_key2];
	    }

	    for (var i = 0; i < args.length; i++) {
	      utils.mix(ret, args[i]);
	    }
	    return ret;
	  },
	  viewportWidth: 0,
	  viewportHeight: 0
	};

	mix(utils, domUtils);

	exports['default'] = utils;
	module.exports = exports['default'];

/***/ },
/* 67 */
[765, 66],
/* 68 */
[766, 66, 67],
/* 69 */
[767, 66],
/* 70 */
[768, 66],
/* 71 */
[769, 72],
/* 72 */
/***/ function(module, exports) {

	/**
	 * 获取 node 上的 align 对齐点 相对于页面的坐标
	 */

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	function getAlignOffset(region, align) {
	  var V = align.charAt(0);
	  var H = align.charAt(1);
	  var w = region.width;
	  var h = region.height;
	  var x = undefined;
	  var y = undefined;

	  x = region.left;
	  y = region.top;

	  if (V === 'c') {
	    y += h / 2;
	  } else if (V === 'b') {
	    y += h;
	  }

	  if (H === 'c') {
	    x += w / 2;
	  } else if (H === 'r') {
	    x += w;
	  }

	  return {
	    left: x,
	    top: y
	  };
	}

	exports['default'] = getAlignOffset;
	module.exports = exports['default'];

/***/ },
/* 73 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports["default"] = isWindow;

	function isWindow(obj) {
	  /* eslint no-eq-null: 0 */
	  /* eslint eqeqeq: 0 */
	  return obj != null && obj == obj.window;
	}

		module.exports = exports["default"];

/***/ },
/* 74 */
[770, 75],
/* 75 */
[771, 76, 77, 82],
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports.toArrayChildren = toArrayChildren;
	exports.findChildInChildrenByKey = findChildInChildrenByKey;
	exports.findShownChildInChildrenByKey = findShownChildInChildrenByKey;
	exports.findHiddenChildInChildrenByKey = findHiddenChildInChildrenByKey;
	exports.isSameChildren = isSameChildren;
	exports.mergeChildren = mergeChildren;

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	function toArrayChildren(children) {
	  var ret = [];
	  _react2['default'].Children.forEach(children, function (child) {
	    ret.push(child);
	  });
	  return ret;
	}

	function findChildInChildrenByKey(children, key) {
	  var ret = null;
	  if (children) {
	    children.forEach(function (child) {
	      if (ret) {
	        return;
	      }
	      if (child.key === key) {
	        ret = child;
	      }
	    });
	  }
	  return ret;
	}

	function findShownChildInChildrenByKey(children, key, showProp) {
	  var ret = null;
	  if (children) {
	    children.forEach(function (child) {
	      if (child.key === key && child.props[showProp]) {
	        if (ret) {
	          throw new Error('two child with same key for <rc-animate> children');
	        }
	        ret = child;
	      }
	    });
	  }
	  return ret;
	}

	function findHiddenChildInChildrenByKey(children, key, showProp) {
	  var found = 0;
	  if (children) {
	    children.forEach(function (child) {
	      if (found) {
	        return;
	      }
	      found = child.key === key && !child.props[showProp];
	    });
	  }
	  return found;
	}

	function isSameChildren(c1, c2, showProp) {
	  var same = c1.length === c2.length;
	  if (same) {
	    c1.forEach(function (child, index) {
	      var child2 = c2[index];
	      if (child.key !== child2.key) {
	        same = false;
	      } else if (showProp && child.props[showProp] !== child2.props[showProp]) {
	        same = false;
	      }
	    });
	  }
	  return same;
	}

	function mergeChildren(prev, next) {
	  var ret = [];

	  // For each key of `next`, the list of keys to insert before that key in
	  // the combined list
	  var nextChildrenPending = {};
	  var pendingChildren = [];
	  prev.forEach(function (child) {
	    if (findChildInChildrenByKey(next, child.key)) {
	      if (pendingChildren.length) {
	        nextChildrenPending[child.key] = pendingChildren;
	        pendingChildren = [];
	      }
	    } else {
	      pendingChildren.push(child);
	    }
	  });

	  next.forEach(function (child) {
	    if (nextChildrenPending.hasOwnProperty(child.key)) {
	      ret = ret.concat(nextChildrenPending[child.key]);
	    }
	    ret.push(child);
	  });

	  ret = ret.concat(pendingChildren);

	  return ret;
		}

/***/ },
/* 77 */
[772, 78, 82],
/* 78 */
[773, 79, 80],
/* 79 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var EVENT_NAME_MAP = {
	  transitionend: {
	    transition: 'transitionend',
	    WebkitTransition: 'webkitTransitionEnd',
	    MozTransition: 'mozTransitionEnd',
	    OTransition: 'oTransitionEnd',
	    msTransition: 'MSTransitionEnd'
	  },

	  animationend: {
	    animation: 'animationend',
	    WebkitAnimation: 'webkitAnimationEnd',
	    MozAnimation: 'mozAnimationEnd',
	    OAnimation: 'oAnimationEnd',
	    msAnimation: 'MSAnimationEnd'
	  }
	};

	var endEvents = [];

	function detectEvents() {
	  var testEl = document.createElement('div');
	  var style = testEl.style;

	  if (!('AnimationEvent' in window)) {
	    delete EVENT_NAME_MAP.animationend.animation;
	  }

	  if (!('TransitionEvent' in window)) {
	    delete EVENT_NAME_MAP.transitionend.transition;
	  }

	  for (var baseEventName in EVENT_NAME_MAP) {
	    if (EVENT_NAME_MAP.hasOwnProperty(baseEventName)) {
	      var baseEvents = EVENT_NAME_MAP[baseEventName];
	      for (var styleName in baseEvents) {
	        if (styleName in style) {
	          endEvents.push(baseEvents[styleName]);
	          break;
	        }
	      }
	    }
	  }
	}

	if (typeof window !== 'undefined' && typeof document !== 'undefined') {
	  detectEvents();
	}

	function addEventListener(node, eventName, eventListener) {
	  node.addEventListener(eventName, eventListener, false);
	}

	function removeEventListener(node, eventName, eventListener) {
	  node.removeEventListener(eventName, eventListener, false);
	}

	var TransitionEvents = {
	  addEndEventListener: function addEndEventListener(node, eventListener) {
	    if (endEvents.length === 0) {
	      window.setTimeout(eventListener, 0);
	      return;
	    }
	    endEvents.forEach(function (endEvent) {
	      addEventListener(node, endEvent, eventListener);
	    });
	  },

	  endEvents: endEvents,

	  removeEndEventListener: function removeEndEventListener(node, eventListener) {
	    if (endEvents.length === 0) {
	      return;
	    }
	    endEvents.forEach(function (endEvent) {
	      removeEventListener(node, endEvent, eventListener);
	    });
	  }
	};

	exports["default"] = TransitionEvents;
	module.exports = exports['default'];

/***/ },
/* 80 */
[774, 81, 81],
/* 81 */
/***/ function(module, exports) {

	"use strict";

	module.exports = function (arr, obj) {
	  if (arr.indexOf) return arr.indexOf(obj);
	  for (var i = 0; i < arr.length; ++i) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
		};

/***/ },
/* 82 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var util = {
	  isAppearSupported: function isAppearSupported(props) {
	    return props.transitionName && props.transitionAppear || props.animation.appear;
	  },
	  isEnterSupported: function isEnterSupported(props) {
	    return props.transitionName && props.transitionEnter || props.animation.enter;
	  },
	  isLeaveSupported: function isLeaveSupported(props) {
	    return props.transitionName && props.transitionLeave || props.animation.leave;
	  },

	  allowAppearCallback: function allowAppearCallback(props) {
	    return props.transitionAppear || props.animation.appear;
	  },
	  allowEnterCallback: function allowEnterCallback(props) {
	    return props.transitionEnter || props.animation.enter;
	  },
	  allowLeaveCallback: function allowLeaveCallback(props) {
	    return props.transitionLeave || props.animation.leave;
	  }
	};
	exports["default"] = util;
	module.exports = exports["default"];

/***/ },
/* 83 */
[775, 84],
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}

	var LazyRenderBox = _react2["default"].createClass({
	  displayName: 'LazyRenderBox',

	  propTypes: {
	    children: _react.PropTypes.any,
	    className: _react.PropTypes.string,
	    visible: _react.PropTypes.bool,
	    hiddenClassName: _react.PropTypes.string
	  },
	  shouldComponentUpdate: function shouldComponentUpdate(nextProps) {
	    return nextProps.hiddenClassName || nextProps.visible;
	  },
	  render: function render() {
	    if (this.props.hiddenClassName) {
	      var className = this.props.className;
	      if (!this.props.visible) {
	        className += ' ' + this.props.hiddenClassName;
	      }
	      return _react2["default"].createElement('div', _extends({}, this.props, { className: className }));
	    }
	    if (_react2["default"].Children.count(this.props.children) > 1) {
	      return _react2["default"].createElement('div', this.props);
	    }
	    return _react2["default"].Children.only(this.props.children);
	  }
	});

	exports["default"] = LazyRenderBox;
	module.exports = exports['default'];

/***/ },
/* 85 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};

	exports.getAlignFromPlacement = getAlignFromPlacement;
	exports.getPopupClassNameFromAlign = getPopupClassNameFromAlign;
	function isPointsEq(a1, a2) {
	  return a1[0] === a2[0] && a1[1] === a2[1];
	}

	function getAlignFromPlacement(builtinPlacements, placementStr, align) {
	  var baseAlign = builtinPlacements[placementStr] || {};
	  return _extends({}, baseAlign, align);
	}

	function getPopupClassNameFromAlign(builtinPlacements, prefixCls, align) {
	  var points = align.points;
	  for (var placement in builtinPlacements) {
	    if (builtinPlacements.hasOwnProperty(placement)) {
	      if (isPointsEq(builtinPlacements[placement].points, points)) {
	        return prefixCls + '-placement-' + placement;
	      }
	    }
	  }
	  return '';
		}

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _MonthPanel = __webpack_require__(47);

	var _MonthPanel2 = _interopRequireDefault(_MonthPanel);

	var _CalendarMixin = __webpack_require__(54);

	var _CalendarMixin2 = _interopRequireDefault(_CalendarMixin);

	var _CommonMixin = __webpack_require__(55);

	var _CommonMixin2 = _interopRequireDefault(_CommonMixin);

	var _rcUtil = __webpack_require__(16);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}

	var MonthCalendar = _react2["default"].createClass({
	  displayName: 'MonthCalendar',

	  mixins: [_CommonMixin2["default"], _CalendarMixin2["default"]],

	  onKeyDown: function onKeyDown(event) {
	    var keyCode = event.keyCode;
	    var ctrlKey = event.ctrlKey || event.metaKey;
	    var stateValue = this.state.value;
	    var value = stateValue;
	    switch (keyCode) {
	      case _rcUtil.KeyCode.DOWN:
	        value = stateValue.clone();
	        value.addMonth(3);
	        break;
	      case _rcUtil.KeyCode.UP:
	        value = stateValue.clone();
	        value.addMonth(-3);
	        break;
	      case _rcUtil.KeyCode.LEFT:
	        value = stateValue.clone();
	        if (ctrlKey) {
	          value.addYear(-1);
	        } else {
	          value.addMonth(-1);
	        }
	        break;
	      case _rcUtil.KeyCode.RIGHT:
	        value = stateValue.clone();
	        if (ctrlKey) {
	          value.addYear(1);
	        } else {
	          value.addMonth(1);
	        }
	        break;
	      case _rcUtil.KeyCode.ENTER:
	        this.onSelect(stateValue);
	        event.preventDefault();
	        return 1;
	      default:
	        return undefined;
	    }
	    if (value !== stateValue) {
	      this.setValue(value);
	      event.preventDefault();
	      return 1;
	    }
	  },
	  render: function render() {
	    var props = this.props;
	    var children = _react2["default"].createElement(_MonthPanel2["default"], {
	      locale: props.locale,
	      disabledDate: props.disabledDate,
	      style: { position: 'relative' },
	      value: this.state.value,
	      rootPrefixCls: props.prefixCls,
	      onChange: this.setValue,
	      onSelect: this.onSelect
	    });
	    return this.renderRoot({
	      children: children
	    });
	  }
	});

	exports["default"] = MonthCalendar;
	module.exports = exports['default'];

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _YearPanel = __webpack_require__(48);

	var _YearPanel2 = _interopRequireDefault(_YearPanel);

	var _CalendarMixin = __webpack_require__(54);

	var _CalendarMixin2 = _interopRequireDefault(_CalendarMixin);

	var _CommonMixin = __webpack_require__(55);

	var _CommonMixin2 = _interopRequireDefault(_CommonMixin);

	var _rcUtil = __webpack_require__(16);

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(4);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { "default": obj };
	}

	var YearCalendar = _react2["default"].createClass({
	    displayName: 'YearCalendar',

	    mixins: [_CalendarMixin2["default"], _CommonMixin2["default"]],

	    onKeyDown: function onKeyDown(e) {
	        var keyCode = e.keyCode;
	        var ctrlKey = e.ctrlKey || e.metaKey;
	        var stateValue = this.state.value;
	        var value = stateValue;
	        switch (keyCode) {
	            case _rcUtil.KeyCode.DOWN:
	                value = stateValue.clone();
	                value.addMonth(3);
	                break;
	            case _rcUtil.KeyCode.UP:
	                value = stateValue.clone();
	                value.addMonth(-3);
	                break;
	            case _rcUtil.KeyCode.LEFT:
	                value = stateValue.clone();
	                if (ctrlKey) {
	                    value.addYear(-1);
	                } else {
	                    value.addMonth(-1);
	                }
	                break;
	            case _rcUtil.KeyCode.RIGHT:
	                value = stateValue.clone();
	                if (ctrlKey) {
	                    value.addYear(1);
	                } else {
	                    value.addMonth(1);
	                }
	                break;
	            case _rcUtil.KeyCode.ENTER:
	                this.onSelect(stateValue);
	                e.preventDefault();
	                return 1;
	            default:
	                return undefined;
	        }
	        if (value !== stateValue) {
	            this.setValue(value);
	            e.preventDefault();
	            return 1;
	        }
	    },
	    render: function render() {
	        var props = this.props;
	        var children = _react2["default"].createElement(_YearPanel2["default"], { locale: props.locale,
	            disabledDate: props.disabledDate,
	            value: this.state.value,
	            rootPrefixCls: props.prefixCls,
	            onChange: this.setValue,
	            onSelect: this.onSelect });
	        return this.renderRoot({
	            children: children,
	            className: props.prefixCls + '-year-calendar-container'

	        });
	    }
	});

	exports["default"] = YearCalendar;
	module.exports = exports['default'];

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _TimePicker = __webpack_require__(89);

	var _TimePicker2 = _interopRequireDefault(_TimePicker);

	exports['default'] = _TimePicker2['default'];
	module.exports = exports['default'];

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _rcTrigger = __webpack_require__(90);

	var _rcTrigger2 = _interopRequireDefault(_rcTrigger);

	var _modulePanel = __webpack_require__(137);

	var _modulePanel2 = _interopRequireDefault(_modulePanel);

	var _utilPlacements = __webpack_require__(149);

	var _utilPlacements2 = _interopRequireDefault(_utilPlacements);

	var _mixinCommonMixin = __webpack_require__(138);

	var _mixinCommonMixin2 = _interopRequireDefault(_mixinCommonMixin);

	var _utilIndex = __webpack_require__(150);

	function noop() {}

	function refFn(field, component) {
	  this[field] = component;
	}

	var Picker = _react2['default'].createClass({
	  displayName: 'Picker',

	  propTypes: {
	    prefixCls: _react.PropTypes.string,
	    locale: _react.PropTypes.object,
	    value: _react.PropTypes.object,
	    disabled: _react.PropTypes.bool,
	    allowEmpty: _react.PropTypes.bool,
	    defaultValue: _react.PropTypes.object,
	    open: _react.PropTypes.bool,
	    defaultOpen: _react.PropTypes.bool,
	    align: _react.PropTypes.object,
	    placement: _react.PropTypes.any,
	    transitionName: _react.PropTypes.string,
	    getPopupContainer: _react.PropTypes.func,
	    placeholder: _react.PropTypes.string,
	    formatter: _react.PropTypes.any,
	    showHour: _react.PropTypes.bool,
	    style: _react.PropTypes.object,
	    className: _react.PropTypes.string,
	    showSecond: _react.PropTypes.bool,
	    disabledHours: _react.PropTypes.func,
	    disabledMinutes: _react.PropTypes.func,
	    disabledSeconds: _react.PropTypes.func,
	    hideDisabledOptions: _react.PropTypes.bool,
	    onChange: _react.PropTypes.func,
	    onOpen: _react.PropTypes.func,
	    onClose: _react.PropTypes.func
	  },

	  mixins: [_mixinCommonMixin2['default']],

	  getDefaultProps: function getDefaultProps() {
	    return {
	      defaultOpen: false,
	      style: {},
	      className: '',
	      align: {},
	      allowEmpty: true,
	      showHour: true,
	      showSecond: true,
	      disabledHours: noop,
	      disabledMinutes: noop,
	      disabledSeconds: noop,
	      hideDisabledOptions: false,
	      placement: 'bottomLeft',
	      onChange: noop,
	      onOpen: noop,
	      onClose: noop
	    };
	  },

	  getInitialState: function getInitialState() {
	    this.savePanelRef = refFn.bind(this, 'panelInstance');
	    var _props = this.props;
	    var defaultOpen = _props.defaultOpen;
	    var defaultValue = _props.defaultValue;
	    var _props$open = _props.open;
	    var open = _props$open === undefined ? defaultOpen : _props$open;
	    var _props$value = _props.value;
	    var value = _props$value === undefined ? defaultValue : _props$value;

	    return {
	      open: open,
	      value: value
	    };
	  },

	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    var value = nextProps.value;
	    var open = nextProps.open;

	    if ('value' in nextProps) {
	      this.setState({
	        value: value
	      });
	    }
	    if (open !== undefined) {
	      this.setState({ open: open });
	    }
	  },

	  onPanelChange: function onPanelChange(value) {
	    this.setValue(value);
	  },

	  onPanelClear: function onPanelClear() {
	    this.setValue(null);
	    this.setOpen(false);
	  },

	  onVisibleChange: function onVisibleChange(open) {
	    this.setOpen(open);
	  },

	  onEsc: function onEsc() {
	    this.setOpen(false);
	    this.refs.picker.focus();
	  },

	  onKeyDown: function onKeyDown(e) {
	    if (e.keyCode === 40) {
	      this.setOpen(true);
	    }
	  },

	  setValue: function setValue(value) {
	    if (!('value' in this.props)) {
	      this.setState({
	        value: value
	      });
	    }
	    this.props.onChange(value);
	  },

	  getFormatter: function getFormatter() {
	    var formatter = this.props.formatter;
	    var locale = this.props.locale;
	    if (formatter) {
	      if (formatter === this.lastFormatter) {
	        return this.normalFormatter;
	      }
	      this.normalFormatter = (0, _utilIndex.getFormatter)(formatter, locale);
	      this.lastFormatter = formatter;
	      return this.normalFormatter;
	    }
	    if (!this.props.showSecond) {
	      if (!this.notShowSecondFormatter) {
	        this.notShowSecondFormatter = (0, _utilIndex.getFormatter)('HH:mm', locale);
	      }
	      return this.notShowSecondFormatter;
	    }
	    if (!this.props.showHour) {
	      if (!this.notShowHourFormatter) {
	        this.notShowHourFormatter = (0, _utilIndex.getFormatter)('mm:ss', locale);
	      }
	      return this.notShowHourFormatter;
	    }
	    if (!this.normalFormatter) {
	      this.normalFormatter = (0, _utilIndex.getFormatter)('HH:mm:ss', locale);
	    }
	    return this.normalFormatter;
	  },

	  getPanelElement: function getPanelElement() {
	    var _props2 = this.props;
	    var prefixCls = _props2.prefixCls;
	    var defaultValue = _props2.defaultValue;
	    var locale = _props2.locale;
	    var placeholder = _props2.placeholder;
	    var disabledHours = _props2.disabledHours;
	    var disabledMinutes = _props2.disabledMinutes;
	    var disabledSeconds = _props2.disabledSeconds;
	    var hideDisabledOptions = _props2.hideDisabledOptions;
	    var allowEmpty = _props2.allowEmpty;
	    var showHour = _props2.showHour;
	    var showSecond = _props2.showSecond;

	    return _react2['default'].createElement(_modulePanel2['default'], {
	      prefixCls: prefixCls + '-panel',
	      ref: this.savePanelRef,
	      value: this.state.value,
	      onChange: this.onPanelChange,
	      gregorianCalendarLocale: locale.calendar,
	      onClear: this.onPanelClear,
	      defaultValue: defaultValue,
	      showHour: showHour,
	      onEsc: this.onEsc,
	      showSecond: showSecond,
	      locale: locale,
	      allowEmpty: allowEmpty,
	      formatter: this.getFormatter(),
	      placeholder: placeholder,
	      disabledHours: disabledHours,
	      disabledMinutes: disabledMinutes,
	      disabledSeconds: disabledSeconds,
	      hideDisabledOptions: hideDisabledOptions
	    });
	  },

	  setOpen: function setOpen(open, callback) {
	    var _props3 = this.props;
	    var onOpen = _props3.onOpen;
	    var onClose = _props3.onClose;

	    if (this.state.open !== open) {
	      this.setState({
	        open: open
	      }, callback);
	      var _event = {
	        open: open
	      };
	      if (open) {
	        onOpen(_event);
	      } else {
	        onClose(_event);
	      }
	    }
	  },

	  render: function render() {
	    var _props4 = this.props;
	    var prefixCls = _props4.prefixCls;
	    var placeholder = _props4.placeholder;
	    var placement = _props4.placement;
	    var align = _props4.align;
	    var disabled = _props4.disabled;
	    var transitionName = _props4.transitionName;
	    var style = _props4.style;
	    var className = _props4.className;
	    var showHour = _props4.showHour;
	    var showSecond = _props4.showSecond;
	    var getPopupContainer = _props4.getPopupContainer;
	    var _state = this.state;
	    var open = _state.open;
	    var value = _state.value;

	    var popupClassName = undefined;
	    if (!showHour || !showSecond) {
	      popupClassName = prefixCls + '-panel-narrow';
	    }
	    return _react2['default'].createElement(
	      _rcTrigger2['default'],
	      {
	        prefixCls: prefixCls + '-panel',
	        popupClassName: popupClassName,
	        popup: this.getPanelElement(),
	        popupAlign: align,
	        builtinPlacements: _utilPlacements2['default'],
	        popupPlacement: placement,
	        action: disabled ? [] : ['click'],
	        destroyPopupOnHide: true,
	        getPopupContainer: getPopupContainer,
	        popupTransitionName: transitionName,
	        popupVisible: open,
	        onPopupVisibleChange: this.onVisibleChange
	      },
	      _react2['default'].createElement(
	        'span',
	        { className: prefixCls + ' ' + className, style: style },
	        _react2['default'].createElement('input', {
	          className: prefixCls + '-input',
	          ref: 'picker', type: 'text', placeholder: placeholder,
	          readOnly: true,
	          onKeyDown: this.onKeyDown,
	          disabled: disabled, value: value && this.getFormatter().format(value) || ''
	        }),
	        _react2['default'].createElement('span', { className: prefixCls + '-icon' })
	      )
	    );
	  }
	});

	exports['default'] = Picker;
	module.exports = exports['default'];

/***/ },
/* 90 */
[759, 91],
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(4);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _rcUtil = __webpack_require__(92);

	var _Popup = __webpack_require__(113);

	var _Popup2 = _interopRequireDefault(_Popup);

	var _utils = __webpack_require__(136);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function noop() {}

	function returnEmptyString() {
	  return '';
	}

	var ALL_HANDLERS = ['onClick', 'onMouseDown', 'onTouchStart', 'onMouseEnter', 'onMouseLeave', 'onFocus', 'onBlur'];

	var Trigger = _react2["default"].createClass({
	  displayName: 'Trigger',

	  propTypes: {
	    action: _react.PropTypes.any,
	    showAction: _react.PropTypes.any,
	    hideAction: _react.PropTypes.any,
	    getPopupClassNameFromAlign: _react.PropTypes.any,
	    onPopupVisibleChange: _react.PropTypes.func,
	    afterPopupVisibleChange: _react.PropTypes.func,
	    popup: _react.PropTypes.node.isRequired,
	    popupStyle: _react.PropTypes.object,
	    prefixCls: _react.PropTypes.string,
	    popupClassName: _react.PropTypes.string,
	    popupPlacement: _react.PropTypes.string,
	    builtinPlacements: _react.PropTypes.object,
	    popupTransitionName: _react.PropTypes.string,
	    popupAnimation: _react.PropTypes.any,
	    mouseEnterDelay: _react.PropTypes.number,
	    mouseLeaveDelay: _react.PropTypes.number,
	    zIndex: _react.PropTypes.number,
	    focusDelay: _react.PropTypes.number,
	    blurDelay: _react.PropTypes.number,
	    getPopupContainer: _react.PropTypes.func,
	    destroyPopupOnHide: _react.PropTypes.bool,
	    mask: _react.PropTypes.bool,
	    onPopupAlign: _react.PropTypes.func,
	    popupAlign: _react.PropTypes.object,
	    popupVisible: _react.PropTypes.bool,
	    maskTransitionName: _react.PropTypes.string,
	    maskAnimation: _react.PropTypes.string
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      prefixCls: 'rc-trigger-popup',
	      getPopupClassNameFromAlign: returnEmptyString,
	      onPopupVisibleChange: noop,
	      afterPopupVisibleChange: noop,
	      onPopupAlign: noop,
	      popupClassName: '',
	      mouseEnterDelay: 0,
	      mouseLeaveDelay: 0.1,
	      focusDelay: 0,
	      blurDelay: 0.15,
	      popupStyle: {},
	      destroyPopupOnHide: false,
	      popupAlign: {},
	      defaultPopupVisible: false,
	      mask: false,
	      action: [],
	      showAction: [],
	      hideAction: []
	    };
	  },
	  getInitialState: function getInitialState() {
	    var props = this.props;
	    var popupVisible = void 0;
	    if ('popupVisible' in props) {
	      popupVisible = !!props.popupVisible;
	    } else {
	      popupVisible = !!props.defaultPopupVisible;
	    }
	    return {
	      popupVisible: popupVisible
	    };
	  },
	  componentDidMount: function componentDidMount() {
	    this.componentDidUpdate({}, {
	      popupVisible: this.state.popupVisible
	    });
	  },
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    if ('popupVisible' in nextProps) {
	      this.setState({
	        popupVisible: !!nextProps.popupVisible
	      });
	    }
	  },
	  componentDidUpdate: function componentDidUpdate(prevProps, prevState) {
	    var _this = this;

	    var props = this.props;
	    var state = this.state;
	    if (this.popupRendered) {
	      var _ret = function () {
	        var self = _this;
	        _reactDom2["default"].unstable_renderSubtreeIntoContainer(_this, _this.getPopupElement(), _this.getPopupContainer(), function renderPopup() {
	          /* eslint react/no-is-mounted:0 */
	          if (this.isMounted()) {
	            self.popupDomNode = this.getPopupDomNode();
	          } else {
	            self.popupDomNode = null;
	          }
	          if (prevState.popupVisible !== state.popupVisible) {
	            props.afterPopupVisibleChange(state.popupVisible);
	          }
	        });
	        if (props.action.indexOf('click') !== -1) {
	          if (state.popupVisible) {
	            if (!_this.clickOutsideHandler) {
	              _this.clickOutsideHandler = _rcUtil.Dom.addEventListener(document, 'mousedown', _this.onDocumentClick);
	              _this.touchOutsideHandler = _rcUtil.Dom.addEventListener(document, 'touchstart', _this.onDocumentClick);
	            }
	            return {
	              v: void 0
	            };
	          }
	        }
	        if (_this.clickOutsideHandler) {
	          _this.clickOutsideHandler.remove();
	          _this.touchOutsideHandler.remove();
	          _this.clickOutsideHandler = null;
	          _this.touchOutsideHandler = null;
	        }
	      }();

	      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
	    }
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    var popupContainer = this.popupContainer;
	    if (popupContainer) {
	      _reactDom2["default"].unmountComponentAtNode(popupContainer);
	      popupContainer.parentNode.removeChild(popupContainer);
	      this.popupContainer = null;
	    }
	    this.clearDelayTimer();
	    if (this.clickOutsideHandler) {
	      this.clickOutsideHandler.remove();
	      this.touchOutsideHandler.remove();
	      this.clickOutsideHandler = null;
	      this.touchOutsideHandler = null;
	    }
	  },
	  onMouseEnter: function onMouseEnter() {
	    this.delaySetPopupVisible(true, this.props.mouseEnterDelay);
	  },
	  onMouseLeave: function onMouseLeave() {
	    this.delaySetPopupVisible(false, this.props.mouseLeaveDelay);
	  },
	  onFocus: function onFocus() {
	    this.focusTime = Date.now();
	    this.delaySetPopupVisible(true, this.props.focusDelay);
	  },
	  onMouseDown: function onMouseDown() {
	    this.preClickTime = Date.now();
	  },
	  onTouchStart: function onTouchStart() {
	    this.preTouchTime = Date.now();
	  },
	  onBlur: function onBlur() {
	    this.delaySetPopupVisible(false, this.props.blurDelay);
	  },
	  onClick: function onClick(event) {
	    // focus will trigger click
	    if (this.focusTime) {
	      var preTime = void 0;
	      if (this.preClickTime && this.preTouchTime) {
	        preTime = Math.min(this.preClickTime, this.preTouchTime);
	      } else if (this.preClickTime) {
	        preTime = this.preClickTime;
	      } else if (this.preTouchTime) {
	        preTime = this.preTouchTime;
	      }
	      if (Math.abs(preTime - this.focusTime) < 20) {
	        return;
	      }
	      this.focusTime = 0;
	    }
	    this.preClickTime = 0;
	    this.preTouchTime = 0;
	    event.preventDefault();
	    var nextVisible = !this.state.popupVisible;
	    if (this.isClickToHide() && !nextVisible || nextVisible && this.isClickToShow()) {
	      this.setPopupVisible(!this.state.popupVisible);
	    }
	  },
	  onDocumentClick: function onDocumentClick(event) {
	    var target = event.target;
	    var root = (0, _reactDom.findDOMNode)(this);
	    var popupNode = this.getPopupDomNode();
	    if (!_rcUtil.Dom.contains(root, target) && !_rcUtil.Dom.contains(popupNode, target)) {
	      this.setPopupVisible(false);
	    }
	  },
	  getPopupDomNode: function getPopupDomNode() {
	    // for test
	    return this.popupDomNode;
	  },
	  getRootDomNode: function getRootDomNode() {
	    return _reactDom2["default"].findDOMNode(this);
	  },
	  getPopupContainer: function getPopupContainer() {
	    if (!this.popupContainer) {
	      this.popupContainer = document.createElement('div');
	      var mountNode = this.props.getPopupContainer ? this.props.getPopupContainer((0, _reactDom.findDOMNode)(this)) : document.body;
	      mountNode.appendChild(this.popupContainer);
	    }
	    return this.popupContainer;
	  },
	  getPopupClassNameFromAlign: function getPopupClassNameFromAlign(align) {
	    var className = [];
	    var props = this.props;
	    var popupPlacement = props.popupPlacement;
	    var builtinPlacements = props.builtinPlacements;
	    var prefixCls = props.prefixCls;

	    if (popupPlacement && builtinPlacements) {
	      className.push((0, _utils.getPopupClassNameFromAlign)(builtinPlacements, prefixCls, align));
	    }
	    if (props.getPopupClassNameFromAlign) {
	      className.push(props.getPopupClassNameFromAlign(align));
	    }
	    return className.join(' ');
	  },
	  getPopupAlign: function getPopupAlign() {
	    var props = this.props;
	    var popupPlacement = props.popupPlacement;
	    var popupAlign = props.popupAlign;
	    var builtinPlacements = props.builtinPlacements;

	    if (popupPlacement && builtinPlacements) {
	      return (0, _utils.getAlignFromPlacement)(builtinPlacements, popupPlacement, popupAlign);
	    }
	    return popupAlign;
	  },
	  getPopupElement: function getPopupElement() {
	    var props = this.props;
	    var state = this.state;
	    var mouseProps = {};
	    if (props.action.indexOf('hover') !== -1) {
	      mouseProps.onMouseEnter = this.onMouseEnter;
	      mouseProps.onMouseLeave = this.onMouseLeave;
	    }
	    return _react2["default"].createElement(
	      _Popup2["default"],
	      _extends({
	        prefixCls: props.prefixCls,
	        destroyPopupOnHide: props.destroyPopupOnHide,
	        visible: state.popupVisible,
	        className: props.popupClassName,
	        action: props.action,
	        align: this.getPopupAlign(),
	        onAlign: props.onPopupAlign,
	        animation: props.popupAnimation,
	        getClassNameFromAlign: this.getPopupClassNameFromAlign
	      }, mouseProps, {
	        getRootDomNode: this.getRootDomNode,
	        style: props.popupStyle,
	        mask: props.mask,
	        zIndex: props.zIndex,
	        transitionName: props.popupTransitionName,
	        maskAnimation: props.maskAnimation,
	        maskTransitionName: props.maskTransitionName
	      }),
	      props.popup
	    );
	  },
	  setPopupVisible: function setPopupVisible(popupVisible) {
	    this.clearDelayTimer();
	    if (this.state.popupVisible !== popupVisible) {
	      if (!('popupVisible' in this.props)) {
	        this.setState({
	          popupVisible: popupVisible
	        });
	      }
	      this.props.onPopupVisibleChange(popupVisible);
	    }
	  },
	  delaySetPopupVisible: function delaySetPopupVisible(visible, delayS) {
	    var _this2 = this;

	    var delay = delayS * 1000;
	    this.clearDelayTimer();
	    if (delay) {
	      this.delayTimer = setTimeout(function () {
	        _this2.setPopupVisible(visible);
	        _this2.clearDelayTimer();
	      }, delay);
	    } else {
	      this.setPopupVisible(visible);
	    }
	  },
	  clearDelayTimer: function clearDelayTimer() {
	    if (this.delayTimer) {
	      clearTimeout(this.delayTimer);
	      this.delayTimer = null;
	    }
	  },
	  isClickToShow: function isClickToShow() {
	    var _props = this.props;
	    var action = _props.action;
	    var showAction = _props.showAction;

	    return action.indexOf('click') !== -1 || showAction.indexOf('click') !== -1;
	  },
	  isClickToHide: function isClickToHide() {
	    var _props2 = this.props;
	    var action = _props2.action;
	    var hideAction = _props2.hideAction;

	    return action.indexOf('click') !== -1 || hideAction.indexOf('click') !== -1;
	  },
	  isMouseEnterToShow: function isMouseEnterToShow() {
	    var _props3 = this.props;
	    var action = _props3.action;
	    var showAction = _props3.showAction;

	    return action.indexOf('hover') !== -1 || showAction.indexOf('mouseEnter') !== -1;
	  },
	  isMouseLeaveToHide: function isMouseLeaveToHide() {
	    var _props4 = this.props;
	    var action = _props4.action;
	    var hideAction = _props4.hideAction;

	    return action.indexOf('hover') !== -1 || hideAction.indexOf('mouseLeave') !== -1;
	  },
	  isFocusToShow: function isFocusToShow() {
	    var _props5 = this.props;
	    var action = _props5.action;
	    var showAction = _props5.showAction;

	    return action.indexOf('focus') !== -1 || showAction.indexOf('focus') !== -1;
	  },
	  isBlurToHide: function isBlurToHide() {
	    var _props6 = this.props;
	    var action = _props6.action;
	    var hideAction = _props6.hideAction;

	    return action.indexOf('focus') !== -1 || hideAction.indexOf('blur') !== -1;
	  },
	  render: function render() {
	    this.popupRendered = this.popupRendered || this.state.popupVisible;
	    var props = this.props;
	    var children = props.children;
	    var child = _react2["default"].Children.only(children);
	    var childProps = child.props || {};
	    var newChildProps = {};

	    if (this.isClickToHide() || this.isClickToShow()) {
	      newChildProps.onClick = (0, _rcUtil.createChainedFunction)(this.onClick, childProps.onClick);
	      newChildProps.onMouseDown = (0, _rcUtil.createChainedFunction)(this.onMouseDown, childProps.onMouseDown);
	      newChildProps.onTouchStart = (0, _rcUtil.createChainedFunction)(this.onTouchStart, childProps.onTouchStart);
	    }
	    if (this.isMouseEnterToShow()) {
	      newChildProps.onMouseEnter = (0, _rcUtil.createChainedFunction)(this.onMouseEnter, childProps.onMouseEnter);
	    }
	    if (this.isMouseLeaveToHide()) {
	      newChildProps.onMouseLeave = (0, _rcUtil.createChainedFunction)(this.onMouseLeave, childProps.onMouseLeave);
	    }
	    if (this.isFocusToShow()) {
	      newChildProps.onFocus = (0, _rcUtil.createChainedFunction)(this.onFocus, childProps.onFocus);
	    }
	    if (this.isBlurToHide()) {
	      newChildProps.onBlur = (0, _rcUtil.createChainedFunction)(this.onBlur, childProps.onBlur);
	    }

	    ALL_HANDLERS.forEach(function (handler) {
	      var newFn = void 0;
	      if (props[handler] && newChildProps[handler]) {
	        newFn = (0, _rcUtil.createChainedFunction)(props[handler], newChildProps[handler]);
	      } else {
	        newFn = props[handler] || newChildProps[handler];
	      }
	      if (newFn) {
	        newChildProps[handler] = newFn;
	      }
	    });

	    return _react2["default"].cloneElement(child, newChildProps);
	  }
	});

	exports["default"] = Trigger;
	module.exports = exports['default'];

/***/ },
/* 92 */
[749, 93, 94, 96, 97, 98, 99, 104, 105, 110, 111, 112],
/* 93 */
17,
/* 94 */
[750, 95],
/* 95 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/**
	 * Module exports.
	 */

	module.exports = deprecate;

	/**
	 * Mark that a method should not be used.
	 * Returns a modified function which warns once by default.
	 *
	 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
	 *
	 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
	 * will throw an Error when invoked.
	 *
	 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
	 * will invoke `console.trace()` instead of `console.error()`.
	 *
	 * @param {Function} fn - the function to deprecate
	 * @param {String} msg - the string to print to the console when `fn` is invoked
	 * @returns {Function} a new "deprecated" version of `fn`
	 * @api public
	 */

	function deprecate (fn, msg) {
	  if (config('noDeprecation')) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (config('throwDeprecation')) {
	        throw new Error(msg);
	      } else if (config('traceDeprecation')) {
	        console.trace(msg);
	      } else {
	        console.warn(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	}

	/**
	 * Checks `localStorage` for boolean values for the given `name`.
	 *
	 * @param {String} name
	 * @returns {Boolean}
	 * @api private
	 */

	function config (name) {
	  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
	  try {
	    if (!global.localStorage) return false;
	  } catch (_) {
	    return false;
	  }
	  var val = global.localStorage[name];
	  if (null == val) return false;
	  return String(val).toLowerCase() === 'true';
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 96 */
[751, 95],
/* 97 */
21,
/* 98 */
[752, 99],
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var fetchKeys = __webpack_require__(100);

	module.exports = function shallowEqual(objA, objB, compare, compareContext) {

	    var ret = compare ? compare.call(compareContext, objA, objB) : void 0;

	    if (ret !== void 0) {
	        return !!ret;
	    }

	    if (objA === objB) {
	        return true;
	    }

	    if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
	        return false;
	    }

	    var keysA = fetchKeys(objA);
	    var keysB = fetchKeys(objB);

	    var len = keysA.length;
	    if (len !== keysB.length) {
	        return false;
	    }

	    compareContext = compareContext || null;

	    // Test for A's keys different from B.
	    var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
	    for (var i = 0; i < len; i++) {
	        var key = keysA[i];
	        if (!bHasOwnProperty(key)) {
	            return false;
	        }
	        var valueA = objA[key];
	        var valueB = objB[key];

	        var _ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;
	        if (_ret === false || _ret === void 0 && valueA !== valueB) {
	            return false;
	        }
	    }

	    return true;
	};

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * lodash 3.1.2 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	var getNative = __webpack_require__(101),
	    isArguments = __webpack_require__(102),
	    isArray = __webpack_require__(103);

	/** Used to detect unsigned integer values. */
	var reIsUint = /^\d+$/;

	/** Used for native method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/* Native method references for those with the same name as other `lodash` methods. */
	var nativeKeys = getNative(Object, 'keys');

	/**
	 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
	 * of an array-like value.
	 */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	/**
	 * Gets the "length" property value of `object`.
	 *
	 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
	 * that affects Safari on at least iOS 8.1-8.3 ARM64.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {*} Returns the "length" value.
	 */
	var getLength = baseProperty('length');

	/**
	 * Checks if `value` is array-like.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 */
	function isArrayLike(value) {
	  return value != null && isLength(getLength(value));
	}

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return value > -1 && value % 1 == 0 && value < length;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 */
	function isLength(value) {
	  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * A fallback implementation of `Object.keys` which creates an array of the
	 * own enumerable property names of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function shimKeys(object) {
	  var props = keysIn(object),
	      propsLength = props.length,
	      length = propsLength && object.length;

	  var allowIndexes = !!length && isLength(length) &&
	    (isArray(object) || isArguments(object));

	  var index = -1,
	      result = [];

	  while (++index < propsLength) {
	    var key = props[index];
	    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	var keys = !nativeKeys ? shimKeys : function(object) {
	  var Ctor = object == null ? undefined : object.constructor;
	  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
	      (typeof object != 'function' && isArrayLike(object))) {
	    return shimKeys(object);
	  }
	  return isObject(object) ? nativeKeys(object) : [];
	};

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn(object) {
	  if (object == null) {
	    return [];
	  }
	  if (!isObject(object)) {
	    object = Object(object);
	  }
	  var length = object.length;
	  length = (length && isLength(length) &&
	    (isArray(object) || isArguments(object)) && length) || 0;

	  var Ctor = object.constructor,
	      index = -1,
	      isProto = typeof Ctor == 'function' && Ctor.prototype === object,
	      result = Array(length),
	      skipIndexes = length > 0;

	  while (++index < length) {
	    result[index] = (index + '');
	  }
	  for (var key in object) {
	    if (!(skipIndexes && isIndex(key, length)) &&
	        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = keys;


/***/ },
/* 101 */
/***/ function(module, exports) {

	/**
	 * lodash 3.9.1 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/** `Object#toString` result references. */
	var funcTag = '[object Function]';

	/** Used to detect host constructors (Safari > 5). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/**
	 * Checks if `value` is object-like.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/** Used for native method references. */
	var objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var fnToString = Function.prototype.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = object == null ? undefined : object[key];
	  return isNative(value) ? value : undefined;
	}

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in older versions of Chrome and Safari which return 'function' for regexes
	  // and Safari 8 equivalents which return 'object' for typed array constructors.
	  return isObject(value) && objToString.call(value) == funcTag;
	}

	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is a native function.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
	 * @example
	 *
	 * _.isNative(Array.prototype.push);
	 * // => true
	 *
	 * _.isNative(_);
	 * // => false
	 */
	function isNative(value) {
	  if (value == null) {
	    return false;
	  }
	  if (isFunction(value)) {
	    return reIsNative.test(fnToString.call(value));
	  }
	  return isObjectLike(value) && reIsHostCtor.test(value);
	}

	module.exports = getNative;


/***/ },
/* 102 */
/***/ function(module, exports) {

	/**
	 * lodash 3.0.8 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	/**
	 * Gets the "length" property value of `object`.
	 *
	 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
	 * that affects Safari on at least iOS 8.1-8.3 ARM64.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {*} Returns the "length" value.
	 */
	var getLength = baseProperty('length');

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	function isArguments(value) {
	  // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.
	  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
	    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
	}

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(getLength(value)) && !isFunction(value);
	}

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object, else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 8 which returns 'object' for typed array and weak map constructors,
	  // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
	  var tag = isObject(value) ? objectToString.call(value) : '';
	  return tag == funcTag || tag == genTag;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This function is loosely based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	module.exports = isArguments;


/***/ },
/* 103 */
/***/ function(module, exports) {

	/**
	 * lodash 3.0.4 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/** `Object#toString` result references. */
	var arrayTag = '[object Array]',
	    funcTag = '[object Function]';

	/** Used to detect host constructors (Safari > 5). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/**
	 * Checks if `value` is object-like.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/** Used for native method references. */
	var objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var fnToString = Function.prototype.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/* Native method references for those with the same name as other `lodash` methods. */
	var nativeIsArray = getNative(Array, 'isArray');

	/**
	 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
	 * of an array-like value.
	 */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = object == null ? undefined : object[key];
	  return isNative(value) ? value : undefined;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 */
	function isLength(value) {
	  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(function() { return arguments; }());
	 * // => false
	 */
	var isArray = nativeIsArray || function(value) {
	  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
	};

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in older versions of Chrome and Safari which return 'function' for regexes
	  // and Safari 8 equivalents which return 'object' for typed array constructors.
	  return isObject(value) && objToString.call(value) == funcTag;
	}

	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is a native function.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
	 * @example
	 *
	 * _.isNative(Array.prototype.push);
	 * // => true
	 *
	 * _.isNative(_);
	 * // => false
	 */
	function isNative(value) {
	  if (value == null) {
	    return false;
	  }
	  if (isFunction(value)) {
	    return reIsNative.test(fnToString.call(value));
	  }
	  return isObjectLike(value) && reIsHostCtor.test(value);
	}

	module.exports = isArray;


/***/ },
/* 104 */
28,
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = addEventListenerWrap;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _addDomEventListener = __webpack_require__(106);

	var _addDomEventListener2 = _interopRequireDefault(_addDomEventListener);

	var _reactDom = __webpack_require__(4);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	function addEventListenerWrap(target, eventType, cb) {
	  /* eslint camelcase: 2 */
	  var callback = _reactDom2['default'].unstable_batchedUpdates ? function run(e) {
	    _reactDom2['default'].unstable_batchedUpdates(cb, e);
	  } : cb;
	  return (0, _addDomEventListener2['default'])(target, eventType, callback);
	}

	module.exports = exports['default'];

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = addEventListener;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _EventObject = __webpack_require__(107);

	var _EventObject2 = _interopRequireDefault(_EventObject);

	function addEventListener(target, eventType, callback) {
	  function wrapCallback(e) {
	    var ne = new _EventObject2['default'](e);
	    callback.call(target, ne);
	  }

	  if (target.addEventListener) {
	    target.addEventListener(eventType, wrapCallback, false);
	    return {
	      remove: function remove() {
	        target.removeEventListener(eventType, wrapCallback, false);
	      }
	    };
	  } else if (target.attachEvent) {
	    target.attachEvent('on' + eventType, wrapCallback);
	    return {
	      remove: function remove() {
	        target.detachEvent('on' + eventType, wrapCallback);
	      }
	    };
	  }
	}

	module.exports = exports['default'];

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @ignore
	 * event object for dom
	 * @author yiminghe@gmail.com
	 */

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _EventBaseObject = __webpack_require__(108);

	var _EventBaseObject2 = _interopRequireDefault(_EventBaseObject);

	var _objectAssign = __webpack_require__(109);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	var TRUE = true;
	var FALSE = false;
	var commonProps = ['altKey', 'bubbles', 'cancelable', 'ctrlKey', 'currentTarget', 'eventPhase', 'metaKey', 'shiftKey', 'target', 'timeStamp', 'view', 'type'];

	function isNullOrUndefined(w) {
	  return w === null || w === undefined;
	}

	var eventNormalizers = [{
	  reg: /^key/,
	  props: ['char', 'charCode', 'key', 'keyCode', 'which'],
	  fix: function fix(event, nativeEvent) {
	    if (isNullOrUndefined(event.which)) {
	      event.which = !isNullOrUndefined(nativeEvent.charCode) ? nativeEvent.charCode : nativeEvent.keyCode;
	    }

	    // add metaKey to non-Mac browsers (use ctrl for PC 's and Meta for Macs)
	    if (event.metaKey === undefined) {
	      event.metaKey = event.ctrlKey;
	    }
	  }
	}, {
	  reg: /^touch/,
	  props: ['touches', 'changedTouches', 'targetTouches']
	}, {
	  reg: /^hashchange$/,
	  props: ['newURL', 'oldURL']
	}, {
	  reg: /^gesturechange$/i,
	  props: ['rotation', 'scale']
	}, {
	  reg: /^(mousewheel|DOMMouseScroll)$/,
	  props: [],
	  fix: function fix(event, nativeEvent) {
	    var deltaX = undefined;
	    var deltaY = undefined;
	    var delta = undefined;
	    var wheelDelta = nativeEvent.wheelDelta;
	    var axis = nativeEvent.axis;
	    var wheelDeltaY = nativeEvent.wheelDeltaY;
	    var wheelDeltaX = nativeEvent.wheelDeltaX;
	    var detail = nativeEvent.detail;

	    // ie/webkit
	    if (wheelDelta) {
	      delta = wheelDelta / 120;
	    }

	    // gecko
	    if (detail) {
	      // press control e.detail == 1 else e.detail == 3
	      delta = 0 - (detail % 3 === 0 ? detail / 3 : detail);
	    }

	    // Gecko
	    if (axis !== undefined) {
	      if (axis === event.HORIZONTAL_AXIS) {
	        deltaY = 0;
	        deltaX = 0 - delta;
	      } else if (axis === event.VERTICAL_AXIS) {
	        deltaX = 0;
	        deltaY = delta;
	      }
	    }

	    // Webkit
	    if (wheelDeltaY !== undefined) {
	      deltaY = wheelDeltaY / 120;
	    }
	    if (wheelDeltaX !== undefined) {
	      deltaX = -1 * wheelDeltaX / 120;
	    }

	    // 默认 deltaY (ie)
	    if (!deltaX && !deltaY) {
	      deltaY = delta;
	    }

	    if (deltaX !== undefined) {
	      /**
	       * deltaX of mousewheel event
	       * @property deltaX
	       * @member Event.DomEvent.Object
	       */
	      event.deltaX = deltaX;
	    }

	    if (deltaY !== undefined) {
	      /**
	       * deltaY of mousewheel event
	       * @property deltaY
	       * @member Event.DomEvent.Object
	       */
	      event.deltaY = deltaY;
	    }

	    if (delta !== undefined) {
	      /**
	       * delta of mousewheel event
	       * @property delta
	       * @member Event.DomEvent.Object
	       */
	      event.delta = delta;
	    }
	  }
	}, {
	  reg: /^mouse|contextmenu|click|mspointer|(^DOMMouseScroll$)/i,
	  props: ['buttons', 'clientX', 'clientY', 'button', 'offsetX', 'relatedTarget', 'which', 'fromElement', 'toElement', 'offsetY', 'pageX', 'pageY', 'screenX', 'screenY'],
	  fix: function fix(event, nativeEvent) {
	    var eventDoc = undefined;
	    var doc = undefined;
	    var body = undefined;
	    var target = event.target;
	    var button = nativeEvent.button;

	    // Calculate pageX/Y if missing and clientX/Y available
	    if (target && isNullOrUndefined(event.pageX) && !isNullOrUndefined(nativeEvent.clientX)) {
	      eventDoc = target.ownerDocument || document;
	      doc = eventDoc.documentElement;
	      body = eventDoc.body;
	      event.pageX = nativeEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
	      event.pageY = nativeEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
	    }

	    // which for click: 1 === left; 2 === middle; 3 === right
	    // do not use button
	    if (!event.which && button !== undefined) {
	      if (button & 1) {
	        event.which = 1;
	      } else if (button & 2) {
	        event.which = 3;
	      } else if (button & 4) {
	        event.which = 2;
	      } else {
	        event.which = 0;
	      }
	    }

	    // add relatedTarget, if necessary
	    if (!event.relatedTarget && event.fromElement) {
	      event.relatedTarget = event.fromElement === target ? event.toElement : event.fromElement;
	    }

	    return event;
	  }
	}];

	function retTrue() {
	  return TRUE;
	}

	function retFalse() {
	  return FALSE;
	}

	function DomEventObject(nativeEvent) {
	  var type = nativeEvent.type;

	  var isNative = typeof nativeEvent.stopPropagation === 'function' || typeof nativeEvent.cancelBubble === 'boolean';

	  _EventBaseObject2['default'].call(this);

	  this.nativeEvent = nativeEvent;

	  // in case dom event has been mark as default prevented by lower dom node
	  var isDefaultPrevented = retFalse;
	  if ('defaultPrevented' in nativeEvent) {
	    isDefaultPrevented = nativeEvent.defaultPrevented ? retTrue : retFalse;
	  } else if ('getPreventDefault' in nativeEvent) {
	    // https://bugzilla.mozilla.org/show_bug.cgi?id=691151
	    isDefaultPrevented = nativeEvent.getPreventDefault() ? retTrue : retFalse;
	  } else if ('returnValue' in nativeEvent) {
	    isDefaultPrevented = nativeEvent.returnValue === FALSE ? retTrue : retFalse;
	  }

	  this.isDefaultPrevented = isDefaultPrevented;

	  var fixFns = [];
	  var fixFn = undefined;
	  var l = undefined;
	  var prop = undefined;
	  var props = commonProps.concat();

	  eventNormalizers.forEach(function (normalizer) {
	    if (type.match(normalizer.reg)) {
	      props = props.concat(normalizer.props);
	      if (normalizer.fix) {
	        fixFns.push(normalizer.fix);
	      }
	    }
	  });

	  l = props.length;

	  // clone properties of the original event object
	  while (l) {
	    prop = props[--l];
	    this[prop] = nativeEvent[prop];
	  }

	  // fix target property, if necessary
	  if (!this.target && isNative) {
	    this.target = nativeEvent.srcElement || document; // srcElement might not be defined either
	  }

	  // check if target is a text node (safari)
	  if (this.target && this.target.nodeType === 3) {
	    this.target = this.target.parentNode;
	  }

	  l = fixFns.length;

	  while (l) {
	    fixFn = fixFns[--l];
	    fixFn(this, nativeEvent);
	  }

	  this.timeStamp = nativeEvent.timeStamp || Date.now();
	}

	var EventBaseObjectProto = _EventBaseObject2['default'].prototype;

	(0, _objectAssign2['default'])(DomEventObject.prototype, EventBaseObjectProto, {
	  constructor: DomEventObject,

	  preventDefault: function preventDefault() {
	    var e = this.nativeEvent;

	    // if preventDefault exists run it on the original event
	    if (e.preventDefault) {
	      e.preventDefault();
	    } else {
	      // otherwise set the returnValue property of the original event to FALSE (IE)
	      e.returnValue = FALSE;
	    }

	    EventBaseObjectProto.preventDefault.call(this);
	  },

	  stopPropagation: function stopPropagation() {
	    var e = this.nativeEvent;

	    // if stopPropagation exists run it on the original event
	    if (e.stopPropagation) {
	      e.stopPropagation();
	    } else {
	      // otherwise set the cancelBubble property of the original event to TRUE (IE)
	      e.cancelBubble = TRUE;
	    }

	    EventBaseObjectProto.stopPropagation.call(this);
	  }
	});

	exports['default'] = DomEventObject;
	module.exports = exports['default'];

/***/ },
/* 108 */
32,
/* 109 */
/***/ function(module, exports) {

	/* eslint-disable no-unused-vars */
	'use strict';
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	module.exports = Object.assign || function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (Object.getOwnPropertySymbols) {
				symbols = Object.getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};


/***/ },
/* 110 */
34,
/* 111 */
35,
/* 112 */
36,
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(4);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _rcAlign = __webpack_require__(114);

	var _rcAlign2 = _interopRequireDefault(_rcAlign);

	var _rcAnimate = __webpack_require__(125);

	var _rcAnimate2 = _interopRequireDefault(_rcAnimate);

	var _PopupInner = __webpack_require__(134);

	var _PopupInner2 = _interopRequireDefault(_PopupInner);

	var _LazyRenderBox = __webpack_require__(135);

	var _LazyRenderBox2 = _interopRequireDefault(_LazyRenderBox);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var Popup = _react2["default"].createClass({
	  displayName: 'Popup',

	  propTypes: {
	    visible: _react.PropTypes.bool,
	    style: _react.PropTypes.object,
	    getClassNameFromAlign: _react.PropTypes.func,
	    onAlign: _react.PropTypes.func,
	    getRootDomNode: _react.PropTypes.func,
	    onMouseEnter: _react.PropTypes.func,
	    align: _react.PropTypes.any,
	    destroyPopupOnHide: _react.PropTypes.bool,
	    className: _react.PropTypes.string,
	    prefixCls: _react.PropTypes.string,
	    onMouseLeave: _react.PropTypes.func
	  },

	  componentDidMount: function componentDidMount() {
	    this.rootNode = this.getPopupDomNode();
	  },
	  onAlign: function onAlign(popupDomNode, align) {
	    var props = this.props;
	    var alignClassName = props.getClassNameFromAlign(props.align);
	    var currentAlignClassName = props.getClassNameFromAlign(align);
	    if (alignClassName !== currentAlignClassName) {
	      this.currentAlignClassName = currentAlignClassName;
	      popupDomNode.className = this.getClassName(currentAlignClassName);
	    }
	    props.onAlign(popupDomNode, align);
	  },
	  getPopupDomNode: function getPopupDomNode() {
	    return _reactDom2["default"].findDOMNode(this.refs.popup);
	  },
	  getTarget: function getTarget() {
	    return this.props.getRootDomNode();
	  },
	  getMaskTransitionName: function getMaskTransitionName() {
	    var props = this.props;
	    var transitionName = props.maskTransitionName;
	    var animation = props.maskAnimation;
	    if (!transitionName && animation) {
	      transitionName = props.prefixCls + '-' + animation;
	    }
	    return transitionName;
	  },
	  getTransitionName: function getTransitionName() {
	    var props = this.props;
	    var transitionName = props.transitionName;
	    if (!transitionName && props.animation) {
	      transitionName = props.prefixCls + '-' + props.animation;
	    }
	    return transitionName;
	  },
	  getClassName: function getClassName(currentAlignClassName) {
	    return this.props.prefixCls + ' ' + this.props.className + ' ' + currentAlignClassName;
	  },
	  getPopupElement: function getPopupElement() {
	    var props = this.props;
	    var align = props.align;
	    var style = props.style;
	    var visible = props.visible;
	    var prefixCls = props.prefixCls;
	    var destroyPopupOnHide = props.destroyPopupOnHide;

	    var className = this.getClassName(this.currentAlignClassName || props.getClassNameFromAlign(align));
	    var hiddenClassName = prefixCls + '-hidden';
	    if (!visible) {
	      this.currentAlignClassName = null;
	    }
	    var newStyle = _extends({}, style, this.getZIndexStyle());
	    var popupInnerProps = {
	      className: className,
	      prefixCls: prefixCls,
	      ref: 'popup',
	      onMouseEnter: props.onMouseEnter,
	      onMouseLeave: props.onMouseLeave,
	      style: newStyle
	    };
	    if (destroyPopupOnHide) {
	      return _react2["default"].createElement(
	        _rcAnimate2["default"],
	        {
	          component: '',
	          exclusive: true,
	          transitionAppear: true,
	          transitionName: this.getTransitionName()
	        },
	        visible ? _react2["default"].createElement(
	          _rcAlign2["default"],
	          {
	            target: this.getTarget,
	            key: 'popup',
	            monitorWindowResize: true,
	            align: align,
	            onAlign: this.onAlign
	          },
	          _react2["default"].createElement(
	            _PopupInner2["default"],
	            _extends({
	              visible: true
	            }, popupInnerProps),
	            props.children
	          )
	        ) : null
	      );
	    }
	    return _react2["default"].createElement(
	      _rcAnimate2["default"],
	      {
	        component: '',
	        exclusive: true,
	        transitionAppear: true,
	        transitionName: this.getTransitionName(),
	        showProp: 'xVisible'
	      },
	      _react2["default"].createElement(
	        _rcAlign2["default"],
	        {
	          target: this.getTarget,
	          key: 'popup',
	          monitorWindowResize: true,
	          xVisible: visible,
	          childrenProps: { visible: 'xVisible' },
	          disabled: !visible,
	          align: align,
	          onAlign: this.onAlign
	        },
	        _react2["default"].createElement(
	          _PopupInner2["default"],
	          _extends({
	            hiddenClassName: hiddenClassName
	          }, popupInnerProps),
	          props.children
	        )
	      )
	    );
	  },
	  getZIndexStyle: function getZIndexStyle() {
	    var style = {};
	    var props = this.props;
	    if (props.zIndex !== undefined) {
	      style.zIndex = props.zIndex;
	    }
	    return style;
	  },
	  getMaskElement: function getMaskElement() {
	    var props = this.props;
	    var maskElement = void 0;
	    if (props.mask) {
	      var maskTransition = this.getMaskTransitionName();
	      maskElement = _react2["default"].createElement(_LazyRenderBox2["default"], {
	        style: this.getZIndexStyle(),
	        key: 'mask',
	        className: props.prefixCls + '-mask',
	        hiddenClassName: props.prefixCls + '-mask-hidden',
	        visible: props.visible
	      });
	      if (maskTransition) {
	        maskElement = _react2["default"].createElement(
	          _rcAnimate2["default"],
	          {
	            key: 'mask',
	            showProp: 'visible',
	            transitionAppear: true,
	            component: '',
	            transitionName: maskTransition
	          },
	          maskElement
	        );
	      }
	    }
	    return maskElement;
	  },
	  render: function render() {
	    return _react2["default"].createElement(
	      'div',
	      null,
	      this.getMaskElement(),
	      this.getPopupElement()
	    );
	  }
	});

	exports["default"] = Popup;
	module.exports = exports['default'];

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	// export this package's api
	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _Align = __webpack_require__(115);

	var _Align2 = _interopRequireDefault(_Align);

	exports['default'] = _Align2['default'];
	module.exports = exports['default'];

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(4);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _domAlign = __webpack_require__(116);

	var _domAlign2 = _interopRequireDefault(_domAlign);

	var _rcUtil = __webpack_require__(92);

	var _isWindow = __webpack_require__(124);

	var _isWindow2 = _interopRequireDefault(_isWindow);

	function buffer(fn, ms) {
	  var timer = undefined;
	  return function bufferFn() {
	    if (timer) {
	      clearTimeout(timer);
	    }
	    timer = setTimeout(fn, ms);
	  };
	}

	var Align = _react2['default'].createClass({
	  displayName: 'Align',

	  propTypes: {
	    childrenProps: _react.PropTypes.object,
	    align: _react.PropTypes.object.isRequired,
	    target: _react.PropTypes.func,
	    onAlign: _react.PropTypes.func,
	    monitorBufferTime: _react.PropTypes.number,
	    monitorWindowResize: _react.PropTypes.bool,
	    disabled: _react.PropTypes.bool,
	    children: _react.PropTypes.any
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      target: function target() {
	        return window;
	      },
	      onAlign: function onAlign() {},
	      monitorBufferTime: 50,
	      monitorWindowResize: false,
	      disabled: false
	    };
	  },

	  componentDidMount: function componentDidMount() {
	    var props = this.props;
	    // if parent ref not attached .... use document.getElementById
	    if (!props.disabled) {
	      var source = _reactDom2['default'].findDOMNode(this);
	      props.onAlign(source, (0, _domAlign2['default'])(source, props.target(), props.align));
	      if (props.monitorWindowResize) {
	        this.startMonitorWindowResize();
	      }
	    }
	  },

	  componentDidUpdate: function componentDidUpdate(prevProps) {
	    var reAlign = false;
	    var props = this.props;
	    var currentTarget = undefined;

	    if (!props.disabled) {
	      if (prevProps.disabled || prevProps.align !== props.align) {
	        reAlign = true;
	        currentTarget = props.target();
	      } else {
	        var lastTarget = prevProps.target();
	        currentTarget = props.target();
	        if ((0, _isWindow2['default'])(lastTarget) && (0, _isWindow2['default'])(currentTarget)) {
	          reAlign = false;
	        } else if (lastTarget !== currentTarget) {
	          reAlign = true;
	        }
	      }
	    }

	    if (reAlign) {
	      var source = _reactDom2['default'].findDOMNode(this);
	      props.onAlign(source, (0, _domAlign2['default'])(source, currentTarget, props.align));
	    }

	    if (props.monitorWindowResize && !props.disabled) {
	      this.startMonitorWindowResize();
	    } else {
	      this.stopMonitorWindowResize();
	    }
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    this.stopMonitorWindowResize();
	  },

	  onWindowResize: function onWindowResize() {
	    var props = this.props;
	    if (!props.disabled) {
	      var source = _reactDom2['default'].findDOMNode(this);
	      props.onAlign(source, (0, _domAlign2['default'])(source, props.target(), props.align));
	    }
	  },

	  startMonitorWindowResize: function startMonitorWindowResize() {
	    if (!this.resizeHandler) {
	      this.resizeHandler = _rcUtil.Dom.addEventListener(window, 'resize', buffer(this.onWindowResize, this.props.monitorBufferTime));
	    }
	  },

	  stopMonitorWindowResize: function stopMonitorWindowResize() {
	    if (this.resizeHandler) {
	      this.resizeHandler.remove();
	      this.resizeHandler = null;
	    }
	  },

	  render: function render() {
	    var _props = this.props;
	    var childrenProps = _props.childrenProps;
	    var children = _props.children;

	    var child = _react2['default'].Children.only(children);
	    if (childrenProps) {
	      var newProps = {};
	      for (var prop in childrenProps) {
	        if (childrenProps.hasOwnProperty(prop)) {
	          newProps[prop] = this.props[childrenProps[prop]];
	        }
	      }
	      return _react2['default'].cloneElement(child, newProps);
	    }
	    return child;
	  }
	});

	exports['default'] = Align;
	module.exports = exports['default'];

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * align dom node flexibly
	 * @author yiminghe@gmail.com
	 */

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _utils = __webpack_require__(117);

	var _utils2 = _interopRequireDefault(_utils);

	var _getOffsetParent = __webpack_require__(118);

	var _getOffsetParent2 = _interopRequireDefault(_getOffsetParent);

	var _getVisibleRectForElement = __webpack_require__(119);

	var _getVisibleRectForElement2 = _interopRequireDefault(_getVisibleRectForElement);

	var _adjustForViewport = __webpack_require__(120);

	var _adjustForViewport2 = _interopRequireDefault(_adjustForViewport);

	var _getRegion = __webpack_require__(121);

	var _getRegion2 = _interopRequireDefault(_getRegion);

	var _getElFuturePos = __webpack_require__(122);

	var _getElFuturePos2 = _interopRequireDefault(_getElFuturePos);

	// http://yiminghe.iteye.com/blog/1124720

	function isFailX(elFuturePos, elRegion, visibleRect) {
	  return elFuturePos.left < visibleRect.left || elFuturePos.left + elRegion.width > visibleRect.right;
	}

	function isFailY(elFuturePos, elRegion, visibleRect) {
	  return elFuturePos.top < visibleRect.top || elFuturePos.top + elRegion.height > visibleRect.bottom;
	}

	function isCompleteFailX(elFuturePos, elRegion, visibleRect) {
	  return elFuturePos.left > visibleRect.right || elFuturePos.left + elRegion.width < visibleRect.left;
	}

	function isCompleteFailY(elFuturePos, elRegion, visibleRect) {
	  return elFuturePos.top > visibleRect.bottom || elFuturePos.top + elRegion.height < visibleRect.top;
	}

	function flip(points, reg, map) {
	  var ret = [];
	  _utils2['default'].each(points, function (p) {
	    ret.push(p.replace(reg, function (m) {
	      return map[m];
	    }));
	  });
	  return ret;
	}

	function flipOffset(offset, index) {
	  offset[index] = -offset[index];
	  return offset;
	}

	function convertOffset(str, offsetLen) {
	  var n = undefined;
	  if (/%$/.test(str)) {
	    n = parseInt(str.substring(0, str.length - 1), 10) / 100 * offsetLen;
	  } else {
	    n = parseInt(str, 10);
	  }
	  return n || 0;
	}

	function normalizeOffset(offset, el) {
	  offset[0] = convertOffset(offset[0], el.width);
	  offset[1] = convertOffset(offset[1], el.height);
	}

	function domAlign(el, refNode, align) {
	  var points = align.points;
	  var offset = align.offset || [0, 0];
	  var targetOffset = align.targetOffset || [0, 0];
	  var overflow = align.overflow;
	  var target = align.target || refNode;
	  var source = align.source || el;
	  offset = [].concat(offset);
	  targetOffset = [].concat(targetOffset);
	  overflow = overflow || {};
	  var newOverflowCfg = {};

	  var fail = 0;
	  // 当前节点可以被放置的显示区域
	  var visibleRect = (0, _getVisibleRectForElement2['default'])(source);
	  // 当前节点所占的区域, left/top/width/height
	  var elRegion = (0, _getRegion2['default'])(source);
	  // 参照节点所占的区域, left/top/width/height
	  var refNodeRegion = (0, _getRegion2['default'])(target);
	  // 将 offset 转换成数值，支持百分比
	  normalizeOffset(offset, elRegion);
	  normalizeOffset(targetOffset, refNodeRegion);
	  // 当前节点将要被放置的位置
	  var elFuturePos = (0, _getElFuturePos2['default'])(elRegion, refNodeRegion, points, offset, targetOffset);
	  // 当前节点将要所处的区域
	  var newElRegion = _utils2['default'].merge(elRegion, elFuturePos);

	  // 如果可视区域不能完全放置当前节点时允许调整
	  if (visibleRect && (overflow.adjustX || overflow.adjustY)) {
	    if (overflow.adjustX) {
	      // 如果横向不能放下
	      if (isFailX(elFuturePos, elRegion, visibleRect)) {
	        // 对齐位置反下
	        var newPoints = flip(points, /[lr]/ig, {
	          l: 'r',
	          r: 'l'
	        });
	        // 偏移量也反下
	        var newOffset = flipOffset(offset, 0);
	        var newTargetOffset = flipOffset(targetOffset, 0);
	        var newElFuturePos = (0, _getElFuturePos2['default'])(elRegion, refNodeRegion, newPoints, newOffset, newTargetOffset);
	        if (!isCompleteFailX(newElFuturePos, elRegion, visibleRect)) {
	          fail = 1;
	          points = newPoints;
	          offset = newOffset;
	          targetOffset = newTargetOffset;
	        }
	      }
	    }

	    if (overflow.adjustY) {
	      // 如果纵向不能放下
	      if (isFailY(elFuturePos, elRegion, visibleRect)) {
	        // 对齐位置反下
	        var newPoints = flip(points, /[tb]/ig, {
	          t: 'b',
	          b: 't'
	        });
	        // 偏移量也反下
	        var newOffset = flipOffset(offset, 1);
	        var newTargetOffset = flipOffset(targetOffset, 1);
	        var newElFuturePos = (0, _getElFuturePos2['default'])(elRegion, refNodeRegion, newPoints, newOffset, newTargetOffset);
	        if (!isCompleteFailY(newElFuturePos, elRegion, visibleRect)) {
	          fail = 1;
	          points = newPoints;
	          offset = newOffset;
	          targetOffset = newTargetOffset;
	        }
	      }
	    }

	    // 如果失败，重新计算当前节点将要被放置的位置
	    if (fail) {
	      elFuturePos = (0, _getElFuturePos2['default'])(elRegion, refNodeRegion, points, offset, targetOffset);
	      _utils2['default'].mix(newElRegion, elFuturePos);
	    }

	    // 检查反下后的位置是否可以放下了
	    // 如果仍然放不下只有指定了可以调整当前方向才调整
	    newOverflowCfg.adjustX = overflow.adjustX && isFailX(elFuturePos, elRegion, visibleRect);

	    newOverflowCfg.adjustY = overflow.adjustY && isFailY(elFuturePos, elRegion, visibleRect);

	    // 确实要调整，甚至可能会调整高度宽度
	    if (newOverflowCfg.adjustX || newOverflowCfg.adjustY) {
	      newElRegion = (0, _adjustForViewport2['default'])(elFuturePos, elRegion, visibleRect, newOverflowCfg);
	    }
	  }

	  // need judge to in case set fixed with in css on height auto element
	  if (newElRegion.width !== elRegion.width) {
	    _utils2['default'].css(source, 'width', source.width() + newElRegion.width - elRegion.width);
	  }

	  if (newElRegion.height !== elRegion.height) {
	    _utils2['default'].css(source, 'height', source.height() + newElRegion.height - elRegion.height);
	  }

	  // https://github.com/kissyteam/kissy/issues/190
	  // http://localhost:8888/kissy/src/overlay/demo/other/relative_align/align.html
	  // 相对于屏幕位置没变，而 left/top 变了
	  // 例如 <div 'relative'><el absolute></div>
	  _utils2['default'].offset(source, {
	    left: newElRegion.left,
	    top: newElRegion.top
	  }, {
	    useCssRight: align.useCssRight,
	    useCssBottom: align.useCssBottom
	  });

	  return {
	    points: points,
	    offset: offset,
	    targetOffset: targetOffset,
	    overflow: newOverflowCfg
	  };
	}

	domAlign.__getOffsetParent = _getOffsetParent2['default'];

	domAlign.__getVisibleRectForElement = _getVisibleRectForElement2['default'];

	exports['default'] = domAlign;

	/**
	 *  2012-04-26 yiminghe@gmail.com
	 *   - 优化智能对齐算法
	 *   - 慎用 resizeXX
	 *
	 *  2011-07-13 yiminghe@gmail.com note:
	 *   - 增加智能对齐，以及大小调整选项
	 **/
	module.exports = exports['default'];

/***/ },
/* 117 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;

	var getComputedStyleX = undefined;

	function css(el, name, v) {
	  var value = v;
	  if (typeof name === 'object') {
	    for (var i in name) {
	      if (name.hasOwnProperty(i)) {
	        css(el, i, name[i]);
	      }
	    }
	    return undefined;
	  }
	  if (typeof value !== 'undefined') {
	    if (typeof value === 'number') {
	      value = value + 'px';
	    }
	    el.style[name] = value;
	    return undefined;
	  }
	  return getComputedStyleX(el, name);
	}

	function getClientPosition(elem) {
	  var box = undefined;
	  var x = undefined;
	  var y = undefined;
	  var doc = elem.ownerDocument;
	  var body = doc.body;
	  var docElem = doc && doc.documentElement;
	  // 根据 GBS 最新数据，A-Grade Browsers 都已支持 getBoundingClientRect 方法，不用再考虑传统的实现方式
	  box = elem.getBoundingClientRect();

	  // 注：jQuery 还考虑减去 docElem.clientLeft/clientTop
	  // 但测试发现，这样反而会导致当 html 和 body 有边距/边框样式时，获取的值不正确
	  // 此外，ie6 会忽略 html 的 margin 值，幸运地是没有谁会去设置 html 的 margin

	  x = box.left;
	  y = box.top;

	  // In IE, most of the time, 2 extra pixels are added to the top and left
	  // due to the implicit 2-pixel inset border.  In IE6/7 quirks mode and
	  // IE6 standards mode, this border can be overridden by setting the
	  // document element's border to zero -- thus, we cannot rely on the
	  // offset always being 2 pixels.

	  // In quirks mode, the offset can be determined by querying the body's
	  // clientLeft/clientTop, but in standards mode, it is found by querying
	  // the document element's clientLeft/clientTop.  Since we already called
	  // getClientBoundingRect we have already forced a reflow, so it is not
	  // too expensive just to query them all.

	  // ie 下应该减去窗口的边框吧，毕竟默认 absolute 都是相对窗口定位的
	  // 窗口边框标准是设 documentElement ,quirks 时设置 body
	  // 最好禁止在 body 和 html 上边框 ，但 ie < 9 html 默认有 2px ，减去
	  // 但是非 ie 不可能设置窗口边框，body html 也不是窗口 ,ie 可以通过 html,body 设置
	  // 标准 ie 下 docElem.clientTop 就是 border-top
	  // ie7 html 即窗口边框改变不了。永远为 2
	  // 但标准 firefox/chrome/ie9 下 docElem.clientTop 是窗口边框，即使设了 border-top 也为 0

	  x -= docElem.clientLeft || body.clientLeft || 0;
	  y -= docElem.clientTop || body.clientTop || 0;

	  return { left: x, top: y };
	}

	function getScroll(w, top) {
	  var ret = w['page' + (top ? 'Y' : 'X') + 'Offset'];
	  var method = 'scroll' + (top ? 'Top' : 'Left');
	  if (typeof ret !== 'number') {
	    var d = w.document;
	    // ie6,7,8 standard mode
	    ret = d.documentElement[method];
	    if (typeof ret !== 'number') {
	      // quirks mode
	      ret = d.body[method];
	    }
	  }
	  return ret;
	}

	function getScrollLeft(w) {
	  return getScroll(w);
	}

	function getScrollTop(w) {
	  return getScroll(w, true);
	}

	function getOffset(el) {
	  var pos = getClientPosition(el);
	  var doc = el.ownerDocument;
	  var w = doc.defaultView || doc.parentWindow;
	  pos.left += getScrollLeft(w);
	  pos.top += getScrollTop(w);
	  return pos;
	}
	function _getComputedStyle(elem, name, cs) {
	  var computedStyle = cs;
	  var val = '';
	  var d = elem.ownerDocument;
	  computedStyle = computedStyle || d.defaultView.getComputedStyle(elem, null);

	  // https://github.com/kissyteam/kissy/issues/61
	  if (computedStyle) {
	    val = computedStyle.getPropertyValue(name) || computedStyle[name];
	  }

	  return val;
	}

	var _RE_NUM_NO_PX = new RegExp('^(' + RE_NUM + ')(?!px)[a-z%]+$', 'i');
	var RE_POS = /^(top|right|bottom|left)$/;
	var CURRENT_STYLE = 'currentStyle';
	var RUNTIME_STYLE = 'runtimeStyle';
	var LEFT = 'left';
	var PX = 'px';

	function _getComputedStyleIE(elem, name) {
	  // currentStyle maybe null
	  // http://msdn.microsoft.com/en-us/library/ms535231.aspx
	  var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name];

	  // 当 width/height 设置为百分比时，通过 pixelLeft 方式转换的 width/height 值
	  // 一开始就处理了! CUSTOM_STYLE.height,CUSTOM_STYLE.width ,cssHook 解决@2011-08-19
	  // 在 ie 下不对，需要直接用 offset 方式
	  // borderWidth 等值也有问题，但考虑到 borderWidth 设为百分比的概率很小，这里就不考虑了

	  // From the awesome hack by Dean Edwards
	  // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
	  // If we're not dealing with a regular pixel number
	  // but a number that has a weird ending, we need to convert it to pixels
	  // exclude left right for relativity
	  if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name)) {
	    // Remember the original values
	    var style = elem.style;
	    var left = style[LEFT];
	    var rsLeft = elem[RUNTIME_STYLE][LEFT];

	    // prevent flashing of content
	    elem[RUNTIME_STYLE][LEFT] = elem[CURRENT_STYLE][LEFT];

	    // Put in the new values to get a computed value out
	    style[LEFT] = name === 'fontSize' ? '1em' : ret || 0;
	    ret = style.pixelLeft + PX;

	    // Revert the changed values
	    style[LEFT] = left;

	    elem[RUNTIME_STYLE][LEFT] = rsLeft;
	  }
	  return ret === '' ? 'auto' : ret;
	}

	if (typeof window !== 'undefined') {
	  getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;
	}

	function getOffsetDirection(dir, option) {
	  if (dir === 'left') {
	    return option.useCssRight ? 'right' : dir;
	  }
	  return option.useCssBottom ? 'bottom' : dir;
	}

	function oppositeOffsetDirection(dir) {
	  if (dir === 'left') {
	    return 'right';
	  } else if (dir === 'right') {
	    return 'left';
	  } else if (dir === 'top') {
	    return 'bottom';
	  } else if (dir === 'bottom') {
	    return 'top';
	  }
	}

	// 设置 elem 相对 elem.ownerDocument 的坐标
	function setOffset(elem, offset, option) {
	  // set position first, in-case top/left are set even on static elem
	  if (css(elem, 'position') === 'static') {
	    elem.style.position = 'relative';
	  }
	  var presetH = -999;
	  var presetV = -999;
	  var horizontalProperty = getOffsetDirection('left', option);
	  var verticalProperty = getOffsetDirection('top', option);
	  var oppositeHorizontalProperty = oppositeOffsetDirection(horizontalProperty);
	  var oppositeVerticalProperty = oppositeOffsetDirection(verticalProperty);

	  if (horizontalProperty !== 'left') {
	    presetH = 999;
	  }

	  if (verticalProperty !== 'top') {
	    presetV = 999;
	  }

	  if ('left' in offset) {
	    elem.style[oppositeHorizontalProperty] = '';
	    elem.style[horizontalProperty] = presetH + 'px';
	  }
	  if ('top' in offset) {
	    elem.style[oppositeVerticalProperty] = '';
	    elem.style[verticalProperty] = presetV + 'px';
	  }
	  var old = getOffset(elem);
	  var ret = {};
	  var key = undefined;
	  for (key in offset) {
	    if (offset.hasOwnProperty(key)) {
	      var dir = getOffsetDirection(key, option);
	      var preset = key === 'left' ? presetH : presetV;
	      if (dir === key) {
	        ret[dir] = preset + offset[key] - old[key];
	      } else {
	        ret[dir] = preset + old[key] - offset[key];
	      }
	    }
	  }
	  css(elem, ret);
	}

	function each(arr, fn) {
	  for (var i = 0; i < arr.length; i++) {
	    fn(arr[i]);
	  }
	}

	function isBorderBoxFn(elem) {
	  return getComputedStyleX(elem, 'boxSizing') === 'border-box';
	}

	var BOX_MODELS = ['margin', 'border', 'padding'];
	var CONTENT_INDEX = -1;
	var PADDING_INDEX = 2;
	var BORDER_INDEX = 1;
	var MARGIN_INDEX = 0;

	function swap(elem, options, callback) {
	  var old = {};
	  var style = elem.style;
	  var name = undefined;

	  // Remember the old values, and insert the new ones
	  for (name in options) {
	    if (options.hasOwnProperty(name)) {
	      old[name] = style[name];
	      style[name] = options[name];
	    }
	  }

	  callback.call(elem);

	  // Revert the old values
	  for (name in options) {
	    if (options.hasOwnProperty(name)) {
	      style[name] = old[name];
	    }
	  }
	}

	function getPBMWidth(elem, props, which) {
	  var value = 0;
	  var prop = undefined;
	  var j = undefined;
	  var i = undefined;
	  for (j = 0; j < props.length; j++) {
	    prop = props[j];
	    if (prop) {
	      for (i = 0; i < which.length; i++) {
	        var cssProp = undefined;
	        if (prop === 'border') {
	          cssProp = prop + which[i] + 'Width';
	        } else {
	          cssProp = prop + which[i];
	        }
	        value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
	      }
	    }
	  }
	  return value;
	}

	/**
	 * A crude way of determining if an object is a window
	 * @member util
	 */
	function isWindow(obj) {
	  // must use == for ie8
	  /* eslint eqeqeq:0 */
	  return obj !== null && obj !== undefined && obj == obj.window;
	}

	var domUtils = {};

	each(['Width', 'Height'], function (name) {
	  domUtils['doc' + name] = function (refWin) {
	    var d = refWin.document;
	    return Math.max(
	    // firefox chrome documentElement.scrollHeight< body.scrollHeight
	    // ie standard mode : documentElement.scrollHeight> body.scrollHeight
	    d.documentElement['scroll' + name],
	    // quirks : documentElement.scrollHeight 最大等于可视窗口多一点？
	    d.body['scroll' + name], domUtils['viewport' + name](d));
	  };

	  domUtils['viewport' + name] = function (win) {
	    // pc browser includes scrollbar in window.innerWidth
	    var prop = 'client' + name;
	    var doc = win.document;
	    var body = doc.body;
	    var documentElement = doc.documentElement;
	    var documentElementProp = documentElement[prop];
	    // 标准模式取 documentElement
	    // backcompat 取 body
	    return doc.compatMode === 'CSS1Compat' && documentElementProp || body && body[prop] || documentElementProp;
	  };
	});

	/*
	 得到元素的大小信息
	 @param elem
	 @param name
	 @param {String} [extra]  'padding' : (css width) + padding
	 'border' : (css width) + padding + border
	 'margin' : (css width) + padding + border + margin
	 */
	function getWH(elem, name, ex) {
	  var extra = ex;
	  if (isWindow(elem)) {
	    return name === 'width' ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
	  } else if (elem.nodeType === 9) {
	    return name === 'width' ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
	  }
	  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];
	  var borderBoxValue = name === 'width' ? elem.offsetWidth : elem.offsetHeight;
	  var computedStyle = getComputedStyleX(elem);
	  var isBorderBox = isBorderBoxFn(elem, computedStyle);
	  var cssBoxValue = 0;
	  if (borderBoxValue === null || borderBoxValue === undefined || borderBoxValue <= 0) {
	    borderBoxValue = undefined;
	    // Fall back to computed then un computed css if necessary
	    cssBoxValue = getComputedStyleX(elem, name);
	    if (cssBoxValue === null || cssBoxValue === undefined || Number(cssBoxValue) < 0) {
	      cssBoxValue = elem.style[name] || 0;
	    }
	    // Normalize '', auto, and prepare for extra
	    cssBoxValue = parseFloat(cssBoxValue) || 0;
	  }
	  if (extra === undefined) {
	    extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
	  }
	  var borderBoxValueOrIsBorderBox = borderBoxValue !== undefined || isBorderBox;
	  var val = borderBoxValue || cssBoxValue;
	  if (extra === CONTENT_INDEX) {
	    if (borderBoxValueOrIsBorderBox) {
	      return val - getPBMWidth(elem, ['border', 'padding'], which, computedStyle);
	    }
	    return cssBoxValue;
	  } else if (borderBoxValueOrIsBorderBox) {
	    if (extra === BORDER_INDEX) {
	      return val;
	    }
	    return val + (extra === PADDING_INDEX ? -getPBMWidth(elem, ['border'], which, computedStyle) : getPBMWidth(elem, ['margin'], which, computedStyle));
	  }
	  return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which, computedStyle);
	}

	var cssShow = { position: 'absolute', visibility: 'hidden', display: 'block' };

	// fix #119 : https://github.com/kissyteam/kissy/issues/119
	function getWHIgnoreDisplay() {
	  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  var val = undefined;
	  var elem = args[0];
	  // in case elem is window
	  // elem.offsetWidth === undefined
	  if (elem.offsetWidth !== 0) {
	    val = getWH.apply(undefined, args);
	  } else {
	    swap(elem, cssShow, function () {
	      val = getWH.apply(undefined, args);
	    });
	  }
	  return val;
	}

	each(['width', 'height'], function (name) {
	  var first = name.charAt(0).toUpperCase() + name.slice(1);
	  domUtils['outer' + first] = function (el, includeMargin) {
	    return el && getWHIgnoreDisplay(el, name, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
	  };
	  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];

	  domUtils[name] = function (elem, v) {
	    var val = v;
	    if (val !== undefined) {
	      if (elem) {
	        var computedStyle = getComputedStyleX(elem);
	        var isBorderBox = isBorderBoxFn(elem);
	        if (isBorderBox) {
	          val += getPBMWidth(elem, ['padding', 'border'], which, computedStyle);
	        }
	        return css(elem, name, val);
	      }
	      return undefined;
	    }
	    return elem && getWHIgnoreDisplay(elem, name, CONTENT_INDEX);
	  };
	});

	function mix(to, from) {
	  for (var i in from) {
	    if (from.hasOwnProperty(i)) {
	      to[i] = from[i];
	    }
	  }
	  return to;
	}

	var utils = {
	  getWindow: function getWindow(node) {
	    if (node && node.document && node.setTimeout) {
	      return node;
	    }
	    var doc = node.ownerDocument || node;
	    return doc.defaultView || doc.parentWindow;
	  },
	  offset: function offset(el, value, option) {
	    if (typeof value !== 'undefined') {
	      setOffset(el, value, option || {});
	    } else {
	      return getOffset(el);
	    }
	  },
	  isWindow: isWindow,
	  each: each,
	  css: css,
	  clone: function clone(obj) {
	    var i = undefined;
	    var ret = {};
	    for (i in obj) {
	      if (obj.hasOwnProperty(i)) {
	        ret[i] = obj[i];
	      }
	    }
	    var overflow = obj.overflow;
	    if (overflow) {
	      for (i in obj) {
	        if (obj.hasOwnProperty(i)) {
	          ret.overflow[i] = obj.overflow[i];
	        }
	      }
	    }
	    return ret;
	  },
	  mix: mix,
	  getWindowScrollLeft: function getWindowScrollLeft(w) {
	    return getScrollLeft(w);
	  },
	  getWindowScrollTop: function getWindowScrollTop(w) {
	    return getScrollTop(w);
	  },
	  merge: function merge() {
	    var ret = {};

	    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	      args[_key2] = arguments[_key2];
	    }

	    for (var i = 0; i < args.length; i++) {
	      utils.mix(ret, args[i]);
	    }
	    return ret;
	  },
	  viewportWidth: 0,
	  viewportHeight: 0
	};

	mix(utils, domUtils);

	exports['default'] = utils;
	module.exports = exports['default'];

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _utils = __webpack_require__(117);

	var _utils2 = _interopRequireDefault(_utils);

	/**
	 * 得到会导致元素显示不全的祖先元素
	 */

	function getOffsetParent(element) {
	  // ie 这个也不是完全可行
	  /*
	   <div style="width: 50px;height: 100px;overflow: hidden">
	   <div style="width: 50px;height: 100px;position: relative;" id="d6">
	   元素 6 高 100px 宽 50px<br/>
	   </div>
	   </div>
	   */
	  // element.offsetParent does the right thing in ie7 and below. Return parent with layout!
	  //  In other browsers it only includes elements with position absolute, relative or
	  // fixed, not elements with overflow set to auto or scroll.
	  //        if (UA.ie && ieMode < 8) {
	  //            return element.offsetParent;
	  //        }
	  // 统一的 offsetParent 方法
	  var doc = element.ownerDocument;
	  var body = doc.body;
	  var parent = undefined;
	  var positionStyle = _utils2['default'].css(element, 'position');
	  var skipStatic = positionStyle === 'fixed' || positionStyle === 'absolute';

	  if (!skipStatic) {
	    return element.nodeName.toLowerCase() === 'html' ? null : element.parentNode;
	  }

	  for (parent = element.parentNode; parent && parent !== body; parent = parent.parentNode) {
	    positionStyle = _utils2['default'].css(parent, 'position');
	    if (positionStyle !== 'static') {
	      return parent;
	    }
	  }
	  return null;
	}

	exports['default'] = getOffsetParent;
	module.exports = exports['default'];

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _utils = __webpack_require__(117);

	var _utils2 = _interopRequireDefault(_utils);

	var _getOffsetParent = __webpack_require__(118);

	var _getOffsetParent2 = _interopRequireDefault(_getOffsetParent);

	/**
	 * 获得元素的显示部分的区域
	 */
	function getVisibleRectForElement(element) {
	  var visibleRect = {
	    left: 0,
	    right: Infinity,
	    top: 0,
	    bottom: Infinity
	  };
	  var el = (0, _getOffsetParent2['default'])(element);
	  var scrollX = undefined;
	  var scrollY = undefined;
	  var winSize = undefined;
	  var doc = element.ownerDocument;
	  var win = doc.defaultView || doc.parentWindow;
	  var body = doc.body;
	  var documentElement = doc.documentElement;

	  // Determine the size of the visible rect by climbing the dom accounting for
	  // all scrollable containers.
	  while (el) {
	    // clientWidth is zero for inline block elements in ie.
	    if ((navigator.userAgent.indexOf('MSIE') === -1 || el.clientWidth !== 0) &&
	    // body may have overflow set on it, yet we still get the entire
	    // viewport. In some browsers, el.offsetParent may be
	    // document.documentElement, so check for that too.
	    el !== body && el !== documentElement && _utils2['default'].css(el, 'overflow') !== 'visible') {
	      var pos = _utils2['default'].offset(el);
	      // add border
	      pos.left += el.clientLeft;
	      pos.top += el.clientTop;
	      visibleRect.top = Math.max(visibleRect.top, pos.top);
	      visibleRect.right = Math.min(visibleRect.right,
	      // consider area without scrollBar
	      pos.left + el.clientWidth);
	      visibleRect.bottom = Math.min(visibleRect.bottom, pos.top + el.clientHeight);
	      visibleRect.left = Math.max(visibleRect.left, pos.left);
	    } else if (el === body || el === documentElement) {
	      break;
	    }
	    el = (0, _getOffsetParent2['default'])(el);
	  }

	  // Clip by window's viewport.
	  scrollX = _utils2['default'].getWindowScrollLeft(win);
	  scrollY = _utils2['default'].getWindowScrollTop(win);
	  visibleRect.left = Math.max(visibleRect.left, scrollX);
	  visibleRect.top = Math.max(visibleRect.top, scrollY);
	  winSize = {
	    width: _utils2['default'].viewportWidth(win),
	    height: _utils2['default'].viewportHeight(win)
	  };
	  visibleRect.right = Math.min(visibleRect.right, scrollX + winSize.width);
	  visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + winSize.height);
	  return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null;
	}

	exports['default'] = getVisibleRectForElement;
	module.exports = exports['default'];

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _utils = __webpack_require__(117);

	var _utils2 = _interopRequireDefault(_utils);

	function adjustForViewport(elFuturePos, elRegion, visibleRect, overflow) {
	  var pos = _utils2['default'].clone(elFuturePos);
	  var size = {
	    width: elRegion.width,
	    height: elRegion.height
	  };

	  if (overflow.adjustX && pos.left < visibleRect.left) {
	    pos.left = visibleRect.left;
	  }

	  // Left edge inside and right edge outside viewport, try to resize it.
	  if (overflow.resizeWidth && pos.left >= visibleRect.left && pos.left + size.width > visibleRect.right) {
	    size.width -= pos.left + size.width - visibleRect.right;
	  }

	  // Right edge outside viewport, try to move it.
	  if (overflow.adjustX && pos.left + size.width > visibleRect.right) {
	    // 保证左边界和可视区域左边界对齐
	    pos.left = Math.max(visibleRect.right - size.width, visibleRect.left);
	  }

	  // Top edge outside viewport, try to move it.
	  if (overflow.adjustY && pos.top < visibleRect.top) {
	    pos.top = visibleRect.top;
	  }

	  // Top edge inside and bottom edge outside viewport, try to resize it.
	  if (overflow.resizeHeight && pos.top >= visibleRect.top && pos.top + size.height > visibleRect.bottom) {
	    size.height -= pos.top + size.height - visibleRect.bottom;
	  }

	  // Bottom edge outside viewport, try to move it.
	  if (overflow.adjustY && pos.top + size.height > visibleRect.bottom) {
	    // 保证上边界和可视区域上边界对齐
	    pos.top = Math.max(visibleRect.bottom - size.height, visibleRect.top);
	  }

	  return _utils2['default'].mix(pos, size);
	}

	exports['default'] = adjustForViewport;
	module.exports = exports['default'];

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _utils = __webpack_require__(117);

	var _utils2 = _interopRequireDefault(_utils);

	function getRegion(node) {
	  var offset = undefined;
	  var w = undefined;
	  var h = undefined;
	  if (!_utils2['default'].isWindow(node) && node.nodeType !== 9) {
	    offset = _utils2['default'].offset(node);
	    w = _utils2['default'].outerWidth(node);
	    h = _utils2['default'].outerHeight(node);
	  } else {
	    var win = _utils2['default'].getWindow(node);
	    offset = {
	      left: _utils2['default'].getWindowScrollLeft(win),
	      top: _utils2['default'].getWindowScrollTop(win)
	    };
	    w = _utils2['default'].viewportWidth(win);
	    h = _utils2['default'].viewportHeight(win);
	  }
	  offset.width = w;
	  offset.height = h;
	  return offset;
	}

	exports['default'] = getRegion;
	module.exports = exports['default'];

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _getAlignOffset = __webpack_require__(123);

	var _getAlignOffset2 = _interopRequireDefault(_getAlignOffset);

	function getElFuturePos(elRegion, refNodeRegion, points, offset, targetOffset) {
	  var xy = undefined;
	  var diff = undefined;
	  var p1 = undefined;
	  var p2 = undefined;

	  xy = {
	    left: elRegion.left,
	    top: elRegion.top
	  };

	  p1 = (0, _getAlignOffset2['default'])(refNodeRegion, points[1]);
	  p2 = (0, _getAlignOffset2['default'])(elRegion, points[0]);

	  diff = [p2.left - p1.left, p2.top - p1.top];

	  return {
	    left: xy.left - diff[0] + offset[0] - targetOffset[0],
	    top: xy.top - diff[1] + offset[1] - targetOffset[1]
	  };
	}

	exports['default'] = getElFuturePos;
	module.exports = exports['default'];

/***/ },
/* 123 */
72,
/* 124 */
73,
/* 125 */
[770, 126],
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _ChildrenUtils = __webpack_require__(127);

	var _AnimateChild = __webpack_require__(128);

	var _AnimateChild2 = _interopRequireDefault(_AnimateChild);

	var _util = __webpack_require__(133);

	var _util2 = _interopRequireDefault(_util);

	var defaultKey = 'rc_animate_' + Date.now();

	function getChildrenFromProps(props) {
	  var children = props.children;
	  if (_react2['default'].isValidElement(children)) {
	    if (!children.key) {
	      return _react2['default'].cloneElement(children, {
	        key: defaultKey
	      });
	    }
	  }
	  return children;
	}

	function noop() {}

	var Animate = _react2['default'].createClass({
	  displayName: 'Animate',

	  propTypes: {
	    component: _react2['default'].PropTypes.any,
	    animation: _react2['default'].PropTypes.object,
	    transitionName: _react2['default'].PropTypes.string,
	    transitionEnter: _react2['default'].PropTypes.bool,
	    transitionAppear: _react2['default'].PropTypes.bool,
	    exclusive: _react2['default'].PropTypes.bool,
	    transitionLeave: _react2['default'].PropTypes.bool,
	    onEnd: _react2['default'].PropTypes.func,
	    onEnter: _react2['default'].PropTypes.func,
	    onLeave: _react2['default'].PropTypes.func,
	    onAppear: _react2['default'].PropTypes.func,
	    showProp: _react2['default'].PropTypes.string
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      animation: {},
	      component: 'span',
	      transitionEnter: true,
	      transitionLeave: true,
	      transitionAppear: false,
	      onEnd: noop,
	      onEnter: noop,
	      onLeave: noop,
	      onAppear: noop
	    };
	  },

	  getInitialState: function getInitialState() {
	    this.currentlyAnimatingKeys = {};
	    this.keysToEnter = [];
	    this.keysToLeave = [];
	    return {
	      children: (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(this.props))
	    };
	  },

	  componentDidMount: function componentDidMount() {
	    var _this = this;

	    var showProp = this.props.showProp;
	    var children = this.state.children;
	    if (showProp) {
	      children = children.filter(function (child) {
	        return !!child.props[showProp];
	      });
	    }
	    children.forEach(function (child) {
	      _this.performAppear(child.key);
	    });
	  },

	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    var _this2 = this;

	    this.nextProps = nextProps;
	    var nextChildren = (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(nextProps));
	    var props = this.props;
	    // exclusive needs immediate response
	    if (props.exclusive) {
	      Object.keys(this.currentlyAnimatingKeys).forEach(function (key) {
	        _this2.stop(key);
	      });
	    }
	    var showProp = props.showProp;
	    var currentlyAnimatingKeys = this.currentlyAnimatingKeys;
	    // last props children if exclusive
	    var currentChildren = props.exclusive ? (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(props)) : this.state.children;
	    // in case destroy in showProp mode
	    var newChildren = [];
	    if (showProp) {
	      currentChildren.forEach(function (currentChild) {
	        var nextChild = (0, _ChildrenUtils.findChildInChildrenByKey)(nextChildren, currentChild.key);
	        var newChild = undefined;
	        if ((!nextChild || !nextChild.props[showProp]) && currentChild.props[showProp]) {
	          newChild = _react2['default'].cloneElement(nextChild || currentChild, _defineProperty({}, showProp, true));
	        } else {
	          newChild = nextChild;
	        }
	        if (newChild) {
	          newChildren.push(newChild);
	        }
	      });
	      nextChildren.forEach(function (nextChild) {
	        if (!(0, _ChildrenUtils.findChildInChildrenByKey)(currentChildren, nextChild.key)) {
	          newChildren.push(nextChild);
	        }
	      });
	    } else {
	      newChildren = (0, _ChildrenUtils.mergeChildren)(currentChildren, nextChildren);
	    }

	    // need render to avoid update
	    this.setState({
	      children: newChildren
	    });

	    nextChildren.forEach(function (child) {
	      var key = child.key;
	      if (currentlyAnimatingKeys[key]) {
	        return;
	      }
	      var hasPrev = (0, _ChildrenUtils.findChildInChildrenByKey)(currentChildren, key);
	      if (showProp) {
	        var showInNext = child.props[showProp];
	        if (hasPrev) {
	          var showInNow = (0, _ChildrenUtils.findShownChildInChildrenByKey)(currentChildren, key, showProp);
	          if (!showInNow && showInNext) {
	            _this2.keysToEnter.push(key);
	          }
	        } else if (showInNext) {
	          _this2.keysToEnter.push(key);
	        }
	      } else if (!hasPrev) {
	        _this2.keysToEnter.push(key);
	      }
	    });

	    currentChildren.forEach(function (child) {
	      var key = child.key;
	      if (currentlyAnimatingKeys[key]) {
	        return;
	      }
	      var hasNext = (0, _ChildrenUtils.findChildInChildrenByKey)(nextChildren, key);
	      if (showProp) {
	        var showInNow = child.props[showProp];
	        if (hasNext) {
	          var showInNext = (0, _ChildrenUtils.findShownChildInChildrenByKey)(nextChildren, key, showProp);
	          if (!showInNext && showInNow) {
	            _this2.keysToLeave.push(key);
	          }
	        } else if (showInNow) {
	          _this2.keysToLeave.push(key);
	        }
	      } else if (!hasNext) {
	        _this2.keysToLeave.push(key);
	      }
	    });
	  },

	  componentDidUpdate: function componentDidUpdate() {
	    if (this.isMounted()) {
	      var keysToEnter = this.keysToEnter;
	      this.keysToEnter = [];
	      keysToEnter.forEach(this.performEnter);
	      var keysToLeave = this.keysToLeave;
	      this.keysToLeave = [];
	      keysToLeave.forEach(this.performLeave);
	    }
	  },

	  performEnter: function performEnter(key) {
	    // may already remove by exclusive
	    if (this.refs[key]) {
	      this.currentlyAnimatingKeys[key] = true;
	      this.refs[key].componentWillEnter(this.handleDoneAdding.bind(this, key, 'enter'));
	    }
	  },

	  performAppear: function performAppear(key) {
	    if (this.refs[key]) {
	      this.currentlyAnimatingKeys[key] = true;
	      this.refs[key].componentWillAppear(this.handleDoneAdding.bind(this, key, 'appear'));
	    }
	  },

	  handleDoneAdding: function handleDoneAdding(key, type) {
	    var props = this.props;
	    delete this.currentlyAnimatingKeys[key];
	    // if update on exclusive mode, skip check
	    if (props.exclusive && props !== this.nextProps) {
	      return;
	    }
	    var currentChildren = (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(props));
	    if (!this.isValidChildByKey(currentChildren, key)) {
	      // exclusive will not need this
	      this.performLeave(key);
	    } else {
	      if (type === 'appear') {
	        if (_util2['default'].allowAppearCallback(props)) {
	          props.onAppear(key);
	          props.onEnd(key, true);
	        }
	      } else {
	        if (_util2['default'].allowEnterCallback(props)) {
	          props.onEnter(key);
	          props.onEnd(key, true);
	        }
	      }
	    }
	  },

	  performLeave: function performLeave(key) {
	    // may already remove by exclusive
	    if (this.refs[key]) {
	      this.currentlyAnimatingKeys[key] = true;
	      this.refs[key].componentWillLeave(this.handleDoneLeaving.bind(this, key));
	    }
	  },

	  handleDoneLeaving: function handleDoneLeaving(key) {
	    var props = this.props;
	    delete this.currentlyAnimatingKeys[key];
	    // if update on exclusive mode, skip check
	    if (props.exclusive && props !== this.nextProps) {
	      return;
	    }
	    var currentChildren = (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(props));
	    // in case state change is too fast
	    if (this.isValidChildByKey(currentChildren, key)) {
	      this.performEnter(key);
	    } else {
	      if (_util2['default'].allowLeaveCallback(props)) {
	        props.onLeave(key);
	        props.onEnd(key, false);
	      }
	      if (this.isMounted() && !(0, _ChildrenUtils.isSameChildren)(this.state.children, currentChildren, props.showProp)) {
	        this.setState({
	          children: currentChildren
	        });
	      }
	    }
	  },

	  isValidChildByKey: function isValidChildByKey(currentChildren, key) {
	    var showProp = this.props.showProp;
	    if (showProp) {
	      return (0, _ChildrenUtils.findShownChildInChildrenByKey)(currentChildren, key, showProp);
	    }
	    return (0, _ChildrenUtils.findChildInChildrenByKey)(currentChildren, key);
	  },

	  stop: function stop(key) {
	    delete this.currentlyAnimatingKeys[key];
	    var component = this.refs[key];
	    if (component) {
	      component.stop();
	    }
	  },

	  render: function render() {
	    var props = this.props;
	    this.nextProps = props;
	    var stateChildren = this.state.children;
	    var children = null;
	    if (stateChildren) {
	      children = stateChildren.map(function (child) {
	        if (child === null) {
	          return child;
	        }
	        if (!child.key) {
	          throw new Error('must set key for <rc-animate> children');
	        }
	        return _react2['default'].createElement(
	          _AnimateChild2['default'],
	          {
	            key: child.key,
	            ref: child.key,
	            animation: props.animation,
	            transitionName: props.transitionName,
	            transitionEnter: props.transitionEnter,
	            transitionAppear: props.transitionAppear,
	            transitionLeave: props.transitionLeave },
	          child
	        );
	      });
	    }
	    var Component = props.component;
	    if (Component) {
	      return _react2['default'].createElement(
	        Component,
	        this.props,
	        children
	      );
	    }
	    return children[0] || null;
	  }
	});

	exports['default'] = Animate;
	module.exports = exports['default'];

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports.toArrayChildren = toArrayChildren;
	exports.findChildInChildrenByKey = findChildInChildrenByKey;
	exports.findShownChildInChildrenByKey = findShownChildInChildrenByKey;
	exports.findHiddenChildInChildrenByKey = findHiddenChildInChildrenByKey;
	exports.isSameChildren = isSameChildren;
	exports.mergeChildren = mergeChildren;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	function toArrayChildren(children) {
	  var ret = [];
	  _react2['default'].Children.forEach(children, function (child) {
	    ret.push(child);
	  });
	  return ret;
	}

	function findChildInChildrenByKey(children, key) {
	  var ret = null;
	  if (children) {
	    children.forEach(function (child) {
	      if (ret) {
	        return;
	      }
	      if (child.key === key) {
	        ret = child;
	      }
	    });
	  }
	  return ret;
	}

	function findShownChildInChildrenByKey(children, key, showProp) {
	  var ret = null;
	  if (children) {
	    children.forEach(function (child) {
	      if (child.key === key && child.props[showProp]) {
	        if (ret) {
	          throw new Error('two child with same key for <rc-animate> children');
	        }
	        ret = child;
	      }
	    });
	  }
	  return ret;
	}

	function findHiddenChildInChildrenByKey(children, key, showProp) {
	  var found = 0;
	  if (children) {
	    children.forEach(function (child) {
	      if (found) {
	        return;
	      }
	      found = child.key === key && !child.props[showProp];
	    });
	  }
	  return found;
	}

	function isSameChildren(c1, c2, showProp) {
	  var same = c1.length === c2.length;
	  if (same) {
	    c1.forEach(function (child, index) {
	      var child2 = c2[index];
	      if (child.key !== child2.key) {
	        same = false;
	      } else if (showProp && child.props[showProp] !== child2.props[showProp]) {
	        same = false;
	      }
	    });
	  }
	  return same;
	}

	function mergeChildren(prev, next) {
	  var ret = [];

	  // For each key of `next`, the list of keys to insert before that key in
	  // the combined list
	  var nextChildrenPending = {};
	  var pendingChildren = [];
	  prev.forEach(function (child) {
	    if (findChildInChildrenByKey(next, child.key)) {
	      if (pendingChildren.length) {
	        nextChildrenPending[child.key] = pendingChildren;
	        pendingChildren = [];
	      }
	    } else {
	      pendingChildren.push(child);
	    }
	  });

	  next.forEach(function (child) {
	    if (nextChildrenPending.hasOwnProperty(child.key)) {
	      ret = ret.concat(nextChildrenPending[child.key]);
	    }
	    ret.push(child);
	  });

	  ret = ret.concat(pendingChildren);

	  return ret;
	}

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(4);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _cssAnimation = __webpack_require__(129);

	var _cssAnimation2 = _interopRequireDefault(_cssAnimation);

	var _util = __webpack_require__(133);

	var _util2 = _interopRequireDefault(_util);

	var transitionMap = {
	  enter: 'transitionEnter',
	  appear: 'transitionAppear',
	  leave: 'transitionLeave'
	};

	var AnimateChild = _react2['default'].createClass({
	  displayName: 'AnimateChild',

	  propTypes: {
	    children: _react2['default'].PropTypes.any
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    this.stop();
	  },

	  componentWillEnter: function componentWillEnter(done) {
	    if (_util2['default'].isEnterSupported(this.props)) {
	      this.transition('enter', done);
	    } else {
	      done();
	    }
	  },

	  componentWillAppear: function componentWillAppear(done) {
	    if (_util2['default'].isAppearSupported(this.props)) {
	      this.transition('appear', done);
	    } else {
	      done();
	    }
	  },

	  componentWillLeave: function componentWillLeave(done) {
	    if (_util2['default'].isLeaveSupported(this.props)) {
	      this.transition('leave', done);
	    } else {
	      done();
	    }
	  },

	  transition: function transition(animationType, finishCallback) {
	    var _this = this;

	    var node = _reactDom2['default'].findDOMNode(this);
	    var props = this.props;
	    var transitionName = props.transitionName;
	    this.stop();
	    var end = function end() {
	      _this.stopper = null;
	      finishCallback();
	    };
	    if ((_cssAnimation.isCssAnimationSupported || !props.animation[animationType]) && transitionName && props[transitionMap[animationType]]) {
	      this.stopper = (0, _cssAnimation2['default'])(node, transitionName + '-' + animationType, end);
	    } else {
	      this.stopper = props.animation[animationType](node, end);
	    }
	  },

	  stop: function stop() {
	    var stopper = this.stopper;
	    if (stopper) {
	      this.stopper = null;
	      stopper.stop();
	    }
	  },

	  render: function render() {
	    return this.props.children;
	  }
	});

	exports['default'] = AnimateChild;
	module.exports = exports['default'];

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Event = __webpack_require__(130);

	var _Event2 = _interopRequireDefault(_Event);

	var _componentClasses = __webpack_require__(131);

	var _componentClasses2 = _interopRequireDefault(_componentClasses);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var isCssAnimationSupported = _Event2["default"].endEvents.length !== 0;


	var capitalPrefixes = ['Webkit', 'Moz', 'O',
	// ms is special .... !
	'ms'];
	var prefixes = ['-webkit-', '-moz-', '-o-', 'ms-', ''];

	function getDuration(node, name) {
	  var style = window.getComputedStyle(node);

	  var ret = '';
	  for (var i = 0; i < prefixes.length; i++) {
	    ret = style.getPropertyValue(prefixes[i] + name);
	    if (ret) {
	      break;
	    }
	  }
	  return ret;
	}

	function fixBrowserByTimeout(node) {
	  if (isCssAnimationSupported) {
	    var transitionDuration = parseFloat(getDuration(node, 'transition-duration')) || 0;
	    var animationDuration = parseFloat(getDuration(node, 'animation-duration')) || 0;
	    var time = Math.max(transitionDuration, animationDuration);
	    // sometimes, browser bug
	    node.rcEndAnimTimeout = setTimeout(function () {
	      node.rcEndAnimTimeout = null;
	      if (node.rcEndListener) {
	        node.rcEndListener();
	      }
	    }, time * 1000 + 200);
	  }
	}

	function clearBrowserBugTimeout(node) {
	  if (node.rcEndAnimTimeout) {
	    clearTimeout(node.rcEndAnimTimeout);
	    node.rcEndAnimTimeout = null;
	  }
	}

	var cssAnimation = function cssAnimation(node, transitionName, endCallback) {
	  var className = transitionName;
	  var activeClassName = className + '-active';
	  var end = endCallback;
	  var start = void 0;
	  var active = void 0;
	  var nodeClasses = (0, _componentClasses2["default"])(node);

	  if (endCallback && Object.prototype.toString.call(endCallback) === '[object Object]') {
	    end = endCallback.end;
	    start = endCallback.start;
	    active = endCallback.active;
	  }

	  if (node.rcEndListener) {
	    node.rcEndListener();
	  }

	  node.rcEndListener = function (e) {
	    if (e && e.target !== node) {
	      return;
	    }

	    if (node.rcAnimTimeout) {
	      clearTimeout(node.rcAnimTimeout);
	      node.rcAnimTimeout = null;
	    }

	    clearBrowserBugTimeout(node);

	    nodeClasses.remove(className);
	    nodeClasses.remove(activeClassName);

	    _Event2["default"].removeEndEventListener(node, node.rcEndListener);
	    node.rcEndListener = null;

	    // Usually this optional end is used for informing an owner of
	    // a leave animation and telling it to remove the child.
	    if (end) {
	      end();
	    }
	  };

	  _Event2["default"].addEndEventListener(node, node.rcEndListener);

	  nodeClasses.add(className);

	  if (start) {
	    start();
	  }

	  node.rcAnimTimeout = setTimeout(function () {
	    node.rcAnimTimeout = null;
	    nodeClasses.add(activeClassName);
	    if (active) {
	      active();
	    }
	    fixBrowserByTimeout(node);
	  }, 0);

	  return {
	    stop: function stop() {
	      if (node.rcEndListener) {
	        node.rcEndListener();
	      }
	    }
	  };
	};

	cssAnimation.style = function (node, style, callback) {
	  if (node.rcEndListener) {
	    node.rcEndListener();
	  }

	  node.rcEndListener = function (e) {
	    if (e && e.target !== node) {
	      return;
	    }

	    if (node.rcAnimTimeout) {
	      clearTimeout(node.rcAnimTimeout);
	      node.rcAnimTimeout = null;
	    }

	    clearBrowserBugTimeout(node);

	    _Event2["default"].removeEndEventListener(node, node.rcEndListener);
	    node.rcEndListener = null;

	    // Usually this optional callback is used for informing an owner of
	    // a leave animation and telling it to remove the child.
	    if (callback) {
	      callback();
	    }
	  };

	  _Event2["default"].addEndEventListener(node, node.rcEndListener);

	  node.rcAnimTimeout = setTimeout(function () {
	    for (var s in style) {
	      if (style.hasOwnProperty(s)) {
	        node.style[s] = style[s];
	      }
	    }
	    node.rcAnimTimeout = null;
	    fixBrowserByTimeout(node);
	  }, 0);
	};

	cssAnimation.setTransition = function (node, p, value) {
	  var property = p;
	  var v = value;
	  if (value === undefined) {
	    v = property;
	    property = '';
	  }
	  property = property || '';
	  capitalPrefixes.forEach(function (prefix) {
	    node.style[prefix + 'Transition' + property] = v;
	  });
	};

	cssAnimation.isCssAnimationSupported = isCssAnimationSupported;

	exports["default"] = cssAnimation;
	module.exports = exports['default'];

/***/ },
/* 130 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var EVENT_NAME_MAP = {
	  transitionend: {
	    transition: 'transitionend',
	    WebkitTransition: 'webkitTransitionEnd',
	    MozTransition: 'mozTransitionEnd',
	    OTransition: 'oTransitionEnd',
	    msTransition: 'MSTransitionEnd'
	  },

	  animationend: {
	    animation: 'animationend',
	    WebkitAnimation: 'webkitAnimationEnd',
	    MozAnimation: 'mozAnimationEnd',
	    OAnimation: 'oAnimationEnd',
	    msAnimation: 'MSAnimationEnd'
	  }
	};

	var endEvents = [];

	function detectEvents() {
	  var testEl = document.createElement('div');
	  var style = testEl.style;

	  if (!('AnimationEvent' in window)) {
	    delete EVENT_NAME_MAP.animationend.animation;
	  }

	  if (!('TransitionEvent' in window)) {
	    delete EVENT_NAME_MAP.transitionend.transition;
	  }

	  for (var baseEventName in EVENT_NAME_MAP) {
	    if (EVENT_NAME_MAP.hasOwnProperty(baseEventName)) {
	      var baseEvents = EVENT_NAME_MAP[baseEventName];
	      for (var styleName in baseEvents) {
	        if (styleName in style) {
	          endEvents.push(baseEvents[styleName]);
	          break;
	        }
	      }
	    }
	  }
	}

	if (typeof window !== 'undefined' && typeof document !== 'undefined') {
	  detectEvents();
	}

	function addEventListener(node, eventName, eventListener) {
	  node.addEventListener(eventName, eventListener, false);
	}

	function removeEventListener(node, eventName, eventListener) {
	  node.removeEventListener(eventName, eventListener, false);
	}

	var TransitionEvents = {
	  addEndEventListener: function addEndEventListener(node, eventListener) {
	    if (endEvents.length === 0) {
	      window.setTimeout(eventListener, 0);
	      return;
	    }
	    endEvents.forEach(function (endEvent) {
	      addEventListener(node, endEvent, eventListener);
	    });
	  },


	  endEvents: endEvents,

	  removeEndEventListener: function removeEndEventListener(node, eventListener) {
	    if (endEvents.length === 0) {
	      return;
	    }
	    endEvents.forEach(function (endEvent) {
	      removeEventListener(node, endEvent, eventListener);
	    });
	  }
	};

	exports["default"] = TransitionEvents;
	module.exports = exports['default'];

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */

	try {
	  var index = __webpack_require__(132);
	} catch (err) {
	  var index = __webpack_require__(132);
	}

	/**
	 * Whitespace regexp.
	 */

	var re = /\s+/;

	/**
	 * toString reference.
	 */

	var toString = Object.prototype.toString;

	/**
	 * Wrap `el` in a `ClassList`.
	 *
	 * @param {Element} el
	 * @return {ClassList}
	 * @api public
	 */

	module.exports = function(el){
	  return new ClassList(el);
	};

	/**
	 * Initialize a new ClassList for `el`.
	 *
	 * @param {Element} el
	 * @api private
	 */

	function ClassList(el) {
	  if (!el || !el.nodeType) {
	    throw new Error('A DOM element reference is required');
	  }
	  this.el = el;
	  this.list = el.classList;
	}

	/**
	 * Add class `name` if not already present.
	 *
	 * @param {String} name
	 * @return {ClassList}
	 * @api public
	 */

	ClassList.prototype.add = function(name){
	  // classList
	  if (this.list) {
	    this.list.add(name);
	    return this;
	  }

	  // fallback
	  var arr = this.array();
	  var i = index(arr, name);
	  if (!~i) arr.push(name);
	  this.el.className = arr.join(' ');
	  return this;
	};

	/**
	 * Remove class `name` when present, or
	 * pass a regular expression to remove
	 * any which match.
	 *
	 * @param {String|RegExp} name
	 * @return {ClassList}
	 * @api public
	 */

	ClassList.prototype.remove = function(name){
	  if ('[object RegExp]' == toString.call(name)) {
	    return this.removeMatching(name);
	  }

	  // classList
	  if (this.list) {
	    this.list.remove(name);
	    return this;
	  }

	  // fallback
	  var arr = this.array();
	  var i = index(arr, name);
	  if (~i) arr.splice(i, 1);
	  this.el.className = arr.join(' ');
	  return this;
	};

	/**
	 * Remove all classes matching `re`.
	 *
	 * @param {RegExp} re
	 * @return {ClassList}
	 * @api private
	 */

	ClassList.prototype.removeMatching = function(re){
	  var arr = this.array();
	  for (var i = 0; i < arr.length; i++) {
	    if (re.test(arr[i])) {
	      this.remove(arr[i]);
	    }
	  }
	  return this;
	};

	/**
	 * Toggle class `name`, can force state via `force`.
	 *
	 * For browsers that support classList, but do not support `force` yet,
	 * the mistake will be detected and corrected.
	 *
	 * @param {String} name
	 * @param {Boolean} force
	 * @return {ClassList}
	 * @api public
	 */

	ClassList.prototype.toggle = function(name, force){
	  // classList
	  if (this.list) {
	    if ("undefined" !== typeof force) {
	      if (force !== this.list.toggle(name, force)) {
	        this.list.toggle(name); // toggle again to correct
	      }
	    } else {
	      this.list.toggle(name);
	    }
	    return this;
	  }

	  // fallback
	  if ("undefined" !== typeof force) {
	    if (!force) {
	      this.remove(name);
	    } else {
	      this.add(name);
	    }
	  } else {
	    if (this.has(name)) {
	      this.remove(name);
	    } else {
	      this.add(name);
	    }
	  }

	  return this;
	};

	/**
	 * Return an array of classes.
	 *
	 * @return {Array}
	 * @api public
	 */

	ClassList.prototype.array = function(){
	  var className = this.el.getAttribute('class') || '';
	  var str = className.replace(/^\s+|\s+$/g, '');
	  var arr = str.split(re);
	  if ('' === arr[0]) arr.shift();
	  return arr;
	};

	/**
	 * Check if class `name` is present.
	 *
	 * @param {String} name
	 * @return {ClassList}
	 * @api public
	 */

	ClassList.prototype.has =
	ClassList.prototype.contains = function(name){
	  return this.list
	    ? this.list.contains(name)
	    : !! ~index(this.array(), name);
	};


/***/ },
/* 132 */
/***/ function(module, exports) {

	module.exports = function(arr, obj){
	  if (arr.indexOf) return arr.indexOf(obj);
	  for (var i = 0; i < arr.length; ++i) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	};

/***/ },
/* 133 */
82,
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _LazyRenderBox = __webpack_require__(135);

	var _LazyRenderBox2 = _interopRequireDefault(_LazyRenderBox);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var PopupInner = _react2["default"].createClass({
	  displayName: 'PopupInner',

	  propTypes: {
	    hiddenClassName: _react.PropTypes.string,
	    className: _react.PropTypes.string,
	    prefixCls: _react.PropTypes.string,
	    onMouseEnter: _react.PropTypes.func,
	    onMouseLeave: _react.PropTypes.func,
	    children: _react.PropTypes.any
	  },
	  render: function render() {
	    var props = this.props;
	    var className = props.className;
	    if (!props.visible) {
	      className += ' ' + props.hiddenClassName;
	    }
	    return _react2["default"].createElement(
	      'div',
	      {
	        className: className,
	        onMouseEnter: props.onMouseEnter,
	        onMouseLeave: props.onMouseLeave,
	        style: props.style
	      },
	      _react2["default"].createElement(
	        _LazyRenderBox2["default"],
	        { className: props.prefixCls + '-content', visible: props.visible },
	        props.children
	      )
	    );
	  }
	});

	exports["default"] = PopupInner;
	module.exports = exports['default'];

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var LazyRenderBox = _react2["default"].createClass({
	  displayName: 'LazyRenderBox',

	  propTypes: {
	    children: _react.PropTypes.any,
	    className: _react.PropTypes.string,
	    visible: _react.PropTypes.bool,
	    hiddenClassName: _react.PropTypes.string
	  },
	  shouldComponentUpdate: function shouldComponentUpdate(nextProps) {
	    return nextProps.hiddenClassName || nextProps.visible;
	  },
	  render: function render() {
	    if (this.props.hiddenClassName) {
	      var className = this.props.className;
	      if (!this.props.visible) {
	        className += ' ' + this.props.hiddenClassName;
	      }
	      return _react2["default"].createElement('div', _extends({}, this.props, { className: className }));
	    }
	    if (_react2["default"].Children.count(this.props.children) > 1) {
	      return _react2["default"].createElement('div', this.props);
	    }
	    return _react2["default"].Children.only(this.props.children);
	  }
	});

	exports["default"] = LazyRenderBox;
	module.exports = exports['default'];

/***/ },
/* 136 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	exports.getAlignFromPlacement = getAlignFromPlacement;
	exports.getPopupClassNameFromAlign = getPopupClassNameFromAlign;
	function isPointsEq(a1, a2) {
	  return a1[0] === a2[0] && a1[1] === a2[1];
	}

	function getAlignFromPlacement(builtinPlacements, placementStr, align) {
	  var baseAlign = builtinPlacements[placementStr] || {};
	  return _extends({}, baseAlign, align);
	}

	function getPopupClassNameFromAlign(builtinPlacements, prefixCls, align) {
	  var points = align.points;
	  for (var placement in builtinPlacements) {
	    if (builtinPlacements.hasOwnProperty(placement)) {
	      if (isPointsEq(builtinPlacements[placement].points, points)) {
	        return prefixCls + '-placement-' + placement;
	      }
	    }
	  }
	  return '';
	}

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _mixinCommonMixin = __webpack_require__(138);

	var _mixinCommonMixin2 = _interopRequireDefault(_mixinCommonMixin);

	var _Header = __webpack_require__(142);

	var _Header2 = _interopRequireDefault(_Header);

	var _Combobox = __webpack_require__(144);

	var _Combobox2 = _interopRequireDefault(_Combobox);

	function noop() {}

	function generateOptions(length, disabledOptions, hideDisabledOptions) {
	  var arr = [];
	  for (var value = 0; value < length; value++) {
	    if (!disabledOptions || disabledOptions.indexOf(value) < 0 || !hideDisabledOptions) {
	      arr.push(value);
	    }
	  }
	  return arr;
	}

	var Panel = _react2['default'].createClass({
	  displayName: 'Panel',

	  propTypes: {
	    prefixCls: _react.PropTypes.string,
	    value: _react.PropTypes.object,
	    locale: _react.PropTypes.object,
	    placeholder: _react.PropTypes.string,
	    gregorianCalendarLocale: _react.PropTypes.object,
	    formatter: _react.PropTypes.object,
	    disabledHours: _react.PropTypes.func,
	    disabledMinutes: _react.PropTypes.func,
	    disabledSeconds: _react.PropTypes.func,
	    hideDisabledOptions: _react.PropTypes.bool,
	    onChange: _react.PropTypes.func,
	    onEsc: _react.PropTypes.func,
	    allowEmpty: _react.PropTypes.bool,
	    showHour: _react.PropTypes.bool,
	    showSecond: _react.PropTypes.bool,
	    onClear: _react.PropTypes.func
	  },

	  mixins: [_mixinCommonMixin2['default']],

	  getDefaultProps: function getDefaultProps() {
	    return {
	      onChange: noop,
	      onClear: noop
	    };
	  },

	  getInitialState: function getInitialState() {
	    return {
	      value: this.props.value,
	      selectionRange: []
	    };
	  },

	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    var value = nextProps.value;
	    if (value) {
	      this.setState({
	        value: value
	      });
	    }
	  },

	  onChange: function onChange(newValue) {
	    this.setState({ value: newValue });
	    this.props.onChange(newValue);
	  },

	  onClear: function onClear() {
	    this.props.onClear();
	  },

	  onCurrentSelectPanelChange: function onCurrentSelectPanelChange(currentSelectPanel) {
	    this.setState({ currentSelectPanel: currentSelectPanel });
	  },

	  render: function render() {
	    var _props = this.props;
	    var locale = _props.locale;
	    var prefixCls = _props.prefixCls;
	    var placeholder = _props.placeholder;
	    var disabledHours = _props.disabledHours;
	    var disabledMinutes = _props.disabledMinutes;
	    var disabledSeconds = _props.disabledSeconds;
	    var hideDisabledOptions = _props.hideDisabledOptions;
	    var allowEmpty = _props.allowEmpty;
	    var showHour = _props.showHour;
	    var showSecond = _props.showSecond;
	    var formatter = _props.formatter;
	    var gregorianCalendarLocale = _props.gregorianCalendarLocale;

	    var value = this.state.value;
	    var disabledHourOptions = disabledHours();
	    var disabledMinuteOptions = disabledMinutes(value ? value.getHourOfDay() : null);
	    var disabledSecondOptions = disabledSeconds(value ? value.getHourOfDay() : null, value ? value.getMinutes() : null);
	    var hourOptions = generateOptions(24, disabledHourOptions, hideDisabledOptions);
	    var minuteOptions = generateOptions(60, disabledMinuteOptions, hideDisabledOptions);
	    var secondOptions = generateOptions(60, disabledSecondOptions, hideDisabledOptions);

	    return _react2['default'].createElement(
	      'div',
	      { className: prefixCls + '-inner' },
	      _react2['default'].createElement(_Header2['default'], {
	        prefixCls: prefixCls,
	        gregorianCalendarLocale: gregorianCalendarLocale,
	        locale: locale,
	        value: value,
	        currentSelectPanel: this.state.currentSelectPanel,
	        onEsc: this.props.onEsc,
	        formatter: formatter,
	        placeholder: placeholder,
	        hourOptions: hourOptions,
	        minuteOptions: minuteOptions,
	        secondOptions: secondOptions,
	        disabledHours: disabledHours,
	        disabledMinutes: disabledMinutes,
	        disabledSeconds: disabledSeconds,
	        onChange: this.onChange,
	        onClear: this.onClear,
	        allowEmpty: allowEmpty
	      }),
	      _react2['default'].createElement(_Combobox2['default'], {
	        prefixCls: prefixCls,
	        value: value,
	        gregorianCalendarLocale: gregorianCalendarLocale,
	        formatter: formatter,
	        onChange: this.onChange,
	        showHour: showHour,
	        showSecond: showSecond,
	        hourOptions: hourOptions,
	        minuteOptions: minuteOptions,
	        secondOptions: secondOptions,
	        disabledHours: disabledHours,
	        disabledMinutes: disabledMinutes,
	        disabledSeconds: disabledSeconds,
	        onCurrentSelectPanelChange: this.onCurrentSelectPanelChange
	      })
	    );
	  }
	});

	exports['default'] = Panel;
	module.exports = exports['default'];

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _react = __webpack_require__(3);

	var _localeEn_US = __webpack_require__(139);

	var _localeEn_US2 = _interopRequireDefault(_localeEn_US);

	exports['default'] = {
	  propTypes: {
	    prefixCls: _react.PropTypes.string,
	    locale: _react.PropTypes.object
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      prefixCls: 'rc-time-picker',
	      locale: _localeEn_US2['default']
	    };
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _gregorianCalendarFormatLibLocaleEn_US = __webpack_require__(140);

	var _gregorianCalendarFormatLibLocaleEn_US2 = _interopRequireDefault(_gregorianCalendarFormatLibLocaleEn_US);

	var _gregorianCalendarLibLocaleEn_US = __webpack_require__(141);

	var _gregorianCalendarLibLocaleEn_US2 = _interopRequireDefault(_gregorianCalendarLibLocaleEn_US);

	exports['default'] = {
	  clear: 'Clear',
	  format: _gregorianCalendarFormatLibLocaleEn_US2['default'],
	  calendar: _gregorianCalendarLibLocaleEn_US2['default']
	};
	module.exports = exports['default'];

/***/ },
/* 140 */
43,
/* 141 */
15,
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _utilSelection = __webpack_require__(143);

	var _utilSelection2 = _interopRequireDefault(_utilSelection);

	var Header = _react2['default'].createClass({
	  displayName: 'Header',

	  propTypes: {
	    formatter: _react.PropTypes.object,
	    prefixCls: _react.PropTypes.string,
	    gregorianCalendarLocale: _react.PropTypes.object,
	    locale: _react.PropTypes.object,
	    disabledDate: _react.PropTypes.func,
	    placeholder: _react.PropTypes.string,
	    value: _react.PropTypes.object,
	    hourOptions: _react.PropTypes.array,
	    minuteOptions: _react.PropTypes.array,
	    secondOptions: _react.PropTypes.array,
	    disabledHours: _react.PropTypes.func,
	    disabledMinutes: _react.PropTypes.func,
	    disabledSeconds: _react.PropTypes.func,
	    onChange: _react.PropTypes.func,
	    onClear: _react.PropTypes.func,
	    onEsc: _react.PropTypes.func,
	    allowEmpty: _react.PropTypes.bool,
	    currentSelectPanel: _react.PropTypes.string
	  },

	  getInitialState: function getInitialState() {
	    var value = this.props.value;
	    return {
	      str: value && this.props.formatter.format(value) || '',
	      invalid: false
	    };
	  },

	  componentDidMount: function componentDidMount() {
	    this.timer = setTimeout(this.selectRange, 0);
	  },

	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    var value = nextProps.value;
	    this.setState({
	      str: value && nextProps.formatter.format(value) || '',
	      invalid: false
	    });
	  },

	  componentDidUpdate: function componentDidUpdate() {
	    this.timer = setTimeout(this.selectRange, 0);
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    clearTimeout(this.timer);
	  },

	  onInputChange: function onInputChange(event) {
	    var str = event.target.value;
	    this.setState({
	      str: str
	    });
	    var value = null;
	    var _props = this.props;
	    var formatter = _props.formatter;
	    var gregorianCalendarLocale = _props.gregorianCalendarLocale;
	    var hourOptions = _props.hourOptions;
	    var minuteOptions = _props.minuteOptions;
	    var secondOptions = _props.secondOptions;
	    var disabledHours = _props.disabledHours;
	    var disabledMinutes = _props.disabledMinutes;
	    var disabledSeconds = _props.disabledSeconds;
	    var onChange = _props.onChange;
	    var allowEmpty = _props.allowEmpty;

	    if (str) {
	      var originalValue = this.props.value;
	      try {
	        value = formatter.parse(str, {
	          locale: gregorianCalendarLocale,
	          obeyCount: true
	        });
	      } catch (ex) {
	        this.setState({
	          invalid: true
	        });
	        return;
	      }

	      if (value) {
	        // if time value not allowed, response warning.
	        if (hourOptions.indexOf(value.getHourOfDay()) < 0 || minuteOptions.indexOf(value.getMinutes()) < 0 || secondOptions.indexOf(value.getSeconds()) < 0) {
	          this.setState({
	            invalid: true
	          });
	          return;
	        }

	        // if time value is disabled, response warning.
	        var disabledHourOptions = disabledHours();
	        var disabledMinuteOptions = disabledMinutes(value.getHourOfDay());
	        var disabledSecondOptions = disabledSeconds(value.getHourOfDay(), value.getMinutes());
	        if (disabledHourOptions && disabledHourOptions.indexOf(value.getHourOfDay()) >= 0 || disabledMinuteOptions && disabledMinuteOptions.indexOf(value.getMinutes()) >= 0 || disabledSecondOptions && disabledSecondOptions.indexOf(value.getSeconds()) >= 0) {
	          this.setState({
	            invalid: true
	          });
	          return;
	        }

	        if (originalValue && value) {
	          if (originalValue.getHourOfDay() !== value.getHourOfDay() || originalValue.getMinutes() !== value.getMinutes() || originalValue.getSeconds() !== value.getSeconds()) {
	            // keep other fields for rc-calendar
	            var changedValue = originalValue.clone();
	            changedValue.setHourOfDay(value.getHourOfDay());
	            changedValue.setMinutes(value.getMinutes());
	            changedValue.setSeconds(value.getSeconds());
	            onChange(changedValue);
	          }
	        } else if (originalValue !== value) {
	          onChange(value);
	        }
	      } else {
	        this.setState({
	          invalid: true
	        });
	        return;
	      }
	    } else if (allowEmpty) {
	      onChange(null);
	    } else {
	      this.setState({
	        invalid: true
	      });
	      return;
	    }

	    this.setState({
	      invalid: false
	    });
	  },

	  onKeyDown: function onKeyDown(e) {
	    if (e.keyCode === 27) {
	      this.props.onEsc();
	    }
	  },

	  onClear: function onClear() {
	    this.setState({ str: '' });
	    this.props.onClear();
	  },

	  getClearButton: function getClearButton() {
	    var _props2 = this.props;
	    var locale = _props2.locale;
	    var prefixCls = _props2.prefixCls;
	    var allowEmpty = _props2.allowEmpty;

	    if (!allowEmpty) {
	      return null;
	    }
	    return _react2['default'].createElement('a', { className: prefixCls + '-clear-btn', role: 'button', title: locale.clear, onMouseDown: this.onClear });
	  },

	  getInput: function getInput() {
	    var _props3 = this.props;
	    var prefixCls = _props3.prefixCls;
	    var placeholder = _props3.placeholder;
	    var _state = this.state;
	    var invalid = _state.invalid;
	    var str = _state.str;

	    var invalidClass = invalid ? prefixCls + '-input-invalid' : '';
	    return _react2['default'].createElement('input', {
	      className: prefixCls + '-input  ' + invalidClass,
	      ref: 'input',
	      onKeyDown: this.onKeyDown,
	      value: str,
	      placeholder: placeholder, onChange: this.onInputChange
	    });
	  },

	  selectRange: function selectRange() {
	    this.refs.input.focus();
	    if (this.props.currentSelectPanel && this.refs.input.value) {
	      var selectionRangeStart = 0;
	      var selectionRangeEnd = 0;
	      if (this.props.currentSelectPanel === 'hour') {
	        selectionRangeStart = 0;
	        selectionRangeEnd = this.refs.input.value.indexOf(':');
	      } else if (this.props.currentSelectPanel === 'minute') {
	        selectionRangeStart = this.refs.input.value.indexOf(':') + 1;
	        selectionRangeEnd = this.refs.input.value.lastIndexOf(':');
	      } else if (this.props.currentSelectPanel === 'second') {
	        selectionRangeStart = this.refs.input.value.lastIndexOf(':') + 1;
	        selectionRangeEnd = this.refs.input.value.length;
	      }
	      if (selectionRangeEnd - selectionRangeStart === 2) {
	        (0, _utilSelection2['default'])(this.refs.input, selectionRangeStart, selectionRangeEnd);
	      }
	    }
	  },

	  render: function render() {
	    var prefixCls = this.props.prefixCls;

	    return _react2['default'].createElement(
	      'div',
	      { className: prefixCls + '-input-wrap' },
	      this.getInput(),
	      this.getClearButton()
	    );
	  }
	});

	exports['default'] = Header;
	module.exports = exports['default'];

/***/ },
/* 143 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = createSelection;

	function createSelection(field, start, end) {
	  if (field.createTextRange) {
	    var selRange = field.createTextRange();
	    selRange.collapse(true);
	    selRange.moveStart('character', start);
	    selRange.moveEnd('character', end);
	    selRange.select();
	    field.focus();
	  } else if (field.setSelectionRange) {
	    field.focus();
	    field.setSelectionRange(start, end);
	  } else if (typeof field.selectionStart !== 'undefined') {
	    field.selectionStart = start;
	    field.selectionEnd = end;
	    field.focus();
	  }
	}

	module.exports = exports['default'];

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _Select = __webpack_require__(145);

	var _Select2 = _interopRequireDefault(_Select);

	var _gregorianCalendar = __webpack_require__(146);

	var _gregorianCalendar2 = _interopRequireDefault(_gregorianCalendar);

	var formatOption = function formatOption(option, disabledOptions) {
	  var value = '' + option;
	  if (option < 10) {
	    value = '0' + option;
	  }

	  var disabled = false;
	  if (disabledOptions && disabledOptions.indexOf(option) >= 0) {
	    disabled = true;
	  }

	  return {
	    value: value,
	    disabled: disabled
	  };
	};

	var Combobox = _react2['default'].createClass({
	  displayName: 'Combobox',

	  propTypes: {
	    formatter: _react.PropTypes.object,
	    prefixCls: _react.PropTypes.string,
	    value: _react.PropTypes.object,
	    onChange: _react.PropTypes.func,
	    showHour: _react.PropTypes.bool,
	    gregorianCalendarLocale: _react.PropTypes.object,
	    showSecond: _react.PropTypes.bool,
	    hourOptions: _react.PropTypes.array,
	    minuteOptions: _react.PropTypes.array,
	    secondOptions: _react.PropTypes.array,
	    disabledHours: _react.PropTypes.func,
	    disabledMinutes: _react.PropTypes.func,
	    disabledSeconds: _react.PropTypes.func,
	    onCurrentSelectPanelChange: _react.PropTypes.func
	  },

	  onItemChange: function onItemChange(type, itemValue) {
	    var onChange = this.props.onChange;

	    var value = this.props.value;
	    if (value) {
	      value = value.clone();
	    } else {
	      value = this.getNow().clone();
	    }
	    if (type === 'hour') {
	      value.setHourOfDay(itemValue);
	    } else if (type === 'minute') {
	      value.setMinutes(itemValue);
	    } else {
	      value.setSeconds(itemValue);
	    }
	    onChange(value);
	  },

	  onEnterSelectPanel: function onEnterSelectPanel(range) {
	    this.props.onCurrentSelectPanelChange(range);
	  },

	  getHourSelect: function getHourSelect(hour) {
	    var _props = this.props;
	    var prefixCls = _props.prefixCls;
	    var hourOptions = _props.hourOptions;
	    var disabledHours = _props.disabledHours;
	    var showHour = _props.showHour;

	    if (!showHour) {
	      return null;
	    }
	    var disabledOptions = disabledHours();

	    return _react2['default'].createElement(_Select2['default'], {
	      prefixCls: prefixCls,
	      options: hourOptions.map(function (option) {
	        return formatOption(option, disabledOptions);
	      }),
	      selectedIndex: hourOptions.indexOf(hour),
	      type: 'hour',
	      onSelect: this.onItemChange,
	      onMouseEnter: this.onEnterSelectPanel.bind(this, 'hour')
	    });
	  },

	  getMinuteSelect: function getMinuteSelect(minute) {
	    var _props2 = this.props;
	    var prefixCls = _props2.prefixCls;
	    var minuteOptions = _props2.minuteOptions;
	    var disabledMinutes = _props2.disabledMinutes;

	    var value = this.props.value || this.getNow();
	    var disabledOptions = disabledMinutes(value.getHourOfDay());

	    return _react2['default'].createElement(_Select2['default'], {
	      prefixCls: prefixCls,
	      options: minuteOptions.map(function (option) {
	        return formatOption(option, disabledOptions);
	      }),
	      selectedIndex: minuteOptions.indexOf(minute),
	      type: 'minute',
	      onSelect: this.onItemChange,
	      onMouseEnter: this.onEnterSelectPanel.bind(this, 'minute')
	    });
	  },

	  getSecondSelect: function getSecondSelect(second) {
	    var _props3 = this.props;
	    var prefixCls = _props3.prefixCls;
	    var secondOptions = _props3.secondOptions;
	    var disabledSeconds = _props3.disabledSeconds;
	    var showSecond = _props3.showSecond;

	    if (!showSecond) {
	      return null;
	    }
	    var value = this.props.value || this.getNow();
	    var disabledOptions = disabledSeconds(value.getHourOfDay(), value.getMinutes());

	    return _react2['default'].createElement(_Select2['default'], {
	      prefixCls: prefixCls,
	      options: secondOptions.map(function (option) {
	        return formatOption(option, disabledOptions);
	      }),
	      selectedIndex: secondOptions.indexOf(second),
	      type: 'second',
	      onSelect: this.onItemChange,
	      onMouseEnter: this.onEnterSelectPanel.bind(this, 'second')
	    });
	  },

	  getNow: function getNow() {
	    if (this.showNow) {
	      return this.showNow;
	    }
	    var value = new _gregorianCalendar2['default'](this.props.gregorianCalendarLocale);
	    value.setTime(Date.now());
	    this.showNow = value;
	    return value;
	  },

	  render: function render() {
	    var prefixCls = this.props.prefixCls;

	    var value = this.props.value || this.getNow();
	    return _react2['default'].createElement(
	      'div',
	      { className: prefixCls + '-combobox' },
	      this.getHourSelect(value.getHourOfDay()),
	      this.getMinuteSelect(value.getMinutes()),
	      this.getSecondSelect(value.getSeconds())
	    );
	  }
	});

	exports['default'] = Combobox;
	module.exports = exports['default'];

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(4);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _classnames2 = __webpack_require__(5);

	var _classnames3 = _interopRequireDefault(_classnames2);

	var scrollTo = function scrollTo(element, to, duration) {
	  var requestAnimationFrame = window.requestAnimationFrame || function requestAnimationFrameTimeout() {
	    return setTimeout(arguments[0], 10);
	  };
	  // jump to target if duration zero
	  if (duration <= 0) {
	    element.scrollTop = to;
	    return;
	  }
	  var difference = to - element.scrollTop;
	  var perTick = difference / duration * 10;

	  requestAnimationFrame(function () {
	    element.scrollTop = element.scrollTop + perTick;
	    if (element.scrollTop === to) return;
	    scrollTo(element, to, duration - 10);
	  });
	};

	var Select = _react2['default'].createClass({
	  displayName: 'Select',

	  propTypes: {
	    prefixCls: _react.PropTypes.string,
	    options: _react.PropTypes.array,
	    gregorianCalendarLocale: _react.PropTypes.object,
	    selectedIndex: _react.PropTypes.number,
	    type: _react.PropTypes.string,
	    onSelect: _react.PropTypes.func,
	    onMouseEnter: _react.PropTypes.func
	  },

	  componentDidMount: function componentDidMount() {
	    // jump to selected option
	    this.scrollToSelected(0);
	  },

	  componentDidUpdate: function componentDidUpdate(prevProps) {
	    // smooth scroll to selected option
	    if (prevProps.selectedIndex !== this.props.selectedIndex) {
	      this.scrollToSelected(120);
	    }
	  },

	  onSelect: function onSelect(value) {
	    var _props = this.props;
	    var onSelect = _props.onSelect;
	    var type = _props.type;

	    onSelect(type, value);
	  },

	  getOptions: function getOptions() {
	    var _this = this;

	    var _props2 = this.props;
	    var options = _props2.options;
	    var selectedIndex = _props2.selectedIndex;
	    var prefixCls = _props2.prefixCls;

	    return options.map(function (item, index) {
	      var _classnames;

	      var cls = (0, _classnames3['default'])((_classnames = {}, _defineProperty(_classnames, prefixCls + '-select-option-selected', selectedIndex === index), _defineProperty(_classnames, prefixCls + '-select-option-disabled', item.disabled), _classnames));
	      var onclick = null;
	      if (!item.disabled) {
	        onclick = _this.onSelect.bind(_this, +item.value);
	      }
	      return _react2['default'].createElement(
	        'li',
	        { className: cls, key: index, onClick: onclick, disabled: item.disabled },
	        item.value
	      );
	    });
	  },

	  scrollToSelected: function scrollToSelected(duration) {
	    // move to selected item
	    var select = _reactDom2['default'].findDOMNode(this);
	    var list = _reactDom2['default'].findDOMNode(this.refs.list);
	    var index = this.props.selectedIndex;
	    if (index < 0) {
	      index = 0;
	    }
	    var topOption = list.children[index];
	    var to = topOption.offsetTop;
	    scrollTo(select, to, duration);
	  },

	  render: function render() {
	    if (this.props.options.length === 0) {
	      return null;
	    }

	    var prefixCls = this.props.prefixCls;

	    return _react2['default'].createElement(
	      'div',
	      { className: prefixCls + '-select',
	        onMouseEnter: this.props.onMouseEnter },
	      _react2['default'].createElement(
	        'ul',
	        { ref: 'list' },
	        this.getOptions()
	      )
	    );
	  }
	});

	exports['default'] = Select;
	module.exports = exports['default'];

/***/ },
/* 146 */
[747, 147, 141, 148],
/* 147 */
[748, 148],
/* 148 */
14,
/* 149 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	var autoAdjustOverflow = {
	  adjustX: 1,
	  adjustY: 1
	};

	var targetOffset = [0, 0];

	var placements = {
	  bottomLeft: {
	    points: ['tl', 'tl'],
	    overflow: autoAdjustOverflow,
	    offset: [0, -3],
	    targetOffset: targetOffset
	  },
	  bottomRight: {
	    points: ['tr', 'tr'],
	    overflow: autoAdjustOverflow,
	    offset: [0, -3],
	    targetOffset: targetOffset
	  },
	  topRight: {
	    points: ['br', 'br'],
	    overflow: autoAdjustOverflow,
	    offset: [0, 3],
	    targetOffset: targetOffset
	  },
	  topLeft: {
	    points: ['bl', 'bl'],
	    overflow: autoAdjustOverflow,
	    offset: [0, 3],
	    targetOffset: targetOffset
	  }
	};

	exports['default'] = placements;
	module.exports = exports['default'];

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports.getFormatter = getFormatter;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _gregorianCalendarFormat = __webpack_require__(151);

	var _gregorianCalendarFormat2 = _interopRequireDefault(_gregorianCalendarFormat);

	function getFormatter(format, locale) {
	  if (typeof format === 'string') {
	    return new _gregorianCalendarFormat2['default'](format, locale.format);
	  }
	  return format;
	}

/***/ },
/* 151 */
[758, 146, 140, 152],
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */

	'use strict';

	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */

	var warning = function() {};

	if (process.env.NODE_ENV !== 'production') {
	  warning = function(condition, format, args) {
	    var len = arguments.length;
	    args = new Array(len > 2 ? len - 2 : 0);
	    for (var key = 2; key < len; key++) {
	      args[key - 2] = arguments[key];
	    }
	    if (format === undefined) {
	      throw new Error(
	        '`warning(condition, format, ...args)` requires a warning ' +
	        'message argument'
	      );
	    }

	    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
	      throw new Error(
	        'The warning format should be able to uniquely identify this ' +
	        'warning. Please, use a more descriptive format than: ' + format
	      );
	    }

	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' +
	        format.replace(/%s/g, function() {
	          return args[argIndex++];
	        });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch(x) {}
	    }
	  };
	}

	module.exports = warning;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(45)))

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Formatter = __webpack_require__(154);
	var Tooltip = __webpack_require__(156);
	var classnames = __webpack_require__(5);
	var i18n = __webpack_require__(208);

	/**
	 * code should be an object like this {'xxxx-xx-xx': 'work/leave/schedule'}
	 */
	var generateContentRender = function generateContentRender(code) {
	    var locale = arguments.length <= 1 || arguments[1] === undefined ? 'zh-cn' : arguments[1];

	    return function contentRender(code, locale, current, value) {
	        // see https://github.com/yiminghe/gregorian-calendar to get details about `current` API
	        var time = current.getTime();
	        var date = Formatter.date(time, 'YYYY-MM-DD');
	        var type = code[date];
	        if (typeof type == 'string') {
	            type = [type];
	        } else if (type == undefined) {
	            type = [];
	        }
	        var tipMap = i18n[locale];
	        var content = [];
	        var isWork = type.indexOf('work') !== -1;
	        var isLeave = type.indexOf('leave') !== -1;
	        var isSchedule = type.indexOf('schedule') !== -1;
	        content.push(React.createElement('span', { key: 'date', className: classnames({
	                'kuma-calendar-date-content': true,
	                'work': isWork,
	                'leave': isLeave,
	                'schedule': isSchedule
	            }) }, current.getDayOfMonth()));
	        if (isSchedule) {
	            content.push(React.createElement('span', { key: 'bottom-line', className: 'kuma-calendar-date-decoration' }));
	        }

	        if (isWork || isLeave) {
	            return React.createElement(Tooltip, { placement: 'right', trigger: ["hover"], overlay: tipMap[isWork ? 'work' : 'leave'] }, React.createElement('div', { className: 'kuma-calendar-date-content-box' }, content));
	        } else {
	            // only one child can be passed.
	            return React.createElement('div', { className: 'kuma-calendar-date-content-box' }, content);
	        }
	    }.bind(null, code, locale);
	};

	module.exports = {
	    generateContentRender: generateContentRender
		};

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Formatter Component for uxcore
	 * @author guanghong.wsj
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

		module.exports = __webpack_require__(155);

/***/ },
/* 155 */
/***/ function(module, exports) {

	"use strict";

	/**
	 * Formatter Component for uxcore
	 * @author eternalsky
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	var Formatter = {};

	Formatter.date = function (str, pattern) {
	    var date = new Date(str);
	    pattern = pattern || 'YYYY-MM-DD';
	    var o = {
	        "M+": date.getMonth() + 1, //月份
	        "D+": date.getDate(), //日
	        "d+": date.getDate(), //日
	        "H+": date.getHours(), //小时
	        "h+": date.getHours(), //小时
	        "m+": date.getMinutes(), //分
	        "s+": date.getSeconds(), //秒
	        "Q+": Math.floor((date.getMonth() + 3) / 3), //季度
	        "q+": Math.floor((date.getMonth() + 3) / 3), //季度
	        "S": date.getMilliseconds() //毫秒
	    };
	    if (/(y+)/i.test(pattern)) {
	        pattern = pattern.replace(RegExp.$1, (date.getFullYear() + "").substr(4 - RegExp.$1.length));
	    }
	    for (var k in o) {
	        if (new RegExp("(" + k + ")").test(pattern)) pattern = pattern.replace(RegExp.$1, RegExp.$1.length == 1 ? o[k] : ("00" + o[k]).substr(("" + o[k]).length));
	    }
	    return pattern;
	};

	Formatter.money = function (str, delimiter, fixedNum) {
	    delimiter = delimiter || " ";
	    if (fixedNum) {
	        str = parseFloat(str).toFixed(fixedNum).toString();
	    }
	    if (str.indexOf(".") !== -1) {
	        return str.replace(/(\d)(?=(?:\d{3})+(\.))/g, function (match, $1) {
	            return $1 + delimiter;
	        }).replace(/(\d{3})(?![$|\.|\(|\s])/g, function (match, $1) {
	            return $1;
	        });
	    } else {
	        return str.replace(/(\d)(?=(?:\d{3})+$)/g, function (match, $1) {
	            return $1 + delimiter;
	        });
	    }
	};

	Formatter.cnmobile = function (str, delimiter) {
	    delimiter = delimiter || " ";
	    return str.replace(/^(\+?0?86)(?!$)/, "$1" + delimiter).replace(/(\d{4})(?!$)/g, "$1" + delimiter);
	};

	Formatter.card = function (str, delimiter) {
	    delimiter = delimiter || " ";
	    return str.replace(/(\d{4})(?!$)/g, "$1" + delimiter);
	};

		module.exports = Formatter;

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Tooltip Component for uxcore
	 * @author 
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

		module.exports = __webpack_require__(157);

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	exports.__esModule = true;

	var _rcTooltip = __webpack_require__(158);

	var _rcTooltip2 = _interopRequireDefault(_rcTooltip);

	var _objectAssign = __webpack_require__(180);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : { "default": obj };
	}

	function _classCallCheck(instance, Constructor) {
		if (!(instance instanceof Constructor)) {
			throw new TypeError("Cannot call a class as a function");
		}
	}

	function _possibleConstructorReturn(self, call) {
		if (!self) {
			throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		}return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
		if (typeof superClass !== "function" && superClass !== null) {
			throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
		}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var Tooltip = function (_RcTooltip) {
		_inherits(Tooltip, _RcTooltip);

		function Tooltip(props) {
			_classCallCheck(this, Tooltip);

			return _possibleConstructorReturn(this, _RcTooltip.call(this, props));
		}

		return Tooltip;
	}(_rcTooltip2["default"]);

	exports["default"] = Tooltip;

	Tooltip.displayName = 'uxcore-tooltip';
	Tooltip.propTypes = _rcTooltip2["default"].propTypes;

	Tooltip.defaultProps = (0, _objectAssign2["default"])(_rcTooltip2["default"].defaultProps, {
		prefixCls: 'kuma-tooltip',
		overlayClassName: 'uxcore'
	});
		module.exports = exports['default'];

/***/ },
/* 158 */
[776, 159],
/* 159 */
[777, 160, 161],
/* 160 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	var autoAdjustOverflow = {
	  adjustX: 1,
	  adjustY: 1
	};

	var targetOffset = [0, 0];

	var placements = {
	  left: {
	    points: ['cr', 'cl'],
	    overflow: autoAdjustOverflow,
	    offset: [-4, 0],
	    targetOffset: targetOffset
	  },
	  right: {
	    points: ['cl', 'cr'],
	    overflow: autoAdjustOverflow,
	    offset: [4, 0],
	    targetOffset: targetOffset
	  },
	  top: {
	    points: ['bc', 'tc'],
	    overflow: autoAdjustOverflow,
	    offset: [0, -4],
	    targetOffset: targetOffset
	  },
	  bottom: {
	    points: ['tc', 'bc'],
	    overflow: autoAdjustOverflow,
	    offset: [0, 4],
	    targetOffset: targetOffset
	  },
	  topLeft: {
	    points: ['bl', 'tl'],
	    overflow: autoAdjustOverflow,
	    offset: [0, -4],
	    targetOffset: targetOffset
	  },
	  leftTop: {
	    points: ['tr', 'tl'],
	    overflow: autoAdjustOverflow,
	    offset: [-3, 0],
	    targetOffset: targetOffset
	  },
	  topRight: {
	    points: ['br', 'tr'],
	    overflow: autoAdjustOverflow,
	    offset: [0, -4],
	    targetOffset: targetOffset
	  },
	  rightTop: {
	    points: ['tl', 'tr'],
	    overflow: autoAdjustOverflow,
	    offset: [4, 0],
	    targetOffset: targetOffset
	  },
	  bottomRight: {
	    points: ['tr', 'br'],
	    overflow: autoAdjustOverflow,
	    offset: [0, 4],
	    targetOffset: targetOffset
	  },
	  rightBottom: {
	    points: ['bl', 'br'],
	    overflow: autoAdjustOverflow,
	    offset: [4, 0],
	    targetOffset: targetOffset
	  },
	  bottomLeft: {
	    points: ['tl', 'bl'],
	    overflow: autoAdjustOverflow,
	    offset: [0, 4],
	    targetOffset: targetOffset
	  },
	  leftBottom: {
	    points: ['br', 'bl'],
	    overflow: autoAdjustOverflow,
	    offset: [-4, 0],
	    targetOffset: targetOffset
	  }
	};

	exports.placements = placements;
	exports['default'] = placements;

/***/ },
/* 161 */
[759, 162],
/* 162 */
[760, 163, 184, 207],
/* 163 */
[749, 164, 165, 167, 168, 169, 170, 175, 176, 181, 182, 183],
/* 164 */
17,
/* 165 */
[750, 166],
/* 166 */
19,
/* 167 */
[751, 166],
/* 168 */
21,
/* 169 */
[752, 170],
/* 170 */
[753, 171],
/* 171 */
[754, 172, 173, 174],
/* 172 */
25,
/* 173 */
26,
/* 174 */
27,
/* 175 */
28,
/* 176 */
[755, 177],
/* 177 */
[756, 178],
/* 178 */
[757, 179, 180],
/* 179 */
32,
/* 180 */
33,
/* 181 */
34,
/* 182 */
35,
/* 183 */
36,
/* 184 */
[761, 185, 196, 205, 206],
/* 185 */
[762, 186],
/* 186 */
[763, 187, 163, 195],
/* 187 */
[764, 188, 189, 190, 191, 192, 193],
/* 188 */
66,
/* 189 */
[765, 188],
/* 190 */
[766, 188, 189],
/* 191 */
[767, 188],
/* 192 */
[768, 188],
/* 193 */
[769, 194],
/* 194 */
72,
/* 195 */
73,
/* 196 */
[770, 197],
/* 197 */
[771, 198, 199, 204],
/* 198 */
76,
/* 199 */
[772, 200, 204],
/* 200 */
[773, 201, 202],
/* 201 */
79,
/* 202 */
[774, 203, 203],
/* 203 */
81,
/* 204 */
82,
/* 205 */
[775, 206],
/* 206 */
84,
/* 207 */
85,
/* 208 */
/***/ function(module, exports) {

	'use strict';

	var locale = {
	    'zh-cn': {
	        'work': '上班',
	        'leave': '休假'
	    },
	    'en-us': {
	        'work': 'work',
	        'leave': 'leave'
	    }
	};

	locale['en'] = locale['en-us'];

	module.exports = locale;

/***/ },
/* 209 */
/***/ function(module, exports) {

	/*
	 * zh-cn locale
	 * @ignore
	 * @author yiminghe@gmail.com
	 */
	"use strict";

	module.exports = {
	  // in minutes
	  timezoneOffset: 8 * 60,
	  firstDayOfWeek: 1,
	  minimalDaysInFirstWeek: 1
		};

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _zh_CN = __webpack_require__(211);

	var _zh_CN2 = _interopRequireDefault(_zh_CN);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}

	exports["default"] = {
	  today: '今天',
	  now: '此刻',
	  ok: '确定',
	  clear: '清除',
	  month: '月',
	  year: '年',
	  previousMonth: '上个月 (翻页上键)',
	  nextMonth: '下个月 (翻页下键)',
	  monthSelect: '选择月份',
	  yearSelect: '选择年份',
	  decadeSelect: '选择年代',
	  yearFormat: 'yyyy\'年\'',
	  monthFormat: 'M\'月\'',
	  dateFormat: 'yyyy\'年\'M\'月\'d\'日\'',
	  previousYear: '上一年 (Control键加左方向键)',
	  nextYear: '下一年 (Control键加右方向键)',
	  previousDecade: '上一年代',
	  nextDecade: '下一年代',
	  previousCentury: '上一世纪',
	  nextCentury: '下一世纪',
	  format: _zh_CN2["default"]
	};
		module.exports = exports['default'];

/***/ },
/* 211 */
/***/ function(module, exports) {

	'use strict';

	module.exports = {
	  eras: ['公元前', '公元'],
	  months: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'],
	  shortMonths: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'],
	  weekdays: ['星期天', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'],
	  shortWeekdays: ['周日', '周一', '周二', '周三', '周四', '周五', '周六'],
	  veryShortWeekdays: ['日', '一', '二', '三', '四', '五', '六'],
	  ampms: ['上午', '下午'],
	  datePatterns: ['yyyy\'年\'M\'月\'d\'日\' EEEE', 'yyyy\'年\'M\'月\'d\'日\'', 'yyyy-M-d', 'yy-M-d'],
	  timePatterns: ['ahh\'时\'mm\'分\'ss\'秒\' \'GMT\'Z', 'ahh\'时\'mm\'分\'ss\'秒\'', 'H:mm:ss', 'ah:mm'],
	  dateTimePattern: '{date} {time}'
		};

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _gregorianCalendarFormatLibLocaleZh_CN = __webpack_require__(213);

	var _gregorianCalendarFormatLibLocaleZh_CN2 = _interopRequireDefault(_gregorianCalendarFormatLibLocaleZh_CN);

	var _gregorianCalendarLibLocaleZh_CN = __webpack_require__(214);

	var _gregorianCalendarLibLocaleZh_CN2 = _interopRequireDefault(_gregorianCalendarLibLocaleZh_CN);

	exports['default'] = {
	  clear: '清除',
	  format: _gregorianCalendarFormatLibLocaleZh_CN2['default'],
	  calendar: _gregorianCalendarLibLocaleZh_CN2['default']
	};
	module.exports = exports['default'];

/***/ },
/* 213 */
211,
/* 214 */
209,
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * CheckboxGroup Component for uxcore
	 * @author eternalsky
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

		module.exports = __webpack_require__(216);

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	/**
	 * CheckboxGroup Component for uxcore
	 * @author eternalsky
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	var Item = __webpack_require__(217);
	var assign = __webpack_require__(218);
	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var CheckboxGroup = function (_React$Component) {
	    _inherits(CheckboxGroup, _React$Component);

	    function CheckboxGroup(props) {
	        _classCallCheck(this, CheckboxGroup);

	        return _possibleConstructorReturn(this, _React$Component.call(this, props));
	    }

	    CheckboxGroup.prototype.componentWillMount = function componentWillMount() {
	        var me = this;
	        me.selected = me._copy(me.props.value) || [];
	    };

	    CheckboxGroup.prototype.componentDidUpdate = function componentDidUpdate() {
	        var me = this;
	        me.selected = me._copy(me.props.value) || [];
	    };

	    CheckboxGroup.prototype._copy = function _copy(a) {
	        return JSON.parse(JSON.stringify(a));
	    };

	    CheckboxGroup.prototype._processChild = function _processChild() {
	        var me = this;
	        var length = React.Children.count(me.props.children);
	        if (!length) return false;
	        var elements = React.Children.map(me.props.children, function (child, index) {
	            if (!!child.type && child.type.displayName == "CheckboxItem") {
	                return React.cloneElement(child, {
	                    jsxdisabled: me.props.disabled,
	                    onChange: me._handleChange.bind(me),
	                    key: index,
	                    checked: me.props.value.indexOf(child.props.value) != -1
	                });
	            }
	        });
	        return elements;
	    };

	    CheckboxGroup.prototype._handleChange = function _handleChange(checked, value) {
	        var me = this;
	        if (checked) {
	            // me.selected = me.selected.concat([value]);
	            me.selected.push(value);
	        } else {
	            me.selected = me.selected.filter(function (item) {
	                return item != value;
	            });
	        }
	        me.props.onChange(JSON.parse(JSON.stringify(me.selected)));
	    };

	    CheckboxGroup.prototype.render = function render() {
	        var me = this;
	        return React.createElement("div", { className: me.props.className }, me._processChild());
	    };

	    return CheckboxGroup;
	}(React.Component);

	CheckboxGroup.Item = Item;

	CheckboxGroup.defaultProps = {
	    value: [],
	    onChange: function onChange() {},
	    disabled: false,
	    className: 'kuma-checkbox-group'
	};

	// http://facebook.github.io/react/docs/reusable-components.html
	CheckboxGroup.propTypes = {
	    value: React.PropTypes.array,
	    onChange: React.PropTypes.func,
	    disabled: React.PropTypes.bool,
	    className: React.PropTypes.string
	};

	CheckboxGroup.displayName = "CheckboxGroup";

	module.exports = CheckboxGroup;

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var CheckboxItem = function (_React$Component) {
	    _inherits(CheckboxItem, _React$Component);

	    function CheckboxItem(props) {
	        _classCallCheck(this, CheckboxItem);

	        return _possibleConstructorReturn(this, _React$Component.call(this, props));
	    }

	    CheckboxItem.prototype._handleChange = function _handleChange(e) {
	        var me = this;
	        me.props.onChange(e.currentTarget.checked, me.props.value);
	    };

	    CheckboxItem.prototype.render = function render() {
	        var me = this;
	        var disabled = false;
	        if ('disabled' in me.props) {
	            disabled = me.props.disabled;
	        } else {
	            disabled = me.props.jsxdisabled;
	        }
	        return React.createElement('label', null, React.createElement('input', { type: 'checkbox', disabled: disabled, ref: 'checkbox', checked: me.props.checked, className: me.props.className, onChange: me._handleChange.bind(me) }), React.createElement('s', null), React.createElement('span', { dangerouslySetInnerHTML: { __html: me.props.text } }));
	    };

	    return CheckboxItem;
	}(React.Component);

	CheckboxItem.defaultProps = {
	    value: "",
	    className: "kuma-checkbox",
	    onChange: function onChange() {}
	};

	CheckboxItem.propTypes = {
	    value: React.PropTypes.string,
	    disabled: React.PropTypes.bool,
	    className: React.PropTypes.string,
	    onChange: React.PropTypes.func
	};

	CheckboxItem.displayName = "CheckboxItem";

	module.exports = CheckboxItem;

/***/ },
/* 218 */
33,
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Collapse Component for uxcore
	 * @author vicent.bian
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

		module.exports = __webpack_require__(220);

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(4);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _Panel = __webpack_require__(221);

	var _Panel2 = _interopRequireDefault(_Panel);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}

	var Collapse = (0, _react.createClass)({
	  statics: {
	    Panel: _Panel2["default"]
	  },

	  propTypes: {
	    prefixCls: _react.PropTypes.string,
	    activeKey: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.arrayOf(_react.PropTypes.string)]),
	    defaultActiveKey: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.arrayOf(_react.PropTypes.string)]),
	    onChange: _react.PropTypes.func,
	    accordion: _react.PropTypes.bool
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      prefixCls: 'kuma-collapse',
	      onChange: function onChange() {},
	      accordion: false
	    };
	  },
	  getInitialState: function getInitialState() {
	    var _props = this.props;
	    var activeKey = _props.activeKey;
	    var accordion = _props.accordion;
	    var defaultActiveKey = this.props.defaultActiveKey;
	    // If is not accordion mode, then, defaultActiveKey should be an array

	    if (!accordion) {
	      defaultActiveKey = defaultActiveKey || [];
	    }

	    return {
	      activeKey: activeKey || defaultActiveKey
	    };
	  },
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    if ('activeKey' in nextProps) {
	      this.setState({
	        activeKey: nextProps.activeKey
	      });
	    }
	  },
	  handleClickItem: function handleClickItem(key) {
	    var _this = this;

	    return function () {
	      var activeKey = _this._getActivityKey();
	      if (_this.props.accordion) {
	        _this.setState({
	          activeKey: key === activeKey ? null : key
	        });
	      } else {
	        var index = activeKey.indexOf(key);
	        var isActive = index > -1;
	        if (isActive) {
	          // remove active state
	          activeKey.splice(index, 1);
	        } else {
	          activeKey.push(key);
	        }

	        _this.setState({ activeKey: activeKey });
	      }
	      _this.props.onChange(key);
	    };
	  },
	  _getActivityKey: function _getActivityKey() {
	    var activeKey = this.state.activeKey;
	    var accordion = this.props.accordion;

	    if (accordion && Array.isArray(activeKey)) {
	      activeKey = activeKey[0];
	    }

	    if (!accordion && !Array.isArray(activeKey)) {
	      activeKey = activeKey ? [activeKey] : [];
	    }
	    return activeKey;
	  },
	  getItems: function getItems() {
	    var _this2 = this;

	    var activeKey = this._getActivityKey();
	    var _props2 = this.props;
	    var prefixCls = _props2.prefixCls;
	    var accordion = _props2.accordion;

	    return _react.Children.map(this.props.children, function (child, index) {
	      // If there is no key provide, use the panel order as default key
	      var key = child.key || index;
	      var header = child.props.header;
	      var isActive = false;
	      if (accordion) {
	        isActive = activeKey === key;
	      } else {
	        isActive = activeKey.indexOf(key) > -1;
	      }

	      var props = {
	        key: key,
	        header: header,
	        isActive: isActive,
	        prefixCls: prefixCls,
	        children: child.props.children,
	        onItemClick: _this2.handleClickItem(key).bind(_this2)
	      };

	      return _react2["default"].createElement(_Panel2["default"], props);
	    });
	  },
	  render: function render() {
	    var prefixCls = this.props.prefixCls;
	    return _react2["default"].createElement('div', { className: prefixCls }, this.getItems());
	  }
	});

	exports["default"] = Collapse;
	module.exports = exports['default'];

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(4);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _classnames2 = __webpack_require__(5);

	var _classnames3 = _interopRequireDefault(_classnames2);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}

	var CollapsePanel = (0, _react.createClass)({
	  propTypes: {
	    prefixCls: _react.PropTypes.string,
	    header: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.number, _react.PropTypes.node]),
	    isActive: _react.PropTypes.bool,
	    onItemClick: _react.PropTypes.func
	  },

	  getInitialState: function getInitialState() {
	    return { isActive: this.props.isActive };
	  },
	  getDefaultProps: function getDefaultProps() {
	    return {
	      isActive: false,
	      onItemClick: function onItemClick() {}
	    };
	  },
	  handleItemClick: function handleItemClick() {
	    this.props.onItemClick();
	  },
	  render: function render() {
	    var _classnames;

	    var _props = this.props;
	    var prefixCls = _props.prefixCls;
	    var header = _props.header;
	    var children = _props.children;
	    var isActive = _props.isActive;

	    var headerCls = prefixCls + '-header';
	    var contentCls = (0, _classnames3["default"])((_classnames = {}, _classnames[prefixCls + '-content'] = true, _classnames[prefixCls + '-content-active'] = isActive, _classnames));

	    return _react2["default"].createElement('div', { className: prefixCls + '-item' }, _react2["default"].createElement('div', { className: headerCls, onClick: this.handleItemClick,
	      role: 'tab', 'aria-expanded': isActive }, _react2["default"].createElement('i', { className: 'arrow' }), header), _react2["default"].createElement('div', { className: contentCls,
	      'data-active': isActive,
	      role: 'tabpanel' }, _react2["default"].createElement('div', { className: prefixCls + '-content-box' }, children)));
	  }
	});

	exports["default"] = CollapsePanel;
	module.exports = exports['default'];

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Const Component for uxcore
	 * @author zhouquan.yezq
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

		module.exports = __webpack_require__(223);

/***/ },
/* 223 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Const Component for uxcore
	 * @author zhouquan.yezq
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	var Const = {
	  MODE: {
	    VIEW: 'view',
	    EDIT: 'edit'
	  },
	  ENV: {
	    DEBUG: 'debug',
	    LIVE: 'live'
	  }
	};

		module.exports = Const;

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Crumb Component for uxcore
	 * @author peijie.dpj
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

		module.exports = __webpack_require__(225);

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	  } else {
	    obj[key] = value;
	  }return obj;
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _possibleConstructorReturn(self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	/**
	 * Crumb Component for uxcore
	 * @author peijie.dpj
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	var CrumbItem = __webpack_require__(226);
	var classnames = __webpack_require__(5);
	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var Crumb = function (_React$Component) {
	  _inherits(Crumb, _React$Component);

	  function Crumb(props) {
	    _classCallCheck(this, Crumb);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(Crumb).call(this, props));
	  }

	  _createClass(Crumb, [{
	    key: 'render',
	    value: function render() {
	      var _classnames;

	      var props = this.props;

	      return React.createElement('div', { className: classnames((_classnames = {}, _defineProperty(_classnames, props.prefixCls, true), _defineProperty(_classnames, props.className, !!props.className), _classnames)) }, React.Children.map(this.props.children, function (item) {
	        return React.createElement(CrumbItem, item.props, item.props.children);
	      }));
	    }
	  }]);

	  return Crumb;
	}(React.Component);

	Crumb.defaultProps = {
	  prefixCls: 'kuma-uxcrumbs'
	};

	// http://facebook.github.io/react/docs/reusable-components.html
	Crumb.propTypes = {
	  prefixCls: React.PropTypes.string,
	  className: React.PropTypes.string
	};

	Crumb.Item = CrumbItem;

	Crumb.displayName = 'Crumb';

	module.exports = Crumb;

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	  } else {
	    obj[key] = value;
	  }return obj;
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _possibleConstructorReturn(self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	/**
	 * CrumbItem Component for uxcore
	 * @author peijie.dpj
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	var classnames = __webpack_require__(5);
	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var CrumbItem = function (_React$Component) {
	  _inherits(CrumbItem, _React$Component);

	  function CrumbItem(props) {
	    _classCallCheck(this, CrumbItem);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(CrumbItem).call(this, props));
	  }

	  _createClass(CrumbItem, [{
	    key: 'render',
	    value: function render() {
	      var props = this.props;

	      return !props.href ? React.createElement('span', { className: classnames(_defineProperty({}, props.className, !!props.className)) }, props.children) : React.createElement('a', { href: props.href, className: props.className }, props.children);
	    }
	  }]);

	  return CrumbItem;
	}(React.Component);

	CrumbItem.defaultProps = {};

	// http://facebook.github.io/react/docs/reusable-components.html
	CrumbItem.propTypes = {
	  href: React.PropTypes.string,
	  className: React.PropTypes.string
	};

	CrumbItem.displayName = 'CrumbItem';

	module.exports = CrumbItem;

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Dialog Component for uxcore
	 * @author 
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

		module.exports = __webpack_require__(228);

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	exports.__esModule = true;

	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};

	var _rcDialog = __webpack_require__(229);

	var _rcDialog2 = _interopRequireDefault(_rcDialog);

	var _confirm = __webpack_require__(274);

	var _confirm2 = _interopRequireDefault(_confirm);

	var _uxcoreButton = __webpack_require__(6);

	var _uxcoreButton2 = _interopRequireDefault(_uxcoreButton);

	var _i18n = __webpack_require__(275);

	var _i18n2 = _interopRequireDefault(_i18n);

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { "default": obj };
	}

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	} /**
	   * @author: vincent
	   * @date: 15/5/19
	   */

	function noop() {}

	var Dialog = function (_React$Component) {
	    _inherits(Dialog, _React$Component);

	    function Dialog(props) {
	        _classCallCheck(this, Dialog);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.state = {
	            confirmLoading: false,
	            visible: _this.props.visible
	        };
	        return _this;
	    }

	    Dialog.prototype.handleCancel = function handleCancel() {
	        this.props.onCancel();
	    };

	    Dialog.prototype.handleOk = function handleOk() {
	        this.props.onOk();
	    };

	    Dialog.prototype.render = function render() {
	        var props = this.props;
	        var locale = _i18n2["default"][props.locale];
	        var defaultFooter = [_react2["default"].createElement(_uxcoreButton2["default"], { key: 'confirm',
	            type: 'primary',
	            size: 'medium',
	            loading: props.confirmLoading,
	            onClick: this.handleOk.bind(this) }, locale['ok']), _react2["default"].createElement(_uxcoreButton2["default"], { key: 'cancel',
	            type: 'secondary',
	            size: 'medium',
	            onClick: this.handleCancel.bind(this) }, locale['cancel'])];
	        var footer = props.footer || defaultFooter;
	        var className = void 0;
	        if (!props.title) {
	            className = props.className + ' ' + props.prefixCls + '-noheader';
	        } else {
	            className = props.className;
	        }
	        console.log(props.title, className);
	        return _react2["default"].createElement(_rcDialog2["default"], _extends({
	            onClose: this.handleCancel.bind(this),
	            footer: footer
	        }, props, {
	            className: className,
	            visible: props.visible }));
	    };

	    return Dialog;
	}(_react2["default"].Component);

	exports["default"] = Dialog;

	Dialog.defaultProps = {
	    prefixCls: 'kuma-dlg',
	    className: '',
	    onOk: noop,
	    locale: 'zh-cn',
	    onCancel: noop,
	    width: 520,
	    transitionName: '',
	    maskAnimation: false,
	    confirmLoading: false,
	    visible: false,
	    closable: true,
	    maskClosable: false,
	    title: ''
	};

	Dialog.info = function (props) {
	    props.iconClassName = 'kuma-icon-information';
	    props.okCancel = false;
	    return (0, _confirm2["default"])(props);
	};

	Dialog.success = function (props) {
	    props.iconClassName = 'kuma-icon-success';
	    props.okCancel = false;
	    return (0, _confirm2["default"])(props);
	};

	Dialog.error = function (props) {
	    props.iconClassName = 'kuma-icon-error';
	    props.okCancel = false;
	    return (0, _confirm2["default"])(props);
	};

	Dialog.confirm = function (props) {
	    props.okCancel = true;
	    return (0, _confirm2["default"])(props);
	};
		module.exports = exports['default'];

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(230);

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ('value' in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	var _get = function get(_x, _x2, _x3) {
	  var _again = true;_function: while (_again) {
	    var object = _x,
	        property = _x2,
	        receiver = _x3;_again = false;if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
	      var parent = Object.getPrototypeOf(object);if (parent === null) {
	        return undefined;
	      } else {
	        _x = parent;_x2 = property;_x3 = receiver;_again = true;desc = parent = undefined;continue _function;
	      }
	    } else if ('value' in desc) {
	      return desc.value;
	    } else {
	      var getter = desc.get;if (getter === undefined) {
	        return undefined;
	      }return getter.call(receiver);
	    }
	  }
	};

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError('Cannot call a class as a function');
	  }
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== 'function' && superClass !== null) {
	    throw new TypeError('Super expression must either be null or a function, not ' + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(4);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _Dialog = __webpack_require__(231);

	var _Dialog2 = _interopRequireDefault(_Dialog);

	function noop() {}

	function copy(obj, fields) {
	  var ret = {};
	  fields.forEach(function (f) {
	    if (obj[f] !== undefined) {
	      ret[f] = obj[f];
	    }
	  });
	  return ret;
	}

	var DialogWrap = function (_React$Component) {
	  _inherits(DialogWrap, _React$Component);

	  function DialogWrap(props) {
	    var _this = this;

	    _classCallCheck(this, DialogWrap);

	    _get(Object.getPrototypeOf(DialogWrap.prototype), 'constructor', this).call(this, props);
	    this.state = {
	      visible: props.visible
	    };
	    ['onClose', 'cleanDialogContainer'].forEach(function (m) {
	      _this[m] = _this[m].bind(_this);
	    });
	  }

	  _createClass(DialogWrap, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      this.componentDidUpdate();
	    }
	  }, {
	    key: 'componentWillReceiveProps',
	    value: function componentWillReceiveProps(props) {
	      if ('visible' in props) {
	        this.setState({
	          visible: props.visible
	        });
	      }
	    }
	  }, {
	    key: 'shouldComponentUpdate',
	    value: function shouldComponentUpdate(nextProps, nextState) {
	      return !!(this.state.visible || nextState.visible);
	    }
	  }, {
	    key: 'componentDidUpdate',
	    value: function componentDidUpdate() {
	      if (this.dialogRendered) {
	        this.dialogInstance = _reactDom2['default'].unstable_renderSubtreeIntoContainer(this, this.getDialogElement(), this.getDialogContainer());
	      }
	    }
	  }, {
	    key: 'componentWillUnmount',
	    value: function componentWillUnmount() {
	      if (this.dialogContainer) {
	        if (this.state.visible) {
	          _reactDom2['default'].unstable_renderSubtreeIntoContainer(this, this.getDialogElement({
	            onAfterClose: this.cleanDialogContainer,
	            onClose: noop,
	            visible: false
	          }), this.dialogContainer);
	        } else {
	          this.cleanDialogContainer();
	        }
	      }
	    }
	  }, {
	    key: 'onClose',
	    value: function onClose(e) {
	      this.props.onClose(e);
	    }
	  }, {
	    key: 'getDialogContainer',
	    value: function getDialogContainer() {
	      if (!this.dialogContainer) {
	        this.dialogContainer = document.createElement('div');
	        this.dialogContainer.className = this.props.prefixCls + '-container';
	        document.body.appendChild(this.dialogContainer);
	      }
	      return this.dialogContainer;
	    }
	  }, {
	    key: 'getDialogElement',
	    value: function getDialogElement(extra) {
	      var props = this.props;
	      var dialogProps = copy(props, ['className', 'closable', 'maskClosable', 'align', 'title', 'footer', 'mask', 'animation', 'transitionName', 'maskAnimation', 'maskTransitionName', 'mousePosition', 'prefixCls', 'style', 'width', 'height', 'zIndex', 'bodyStyle']);
	      dialogProps = _extends({}, dialogProps, {
	        onClose: this.onClose,
	        visible: this.state.visible
	      }, extra);
	      return _react2['default'].createElement(_Dialog2['default'], _extends({}, dialogProps, { key: 'dialog' }), props.children);
	    }
	  }, {
	    key: 'getElement',
	    value: function getElement(part) {
	      return this.dialogInstance.getElement(part);
	    }
	  }, {
	    key: 'cleanDialogContainer',
	    value: function cleanDialogContainer() {
	      _reactDom2['default'].unmountComponentAtNode(this.getDialogContainer());
	      document.body.removeChild(this.dialogContainer);
	      this.dialogContainer = null;
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      this.dialogRendered = this.dialogRendered || this.state.visible;
	      return null;
	    }
	  }]);

	  return DialogWrap;
	}(_react2['default'].Component);

	DialogWrap.defaultProps = {
	  className: '',
	  align: {
	    points: ['tc', 'tc'],
	    offset: [0, 100]
	  },
	  mask: true,
	  closable: true,
	  maskClosable: true,
	  prefixCls: 'rc-dialog',
	  onClose: noop
	};

	DialogWrap.propTypes = {
	  className: _react2['default'].PropTypes.string,
	  align: _react2['default'].PropTypes.shape({
	    align: _react2['default'].PropTypes.array,
	    offset: _react2['default'].PropTypes.arrayOf(_react2['default'].PropTypes.number)
	  }),
	  mask: _react2['default'].PropTypes.bool,
	  closable: _react2['default'].PropTypes.bool,
	  maskClosable: _react2['default'].PropTypes.bool,
	  prefixCls: _react2['default'].PropTypes.string,
	  visible: _react2['default'].PropTypes.bool,
	  onClose: _react2['default'].PropTypes.func
	};

	exports['default'] = DialogWrap;
	module.exports = exports['default'];

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	  } else {
	    obj[key] = value;
	  }return obj;
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(4);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _rcAlign = __webpack_require__(232);

	var _rcAlign2 = _interopRequireDefault(_rcAlign);

	var _rcUtilLibKeyCode = __webpack_require__(247);

	var _rcUtilLibKeyCode2 = _interopRequireDefault(_rcUtilLibKeyCode);

	var _rcAnimate = __webpack_require__(264);

	var _rcAnimate2 = _interopRequireDefault(_rcAnimate);

	var _DOMWrap = __webpack_require__(273);

	var _DOMWrap2 = _interopRequireDefault(_DOMWrap);

	var _classnames = __webpack_require__(5);

	var _classnames2 = _interopRequireDefault(_classnames);

	function noop() {}

	function getScroll(w, top) {
	  var ret = w['page' + (top ? 'Y' : 'X') + 'Offset'];
	  var method = 'scroll' + (top ? 'Top' : 'Left');
	  if (typeof ret !== 'number') {
	    var d = w.document;
	    ret = d.documentElement[method];
	    if (typeof ret !== 'number') {
	      ret = d.body[method];
	    }
	  }
	  return ret;
	}

	function setTransformOrigin(node, value) {
	  var style = node.style;
	  ['Webkit', 'Moz', 'Ms', 'ms'].forEach(function (prefix) {
	    style[prefix + 'TransformOrigin'] = value;
	  });
	  style['transformOrigin'] = value;
	}

	function offset(el) {
	  var rect = el.getBoundingClientRect();
	  var pos = {
	    left: rect.left,
	    top: rect.top
	  };
	  var doc = el.ownerDocument;
	  var w = doc.defaultView || doc.parentWindow;
	  pos.left += getScroll(w);
	  pos.top += getScroll(w, 1);
	  return pos;
	}

	var Dialog = _react2['default'].createClass({
	  displayName: 'Dialog',

	  propTypes: {
	    onAfterClose: _react.PropTypes.func,
	    onClose: _react.PropTypes.func,
	    closable: _react.PropTypes.bool,
	    maskClosable: _react.PropTypes.bool,
	    visible: _react.PropTypes.bool,
	    mousePosition: _react.PropTypes.object
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      onAfterClose: noop,
	      onClose: noop
	    };
	  },

	  componentDidMount: function componentDidMount() {
	    this.componentDidUpdate({});
	  },

	  componentDidUpdate: function componentDidUpdate(prevProps) {
	    var props = this.props;
	    if (props.visible) {
	      // first show
	      if (!prevProps.visible) {
	        this.lastOutSideFocusNode = document.activeElement;
	        _reactDom2['default'].findDOMNode(this.refs.dialog).focus();
	      }
	    } else if (prevProps.visible) {
	      if (props.mask && this.lastOutSideFocusNode) {
	        try {
	          this.lastOutSideFocusNode.focus();
	        } catch (e) {
	          this.lastOutSideFocusNode = null;
	        }
	        this.lastOutSideFocusNode = null;
	      }
	    }
	  },

	  onAnimateLeave: function onAnimateLeave() {
	    this.props.onAfterClose();
	  },

	  onMaskClick: function onMaskClick(e) {
	    if (this.props.closable && this.props.maskClosable) {
	      this.close(e);
	    }
	    _reactDom2['default'].findDOMNode(this.refs.dialog).focus();
	  },

	  onKeyDown: function onKeyDown(e) {
	    var props = this.props;
	    if (props.closable) {
	      if (e.keyCode === _rcUtilLibKeyCode2['default'].ESC) {
	        this.close(e);
	      }
	    }
	    // keep focus inside dialog
	    if (props.visible) {
	      if (e.keyCode === _rcUtilLibKeyCode2['default'].TAB) {
	        var activeElement = document.activeElement;
	        var dialogRoot = _reactDom2['default'].findDOMNode(this.refs.dialog);
	        var sentinel = this.refs.sentinel;
	        if (e.shiftKey) {
	          if (activeElement === dialogRoot) {
	            sentinel.focus();
	          }
	        } else if (activeElement === this.refs.sentinel) {
	          dialogRoot.focus();
	        }
	      }
	    }
	  },

	  onAlign: function onAlign(dialogNode) {
	    var mousePosition = this.props.mousePosition;
	    if (this.props.visible) {
	      if (mousePosition) {
	        var elOffset = offset(dialogNode);
	        setTransformOrigin(dialogNode, mousePosition.x - elOffset.left + 'px ' + (mousePosition.y - elOffset.top) + 'px');
	      } else {
	        setTransformOrigin(dialogNode, '');
	      }
	    }
	  },

	  getDialogElement: function getDialogElement() {
	    var props = this.props;
	    var closable = props.closable;
	    var prefixCls = props.prefixCls;
	    var dest = {};
	    if (props.width !== undefined) {
	      dest.width = props.width;
	    }
	    if (props.height !== undefined) {
	      dest.height = props.height;
	    }
	    if (props.zIndex !== undefined) {
	      dest.zIndex = props.zIndex;
	    }

	    var footer = undefined;
	    if (props.footer) {
	      footer = _react2['default'].createElement('div', { className: prefixCls + '-footer', ref: 'footer' }, props.footer);
	    }

	    var header = undefined;
	    if (props.title) {
	      header = _react2['default'].createElement('div', { className: prefixCls + '-header', ref: 'header' }, _react2['default'].createElement('div', { className: prefixCls + '-title' }, props.title));
	    }

	    var closer = undefined;
	    if (closable) {
	      closer = _react2['default'].createElement('a', { tabIndex: '0', onClick: this.close, className: prefixCls + '-close' }, _react2['default'].createElement('span', { className: prefixCls + '-close-x' }));
	    }

	    var style = _extends({}, props.style, dest);
	    var dialogProps = {
	      className: [props.prefixCls, props.className].join(' '),
	      tabIndex: '0',
	      role: 'dialog',
	      ref: 'dialog',
	      style: style,
	      onKeyDown: this.onKeyDown
	    };
	    var transitionName = this.getTransitionName();
	    var dialogElement = _react2['default'].createElement(_DOMWrap2['default'], _extends({}, dialogProps, {
	      hiddenClassName: prefixCls + '-hidden' }), _react2['default'].createElement('div', { className: prefixCls + '-content' }, closer, header, _react2['default'].createElement('div', { className: prefixCls + '-body', style: props.bodyStyle, ref: 'body' }, props.children), footer), _react2['default'].createElement('div', { tabIndex: '0', ref: 'sentinel', style: { width: 0, height: 0, overflow: 'hidden' } }, 'sentinel'));
	    // add key for align to keep animate children stable
	    return _react2['default'].createElement(_rcAnimate2['default'], { key: 'dialog',
	      showProp: 'dialogVisible',
	      onLeave: this.onAnimateLeave,
	      transitionName: transitionName,
	      component: '',
	      transitionAppear: true }, _react2['default'].createElement(_rcAlign2['default'], { align: props.align,
	      key: 'dialog',
	      onAlign: this.onAlign,
	      dialogVisible: props.visible,
	      childrenProps: {
	        visible: 'dialogVisible'
	      },
	      monitorBufferTime: 80,
	      monitorWindowResize: true,
	      disabled: !props.visible }, dialogElement));
	  },

	  getMaskElement: function getMaskElement() {
	    var props = this.props;
	    var maskProps = {
	      onClick: this.onMaskClick
	    };

	    if (props.zIndex) {
	      maskProps.style = { zIndex: props.zIndex };
	    }
	    var maskElement = undefined;
	    if (props.mask) {
	      var maskTransition = this.getMaskTransitionName();
	      maskElement = _react2['default'].createElement(_DOMWrap2['default'], _extends({}, maskProps, { key: 'mask',
	        className: props.prefixCls + '-mask',
	        visible: props.visible,
	        hiddenClassName: props.prefixCls + '-mask-hidden' }));
	      if (maskTransition) {
	        maskElement = _react2['default'].createElement(_rcAnimate2['default'], { key: 'mask', showProp: 'visible',
	          transitionAppear: true, component: '',
	          transitionName: maskTransition }, maskElement);
	      }
	    }
	    return maskElement;
	  },

	  getMaskTransitionName: function getMaskTransitionName() {
	    var props = this.props;
	    var transitionName = props.maskTransitionName;
	    var animation = props.maskAnimation;
	    if (!transitionName && animation) {
	      transitionName = props.prefixCls + '-' + animation;
	    }
	    return transitionName;
	  },

	  getTransitionName: function getTransitionName() {
	    var props = this.props;
	    var transitionName = props.transitionName;
	    var animation = props.animation;
	    if (!transitionName && animation) {
	      transitionName = props.prefixCls + '-' + animation;
	    }
	    return transitionName;
	  },

	  getElement: function getElement(part) {
	    return this.refs[part];
	  },

	  close: function close(e) {
	    this.props.onClose(e);
	  },

	  render: function render() {
	    var props = this.props;
	    var prefixCls = props.prefixCls;
	    var className = _defineProperty({}, prefixCls + '-wrap', 1);

	    return _react2['default'].createElement('div', { className: (0, _classnames2['default'])(className), ref: 'root' }, [this.getMaskElement(), this.getDialogElement()]);
	  }
	});

	exports['default'] = Dialog;
	module.exports = exports['default'];

/***/ },
/* 232 */
[762, 233],
/* 233 */
[763, 234, 242, 263],
/* 234 */
[764, 235, 236, 237, 238, 239, 240],
/* 235 */
66,
/* 236 */
[765, 235],
/* 237 */
[766, 235, 236],
/* 238 */
[767, 235],
/* 239 */
[768, 235],
/* 240 */
[769, 241],
/* 241 */
72,
/* 242 */
[749, 243, 244, 246, 247, 248, 249, 254, 255, 260, 261, 262],
/* 243 */
17,
/* 244 */
[750, 245],
/* 245 */
19,
/* 246 */
[751, 245],
/* 247 */
21,
/* 248 */
[752, 249],
/* 249 */
[753, 250],
/* 250 */
[754, 251, 252, 253],
/* 251 */
25,
/* 252 */
26,
/* 253 */
27,
/* 254 */
28,
/* 255 */
[755, 256],
/* 256 */
[756, 257],
/* 257 */
[757, 258, 259],
/* 258 */
32,
/* 259 */
33,
/* 260 */
34,
/* 261 */
35,
/* 262 */
36,
/* 263 */
73,
/* 264 */
[770, 265],
/* 265 */
[771, 266, 267, 272],
/* 266 */
76,
/* 267 */
[772, 268, 272],
/* 268 */
[773, 269, 270],
/* 269 */
79,
/* 270 */
[774, 271, 271],
/* 271 */
81,
/* 272 */
82,
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var DOMWrap = _react2['default'].createClass({
	  displayName: 'DOMWrap',

	  propTypes: {
	    tag: _react2['default'].PropTypes.string
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      tag: 'div'
	    };
	  },

	  render: function render() {
	    var props = _extends({}, this.props);
	    if (!props.visible) {
	      props.className = props.className || '';
	      props.className += ' ' + props.hiddenClassName;
	    }
	    var Tag = props.tag;
	    return _react2['default'].createElement(Tag, props);
	  }
	});

	exports['default'] = DOMWrap;
	module.exports = exports['default'];

/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	exports["default"] = function (props) {
	    var div = document.createElement('div');
	    document.body.appendChild(div);

	    var d = void 0;
	    props = props || {};
	    props.iconClassName = props.iconClassName || 'kuma-icon-caution';
	    var width = props.width || 300;

	    props.locale = props.locale || 'zh-cn';
	    var locale = _i18n2["default"][props.locale];

	    // 默认为 true，保持向下兼容
	    if (!('okCancel' in props)) {
	        props.okCancel = true;
	    }

	    function close() {
	        d.setState({
	            visible: false
	        });
	        _reactDom2["default"].unmountComponentAtNode(div);
	        document.body.removeChild(div);
	    }

	    function onCancel() {
	        var cancelFn = props.onCancel;
	        if (cancelFn) {
	            var ret = void 0;
	            if (cancelFn.length) {
	                ret = cancelFn(close);
	            } else {
	                ret = cancelFn();
	                if (!ret) {
	                    close();
	                }
	            }
	            if (ret && ret.then) {
	                ret.then(close);
	            }
	        } else {
	            close();
	        }
	    }

	    function onOk() {
	        var okFn = props.onOk;
	        if (okFn) {
	            var ret = void 0;
	            if (okFn.length) {
	                ret = okFn(close);
	            } else {
	                ret = okFn();
	                if (!ret) {
	                    close();
	                }
	            }
	            if (ret && ret.then) {
	                ret.then(close);
	            }
	        } else {
	            close();
	        }
	    }

	    var body = _react2["default"].createElement('div', { className: 'kuma-confirm-body' }, _react2["default"].createElement('i', { className: 'kuma-icon ' + props.iconClassName }), _react2["default"].createElement('span', { className: 'kuma-confirm-title' }, props.title), _react2["default"].createElement('div', { className: 'kuma-confirm-content' }, props.content));
	    var footer = void 0;

	    if (props.okCancel) {
	        footer = _react2["default"].createElement('div', { className: 'kuma-confirm-action' }, _react2["default"].createElement(_uxcoreButton2["default"], { size: props.buttonSize || "small", onClick: onOk }, locale['ok']), _react2["default"].createElement(_uxcoreButton2["default"], { type: 'secondary', size: props.buttonSize || "small", onClick: onCancel }, locale['cancel']));
	    } else {
	        footer = _react2["default"].createElement('div', { className: 'kuma-confirm-action' }, _react2["default"].createElement(_uxcoreButton2["default"], { size: props.buttonSize || "small", onClick: onOk }, locale['isee']));
	    }

	    _reactDom2["default"].render(_react2["default"].createElement(_Dialog2["default"], {
	        prefixCls: 'kuma-dlg',
	        className: 'kuma-dlg-confirm',
	        onCancel: onCancel,
	        visible: true,
	        closable: true,
	        title: '',
	        footer: '',
	        transitionName: props.transitionName || "threeFallV",
	        maskTransitionName: props.transitionName || "fade", width: width }, _react2["default"].createElement('div', null, body, ' ', footer)), div, function () {
	        d = this;
	    });
	};

	var _uxcoreButton = __webpack_require__(6);

	var _uxcoreButton2 = _interopRequireDefault(_uxcoreButton);

	var _Dialog = __webpack_require__(228);

	var _Dialog2 = _interopRequireDefault(_Dialog);

	var _i18n = __webpack_require__(275);

	var _i18n2 = _interopRequireDefault(_i18n);

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(4);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { "default": obj };
	}

	module.exports = exports['default'];

/***/ },
/* 275 */
/***/ function(module, exports) {

	'use strict';

	module.exports = {
	    'zh-cn': {
	        'ok': '确定',
	        'cancel': '取消',
	        'isee': '知道了'
	    },
	    'en-us': {
	        'ok': 'ok',
	        'cancel': 'cancel',
	        'isee': 'ok'
	    }
		};

/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Dropdown Component for uxcore
	 * @author 
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

		module.exports = __webpack_require__(277);

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	exports.__esModule = true;

	var _rcDropdown = __webpack_require__(278);

	var _rcDropdown2 = _interopRequireDefault(_rcDropdown);

	var _objectAssign = __webpack_require__(299);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : { "default": obj };
	}

	function _classCallCheck(instance, Constructor) {
		if (!(instance instanceof Constructor)) {
			throw new TypeError("Cannot call a class as a function");
		}
	}

	function _possibleConstructorReturn(self, call) {
		if (!self) {
			throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		}return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
		if (typeof superClass !== "function" && superClass !== null) {
			throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
		}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var Dropdown = function (_RcDropdown) {
		_inherits(Dropdown, _RcDropdown);

		function Dropdown(props) {
			_classCallCheck(this, Dropdown);

			return _possibleConstructorReturn(this, _RcDropdown.call(this, props));
		}

		return Dropdown;
	}(_rcDropdown2["default"]);

	Dropdown.displayName = 'uxcore-dropdown';
	Dropdown.propTypes = _rcDropdown2["default"].propTypes;
	Dropdown.defaultProps = (0, _objectAssign2["default"])(_rcDropdown2["default"].defaultProps, {
		prefixCls: 'kuma-dropdown',
		overlayClassName: 'uxcore'
	});

	exports["default"] = Dropdown;
	module.exports = exports['default'];

/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Dropdown = __webpack_require__(279);

	var _Dropdown2 = _interopRequireDefault(_Dropdown);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}

	exports["default"] = _Dropdown2["default"];
	module.exports = exports['default'];

/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(4);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _rcTrigger = __webpack_require__(280);

	var _rcTrigger2 = _interopRequireDefault(_rcTrigger);

	var _placements = __webpack_require__(327);

	var _placements2 = _interopRequireDefault(_placements);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	  } else {
	    obj[key] = value;
	  }return obj;
	}

	function _objectWithoutProperties(obj, keys) {
	  var target = {};for (var i in obj) {
	    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	  }return target;
	}

	/*

	 var MenuItem = Menu.Item;

	 var menu = <Menu><MenuItem>1</MenuItem></Menu>;

	 <DropDown trigger="click" animationName="" overlay={<>} onSelect={}>
	 <button>open</button>
	 </DropDown>
	 */

	var Dropdown = _react2["default"].createClass({
	  displayName: 'Dropdown',

	  propTypes: {
	    minOverlayWidthMatchTrigger: _react.PropTypes.bool,
	    onVisibleChange: _react.PropTypes.func,
	    prefixCls: _react.PropTypes.string,
	    children: _react.PropTypes.any,
	    transitionName: _react.PropTypes.string,
	    overlayClassName: _react.PropTypes.string,
	    animation: _react.PropTypes.any,
	    align: _react.PropTypes.object,
	    overlayStyle: _react.PropTypes.object,
	    placement: _react.PropTypes.string,
	    trigger: _react.PropTypes.array,
	    showAction: _react.PropTypes.array,
	    hideAction: _react.PropTypes.array,
	    getPopupContainer: _react.PropTypes.func
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      minOverlayWidthMatchTrigger: true,
	      prefixCls: 'rc-dropdown',
	      trigger: ['hover'],
	      showAction: [],
	      hideAction: [],
	      overlayClassName: '',
	      overlayStyle: {},
	      defaultVisible: false,
	      onVisibleChange: function onVisibleChange() {},

	      placement: 'bottomLeft'
	    };
	  },
	  getInitialState: function getInitialState() {
	    var props = this.props;
	    if ('visible' in props) {
	      return {
	        visible: props.visible
	      };
	    }
	    return {
	      visible: props.defaultVisible
	    };
	  },
	  componentWillReceiveProps: function componentWillReceiveProps(props) {
	    if ('visible' in props) {
	      this.setState({
	        visible: props.visible
	      });
	    }
	  },
	  onClick: function onClick(e) {
	    var props = this.props;
	    var overlayProps = props.overlay.props;
	    if (!('visible' in props)) {
	      this.setState({
	        visible: false
	      });
	    }
	    if (overlayProps.onClick) {
	      overlayProps.onClick(e);
	    }
	  },
	  onVisibleChange: function onVisibleChange(v) {
	    var props = this.props;
	    if (!('visible' in props)) {
	      this.setState({
	        visible: v
	      });
	    }
	    props.onVisibleChange(v);
	  },
	  getMenuElement: function getMenuElement() {
	    var props = this.props;
	    return _react2["default"].cloneElement(props.overlay, {
	      prefixCls: props.prefixCls + '-menu',
	      onClick: this.onClick
	    });
	  },
	  getPopupDomNode: function getPopupDomNode() {
	    return this.refs.trigger.getPopupDomNode();
	  },
	  afterVisibleChange: function afterVisibleChange(visible) {
	    if (visible && this.props.minOverlayWidthMatchTrigger) {
	      var overlayNode = this.getPopupDomNode();
	      var rootNode = _reactDom2["default"].findDOMNode(this);
	      if (rootNode.offsetWidth > overlayNode.offsetWidth) {
	        overlayNode.style.width = rootNode.offsetWidth + 'px';
	      }
	    }
	  },
	  render: function render() {
	    var _extends2;

	    var _props = this.props;
	    var prefixCls = _props.prefixCls;
	    var children = _props.children;
	    var transitionName = _props.transitionName;
	    var animation = _props.animation;
	    var align = _props.align;
	    var placement = _props.placement;
	    var getPopupContainer = _props.getPopupContainer;
	    var showAction = _props.showAction;
	    var hideAction = _props.hideAction;
	    var overlayClassName = _props.overlayClassName;
	    var overlayStyle = _props.overlayStyle;
	    var trigger = _props.trigger;

	    var otherProps = _objectWithoutProperties(_props, ['prefixCls', 'children', 'transitionName', 'animation', 'align', 'placement', 'getPopupContainer', 'showAction', 'hideAction', 'overlayClassName', 'overlayStyle', 'trigger']);

	    return _react2["default"].createElement(_rcTrigger2["default"], _extends({}, otherProps, (_extends2 = {
	      prefixCls: prefixCls,
	      ref: 'trigger',
	      popupClassName: overlayClassName,
	      popupStyle: overlayStyle,
	      builtinPlacements: _placements2["default"],
	      action: trigger,
	      showAction: showAction
	    }, _defineProperty(_extends2, 'showAction', showAction), _defineProperty(_extends2, 'hideAction', hideAction), _defineProperty(_extends2, 'popupPlacement', placement), _defineProperty(_extends2, 'popupAlign', align), _defineProperty(_extends2, 'popupTransitionName', transitionName), _defineProperty(_extends2, 'popupAnimation', animation), _defineProperty(_extends2, 'popupVisible', this.state.visible), _defineProperty(_extends2, 'afterPopupVisibleChange', this.afterVisibleChange), _defineProperty(_extends2, 'popup', this.getMenuElement()), _defineProperty(_extends2, 'onPopupVisibleChange', this.onVisibleChange), _defineProperty(_extends2, 'getPopupContainer', getPopupContainer), _extends2)), children);
	  }
	});

	exports["default"] = Dropdown;
	module.exports = exports['default'];

/***/ },
/* 280 */
[759, 281],
/* 281 */
[760, 282, 303, 326],
/* 282 */
[749, 283, 284, 286, 287, 288, 289, 294, 295, 300, 301, 302],
/* 283 */
17,
/* 284 */
[750, 285],
/* 285 */
19,
/* 286 */
[751, 285],
/* 287 */
21,
/* 288 */
[752, 289],
/* 289 */
[753, 290],
/* 290 */
[754, 291, 292, 293],
/* 291 */
25,
/* 292 */
26,
/* 293 */
27,
/* 294 */
28,
/* 295 */
[755, 296],
/* 296 */
[756, 297],
/* 297 */
[757, 298, 299],
/* 298 */
32,
/* 299 */
33,
/* 300 */
34,
/* 301 */
35,
/* 302 */
36,
/* 303 */
[761, 304, 315, 324, 325],
/* 304 */
[762, 305],
/* 305 */
[763, 306, 282, 314],
/* 306 */
[764, 307, 308, 309, 310, 311, 312],
/* 307 */
66,
/* 308 */
[765, 307],
/* 309 */
[766, 307, 308],
/* 310 */
[767, 307],
/* 311 */
[768, 307],
/* 312 */
[769, 313],
/* 313 */
72,
/* 314 */
73,
/* 315 */
[770, 316],
/* 316 */
[771, 317, 318, 323],
/* 317 */
76,
/* 318 */
[772, 319, 323],
/* 319 */
[773, 320, 321],
/* 320 */
79,
/* 321 */
[774, 322, 322],
/* 322 */
81,
/* 323 */
82,
/* 324 */
[775, 325],
/* 325 */
84,
/* 326 */
85,
/* 327 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var autoAdjustOverflow = {
	  adjustX: 1,
	  adjustY: 1
	};

	var targetOffset = [0, 0];

	var placements = exports.placements = {
	  topLeft: {
	    points: ['bl', 'tl'],
	    overflow: autoAdjustOverflow,
	    offset: [0, -4],
	    targetOffset: targetOffset
	  },
	  bottomLeft: {
	    points: ['tl', 'bl'],
	    overflow: autoAdjustOverflow,
	    offset: [0, 4],
	    targetOffset: targetOffset
	  }
	};

		exports["default"] = placements;

/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/**
	 * Form Component for uxcore
	 * @author eternalsky
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	var Form = __webpack_require__(329);

	// 以 Form 插件的形式给出
	Form.TextAreaFormField = __webpack_require__(349);
	Form.InputFormField = __webpack_require__(350);
	Form.RadioGroupFormField = __webpack_require__(351);
	Form.SelectFormField = __webpack_require__(355);
	Form.NumberInputFormField = __webpack_require__(426);
	Form.DateFormField = __webpack_require__(427);
	Form.CheckboxGroupFormField = __webpack_require__(490);
	Form.CascadeSelectFormField = __webpack_require__(491);
	Form.OtherFormField = __webpack_require__(492);
	Form.ButtonGroupFormField = __webpack_require__(493);
	Form.EditorFormField = __webpack_require__(494);
	Form.SearchFormField = __webpack_require__(500);

	module.exports = Form;

/***/ },
/* 329 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	    return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	    return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof2(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	/**
	 * Form Component for uxcore
	 * @author eternalsky
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);
	var FormRow = __webpack_require__(330);
	var FormRowTitle = __webpack_require__(331);
	var FormField = __webpack_require__(332);

	var Constants = __webpack_require__(222);
	var Validators = __webpack_require__(337);
	var KeyCode = __webpack_require__(340);

	var classnames = __webpack_require__(5);
	var assign = __webpack_require__(333);
	var deepcopy = __webpack_require__(341);
	var deepEqual = __webpack_require__(334);

	var Form = function (_React$Component) {
	    _inherits(Form, _React$Component);

	    function Form(props) {
	        _classCallCheck(this, Form);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.fields = {};
	        _this.errors = {};
	        _this.data = {};
	        _this.state = {};
	        return _this;
	    }

	    Form.prototype.componentDidMount = function componentDidMount() {
	        var me = this;
	    };

	    Form.prototype._copy = function _copy(a) {
	        return deepcopy(a);
	    };

	    Form.prototype.attachFormField = function attachFormField(field) {
	        var name = field.getName();
	        if (!name) {
	            console.warn("Each field needs a name to identify itself");
	        } else {
	            this.fields[name] = field;
	        }
	    };

	    Form.prototype.detachFormField = function detachFormField(field) {
	        var name = field.getName();
	        delete this.fields[name];
	        delete this.data[name];
	    };

	    Form.prototype.handleDataChange = function handleDataChange(field, fieldData, fromMount) {
	        var me = this;
	        me.data[field.props.jsxname] = fieldData.value;
	        if (!fromMount) {
	            me.props.jsxonChange(me._copy(me.data), field.props.jsxname, fieldData.pass);
	        }
	    };

	    Form.prototype.getValues = function getValues(force) {
	        var me = this;
	        var _flag = me.doValidate(force);
	        return {
	            values: me._copy(me.data),
	            pass: _flag
	        };
	    };

	    Form.prototype.resetValues = function resetValues() {
	        var me = this;
	        var keys = Object.keys(me.fields);
	        var data = me.props.jsxvalues || me.props.passedData || {};
	        for (var i = 0; i < keys.length; i++) {
	            me.fields[keys[i]].handleDataChange(data[keys[i]] == undefined ? null : data[keys[i]], true);
	        }
	    };

	    /*
	     * set Form values manually
	     */

	    Form.prototype.setValues = function setValues(data) {
	        if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) != 'object') return;
	        var me = this;
	        var savedData = me.data;
	        var keys = Object.keys(data);
	        for (var i = 0; i < keys.length; i++) {
	            if (!deepEqual(data[keys[i]], savedData[keys[i]])) {
	                me.fields[keys[i]].handleDataChange(data[keys[i]] == undefined ? null : data[keys[i]], true);
	            }
	        }
	    };

	    Form.prototype.doValidate = function doValidate(force) {
	        var me = this;
	        var pass = true;
	        var keys = Object.keys(me.fields);
	        for (var i = 0; i < keys.length; i++) {
	            var itemPass = me.fields[keys[i]].doValidate(force);
	            me.errors[keys[i]] = !itemPass;
	            if (!itemPass) {
	                pass = false;
	            }
	        }
	        return pass;
	    };

	    Form.prototype.isDirty = function isDirty() {
	        return !this.doValidate();
	    };

	    /*
	     * 统一数据流，所有的 props，通过 Form -> FormRow -> FormField 向下传递，如果有的
	     * 子元素是 FormField，则自动在他的外面包一层 FormRow。
	     * @param {React Elements Array} children this.props.children
	     */

	    Form.prototype._processChild = function _processChild(children) {
	        var length = React.Children.count(children);
	        var elements = [];
	        if (length == 0) {
	            console.warn("FORM: You must pass children to the form component");
	            return false;
	        }

	        React.Children.forEach(children, function (child, index) {
	            // 如果是自己添加的 DOM 直接抛弃
	            if (typeof child.type == 'function') {
	                if (/FormField/.test(child.type.displayName)) {
	                    elements.push(React.createElement(FormRow, null, child));
	                } else if (/FormRow/.test(child.type.displayName)) {
	                    elements.push(child);
	                }
	            }
	        });

	        return elements;
	    };

	    Form.prototype.render = function render() {
	        var _classnames;

	        var me = this;
	        var elements = me._processChild(me.props.children);

	        return React.createElement('div', { className: classnames((_classnames = {}, _classnames[me.props.jsxprefixCls] = true, _classnames[me.props.className] = !!me.props.className, _classnames["kuma-uxform-edit-mode"] = me.props.jsxmode == Constants.MODE.EDIT, _classnames["kuma-uxform-view-mode"] = me.props.jsxmode == Constants.MODE.VIEW, _classnames)) }, !!elements && elements.map(function (child, index) {
	            return React.cloneElement(child, {
	                mode: me.props.jsxmode,
	                instantValidate: me.props.instantValidate,
	                data: deepcopy(me.props.jsxvalues || me.props.passedData || {}),
	                key: index,
	                attachFormField: me.attachFormField.bind(me),
	                detachFormField: me.detachFormField.bind(me),
	                handleDataChange: me.handleDataChange.bind(me),
	                getValues: me.getValues.bind(me),
	                resetValues: me.resetValues.bind(me)
	            });
	        }));
	    };

	    return Form;
	}(React.Component);

	// 以 Form 的插件的形式给出

	Form.FormRow = FormRow;
	Form.FormRowTitle = FormRowTitle;
	Form.FormField = FormField;

	// Form.MentionFormField = MentionFormField;
	Form.Constants = Constants;
	Form.Validators = Validators;
	Form.KeyCode = KeyCode;

	Form.defaultProps = {
	    jsxprefixCls: "kuma-uxform",
	    jsxmode: Constants.MODE.EDIT,
	    instantValidate: true,
	    jsxonChange: function jsxonChange() {}
	};

	// http://facebook.github.io/react/docs/reusable-components.html
	Form.propTypes = {
	    jsxprefixCls: React.PropTypes.string,
	    jsxmode: React.PropTypes.string,
	    jsxvalues: React.PropTypes.object,
	    instantValidate: React.PropTypes.bool,
	    jsxonChange: React.PropTypes.func
	};

	Form.displayName = "Form";

	module.exports = Form;

/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);
	var classnames = __webpack_require__(5);

	var FormRow = function (_React$Component) {
	    _inherits(FormRow, _React$Component);

	    function FormRow(props) {
	        _classCallCheck(this, FormRow);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.totalFlex = 0;
	        return _this;
	    }

	    FormRow.prototype._processChild = function _processChild(children) {
	        var me = this;
	        me.totalFlex = 0;
	        var length = React.Children.count(children);
	        var elements = [];
	        if (length == 0) {
	            console.warn("FORM: You must pass children to the form component");
	            return false;
	        }
	        React.Children.forEach(children, function (child, index) {
	            // 如果是自己添加的 DOM 直接抛弃
	            if (typeof child.type == 'function') {
	                if (/FormField/.test(child.type.displayName)) {
	                    if (child.props.jsxshow) {
	                        me.totalFlex += child.props.jsxflex;
	                    }
	                    elements.push(child);
	                }
	            }
	        });

	        return elements;
	    };

	    FormRow.prototype.render = function render() {
	        var _classnames;

	        var me = this;
	        var elements = me._processChild(me.props.children);
	        return React.createElement('div', { className: classnames((_classnames = {}, _classnames[me.props.jsxprefixCls] = true, _classnames[me.props.className] = !!me.props.className, _classnames)) }, !!elements && elements.map(function (child, index) {
	            var value = me.props.data[child.props.jsxname];
	            return React.cloneElement(child, {
	                mode: me.props.mode,
	                jsxinstant: me.props.instantValidate,
	                value: value,
	                key: child.props.jsxname || index,
	                style: { width: child.props.jsxflex / me.totalFlex * 100 + '%' },
	                attachFormField: me.props.attachFormField,
	                detachFormField: me.props.detachFormField,
	                handleDataChange: me.props.handleDataChange,
	                getValues: me.props.getValues,
	                resetValues: me.props.resetValues
	            });

	            return child;
	        }));
	    };

	    return FormRow;
	}(React.Component);

	FormRow.defaultProps = {
	    jsxprefixCls: "kuma-uxform-row"
	};
	FormRow.propTypes = {
	    jsxprefixCls: React.PropTypes.string
	};
	FormRow.displayName = "FormRow";

	module.exports = FormRow;

/***/ },
/* 331 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	/**
	 * @author: zhouquan.yezq
	 * @time: 8/7 2015
	 * Form Row Title
	 */
	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);
	var Constants = __webpack_require__(222);
	var classnames = __webpack_require__(5);

	var FormRowTitle = function (_React$Component) {
	    _inherits(FormRowTitle, _React$Component);

	    function FormRowTitle(props) {
	        _classCallCheck(this, FormRowTitle);

	        return _possibleConstructorReturn(this, _React$Component.call(this, props));
	    }

	    FormRowTitle.prototype.render = function render() {
	        var _classnames;

	        var me = this;
	        var length = React.Children.count(me.props.children);
	        return React.createElement('div', { className: classnames((_classnames = {}, _classnames[me.props.jsxprefixCls] = true, _classnames[me.props.className] = !!me.props.className, _classnames)) }, me.props.jsxtitle, !!length && React.Children.map(me.props.children, function (item) {
	            return item;
	        }));
	    };

	    return FormRowTitle;
	}(React.Component);

	;

	FormRowTitle.propTypes = {
	    jsxprefixCls: React.PropTypes.string,
	    jsxtitle: React.PropTypes.string
	};

	FormRowTitle.defaultProps = {
	    jsxprefixCls: "kuma-uxform-row-title",
	    jsxtitle: ""
	};

	FormRowTitle.displayName = "FormRowTitle";

	module.exports = FormRowTitle;

/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	    return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	    return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof2(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);
	var Constants = __webpack_require__(222);
	var classnames = __webpack_require__(5);
	var assign = __webpack_require__(333);
	var deepequal = __webpack_require__(334);

	var FormField = function (_React$Component) {
	    _inherits(FormField, _React$Component);

	    function FormField(props) {
	        _classCallCheck(this, FormField);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.state = {
	            value: props.value,
	            formatValue: _this.formatValue(props.value),
	            error: false,
	            errMsg: ''
	        };
	        return _this;
	    }

	    FormField.prototype.componentDidMount = function componentDidMount() {
	        var me = this;
	        if (!me.props.standalone) {
	            me.props.attachFormField(me);
	            me.props.handleDataChange(me, {
	                value: me.props.value,
	                pass: true
	            }, true);
	        }
	    };

	    FormField.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	        var me = this;
	        if (!me._isEqual(nextProps.value, me.props.value)) {
	            me.handleDataChange(nextProps.value, true);
	        }
	    };

	    FormField.prototype._isEqual = function _isEqual(a, b) {
	        return deepequal(a, b);
	    };

	    FormField.prototype.componentWillUnmount = function componentWillUnmount() {
	        var me = this;
	        if (!me.props.standalone) {
	            this.props.detachFormField(this);
	        }
	    };

	    FormField.prototype.getName = function getName() {
	        return this.props.jsxname;
	    };

	    /*
	     * Fired when field value changes，update form's state and then trigger re-render.
	     * @param fromReset {boolean} if handleDataChange is invoked by form's resetValues,
	     * doValidate should not be invoked.
	     */

	    FormField.prototype.handleDataChange = function handleDataChange(value, fromReset) {
	        var me = this;
	        me.setState({
	            value: value,
	            formatValue: me.formatValue(value),
	            error: !!fromReset ? false : me.state.error,
	            /*
	             * why set state fromReset? some field like editor cannot be reset in the common way
	             * so set this state to tell the field that you need to reset by yourself.
	             */
	            fromReset: !!fromReset
	        }, function () {
	            var pass = true;
	            // validateOnBlur only support InputFormField & TextAraeFormField now
	            if (!fromReset && !me.props.standalone && !me.props.validateOnBlur) {
	                pass = me.doValidate();
	            }
	            !!me.props.handleDataChange && me.props.handleDataChange(me, {
	                value: value,
	                pass: pass
	            });
	        });
	    };

	    /**
	     * @return {boolean} if validate pass, return true, or, return false
	     * if no rule, it means validate pass.
	     */

	    FormField.prototype.doValidate = function doValidate(force) {
	        var me = this;
	        var instant = true;
	        if ('instantValidate' in me.props) {
	            instant = me.props.instantValidate;
	        } else {
	            instant = me.props.jsxinstant;
	        }
	        // `force` has the top priority, `undefined` is not equal to `false`
	        // `instant` has the sceond priority here
	        // eternalsky@2016.03.15
	        if (force === true || force !== false && instant) {
	            if (me.props.jsxrules) {
	                var error = me.isDirty();
	                me.setState({ error: error.isDirty, errMsg: error.errMsg });
	                return !error.isDirty;
	            } else {
	                return true;
	            }
	        } else {
	            return true;
	        }
	    };

	    /*
	     * rule can be an object, containing errMsg & validator,
	     * and rule can also be an array containing such objects.
	     * this func will check them one by one, and return false
	     * unless all rules pass
	     */

	    FormField.prototype.isDirty = function isDirty() {
	        var me = this;
	        var rules = me.props.jsxrules;
	        var isDirty = false;
	        var errMsg = "";
	        if ((typeof rules === 'undefined' ? 'undefined' : _typeof(rules)) == "object" && !Array.isArray(rules)) {
	            isDirty = !rules.validator(me.state.value);
	            errMsg = rules.errMsg;
	        } else if (Array.isArray(rules)) {
	            for (var i = 0; i < rules.length; i++) {
	                isDirty = !rules[i].validator(me.state.value);
	                if (isDirty) {
	                    errMsg = rules[i].errMsg;
	                    break;
	                }
	            }
	        }
	        return {
	            isDirty: isDirty,
	            errMsg: errMsg
	        };
	    };

	    FormField.prototype.renderTips = function renderTips() {
	        var me = this;
	        var mode = me.props.jsxmode || me.props.mode;
	        if (mode != Constants.MODE.EDIT) return;
	        if (me.props.standalone && me.props.message && me.props.message.type == "tip") {
	            return React.createElement('li', { className: 'kuma-uxform-tips' }, React.createElement('i', { className: 'kuma-icon kuma-icon-information' }), me.props.message.message);
	        }
	        if (!!this.props.jsxtips && !me.state.error) {
	            return React.createElement('li', { className: 'kuma-uxform-tips' }, React.createElement('i', { className: 'kuma-icon kuma-icon-information' }), this.props.jsxtips);
	        }
	    };

	    /*
	     * You should rewrite this method，when you need to format the value as you concern.
	     */

	    FormField.prototype.formatValue = function formatValue(value) {
	        return value;
	    };

	    /*
	     * You should rewrite this method, when you are developing a new type of form field.
	     */

	    FormField.prototype.renderField = function renderField() {};

	    FormField.prototype.renderErrorMsg = function renderErrorMsg() {
	        var me = this;
	        var mode = me.props.jsxmode || me.props.mode;
	        if (mode != Constants.MODE.EDIT) return;
	        if (me.props.standalone && me.props.message && me.props.message.type == "error") {
	            return React.createElement('li', { className: 'kuma-uxform-errormsg' }, React.createElement('i', { className: 'kuma-icon kuma-icon-error' }), me.props.message.message);
	        }
	        if (!!me.state.error) {
	            return React.createElement('li', { className: 'kuma-uxform-errormsg' }, React.createElement('i', { className: 'kuma-icon kuma-icon-error' }), me.state.errMsg);
	        }
	    };

	    FormField.prototype.renderLabel = function renderLabel() {
	        var me = this;
	        var mode = me.props.jsxmode || me.props.mode;
	        var align = me.props.verticalAlign || me.props.jsxVerticalAlign; // jsxVerticalAlign is an internal varible.
	        if (me.props.jsxshowLabel) {
	            return React.createElement('label', { className: classnames({
	                    "kuma-label": true,
	                    "vertical-align": align
	                }) }, React.createElement('span', { className: 'required' }, me.props.required && mode == Constants.MODE.EDIT ? "* " : ""), React.createElement('span', { className: 'label-content', dangerouslySetInnerHTML: { __html: me.props.jsxlabel } }));
	        }
	    };

	    FormField.prototype.addSpecificClass = function addSpecificClass(classname) {
	        return this.props.jsxprefixCls;
	    };

	    FormField.prototype.render = function render() {
	        var _classnames;

	        var me = this;
	        var specificCls = me.addSpecificClass();
	        var mode = me.props.jsxmode || me.props.mode;

	        return React.createElement('div', { className: classnames((_classnames = {}, _classnames[specificCls] = true, _classnames[me.props.className] = !!me.props.className, _classnames)), style: assign({}, me.props.style, {
	                display: me.props.jsxshow ? "table" : "none"
	            }) }, me.renderLabel(), React.createElement('ul', { className: classnames({
	                "kuma-uxform-field-content": true,
	                "view-mode": mode == Constants.MODE.VIEW,
	                "edit-mode": mode == Constants.MODE.EDIT,
	                "has-error": !!me.state.error
	            }) }, React.createElement('li', { className: 'kuma-uxform-field-core' }, me.renderField()), me.renderTips(), me.renderErrorMsg()));
	    };

	    return FormField;
	}(React.Component);

	;

	FormField.propTypes = {
	    instantValidate: React.PropTypes.bool, // 是否立即校验
	    jsxshow: React.PropTypes.bool,
	    jsxmode: React.PropTypes.string,
	    jsxshowLabel: React.PropTypes.bool,
	    jsxprefixCls: React.PropTypes.string,
	    jsxflex: React.PropTypes.number,
	    jsxname: React.PropTypes.string.isRequired,
	    jsxplaceholder: React.PropTypes.string,
	    jsxlabel: React.PropTypes.string,
	    jsxtips: React.PropTypes.string,
	    jsxrules: React.PropTypes.oneOfType([React.PropTypes.object, React.PropTypes.array]),
	    standalone: React.PropTypes.bool,
	    required: React.PropTypes.bool
	};

	FormField.defaultProps = {
	    jsxshow: true, // 是否显示该块
	    jsxshowLabel: true, // 是否展示 label
	    jsxprefixCls: "kuma-uxform-field", // 默认类名
	    jsxflex: 1, // 占 Form 的比例，类似于 css3 中的 flex-box
	    jsxname: "", // 表单字段
	    jsxplaceholder: "", // 在未选值之前的占位符
	    jsxlabel: "", // 左侧表单域标题
	    jsxtips: "", // 提醒
	    standalone: false, // 是否处于独立使用模式
	    mode: Constants.MODE.EDIT,
	    required: false
	};

	FormField.displayName = "FormField";

	module.exports = FormField;

/***/ },
/* 333 */
33,
/* 334 */
[778, 335, 336],
/* 335 */
/***/ function(module, exports) {

	'use strict';

	exports = module.exports = typeof Object.keys === 'function' ? Object.keys : shim;

	exports.shim = shim;
	function shim(obj) {
	  var keys = [];
	  for (var key in obj) {
	    keys.push(key);
	  }return keys;
		}

/***/ },
/* 336 */
/***/ function(module, exports) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var supportsArgumentsClass = function () {
	  return Object.prototype.toString.call(arguments);
	}() == '[object Arguments]';

	exports = module.exports = supportsArgumentsClass ? supported : unsupported;

	exports.supported = supported;
	function supported(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	};

	exports.unsupported = unsupported;
	function unsupported(object) {
	  return object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) == 'object' && typeof object.length == 'number' && Object.prototype.hasOwnProperty.call(object, 'callee') && !Object.prototype.propertyIsEnumerable.call(object, 'callee') || false;
		};

/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/**
	 * Created by xy on 15/4/16.
	 */

		module.exports = __webpack_require__(338);

/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Validator Component for uxcore
	 * @author eternalsky
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

		module.exports = __webpack_require__(339);

/***/ },
/* 339 */
/***/ function(module, exports) {

	'use strict';

	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	    return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	    return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};

	/**
	 * Created by xy on 15/4/16.
	 */

	var Validator = {};

	var PATTERN = {
	    EMAIL: /^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})$/,
	    URL: /^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/,
	    HEX: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i,
	    NUM: /^((-?\d+\.\d+)|(-?\d+)|(-?\.\d+))$/,
	    IDCARD: /(^\d{15}$)|(^\d{17}([0-9]|X)$)/i,
	    CNMOBILE: /^(0|86|17951)?(13[0-9]|15[012356789]|17[0678]|18[0-9]|14[57])[0-9]{8}$/
	};

	Validator.isNotEmpty = function (value) {
	    // empty means empty string, empty array, empty object & null & undefined
	    if (typeof value == "string") {
	        return value.length !== 0;
	    } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object') {
	        if (value instanceof Array) {
	            return value.length !== 0;
	        } else {
	            var i = 0;
	            for (var key in value) {
	                i++;
	            }
	            return !!i;
	        }
	    } else if (typeof value == 'number') {
	        return true;
	    } else {
	        return !!value;
	    }
	};

	Validator.isNum = function (value) {
	    return PATTERN.NUM.test(value);
	};

	Validator.isInt = function (value) {
	    return Validator.isNum(value) && parseInt(value) == value;
	};

	Validator.isDecimal = function (value) {
	    return Validator.isNum(value) && !Validator.isInt(value);
	};

	Validator.isArray = function (value) {
	    return Array.isArray(value);
	};

	Validator.isRegExp = function (value) {
	    if (value instanceof RegExp) {
	        return true;
	    }
	    try {
	        return !!new RegExp(value);
	    } catch (e) {
	        return false;
	    }
	};

	Validator.isObject = function (value) {
	    return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && !Validator.isArray(value);
	};

	Validator.isFunc = function (value) {
	    return typeof value === 'function';
	};

	Validator.isEmail = function (value) {
	    return typeof value === 'string' && PATTERN.EMAIL.test(value);
	};

	Validator.isUrl = function (value) {
	    return typeof value === 'string' && PATTERN.URL.test(value);
	};

	Validator.isHex = function (value) {
	    return typeof value === 'string' && PATTERN.HEX.test(value);
	};

	Validator.isIdCard = function (value) {
	    return typeof value === 'string' && PATTERN.IDCARD.test(value);
	};

	Validator.isCNMobile = function (value) {
	    return typeof value === 'string' && PATTERN.CNMOBILE.test(value);
	};
		module.exports = Validator;

/***/ },
/* 340 */
/***/ function(module, exports) {

	"use strict";

	module.exports = {
	  /*
	   * Enter
	   */
	  Enter: 13
		};

/***/ },
/* 341 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, Buffer) {'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	/*!
	 * @license deepcopy.js Copyright(c) 2013 sasa+1
	 * https://github.com/sasaplus1/deepcopy.js
	 * Released under the MIT license.
	 */

	/**
	 * export to AMD/CommonJS/global.
	 *
	 * @param {Object} global global object.
	 * @param {Function} factory factory method.
	 */
	(function (global, factory) {
	  'use strict';

	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
	    module.exports = factory();
	  } else {
	    global.deepcopy = factory();
	  }
	})(undefined, function () {
	  'use strict';

	  var isNode, util, isBuffer, getKeys, getSymbols, indexOfArray;

	  // is node.js/io.js?
	  isNode = typeof process !== 'undefined' && "function" !== 'undefined';

	  // fallback util module for browser.
	  util = isNode ? __webpack_require__(346) : function () {
	    function isArray(value) {
	      return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && Object.prototype.toString.call(value) === '[object Array]';
	    }

	    function isDate(value) {
	      return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && Object.prototype.toString.call(value) === '[object Date]';
	    }

	    function isRegExp(value) {
	      return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && Object.prototype.toString.call(value) === '[object RegExp]';
	    }

	    function isSymbol(value) {
	      return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'symbol';
	    }

	    return {
	      isArray: typeof Array.isArray === 'function' ? function (obj) {
	        return Array.isArray(obj);
	      } : isArray,
	      isDate: isDate,
	      isRegExp: isRegExp,
	      isSymbol: typeof Symbol === 'function' ? isSymbol : function () {
	        // always return false when Symbol is not supported.
	        return false;
	      }
	    };
	  }();

	  // fallback Buffer.isBuffer
	  isBuffer = isNode ? function (obj) {
	    return Buffer.isBuffer(obj);
	  } : function () {
	    // if browser, always return false
	    return false;
	  };

	  // fallback Object.keys for old browsers.
	  getKeys = typeof Object.keys === 'function' ? function (obj) {
	    return Object.keys(obj);
	  } : function (obj) {
	    var keys = [],
	        key;

	    if (obj === null || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {
	      throw new TypeError('obj is not an Object');
	    }

	    for (key in obj) {
	      obj.hasOwnProperty(key) && keys.push(key);
	    }

	    return keys;
	  };

	  // get symbols in object.
	  getSymbols = typeof Symbol === 'function' ? function (obj) {
	    return Object.getOwnPropertySymbols(obj);
	  } : function () {
	    // always return empty array when Symbol is not supported.
	    return [];
	  };

	  // fallback Array#indexOf for old browsers.
	  indexOfArray = typeof Array.prototype.indexOf === 'function' ? function (array, searchElement) {
	    return array.indexOf(searchElement);
	  } : function (array, searchElement) {
	    var i, len;

	    if (!util.isArray(array)) {
	      throw new TypeError('array is not an Array');
	    }

	    for (i = 0, len = array.length; i < len; ++i) {
	      if (array[i] === searchElement) {
	        return i;
	      }
	    }

	    return -1;
	  };

	  /**
	   * recursive deep copy for value.
	   *
	   * @private
	   * @param {*} value copy target.
	   * @param {*} clone
	   * @param {Array} visited
	   * @param {Array} reference
	   * @return {*} copied value.
	   */
	  function copyValue_(value, clone, visited, reference) {
	    var str, pos, buf, keys, i, len, key, val, idx, obj, ref;

	    // number, string, boolean, null, undefined, function and symbol.
	    if (value === null || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object') {
	      return value;
	    }

	    // Date.
	    if (util.isDate(value)) {
	      // Firefox need to convert to Number
	      //
	      // Firefox:
	      //   var date = new Date;
	      //   +date;            // 1420909365967
	      //   +new Date(date);  // 1420909365000
	      //   +new Date(+date); // 1420909365967
	      // Chrome:
	      //   var date = new Date;
	      //   +date;            // 1420909757913
	      //   +new Date(date);  // 1420909757913
	      //   +new Date(+date); // 1420909757913
	      return new Date(+value);
	    }

	    // RegExp.
	    if (util.isRegExp(value)) {
	      // Chrome, Safari:
	      //   (new RegExp).source => "(?:)"
	      // Firefox:
	      //   (new RegExp).source => ""
	      // Chrome, Safari, Firefox
	      //   String(new RegExp) => "/(?:)/"
	      str = String(value);
	      pos = str.lastIndexOf('/');

	      return new RegExp(str.slice(1, pos), str.slice(pos + 1));
	    }

	    // Buffer, node.js only.
	    if (isBuffer(value)) {
	      buf = new Buffer(value.length);
	      value.copy(buf);

	      return buf;
	    }

	    // Object or Array.
	    keys = getKeys(value).concat(getSymbols(value));

	    for (i = 0, len = keys.length; i < len; ++i) {
	      key = keys[i];
	      val = value[key];

	      if (val !== null && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object') {
	        idx = indexOfArray(visited, val);

	        if (idx === -1) {
	          // not circular reference
	          obj = util.isArray(val) ? [] : {};

	          visited.push(val);
	          reference.push(obj);
	        } else {
	          // circular reference
	          ref = reference[idx];
	        }
	      }

	      clone[key] = ref || copyValue_(val, obj, visited, reference);
	    }

	    return clone;
	  }

	  /**
	   * deep copy for value.
	   *
	   * @param {*} value copy target.
	   */
	  function deepcopy(value) {
	    var clone = util.isArray(value) ? [] : {},
	        visited = [value],
	        reference = [clone];

	    return copyValue_(value, clone, visited, reference);
	  }

	  return deepcopy;
		});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(45), __webpack_require__(342).Buffer))

/***/ },
/* 342 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */

	'use strict'

	var base64 = __webpack_require__(343)
	var ieee754 = __webpack_require__(344)
	var isArray = __webpack_require__(345)

	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	Buffer.poolSize = 8192 // not used by this implementation

	var rootParent = {}

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
	 *     on objects.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()

	function typedArraySupport () {
	  function Bar () {}
	  try {
	    var arr = new Uint8Array(1)
	    arr.foo = function () { return 42 }
	    arr.constructor = Bar
	    return arr.foo() === 42 && // typed array instances can be augmented
	        arr.constructor === Bar && // constructor can be set
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}

	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	/**
	 * Class: Buffer
	 * =============
	 *
	 * The Buffer constructor returns instances of `Uint8Array` that are augmented
	 * with function properties for all the node `Buffer` API functions. We use
	 * `Uint8Array` so that square bracket notation works as expected -- it returns
	 * a single octet.
	 *
	 * By augmenting the instances, we can avoid modifying the `Uint8Array`
	 * prototype.
	 */
	function Buffer (arg) {
	  if (!(this instanceof Buffer)) {
	    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
	    if (arguments.length > 1) return new Buffer(arg, arguments[1])
	    return new Buffer(arg)
	  }

	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    this.length = 0
	    this.parent = undefined
	  }

	  // Common case.
	  if (typeof arg === 'number') {
	    return fromNumber(this, arg)
	  }

	  // Slightly less common case.
	  if (typeof arg === 'string') {
	    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
	  }

	  // Unusual.
	  return fromObject(this, arg)
	}

	function fromNumber (that, length) {
	  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < length; i++) {
	      that[i] = 0
	    }
	  }
	  return that
	}

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

	  // Assumption: byteLength() return value is always < kMaxLength.
	  var length = byteLength(string, encoding) | 0
	  that = allocate(that, length)

	  that.write(string, encoding)
	  return that
	}

	function fromObject (that, object) {
	  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

	  if (isArray(object)) return fromArray(that, object)

	  if (object == null) {
	    throw new TypeError('must start with number, buffer, array or string')
	  }

	  if (typeof ArrayBuffer !== 'undefined') {
	    if (object.buffer instanceof ArrayBuffer) {
	      return fromTypedArray(that, object)
	    }
	    if (object instanceof ArrayBuffer) {
	      return fromArrayBuffer(that, object)
	    }
	  }

	  if (object.length) return fromArrayLike(that, object)

	  return fromJsonObject(that, object)
	}

	function fromBuffer (that, buffer) {
	  var length = checked(buffer.length) | 0
	  that = allocate(that, length)
	  buffer.copy(that, 0, 0, length)
	  return that
	}

	function fromArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	// Duplicate of fromArray() to keep fromArray() monomorphic.
	function fromTypedArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  // Truncating the elements is probably not what people expect from typed
	  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
	  // of the old Buffer constructor.
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	function fromArrayBuffer (that, array) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    array.byteLength
	    that = Buffer._augment(new Uint8Array(array))
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromTypedArray(that, new Uint8Array(array))
	  }
	  return that
	}

	function fromArrayLike (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
	// Returns a zero-length buffer for inputs that don't conform to the spec.
	function fromJsonObject (that, object) {
	  var array
	  var length = 0

	  if (object.type === 'Buffer' && isArray(object.data)) {
	    array = object.data
	    length = checked(array.length) | 0
	  }
	  that = allocate(that, length)

	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	} else {
	  // pre-set for values that may exist in the future
	  Buffer.prototype.length = undefined
	  Buffer.prototype.parent = undefined
	}

	function allocate (that, length) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = Buffer._augment(new Uint8Array(length))
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that.length = length
	    that._isBuffer = true
	  }

	  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
	  if (fromPool) that.parent = rootParent

	  return that
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}

	function SlowBuffer (subject, encoding) {
	  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

	  var buf = new Buffer(subject, encoding)
	  delete buf.parent
	  return buf
	}

	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length
	  var y = b.length

	  var i = 0
	  var len = Math.min(x, y)
	  while (i < len) {
	    if (a[i] !== b[i]) break

	    ++i
	  }

	  if (i !== len) {
	    x = a[i]
	    y = b[i]
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'raw':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}

	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

	  if (list.length === 0) {
	    return new Buffer(0)
	  }

	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; i++) {
	      length += list[i].length
	    }
	  }

	  var buf = new Buffer(length)
	  var pos = 0
	  for (i = 0; i < list.length; i++) {
	    var item = list[i]
	    item.copy(buf, pos)
	    pos += item.length
	  }
	  return buf
	}

	function byteLength (string, encoding) {
	  if (typeof string !== 'string') string = '' + string

	  var len = string.length
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'binary':
	      // Deprecated
	      case 'raw':
	      case 'raws':
	        return len
	      case 'utf8':
	      case 'utf-8':
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength

	function slowToString (encoding, start, end) {
	  var loweredCase = false

	  start = start | 0
	  end = end === undefined || end === Infinity ? this.length : end | 0

	  if (!encoding) encoding = 'utf8'
	  if (start < 0) start = 0
	  if (end > this.length) end = this.length
	  if (end <= start) return ''

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'binary':
	        return binarySlice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}

	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}

	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}

	Buffer.prototype.compare = function compare (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return 0
	  return Buffer.compare(this, b)
	}

	Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
	  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
	  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
	  byteOffset >>= 0

	  if (this.length === 0) return -1
	  if (byteOffset >= this.length) return -1

	  // Negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

	  if (typeof val === 'string') {
	    if (val.length === 0) return -1 // special case: looking for empty string always fails
	    return String.prototype.indexOf.call(this, val, byteOffset)
	  }
	  if (Buffer.isBuffer(val)) {
	    return arrayIndexOf(this, val, byteOffset)
	  }
	  if (typeof val === 'number') {
	    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
	      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
	    }
	    return arrayIndexOf(this, [ val ], byteOffset)
	  }

	  function arrayIndexOf (arr, val, byteOffset) {
	    var foundIndex = -1
	    for (var i = 0; byteOffset + i < arr.length; i++) {
	      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
	      } else {
	        foundIndex = -1
	      }
	    }
	    return -1
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	// `get` is deprecated
	Buffer.prototype.get = function get (offset) {
	  console.log('.get() is deprecated. Access using array indexes instead.')
	  return this.readUInt8(offset)
	}

	// `set` is deprecated
	Buffer.prototype.set = function set (v, offset) {
	  console.log('.set() is deprecated. Access using array indexes instead.')
	  return this.writeUInt8(v, offset)
	}

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; i++) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) throw new Error('Invalid hex string')
	    buf[offset + i] = parsed
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function binaryWrite (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    var swap = encoding
	    encoding = offset
	    offset = length | 0
	    length = swap
	  }

	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8'

	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'binary':
	        return binaryWrite(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []

	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1

	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint

	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }

	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }

	    res.push(codePoint)
	    i += bytesPerSequence
	  }

	  return decodeCodePointsArray(res)
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000

	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}

	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}

	function binarySlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length

	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len

	  var out = ''
	  for (var i = start; i < end; i++) {
	    out += toHex(buf[i])
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}

	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end

	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }

	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }

	  if (end < start) end = start

	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = Buffer._augment(this.subarray(start, end))
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; i++) {
	      newBuf[i] = this[i + start]
	    }
	  }

	  if (newBuf.length) newBuf.parent = this.parent || this

	  return newBuf
	}

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }

	  return val
	}

	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }

	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }

	  return val
	}

	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}

	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}

	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}

	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}

	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}

	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}

	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}

	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}

	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}

	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}

	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}

	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	}

	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}

	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}

	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = 0
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	  if (offset < 0) throw new RangeError('index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}

	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}

	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }

	  var len = end - start
	  var i

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; i--) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; i++) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    target._set(this.subarray(start, start + len), targetStart)
	  }

	  return len
	}

	// fill(value, start=0, end=buffer.length)
	Buffer.prototype.fill = function fill (value, start, end) {
	  if (!value) value = 0
	  if (!start) start = 0
	  if (!end) end = this.length

	  if (end < start) throw new RangeError('end < start')

	  // Fill 0 bytes; we're done
	  if (end === start) return
	  if (this.length === 0) return

	  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
	  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

	  var i
	  if (typeof value === 'number') {
	    for (i = start; i < end; i++) {
	      this[i] = value
	    }
	  } else {
	    var bytes = utf8ToBytes(value.toString())
	    var len = bytes.length
	    for (i = start; i < end; i++) {
	      this[i] = bytes[i % len]
	    }
	  }

	  return this
	}

	/**
	 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
	 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
	 */
	Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
	  if (typeof Uint8Array !== 'undefined') {
	    if (Buffer.TYPED_ARRAY_SUPPORT) {
	      return (new Buffer(this)).buffer
	    } else {
	      var buf = new Uint8Array(this.length)
	      for (var i = 0, len = buf.length; i < len; i += 1) {
	        buf[i] = this[i]
	      }
	      return buf.buffer
	    }
	  } else {
	    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
	  }
	}

	// HELPER FUNCTIONS
	// ================

	var BP = Buffer.prototype

	/**
	 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
	 */
	Buffer._augment = function _augment (arr) {
	  arr.constructor = Buffer
	  arr._isBuffer = true

	  // save reference to original Uint8Array set method before overwriting
	  arr._set = arr.set

	  // deprecated
	  arr.get = BP.get
	  arr.set = BP.set

	  arr.write = BP.write
	  arr.toString = BP.toString
	  arr.toLocaleString = BP.toString
	  arr.toJSON = BP.toJSON
	  arr.equals = BP.equals
	  arr.compare = BP.compare
	  arr.indexOf = BP.indexOf
	  arr.copy = BP.copy
	  arr.slice = BP.slice
	  arr.readUIntLE = BP.readUIntLE
	  arr.readUIntBE = BP.readUIntBE
	  arr.readUInt8 = BP.readUInt8
	  arr.readUInt16LE = BP.readUInt16LE
	  arr.readUInt16BE = BP.readUInt16BE
	  arr.readUInt32LE = BP.readUInt32LE
	  arr.readUInt32BE = BP.readUInt32BE
	  arr.readIntLE = BP.readIntLE
	  arr.readIntBE = BP.readIntBE
	  arr.readInt8 = BP.readInt8
	  arr.readInt16LE = BP.readInt16LE
	  arr.readInt16BE = BP.readInt16BE
	  arr.readInt32LE = BP.readInt32LE
	  arr.readInt32BE = BP.readInt32BE
	  arr.readFloatLE = BP.readFloatLE
	  arr.readFloatBE = BP.readFloatBE
	  arr.readDoubleLE = BP.readDoubleLE
	  arr.readDoubleBE = BP.readDoubleBE
	  arr.writeUInt8 = BP.writeUInt8
	  arr.writeUIntLE = BP.writeUIntLE
	  arr.writeUIntBE = BP.writeUIntBE
	  arr.writeUInt16LE = BP.writeUInt16LE
	  arr.writeUInt16BE = BP.writeUInt16BE
	  arr.writeUInt32LE = BP.writeUInt32LE
	  arr.writeUInt32BE = BP.writeUInt32BE
	  arr.writeIntLE = BP.writeIntLE
	  arr.writeIntBE = BP.writeIntBE
	  arr.writeInt8 = BP.writeInt8
	  arr.writeInt16LE = BP.writeInt16LE
	  arr.writeInt16BE = BP.writeInt16BE
	  arr.writeInt32LE = BP.writeInt32LE
	  arr.writeInt32BE = BP.writeInt32BE
	  arr.writeFloatLE = BP.writeFloatLE
	  arr.writeFloatBE = BP.writeFloatBE
	  arr.writeDoubleLE = BP.writeDoubleLE
	  arr.writeDoubleBE = BP.writeDoubleBE
	  arr.fill = BP.fill
	  arr.inspect = BP.inspect
	  arr.toArrayBuffer = BP.toArrayBuffer

	  return arr
	}

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []

	  for (var i = 0; i < length; i++) {
	    codePoint = string.charCodeAt(i)

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }

	        // valid lead
	        leadSurrogate = codePoint

	        continue
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }

	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }

	    leadSurrogate = null

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }

	  return byteArray
	}

	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; i++) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(342).Buffer, (function() { return this; }())))

/***/ },
/* 343 */
/***/ function(module, exports, __webpack_require__) {

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	;(function (exports) {
		'use strict';

	  var Arr = (typeof Uint8Array !== 'undefined')
	    ? Uint8Array
	    : Array

		var PLUS   = '+'.charCodeAt(0)
		var SLASH  = '/'.charCodeAt(0)
		var NUMBER = '0'.charCodeAt(0)
		var LOWER  = 'a'.charCodeAt(0)
		var UPPER  = 'A'.charCodeAt(0)
		var PLUS_URL_SAFE = '-'.charCodeAt(0)
		var SLASH_URL_SAFE = '_'.charCodeAt(0)

		function decode (elt) {
			var code = elt.charCodeAt(0)
			if (code === PLUS ||
			    code === PLUS_URL_SAFE)
				return 62 // '+'
			if (code === SLASH ||
			    code === SLASH_URL_SAFE)
				return 63 // '/'
			if (code < NUMBER)
				return -1 //no match
			if (code < NUMBER + 10)
				return code - NUMBER + 26 + 26
			if (code < UPPER + 26)
				return code - UPPER
			if (code < LOWER + 26)
				return code - LOWER + 26
		}

		function b64ToByteArray (b64) {
			var i, j, l, tmp, placeHolders, arr

			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4')
			}

			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders)

			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length

			var L = 0

			function push (v) {
				arr[L++] = v
			}

			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
				push((tmp & 0xFF0000) >> 16)
				push((tmp & 0xFF00) >> 8)
				push(tmp & 0xFF)
			}

			if (placeHolders === 2) {
				tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
				push(tmp & 0xFF)
			} else if (placeHolders === 1) {
				tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
				push((tmp >> 8) & 0xFF)
				push(tmp & 0xFF)
			}

			return arr
		}

		function uint8ToBase64 (uint8) {
			var i,
				extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
				output = "",
				temp, length

			function encode (num) {
				return lookup.charAt(num)
			}

			function tripletToBase64 (num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
			}

			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
				output += tripletToBase64(temp)
			}

			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1]
					output += encode(temp >> 2)
					output += encode((temp << 4) & 0x3F)
					output += '=='
					break
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
					output += encode(temp >> 10)
					output += encode((temp >> 4) & 0x3F)
					output += encode((temp << 2) & 0x3F)
					output += '='
					break
			}

			return output
		}

		exports.toByteArray = b64ToByteArray
		exports.fromByteArray = uint8ToBase64
	}( false ? (this.base64js = {}) : exports))


/***/ },
/* 344 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]

	  i += d

	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

	  value = Math.abs(value)

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }

	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 345 */
/***/ function(module, exports) {

	var toString = {}.toString;

	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 346 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }

	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};


	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }

	  if (process.noDeprecation === true) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	};


	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};


	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;


	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};

	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};


	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];

	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}


	function stylizeNoColor(str, styleType) {
	  return str;
	}


	function arrayToHash(array) {
	  var hash = {};

	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });

	  return hash;
	}


	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);

	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }

	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }

	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }

	  var base = '', array = false, braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}


	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}


	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}


	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}


	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}


	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}


	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = __webpack_require__(347);

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}


	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}


	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];

	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}


	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};


	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(348);

	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;

	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};

	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(45)))

/***/ },
/* 347 */
/***/ function(module, exports) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 348 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 349 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	/**
	 * Created by xy on 15/4/13.
	 */
	var FormField = __webpack_require__(332);
	var Constants = __webpack_require__(222);
	var assign = __webpack_require__(333);

	var TextAreaFormField = function (_FormField) {
	    _inherits(TextAreaFormField, _FormField);

	    function TextAreaFormField(props) {
	        _classCallCheck(this, TextAreaFormField);

	        return _possibleConstructorReturn(this, _FormField.call(this, props));
	    }

	    TextAreaFormField.prototype.handleChange = function handleChange(e) {
	        var me = this;
	        var autoTrim = me.props.autoTrim;

	        var value = e.currentTarget.value;
	        if (autoTrim) {
	            value = me.trim(value);
	        }
	        me.handleDataChange(value);
	    };

	    TextAreaFormField.prototype.trim = function trim(str) {
	        return str.replace(/(^\s+|\s+$)/g, "");
	    };

	    TextAreaFormField.prototype.addSpecificClass = function addSpecificClass() {
	        var me = this;
	        if (me.props.jsxprefixCls == "kuma-uxform-field") {
	            return me.props.jsxprefixCls + " kuma-textarea-uxform-field";
	        } else {
	            return me.props.jsxprefixCls;
	        }
	    };

	    TextAreaFormField.prototype.handleFocus = function handleFocus(e) {
	        this.props.onFocus(e);
	    };

	    TextAreaFormField.prototype.handleBlur = function handleBlur(e) {
	        var me = this;
	        var pass = true;
	        if (me.props.validateOnBlur) {
	            pass = me.doValidate();
	        }
	        me.props.onBlur(e, pass);
	    };

	    TextAreaFormField.prototype.handleKeyDown = function handleKeyDown(e) {
	        var me = this;
	        me.props.onKeyDown(e);
	    };

	    TextAreaFormField.prototype.renderField = function renderField() {
	        var me = this;
	        var mode = me.props.jsxmode || me.props.mode;
	        if (mode == Constants.MODE.EDIT) {
	            return React.createElement('textarea', {
	                disabled: me.props.jsxdisabled,
	                placeholder: me.props.jsxplaceholder,
	                className: 'kuma-textarea',
	                ref: 'root',
	                value: me.state.value || "",
	                onChange: me.handleChange.bind(me),
	                onFocus: me.handleFocus.bind(me),
	                onBlur: me.handleBlur.bind(me),
	                onKeyDown: me.handleKeyDown.bind(me) });
	        } else if (mode == Constants.MODE.VIEW) {
	            return React.createElement('span', null, me.state.value);
	        }
	    };

	    return TextAreaFormField;
	}(FormField);

	TextAreaFormField.displayName = "TextAreaFormField";
	TextAreaFormField.propTypes = assign({}, FormField.propTypes, {
	    onBlur: React.PropTypes.func,
	    onFocus: React.PropTypes.func,
	    onKeyDown: React.PropTypes.func,
	    validateOnBlur: React.PropTypes.bool,
	    autoTrim: React.PropTypes.bool
	});
	TextAreaFormField.defaultProps = assign({}, FormField.defaultProps, {
	    onBlur: function onBlur() {},
	    onFocus: function onFocus() {},
	    onKeyDown: function onKeyDown() {},
	    validateOnBlur: false
	});
		module.exports = TextAreaFormField;

/***/ },
/* 350 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);
	var FormField = __webpack_require__(332);
	var Constants = __webpack_require__(222);
	var classnames = __webpack_require__(5);
	var assign = __webpack_require__(333);

	var FormCount = function (_React$Component) {
	    _inherits(FormCount, _React$Component);

	    function FormCount(props) {
	        _classCallCheck(this, FormCount);

	        return _possibleConstructorReturn(this, _React$Component.call(this, props));
	    }

	    FormCount.prototype.render = function render() {
	        var me = this;
	        return React.createElement('div', { className: 'kuma-uxform-count' }, me.props.length + "/" + me.props.total);
	    };

	    return FormCount;
	}(React.Component);

	FormCount.defaultProps = {};
	FormCount.propTypes = {
	    length: React.PropTypes.number,
	    total: React.PropTypes.number
	};

	FormCount.displayName = "FormCount";

	var LeftAddon = function (_React$Component2) {
	    _inherits(LeftAddon, _React$Component2);

	    function LeftAddon(props) {
	        _classCallCheck(this, LeftAddon);

	        return _possibleConstructorReturn(this, _React$Component2.call(this, props));
	    }

	    LeftAddon.prototype.render = function render() {
	        var me = this;
	        return React.createElement('div', { className: classnames({
	                "kuma-uxform-left-icon": true,
	                "kuma-uxform-left-icon-focus": !!me.props.focus
	            }) }, me.props.children);
	    };

	    return LeftAddon;
	}(React.Component);

	LeftAddon.defaultProps = {};
	LeftAddon.propTypes = {};
	LeftAddon.displayName = "LeftAddon";

	var RightAddon = function (_React$Component3) {
	    _inherits(RightAddon, _React$Component3);

	    function RightAddon(props) {
	        _classCallCheck(this, RightAddon);

	        return _possibleConstructorReturn(this, _React$Component3.call(this, props));
	    }

	    RightAddon.prototype.render = function render() {
	        var me = this;
	        return React.createElement('div', { className: 'kuma-uxform-right-icon ' }, me.props.children);
	    };

	    return RightAddon;
	}(React.Component);

	RightAddon.defaultProps = {};
	RightAddon.propTypes = {};
	RightAddon.displayName = "RightAddon";

	/**
	 * extend FormField, rewrite renderField method
	 */

	var InputFormField = function (_FormField) {
	    _inherits(InputFormField, _FormField);

	    function InputFormField(props) {
	        _classCallCheck(this, InputFormField);

	        return _possibleConstructorReturn(this, _FormField.call(this, props));
	    }

	    InputFormField.prototype.getValue = function getValue() {
	        return ReactDOM.findDOMNode(this.refs.root).value();
	    };

	    InputFormField.prototype.handleChange = function handleChange(e) {
	        var me = this;
	        var autoTrim = me.props.autoTrim;

	        var value = e.currentTarget.value;
	        if (autoTrim) {
	            value = me.trim(value);
	        }
	        me.handleDataChange(me.deFormatValue(value));
	    };

	    InputFormField.prototype.trim = function trim(str) {
	        return str.replace(/(^\s+|\s+$)/g, "");
	    };

	    InputFormField.prototype.handleFocus = function handleFocus(e) {
	        this.setState({
	            focus: true
	        });
	        this.props.onFocus(e);
	    };

	    InputFormField.prototype.handleBlur = function handleBlur(e) {
	        var me = this;
	        me.setState({
	            focus: false
	        });
	        var pass = true;
	        if (me.props.validateOnBlur) {
	            pass = me.doValidate();
	        }
	        me.props.onBlur(e, pass);
	    };

	    InputFormField.prototype.handleKeyDown = function handleKeyDown(e) {
	        var me = this;
	        me.props.onKeyDown(e);
	    };

	    InputFormField.prototype.deFormatValue = function deFormatValue(value) {
	        return value;
	    };

	    InputFormField.prototype.addSpecificClass = function addSpecificClass() {
	        var me = this;
	        if (me.props.jsxprefixCls == "kuma-uxform-field") {
	            return me.props.jsxprefixCls + " kuma-input-uxform-field";
	        } else {
	            return me.props.jsxprefixCls;
	        }
	    };

	    InputFormField.prototype.getCount = function getCount() {
	        var me = this;
	        var children = me.props.children;
	        var element = void 0;
	        React.Children.map(children, function (child) {
	            if (child && typeof child.type == 'function' && child.type.displayName == 'FormCount') {
	                element = child;
	            }
	        });
	        if (!!element) {
	            var total = element.props.total;
	            var Count = React.cloneElement(element, {
	                length: !!me.state.value ? me.state.value.length : 0,
	                key: "count"
	            });

	            return {
	                element: Count,
	                total: total
	            };
	        }
	    };

	    InputFormField.prototype.renderLeftAddon = function renderLeftAddon() {
	        var me = this;
	        var children = me.props.children;
	        var element = void 0;
	        React.Children.map(children, function (child) {
	            if (child && typeof child.type == 'function' && child.type.displayName == 'LeftAddon') {
	                element = child;
	            }
	        });
	        if (!!element) {
	            return React.cloneElement(element, {
	                focus: !!me.state.focus,
	                key: "left"
	            });
	        }
	    };

	    InputFormField.prototype.renderRightAddon = function renderRightAddon() {
	        var me = this;
	        var children = me.props.children;
	        var element = void 0;
	        React.Children.map(children, function (child) {
	            if (child && typeof child.type == 'function' && child.type.displayName == 'RightAddon') {
	                element = child;
	            }
	        });

	        if (!!element) {
	            return React.cloneElement(element, {
	                key: "right"
	            });
	        }
	    };

	    InputFormField.prototype.renderField = function renderField() {
	        var me = this;
	        var arr = [];
	        var mode = me.props.jsxmode || me.props.mode;
	        var count = me.getCount();
	        var leftAddon = me.renderLeftAddon();
	        var rightAddon = me.renderRightAddon();
	        var children = me.props.children;
	        if (mode == Constants.MODE.EDIT) {
	            var otherOptions = {};
	            // if (!!count) {
	            //     otherOptions.maxLength = count.total + "";
	            // }
	            if (!!leftAddon) {
	                arr.push(leftAddon);
	            }
	            arr.push(React.createElement('input', _extends({
	                className: classnames({
	                    "kuma-input": true,
	                    'kuma-uxform-input-has-right': !!count || !!rightAddon,
	                    "kuma-uxform-input-has-left": !!leftAddon
	                }),
	                ref: 'root',
	                key: me.props.inputType,
	                type: me.props.inputType,
	                placeholder: me.props.jsxplaceholder,
	                disabled: me.props.jsxdisabled == "disabled" || me.props.jsxdisabled == true ? "disabled" : "",
	                name: me.props.key,
	                value: me.state.formatValue,
	                onFocus: me.handleFocus.bind(me),
	                onBlur: me.handleBlur.bind(me),
	                onChange: me.handleChange.bind(me),
	                onKeyDown: me.handleKeyDown.bind(me)
	            }, otherOptions)));

	            if (!!rightAddon) {
	                arr.push(rightAddon);
	            } else if (!!count) {
	                arr.push(count.element);
	            }
	        } else if (mode == Constants.MODE.VIEW) {
	            arr.push(React.createElement('span', { key: 'text' }, me.state.formatValue));
	        }
	        return arr;
	    };

	    return InputFormField;
	}(FormField);

	InputFormField.Count = FormCount;
	InputFormField.LeftAddon = LeftAddon;
	InputFormField.RightAddon = RightAddon;
	InputFormField.propTypes = assign({}, FormField.propTypes, {
	    onBlur: React.PropTypes.func,
	    onFocus: React.PropTypes.func,
	    onKeyDown: React.PropTypes.func,
	    validateOnBlur: React.PropTypes.bool,
	    autoTrim: React.PropTypes.bool,
	    inputType: React.PropTypes.string
	});
	InputFormField.defaultProps = assign({}, FormField.defaultProps, {
	    onBlur: function onBlur() {},
	    onFocus: function onFocus() {},
	    onKeyDown: function onKeyDown() {},
	    validateOnBlur: false,
	    inputType: 'text'
	});
	InputFormField.displayName = "InputFormField";
	module.exports = InputFormField;

/***/ },
/* 351 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	/**
	 * Created by xy on 15/4/13.
	 */
	var FormField = __webpack_require__(332);
	var Constants = __webpack_require__(222);
	var RadioGroup = __webpack_require__(352);
	var Item = RadioGroup.Item;

	var RadioGroupFormField = function (_FormField) {
	    _inherits(RadioGroupFormField, _FormField);

	    function RadioGroupFormField(props) {
	        _classCallCheck(this, RadioGroupFormField);

	        return _possibleConstructorReturn(this, _FormField.call(this, props));
	    }

	    RadioGroupFormField.prototype.handleChange = function handleChange(value) {
	        var me = this;
	        me.handleDataChange(value);
	    };

	    RadioGroupFormField.prototype.addSpecificClass = function addSpecificClass() {
	        var me = this;
	        if (me.props.jsxprefixCls == "kuma-uxform-field") {
	            return me.props.jsxprefixCls + " kuma-radio-group-uxform-field";
	        } else {
	            return me.props.jsxprefixCls;
	        }
	    };

	    RadioGroupFormField.prototype.renderField = function renderField() {
	        var me = this;
	        var arr = [];
	        var mode = me.props.jsxmode || me.props.mode;
	        if (mode == Constants.MODE.EDIT) {
	            arr.push(React.createElement(RadioGroup, {
	                ref: 'el',
	                key: 'radiogroup',
	                value: me.state.value,
	                onChange: me.handleChange.bind(me) }, me.props.children));
	        } else {
	            var text = me.props.children.filter(function (child, index) {
	                return child.props.value == me.state.value;
	            });

	            if (text.length) {
	                arr.push(React.createElement('span', { key: 'radiogroup' }, text[0].props.text));
	            }
	        }
	        return arr;
	    };

	    return RadioGroupFormField;
	}(FormField);

	RadioGroupFormField.displayName = "RadioGroupFormField";
	RadioGroupFormField.propTypes = FormField.propTypes;
	RadioGroupFormField.defaultProps = FormField.defaultProps;
	RadioGroupFormField.Item = Item;
	module.exports = RadioGroupFormField;

/***/ },
/* 352 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Radiogroup Component for uxcore
	 * @author 
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

		module.exports = __webpack_require__(353);

/***/ },
/* 353 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	/**
	* thanks for https://github.com/chenglou/react-radio-group
	* @author: zhouquan.yezq
	* @time  : 5/25 2015
	*/

	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);
	var Item = __webpack_require__(354);
	var classnames = __webpack_require__(5);

	var Radiogroup = function (_React$Component) {
	    _inherits(Radiogroup, _React$Component);

	    function Radiogroup(props) {
	        _classCallCheck(this, Radiogroup);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.state = {
	            defaultValue: props.defaultValue
	        };
	        return _this;
	    }

	    Radiogroup.prototype._handleChange = function _handleChange(value) {
	        var me = this;
	        me.props.onChange(value);
	    };

	    Radiogroup.prototype._processChild = function _processChild() {
	        var me = this;
	        var length = React.Children.count(me.props.children);
	        if (!length) return false;
	        var elements = React.Children.map(me.props.children, function (child, index) {
	            if (!!child.type && child.type.displayName == "RadiogroupItem") {
	                return React.cloneElement(child, {
	                    onChange: me._handleChange.bind(me),
	                    key: index,
	                    checked: me.props.value == child.props.value
	                });
	            }
	        });
	        return elements;
	    };

	    Radiogroup.prototype.render = function render() {
	        var _classnames;

	        var me = this;
	        return React.createElement('div', { className: classnames((_classnames = {
	                "kuma-radio-group": true
	            }, _classnames[me.props.className] = !!me.props.className, _classnames)) }, me._processChild());
	    };

	    return Radiogroup;
	}(React.Component);

	Radiogroup.displayName = "Radiogroup";
	Radiogroup.propTypes = {
	    value: React.PropTypes.string,
	    onChange: React.PropTypes.func
	};
	Radiogroup.defaultProps = {
	    value: "",
	    onChange: function onChange() {}
	};

	Radiogroup.Item = Item;

	module.exports = Radiogroup;

/***/ },
/* 354 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var RadiogroupItem = function (_React$Component) {
	    _inherits(RadiogroupItem, _React$Component);

	    function RadiogroupItem(props) {
	        _classCallCheck(this, RadiogroupItem);

	        return _possibleConstructorReturn(this, _React$Component.call(this, props));
	    }

	    RadiogroupItem.prototype._handleChange = function _handleChange(e) {
	        var me = this;
	        me.props.onChange(me.props.value);
	    };

	    RadiogroupItem.prototype.render = function render() {
	        var me = this;
	        return React.createElement('label', null, React.createElement('input', { type: 'radio', disabled: me.props.disabled, ref: 'radio', className: me.props.className, checked: me.props.checked, onChange: me._handleChange.bind(me) }), React.createElement('s', null), me.props.text);
	    };

	    return RadiogroupItem;
	}(React.Component);

	RadiogroupItem.displayName = "RadiogroupItem";
	RadiogroupItem.propTypes = {
	    text: React.PropTypes.string,
	    value: React.PropTypes.string,
	    className: React.PropTypes.string,
	    disabled: React.PropTypes.bool,
	    onChange: React.PropTypes.func
	};
	RadiogroupItem.defaultProps = {
	    text: "",
	    value: "",
	    className: "kuma-checkbox",
	    disabled: false,
	    onChange: function onChange() {}
	};

		module.exports = RadiogroupItem;

/***/ },
/* 355 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	/**
	 * Created by xy on 15/4/13.
	 */
	var FormField = __webpack_require__(332);
	var Constants = __webpack_require__(222);
	var Select = __webpack_require__(356);
	var assign = __webpack_require__(333);
	var Option = Select.Option;

	var selectOptions = ['onSelect', 'onDeselect', 'getPopupContainer', 'multiple', 'filterOption', 'allowClear', 'combobox', 'searchPlaceholder', 'tags', 'disabled', 'showSearch', 'placeholder', 'optionLabelProp', 'maxTagTextLength', 'dropdownMatchSelectWidth', 'dropdownClassName', 'notFoundContent'];

	var SelectFormField = function (_FormField) {
	    _inherits(SelectFormField, _FormField);

	    function SelectFormField(props) {
	        _classCallCheck(this, SelectFormField);

	        var _this = _possibleConstructorReturn(this, _FormField.call(this, props));

	        var me = _this;
	        assign(me.state, {
	            data: props.jsxdata
	        });
	        return _this;
	    }

	    SelectFormField.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	        var me = this;
	        if (!me._isEqual(nextProps.value, me.props.value)) {
	            me.handleDataChange(nextProps.value, true);
	        }
	        if (!me._isEqual(nextProps.jsxdata, me.props.jsxdata)) {
	            me.setState({
	                data: nextProps.jsxdata
	            });
	        }
	    };

	    SelectFormField.prototype.componentWillMount = function componentWillMount() {
	        var me = this;
	        if (me.props.jsxfetchUrl) {
	            me.fetchData();
	        }
	    };

	    SelectFormField.prototype.componentDidMount = function componentDidMount() {
	        var me = this;
	        if (!me.props.standalone) {
	            me.props.attachFormField(me);
	            me.props.handleDataChange(me, {
	                value: me.props.value,
	                pass: true
	            }, true);
	        }
	        me.hasDeprecatedProps();
	    };

	    SelectFormField.prototype.handleDataChange = function handleDataChange(value, fromReset, label) {
	        var me = this;
	        me.setState({
	            value: value,
	            label: label || [],
	            formatValue: me.formatValue(value),
	            error: !!fromReset ? false : me.state.error,
	            /*
	             * why set state fromReset? some field like editor cannot be reset in the common way
	             * so set this state to tell the field that you need to reset by yourself.
	             */
	            fromReset: fromReset
	        }, function () {
	            var pass = true;
	            if (!fromReset) {
	                pass = me.doValidate();
	            }
	            me.props.handleDataChange(me, {
	                value: value,
	                pass: pass
	            });
	        });
	    };

	    SelectFormField.prototype.fetchData = function fetchData(value) {
	        var me = this;
	        var ajaxOptions = {
	            url: me.props.jsxfetchUrl,
	            dataType: me.props.dataType,
	            data: me.props.beforeFetch({ q: value }),
	            success: function success(data) {
	                var fetchData = me.props.afterFetch(data);
	                if (!!me.props.jsxdata) {
	                    fetchData = assign({}, fetchData, me.props.jsxdata);
	                }
	                me.setState({
	                    data: fetchData
	                });
	            },
	            fail: function fail() {
	                console.log("Fetch Data failed");
	            }
	        };
	        if (/\.jsonp/.test(me.props.jsxfetchUrl)) {
	            ajaxOptions.dataType = "jsonp";
	        }
	        $.ajax(ajaxOptions);
	    };

	    SelectFormField.prototype.handleChange = function handleChange(value, label) {
	        var me = this;
	        me.handleDataChange(value, false, label);
	    };

	    SelectFormField.prototype.handleSearch = function handleSearch(value) {
	        var me = this;
	        if (me.props.jsxfetchUrl) {
	            me.fetchData(value);
	        } else {
	            me.props.onSearch(value);
	        }
	    };

	    SelectFormField.prototype._processData = function _processData() {
	        var me = this;
	        var values = Object.keys(me.state.data);
	        var children = me.props.children;
	        if (!values.length) {
	            // console.warn("You need to pass data to initialize Select.");
	            if (!!children) {
	                return children;
	            }
	        } else {
	            var arr = values.map(function (value, index) {
	                var content = "";
	                var _me$props = me.props;
	                var multiple = _me$props.multiple;
	                var jsxmultiple = _me$props.jsxmultiple;
	                var combobox = _me$props.combobox;
	                var jsxcombobox = _me$props.jsxcombobox;

	                if (multiple == true || jsxmultiple == true || combobox == true || jsxcombobox == true) {
	                    content = me.state.data[value];
	                } else {
	                    content = React.createElement('span', { title: me.state.data[value] }, me.state.data[value]);
	                }
	                return React.createElement(Option, { key: value, title: me.state.data[value] }, content);
	            });
	            return arr;
	        }
	    };

	    SelectFormField.prototype.addSpecificClass = function addSpecificClass() {
	        var me = this;
	        if (me.props.jsxprefixCls == "kuma-uxform-field") {
	            return me.props.jsxprefixCls + " kuma-select-uxform-field";
	        } else {
	            return me.props.jsxprefixCls;
	        }
	    };

	    SelectFormField.prototype.hasDeprecatedProps = function hasDeprecatedProps() {
	        var arr = ['jsxmultiple', 'jsxallowClear', 'jsxcombobox', 'jsxsearchPlaceholder', 'jsxtags', 'jsxdisabled', 'jsxshowSearch', 'jsxplaceholder'];
	        var me = this;
	        var keys = Object.keys(me.props);
	        var hasDeprecated = keys.some(function (item, index) {
	            return arr.indexOf(item) != -1;
	        });
	        if (hasDeprecated) {
	            console.warn("SelectFormField: props same as uxcore-select2 can be passed without prefix 'jsx' now (exclude style). we will remove the support of the props mentioned above with prefix 'jsx' at uxcore-form@1.3.0 .");
	        }
	    };

	    SelectFormField.prototype.getValuePropValue = function getValuePropValue(child) {
	        var key = "";
	        if ('value' in child.props) {
	            key = child.props.value;
	        } else {
	            key = child.key;
	        }
	        return key;
	    };

	    SelectFormField.prototype.renderField = function renderField() {
	        var me = this;
	        var arr = [];
	        var mode = me.props.jsxmode || me.props.mode;

	        if (mode == Constants.MODE.EDIT) {
	            (function () {
	                var options = {
	                    ref: "el",
	                    key: "select",
	                    optionLabelProp: me.props.optionLabelProp,
	                    style: me.props.jsxstyle,
	                    multiple: me.props.jsxmultiple,
	                    allowClear: me.props.jsxallowClear,
	                    combobox: me.props.jsxcombobox,
	                    searchPlaceholder: me.props.jsxsearchPlaceholder,
	                    tags: me.props.jsxtags,
	                    optionFilterProp: me.props.optionFilterProp,
	                    disabled: !!me.props.jsxdisabled,
	                    // value: me.state.value || [],
	                    showSearch: me.props.jsxshowSearch,
	                    placeholder: me.props.jsxplaceholder,
	                    onChange: me.handleChange.bind(me),
	                    onSearch: me.handleSearch.bind(me)
	                };

	                selectOptions.forEach(function (item, index) {
	                    if (item in me.props) {
	                        options[item] = me.props[item];
	                    }
	                });

	                if (Object.keys(me.props.jsxdata).length > 0) {
	                    options.optionFilterProp = 'title';
	                }

	                // only jsxfetchUrl mode need pass label, for the options always change.
	                // when mount, state.label is undefined, which cause defalutValue cannot be used.
	                if (!!me.props.jsxfetchUrl && !!me.state.label && me.state.label.length !== 0) {
	                    options.label = me.state.label || [];
	                }

	                if (!me.props.combobox || me.state.fromReset) {
	                    options.value = me.state.value || [];
	                }

	                if (!!me.props.jsxfetchUrl) {
	                    options.filterOption = false;
	                }
	                arr.push(React.createElement(Select, options, me._processData()));
	            })();
	        } else if (mode == Constants.MODE.VIEW) {
	            var str = '';
	            if (me.state.value) {
	                (function () {
	                    var values = typeof me.state.value == 'string' ? [me.state.value] : me.state.value;

	                    if (me.state.label && me.state.label.length > 0) {
	                        str = me.state.label;
	                    } else {
	                        // if in jsxdata or jsxfetchUrl mode
	                        if (Object.keys(me.state.data).length > 0) {
	                            values.forEach(function (value, index) {
	                                str += me.state.data[value] + " ";
	                            });
	                        }
	                        // else in <Option> Mode
	                        else {
	                                me.props.children && me.props.children.forEach(function (child, index) {
	                                    var valuePropValue = me.getValuePropValue(child);
	                                    if (values.indexOf(valuePropValue) !== -1) {
	                                        str += child.props[me.props.optionLabelProp] + " ";
	                                    }
	                                });
	                            }
	                    }
	                })();
	            }
	            arr.push(React.createElement('span', { key: 'select' }, str));
	        }
	        return arr;
	    };

	    return SelectFormField;
	}(FormField);

	SelectFormField.Option = Option;
	SelectFormField.displayName = "SelectFormField";
	SelectFormField.propTypes = assign({}, FormField.propTypes, {
	    jsxstyle: React.PropTypes.object,
	    jsxplaceholder: React.PropTypes.string,
	    jsxcombobox: React.PropTypes.bool,
	    jsxdata: React.PropTypes.object,
	    beforeFetch: React.PropTypes.func,
	    afterFetch: React.PropTypes.func,
	    jsxshowSearch: React.PropTypes.bool,
	    jsxtags: React.PropTypes.bool,
	    jsxmultiple: React.PropTypes.bool,
	    jsxallowClear: React.PropTypes.bool,
	    jsxsearchPlaceholder: React.PropTypes.string,
	    optionFilterProp: React.PropTypes.string,
	    dataType: React.PropTypes.string
	});
	SelectFormField.defaultProps = assign({}, FormField.defaultProps, {
	    jsxstyle: {},
	    jsxplaceholder: "请下拉选择",
	    jsxcombobox: false,
	    jsxdata: {},
	    beforeFetch: function beforeFetch(obj) {
	        return obj;
	    },
	    afterFetch: function afterFetch(obj) {
	        return obj;
	    },
	    onSearch: function onSearch() {},
	    jsxshowSearch: true,
	    jsxallowClear: false,
	    jsxtags: false,
	    jsxmultiple: false,
	    jsxsearchPlaceholder: "",
	    optionFilterProp: "children",
	    optionLabelProp: "children",
	    dataType: 'json'
	});

		module.exports = SelectFormField;

/***/ },
/* 356 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Select2 Component for uxcore
	 * @author 
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

		module.exports = __webpack_require__(357);

/***/ },
/* 357 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var RcSelect = __webpack_require__(358);
	var assign = __webpack_require__(377);

	var Select2 = function (_RcSelect) {
	    _inherits(Select2, _RcSelect);

	    function Select2(props) {
	        _classCallCheck(this, Select2);

	        return _possibleConstructorReturn(this, _RcSelect.call(this, props));
	    }

	    return Select2;
	}(RcSelect);

	Select2.displayName = 'Select2';
	Select2.defaultProps = assign({}, RcSelect.defaultProps, {
	    prefixCls: "kuma-select2",
	    optionLabelProp: "children",
	    transitionName: 'slideUp'
	});

		module.exports = Select2;

/***/ },
/* 358 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _Select = __webpack_require__(359);

	var _Select2 = _interopRequireDefault(_Select);

	var _Option = __webpack_require__(425);

	var _Option2 = _interopRequireDefault(_Option);

	var _OptGroup = __webpack_require__(381);

	var _OptGroup2 = _interopRequireDefault(_OptGroup);

	_Select2['default'].Option = _Option2['default'];
	_Select2['default'].OptGroup = _OptGroup2['default'];
	exports['default'] = _Select2['default'];
	module.exports = exports['default'];

/***/ },
/* 359 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	  } else {
	    obj[key] = value;
	  }return obj;
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(4);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _rcUtil = __webpack_require__(360);

	var _classnames = __webpack_require__(5);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _OptGroup = __webpack_require__(381);

	var _OptGroup2 = _interopRequireDefault(_OptGroup);

	var _rcAnimate = __webpack_require__(382);

	var _rcAnimate2 = _interopRequireDefault(_rcAnimate);

	var _util = __webpack_require__(391);

	var _SelectTrigger = __webpack_require__(406);

	var _SelectTrigger2 = _interopRequireDefault(_SelectTrigger);

	function noop() {}

	function filterFn(input, child) {
	  return String((0, _util.getPropValue)(child, this.props.optionFilterProp)).indexOf(input) > -1;
	}

	function saveRef(name, component) {
	  this[name] = component;
	}

	var Select = _react2['default'].createClass({
	  displayName: 'Select',

	  propTypes: {
	    defaultActiveFirstOption: _react.PropTypes.bool,
	    multiple: _react.PropTypes.bool,
	    filterOption: _react.PropTypes.any,
	    showSearch: _react.PropTypes.bool,
	    disabled: _react.PropTypes.bool,
	    showArrow: _react.PropTypes.bool,
	    tags: _react.PropTypes.bool,
	    transitionName: _react.PropTypes.string,
	    optionLabelProp: _react.PropTypes.string,
	    optionFilterProp: _react.PropTypes.string,
	    animation: _react.PropTypes.string,
	    choiceTransitionName: _react.PropTypes.string,
	    onChange: _react.PropTypes.func,
	    onSelect: _react.PropTypes.func,
	    onSearch: _react.PropTypes.func,
	    searchPlaceholder: _react.PropTypes.string,
	    placeholder: _react.PropTypes.any,
	    onDeselect: _react.PropTypes.func,
	    value: _react.PropTypes.oneOfType([_react.PropTypes.array, _react.PropTypes.string]),
	    defaultValue: _react.PropTypes.oneOfType([_react.PropTypes.array, _react.PropTypes.string]),
	    label: _react.PropTypes.oneOfType([_react.PropTypes.array, _react.PropTypes.any]),
	    defaultLabel: _react.PropTypes.oneOfType([_react.PropTypes.array, _react.PropTypes.any]),
	    dropdownStyle: _react.PropTypes.object,
	    maxTagTextLength: _react.PropTypes.number
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      prefixCls: 'rc-select',
	      filterOption: filterFn,
	      defaultActiveFirstOption: true,
	      showSearch: true,
	      allowClear: false,
	      placeholder: '',
	      searchPlaceholder: '',
	      defaultValue: [],
	      onChange: noop,
	      onSelect: noop,
	      onSearch: noop,
	      onDeselect: noop,
	      showArrow: true,
	      dropdownMatchSelectWidth: true,
	      dropdownStyle: {},
	      dropdownMenuStyle: {},
	      optionFilterProp: 'value',
	      optionLabelProp: 'value',
	      notFoundContent: 'Not Found'
	    };
	  },

	  getInitialState: function getInitialState() {
	    var props = this.props;
	    var value = [];
	    if ('value' in props) {
	      value = (0, _util.toArray)(props.value);
	    } else {
	      value = (0, _util.toArray)(props.defaultValue);
	    }
	    var label = this.getLabelFromProps(props, value, 1);
	    var inputValue = '';
	    if (props.combobox) {
	      inputValue = value[0] || '';
	    }
	    this.saveInputRef = saveRef.bind(this, 'inputInstance');
	    return { value: value, inputValue: inputValue, label: label };
	  },

	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    if ('value' in nextProps) {
	      var value = (0, _util.toArray)(nextProps.value);
	      var label = this.getLabelFromProps(nextProps, value);
	      this.setState({
	        value: value,
	        label: label
	      });
	      if (nextProps.combobox) {
	        this.setState({
	          inputValue: value[0] || ''
	        });
	      }
	    }
	  },

	  componentDidUpdate: function componentDidUpdate() {
	    var state = this.state;
	    var props = this.props;
	    if (state.open && (0, _util.isMultipleOrTags)(props)) {
	      var inputNode = this.getInputDOMNode();
	      if (inputNode.value) {
	        inputNode.style.width = '';
	        inputNode.style.width = inputNode.scrollWidth + 'px';
	      } else {
	        inputNode.style.width = '';
	      }
	    }
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    if (this.dropdownContainer) {
	      _reactDom2['default'].unmountComponentAtNode(this.dropdownContainer);
	      document.body.removeChild(this.dropdownContainer);
	      this.dropdownContainer = null;
	    }
	  },

	  onInputChange: function onInputChange(event) {
	    var val = event.target.value;
	    var props = this.props;
	    this.setState({
	      inputValue: val,
	      open: true
	    });
	    if ((0, _util.isCombobox)(props)) {
	      this.fireChange([val], [val]);
	    }
	    props.onSearch(val);
	  },

	  onDropdownVisibleChange: function onDropdownVisibleChange(open) {
	    this.setOpenState(open);
	  },

	  // combobox ignore
	  onKeyDown: function onKeyDown(event) {
	    var props = this.props;
	    if (props.disabled) {
	      return;
	    }
	    var keyCode = event.keyCode;
	    if (this.state.open && !this.getInputDOMNode()) {
	      this.onInputKeyDown(event);
	    } else if (keyCode === _rcUtil.KeyCode.ENTER || keyCode === _rcUtil.KeyCode.DOWN) {
	      this.setOpenState(true);
	      event.preventDefault();
	    }
	  },

	  onInputKeyDown: function onInputKeyDown(event) {
	    var props = this.props;
	    var state = this.state;
	    var keyCode = event.keyCode;
	    if ((0, _util.isMultipleOrTags)(props) && !event.target.value && keyCode === _rcUtil.KeyCode.BACKSPACE) {
	      var value = state.value.concat();
	      if (value.length) {
	        var label = state.label.concat();
	        var popValue = value.pop();
	        label.pop();
	        props.onDeselect(popValue);
	        this.fireChange(value, label);
	      }
	      return;
	    }

	    if (keyCode === _rcUtil.KeyCode.DOWN) {
	      if (!state.open) {
	        this.openIfHasChildren();
	        event.preventDefault();
	        event.stopPropagation();
	        return;
	      }
	    } else if (keyCode === _rcUtil.KeyCode.ESC) {
	      if (state.open) {
	        this.setOpenState(false);
	        event.preventDefault();
	        event.stopPropagation();
	      }
	      return;
	    }

	    if (state.open) {
	      var menu = this.refs.trigger.getInnerMenu();
	      if (menu && menu.onKeyDown(event)) {
	        event.preventDefault();
	        event.stopPropagation();
	      }
	    }
	  },

	  onMenuSelect: function onMenuSelect(_ref) {
	    var item = _ref.item;

	    var value = this.state.value;
	    var label = this.state.label;
	    var props = this.props;
	    var selectedValue = (0, _util.getValuePropValue)(item);
	    var selectedLabel = this.getLabelFromOption(item);
	    props.onSelect(selectedValue, item);
	    if ((0, _util.isMultipleOrTags)(props)) {
	      if (value.indexOf(selectedValue) !== -1) {
	        return;
	      }
	      value = value.concat([selectedValue]);
	      label = label.concat([selectedLabel]);
	    } else {
	      if (value[0] === selectedValue) {
	        this.setOpenState(false);
	        return;
	      }
	      value = [selectedValue];
	      label = [selectedLabel];
	      this.setOpenState(false);
	    }
	    this.fireChange(value, label);
	    this.setState({
	      inputValue: ''
	    });
	    if ((0, _util.isCombobox)(props)) {
	      this.setState({
	        inputValue: (0, _util.getPropValue)(item, props.optionLabelProp)
	      });
	    }
	  },

	  onMenuDeselect: function onMenuDeselect(_ref2) {
	    var item = _ref2.item;
	    var domEvent = _ref2.domEvent;

	    if (domEvent.type === 'click') {
	      this.removeSelected((0, _util.getValuePropValue)(item));
	    }
	    if (!(0, _util.isMultipleOrTags)(this.props)) {
	      this.setOpenState(false);
	    }
	    this.setState({
	      inputValue: ''
	    });
	  },

	  onPlaceholderClick: function onPlaceholderClick() {
	    this.getInputDOMNode().focus();
	  },

	  onClearSelection: function onClearSelection(event) {
	    var props = this.props;
	    var state = this.state;
	    if (props.disabled) {
	      return;
	    }
	    event.stopPropagation();
	    if (state.inputValue || state.value.length) {
	      this.fireChange([], []);
	      this.setOpenState(false);
	      this.setState({
	        inputValue: ''
	      });
	    }
	  },

	  getLabelBySingleValue: function getLabelBySingleValue(children, value) {
	    var _this = this;

	    if (value === undefined) {
	      return null;
	    }
	    var label = null;
	    _react2['default'].Children.forEach(children, function (child) {
	      if (child.type === _OptGroup2['default']) {
	        var maybe = _this.getLabelBySingleValue(child.props.children, value);
	        if (maybe !== null) {
	          label = maybe;
	        }
	      } else if ((0, _util.getValuePropValue)(child) === value) {
	        label = _this.getLabelFromOption(child);
	      }
	    });
	    return label;
	  },

	  getLabelFromOption: function getLabelFromOption(child) {
	    return (0, _util.getPropValue)(child, this.props.optionLabelProp);
	  },

	  getLabelFromProps: function getLabelFromProps(props, value, init) {
	    var label = [];
	    if ('label' in props) {
	      label = (0, _util.toArray)(props.label);
	    } else if (init && 'defaultLabel' in props) {
	      label = (0, _util.toArray)(props.defaultLabel);
	    } else {
	      label = this.getLabelByValue(props.children, value);
	    }
	    return label;
	  },

	  getVLForOnChange: function getVLForOnChange(vls) {
	    if (vls !== undefined) {
	      return (0, _util.isMultipleOrTags)(this.props) ? vls : vls[0];
	    }
	    return vls;
	  },

	  getLabelByValue: function getLabelByValue(children, values) {
	    var _this2 = this;

	    return values.map(function (value) {
	      var label = _this2.getLabelBySingleValue(children, value);
	      if (label === null) {
	        return value;
	      }
	      return label;
	    });
	  },

	  getDropdownContainer: function getDropdownContainer() {
	    if (!this.dropdownContainer) {
	      this.dropdownContainer = document.createElement('div');
	      document.body.appendChild(this.dropdownContainer);
	    }
	    return this.dropdownContainer;
	  },

	  getSearchPlaceholderElement: function getSearchPlaceholderElement(hidden) {
	    var props = this.props;
	    if (props.searchPlaceholder) {
	      return _react2['default'].createElement('span', {
	        style: { display: hidden ? 'none' : 'block' },
	        onClick: this.onPlaceholderClick,
	        className: props.prefixCls + '-search__field__placeholder' }, props.searchPlaceholder);
	    }
	    return null;
	  },

	  getInputElement: function getInputElement() {
	    var props = this.props;
	    return _react2['default'].createElement('span', { className: props.prefixCls + '-search__field__wrap' }, _react2['default'].createElement('input', { ref: this.saveInputRef,
	      onChange: this.onInputChange,
	      onKeyDown: this.onInputKeyDown,
	      value: this.state.inputValue,
	      disabled: props.disabled,
	      className: props.prefixCls + '-search__field',
	      role: 'textbox' }), (0, _util.isMultipleOrTags)(props) ? null : this.getSearchPlaceholderElement(!!this.state.inputValue));
	  },

	  getInputDOMNode: function getInputDOMNode() {
	    return this.inputInstance;
	  },

	  getPopupDOMNode: function getPopupDOMNode() {
	    return this.refs.trigger.getPopupDOMNode();
	  },

	  getPopupMenuComponent: function getPopupMenuComponent() {
	    return this.refs.trigger.getInnerMenu();
	  },

	  setOpenState: function setOpenState(open) {
	    var _this3 = this;

	    var refs = this.refs;
	    this.setState({
	      open: open
	    }, function () {
	      if (open || (0, _util.isMultipleOrTagsOrCombobox)(_this3.props)) {
	        if (_this3.getInputDOMNode()) {
	          _this3.getInputDOMNode().focus();
	        }
	      } else if (refs.selection) {
	        refs.selection.focus();
	      }
	    });
	  },

	  removeSelected: function removeSelected(selectedValue) {
	    var props = this.props;
	    if (props.disabled) {
	      return;
	    }
	    var label = this.state.label.concat();
	    var index = this.state.value.indexOf(selectedValue);
	    var value = this.state.value.filter(function (singleValue) {
	      return singleValue !== selectedValue;
	    });
	    if (index !== -1) {
	      label.splice(index, 1);
	    }
	    var canMultiple = (0, _util.isMultipleOrTags)(props);
	    if (canMultiple) {
	      props.onDeselect(selectedValue);
	    }
	    this.fireChange(value, label);
	  },

	  openIfHasChildren: function openIfHasChildren() {
	    var props = this.props;
	    if (_react2['default'].Children.count(props.children) || (0, _util.isSingleMode)(props)) {
	      this.setOpenState(true);
	    }
	  },

	  fireChange: function fireChange(value, label) {
	    var props = this.props;
	    if (!('value' in props)) {
	      this.setState({
	        value: value, label: label
	      });
	    }
	    props.onChange(this.getVLForOnChange(value), this.getVLForOnChange(label));
	  },
	  renderTopControlNode: function renderTopControlNode() {
	    var _this4 = this;

	    var value = this.state.value;
	    var label = this.state.label;
	    var props = this.props;
	    var choiceTransitionName = props.choiceTransitionName;
	    var prefixCls = props.prefixCls;
	    var maxTagTextLength = props.maxTagTextLength;

	    // single and not combobox, input is inside dropdown
	    if ((0, _util.isSingleMode)(props)) {
	      var placeholder = _react2['default'].createElement('span', { key: 'placeholder',
	        className: prefixCls + '-selection__placeholder' }, props.placeholder);
	      var innerNode = placeholder;
	      if (this.state.label[0]) {
	        innerNode = _react2['default'].createElement('span', { key: 'value' }, this.state.label[0]);
	      }
	      return _react2['default'].createElement('span', { className: prefixCls + '-selection__rendered' }, innerNode);
	    }

	    var selectedValueNodes = [];
	    if ((0, _util.isMultipleOrTags)(props)) {
	      selectedValueNodes = value.map(function (singleValue, index) {
	        var content = label[index];
	        var title = content;
	        if (maxTagTextLength && typeof content === 'string' && content.length > maxTagTextLength) {
	          content = content.slice(0, maxTagTextLength) + '...';
	        }
	        return _react2['default'].createElement('li', { className: prefixCls + '-selection__choice',
	          key: singleValue,
	          title: title }, _react2['default'].createElement('span', { className: prefixCls + '-selection__choice__content' }, content), _react2['default'].createElement('span', { className: prefixCls + '-selection__choice__remove',
	          onClick: _this4.removeSelected.bind(_this4, singleValue) }));
	      });
	    }
	    selectedValueNodes.push(_react2['default'].createElement('li', { className: prefixCls + '-search ' + prefixCls + '-search--inline', key: '__input' }, this.getInputElement()));
	    var className = prefixCls + '-selection__rendered';
	    if ((0, _util.isMultipleOrTags)(props) && choiceTransitionName) {
	      return _react2['default'].createElement(_rcAnimate2['default'], { className: className,
	        component: 'ul',
	        transitionName: choiceTransitionName }, selectedValueNodes);
	    }
	    return _react2['default'].createElement('ul', { className: className }, selectedValueNodes);
	  },

	  render: function render() {
	    var _rootCls;

	    var props = this.props;
	    var multiple = (0, _util.isMultipleOrTags)(props);
	    var state = this.state;
	    var className = props.className;
	    var disabled = props.disabled;
	    var allowClear = props.allowClear;
	    var prefixCls = props.prefixCls;

	    var ctrlNode = this.renderTopControlNode();
	    var extraSelectionProps = {};
	    if (!(0, _util.isCombobox)(props)) {
	      extraSelectionProps = {
	        onKeyDown: this.onKeyDown,
	        tabIndex: 0
	      };
	    }
	    var rootCls = (_rootCls = {}, _defineProperty(_rootCls, className, !!className), _defineProperty(_rootCls, prefixCls, 1), _defineProperty(_rootCls, prefixCls + '-open', state.open), _defineProperty(_rootCls, prefixCls + '-combobox', (0, _util.isCombobox)(props)), _defineProperty(_rootCls, prefixCls + '-disabled', disabled), _defineProperty(_rootCls, prefixCls + '-enabled', !disabled), _rootCls);

	    var clear = _react2['default'].createElement('span', { key: 'clear',
	      className: prefixCls + '-selection__clear',
	      onClick: this.onClearSelection });
	    return _react2['default'].createElement(_SelectTrigger2['default'], _extends({}, props, {
	      options: props.children,
	      multiple: multiple,
	      disabled: disabled,
	      visible: state.open,
	      inputValue: state.inputValue,
	      inputElement: this.getInputElement(),
	      value: state.value,
	      onDropdownVisibleChange: this.onDropdownVisibleChange,
	      onMenuSelect: this.onMenuSelect,
	      onMenuDeselect: this.onMenuDeselect,
	      ref: 'trigger' }), _react2['default'].createElement('span', {
	      style: props.style,
	      className: (0, _classnames2['default'])(rootCls) }, _react2['default'].createElement('span', _extends({ ref: 'selection',
	      key: 'selection',
	      className: prefixCls + '-selection ' + prefixCls + '-selection--' + (multiple ? 'multiple' : 'single'),
	      role: 'combobox',
	      'aria-autocomplete': 'list',
	      'aria-haspopup': 'true',
	      'aria-expanded': state.open
	    }, extraSelectionProps), ctrlNode, allowClear && !(0, _util.isMultipleOrTags)(props) ? clear : null, multiple || !props.showArrow ? null : _react2['default'].createElement('span', { key: 'arrow', className: prefixCls + '-arrow', tabIndex: '-1', style: { outline: 'none' } }, _react2['default'].createElement('b', null)), multiple ? this.getSearchPlaceholderElement(!!this.state.inputValue || this.state.value.length) : null)));
	  }
	});

	exports['default'] = Select;
	module.exports = exports['default'];

/***/ },
/* 360 */
[749, 361, 362, 364, 365, 366, 367, 372, 373, 378, 379, 380],
/* 361 */
17,
/* 362 */
[750, 363],
/* 363 */
19,
/* 364 */
[751, 363],
/* 365 */
21,
/* 366 */
[752, 367],
/* 367 */
[753, 368],
/* 368 */
[754, 369, 370, 371],
/* 369 */
25,
/* 370 */
26,
/* 371 */
27,
/* 372 */
28,
/* 373 */
[755, 374],
/* 374 */
[756, 375],
/* 375 */
[757, 376, 377],
/* 376 */
32,
/* 377 */
33,
/* 378 */
34,
/* 379 */
35,
/* 380 */
36,
/* 381 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _get = function get(_x, _x2, _x3) {
	  var _again = true;_function: while (_again) {
	    var object = _x,
	        property = _x2,
	        receiver = _x3;_again = false;if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
	      var parent = Object.getPrototypeOf(object);if (parent === null) {
	        return undefined;
	      } else {
	        _x = parent;_x2 = property;_x3 = receiver;_again = true;desc = parent = undefined;continue _function;
	      }
	    } else if ('value' in desc) {
	      return desc.value;
	    } else {
	      var getter = desc.get;if (getter === undefined) {
	        return undefined;
	      }return getter.call(receiver);
	    }
	  }
	};

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError('Cannot call a class as a function');
	  }
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== 'function' && superClass !== null) {
	    throw new TypeError('Super expression must either be null or a function, not ' + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var OptGroup = function (_React$Component) {
	  _inherits(OptGroup, _React$Component);

	  function OptGroup() {
	    _classCallCheck(this, OptGroup);

	    _get(Object.getPrototypeOf(OptGroup.prototype), 'constructor', this).apply(this, arguments);
	  }

	  return OptGroup;
	}(_react2['default'].Component);

	exports['default'] = OptGroup;
	module.exports = exports['default'];

/***/ },
/* 382 */
[770, 383],
/* 383 */
[771, 384, 385, 390],
/* 384 */
76,
/* 385 */
[772, 386, 390],
/* 386 */
[773, 387, 388],
/* 387 */
79,
/* 388 */
[774, 389, 389],
/* 389 */
81,
/* 390 */
82,
/* 391 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports.getValuePropValue = getValuePropValue;
	exports.getPropValue = getPropValue;
	exports.isCombobox = isCombobox;
	exports.isMultipleOrTags = isMultipleOrTags;
	exports.isMultipleOrTagsOrCombobox = isMultipleOrTagsOrCombobox;
	exports.isSingleMode = isSingleMode;
	exports.toArray = toArray;
	exports.getSelectKeys = getSelectKeys;

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _rcMenu = __webpack_require__(392);

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	function getValuePropValue(child) {
	  var props = child.props;
	  if ('value' in props) {
	    return props.value;
	  }
	  if (child.key) {
	    return child.key;
	  }
	  throw new Error('no key or value for ' + child);
	}

	function getPropValue(child, prop) {
	  if (prop === 'value') {
	    return getValuePropValue(child);
	  }
	  return child.props[prop];
	}

	function isCombobox(props) {
	  return props.combobox;
	}

	function isMultipleOrTags(props) {
	  return props.multiple || props.tags;
	}

	function isMultipleOrTagsOrCombobox(props) {
	  return isMultipleOrTags(props) || isCombobox(props);
	}

	function isSingleMode(props) {
	  return !isMultipleOrTagsOrCombobox(props);
	}

	function toArray(value) {
	  var ret = value;
	  if (value === undefined) {
	    ret = [];
	  } else if (!Array.isArray(value)) {
	    ret = [value];
	  }
	  return ret;
	}

	function getSelectKeys(menuItems, value) {
	  if (value === null || value === undefined) {
	    return [];
	  }
	  var selectedKeys = [];
	  _react2['default'].Children.forEach(menuItems, function (item) {
	    if (item.type === _rcMenu.ItemGroup) {
	      selectedKeys = selectedKeys.concat(getSelectKeys(item.props.children, value));
	    } else {
	      var itemValue = getValuePropValue(item);
	      var itemKey = item.key;
	      if (value.indexOf(itemValue) !== -1 && itemKey) {
	        selectedKeys.push(itemKey);
	      }
	    }
	  });
	  return selectedKeys;
		}

/***/ },
/* 392 */
[779, 393, 400, 403, 404, 405],
/* 393 */
[780, 394, 377, 398],
/* 394 */
[781, 360, 395, 377, 398, 399],
/* 395 */
[782, 396],
/* 396 */
[783, 397],
/* 397 */
/***/ function(module, exports) {

	'use strict';

	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};

	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};

	var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;

	function getClientPosition(elem) {
	  var box = undefined;
	  var x = undefined;
	  var y = undefined;
	  var doc = elem.ownerDocument;
	  var body = doc.body;
	  var docElem = doc && doc.documentElement;
	  // 根据 GBS 最新数据，A-Grade Browsers 都已支持 getBoundingClientRect 方法，不用再考虑传统的实现方式
	  box = elem.getBoundingClientRect();

	  // 注：jQuery 还考虑减去 docElem.clientLeft/clientTop
	  // 但测试发现，这样反而会导致当 html 和 body 有边距/边框样式时，获取的值不正确
	  // 此外，ie6 会忽略 html 的 margin 值，幸运地是没有谁会去设置 html 的 margin

	  x = box.left;
	  y = box.top;

	  // In IE, most of the time, 2 extra pixels are added to the top and left
	  // due to the implicit 2-pixel inset border.  In IE6/7 quirks mode and
	  // IE6 standards mode, this border can be overridden by setting the
	  // document element's border to zero -- thus, we cannot rely on the
	  // offset always being 2 pixels.

	  // In quirks mode, the offset can be determined by querying the body's
	  // clientLeft/clientTop, but in standards mode, it is found by querying
	  // the document element's clientLeft/clientTop.  Since we already called
	  // getClientBoundingRect we have already forced a reflow, so it is not
	  // too expensive just to query them all.

	  // ie 下应该减去窗口的边框吧，毕竟默认 absolute 都是相对窗口定位的
	  // 窗口边框标准是设 documentElement ,quirks 时设置 body
	  // 最好禁止在 body 和 html 上边框 ，但 ie < 9 html 默认有 2px ，减去
	  // 但是非 ie 不可能设置窗口边框，body html 也不是窗口 ,ie 可以通过 html,body 设置
	  // 标准 ie 下 docElem.clientTop 就是 border-top
	  // ie7 html 即窗口边框改变不了。永远为 2
	  // 但标准 firefox/chrome/ie9 下 docElem.clientTop 是窗口边框，即使设了 border-top 也为 0

	  x -= docElem.clientLeft || body.clientLeft || 0;
	  y -= docElem.clientTop || body.clientTop || 0;

	  return {
	    left: x,
	    top: y
	  };
	}

	function getScroll(w, top) {
	  var ret = w['page' + (top ? 'Y' : 'X') + 'Offset'];
	  var method = 'scroll' + (top ? 'Top' : 'Left');
	  if (typeof ret !== 'number') {
	    var d = w.document;
	    // ie6,7,8 standard mode
	    ret = d.documentElement[method];
	    if (typeof ret !== 'number') {
	      // quirks mode
	      ret = d.body[method];
	    }
	  }
	  return ret;
	}

	function getScrollLeft(w) {
	  return getScroll(w);
	}

	function getScrollTop(w) {
	  return getScroll(w, true);
	}

	function getOffset(el) {
	  var pos = getClientPosition(el);
	  var doc = el.ownerDocument;
	  var w = doc.defaultView || doc.parentWindow;
	  pos.left += getScrollLeft(w);
	  pos.top += getScrollTop(w);
	  return pos;
	}
	function _getComputedStyle(elem, name, computedStyle_) {
	  var val = '';
	  var d = elem.ownerDocument;
	  var computedStyle = computedStyle_ || d.defaultView.getComputedStyle(elem, null);

	  // https://github.com/kissyteam/kissy/issues/61
	  if (computedStyle) {
	    val = computedStyle.getPropertyValue(name) || computedStyle[name];
	  }

	  return val;
	}

	var _RE_NUM_NO_PX = new RegExp('^(' + RE_NUM + ')(?!px)[a-z%]+$', 'i');
	var RE_POS = /^(top|right|bottom|left)$/;
	var CURRENT_STYLE = 'currentStyle';
	var RUNTIME_STYLE = 'runtimeStyle';
	var LEFT = 'left';
	var PX = 'px';

	function _getComputedStyleIE(elem, name) {
	  // currentStyle maybe null
	  // http://msdn.microsoft.com/en-us/library/ms535231.aspx
	  var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name];

	  // 当 width/height 设置为百分比时，通过 pixelLeft 方式转换的 width/height 值
	  // 一开始就处理了! CUSTOM_STYLE.height,CUSTOM_STYLE.width ,cssHook 解决@2011-08-19
	  // 在 ie 下不对，需要直接用 offset 方式
	  // borderWidth 等值也有问题，但考虑到 borderWidth 设为百分比的概率很小，这里就不考虑了

	  // From the awesome hack by Dean Edwards
	  // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
	  // If we're not dealing with a regular pixel number
	  // but a number that has a weird ending, we need to convert it to pixels
	  // exclude left right for relativity
	  if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name)) {
	    // Remember the original values
	    var style = elem.style;
	    var left = style[LEFT];
	    var rsLeft = elem[RUNTIME_STYLE][LEFT];

	    // prevent flashing of content
	    elem[RUNTIME_STYLE][LEFT] = elem[CURRENT_STYLE][LEFT];

	    // Put in the new values to get a computed value out
	    style[LEFT] = name === 'fontSize' ? '1em' : ret || 0;
	    ret = style.pixelLeft + PX;

	    // Revert the changed values
	    style[LEFT] = left;

	    elem[RUNTIME_STYLE][LEFT] = rsLeft;
	  }
	  return ret === '' ? 'auto' : ret;
	}

	var getComputedStyleX = undefined;
	if (typeof window !== 'undefined') {
	  getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;
	}

	function each(arr, fn) {
	  for (var i = 0; i < arr.length; i++) {
	    fn(arr[i]);
	  }
	}

	function isBorderBoxFn(elem) {
	  return getComputedStyleX(elem, 'boxSizing') === 'border-box';
	}

	var BOX_MODELS = ['margin', 'border', 'padding'];
	var CONTENT_INDEX = -1;
	var PADDING_INDEX = 2;
	var BORDER_INDEX = 1;
	var MARGIN_INDEX = 0;

	function swap(elem, options, callback) {
	  var old = {};
	  var style = elem.style;
	  var name = undefined;

	  // Remember the old values, and insert the new ones
	  for (name in options) {
	    if (options.hasOwnProperty(name)) {
	      old[name] = style[name];
	      style[name] = options[name];
	    }
	  }

	  callback.call(elem);

	  // Revert the old values
	  for (name in options) {
	    if (options.hasOwnProperty(name)) {
	      style[name] = old[name];
	    }
	  }
	}

	function getPBMWidth(elem, props, which) {
	  var value = 0;
	  var prop = undefined;
	  var j = undefined;
	  var i = undefined;
	  for (j = 0; j < props.length; j++) {
	    prop = props[j];
	    if (prop) {
	      for (i = 0; i < which.length; i++) {
	        var cssProp = undefined;
	        if (prop === 'border') {
	          cssProp = prop + which[i] + 'Width';
	        } else {
	          cssProp = prop + which[i];
	        }
	        value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
	      }
	    }
	  }
	  return value;
	}

	/**
	 * A crude way of determining if an object is a window
	 * @member util
	 */
	function isWindow(obj) {
	  // must use == for ie8
	  /* eslint eqeqeq:0 */
	  return obj != null && obj == obj.window;
	}

	var domUtils = {};

	each(['Width', 'Height'], function (name) {
	  domUtils['doc' + name] = function (refWin) {
	    var d = refWin.document;
	    return Math.max(
	    // firefox chrome documentElement.scrollHeight< body.scrollHeight
	    // ie standard mode : documentElement.scrollHeight> body.scrollHeight
	    d.documentElement['scroll' + name],
	    // quirks : documentElement.scrollHeight 最大等于可视窗口多一点？
	    d.body['scroll' + name], domUtils['viewport' + name](d));
	  };

	  domUtils['viewport' + name] = function (win) {
	    // pc browser includes scrollbar in window.innerWidth
	    var prop = 'client' + name;
	    var doc = win.document;
	    var body = doc.body;
	    var documentElement = doc.documentElement;
	    var documentElementProp = documentElement[prop];
	    // 标准模式取 documentElement
	    // backcompat 取 body
	    return doc.compatMode === 'CSS1Compat' && documentElementProp || body && body[prop] || documentElementProp;
	  };
	});

	/*
	 得到元素的大小信息
	 @param elem
	 @param name
	 @param {String} [extra]  'padding' : (css width) + padding
	 'border' : (css width) + padding + border
	 'margin' : (css width) + padding + border + margin
	 */
	function getWH(elem, name, extra) {
	  if (isWindow(elem)) {
	    return name === 'width' ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
	  } else if (elem.nodeType === 9) {
	    return name === 'width' ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
	  }
	  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];
	  var borderBoxValue = name === 'width' ? elem.offsetWidth : elem.offsetHeight;
	  var computedStyle = getComputedStyleX(elem);
	  var isBorderBox = isBorderBoxFn(elem, computedStyle);
	  var cssBoxValue = 0;
	  if (borderBoxValue == null || borderBoxValue <= 0) {
	    borderBoxValue = undefined;
	    // Fall back to computed then un computed css if necessary
	    cssBoxValue = getComputedStyleX(elem, name);
	    if (cssBoxValue == null || Number(cssBoxValue) < 0) {
	      cssBoxValue = elem.style[name] || 0;
	    }
	    // Normalize '', auto, and prepare for extra
	    cssBoxValue = parseFloat(cssBoxValue) || 0;
	  }
	  if (extra === undefined) {
	    extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
	  }
	  var borderBoxValueOrIsBorderBox = borderBoxValue !== undefined || isBorderBox;
	  var val = borderBoxValue || cssBoxValue;
	  if (extra === CONTENT_INDEX) {
	    if (borderBoxValueOrIsBorderBox) {
	      return val - getPBMWidth(elem, ['border', 'padding'], which, computedStyle);
	    }
	    return cssBoxValue;
	  }
	  if (borderBoxValueOrIsBorderBox) {
	    var padding = extra === PADDING_INDEX ? -getPBMWidth(elem, ['border'], which, computedStyle) : getPBMWidth(elem, ['margin'], which, computedStyle);
	    return val + (extra === BORDER_INDEX ? 0 : padding);
	  }
	  return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which, computedStyle);
	}

	var cssShow = {
	  position: 'absolute',
	  visibility: 'hidden',
	  display: 'block'
	};

	// fix #119 : https://github.com/kissyteam/kissy/issues/119
	function getWHIgnoreDisplay(elem) {
	  var val = undefined;
	  var args = arguments;
	  // in case elem is window
	  // elem.offsetWidth === undefined
	  if (elem.offsetWidth !== 0) {
	    val = getWH.apply(undefined, args);
	  } else {
	    swap(elem, cssShow, function () {
	      val = getWH.apply(undefined, args);
	    });
	  }
	  return val;
	}

	function css(el, name, v) {
	  var value = v;
	  if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
	    for (var i in name) {
	      if (name.hasOwnProperty(i)) {
	        css(el, i, name[i]);
	      }
	    }
	    return undefined;
	  }
	  if (typeof value !== 'undefined') {
	    if (typeof value === 'number') {
	      value += 'px';
	    }
	    el.style[name] = value;
	    return undefined;
	  }
	  return getComputedStyleX(el, name);
	}

	each(['width', 'height'], function (name) {
	  var first = name.charAt(0).toUpperCase() + name.slice(1);
	  domUtils['outer' + first] = function (el, includeMargin) {
	    return el && getWHIgnoreDisplay(el, name, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
	  };
	  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];

	  domUtils[name] = function (elem, val) {
	    if (val !== undefined) {
	      if (elem) {
	        var computedStyle = getComputedStyleX(elem);
	        var isBorderBox = isBorderBoxFn(elem);
	        if (isBorderBox) {
	          val += getPBMWidth(elem, ['padding', 'border'], which, computedStyle);
	        }
	        return css(elem, name, val);
	      }
	      return undefined;
	    }
	    return elem && getWHIgnoreDisplay(elem, name, CONTENT_INDEX);
	  };
	});

	// 设置 elem 相对 elem.ownerDocument 的坐标
	function setOffset(elem, offset) {
	  // set position first, in-case top/left are set even on static elem
	  if (css(elem, 'position') === 'static') {
	    elem.style.position = 'relative';
	  }

	  var old = getOffset(elem);
	  var ret = {};
	  var current = undefined;
	  var key = undefined;

	  for (key in offset) {
	    if (offset.hasOwnProperty(key)) {
	      current = parseFloat(css(elem, key)) || 0;
	      ret[key] = current + offset[key] - old[key];
	    }
	  }
	  css(elem, ret);
	}

	module.exports = _extends({
	  getWindow: function getWindow(node) {
	    var doc = node.ownerDocument || node;
	    return doc.defaultView || doc.parentWindow;
	  },
	  offset: function offset(el, value) {
	    if (typeof value !== 'undefined') {
	      setOffset(el, value);
	    } else {
	      return getOffset(el);
	    }
	  },

	  isWindow: isWindow,
	  each: each,
	  css: css,
	  clone: function clone(obj) {
	    var ret = {};
	    for (var i in obj) {
	      if (obj.hasOwnProperty(i)) {
	        ret[i] = obj[i];
	      }
	    }
	    var overflow = obj.overflow;
	    if (overflow) {
	      for (var i in obj) {
	        if (obj.hasOwnProperty(i)) {
	          ret.overflow[i] = obj.overflow[i];
	        }
	      }
	    }
	    return ret;
	  },
	  scrollLeft: function scrollLeft(w, v) {
	    if (isWindow(w)) {
	      if (v === undefined) {
	        return getScrollLeft(w);
	      }
	      window.scrollTo(v, getScrollTop(w));
	    } else {
	      if (v === undefined) {
	        return w.scrollLeft;
	      }
	      w.scrollLeft = v;
	    }
	  },
	  scrollTop: function scrollTop(w, v) {
	    if (isWindow(w)) {
	      if (v === undefined) {
	        return getScrollTop(w);
	      }
	      window.scrollTo(getScrollLeft(w), v);
	    } else {
	      if (v === undefined) {
	        return w.scrollTop;
	      }
	      w.scrollTop = v;
	    }
	  },

	  viewportWidth: 0,
	  viewportHeight: 0
		}, domUtils);

/***/ },
/* 398 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports.noop = noop;
	exports.getKeyFromChildrenIndex = getKeyFromChildrenIndex;
	exports.loopMenuItem = loopMenuItem;

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var now = Date.now();

	function noop() {}

	function getKeyFromChildrenIndex(child, menuEventKey, index) {
	  var prefix = menuEventKey || '';
	  return child.key || prefix + 'item_' + now + '_' + index;
	}

	function loopMenuItem(children, cb) {
	  var index = -1;
	  _react2['default'].Children.forEach(children, function (c) {
	    index++;
	    if (c && c.type.isMenuItemGroup) {
	      _react2['default'].Children.forEach(c.props.children, function (c2) {
	        index++;
	        cb(c2, index);
	      });
	    } else {
	      cb(c, index);
	    }
	  });
		}

/***/ },
/* 399 */
[784, 377],
/* 400 */
[785, 401, 360, 377, 402],
/* 401 */
[786, 394, 377, 398, 382],
/* 402 */
[787, 360],
/* 403 */
[788, 360],
/* 404 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var MenuItemGroup = _react2['default'].createClass({
	  displayName: 'MenuItemGroup',

	  propTypes: {
	    renderMenuItem: _react.PropTypes.func,
	    index: _react.PropTypes.number
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      disabled: true
	    };
	  },

	  renderInnerMenuItem: function renderInnerMenuItem(item, subIndex) {
	    var renderMenuItem = this.props.renderMenuItem;
	    return renderMenuItem(item, this.props.index, subIndex);
	  },

	  render: function render() {
	    var props = this.props;
	    var className = props.className || '';
	    var rootPrefixCls = props.rootPrefixCls;

	    className += ' ' + rootPrefixCls + '-item-group';
	    var titleClassName = rootPrefixCls + '-item-group-title';
	    var listClassName = rootPrefixCls + '-item-group-list';
	    return _react2['default'].createElement('li', { className: className }, _react2['default'].createElement('div', { className: titleClassName }, props.title), _react2['default'].createElement('ul', { className: listClassName }, _react2['default'].Children.map(props.children, this.renderInnerMenuItem)));
	  }
	});

	MenuItemGroup.isMenuItemGroup = true;

	exports['default'] = MenuItemGroup;
	module.exports = exports['default'];

/***/ },
/* 405 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var Divider = _react2['default'].createClass({
	  displayName: 'Divider',

	  getDefaultProps: function getDefaultProps() {
	    return {
	      disabled: true
	    };
	  },

	  render: function render() {
	    var props = this.props;
	    var className = props.className || '';
	    var rootPrefixCls = props.rootPrefixCls;
	    className += ' ' + (rootPrefixCls + '-item-divider');
	    return _react2['default'].createElement('li', _extends({}, props, { className: className }));
	  }
	});

	exports['default'] = Divider;
	module.exports = exports['default'];

/***/ },
/* 406 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	  } else {
	    obj[key] = value;
	  }return obj;
	}

	var _rcTrigger = __webpack_require__(407);

	var _rcTrigger2 = _interopRequireDefault(_rcTrigger);

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _classnames = __webpack_require__(5);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _DropdownMenu = __webpack_require__(424);

	var _DropdownMenu2 = _interopRequireDefault(_DropdownMenu);

	var _reactDom = __webpack_require__(4);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _OptGroup = __webpack_require__(381);

	var _OptGroup2 = _interopRequireDefault(_OptGroup);

	var _util = __webpack_require__(391);

	var _rcMenu = __webpack_require__(392);

	var BUILT_IN_PLACEMENTS = {
	  bottomLeft: {
	    points: ['tl', 'bl'],
	    offset: [0, 4],
	    overflow: {
	      adjustX: 0,
	      adjustY: 1
	    }
	  },
	  topLeft: {
	    points: ['bl', 'tl'],
	    offset: [0, -4],
	    overflow: {
	      adjustX: 0,
	      adjustY: 1
	    }
	  }
	};

	var SelectTrigger = _react2['default'].createClass({
	  displayName: 'SelectTrigger',

	  propTypes: {
	    dropdownMatchSelectWidth: _react.PropTypes.bool,
	    visible: _react.PropTypes.bool,
	    filterOption: _react.PropTypes.any,
	    options: _react.PropTypes.any,
	    prefixCls: _react.PropTypes.string,
	    popupClassName: _react.PropTypes.string,
	    children: _react.PropTypes.any
	  },

	  componentDidUpdate: function componentDidUpdate() {
	    if (this.props.dropdownMatchSelectWidth && this.props.visible) {
	      var dropdownDOMNode = this.getPopupDOMNode();
	      if (dropdownDOMNode) {
	        dropdownDOMNode.style.width = _reactDom2['default'].findDOMNode(this).offsetWidth + 'px';
	      }
	    }
	  },

	  getInnerMenu: function getInnerMenu() {
	    return this.popupMenu && this.popupMenu.refs.menu;
	  },

	  getPopupDOMNode: function getPopupDOMNode() {
	    return this.refs.trigger.getPopupDomNode();
	  },

	  getDropdownElement: function getDropdownElement(newProps) {
	    var props = this.props;
	    return _react2['default'].createElement(_DropdownMenu2['default'], _extends({
	      ref: this.saveMenu
	    }, newProps, {
	      prefixCls: this.getDropdownPrefixCls(),
	      onMenuSelect: props.onMenuSelect,
	      onMenuDeselect: props.onMenuDeselect,
	      value: props.value,
	      defaultActiveFirstOption: props.defaultActiveFirstOption,
	      dropdownMenuStyle: props.dropdownMenuStyle
	    }));
	  },

	  getDropdownTransitionName: function getDropdownTransitionName() {
	    var props = this.props;
	    var transitionName = props.transitionName;
	    if (!transitionName && props.animation) {
	      transitionName = this.getDropdownPrefixCls() + '-' + props.animation;
	    }
	    return transitionName;
	  },

	  getDropdownPrefixCls: function getDropdownPrefixCls() {
	    return this.props.prefixCls + '-dropdown';
	  },

	  filterOption: function filterOption(input, child) {
	    if (!input) {
	      return true;
	    }
	    var filterOption = this.props.filterOption;
	    if (!filterOption) {
	      return true;
	    }
	    if (child.props.disabled) {
	      return false;
	    }
	    return filterOption.call(this, input, child);
	  },

	  saveMenu: function saveMenu(menu) {
	    this.popupMenu = menu;
	  },

	  renderFilterOptions: function renderFilterOptions() {
	    return this.renderFilterOptionsFromChildren(this.props.options, true);
	  },

	  renderFilterOptionsFromChildren: function renderFilterOptionsFromChildren(children, showNotFound) {
	    var _this = this;

	    var sel = [];
	    var props = this.props;
	    var inputValue = props.inputValue;
	    var childrenKeys = [];
	    var tags = props.tags;
	    _react2['default'].Children.forEach(children, function (child) {
	      if (child.type === _OptGroup2['default']) {
	        var innerItems = _this.renderFilterOptionsFromChildren(child.props.children, false);
	        if (innerItems.length) {
	          var label = child.props.label;
	          var key = child.key;
	          if (!key && typeof label === 'string') {
	            key = label;
	          } else if (!label && key) {
	            label = key;
	          }
	          sel.push(_react2['default'].createElement(_rcMenu.ItemGroup, { key: key, title: label }, innerItems));
	        }
	        return;
	      }
	      var childValue = (0, _util.getValuePropValue)(child);
	      if (_this.filterOption(inputValue, child)) {
	        sel.push(_react2['default'].createElement(_rcMenu.Item, _extends({
	          value: childValue,
	          key: childValue
	        }, child.props)));
	      }
	      if (tags && !child.props.disabled) {
	        childrenKeys.push(childValue);
	      }
	    });
	    if (tags) {
	      // tags value must be string
	      var value = props.value;
	      value = value.filter(function (singleValue) {
	        return childrenKeys.indexOf(singleValue) === -1 && (!inputValue || singleValue.indexOf(inputValue) > -1);
	      });
	      sel = sel.concat(value.map(function (singleValue) {
	        return _react2['default'].createElement(_rcMenu.Item, { value: singleValue, key: singleValue }, singleValue);
	      }));
	      if (inputValue) {
	        var notFindInputItem = sel.every(function (option) {
	          return (0, _util.getValuePropValue)(option) !== inputValue;
	        });
	        if (notFindInputItem) {
	          sel.unshift(_react2['default'].createElement(_rcMenu.Item, { value: inputValue, key: inputValue }, inputValue));
	        }
	      }
	    }
	    if (!sel.length && showNotFound && props.notFoundContent) {
	      sel = [_react2['default'].createElement(_rcMenu.Item, { disabled: true, value: 'NOT_FOUND', key: 'NOT_FOUND' }, props.notFoundContent)];
	    }
	    return sel;
	  },

	  render: function render() {
	    var _popupClassName;

	    var props = this.props;
	    var multiple = props.multiple;
	    var dropdownPrefixCls = this.getDropdownPrefixCls();
	    var popupClassName = (_popupClassName = {}, _defineProperty(_popupClassName, props.dropdownClassName, !!props.dropdownClassName), _defineProperty(_popupClassName, dropdownPrefixCls + '--' + (multiple ? 'multiple' : 'single'), 1), _popupClassName);
	    var visible = props.visible;
	    var menuItems = undefined;
	    var search = undefined;
	    menuItems = this.renderFilterOptions();
	    search = multiple || props.combobox || !props.showSearch ? null : _react2['default'].createElement('span', { className: dropdownPrefixCls + '-search' }, props.inputElement);
	    if (!search && !menuItems.length) {
	      visible = false;
	    }
	    var popupElement = this.getDropdownElement({
	      menuItems: menuItems,
	      search: search,
	      multiple: multiple,
	      visible: visible
	    });
	    return _react2['default'].createElement(_rcTrigger2['default'], { action: props.disabled ? [] : ['click'],
	      ref: 'trigger',
	      getPopupContainer: props.getPopupContainer,
	      popupPlacement: 'bottomLeft',
	      builtinPlacements: BUILT_IN_PLACEMENTS,
	      prefixCls: dropdownPrefixCls,
	      popupTransitionName: this.getDropdownTransitionName(),
	      onPopupVisibleChange: props.onDropdownVisibleChange,
	      popup: popupElement,
	      popupVisible: visible,
	      popupClassName: (0, _classnames2['default'])(popupClassName),
	      popupStyle: props.dropdownStyle
	    }, this.props.children);
	  }
	});

	exports['default'] = SelectTrigger;
	module.exports = exports['default'];

/***/ },
/* 407 */
[759, 408],
/* 408 */
[760, 360, 409, 423],
/* 409 */
[761, 410, 382, 421, 422],
/* 410 */
[762, 411],
/* 411 */
[763, 412, 360, 420],
/* 412 */
[764, 413, 414, 415, 416, 417, 418],
/* 413 */
66,
/* 414 */
[765, 413],
/* 415 */
[766, 413, 414],
/* 416 */
[767, 413],
/* 417 */
[768, 413],
/* 418 */
[769, 419],
/* 419 */
72,
/* 420 */
73,
/* 421 */
[775, 422],
/* 422 */
84,
/* 423 */
85,
/* 424 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(4);

	var _util = __webpack_require__(391);

	var _rcMenu = __webpack_require__(392);

	var _rcMenu2 = _interopRequireDefault(_rcMenu);

	var _domScrollIntoView = __webpack_require__(395);

	var _domScrollIntoView2 = _interopRequireDefault(_domScrollIntoView);

	var DropdownMenu = _react2['default'].createClass({
	  displayName: 'DropdownMenu',

	  propTypes: {
	    prefixCls: _react2['default'].PropTypes.string,
	    menuItems: _react2['default'].PropTypes.any,
	    search: _react2['default'].PropTypes.any
	  },

	  componentDidMount: function componentDidMount() {
	    this.scrollActiveItemToView();
	  },

	  shouldComponentUpdate: function shouldComponentUpdate(nextProps) {
	    // freeze when hide
	    return nextProps.visible;
	  },

	  componentDidUpdate: function componentDidUpdate(prevProps) {
	    var props = this.props;
	    if (!prevProps.visible && props.visible) {
	      this.scrollActiveItemToView();
	    }
	  },

	  scrollActiveItemToView: function scrollActiveItemToView() {
	    // scroll into view
	    var itemComponent = (0, _reactDom.findDOMNode)(this.firstActiveItem);
	    if (itemComponent) {
	      (0, _domScrollIntoView2['default'])(itemComponent, (0, _reactDom.findDOMNode)(this.refs.menu), {
	        onlyScrollIfNeeded: true
	      });
	    }
	  },

	  renderMenu: function renderMenu() {
	    var _this = this;

	    var props = this.props;
	    var menuItems = props.menuItems;
	    var defaultActiveFirstOption = props.defaultActiveFirstOption;
	    var value = props.value;
	    var dropdownMenuStyle = props.dropdownMenuStyle;
	    var prefixCls = props.prefixCls;
	    var multiple = props.multiple;
	    var onMenuDeselect = props.onMenuDeselect;
	    var onMenuSelect = props.onMenuSelect;

	    if (menuItems && menuItems.length) {
	      var _ret = function () {
	        var menuProps = {};
	        if (multiple) {
	          menuProps.onDeselect = onMenuDeselect;
	          menuProps.onSelect = onMenuSelect;
	        } else {
	          menuProps.onClick = onMenuSelect;
	        }
	        var selectedKeys = (0, _util.getSelectKeys)(menuItems, value);
	        var activeKeyProps = {};

	        var clonedMenuItems = menuItems;
	        if (selectedKeys.length) {
	          (function () {
	            activeKeyProps.activeKey = selectedKeys[0];
	            var foundFirst = false;
	            // set firstActiveItem via cloning menus
	            // for scroll into view
	            var clone = function clone(item) {
	              if (!foundFirst && selectedKeys.indexOf(item.key) !== -1) {
	                foundFirst = true;
	                return (0, _react.cloneElement)(item, {
	                  ref: function ref(_ref) {
	                    _this.firstActiveItem = _ref;
	                  }
	                });
	              }
	              return item;
	            };

	            clonedMenuItems = menuItems.map(function (item) {
	              if (item.type === _rcMenu.ItemGroup) {
	                var children = item.props.children.map(clone);
	                return (0, _react.cloneElement)(item, {}, children);
	              }
	              return clone(item);
	            });
	          })();
	        }

	        return {
	          v: _react2['default'].createElement(_rcMenu2['default'], _extends({
	            ref: 'menu',
	            defaultActiveFirst: defaultActiveFirstOption,
	            style: dropdownMenuStyle
	          }, activeKeyProps, {
	            multiple: multiple,
	            focusable: false
	          }, menuProps, {
	            selectedKeys: selectedKeys,
	            prefixCls: prefixCls + '-menu' }), clonedMenuItems)
	        };
	      }();

	      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === 'object') return _ret.v;
	    }
	    return null;
	  },

	  render: function render() {
	    return _react2['default'].createElement('div', null, this.props.search, this.renderMenu());
	  }
	});

	exports['default'] = DropdownMenu;
	module.exports = exports['default'];

/***/ },
/* 425 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _get = function get(_x, _x2, _x3) {
	  var _again = true;_function: while (_again) {
	    var object = _x,
	        property = _x2,
	        receiver = _x3;_again = false;if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
	      var parent = Object.getPrototypeOf(object);if (parent === null) {
	        return undefined;
	      } else {
	        _x = parent;_x2 = property;_x3 = receiver;_again = true;desc = parent = undefined;continue _function;
	      }
	    } else if ('value' in desc) {
	      return desc.value;
	    } else {
	      var getter = desc.get;if (getter === undefined) {
	        return undefined;
	      }return getter.call(receiver);
	    }
	  }
	};

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError('Cannot call a class as a function');
	  }
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== 'function' && superClass !== null) {
	    throw new TypeError('Super expression must either be null or a function, not ' + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var Option = function (_React$Component) {
	  _inherits(Option, _React$Component);

	  function Option() {
	    _classCallCheck(this, Option);

	    _get(Object.getPrototypeOf(Option.prototype), 'constructor', this).apply(this, arguments);
	  }

	  return Option;
	}(_react2['default'].Component);

	exports['default'] = Option;
	module.exports = exports['default'];

/***/ },
/* 426 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var InputFormField = __webpack_require__(350);
	var Formatter = __webpack_require__(154);
	var assign = __webpack_require__(333);

	var NumberInputFormField = function (_InputFormField) {
	    _inherits(NumberInputFormField, _InputFormField);

	    function NumberInputFormField(props) {
	        _classCallCheck(this, NumberInputFormField);

	        return _possibleConstructorReturn(this, _InputFormField.call(this, props));
	    }

	    NumberInputFormField.prototype.formatValue = function formatValue(value) {
	        if (value === undefined || value === null) return "";
	        var me = this;
	        value = value + "";
	        if (me.props.jsxtype == "money") {
	            if (value.match(/\.(\d+)/) && value.match(/\.(\d+)/)[1].length > me.props.fixedNum) {
	                return Formatter.money(value, me.props.delimiter, me.props.fixedNum);
	            } else {
	                return Formatter.money(value, me.props.delimiter);
	            }
	        } else if (me.props.jsxtype == "cnmobile") {
	            return Formatter.cnmobile(value, me.props.delimiter);
	        } else if (me.props.jsxtype == "card") {
	            return Formatter.card(value, me.props.delimiter);
	        } else {
	            return value;
	        }
	    };

	    NumberInputFormField.prototype.deFormatValue = function deFormatValue(value) {
	        var me = this;
	        if (me.props.jsxtype == "money" || me.props.jsxtype == "cnmobile" || me.props.jsxtype == "card") {
	            return value.split(me.props.delimiter).join("");
	        } else {
	            return value;
	        }
	    };

	    NumberInputFormField.prototype.addSpecificClass = function addSpecificClass() {
	        var me = this;
	        if (me.props.jsxprefixCls == "kuma-uxform-field") {
	            return me.props.jsxprefixCls + " kuma-number-input-uxform-field";
	        } else {
	            return me.props.jsxprefixCls;
	        }
	    };

	    return NumberInputFormField;
	}(InputFormField);

	NumberInputFormField.displayName = "NumberInputFormField";
	NumberInputFormField.propTypes = assign({}, InputFormField.propTypes, {
	    jsxtype: React.PropTypes.string,
	    delimiter: React.PropTypes.string,
	    fixedNum: React.PropTypes.number
	});
	NumberInputFormField.defaultProps = assign({}, InputFormField.defaultProps, {
	    jsxtype: '',
	    delimiter: ' '
	});

		module.exports = NumberInputFormField;

/***/ },
/* 427 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};

	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var FormField = __webpack_require__(332);
	var Constants = __webpack_require__(222);
	var classnames = __webpack_require__(5);
	var Calendar = __webpack_require__(428);
	var assign = __webpack_require__(333);
	var update = React.addons.update;
	var deepcopy = __webpack_require__(341);

	var DateFormField = function (_FormField) {
	    _inherits(DateFormField, _FormField);

	    function DateFormField(props) {
	        _classCallCheck(this, DateFormField);

	        return _possibleConstructorReturn(this, _FormField.call(this, props));
	    }

	    DateFormField.prototype.handleChange = function handleChange(value) {
	        var me = this;
	        me.handleDataChange(new Date(value).toJSON());
	    };

	    DateFormField.prototype.handleCascadeChange = function handleCascadeChange(i, value) {
	        var me = this;
	        var values = deepcopy(me.state.value) || [];
	        values[i] = new Date(value).toJSON();
	        if (i == 0 && !!values[1] && new Date(value).getTime() > new Date(values[1]).getTime()) {
	            values.pop();
	        }
	        if (i == 1 && !!values[0] && new Date(value).getTime() < new Date(values[0]).getTime()) {
	            values[0] = undefined;
	        }
	        me.handleDataChange(values);
	    };

	    DateFormField.prototype.addSpecificClass = function addSpecificClass() {
	        var me = this;
	        if (me.props.jsxprefixCls == "kuma-uxform-field") {
	            var str = me.props.jsxprefixCls + " kuma-date-uxform-field";
	            if (me.props.jsxtype == "cascade") {
	                str += " kuma-cascade-date-uxform-field";
	            }
	            return str;
	        } else {
	            return me.props.jsxprefixCls;
	        }
	    };

	    DateFormField.prototype.renderField = function renderField() {
	        var me = this;
	        var _me$props = me.props;
	        var onSelect = _me$props.onSelect;
	        var style = _me$props.style;
	        var prefixCls = _me$props.prefixCls;
	        var value = _me$props.value;
	        var jsxtype = _me$props.jsxtype;
	        var jsxfrom = _me$props.jsxfrom;
	        var jsxto = _me$props.jsxto;
	        var disabledDate = _me$props.disabledDate;

	        var others = _objectWithoutProperties(_me$props, ['onSelect', 'style', 'prefixCls', 'value', 'jsxtype', 'jsxfrom', 'jsxto', 'disabledDate']);

	        var from = !!jsxfrom ? new Date(jsxfrom).getTime() : 0;
	        var to = !!jsxto ? new Date(jsxto).getTime() : Infinity;
	        var mode = me.props.jsxmode || me.props.mode;
	        if (mode == Constants.MODE.EDIT) {
	            if (jsxtype == "single") {
	                return React.createElement(Calendar, _extends({
	                    value: me.state.value,
	                    onSelect: me.handleChange.bind(me),
	                    disabledDate: function disabledDate(current, value) {
	                        return current.getTime() < from || current.getTime() > to;
	                    }
	                }, others));
	            } else if (jsxtype == "cascade") {
	                var arr = [];
	                var others1 = assign({}, others);
	                var others2 = assign({}, others);
	                if (me.state.value && me.state.value[0]) {
	                    others1 = assign({}, others, {
	                        value: me.state.value[0]
	                    });
	                } else {
	                    others1 = assign({}, others, {
	                        value: null
	                    });
	                }
	                if (me.state.value && me.state.value[1]) {
	                    others2 = assign({}, others, {
	                        value: me.state.value[1]
	                    });
	                } else {
	                    others2 = assign({}, others, {
	                        value: null
	                    });
	                }
	                arr.push(React.createElement(Calendar, _extends({
	                    key: 'calendar1',
	                    onSelect: me.handleCascadeChange.bind(me, 0),
	                    disabledDate: function disabledDate(current, value) {
	                        return current.getTime() < from || current.getTime() > to;
	                    }
	                }, others1)));
	                arr.push(React.createElement('span', { key: 'split', className: 'kuma-uxform-split' }, '-'));

	                arr.push(React.createElement(Calendar, _extends({
	                    key: 'calendar2',
	                    onSelect: me.handleCascadeChange.bind(me, 1),
	                    disabledDate: function disabledDate(current, value) {
	                        var now = current.getTime();
	                        var first = me.state.value ? me.state.value[0] : 0;
	                        first = new Date(first).getTime();
	                        return now < from || now > to || now < first;
	                    }
	                }, others2)));
	                return arr;
	            }
	        } else if (mode == Constants.MODE.VIEW) {
	            if (jsxtype == "single") {
	                return React.createElement('span', null, me.state.value);
	            } else {
	                return React.createElement('span', null, !!me.state.value ? me.state.value.join(" - ") : "");
	            }
	        }
	    };

	    return DateFormField;
	}(FormField);

	DateFormField.displayName = "DateFormField";
	DateFormField.propTypes = assign(FormField.propTypes, {
	    jsxtype: React.PropTypes.string
	});
	DateFormField.defaultProps = assign(FormField.defaultProps, {
	    locale: 'zh-cn',
	    hasTrigger: true,
	    jsxtype: "single"
	});
		module.exports = DateFormField;

/***/ },
/* 428 */
[746, 429],
/* 429 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var RcCalendar = __webpack_require__(430);
	var Datepicker = __webpack_require__(485);
	var GregorianCalendar = __webpack_require__(434);
	var DateTimeFormat = __webpack_require__(432);
	var RcMonthCalendar = __webpack_require__(484);
	var RcYearCalendar = __webpack_require__(486);
	var classSet = __webpack_require__(439).classSet;
	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var defaultValueLocale = {};
	var CalendarLocale = {};
	defaultValueLocale['zh-cn'] = __webpack_require__(487);
	defaultValueLocale['en-us'] = __webpack_require__(437);
	CalendarLocale['zh-cn'] = __webpack_require__(488);
	CalendarLocale['en-us'] = __webpack_require__(463);

	function getGregorianCalendarDate(date, locale) {
	    defaultValueLocale[locale].timezoneOffset = -new Date().getTimezoneOffset();
	    var value = new GregorianCalendar(defaultValueLocale[locale]);
	    value.setTime(new Date(date).valueOf());
	    return value;
	}

	function getCalendarContainer() {
	    var c = document.createElement('div');
	    c.className = 'uxcore';
	    document.body.appendChild(c);
	    return c;
	}

	var Calendar = function (_React$Component) {
	    _inherits(Calendar, _React$Component);

	    function Calendar(props) {
	        _classCallCheck(this, Calendar);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.state = {};
	        return _this;
	    }

	    Calendar.prototype.render = function render() {
	        var me = this;
	        var p = me.props;
	        var formatter = new DateTimeFormat(p.format);
	        var calendarOptions = {
	            className: p.className,
	            style: p.style,
	            disabledDate: p.disabledDate,
	            showWeekNumber: p.showWeekNumber,
	            showToday: p.showToday,
	            showTime: p.showTime,
	            locale: CalendarLocale[p.locale],
	            orient: ['top', 'left'],
	            prefixCls: 'kuma-calendar'
	        };
	        var pickerOptions = {
	            disabled: p.disabled,
	            formatter: formatter,
	            adjustOrientOnCalendarOverflow: false,
	            prefixCls: 'kuma-calendar-picker',
	            getCalendarContainer: getCalendarContainer
	        };

	        if (p.value) {
	            var value = getGregorianCalendarDate(p.value, p.locale);
	            pickerOptions.value = calendarOptions.value = value;
	        } else {
	            pickerOptions.value = calendarOptions.value = null;
	        }

	        if (p.defaultValue) {
	            var value = getGregorianCalendarDate(p.defaultValue, p.locale);
	            calendarOptions.defaultValue = value;
	            pickerOptions.defaultValue = value;
	        } else {
	            var value = getGregorianCalendarDate(new Date().getTime(), p.locale);
	            calendarOptions.defaultValue = value;
	        }
	        if (p.hasTrigger) {
	            pickerOptions.trigger = React.createElement('i', { className: 'kuma-icon kuma-icon-calender' });
	        }

	        var calendar = React.createElement(RcCalendar, calendarOptions);

	        function _onChange(v) {
	            var date = v.getTime();
	            var value = getGregorianCalendarDate(date, p.locale);
	            this.props.onSelect(new Date(date), formatter.format(value));
	        }

	        return React.createElement(Datepicker, _extends({
	            calendar: calendar,
	            onChange: _onChange.bind(me)
	        }, pickerOptions), React.createElement('input', { disabled: me.props.disabled, placeholder: this.props.placeholder, className: 'kuma-calendar-picker-input kuma-input' }));
	    };

	    return Calendar;
	}(React.Component);

	Calendar.displayName = 'Calendar';
	Calendar.defaultProps = {
	    format: 'yyyy-MM-dd',
	    placeholder: '请选择日期',
	    onSelect: function onSelect() {},
	    locale: 'zh-cn',
	    hasTrigger: false
	};
	Calendar.propTypes = {
	    format: React.PropTypes.string,
	    placeholder: React.PropTypes.string,
	    onSelect: React.PropTypes.func,
	    locale: React.PropTypes.string,
	    hasTrigger: React.PropTypes.bool
	};

	var MonthCalendar = function (_React$Component2) {
	    _inherits(MonthCalendar, _React$Component2);

	    function MonthCalendar(props) {
	        _classCallCheck(this, MonthCalendar);

	        var _this2 = _possibleConstructorReturn(this, _React$Component2.call(this, props));

	        _this2.state = {};
	        return _this2;
	    }

	    MonthCalendar.prototype.render = function render() {
	        var me = this;
	        var p = me.props;
	        var formatter = new DateTimeFormat(p.format);
	        var calendarOptions = {
	            className: p.className,
	            style: p.style,
	            locale: CalendarLocale[p.locale],
	            orient: ['top', 'left'],
	            prefixCls: 'kuma-calendar'
	        };
	        var pickerOptions = {
	            disabled: p.disabled,
	            formatter: formatter,
	            adjustOrientOnCalendarOverflow: false,
	            prefixCls: 'kuma-calendar-picker',
	            getCalendarContainer: getCalendarContainer
	        };

	        if (p.value) {
	            var value = getGregorianCalendarDate(p.value, p.locale);
	            pickerOptions.value = calendarOptions.value = value;
	        } else {
	            pickerOptions.value = calendarOptions.value = null;
	        }

	        if (p.defaultValue) {
	            var value = getGregorianCalendarDate(p.defaultValue, p.locale);
	            calendarOptions.defaultValue = value;
	        }
	        var calendar = React.createElement(RcMonthCalendar, calendarOptions);

	        function _onChange(v) {
	            var date = v.getTime();
	            var value = getGregorianCalendarDate(date, p.locale);
	            this.props.onSelect(new Date(date), formatter.format(value));
	        }

	        return React.createElement(Datepicker, _extends({
	            calendar: calendar,
	            onChange: _onChange.bind(me)
	        }, pickerOptions), React.createElement('input', { disabled: me.props.disabled, placeholder: this.props.placeholder, className: 'kuma-calendar-picker-input kuma-input' }));
	    };

	    return MonthCalendar;
	}(React.Component);

	MonthCalendar.displayName = 'MonthCalendar';
	MonthCalendar.defaultProps = {
	    format: 'yyyy-MM',
	    placeholder: '请选择月份',
	    onSelect: function onSelect() {},
	    locale: 'zh-cn'
	};
	MonthCalendar.propTypes = {
	    format: React.PropTypes.string,
	    placeholder: React.PropTypes.string,
	    onSelect: React.PropTypes.func,
	    locale: React.PropTypes.string
	};

	var YearCalendar = function (_React$Component3) {
	    _inherits(YearCalendar, _React$Component3);

	    function YearCalendar(props) {
	        _classCallCheck(this, YearCalendar);

	        var _this3 = _possibleConstructorReturn(this, _React$Component3.call(this, props));

	        _this3.state = {};
	        return _this3;
	    }

	    YearCalendar.prototype.render = function render() {
	        var me = this;
	        var p = me.props;
	        var formatter = new DateTimeFormat(p.format);
	        var calendarOptions = {
	            className: p.className,
	            style: p.style,
	            locale: CalendarLocale[p.locale],
	            orient: ['top', 'left'],
	            prefixCls: 'kuma-calendar'
	        };
	        var pickerOptions = {
	            disabled: p.disabled,
	            formatter: formatter,
	            adjustOrientOnCalendarOverflow: false,
	            prefixCls: 'kuma-calendar-picker',
	            getCalendarContainer: getCalendarContainer
	        };

	        if (p.value) {
	            var value = getGregorianCalendarDate(p.value, p.locale);
	            pickerOptions.value = calendarOptions.value = value;
	        } else {
	            pickerOptions.value = calendarOptions.value = null;
	        }

	        if (p.defaultValue) {
	            var value = getGregorianCalendarDate(p.defaultValue, p.locale);
	            calendarOptions.defaultValue = value;
	        }
	        var calendar = React.createElement(RcYearCalendar, calendarOptions);

	        function _onChange(v) {
	            var date = v.getTime();
	            var value = getGregorianCalendarDate(date, p.locale);
	            this.props.onSelect(new Date(date), formatter.format(value));
	        }

	        return React.createElement(Datepicker, _extends({
	            calendar: calendar,
	            onChange: _onChange.bind(me)
	        }, pickerOptions), React.createElement('input', { disabled: me.props.disabled, placeholder: this.props.placeholder, className: 'kuma-calendar-picker-input kuma-input' }));
	    };

	    return YearCalendar;
	}(React.Component);

	YearCalendar.displayName = 'YearCalendar';
	YearCalendar.defaultProps = {
	    format: 'yyyy',
	    placeholder: '请选择年份',
	    onSelect: function onSelect() {},
	    locale: 'zh-cn'
	};
	YearCalendar.propTypes = {
	    format: React.PropTypes.string,
	    placeholder: React.PropTypes.string,
	    onSelect: React.PropTypes.func,
	    locale: React.PropTypes.string
	};

	Calendar.MonthCalendar = MonthCalendar;
	Calendar.YearCalendar = YearCalendar;

	module.exports = Calendar;

/***/ },
/* 430 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _Calendar = __webpack_require__(431);

	var _Calendar2 = _interopRequireDefault(_Calendar);

	var _Picker = __webpack_require__(464);

	var _Picker2 = _interopRequireDefault(_Picker);

	var _MonthCalendar = __webpack_require__(484);

	var _MonthCalendar2 = _interopRequireDefault(_MonthCalendar);

	_Calendar2['default'].Picker = _Picker2['default'];
	_Calendar2['default'].MonthCalendar = _MonthCalendar2['default'];

	exports['default'] = _Calendar2['default'];
	module.exports = exports['default'];

/***/ },
/* 431 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _gregorianCalendarFormat = __webpack_require__(432);

	var _gregorianCalendarFormat2 = _interopRequireDefault(_gregorianCalendarFormat);

	var _gregorianCalendar = __webpack_require__(434);

	var _gregorianCalendar2 = _interopRequireDefault(_gregorianCalendar);

	var _rcUtil = __webpack_require__(439);

	var _dateDateTable = __webpack_require__(451);

	var _dateDateTable2 = _interopRequireDefault(_dateDateTable);

	var _calendarCalendarHeader = __webpack_require__(455);

	var _calendarCalendarHeader2 = _interopRequireDefault(_calendarCalendarHeader);

	var _calendarCalendarFooter = __webpack_require__(459);

	var _calendarCalendarFooter2 = _interopRequireDefault(_calendarCalendarFooter);

	var _mixinCalendarMixin = __webpack_require__(462);

	var _mixinCalendarMixin2 = _interopRequireDefault(_mixinCalendarMixin);

	function noop() {}

	function goStartMonth() {
	  var next = this.state.value.clone();
	  next.setDayOfMonth(1);
	  this.setValue(next);
	}

	function goEndMonth() {
	  var next = this.state.value.clone();
	  next.setDayOfMonth(next.getActualMaximum(_gregorianCalendar2['default'].MONTH));
	  this.setValue(next);
	}

	function goMonth(direction) {
	  var next = this.state.value.clone();
	  next.addMonth(direction);
	  this.setValue(next);
	}

	function goYear(direction) {
	  var next = this.state.value.clone();
	  next.addYear(direction);
	  this.setValue(next);
	}

	function goWeek(direction) {
	  var next = this.state.value.clone();
	  next.addWeekOfYear(direction);
	  this.setValue(next);
	}

	function goDay(direction) {
	  var next = this.state.value.clone();
	  next.addDayOfMonth(direction);
	  this.setValue(next);
	}

	var Calendar = _react2['default'].createClass({
	  displayName: 'Calendar',

	  mixins: [_mixinCalendarMixin2['default']],

	  propTypes: {
	    value: _react2['default'].PropTypes.object,
	    defaultValue: _react2['default'].PropTypes.object,
	    className: _react2['default'].PropTypes.string,
	    orient: _react2['default'].PropTypes.arrayOf(_react2['default'].PropTypes.oneOf(['left', 'top', 'right', 'bottom'])),
	    locale: _react2['default'].PropTypes.object,
	    showWeekNumber: _react2['default'].PropTypes.bool,
	    style: _react2['default'].PropTypes.object,
	    showToday: _react2['default'].PropTypes.bool,
	    visible: _react2['default'].PropTypes.bool,
	    showTime: _react2['default'].PropTypes.bool,
	    onSelect: _react2['default'].PropTypes.func,
	    onOk: _react2['default'].PropTypes.func,
	    prefixCls: _react2['default'].PropTypes.string,
	    onKeyDown: _react2['default'].PropTypes.func,
	    onClear: _react2['default'].PropTypes.func,
	    onChange: _react2['default'].PropTypes.func,
	    onFocus: _react2['default'].PropTypes.func,
	    onBlur: _react2['default'].PropTypes.func
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      showToday: true,
	      onClear: noop,
	      onOk: noop
	    };
	  },

	  getInitialState: function getInitialState() {
	    var props = this.props;
	    this.dateFormatter = new _gregorianCalendarFormat2['default'](props.locale.dateFormat);
	    var orient = props.orient;
	    // bind methods
	    this.nextMonth = goMonth.bind(this, 1);
	    this.previousMonth = goMonth.bind(this, -1);
	    this.nextYear = goYear.bind(this, 1);
	    this.previousYear = goYear.bind(this, -1);
	    return { orient: orient };
	  },

	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    if (nextProps.orient) {
	      this.setState({
	        orient: nextProps.orient
	      });
	    }
	    if (nextProps.locale !== this.props.locale) {
	      this.dateFormatter = new _gregorianCalendarFormat2['default'](nextProps.locale.dateFormat);
	    }
	  },

	  onKeyDown: function onKeyDown(e) {
	    var keyCode = e.keyCode;
	    // mac
	    var ctrlKey = e.ctrlKey || e.metaKey;
	    switch (keyCode) {
	      case _rcUtil.KeyCode.DOWN:
	        goWeek.call(this, 1);
	        e.preventDefault();
	        return 1;
	      case _rcUtil.KeyCode.UP:
	        goWeek.call(this, -1);
	        e.preventDefault();
	        return 1;
	      case _rcUtil.KeyCode.LEFT:
	        if (ctrlKey) {
	          this.previousYear();
	        } else {
	          goDay.call(this, -1);
	        }
	        e.preventDefault();
	        return 1;
	      case _rcUtil.KeyCode.RIGHT:
	        if (ctrlKey) {
	          this.nextYear();
	        } else {
	          goDay.call(this, 1);
	        }
	        e.preventDefault();
	        return 1;
	      case _rcUtil.KeyCode.HOME:
	        goStartMonth.call(this);
	        e.preventDefault();
	        return 1;
	      case _rcUtil.KeyCode.END:
	        goEndMonth.call(this);
	        e.preventDefault();
	        return 1;
	      case _rcUtil.KeyCode.PAGE_DOWN:
	        this.nextMonth();
	        e.preventDefault();
	        return 1;
	      case _rcUtil.KeyCode.PAGE_UP:
	        this.previousMonth();
	        e.preventDefault();
	        return 1;
	      case _rcUtil.KeyCode.ENTER:
	        this.onSelect(this.state.value);
	        e.preventDefault();
	        return 1;
	      default:
	        this.props.onKeyDown(e);
	        return 1;
	    }
	  },

	  onClear: function onClear() {
	    this.props.onClear();
	  },

	  onOk: function onOk() {
	    this.props.onOk(this.state.value);
	  },

	  render: function render() {
	    var props = this.props;
	    var locale = props.locale;
	    var state = this.state;
	    var value = state.value;
	    var prefixCls = props.prefixCls;
	    var children = _react2['default'].createElement('div', { style: { outline: 'none' } }, _react2['default'].createElement(_calendarCalendarHeader2['default'], {
	      locale: locale,
	      onValueChange: this.setValue,
	      previousYear: this.previousYear,
	      previousMonth: this.previousMonth,
	      nextMonth: this.nextMonth,
	      nextYear: this.nextYear,
	      value: value,
	      prefixCls: prefixCls }), _react2['default'].createElement('div', { className: prefixCls + '-calendar-body' }, _react2['default'].createElement(_dateDateTable2['default'], {
	      locale: locale,
	      value: value,
	      prefixCls: prefixCls,
	      dateRender: props.dateRender,
	      onSelect: this.onSelect,
	      disabledDate: props.disabledDate,
	      showWeekNumber: props.showWeekNumber,
	      dateFormatter: this.dateFormatter })), _react2['default'].createElement(_calendarCalendarFooter2['default'], {
	      locale: locale,
	      showClear: props.showClear,
	      showOk: props.showOk,
	      prefixCls: prefixCls,
	      showToday: props.showToday,
	      showTime: props.showTime,
	      value: value,
	      disabledDate: props.disabledDate,
	      dateFormatter: this.dateFormatter,
	      onClear: this.onClear,
	      onOk: this.onOk,
	      onSelect: this.onSelect,
	      onToday: this.chooseToday
	    }));

	    return this.renderRoot({
	      children: children,
	      className: props.showWeekNumber ? prefixCls + '-week-number' : ''
	    });
	  },

	  chooseToday: function chooseToday() {
	    var today = this.state.value.clone();
	    today.setTime(Date.now());
	    this.onSelect(today);
	  }
	});

	exports['default'] = Calendar;
	module.exports = exports['default'];

/***/ },
/* 432 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

		module.exports = __webpack_require__(433);

/***/ },
/* 433 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * @ignore
	 * DateTimeFormat for
	 * Inspired by DateTimeFormat from JDK.
	 * @author yiminghe@gmail.com
	 */

	var GregorianCalendar = __webpack_require__(434);
	var enUsLocale = __webpack_require__(438);
	var MAX_VALUE = Number.MAX_VALUE;
	/**
	 * date or time style enum
	 * @enum {Number} Date.Formatter.Style
	 */
	var DateTimeStyle = {
	  /**
	   * full style
	   */
	  FULL: 0,
	  /**
	   * long style
	   */
	  LONG: 1,
	  /**
	   * medium style
	   */
	  MEDIUM: 2,
	  /**
	   * short style
	   */
	  SHORT: 3
	};

	/*
	 Letter    Date or Time Component    Presentation    Examples
	 G    Era designator    Text    AD
	 y    Year    Year    1996; 96
	 M    Month in year    Month    July; Jul; 07
	 w    Week in year    Number    27
	 W    Week in month    Number    2
	 D    Day in year    Number    189
	 d    Day in month    Number    10
	 F    Day of week in month    Number    2
	 E    Day in week    Text    Tuesday; Tue
	 a    Am/pm marker    Text    PM
	 H    Hour in day (0-23)    Number    0
	 k    Hour in day (1-24)    Number    24
	 K    Hour in am/pm (0-11)    Number    0
	 h    Hour in am/pm (1-12)    Number    12
	 m    Minute in hour    Number    30
	 s    Second in minute    Number    55
	 S    Millisecond    Number    978
	 x z    Time zone    General time zone    Pacific Standard Time; PST; GMT-08:00
	 Z    Time zone    RFC 822 time zone    -0800
	 */

	var patternChars = new Array(GregorianCalendar.DAY_OF_WEEK_IN_MONTH + 2).join('1');
	var ERA = 0;
	var calendarIndexMap = {};

	patternChars = patternChars.split('');
	patternChars[ERA] = 'G';
	patternChars[GregorianCalendar.YEAR] = 'y';
	patternChars[GregorianCalendar.MONTH] = 'M';
	patternChars[GregorianCalendar.DAY_OF_MONTH] = 'd';
	patternChars[GregorianCalendar.HOUR_OF_DAY] = 'H';
	patternChars[GregorianCalendar.MINUTES] = 'm';
	patternChars[GregorianCalendar.SECONDS] = 's';
	patternChars[GregorianCalendar.MILLISECONDS] = 'S';
	patternChars[GregorianCalendar.WEEK_OF_YEAR] = 'w';
	patternChars[GregorianCalendar.WEEK_OF_MONTH] = 'W';
	patternChars[GregorianCalendar.DAY_OF_YEAR] = 'D';
	patternChars[GregorianCalendar.DAY_OF_WEEK_IN_MONTH] = 'F';

	(function () {
	  for (var index in patternChars) {
	    calendarIndexMap[patternChars[index]] = index;
	  }
	})();

	function mix(t, s) {
	  for (var p in s) {
	    t[p] = s[p];
	  }
	}

	var SUBSTITUTE_REG = /\\?\{([^{}]+)\}/g;
	var EMPTY = '';

	function substitute(str, o, regexp) {
	  if (typeof str !== 'string' || !o) {
	    return str;
	  }

	  return str.replace(regexp || SUBSTITUTE_REG, function (match, name) {
	    if (match.charAt(0) === '\\') {
	      return match.slice(1);
	    }
	    return o[name] === undefined ? EMPTY : o[name];
	  });
	}

	patternChars = patternChars.join('') + 'ahkKZE';

	function encode(lastField, count, compiledPattern) {
	  compiledPattern.push({
	    field: lastField,
	    count: count
	  });
	}

	function compile(pattern) {
	  var length = pattern.length;
	  var inQuote = false;
	  var compiledPattern = [];
	  var tmpBuffer = null;
	  var count = 0;
	  var lastField = -1;

	  for (var i = 0; i < length; i++) {
	    var c = pattern.charAt(i);

	    if (c === '\'') {
	      // '' is treated as a single quote regardless of being
	      // in a quoted section.
	      if (i + 1 < length) {
	        c = pattern.charAt(i + 1);
	        if (c === '\'') {
	          i++;
	          if (count !== 0) {
	            encode(lastField, count, compiledPattern);
	            lastField = -1;
	            count = 0;
	          }
	          if (inQuote) {
	            tmpBuffer += c;
	          }
	          continue;
	        }
	      }
	      if (!inQuote) {
	        if (count !== 0) {
	          encode(lastField, count, compiledPattern);
	          lastField = -1;
	          count = 0;
	        }
	        tmpBuffer = '';
	        inQuote = true;
	      } else {
	        compiledPattern.push({
	          text: tmpBuffer
	        });
	        inQuote = false;
	      }
	      continue;
	    }
	    if (inQuote) {
	      tmpBuffer += c;
	      continue;
	    }
	    if (!(c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z')) {
	      if (count !== 0) {
	        encode(lastField, count, compiledPattern);
	        lastField = -1;
	        count = 0;
	      }
	      compiledPattern.push({
	        text: c
	      });
	      continue;
	    }

	    if (patternChars.indexOf(c) === -1) {
	      throw new Error('Illegal pattern character "' + c + '"');
	    }

	    if (lastField === -1 || lastField === c) {
	      lastField = c;
	      count++;
	      continue;
	    }
	    encode(lastField, count, compiledPattern);
	    lastField = c;
	    count = 1;
	  }

	  if (inQuote) {
	    throw new Error('Unterminated quote');
	  }

	  if (count !== 0) {
	    encode(lastField, count, compiledPattern);
	  }

	  return compiledPattern;
	}

	var zeroDigit = '0';

	// TODO zeroDigit localization??
	function zeroPaddingNumber(value, minDigits, maxDigits, buffer) {
	  // Optimization for 1, 2 and 4 digit numbers. This should
	  // cover most cases of formatting date/time related items.
	  // Note: This optimization code assumes that maxDigits is
	  // either 2 or Integer.MAX_VALUE (maxIntCount in format()).
	  buffer = buffer || [];
	  maxDigits = maxDigits || MAX_VALUE;
	  if (value >= 0) {
	    if (value < 100 && minDigits >= 1 && minDigits <= 2) {
	      if (value < 10 && minDigits === 2) {
	        buffer.push(zeroDigit);
	      }
	      buffer.push(value);
	      return buffer.join('');
	    } else if (value >= 1000 && value < 10000) {
	      if (minDigits === 4) {
	        buffer.push(value);
	        return buffer.join('');
	      }
	      if (minDigits === 2 && maxDigits === 2) {
	        return zeroPaddingNumber(value % 100, 2, 2, buffer);
	      }
	    }
	  }
	  buffer.push(value + '');
	  return buffer.join('');
	}

	/**
	 *
	 * date time formatter for GregorianCalendar
	 *
	 *      @example
	 *
	 *          var calendar = new GregorianCalendar(2013,9,24);
	 *          // ' to escape
	 *          var formatter = new GregorianCalendarFormat("'today is' ''yyyy/MM/dd a''");
	 *          document.write(formatter.format(calendar));
	 *
	 * @class GregorianCalendarFormat
	 * @param {String} pattern patter string of date formatter
	 *
	 * <table border="1">
	 * <thead valign="bottom">
	 * <tr><th class="head">Letter</th>
	 * <th class="head">Date or Time Component</th>
	 * <th class="head">Presentation</th>
	 * <th class="head">Examples</th>
	 * </tr>
	 * </thead>
	 * <tbody valign="top">
	 * <tr><td>G</td>
	 * <td>Era designator</td>
	 * <td>Text</td>
	 * <td>AD</td>
	 * </tr>
	 * <tr><td>y</td>
	 * <td>Year</td>
	 * <td>Year</td>
	 * <td>1996; 96</td>
	 * </tr>
	 * <tr><td>M</td>
	 * <td>Month in year</td>
	 * <td>Month</td>
	 * <td>July; Jul; 07</td>
	 * </tr>
	 * <tr><td>w</td>
	 * <td>Week in year</td>
	 * <td>Number</td>
	 * <td>27</td>
	 * </tr>
	 * <tr><td>W</td>
	 * <td>Week in month</td>
	 * <td>Number</td>
	 * <td>2</td>
	 * </tr>
	 * <tr><td>D</td>
	 * <td>Day in year</td>
	 * <td>Number</td>
	 * <td>189</td>
	 * </tr>
	 * <tr><td>d</td>
	 * <td>Day in month</td>
	 * <td>Number</td>
	 * <td>10</td>
	 * </tr>
	 * <tr><td>F</td>
	 * <td>Day of week in month</td>
	 * <td>Number</td>
	 * <td>2</td>
	 * </tr>
	 * <tr><td>E</td>
	 * <td>Day in week</td>
	 * <td>Text</td>
	 * <td>Tuesday; Tue</td>
	 * </tr>
	 * <tr><td>a</td>
	 * <td>Am/pm marker</td>
	 * <td>Text</td>
	 * <td>PM</td>
	 * </tr>
	 * <tr><td>H</td>
	 *       <td>Hour in day (0-23)</td>
	 * <td>Number</td>
	 * <td>0</td>
	 * </tr>
	 * <tr><td>k</td>
	 *       <td>Hour in day (1-24)</td>
	 * <td>Number</td>
	 * <td>24</td>
	 * </tr>
	 * <tr><td>K</td>
	 * <td>Hour in am/pm (0-11)</td>
	 * <td>Number</td>
	 * <td>0</td>
	 * </tr>
	 * <tr><td>h</td>
	 * <td>Hour in am/pm (1-12)</td>
	 * <td>Number</td>
	 * <td>12</td>
	 * </tr>
	 * <tr><td>m</td>
	 * <td>Minute in hour</td>
	 * <td>Number</td>
	 * <td>30</td>
	 * </tr>
	 * <tr><td>s</td>
	 * <td>Second in minute</td>
	 * <td>Number</td>
	 * <td>55</td>
	 * </tr>
	 * <tr><td>S</td>
	 * <td>Millisecond</td>
	 * <td>Number</td>
	 * <td>978</td>
	 * </tr>
	 * <tr><td>x/z</td>
	 * <td>Time zone</td>
	 * <td>General time zone</td>
	 * <td>Pacific Standard Time; PST; GMT-08:00</td>
	 * </tr>
	 * <tr><td>Z</td>
	 * <td>Time zone</td>
	 * <td>RFC 822 time zone</td>
	 * <td>-0800</td>
	 * </tr>
	 * </tbody>
	 * </table>

	 * @param {Object} locale format locale
	 */
	function DateTimeFormat(pattern, locale) {
	  this.locale = locale || enUsLocale;
	  this.originalPattern = pattern;
	  this.pattern = compile(pattern);
	}

	function formatField(field, count, locale, calendar) {
	  var current, value;
	  switch (field) {
	    case 'G':
	      value = calendar.getYear() > 0 ? 1 : 0;
	      current = locale.eras[value];
	      break;
	    case 'y':
	      value = calendar.getYear();
	      if (value <= 0) {
	        value = 1 - value;
	      }
	      current = zeroPaddingNumber(value, 2, count !== 2 ? MAX_VALUE : 2);
	      break;
	    case 'M':
	      value = calendar.getMonth();
	      if (count >= 4) {
	        current = locale.months[value];
	      } else if (count === 3) {
	        current = locale.shortMonths[value];
	      } else {
	        current = zeroPaddingNumber(value + 1, count);
	      }
	      break;
	    case 'k':
	      current = zeroPaddingNumber(calendar.getHourOfDay() || 24, count);
	      break;
	    case 'E':
	      value = calendar.getDayOfWeek();
	      current = count >= 4 ? locale.weekdays[value] : locale.shortWeekdays[value];
	      break;
	    case 'a':
	      current = locale.ampms[calendar.getHourOfDay() >= 12 ? 1 : 0];
	      break;
	    case 'h':
	      current = zeroPaddingNumber(calendar.getHourOfDay() % 12 || 12, count);
	      break;
	    case 'K':
	      current = zeroPaddingNumber(calendar.getHourOfDay() % 12, count);
	      break;
	    case 'Z':
	      var offset = calendar.getTimezoneOffset();
	      var parts = [offset < 0 ? '-' : '+'];
	      offset = Math.abs(offset);
	      parts.push(zeroPaddingNumber(Math.floor(offset / 60) % 100, 2), zeroPaddingNumber(offset % 60, 2));
	      current = parts.join('');
	      break;
	    default:
	      // case 'd':
	      // case 'H':
	      // case 'm':
	      // case 's':
	      // case 'S':
	      // case 'D':
	      // case 'F':
	      // case 'w':
	      // case 'W':
	      var index = calendarIndexMap[field];
	      value = calendar.get(index);
	      current = zeroPaddingNumber(value, count);
	  }
	  return current;
	}

	function matchField(dateStr, startIndex, matches) {
	  var matchedLen = -1;
	  var index = -1;
	  var i;
	  var len = matches.length;
	  for (i = 0; i < len; i++) {
	    var m = matches[i];
	    var mLen = m.length;
	    if (mLen > matchedLen && matchPartString(dateStr, startIndex, m, mLen)) {
	      matchedLen = mLen;
	      index = i;
	    }
	  }
	  return index >= 0 ? {
	    value: index,
	    startIndex: startIndex + matchedLen
	  } : null;
	}

	function matchPartString(dateStr, startIndex, match, mLen) {
	  for (var i = 0; i < mLen; i++) {
	    if (dateStr.charAt(startIndex + i) !== match.charAt(i)) {
	      return false;
	    }
	  }
	  return true;
	}

	function getLeadingNumberLen(str) {
	  var i, c;
	  var len = str.length;
	  for (i = 0; i < len; i++) {
	    c = str.charAt(i);
	    if (c < '0' || c > '9') {
	      break;
	    }
	  }
	  return i;
	}

	function matchNumber(dateStr, startIndex, count, obeyCount) {
	  var str = dateStr;
	  var n;
	  if (obeyCount) {
	    if (dateStr.length <= startIndex + count) {
	      return null;
	    }
	    str = dateStr.slice(startIndex, startIndex + count);
	    if (!str.match(/^\d+$/)) {
	      throw new Error('GregorianCalendarFormat parse error, dateStr: ' + dateStr + ', patter: ' + this.originalPattern);
	    }
	  } else {
	    str = str.slice(startIndex);
	  }
	  n = parseInt(str, 10);
	  if (isNaN(n)) {
	    throw new Error('GregorianCalendarFormat parse error, dateStr: ' + dateStr + ', patter: ' + this.originalPattern);
	  }
	  return {
	    value: n,
	    startIndex: startIndex + getLeadingNumberLen(str)
	  };
	}

	function parseField(calendar, dateStr, startIndex, field, count, obeyCount, tmp) {
	  var match, year, hour;
	  if (dateStr.length <= startIndex) {
	    return startIndex;
	  }
	  var locale = this.locale;
	  switch (field) {
	    case 'G':
	      if (match = matchField(dateStr, startIndex, locale.eras)) {
	        if (calendar.isSetYear()) {
	          if (match.value === 0) {
	            year = calendar.getYear();
	            calendar.setYear(1 - year);
	          }
	        } else {
	          tmp.era = match.value;
	        }
	      }
	      break;
	    case 'y':
	      if (match = matchNumber.call(this, dateStr, startIndex, count, obeyCount)) {
	        year = match.value;
	        if ('era' in tmp) {
	          if (tmp.era === 0) {
	            year = 1 - year;
	          }
	        }
	        calendar.setYear(year);
	      }
	      break;
	    case 'M':
	      var month;
	      if (count >= 3) {
	        if (match = matchField(dateStr, startIndex, locale[count === 3 ? 'shortMonths' : 'months'])) {
	          month = match.value;
	        }
	      } else {
	        if (match = matchNumber.call(this, dateStr, startIndex, count, obeyCount)) {
	          month = match.value - 1;
	        }
	      }
	      if (match) {
	        calendar.setMonth(month);
	      }
	      break;
	    case 'k':
	      if (match = matchNumber.call(this, dateStr, startIndex, count, obeyCount)) {
	        calendar.setHourOfDay(match.value % 24);
	      }
	      break;
	    case 'E':
	      if (match = matchField(dateStr, startIndex, locale[count > 3 ? 'weekdays' : 'shortWeekdays'])) {
	        calendar.setDayOfWeek(match.value);
	      }
	      break;
	    case 'a':
	      if (match = matchField(dateStr, startIndex, locale.ampms)) {
	        if (calendar.isSetHourOfDay()) {
	          if (match.value) {
	            hour = calendar.getHourOfDay();
	            if (hour < 12) {
	              calendar.setHourOfDay((hour + 12) % 24);
	            }
	          }
	        } else {
	          tmp.ampm = match.value;
	        }
	      }
	      break;
	    case 'h':
	      if (match = matchNumber.call(this, dateStr, startIndex, count, obeyCount)) {
	        hour = match.value %= 12;
	        if (tmp.ampm) {
	          hour += 12;
	        }
	        calendar.setHourOfDay(hour);
	      }
	      break;
	    case 'K':
	      if (match = matchNumber.call(this, dateStr, startIndex, count, obeyCount)) {
	        hour = match.value;
	        if (tmp.ampm) {
	          hour += 12;
	        }
	        calendar.setHourOfDay(hour);
	      }
	      break;
	    case 'Z':
	      var sign = 1;
	      var zoneChar = dateStr.charAt(startIndex);
	      if (zoneChar === '-') {
	        sign = -1;
	        startIndex++;
	      } else if (zoneChar === '+') {
	        startIndex++;
	      } else {
	        break;
	      }
	      if (match = matchNumber.call(this, dateStr, startIndex, 2, true)) {
	        var zoneOffset = match.value * 60;
	        startIndex = match.startIndex;
	        if (match = matchNumber.call(this, dateStr, startIndex, 2, true)) {
	          zoneOffset += match.value;
	        }
	        calendar.setTimezoneOffset(zoneOffset);
	      }
	      break;
	    default:
	      // case 'd':
	      // case 'H':
	      // case 'm':
	      // case 's':
	      // case 'S':
	      // case 'D':
	      // case 'F':
	      // case 'w':
	      // case 'W'
	      if (match = matchNumber.call(this, dateStr, startIndex, count, obeyCount)) {
	        var index = calendarIndexMap[field];
	        calendar.set(index, match.value);
	      }
	  }
	  if (match) {
	    startIndex = match.startIndex;
	  }
	  return startIndex;
	}

	mix(DateTimeFormat.prototype, {
	  /**
	   * format a GregorianDate instance according to specified pattern
	   * @param {GregorianCalendar} calendar GregorianDate instance
	   * @returns {string} formatted string of GregorianDate instance
	   */
	  format: function format(calendar) {
	    if (!calendar.isGregorianCalendar) {
	      throw new Error('calendar must be type of GregorianCalendar');
	    }
	    var i;
	    var ret = [];
	    var pattern = this.pattern;
	    var len = pattern.length;
	    for (i = 0; i < len; i++) {
	      var comp = pattern[i];
	      if (comp.text) {
	        ret.push(comp.text);
	      } else if ('field' in comp) {
	        ret.push(formatField(comp.field, comp.count, this.locale, calendar));
	      }
	    }
	    return ret.join('');
	  },

	  /**
	   * parse a formatted string of GregorianDate instance according to specified pattern
	   * @param {String} dateStr formatted string of GregorianDate
	   * @returns {GregorianCalendar}
	   */
	  parse: function parse(dateStr, calendarLocale) {
	    var calendar = new GregorianCalendar(calendarLocale);
	    var i;
	    var j;
	    var tmp = {};
	    var obeyCount = false;
	    var dateStrLen = dateStr.length;
	    var errorIndex = -1;
	    var startIndex = 0;
	    var oldStartIndex = 0;
	    var pattern = this.pattern;
	    var len = pattern.length;

	    loopPattern: {
	      for (i = 0; errorIndex < 0 && i < len; i++) {
	        var comp = pattern[i],
	            text,
	            textLen;
	        oldStartIndex = startIndex;
	        if (text = comp.text) {
	          textLen = text.length;
	          if (textLen + startIndex > dateStrLen) {
	            errorIndex = startIndex;
	          } else {
	            for (j = 0; j < textLen; j++) {
	              if (text.charAt(j) !== dateStr.charAt(j + startIndex)) {
	                errorIndex = startIndex;
	                break loopPattern;
	              }
	            }
	            startIndex += textLen;
	          }
	        } else if ('field' in comp) {
	          obeyCount = false;
	          var nextComp = pattern[i + 1];
	          if (nextComp) {
	            if ('field' in nextComp) {
	              obeyCount = true;
	            } else {
	              var c = nextComp.text.charAt(0);
	              if (c >= '0' && c <= '9') {
	                obeyCount = true;
	              }
	            }
	          }
	          startIndex = parseField.call(this, calendar, dateStr, startIndex, comp.field, comp.count, obeyCount, tmp);
	          if (startIndex === oldStartIndex) {
	            errorIndex = startIndex;
	          }
	        }
	      }
	    }

	    if (errorIndex >= 0) {
	      console.error('error when parsing date');
	      console.error(dateStr);
	      console.error(dateStr.slice(0, errorIndex) + '^');
	      return undefined;
	    }
	    return calendar;
	  }
	});

	mix(DateTimeFormat, {
	  Style: DateTimeStyle,

	  /**
	   * get a formatter instance of short style pattern.
	   * en-us: M/d/yy h:mm a
	   * zh-cn: yy-M-d ah:mm
	   * @param {Object} locale locale object
	   * @returns {GregorianCalendar}
	   * @static
	   */
	  getInstance: function getInstance(locale) {
	    return this.getDateTimeInstance(DateTimeStyle.SHORT, DateTimeStyle.SHORT, locale);
	  },

	  /**
	   * get a formatter instance of specified date style.
	   * @param {Date.Formatter.Style} dateStyle date format style
	   * @param {Object} locale
	   * @returns {GregorianCalendar}
	   * @static
	   */
	  getDateInstance: function getDateInstance(dateStyle, locale) {
	    return this.getDateTimeInstance(dateStyle, undefined, locale);
	  },

	  /**
	   * get a formatter instance of specified date style and time style.
	   * @param {Date.Formatter.Style} dateStyle date format style
	   * @param {Date.Formatter.Style} timeStyle time format style
	   * @param {Object} locale
	   * @returns {GregorianCalendar}
	   * @static
	   */
	  getDateTimeInstance: function getDateTimeInstance(dateStyle, timeStyle, locale) {
	    locale = locale || enUsLocale;
	    var datePattern = '';
	    if (dateStyle !== undefined) {
	      datePattern = locale.datePatterns[dateStyle];
	    }
	    var timePattern = '';
	    if (timeStyle !== undefined) {
	      timePattern = locale.timePatterns[timeStyle];
	    }
	    var pattern = datePattern;
	    if (timePattern) {
	      if (datePattern) {
	        pattern = substitute(locale.dateTimePattern, {
	          date: datePattern,
	          time: timePattern
	        });
	      } else {
	        pattern = timePattern;
	      }
	    }
	    return new DateTimeFormat(pattern, locale);
	  },

	  /**
	   * get a formatter instance of specified time style.
	   * @param {Date.Formatter.Style} timeStyle time format style
	   * @param {Object} locale
	   * @returns {GregorianCalendar}
	   * @static
	   */
	  getTimeInstance: function getTimeInstance(timeStyle, locale) {
	    return this.getDateTimeInstance(undefined, timeStyle, locale);
	  }
	});

	module.exports = DateTimeFormat;

	DateTimeFormat.version = '@VERSION@';

	// gc_format@163.com

/***/ },
/* 434 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * GregorianCalendar class
	 * @ignore
	 * @author yiminghe@gmail.com
	 */
	'use strict';

	var toInt = parseInt;
	var Utils = __webpack_require__(435);
	var defaultLocale = __webpack_require__(437);
	var Const = __webpack_require__(436);

	/*
	 * GregorianCalendar class.
	 *
	 * - no arguments:
	 *   Constructs a default GregorianCalendar using the current time
	 *   in the default time zone with the default locale.
	 * - one argument locale:
	 *   Constructs a GregorianCalendar
	 *   based on the current time in the default time zone with the given locale.
	 *
	 * @class Date.Gregorian
	 */
	function GregorianCalendar(loc) {
	  var locale = loc || defaultLocale;

	  this.locale = locale;

	  this.fields = [];

	  /*
	   * The currently set time for this date.
	   * @protected
	   * @type Number|undefined
	   */
	  this.time = undefined;
	  /*
	   * The timezoneOffset in minutes used by this date.
	   * @type Number
	   * @protected
	   */

	  this.timezoneOffset = locale.timezoneOffset;

	  /*
	   * The first day of the week
	   * @type Number
	   * @protected
	   */
	  this.firstDayOfWeek = locale.firstDayOfWeek;

	  /*
	   * The number of days required for the first week in a month or year,
	   * with possible values from 1 to 7.
	   * @@protected
	   * @type Number
	   */
	  this.minimalDaysInFirstWeek = locale.minimalDaysInFirstWeek;

	  this.fieldsComputed = false;
	}

	Utils.mix(GregorianCalendar, Const);

	Utils.mix(GregorianCalendar, {
	  Utils: Utils,

	  defaultLocale: defaultLocale,

	  /*
	   * Determines if the given year is a leap year.
	   * Returns true if the given year is a leap year. To specify BC year numbers,
	   * 1 - year number must be given. For example, year BC 4 is specified as -3.
	   * @param {Number} year the given year.
	   * @returns {Boolean} true if the given year is a leap year; false otherwise.
	   * @static
	   * @method
	   */
	  isLeapYear: Utils.isLeapYear,

	  /*
	   * Enum indicating year field of date
	   * @type Number
	   */
	  YEAR: 1,
	  /*
	   * Enum indicating month field of date
	   * @type Number
	   */
	  MONTH: 2,
	  /*
	   * Enum indicating the day of the month
	   * @type Number
	   */
	  DAY_OF_MONTH: 3,
	  /*
	   * Enum indicating the hour (24).
	   * @type Number
	   */
	  HOUR_OF_DAY: 4,
	  /*
	   * Enum indicating the minute of the day
	   * @type Number
	   */
	  MINUTES: 5,
	  /*
	   * Enum indicating the second of the day
	   * @type Number
	   */
	  SECONDS: 6,
	  /*
	   * Enum indicating the millisecond of the day
	   * @type Number
	   */
	  MILLISECONDS: 7,
	  /*
	   * Enum indicating the week number within the current year
	   * @type Number
	   */
	  WEEK_OF_YEAR: 8,
	  /*
	   * Enum indicating the week number within the current month
	   * @type Number
	   */
	  WEEK_OF_MONTH: 9,

	  /*
	   * Enum indicating the day of the day number within the current year
	   * @type Number
	   */
	  DAY_OF_YEAR: 10,
	  /*
	   * Enum indicating the day of the week
	   * @type Number
	   */
	  DAY_OF_WEEK: 11,
	  /*
	   * Enum indicating the day of the ordinal number of the day of the week
	   * @type Number
	   */
	  DAY_OF_WEEK_IN_MONTH: 12,

	  /*
	   * Enum indicating am
	   * @type Number
	   */
	  AM: 0,
	  /*
	   * Enum indicating pm
	   * @type Number
	   */
	  PM: 1
	});

	var FIELDS = ['', 'Year', 'Month', 'DayOfMonth', 'HourOfDay', 'Minutes', 'Seconds', 'Milliseconds', 'WeekOfYear', 'WeekOfMonth', 'DayOfYear', 'DayOfWeek', 'DayOfWeekInMonth'];

	var YEAR = GregorianCalendar.YEAR;
	var MONTH = GregorianCalendar.MONTH;
	var DAY_OF_MONTH = GregorianCalendar.DAY_OF_MONTH;
	var HOUR_OF_DAY = GregorianCalendar.HOUR_OF_DAY;
	var MINUTE = GregorianCalendar.MINUTES;
	var SECONDS = GregorianCalendar.SECONDS;

	var MILLISECONDS = GregorianCalendar.MILLISECONDS;
	var DAY_OF_WEEK_IN_MONTH = GregorianCalendar.DAY_OF_WEEK_IN_MONTH;
	var DAY_OF_YEAR = GregorianCalendar.DAY_OF_YEAR;
	var DAY_OF_WEEK = GregorianCalendar.DAY_OF_WEEK;

	var WEEK_OF_MONTH = GregorianCalendar.WEEK_OF_MONTH;
	var WEEK_OF_YEAR = GregorianCalendar.WEEK_OF_YEAR;

	var MONTH_LENGTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; // 0-based
	var LEAP_MONTH_LENGTH = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; // 0-based

	var ONE_SECOND = 1000;
	var ONE_MINUTE = 60 * ONE_SECOND;
	var ONE_HOUR = 60 * ONE_MINUTE;
	var ONE_DAY = 24 * ONE_HOUR;
	var ONE_WEEK = ONE_DAY * 7;

	var EPOCH_OFFSET = 719163; // Fixed date of January 1, 1970 (Gregorian)

	var mod = Utils.mod;
	var _isLeapYear = Utils.isLeapYear;
	var floorDivide = Math.floor;

	var MIN_VALUES = [undefined, 1, // YEAR
	GregorianCalendar.JANUARY, // MONTH
	1, // DAY_OF_MONTH
	0, // HOUR_OF_DAY
	0, // MINUTE
	0, // SECONDS
	0, // MILLISECONDS

	1, // WEEK_OF_YEAR
	undefined, // WEEK_OF_MONTH

	1, // DAY_OF_YEAR
	GregorianCalendar.SUNDAY, // DAY_OF_WEEK
	1];

	// DAY_OF_WEEK_IN_MONTH
	var MAX_VALUES = [undefined, 292278994, // YEAR
	GregorianCalendar.DECEMBER, // MONTH
	undefined, // DAY_OF_MONTH
	23, // HOUR_OF_DAY
	59, // MINUTE
	59, // SECONDS
	999, // MILLISECONDS
	undefined, // WEEK_OF_YEAR
	undefined, // WEEK_OF_MONTH
	undefined, // DAY_OF_YEAR
	GregorianCalendar.SATURDAY, // DAY_OF_WEEK
	undefined];

	// ------------------- private start

	// DAY_OF_WEEK_IN_MONTH
	function getMonthLength(year, month) {
	  return _isLeapYear(year) ? LEAP_MONTH_LENGTH[month] : MONTH_LENGTH[month];
	}

	function getYearLength(year) {
	  return _isLeapYear(year) ? 366 : 365;
	}

	function adjustDayOfMonth(self) {
	  var fields = self.fields;
	  var year = fields[YEAR];
	  var month = fields[MONTH];
	  var monthLen = getMonthLength(year, month);
	  var dayOfMonth = fields[DAY_OF_MONTH];
	  if (dayOfMonth > monthLen) {
	    self.set(DAY_OF_MONTH, monthLen);
	  }
	}

	function getDayOfWeekDateOnOrBefore(fixedDate, dayOfWeek) {
	  // 1.1.1 is monday
	  // one week has 7 days
	  return fixedDate - mod(fixedDate - dayOfWeek, 7);
	}

	function getWeekNumber(self, fixedDay1, fixedDate) {
	  var fixedDay1st = getDayOfWeekDateOnOrBefore(fixedDay1 + 6, self.firstDayOfWeek);
	  var nDays = fixedDay1st - fixedDay1;
	  if (nDays >= self.minimalDaysInFirstWeek) {
	    fixedDay1st -= 7;
	  }
	  var normalizedDayOfPeriod = fixedDate - fixedDay1st;
	  return floorDivide(normalizedDayOfPeriod / 7) + 1;
	}

	// ------------------- private end

	GregorianCalendar.prototype = {
	  constructor: GregorianCalendar,

	  isGregorianCalendar: 1,

	  /*
	   * Determines if current year is a leap year.
	   * Returns true if the given year is a leap year. To specify BC year numbers,
	   * 1 - year number must be given. For example, year BC 4 is specified as -3.
	   * @returns {Boolean} true if the given year is a leap year; false otherwise.
	   * @method
	   * @member Date.Gregorian
	   */
	  isLeapYear: function isLeapYear() {
	    return _isLeapYear(this.getYear());
	  },

	  /*
	   * Return local info for current date instance
	   * @returns {Object}
	   */
	  getLocale: function getLocale() {
	    return this.locale;
	  },

	  /*
	   * Returns the minimum value for
	   * the given calendar field of this GregorianCalendar instance.
	   * The minimum value is defined as the smallest value
	   * returned by the get method for any possible time value,
	   * taking into consideration the current values of the getFirstDayOfWeek,
	   * getMinimalDaysInFirstWeek.
	   * @param field the calendar field.
	   * @returns {Number} the minimum value for the given calendar field.
	   */
	  getActualMinimum: function getActualMinimum(field) {
	    if (MIN_VALUES[field] !== undefined) {
	      return MIN_VALUES[field];
	    }
	    if (field === WEEK_OF_MONTH) {
	      var cal = this.clone();
	      cal.clear();
	      cal.set(this.fields[YEAR], this.fields[MONTH], 1);
	      return cal.get(WEEK_OF_MONTH);
	    }

	    throw new Error('minimum value not defined!');
	  },

	  /*
	   * Returns the maximum value for the given calendar field
	   * of this GregorianCalendar instance.
	   * The maximum value is defined as the largest value returned
	   * by the get method for any possible time value, taking into consideration
	   * the current values of the getFirstDayOfWeek, getMinimalDaysInFirstWeek methods.
	   * @param field the calendar field.
	   * @returns {Number} the maximum value for the given calendar field.
	   */
	  getActualMaximum: function getActualMaximum(field) {
	    if (MAX_VALUES[field] !== undefined) {
	      return MAX_VALUES[field];
	    }
	    var value = undefined;
	    var fields = this.fields;
	    switch (field) {
	      case DAY_OF_MONTH:
	        value = getMonthLength(fields[YEAR], fields[MONTH]);
	        break;

	      case WEEK_OF_YEAR:
	        var endOfYear = this.clone();
	        endOfYear.clear();
	        endOfYear.set(fields[YEAR], GregorianCalendar.DECEMBER, 31);
	        value = endOfYear.get(WEEK_OF_YEAR);
	        if (value === 1) {
	          value = 52;
	        }
	        break;

	      case WEEK_OF_MONTH:
	        var endOfMonth = this.clone();
	        endOfMonth.clear();
	        endOfMonth.set(fields[YEAR], fields[MONTH], getMonthLength(fields[YEAR], fields[MONTH]));
	        value = endOfMonth.get(WEEK_OF_MONTH);
	        break;

	      case DAY_OF_YEAR:
	        value = getYearLength(fields[YEAR]);
	        break;

	      case DAY_OF_WEEK_IN_MONTH:
	        value = toInt((getMonthLength(fields[YEAR], fields[MONTH]) - 1) / 7) + 1;
	        break;
	      default:
	        break;
	    }
	    if (value === undefined) {
	      throw new Error('maximum value not defined!');
	    }
	    return value;
	  },

	  /*
	   * Determines if the given calendar field has a value set,
	   * including cases that the value has been set by internal fields calculations
	   * triggered by a get method call.
	   * @param field the calendar field to be cleared.
	   * @returns {boolean} true if the given calendar field has a value set; false otherwise.
	   */
	  isSet: function isSet(field) {
	    return this.fields[field] !== undefined;
	  },

	  /*
	   * Converts the time value (millisecond offset from the Epoch)
	   * to calendar field values.
	   * @protected
	   */
	  computeFields: function computeFields() {
	    var time = this.time;
	    var timezoneOffset = this.timezoneOffset * ONE_MINUTE;
	    var fixedDate = toInt(timezoneOffset / ONE_DAY);
	    var timeOfDay = timezoneOffset % ONE_DAY;
	    fixedDate += toInt(time / ONE_DAY);
	    timeOfDay += time % ONE_DAY;
	    if (timeOfDay >= ONE_DAY) {
	      timeOfDay -= ONE_DAY;
	      fixedDate++;
	    } else {
	      while (timeOfDay < 0) {
	        timeOfDay += ONE_DAY;
	        fixedDate--;
	      }
	    }

	    fixedDate += EPOCH_OFFSET;

	    var date = Utils.getGregorianDateFromFixedDate(fixedDate);

	    var year = date.year;

	    var fields = this.fields;
	    fields[YEAR] = year;
	    fields[MONTH] = date.month;
	    fields[DAY_OF_MONTH] = date.dayOfMonth;
	    fields[DAY_OF_WEEK] = date.dayOfWeek;

	    if (timeOfDay !== 0) {
	      fields[HOUR_OF_DAY] = toInt(timeOfDay / ONE_HOUR);
	      var r = timeOfDay % ONE_HOUR;
	      fields[MINUTE] = toInt(r / ONE_MINUTE);
	      r %= ONE_MINUTE;
	      fields[SECONDS] = toInt(r / ONE_SECOND);
	      fields[MILLISECONDS] = r % ONE_SECOND;
	    } else {
	      fields[HOUR_OF_DAY] = fields[MINUTE] = fields[SECONDS] = fields[MILLISECONDS] = 0;
	    }

	    var fixedDateJan1 = Utils.getFixedDate(year, GregorianCalendar.JANUARY, 1);
	    var dayOfYear = fixedDate - fixedDateJan1 + 1;
	    var fixDateMonth1 = fixedDate - date.dayOfMonth + 1;

	    fields[DAY_OF_YEAR] = dayOfYear;
	    fields[DAY_OF_WEEK_IN_MONTH] = toInt((date.dayOfMonth - 1) / 7) + 1;

	    var weekOfYear = getWeekNumber(this, fixedDateJan1, fixedDate);

	    // 本周没有足够的时间在当前年
	    if (weekOfYear === 0) {
	      // If the date belongs to the last week of the
	      // previous year, use the week number of "12/31" of
	      // the "previous" year.
	      var fixedDec31 = fixedDateJan1 - 1;
	      var prevJan1 = fixedDateJan1 - getYearLength(year - 1);
	      weekOfYear = getWeekNumber(this, prevJan1, fixedDec31);
	    } else
	      // 本周是年末最后一周，可能有足够的时间在新的一年
	      if (weekOfYear >= 52) {
	        var nextJan1 = fixedDateJan1 + getYearLength(year);
	        var nextJan1st = getDayOfWeekDateOnOrBefore(nextJan1 + 6, this.firstDayOfWeek);
	        var nDays = nextJan1st - nextJan1;
	        // 本周有足够天数在新的一年
	        if (nDays >= this.minimalDaysInFirstWeek &&
	        // 当天确实在本周，weekOfYear === 53 时是不需要这个判断
	        fixedDate >= nextJan1st - 7) {
	          weekOfYear = 1;
	        }
	      }

	    fields[WEEK_OF_YEAR] = weekOfYear;
	    fields[WEEK_OF_MONTH] = getWeekNumber(this, fixDateMonth1, fixedDate);

	    this.fieldsComputed = true;
	  },

	  /*
	   * Converts calendar field values to the time value
	   * (millisecond offset from the Epoch).
	   * @protected
	   */
	  computeTime: function computeTime() {
	    if (!this.isSet(YEAR)) {
	      throw new Error('year must be set for GregorianCalendar');
	    }

	    var fields = this.fields;

	    var year = fields[YEAR];
	    var timeOfDay = 0;
	    if (this.isSet(HOUR_OF_DAY)) {
	      timeOfDay += fields[HOUR_OF_DAY];
	    }
	    timeOfDay *= 60;
	    timeOfDay += fields[MINUTE] || 0;
	    timeOfDay *= 60;
	    timeOfDay += fields[SECONDS] || 0;
	    timeOfDay *= 1000;
	    timeOfDay += fields[MILLISECONDS] || 0;

	    var fixedDate = 0;

	    fields[YEAR] = year;

	    fixedDate = fixedDate + this.getFixedDate();

	    // millis represents local wall-clock time in milliseconds.
	    var millis = (fixedDate - EPOCH_OFFSET) * ONE_DAY + timeOfDay;

	    millis -= this.timezoneOffset * ONE_MINUTE;

	    this.time = millis;

	    this.computeFields();
	  },

	  /*
	   * Fills in any unset fields in the calendar fields. First,
	   * the computeTime() method is called if the time value (millisecond offset from the Epoch)
	   * has not been calculated from calendar field values.
	   * Then, the computeFields() method is called to calculate all calendar field values.
	   * @protected
	   */
	  complete: function complete() {
	    if (this.time === undefined) {
	      this.computeTime();
	    }
	    if (!this.fieldsComputed) {
	      this.computeFields();
	    }
	  },

	  getFixedDate: function getFixedDate() {
	    var self = this;

	    var fields = self.fields;

	    var firstDayOfWeekCfg = self.firstDayOfWeek;

	    var year = fields[YEAR];

	    var month = GregorianCalendar.JANUARY;

	    if (self.isSet(MONTH)) {
	      month = fields[MONTH];
	      if (month > GregorianCalendar.DECEMBER) {
	        year += toInt(month / 12);
	        month %= 12;
	      } else if (month < GregorianCalendar.JANUARY) {
	        year += floorDivide(month / 12);
	        month = mod(month, 12);
	      }
	    }

	    // Get the fixed date since Jan 1, 1 (Gregorian). We are on
	    // the first day of either `month' or January in 'year'.
	    var fixedDate = Utils.getFixedDate(year, month, 1);
	    var firstDayOfWeek = undefined;
	    var dayOfWeek = self.firstDayOfWeek;

	    if (self.isSet(DAY_OF_WEEK)) {
	      dayOfWeek = fields[DAY_OF_WEEK];
	    }

	    if (self.isSet(MONTH)) {
	      if (self.isSet(DAY_OF_MONTH)) {
	        fixedDate += fields[DAY_OF_MONTH] - 1;
	      } else {
	        if (self.isSet(WEEK_OF_MONTH)) {
	          firstDayOfWeek = getDayOfWeekDateOnOrBefore(fixedDate + 6, firstDayOfWeekCfg);

	          // If we have enough days in the first week, then
	          // move to the previous week.
	          if (firstDayOfWeek - fixedDate >= self.minimalDaysInFirstWeek) {
	            firstDayOfWeek -= 7;
	          }

	          if (dayOfWeek !== firstDayOfWeekCfg) {
	            firstDayOfWeek = getDayOfWeekDateOnOrBefore(firstDayOfWeek + 6, dayOfWeek);
	          }

	          fixedDate = firstDayOfWeek + 7 * (fields[WEEK_OF_MONTH] - 1);
	        } else {
	          var dowim = undefined;
	          if (self.isSet(DAY_OF_WEEK_IN_MONTH)) {
	            dowim = fields[DAY_OF_WEEK_IN_MONTH];
	          } else {
	            dowim = 1;
	          }
	          var lastDate = 7 * dowim;
	          if (dowim < 0) {
	            lastDate = getMonthLength(year, month) + 7 * (dowim + 1);
	          }
	          fixedDate = getDayOfWeekDateOnOrBefore(fixedDate + lastDate - 1, dayOfWeek);
	        }
	      }
	    } else {
	      // We are on the first day of the year.
	      if (self.isSet(DAY_OF_YEAR)) {
	        fixedDate += fields[DAY_OF_YEAR] - 1;
	      } else {
	        firstDayOfWeek = getDayOfWeekDateOnOrBefore(fixedDate + 6, firstDayOfWeekCfg);
	        // If we have enough days in the first week, then move
	        // to the previous week.
	        if (firstDayOfWeek - fixedDate >= self.minimalDaysInFirstWeek) {
	          firstDayOfWeek -= 7;
	        }
	        if (dayOfWeek !== firstDayOfWeekCfg) {
	          firstDayOfWeek = getDayOfWeekDateOnOrBefore(firstDayOfWeek + 6, dayOfWeek);
	        }
	        fixedDate = firstDayOfWeek + 7 * (fields[WEEK_OF_YEAR] - 1);
	      }
	    }

	    return fixedDate;
	  },

	  /*
	   * Returns this Calendar's time value in milliseconds
	   * @member Date.Gregorian
	   * @returns {Number} the current time as UTC milliseconds from the epoch.
	   */
	  getTime: function getTime() {
	    if (this.time === undefined) {
	      this.computeTime();
	    }
	    return this.time;
	  },

	  /*
	   * Sets this Calendar's current time from the given long value.
	   * @param time the new time in UTC milliseconds from the epoch.
	   */
	  setTime: function setTime(time) {
	    this.time = time;
	    this.fieldsComputed = false;
	    this.complete();
	  },

	  /*
	   * Returns the value of the given calendar field.
	   * @param field the given calendar field.
	   * @returns {Number} the value for the given calendar field.
	   */
	  get: function get(field) {
	    this.complete();
	    return this.fields[field];
	  },

	  /*
	   * Returns the year of the given calendar field.
	   * @method getYear
	   * @returns {Number} the year for the given calendar field.
	   */

	  /*
	   * Returns the month of the given calendar field.
	   * @method getMonth
	   * @returns {Number} the month for the given calendar field.
	   */

	  /*
	   * Returns the day of month of the given calendar field.
	   * @method getDayOfMonth
	   * @returns {Number} the day of month for the given calendar field.
	   */

	  /*
	   * Returns the hour of day of the given calendar field.
	   * @method getHourOfDay
	   * @returns {Number} the hour of day for the given calendar field.
	   */

	  /*
	   * Returns the minute of the given calendar field.
	   * @method getMinute
	   * @returns {Number} the minute for the given calendar field.
	   */

	  /*
	   * Returns the second of the given calendar field.
	   * @method getSecond
	   * @returns {Number} the second for the given calendar field.
	   */

	  /*
	   * Returns the millisecond of the given calendar field.
	   * @method getMilliSecond
	   * @returns {Number} the millisecond for the given calendar field.
	   */

	  /*
	   * Returns the week of year of the given calendar field.
	   * @method getWeekOfYear
	   * @returns {Number} the week of year for the given calendar field.
	   */

	  /*
	   * Returns the week of month of the given calendar field.
	   * @method getWeekOfMonth
	   * @returns {Number} the week of month for the given calendar field.
	   */

	  /*
	   * Returns the day of year of the given calendar field.
	   * @method getDayOfYear
	   * @returns {Number} the day of year for the given calendar field.
	   */

	  /*
	   * Returns the day of week of the given calendar field.
	   * @method getDayOfWeek
	   * @returns {Number} the day of week for the given calendar field.
	   */

	  /*
	   * Returns the day of week in month of the given calendar field.
	   * @method getDayOfWeekInMonth
	   * @returns {Number} the day of week in month for the given calendar field.
	   */

	  /*
	   * Sets the given calendar field to the given value.
	   * @param field the given calendar field.
	   * @param v the value to be set for the given calendar field.
	   */
	  set: function set(field, v) {
	    var len = arguments.length;
	    if (len === 2) {
	      this.fields[field] = v;
	    } else if (len < MILLISECONDS + 1) {
	      for (var i = 0; i < len; i++) {
	        this.fields[YEAR + i] = arguments[i];
	      }
	    } else {
	      throw new Error('illegal arguments for GregorianCalendar set');
	    }
	    this.time = undefined;
	  },

	  /*
	   * Set the year of the given calendar field.
	   * @method setYear
	   */

	  /*
	   * Set the month of the given calendar field.
	   * @method setMonth
	   */

	  /*
	   * Set the day of month of the given calendar field.
	   * @method setDayOfMonth
	   */

	  /*
	   * Set the hour of day of the given calendar field.
	   * @method setHourOfDay
	   */

	  /*
	   * Set the minute of the given calendar field.
	   * @method setMinute
	   */

	  /*
	   * Set the second of the given calendar field.
	   * @method setSecond
	   */

	  /*
	   * Set the millisecond of the given calendar field.
	   * @method setMilliSecond
	   */

	  /*
	   * Set the week of year of the given calendar field.
	   * @method setWeekOfYear
	   */

	  /*
	   * Set the week of month of the given calendar field.
	   * @method setWeekOfMonth
	   */

	  /*
	   * Set the day of year of the given calendar field.
	   * @method setDayOfYear
	   */

	  /*
	   * Set the day of week of the given calendar field.
	   * @method setDayOfWeek
	   */

	  /*
	   * Set the day of week in month of the given calendar field.
	   * @method setDayOfWeekInMonth
	   */

	  /*
	   * add for specified field based on two rules:
	   *
	   *  - Add rule 1. The value of field after the call minus the value of field before the
	   *  call is amount, modulo any overflow that has occurred in field
	   *  Overflow occurs when a field value exceeds its range and,
	   *  as a result, the next larger field is incremented or
	   *  decremented and the field value is adjusted back into its range.
	   *
	   *  - Add rule 2. If a smaller field is expected to be invariant,
	   *  but it is impossible for it to be equal to its
	   *  prior value because of changes in its minimum or maximum after
	   *  field is changed, then its value is adjusted to be as close
	   *  as possible to its expected value. A smaller field represents a
	   *  smaller unit of time. HOUR_OF_DAY is a smaller field than
	   *  DAY_OF_MONTH. No adjustment is made to smaller fields
	   *  that are not expected to be invariant. The calendar system
	   *  determines what fields are expected to be invariant.
	   *
	   *
	   *      @example
	   *      use('date/gregorian',function(S, GregorianCalendar){
	   *          const d = new GregorianCalendar();
	   *          d.set(2012, GregorianCalendar.JANUARY, 31);
	   *          d.add(Gregorian.MONTH,1);
	   *          // 2012-2-29
	   *          document.writeln('<p>'+d.getYear()+'-'+d.getMonth()+'-'+d.getDayOfWeek())
	   *          d.add(Gregorian.MONTH,12);
	   *          // 2013-2-28
	   *          document.writeln('<p>'+d.getYear()+'-'+d.getMonth()+'-'+d.getDayOfWeek())
	   *      });
	   *
	   * @param field the calendar field.
	   * @param {Number} amount he amount of date or time to be added to the field.
	   */
	  add: function add(field, a) {
	    if (!a) {
	      return;
	    }
	    var amount = a;
	    var self = this;
	    var fields = self.fields;
	    // computer and retrieve original value
	    var value = self.get(field);
	    if (field === YEAR) {
	      value += amount;
	      self.set(YEAR, value);
	      adjustDayOfMonth(self);
	    } else if (field === MONTH) {
	      value += amount;
	      var yearAmount = floorDivide(value / 12);
	      value = mod(value, 12);
	      if (yearAmount) {
	        self.set(YEAR, fields[YEAR] + yearAmount);
	      }
	      self.set(MONTH, value);
	      adjustDayOfMonth(self);
	    } else {
	      switch (field) {
	        case HOUR_OF_DAY:
	          amount *= ONE_HOUR;
	          break;
	        case MINUTE:
	          amount *= ONE_MINUTE;
	          break;
	        case SECONDS:
	          amount *= ONE_SECOND;
	          break;
	        case MILLISECONDS:
	          break;
	        case WEEK_OF_MONTH:
	        case WEEK_OF_YEAR:
	        case DAY_OF_WEEK_IN_MONTH:
	          amount *= ONE_WEEK;
	          break;
	        case DAY_OF_WEEK:
	        case DAY_OF_YEAR:
	        case DAY_OF_MONTH:
	          amount *= ONE_DAY;
	          break;
	        default:
	          throw new Error('illegal field for add');
	      }
	      self.setTime(self.time + amount);
	    }
	  },

	  /*
	   * add the year of the given calendar field.
	   * @method addYear
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * add the month of the given calendar field.
	   * @method addMonth
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * add the day of month of the given calendar field.
	   * @method addDayOfMonth
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * add the hour of day of the given calendar field.
	   * @method addHourOfDay
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * add the minute of the given calendar field.
	   * @method addMinute
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * add the second of the given calendar field.
	   * @method addSecond
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * add the millisecond of the given calendar field.
	   * @method addMilliSecond
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * add the week of year of the given calendar field.
	   * @method addWeekOfYear
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * add the week of month of the given calendar field.
	   * @method addWeekOfMonth
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * add the day of year of the given calendar field.
	   * @method addDayOfYear
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * add the day of week of the given calendar field.
	   * @method addDayOfWeek
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * add the day of week in month of the given calendar field.
	   * @method addDayOfWeekInMonth
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * Get rolled value for the field
	   * @protected
	   */
	  getRolledValue: function getRolledValue(value, a, min, max) {
	    var amount = a;
	    var diff = value - min;
	    var range = max - min + 1;
	    amount %= range;
	    return min + (diff + amount + range) % range;
	  },

	  /*
	   * Adds a signed amount to the specified calendar field without changing larger fields.
	   * A negative roll amount means to subtract from field without changing
	   * larger fields. If the specified amount is 0, this method performs nothing.
	   *
	   *
	   *
	   *      @example
	   *      const d = new GregorianCalendar();
	   *      d.set(1999, GregorianCalendar.AUGUST, 31);
	   *      // 1999-4-30
	   *      // Tuesday June 1, 1999
	   *      d.set(1999, GregorianCalendar.JUNE, 1);
	   *      d.add(Gregorian.WEEK_OF_MONTH,-1); // === d.add(Gregorian.WEEK_OF_MONTH,
	   *      d.get(Gregorian.WEEK_OF_MONTH));
	   *      // 1999-06-29
	   *
	   *
	   * @param field the calendar field.
	   * @param {Number} amount the signed amount to add to field.
	   */
	  roll: function roll(field, amount) {
	    if (!amount) {
	      return;
	    }
	    var self = this;
	    // computer and retrieve original value
	    var value = self.get(field);
	    var min = self.getActualMinimum(field);
	    var max = self.getActualMaximum(field);
	    value = self.getRolledValue(value, amount, min, max);

	    self.set(field, value);

	    // consider compute time priority
	    switch (field) {
	      case MONTH:
	        adjustDayOfMonth(self);
	        break;
	      default:
	        // other fields are set already when get
	        self.updateFieldsBySet(field);
	        break;
	    }
	  },

	  /*
	   * keep field stable.
	   *
	   * 2015-09-29 setMonth 2 vs rollSetMonth 2
	   *
	   */
	  rollSet: function rollSet(field, v) {
	    this.set(field, v);
	    switch (field) {
	      case MONTH:
	        adjustDayOfMonth(this);
	        break;
	      default:
	        // other fields are set already when get
	        this.updateFieldsBySet(field);
	        break;
	    }
	  },

	  /*
	   * roll the year of the given calendar field.
	   * @method rollYear
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * roll the month of the given calendar field.
	   * @param {Number} amount the signed amount to add to field.
	   * @method rollMonth
	   */

	  /*
	   * roll the day of month of the given calendar field.
	   * @method rollDayOfMonth
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * roll the hour of day of the given calendar field.
	   * @method rollHourOfDay
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * roll the minute of the given calendar field.
	   * @method rollMinute
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * roll the second of the given calendar field.
	   * @method rollSecond
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * roll the millisecond of the given calendar field.
	   * @method rollMilliSecond
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * roll the week of year of the given calendar field.
	   * @method rollWeekOfYear
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * roll the week of month of the given calendar field.
	   * @method rollWeekOfMonth
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * roll the day of year of the given calendar field.
	   * @method rollDayOfYear
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * roll the day of week of the given calendar field.
	   * @method rollDayOfWeek
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * remove other priority fields when call getFixedDate
	   * precondition: other fields are all set or computed
	   * @protected
	   */
	  updateFieldsBySet: function updateFieldsBySet(field) {
	    var fields = this.fields;
	    switch (field) {
	      case WEEK_OF_MONTH:
	        fields[DAY_OF_MONTH] = undefined;
	        break;
	      case DAY_OF_YEAR:
	        fields[MONTH] = undefined;
	        break;
	      case DAY_OF_WEEK:
	        fields[DAY_OF_MONTH] = undefined;
	        break;
	      case WEEK_OF_YEAR:
	        fields[DAY_OF_YEAR] = undefined;
	        fields[MONTH] = undefined;
	        break;
	      default:
	        break;
	    }
	  },

	  /*
	   * get current date instance's timezone offset
	   * @returns {Number}
	   */
	  getTimezoneOffset: function getTimezoneOffset() {
	    return this.timezoneOffset;
	  },

	  /*
	   * set current date instance's timezone offset
	   */
	  setTimezoneOffset: function setTimezoneOffset(timezoneOffset) {
	    if (this.timezoneOffset !== timezoneOffset) {
	      this.fieldsComputed = undefined;
	      this.timezoneOffset = timezoneOffset;
	    }
	  },

	  /*
	   * set first day of week for current date instance
	   */
	  setFirstDayOfWeek: function setFirstDayOfWeek(firstDayOfWeek) {
	    if (this.firstDayOfWeek !== firstDayOfWeek) {
	      this.firstDayOfWeek = firstDayOfWeek;
	      this.fieldsComputed = false;
	    }
	  },

	  /*
	   * Gets what the first day of the week is; e.g., SUNDAY in the U.S., MONDAY in France.
	   * @returns {Number} the first day of the week.
	   */
	  getFirstDayOfWeek: function getFirstDayOfWeek() {
	    return this.firstDayOfWeek;
	  },

	  /*
	   * Sets what the minimal days required in the first week of the year are; For example,
	   * if the first week is defined as one that contains the first day of the first month of a year,
	   * call this method with value 1.
	   * If it must be a full week, use value 7.
	   * @param minimalDaysInFirstWeek the given minimal days required in the first week of the year.
	   */
	  setMinimalDaysInFirstWeek: function setMinimalDaysInFirstWeek(minimalDaysInFirstWeek) {
	    if (this.minimalDaysInFirstWeek !== minimalDaysInFirstWeek) {
	      this.minimalDaysInFirstWeek = minimalDaysInFirstWeek;
	      this.fieldsComputed = false;
	    }
	  },

	  /*
	   * Gets what the minimal days required in the first week of the year are; e.g.,
	   * if the first week is defined as one that contains the first day of the first month of a year,
	   * this method returns 1.
	   * If the minimal days required must be a full week, this method returns 7.
	   * @returns {Number} the minimal days required in the first week of the year.
	   */
	  getMinimalDaysInFirstWeek: function getMinimalDaysInFirstWeek() {
	    return this.minimalDaysInFirstWeek;
	  },

	  /*
	   * Returns the number of weeks in the week year
	   * represented by this GregorianCalendar.
	   *
	   * For example, if this GregorianCalendar's date is
	   * December 31, 2008 with the ISO
	   * 8601 compatible setting, this method will return 53 for the
	   * period: December 29, 2008 to January 3, 2010
	   * while getActualMaximum(WEEK_OF_YEAR) will return
	   * 52 for the period: December 31, 2007 to December 28, 2008.
	   *
	   * @return {Number} the number of weeks in the week year.
	   */
	  getWeeksInWeekYear: function getWeeksInWeekYear() {
	    var weekYear = this.getWeekYear();
	    if (weekYear === this.get(YEAR)) {
	      return this.getActualMaximum(WEEK_OF_YEAR);
	    }
	    // Use the 2nd week for calculating the max of WEEK_OF_YEAR
	    var gc = this.clone();
	    gc.clear();
	    gc.setWeekDate(weekYear, 2, this.get(DAY_OF_WEEK));
	    return gc.getActualMaximum(WEEK_OF_YEAR);
	  },

	  /*
	   * Returns the week year represented by this GregorianCalendar.
	   * The dates in the weeks between 1 and the
	   * maximum week number of the week year have the same week year value
	   * that may be one year before or after the calendar year value.
	   *
	   * @return {Number} the week year represented by this GregorianCalendar.
	   */
	  getWeekYear: function getWeekYear() {
	    var year = this.get(YEAR); // implicitly  complete
	    var weekOfYear = this.get(WEEK_OF_YEAR);
	    var month = this.get(MONTH);
	    if (month === GregorianCalendar.JANUARY) {
	      if (weekOfYear >= 52) {
	        --year;
	      }
	    } else if (month === GregorianCalendar.DECEMBER) {
	      if (weekOfYear === 1) {
	        ++year;
	      }
	    }
	    return year;
	  },
	  /*
	   * Sets this GregorianCalendar to the date given by the date specifiers - weekYear,
	   * weekOfYear, and dayOfWeek. weekOfYear follows the WEEK_OF_YEAR numbering.
	   * The dayOfWeek value must be one of the DAY_OF_WEEK values: SUNDAY to SATURDAY.
	   *
	   * @param weekYear    the week year
	   * @param weekOfYear  the week number based on weekYear
	   * @param dayOfWeek   the day of week value
	   */
	  setWeekDate: function setWeekDate(weekYear, weekOfYear, dayOfWeek) {
	    if (dayOfWeek < GregorianCalendar.SUNDAY || dayOfWeek > GregorianCalendar.SATURDAY) {
	      throw new Error('invalid dayOfWeek: ' + dayOfWeek);
	    }
	    var fields = this.fields;
	    // To avoid changing the time of day fields by date
	    // calculations, use a clone with the GMT time zone.
	    var gc = this.clone();
	    gc.clear();
	    gc.setTimezoneOffset(0);
	    gc.set(YEAR, weekYear);
	    gc.set(WEEK_OF_YEAR, 1);
	    gc.set(DAY_OF_WEEK, this.getFirstDayOfWeek());
	    var days = dayOfWeek - this.getFirstDayOfWeek();
	    if (days < 0) {
	      days += 7;
	    }
	    days += 7 * (weekOfYear - 1);
	    if (days !== 0) {
	      gc.add(DAY_OF_YEAR, days);
	    } else {
	      gc.complete();
	    }
	    fields[YEAR] = gc.get(YEAR);
	    fields[MONTH] = gc.get(MONTH);
	    fields[DAY_OF_MONTH] = gc.get(DAY_OF_MONTH);
	    this.complete();
	  },
	  /*
	   * Creates and returns a copy of this object.
	   * @returns {Date.Gregorian}
	   */
	  clone: function clone() {
	    if (this.time === undefined) {
	      this.computeTime();
	    }
	    var cal = new GregorianCalendar(this.locale);
	    cal.setTimezoneOffset(cal.getTimezoneOffset());
	    cal.setFirstDayOfWeek(cal.getFirstDayOfWeek());
	    cal.setMinimalDaysInFirstWeek(cal.getMinimalDaysInFirstWeek());
	    cal.setTime(this.time);
	    return cal;
	  },

	  /*
	   * Compares this GregorianCalendar to the specified Object.
	   * The result is true if and only if the argument is a GregorianCalendar object
	   * that represents the same time value (millisecond offset from the Epoch)
	   * under the same Calendar parameters and Gregorian change date as this object.
	   * @param {Date.Gregorian} obj the object to compare with.
	   * @returns {boolean} true if this object is equal to obj; false otherwise.
	   */
	  equals: function equals(obj) {
	    return this.getTime() === obj.getTime() && this.firstDayOfWeek === obj.firstDayOfWeek && this.timezoneOffset === obj.timezoneOffset && this.minimalDaysInFirstWeek === obj.minimalDaysInFirstWeek;
	  },

	  /*
	   * Sets all the calendar field values or specified field and the time value
	   * (millisecond offset from the Epoch) of this Calendar undefined.
	   * This means that isSet() will return false for all the calendar fields,
	   * and the date and time calculations will treat the fields as if they had never been set.
	   * @param [field] the calendar field to be cleared.
	   */
	  clear: function clear(field) {
	    if (field === undefined) {
	      this.field = [];
	    } else {
	      this.fields[field] = undefined;
	    }
	    this.time = undefined;
	    this.fieldsComputed = false;
	  }
	};

	var GregorianCalendarProto = GregorianCalendar.prototype;

	Utils.each(FIELDS, function (f, index) {
	  if (f) {
	    GregorianCalendarProto['get' + f] = function get() {
	      return this.get(index);
	    };

	    GregorianCalendarProto['isSet' + f] = function isSet() {
	      return this.isSet(index);
	    };

	    GregorianCalendarProto['set' + f] = function set(v) {
	      return this.set(index, v);
	    };

	    GregorianCalendarProto['add' + f] = function add(v) {
	      return this.add(index, v);
	    };

	    GregorianCalendarProto['roll' + f] = function roll(v) {
	      return this.roll(index, v);
	    };

	    GregorianCalendarProto['rollSet' + f] = function rollSet(v) {
	      return this.rollSet(index, v);
	    };
	  }
	});

	module.exports = GregorianCalendar;
	/*
	 http://docs.oracle.com/javase/7/docs/api/java/util/GregorianCalendar.html

	 TODO
	 - day saving time
	 - i18n
	 - julian calendar
	 */

/***/ },
/* 435 */
[748, 436],
/* 436 */
14,
/* 437 */
15,
/* 438 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * en-us locale
	 * @ignore
	 * @author yiminghe@gmail.com
	 */
	module.exports = {
	  eras: ['BC', 'AD'],
	  months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
	  shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
	  weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
	  shortWeekdays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
	  veryShortWeekdays: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
	  ampms: ['AM', 'PM'],
	  datePatterns: ['EEEE, MMMM d, yyyy', 'MMMM d, yyyy', 'MMM d, yyyy', 'M/d/yy'],
	  timePatterns: ['h:mm:ss a \'GMT\'Z', 'h:mm:ss a', 'h:mm:ss a', 'h:mm a'],
	  dateTimePattern: '{date} {time}'
		};

/***/ },
/* 439 */
[789, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450],
/* 440 */
/***/ function(module, exports) {

	'use strict';

	var seed = 0;
	module.exports = function () {
	  return Date.now() + '_' + seed++;
		};

/***/ },
/* 441 */
/***/ function(module, exports) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	/**
	 * Copyright 2013-2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This file contains an unmodified version of:
	 * https://github.com/facebook/react/blob/v0.12.0/src/vendor/stubs/cx.js
	 *
	 * This source code is licensed under the BSD-style license found here:
	 * https://github.com/facebook/react/blob/v0.12.0/LICENSE
	 * An additional grant of patent rights can be found here:
	 * https://github.com/facebook/react/blob/v0.12.0/PATENTS
	 */

	/**
	 * This function is used to mark string literals representing CSS class names
	 * so that they can be transformed statically. This allows for modularization
	 * and minification of CSS class names.
	 *
	 * In static_upstream, this function is actually implemented, but it should
	 * eventually be replaced with something more descriptive, and the transform
	 * that is used in the main stack should be ported for use elsewhere.
	 *
	 * @param string|object className to modularize, or an object of key/values.
	 *                      In the object case, the values are conditions that
	 *                      determine if the className keys should be included.
	 * @param [string ...]  Variable list of classNames in the string case.
	 * @return string       Renderable space-separated CSS className.
	 */
	function cx(classNames) {
	  if ((typeof classNames === 'undefined' ? 'undefined' : _typeof(classNames)) === 'object') {
	    return Object.keys(classNames).filter(function (className) {
	      return classNames[className];
	    }).join(' ');
	  } else {
	    return Array.prototype.join.call(arguments, ' ');
	  }
	}

		module.exports = cx;

/***/ },
/* 442 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This file contains an unmodified version of:
	 * https://github.com/facebook/react/blob/v0.12.0/src/utils/joinClasses.js
	 *
	 * This source code is licensed under the BSD-style license found here:
	 * https://github.com/facebook/react/blob/v0.12.0/LICENSE
	 * An additional grant of patent rights can be found here:
	 * https://github.com/facebook/react/blob/v0.12.0/PATENTS
	 */

	"use strict";

	/**
	 * Combines multiple className strings into one.
	 * http://jsperf.com/joinclasses-args-vs-array
	 *
	 * @param {...?string} classes
	 * @return {string}
	 */

	function joinClasses(className /*, ... */) {
	  if (!className) {
	    className = '';
	  }
	  var nextClass;
	  var argLength = arguments.length;
	  if (argLength > 1) {
	    for (var ii = 1; ii < argLength; ii++) {
	      nextClass = arguments[ii];
	      if (nextClass) {
	        className = (className ? className + ' ' : '') + nextClass;
	      }
	    }
	  }
	  return className;
	}

		module.exports = joinClasses;

/***/ },
/* 443 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * @ignore
	 * some key-codes definition and utils from closure-library
	 * @author yiminghe@gmail.com
	 */

	var KeyCode = {
	  /**
	   * MAC_ENTER
	   */
	  MAC_ENTER: 3,
	  /**
	   * BACKSPACE
	   */
	  BACKSPACE: 8,
	  /**
	   * TAB
	   */
	  TAB: 9,
	  /**
	   * NUMLOCK on FF/Safari Mac
	   */
	  NUM_CENTER: 12, // NUMLOCK on FF/Safari Mac
	  /**
	   * ENTER
	   */
	  ENTER: 13,
	  /**
	   * SHIFT
	   */
	  SHIFT: 16,
	  /**
	   * CTRL
	   */
	  CTRL: 17,
	  /**
	   * ALT
	   */
	  ALT: 18,
	  /**
	   * PAUSE
	   */
	  PAUSE: 19,
	  /**
	   * CAPS_LOCK
	   */
	  CAPS_LOCK: 20,
	  /**
	   * ESC
	   */
	  ESC: 27,
	  /**
	   * SPACE
	   */
	  SPACE: 32,
	  /**
	   * PAGE_UP
	   */
	  PAGE_UP: 33, // also NUM_NORTH_EAST
	  /**
	   * PAGE_DOWN
	   */
	  PAGE_DOWN: 34, // also NUM_SOUTH_EAST
	  /**
	   * END
	   */
	  END: 35, // also NUM_SOUTH_WEST
	  /**
	   * HOME
	   */
	  HOME: 36, // also NUM_NORTH_WEST
	  /**
	   * LEFT
	   */
	  LEFT: 37, // also NUM_WEST
	  /**
	   * UP
	   */
	  UP: 38, // also NUM_NORTH
	  /**
	   * RIGHT
	   */
	  RIGHT: 39, // also NUM_EAST
	  /**
	   * DOWN
	   */
	  DOWN: 40, // also NUM_SOUTH
	  /**
	   * PRINT_SCREEN
	   */
	  PRINT_SCREEN: 44,
	  /**
	   * INSERT
	   */
	  INSERT: 45, // also NUM_INSERT
	  /**
	   * DELETE
	   */
	  DELETE: 46, // also NUM_DELETE
	  /**
	   * ZERO
	   */
	  ZERO: 48,
	  /**
	   * ONE
	   */
	  ONE: 49,
	  /**
	   * TWO
	   */
	  TWO: 50,
	  /**
	   * THREE
	   */
	  THREE: 51,
	  /**
	   * FOUR
	   */
	  FOUR: 52,
	  /**
	   * FIVE
	   */
	  FIVE: 53,
	  /**
	   * SIX
	   */
	  SIX: 54,
	  /**
	   * SEVEN
	   */
	  SEVEN: 55,
	  /**
	   * EIGHT
	   */
	  EIGHT: 56,
	  /**
	   * NINE
	   */
	  NINE: 57,
	  /**
	   * QUESTION_MARK
	   */
	  QUESTION_MARK: 63, // needs localization
	  /**
	   * A
	   */
	  A: 65,
	  /**
	   * B
	   */
	  B: 66,
	  /**
	   * C
	   */
	  C: 67,
	  /**
	   * D
	   */
	  D: 68,
	  /**
	   * E
	   */
	  E: 69,
	  /**
	   * F
	   */
	  F: 70,
	  /**
	   * G
	   */
	  G: 71,
	  /**
	   * H
	   */
	  H: 72,
	  /**
	   * I
	   */
	  I: 73,
	  /**
	   * J
	   */
	  J: 74,
	  /**
	   * K
	   */
	  K: 75,
	  /**
	   * L
	   */
	  L: 76,
	  /**
	   * M
	   */
	  M: 77,
	  /**
	   * N
	   */
	  N: 78,
	  /**
	   * O
	   */
	  O: 79,
	  /**
	   * P
	   */
	  P: 80,
	  /**
	   * Q
	   */
	  Q: 81,
	  /**
	   * R
	   */
	  R: 82,
	  /**
	   * S
	   */
	  S: 83,
	  /**
	   * T
	   */
	  T: 84,
	  /**
	   * U
	   */
	  U: 85,
	  /**
	   * V
	   */
	  V: 86,
	  /**
	   * W
	   */
	  W: 87,
	  /**
	   * X
	   */
	  X: 88,
	  /**
	   * Y
	   */
	  Y: 89,
	  /**
	   * Z
	   */
	  Z: 90,
	  /**
	   * META
	   */
	  META: 91, // WIN_KEY_LEFT
	  /**
	   * WIN_KEY_RIGHT
	   */
	  WIN_KEY_RIGHT: 92,
	  /**
	   * CONTEXT_MENU
	   */
	  CONTEXT_MENU: 93,
	  /**
	   * NUM_ZERO
	   */
	  NUM_ZERO: 96,
	  /**
	   * NUM_ONE
	   */
	  NUM_ONE: 97,
	  /**
	   * NUM_TWO
	   */
	  NUM_TWO: 98,
	  /**
	   * NUM_THREE
	   */
	  NUM_THREE: 99,
	  /**
	   * NUM_FOUR
	   */
	  NUM_FOUR: 100,
	  /**
	   * NUM_FIVE
	   */
	  NUM_FIVE: 101,
	  /**
	   * NUM_SIX
	   */
	  NUM_SIX: 102,
	  /**
	   * NUM_SEVEN
	   */
	  NUM_SEVEN: 103,
	  /**
	   * NUM_EIGHT
	   */
	  NUM_EIGHT: 104,
	  /**
	   * NUM_NINE
	   */
	  NUM_NINE: 105,
	  /**
	   * NUM_MULTIPLY
	   */
	  NUM_MULTIPLY: 106,
	  /**
	   * NUM_PLUS
	   */
	  NUM_PLUS: 107,
	  /**
	   * NUM_MINUS
	   */
	  NUM_MINUS: 109,
	  /**
	   * NUM_PERIOD
	   */
	  NUM_PERIOD: 110,
	  /**
	   * NUM_DIVISION
	   */
	  NUM_DIVISION: 111,
	  /**
	   * F1
	   */
	  F1: 112,
	  /**
	   * F2
	   */
	  F2: 113,
	  /**
	   * F3
	   */
	  F3: 114,
	  /**
	   * F4
	   */
	  F4: 115,
	  /**
	   * F5
	   */
	  F5: 116,
	  /**
	   * F6
	   */
	  F6: 117,
	  /**
	   * F7
	   */
	  F7: 118,
	  /**
	   * F8
	   */
	  F8: 119,
	  /**
	   * F9
	   */
	  F9: 120,
	  /**
	   * F10
	   */
	  F10: 121,
	  /**
	   * F11
	   */
	  F11: 122,
	  /**
	   * F12
	   */
	  F12: 123,
	  /**
	   * NUMLOCK
	   */
	  NUMLOCK: 144,
	  /**
	   * SEMICOLON
	   */
	  SEMICOLON: 186, // needs localization
	  /**
	   * DASH
	   */
	  DASH: 189, // needs localization
	  /**
	   * EQUALS
	   */
	  EQUALS: 187, // needs localization
	  /**
	   * COMMA
	   */
	  COMMA: 188, // needs localization
	  /**
	   * PERIOD
	   */
	  PERIOD: 190, // needs localization
	  /**
	   * SLASH
	   */
	  SLASH: 191, // needs localization
	  /**
	   * APOSTROPHE
	   */
	  APOSTROPHE: 192, // needs localization
	  /**
	   * SINGLE_QUOTE
	   */
	  SINGLE_QUOTE: 222, // needs localization
	  /**
	   * OPEN_SQUARE_BRACKET
	   */
	  OPEN_SQUARE_BRACKET: 219, // needs localization
	  /**
	   * BACKSLASH
	   */
	  BACKSLASH: 220, // needs localization
	  /**
	   * CLOSE_SQUARE_BRACKET
	   */
	  CLOSE_SQUARE_BRACKET: 221, // needs localization
	  /**
	   * WIN_KEY
	   */
	  WIN_KEY: 224,
	  /**
	   * MAC_FF_META
	   */
	  MAC_FF_META: 224, // Firefox (Gecko) fires this for the meta key instead of 91
	  /**
	   * WIN_IME
	   */
	  WIN_IME: 229
	};

	/*
	 whether text and modified key is entered at the same time.
	 */
	KeyCode.isTextModifyingKeyEvent = function (e) {
	  var keyCode = e.keyCode;
	  if (e.altKey && !e.ctrlKey || e.metaKey ||
	  // Function keys don't generate text
	  keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) {
	    return false;
	  }

	  // The following keys are quite harmless, even in combination with
	  // CTRL, ALT or SHIFT.
	  switch (keyCode) {
	    case KeyCode.ALT:
	    case KeyCode.CAPS_LOCK:
	    case KeyCode.CONTEXT_MENU:
	    case KeyCode.CTRL:
	    case KeyCode.DOWN:
	    case KeyCode.END:
	    case KeyCode.ESC:
	    case KeyCode.HOME:
	    case KeyCode.INSERT:
	    case KeyCode.LEFT:
	    case KeyCode.MAC_FF_META:
	    case KeyCode.META:
	    case KeyCode.NUMLOCK:
	    case KeyCode.NUM_CENTER:
	    case KeyCode.PAGE_DOWN:
	    case KeyCode.PAGE_UP:
	    case KeyCode.PAUSE:
	    case KeyCode.PRINT_SCREEN:
	    case KeyCode.RIGHT:
	    case KeyCode.SHIFT:
	    case KeyCode.UP:
	    case KeyCode.WIN_KEY:
	    case KeyCode.WIN_KEY_RIGHT:
	      return false;
	    default:
	      return true;
	  }
	};

	/*
	 whether character is entered.
	 */
	KeyCode.isCharacterKey = function (keyCode) {
	  if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) {
	    return true;
	  }

	  if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) {
	    return true;
	  }

	  if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) {
	    return true;
	  }

	  // Safari sends zero key code for non-latin characters.
	  if (window.navigation.userAgent.indexOf('WebKit') !== -1 && keyCode === 0) {
	    return true;
	  }

	  switch (keyCode) {
	    case KeyCode.SPACE:
	    case KeyCode.QUESTION_MARK:
	    case KeyCode.NUM_PLUS:
	    case KeyCode.NUM_MINUS:
	    case KeyCode.NUM_PERIOD:
	    case KeyCode.NUM_DIVISION:
	    case KeyCode.SEMICOLON:
	    case KeyCode.DASH:
	    case KeyCode.EQUALS:
	    case KeyCode.COMMA:
	    case KeyCode.PERIOD:
	    case KeyCode.SLASH:
	    case KeyCode.APOSTROPHE:
	    case KeyCode.SINGLE_QUOTE:
	    case KeyCode.OPEN_SQUARE_BRACKET:
	    case KeyCode.BACKSLASH:
	    case KeyCode.CLOSE_SQUARE_BRACKET:
	      return true;
	    default:
	      return false;
	  }
	};

		module.exports = KeyCode;

/***/ },
/* 444 */
[790, 445],
/* 445 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule shallowEqual
	 */

	"use strict";

	/**
	 * Performs equality by iterating through keys on an object and returning
	 * false when any key has values which are not strictly equal between
	 * objA and objB. Returns true when the values of all keys are strictly equal.
	 *
	 * @return {boolean}
	 */

	function shallowEqual(objA, objB) {
	  if (objA === objB) {
	    return true;
	  }
	  var key;
	  // Test for A's keys different from B.
	  for (key in objA) {
	    if (objA.hasOwnProperty(key) && (!objB.hasOwnProperty(key) || objA[key] !== objB[key])) {
	      return false;
	    }
	  }
	  // Test for B's keys missing from A.
	  for (key in objB) {
	    if (objB.hasOwnProperty(key) && !objA.hasOwnProperty(key)) {
	      return false;
	    }
	  }
	  return true;
	}

		module.exports = shallowEqual;

/***/ },
/* 446 */
/***/ function(module, exports) {

	"use strict";

	/**
	 * Safe chained function
	 *
	 * Will only create a new function if needed,
	 * otherwise will pass back existing functions or null.
	 *
	 * @returns {function|null}
	 */
	function createChainedFunction() {
	  var args = arguments;

	  return function chainedFunction() {
	    for (var i = 0; i < args.length; i++) {
	      if (args[i] && args[i].apply) {
	        args[i].apply(this, arguments);
	      }
	    }
	  };
	}

		module.exports = createChainedFunction;

/***/ },
/* 447 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function (target, eventType, callback) {
	  if (target.addEventListener) {
	    target.addEventListener(eventType, callback, false);
	    return {
	      remove: function remove() {
	        target.removeEventListener(eventType, callback, false);
	      }
	    };
	  } else if (target.attachEvent) {
	    target.attachEvent('on' + eventType, callback);
	    return {
	      remove: function remove() {
	        target.detachEvent('on' + eventType, callback);
	      }
	    };
	  }
		};

/***/ },
/* 448 */
/***/ function(module, exports) {

	"use strict";

	module.exports = function (root, node) {
	  while (node) {
	    if (node === root) {
	      return true;
	    }
	    node = node.parentNode;
	  }

	  return false;
		};

/***/ },
/* 449 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var React = __webpack_require__(3);

	module.exports = function (children) {
	  var ret = [];
	  React.Children.forEach(children, function (c) {
	    ret.push(c);
	  });
	  return ret;
		};

/***/ },
/* 450 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var React = __webpack_require__(3);

	function mirror(o) {
	  return o;
	}

	module.exports = function (children) {
	  // return ReactFragment
	  return React.Children.map(children, mirror);
		};

/***/ },
/* 451 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ('value' in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	var _get = function get(_x, _x2, _x3) {
	  var _again = true;_function: while (_again) {
	    var object = _x,
	        property = _x2,
	        receiver = _x3;desc = parent = getter = undefined;_again = false;if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
	      var parent = Object.getPrototypeOf(object);if (parent === null) {
	        return undefined;
	      } else {
	        _x = parent;_x2 = property;_x3 = receiver;_again = true;continue _function;
	      }
	    } else if ('value' in desc) {
	      return desc.value;
	    } else {
	      var getter = desc.get;if (getter === undefined) {
	        return undefined;
	      }return getter.call(receiver);
	    }
	  }
	};

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError('Cannot call a class as a function');
	  }
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== 'function' && superClass !== null) {
	    throw new TypeError('Super expression must either be null or a function, not ' + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _DateTHead = __webpack_require__(452);

	var _DateTHead2 = _interopRequireDefault(_DateTHead);

	var _DateTBody = __webpack_require__(454);

	var _DateTBody2 = _interopRequireDefault(_DateTBody);

	var DateTable = function (_React$Component) {
	  _inherits(DateTable, _React$Component);

	  function DateTable() {
	    _classCallCheck(this, DateTable);

	    _get(Object.getPrototypeOf(DateTable.prototype), 'constructor', this).apply(this, arguments);
	  }

	  _createClass(DateTable, [{
	    key: 'render',
	    value: function render() {
	      var props = this.props;
	      var prefixCls = props.prefixCls;
	      return _react2['default'].createElement('table', { className: prefixCls + '-table', cellSpacing: '0', role: 'grid' }, _react2['default'].createElement(_DateTHead2['default'], props), _react2['default'].createElement(_DateTBody2['default'], props));
	    }
	  }]);

	  return DateTable;
	}(_react2['default'].Component);

	exports['default'] = DateTable;
	module.exports = exports['default'];

/***/ },
/* 452 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ('value' in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	var _get = function get(_x, _x2, _x3) {
	  var _again = true;_function: while (_again) {
	    var object = _x,
	        property = _x2,
	        receiver = _x3;desc = parent = getter = undefined;_again = false;if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
	      var parent = Object.getPrototypeOf(object);if (parent === null) {
	        return undefined;
	      } else {
	        _x = parent;_x2 = property;_x3 = receiver;_again = true;continue _function;
	      }
	    } else if ('value' in desc) {
	      return desc.value;
	    } else {
	      var getter = desc.get;if (getter === undefined) {
	        return undefined;
	      }return getter.call(receiver);
	    }
	  }
	};

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError('Cannot call a class as a function');
	  }
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== 'function' && superClass !== null) {
	    throw new TypeError('Super expression must either be null or a function, not ' + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _DateConstants = __webpack_require__(453);

	var _DateConstants2 = _interopRequireDefault(_DateConstants);

	var DateTHead = function (_React$Component) {
	  _inherits(DateTHead, _React$Component);

	  function DateTHead() {
	    _classCallCheck(this, DateTHead);

	    _get(Object.getPrototypeOf(DateTHead.prototype), 'constructor', this).apply(this, arguments);
	  }

	  _createClass(DateTHead, [{
	    key: 'render',
	    value: function render() {
	      var props = this.props;
	      var value = props.value;
	      var locale = props.locale;
	      var prefixCls = props.prefixCls;
	      var veryShortWeekdays = [];
	      var weekDays = [];
	      var firstDayOfWeek = value.getFirstDayOfWeek();
	      var showWeekNumberEl = undefined;

	      for (var i = 0; i < _DateConstants2['default'].DATE_COL_COUNT; i++) {
	        var index = (firstDayOfWeek + i) % _DateConstants2['default'].DATE_COL_COUNT;
	        veryShortWeekdays[i] = locale.format.veryShortWeekdays[index];
	        weekDays[i] = locale.format.weekdays[index];
	      }

	      if (props.showWeekNumber) {
	        showWeekNumberEl = _react2['default'].createElement('th', { role: 'columnheader', className: prefixCls + '-column-header ' + prefixCls + '-week-number-header' }, _react2['default'].createElement('span', { className: prefixCls + '-column-header-inner' }, 'x'));
	      }
	      var weekDaysEls = weekDays.map(function (day, xindex) {
	        return _react2['default'].createElement('th', { key: xindex, role: 'columnheader', title: day, className: prefixCls + '-column-header' }, _react2['default'].createElement('span', { className: prefixCls + '-column-header-inner' }, veryShortWeekdays[xindex]));
	      });
	      return _react2['default'].createElement('thead', null, _react2['default'].createElement('tr', { role: 'row' }, showWeekNumberEl, weekDaysEls));
	    }
	  }]);

	  return DateTHead;
	}(_react2['default'].Component);

	exports['default'] = DateTHead;
	module.exports = exports['default'];

/***/ },
/* 453 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports["default"] = {
	  DATE_ROW_COUNT: 6,
	  DATE_COL_COUNT: 7
	};
		module.exports = exports["default"];

/***/ },
/* 454 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ('value' in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	var _get = function get(_x, _x2, _x3) {
	  var _again = true;_function: while (_again) {
	    var object = _x,
	        property = _x2,
	        receiver = _x3;desc = parent = getter = undefined;_again = false;if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
	      var parent = Object.getPrototypeOf(object);if (parent === null) {
	        return undefined;
	      } else {
	        _x = parent;_x2 = property;_x3 = receiver;_again = true;continue _function;
	      }
	    } else if ('value' in desc) {
	      return desc.value;
	    } else {
	      var getter = desc.get;if (getter === undefined) {
	        return undefined;
	      }return getter.call(receiver);
	    }
	  }
	};

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError('Cannot call a class as a function');
	  }
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== 'function' && superClass !== null) {
	    throw new TypeError('Super expression must either be null or a function, not ' + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _DateConstants = __webpack_require__(453);

	var _DateConstants2 = _interopRequireDefault(_DateConstants);

	function isSameDay(one, two) {
	  return one.getYear() === two.getYear() && one.getMonth() === two.getMonth() && one.getDayOfMonth() === two.getDayOfMonth();
	}

	function beforeCurrentMonthYear(current, today) {
	  if (current.getYear() < today.getYear()) {
	    return 1;
	  }
	  return current.getYear() === today.getYear() && current.getMonth() < today.getMonth();
	}

	function afterCurrentMonthYear(current, today) {
	  if (current.getYear() > today.getYear()) {
	    return 1;
	  }
	  return current.getYear() === today.getYear() && current.getMonth() > today.getMonth();
	}

	function getIdFromDate(d) {
	  return 'rc-calendar-' + d.getYear() + '-' + d.getMonth() + '-' + d.getDayOfMonth();
	}

	function noop() {}

	function handleDayClick(current) {
	  this.props.onSelect(current);
	}

	var DateTBody = function (_React$Component) {
	  _inherits(DateTBody, _React$Component);

	  function DateTBody() {
	    _classCallCheck(this, DateTBody);

	    _get(Object.getPrototypeOf(DateTBody.prototype), 'constructor', this).apply(this, arguments);
	  }

	  _createClass(DateTBody, [{
	    key: 'render',
	    value: function render() {
	      var props = this.props;
	      var i = undefined;
	      var j = undefined;
	      var current = undefined;
	      var dateTable = [];
	      var showWeekNumber = props.showWeekNumber;
	      var value = props.value;
	      var today = value.clone();
	      var prefixCls = props.prefixCls;
	      var cellClass = prefixCls + '-cell';
	      var weekNumberCellClass = prefixCls + '-week-number-cell';
	      var dateClass = prefixCls + '-date';
	      var dateRender = props.dateRender;
	      var disabledDate = props.disabledDate;
	      var dateFormatter = this.props.dateFormatter;
	      var todayClass = prefixCls + '-today';
	      var selectedClass = prefixCls + '-selected-day';
	      var lastMonthDayClass = prefixCls + '-last-month-cell';
	      var nextMonthDayClass = prefixCls + '-next-month-btn-day';
	      var disabledClass = prefixCls + '-disabled-cell';
	      var firstDisableClass = prefixCls + '-disabled-cell-first-of-row';
	      var lastDisableClass = prefixCls + '-disabled-cell-last-of-row';
	      today.setTime(Date.now());
	      var month1 = value.clone();
	      month1.set(value.getYear(), value.getMonth(), 1);
	      var day = month1.getDayOfWeek();
	      var lastMonthDiffDay = (day + 7 - value.getFirstDayOfWeek()) % 7;
	      // calculate last month
	      var lastMonth1 = month1.clone();
	      lastMonth1.addDayOfMonth(0 - lastMonthDiffDay);
	      var passed = 0;
	      for (i = 0; i < _DateConstants2['default'].DATE_ROW_COUNT; i++) {
	        for (j = 0; j < _DateConstants2['default'].DATE_COL_COUNT; j++) {
	          current = lastMonth1;
	          if (passed) {
	            current = current.clone();
	            current.addDayOfMonth(passed);
	          }
	          dateTable.push(current);
	          passed++;
	        }
	      }
	      var tableHtml = [];
	      passed = 0;
	      for (i = 0; i < _DateConstants2['default'].DATE_ROW_COUNT; i++) {
	        var weekNumberCell = undefined;
	        var dateCells = [];
	        if (showWeekNumber) {
	          weekNumberCell = _react2['default'].createElement('td', { key: dateTable[passed].getWeekOfYear(), role: 'gridcell',
	            className: weekNumberCellClass }, dateTable[passed].getWeekOfYear());
	        }
	        for (j = 0; j < _DateConstants2['default'].DATE_COL_COUNT; j++) {
	          var next = null;
	          var last = null;
	          current = dateTable[passed];
	          if (j < _DateConstants2['default'].DATE_COL_COUNT - 1) {
	            next = dateTable[passed + 1];
	          }
	          if (j > 0) {
	            last = dateTable[passed - 1];
	          }
	          var cls = cellClass;
	          var disabled = false;
	          var selected = false;

	          if (isSameDay(current, today)) {
	            cls += ' ' + todayClass;
	          }
	          if (isSameDay(current, value)) {
	            cls += ' ' + selectedClass;
	            selected = true;
	          }
	          if (beforeCurrentMonthYear(current, value)) {
	            cls += ' ' + lastMonthDayClass;
	          }
	          if (afterCurrentMonthYear(current, value)) {
	            cls += ' ' + nextMonthDayClass;
	          }
	          if (disabledDate) {
	            if (disabledDate(current, value)) {
	              cls += ' ' + disabledClass;
	              disabled = true;

	              if (!last || !disabledDate(last, value)) {
	                cls += ' ' + firstDisableClass;
	              }

	              if (!next || !disabledDate(next, value)) {
	                cls += ' ' + lastDisableClass;
	              }
	            }
	          }

	          var dateHtml = undefined;
	          if (dateRender) {
	            dateHtml = dateRender(current, value);
	          } else {
	            dateHtml = _react2['default'].createElement('span', {
	              key: getIdFromDate(current),
	              className: dateClass,
	              'aria-selected': selected,
	              'aria-disabled': disabled }, current.getDayOfMonth());
	          }

	          dateCells.push(_react2['default'].createElement('td', { key: passed, onClick: disabled ? noop : handleDayClick.bind(this, current), role: 'gridcell',
	            title: dateFormatter.format(current), className: cls }, dateHtml));

	          passed++;
	        }
	        tableHtml.push(_react2['default'].createElement('tr', {
	          key: i,
	          role: 'row' }, weekNumberCell, dateCells));
	      }
	      return _react2['default'].createElement('tbody', { className: prefixCls + 'tbody' }, tableHtml);
	    }
	  }]);

	  return DateTBody;
	}(_react2['default'].Component);

	exports['default'] = DateTBody;

	DateTBody.propTypes = {
	  dateFormatter: _react2['default'].PropTypes.object
	};
		module.exports = exports['default'];

/***/ },
/* 455 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ('value' in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	var _get = function get(_x, _x2, _x3) {
	  var _again = true;_function: while (_again) {
	    var object = _x,
	        property = _x2,
	        receiver = _x3;desc = parent = getter = undefined;_again = false;if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
	      var parent = Object.getPrototypeOf(object);if (parent === null) {
	        return undefined;
	      } else {
	        _x = parent;_x2 = property;_x3 = receiver;_again = true;continue _function;
	      }
	    } else if ('value' in desc) {
	      return desc.value;
	    } else {
	      var getter = desc.get;if (getter === undefined) {
	        return undefined;
	      }return getter.call(receiver);
	    }
	  }
	};

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError('Cannot call a class as a function');
	  }
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== 'function' && superClass !== null) {
	    throw new TypeError('Super expression must either be null or a function, not ' + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _monthMonthPanel = __webpack_require__(456);

	var _monthMonthPanel2 = _interopRequireDefault(_monthMonthPanel);

	var _gregorianCalendarFormat = __webpack_require__(432);

	var _gregorianCalendarFormat2 = _interopRequireDefault(_gregorianCalendarFormat);

	var _yearYearPanel = __webpack_require__(457);

	var _yearYearPanel2 = _interopRequireDefault(_yearYearPanel);

	var _rcUtil = __webpack_require__(439);

	var _rcUtil2 = _interopRequireDefault(_rcUtil);

	var toFragment = _rcUtil2['default'].Children.mapSelf;

	var CalendarHeader = function (_React$Component) {
	  _inherits(CalendarHeader, _React$Component);

	  function CalendarHeader(props) {
	    _classCallCheck(this, CalendarHeader);

	    _get(Object.getPrototypeOf(CalendarHeader.prototype), 'constructor', this).call(this, props);
	    this.state = {};
	    this.yearFormatter = new _gregorianCalendarFormat2['default'](props.locale.yearFormat);
	    this.monthFormatter = new _gregorianCalendarFormat2['default'](props.locale.monthFormat);
	    this.showMonthPanel = this.showMonthPanel.bind(this);
	    this.showYearPanel = this.showYearPanel.bind(this);
	    this.onSelect = this.onSelect.bind(this);
	  }

	  _createClass(CalendarHeader, [{
	    key: 'componentWillReceiveProps',
	    value: function componentWillReceiveProps(nextProps) {
	      var locale = this.props.locale;
	      if (nextProps.locale !== locale) {
	        this.yearFormatter = new _gregorianCalendarFormat2['default'](locale.yearFormat);
	        this.monthFormatter = new _gregorianCalendarFormat2['default'](locale.monthFormat);
	      }
	    }
	  }, {
	    key: 'onSelect',
	    value: function onSelect(value) {
	      this.setState({
	        showMonthPanel: 0,
	        showYearPanel: 0
	      });
	      this.props.onValueChange(value);
	    }
	  }, {
	    key: 'getMonthYearElement',
	    value: function getMonthYearElement() {
	      var props = this.props;
	      var prefixCls = props.prefixCls;
	      var locale = props.locale;
	      var value = this.props.value;
	      var monthBeforeYear = locale.monthBeforeYear;
	      var selectClassName = prefixCls + '-' + (monthBeforeYear ? 'my-select' : 'ym-select');
	      var year = _react2['default'].createElement('a', { className: prefixCls + '-year-select',
	        role: 'button',
	        onClick: this.showYearPanel,
	        title: locale.monthSelect }, this.yearFormatter.format(value));
	      var month = _react2['default'].createElement('a', { className: prefixCls + '-month-select',
	        role: 'button',
	        onClick: this.showMonthPanel,
	        title: locale.monthSelect }, this.monthFormatter.format(value));
	      var my = [];
	      if (monthBeforeYear) {
	        my = [month, year];
	      } else {
	        my = [year, month];
	      }
	      return _react2['default'].createElement('span', { className: selectClassName }, toFragment(my));
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var props = this.props;
	      var state = this.state;
	      var prefixCls = props.prefixCls;
	      var locale = props.locale;
	      var value = props.value;
	      var PanelClass = null;
	      if (state.showMonthPanel) {
	        PanelClass = _monthMonthPanel2['default'];
	      } else if (state.showYearPanel) {
	        PanelClass = _yearYearPanel2['default'];
	      }
	      var panel = undefined;
	      if (PanelClass) {
	        panel = _react2['default'].createElement(PanelClass, { locale: locale, defaultValue: value, rootPrefixCls: prefixCls, onSelect: this.onSelect });
	      }
	      return _react2['default'].createElement('div', { className: prefixCls + '-header' }, _react2['default'].createElement('a', { className: prefixCls + '-prev-year-btn',
	        role: 'button',
	        onClick: props.previousYear,
	        title: locale.previousYear }, '«'), _react2['default'].createElement('a', { className: prefixCls + '-prev-month-btn',
	        role: 'button',
	        onClick: props.previousMonth,
	        title: locale.previousMonth }, '‹'), this.getMonthYearElement(), _react2['default'].createElement('a', { className: prefixCls + '-next-month-btn',
	        onClick: props.nextMonth,
	        title: locale.nextMonth }, '›'), _react2['default'].createElement('a', { className: prefixCls + '-next-year-btn',
	        onClick: props.nextYear,
	        title: locale.nextYear }, '»'), panel);
	    }
	  }, {
	    key: 'showMonthPanel',
	    value: function showMonthPanel() {
	      this.setState({
	        showMonthPanel: 1,
	        showYearPanel: 0
	      });
	    }
	  }, {
	    key: 'showYearPanel',
	    value: function showYearPanel() {
	      this.setState({
	        showMonthPanel: 0,
	        showYearPanel: 1
	      });
	    }
	  }]);

	  return CalendarHeader;
	}(_react2['default'].Component);

	exports['default'] = CalendarHeader;

	CalendarHeader.propTypes = {
	  locale: _react2['default'].PropTypes.object,
	  value: _react2['default'].PropTypes.object,
	  onValueChange: _react2['default'].PropTypes.func
	};
		module.exports = exports['default'];

/***/ },
/* 456 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	  } else {
	    obj[key] = value;
	  }return obj;
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _rcUtil = __webpack_require__(439);

	var _yearYearPanel = __webpack_require__(457);

	var _yearYearPanel2 = _interopRequireDefault(_yearYearPanel);

	var ROW = 4;
	var COL = 3;

	function goYear(direction) {
	  var next = this.state.value.clone();
	  next.addYear(direction);
	  this.setAndChangeValue(next);
	}

	function chooseMonth(month) {
	  var next = this.state.value.clone();
	  next.setMonth(month);
	  this.setAndSelectValue(next);
	}

	function noop() {}

	var MonthPanel = _react2['default'].createClass({
	  displayName: 'MonthPanel',

	  propTypes: {
	    onChange: _react2['default'].PropTypes.func,
	    onSelect: _react2['default'].PropTypes.func
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      onChange: noop,
	      onSelect: noop
	    };
	  },

	  getInitialState: function getInitialState() {
	    var props = this.props;
	    // bind methods
	    this.nextYear = goYear.bind(this, 1);
	    this.previousYear = goYear.bind(this, -1);
	    this.prefixCls = props.rootPrefixCls + '-month-panel';
	    return {
	      value: props.value || props.defaultValue
	    };
	  },

	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    if ('value' in nextProps) {
	      this.setState({
	        value: nextProps.value
	      });
	    }
	  },

	  onYearPanelSelect: function onYearPanelSelect(current) {
	    this.setState({
	      showYearPanel: 0
	    });
	    this.setAndChangeValue(current);
	  },

	  getMonths: function getMonths() {
	    var props = this.props;
	    var value = this.state.value;
	    var current = value.clone();
	    var locale = props.locale;
	    var months = [];
	    var shortMonths = locale.format.shortMonths;
	    var index = 0;
	    for (var i = 0; i < ROW; i++) {
	      months[i] = [];
	      for (var j = 0; j < COL; j++) {
	        current.setMonth(index);
	        months[i][j] = {
	          value: index,
	          content: shortMonths[index],
	          title: shortMonths[index]
	        };
	        index++;
	      }
	    }

	    return months;
	  },

	  render: function render() {
	    var _this = this;

	    var props = this.props;
	    var value = this.state.value;
	    var locale = props.locale;
	    var months = this.getMonths();
	    var year = value.getYear();
	    var currentMonth = value.getMonth();
	    var prefixCls = this.prefixCls;
	    var monthsEls = months.map(function (month, index) {
	      var tds = month.map(function (m) {
	        var _classNameMap;

	        var disabled = false;
	        if (props.disabledDate) {
	          var testValue = value.clone();
	          testValue.setMonth(m.value);
	          disabled = props.disabledDate(testValue);
	        }
	        var classNameMap = (_classNameMap = {}, _defineProperty(_classNameMap, prefixCls + '-cell', 1), _defineProperty(_classNameMap, prefixCls + '-cell-disabled', disabled), _defineProperty(_classNameMap, prefixCls + '-selected-cell', m.value === currentMonth), _classNameMap);
	        return _react2['default'].createElement('td', { role: 'gridcell',
	          key: m.value,
	          onClick: disabled ? null : chooseMonth.bind(_this, m.value),
	          title: m.title,
	          className: (0, _rcUtil.classSet)(classNameMap) }, _react2['default'].createElement('a', {
	          className: prefixCls + '-month' }, m.content));
	      });
	      return _react2['default'].createElement('tr', { key: index, role: 'row' }, tds);
	    });

	    var yearPanel = undefined;
	    if (this.state.showYearPanel) {
	      yearPanel = _react2['default'].createElement(_yearYearPanel2['default'], { locale: locale, value: value, rootPrefixCls: props.rootPrefixCls,
	        onSelect: this.onYearPanelSelect });
	    }

	    return _react2['default'].createElement('div', { className: prefixCls, style: props.style }, _react2['default'].createElement('div', null, _react2['default'].createElement('div', { className: prefixCls + '-header' }, _react2['default'].createElement('a', { className: prefixCls + '-prev-year-btn',
	      role: 'button',
	      onClick: this.previousYear,
	      title: locale.previousYear }, '«'), _react2['default'].createElement('a', { className: prefixCls + '-year-select',
	      role: 'button',
	      onClick: this.showYearPanel,
	      title: locale.yearSelect }, _react2['default'].createElement('span', { className: prefixCls + '-year-select-content' }, year), _react2['default'].createElement('span', { className: prefixCls + '-year-select-arrow' }, 'x')), _react2['default'].createElement('a', { className: prefixCls + '-next-year-btn',
	      role: 'button',
	      onClick: this.nextYear,
	      title: locale.nextYear }, '»')), _react2['default'].createElement('div', { className: prefixCls + '-body' }, _react2['default'].createElement('table', { className: prefixCls + '-table', cellSpacing: '0', role: 'grid' }, _react2['default'].createElement('tbody', { className: prefixCls + '-tbody' }, monthsEls)))), yearPanel);
	  },

	  setAndChangeValue: function setAndChangeValue(value) {
	    this.setValue(value);
	    this.props.onChange(value);
	  },

	  setAndSelectValue: function setAndSelectValue(value) {
	    this.setValue(value);
	    this.props.onSelect(value);
	  },

	  setValue: function setValue(value) {
	    if (!('value' in this.props)) {
	      this.setState({
	        value: value
	      });
	    }
	  },

	  showYearPanel: function showYearPanel() {
	    this.setState({
	      showYearPanel: 1
	    });
	  }
	});

	exports['default'] = MonthPanel;
	module.exports = exports['default'];

/***/ },
/* 457 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ('value' in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	var _get = function get(_x, _x2, _x3) {
	  var _again = true;_function: while (_again) {
	    var object = _x,
	        property = _x2,
	        receiver = _x3;desc = parent = getter = undefined;_again = false;if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
	      var parent = Object.getPrototypeOf(object);if (parent === null) {
	        return undefined;
	      } else {
	        _x = parent;_x2 = property;_x3 = receiver;_again = true;continue _function;
	      }
	    } else if ('value' in desc) {
	      return desc.value;
	    } else {
	      var getter = desc.get;if (getter === undefined) {
	        return undefined;
	      }return getter.call(receiver);
	    }
	  }
	};

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	  } else {
	    obj[key] = value;
	  }return obj;
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError('Cannot call a class as a function');
	  }
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== 'function' && superClass !== null) {
	    throw new TypeError('Super expression must either be null or a function, not ' + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _rcUtil = __webpack_require__(439);

	var _decadeDecadePanel = __webpack_require__(458);

	var _decadeDecadePanel2 = _interopRequireDefault(_decadeDecadePanel);

	var ROW = 4;
	var COL = 3;

	function goYear(direction) {
	  var next = this.state.value.clone();
	  next.addYear(direction);
	  this.setState({ value: next });
	}

	function chooseYear(year) {
	  var next = this.state.value.clone();
	  next.setYear(year);
	  this.props.onSelect(next);
	}

	var YearPanel = function (_React$Component) {
	  _inherits(YearPanel, _React$Component);

	  function YearPanel(props) {
	    var _this = this;

	    _classCallCheck(this, YearPanel);

	    _get(Object.getPrototypeOf(YearPanel.prototype), 'constructor', this).call(this, props);
	    this.prefixCls = props.rootPrefixCls + '-year-panel';
	    this.state = {
	      value: props.value || props.defaultValue
	    };
	    this.nextDecade = goYear.bind(this, 10);
	    this.previousDecade = goYear.bind(this, -10);
	    ['showDecadePanel', 'onDecadePanelSelect'].forEach(function (m) {
	      _this[m] = _this[m].bind(_this);
	    });
	  }

	  _createClass(YearPanel, [{
	    key: 'onDecadePanelSelect',
	    value: function onDecadePanelSelect(current) {
	      this.setState({
	        value: current,
	        showDecadePanel: 0
	      });
	    }
	  }, {
	    key: 'getYears',
	    value: function getYears() {
	      var value = this.state.value;
	      var currentYear = value.getYear();
	      var startYear = parseInt(currentYear / 10, 10) * 10;
	      var previousYear = startYear - 1;
	      var endYear = startYear + 9;
	      var years = [];
	      var index = 0;
	      for (var i = 0; i < ROW; i++) {
	        years[i] = [];
	        for (var j = 0; j < COL; j++) {
	          var year = previousYear + index;
	          var content = undefined;
	          if (year < startYear) {
	            content = '';
	          } else if (year > endYear) {
	            content = '';
	          } else {
	            content = year + '';
	          }
	          years[i][j] = {
	            content: content,
	            year: year,
	            title: content
	          };
	          index++;
	        }
	      }
	      return years;
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this2 = this;

	      var props = this.props;
	      var value = this.state.value;
	      var locale = props.locale;
	      var years = this.getYears();
	      var currentYear = value.getYear();
	      var startYear = parseInt(currentYear / 10, 10) * 10;
	      var endYear = startYear + 9;
	      var prefixCls = this.prefixCls;

	      var yeasEls = years.map(function (row, index) {
	        var tds = row.map(function (y) {
	          var _classNameMap;

	          var classNameMap = (_classNameMap = {}, _defineProperty(_classNameMap, prefixCls + '-cell', 1), _defineProperty(_classNameMap, prefixCls + '-selected-cell', y.year === currentYear), _defineProperty(_classNameMap, prefixCls + '-last-decade-cell', y.year < startYear), _defineProperty(_classNameMap, prefixCls + '-next-decade-cell', y.year > endYear), _classNameMap);
	          var clickHandler = undefined;
	          if (y.year < startYear) {
	            clickHandler = _this2.previousDecade;
	          } else if (y.year > endYear) {
	            clickHandler = _this2.nextDecade;
	          } else {
	            clickHandler = chooseYear.bind(_this2, y.year);
	          }
	          return _react2['default'].createElement('td', { role: 'gridcell',
	            title: y.title,
	            key: y.content,
	            onClick: clickHandler,
	            className: (0, _rcUtil.classSet)(classNameMap)
	          }, _react2['default'].createElement('a', {
	            className: prefixCls + '-year' }, y.content));
	        });
	        return _react2['default'].createElement('tr', { key: index, role: 'row' }, tds);
	      });

	      var decadePanel = undefined;
	      if (this.state.showDecadePanel) {
	        decadePanel = _react2['default'].createElement(_decadeDecadePanel2['default'], { locale: locale, value: value, rootPrefixCls: props.rootPrefixCls,
	          onSelect: this.onDecadePanelSelect });
	      }

	      return _react2['default'].createElement('div', { className: this.prefixCls }, _react2['default'].createElement('div', null, _react2['default'].createElement('div', { className: prefixCls + '-header' }, _react2['default'].createElement('a', { className: prefixCls + '-prev-decade-btn',
	        role: 'button',
	        onClick: this.previousDecade,
	        title: locale.previousDecade }, '«'), _react2['default'].createElement('a', { className: prefixCls + '-decade-select',
	        role: 'button',
	        onClick: this.showDecadePanel,
	        title: locale.decadeSelect }, _react2['default'].createElement('span', { className: prefixCls + '-decade-select-content' }, startYear, '-', endYear), _react2['default'].createElement('span', { className: prefixCls + '-decade-select-arrow' }, 'x')), _react2['default'].createElement('a', { className: prefixCls + '-next-decade-btn',
	        role: 'button',
	        onClick: this.nextDecade,
	        title: locale.nextDecade }, '»')), _react2['default'].createElement('div', { className: prefixCls + '-body' }, _react2['default'].createElement('table', { className: prefixCls + '-table', cellSpacing: '0', role: 'grid' }, _react2['default'].createElement('tbody', { className: prefixCls + '-tbody' }, yeasEls)))), decadePanel);
	    }
	  }, {
	    key: 'showDecadePanel',
	    value: function showDecadePanel() {
	      this.setState({
	        showDecadePanel: 1
	      });
	    }
	  }]);

	  return YearPanel;
	}(_react2['default'].Component);

	exports['default'] = YearPanel;

	YearPanel.defaultProps = {
	  onSelect: function onSelect() {}
	};
		module.exports = exports['default'];

/***/ },
/* 458 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ('value' in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	var _get = function get(_x, _x2, _x3) {
	  var _again = true;_function: while (_again) {
	    var object = _x,
	        property = _x2,
	        receiver = _x3;desc = parent = getter = undefined;_again = false;if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
	      var parent = Object.getPrototypeOf(object);if (parent === null) {
	        return undefined;
	      } else {
	        _x = parent;_x2 = property;_x3 = receiver;_again = true;continue _function;
	      }
	    } else if ('value' in desc) {
	      return desc.value;
	    } else {
	      var getter = desc.get;if (getter === undefined) {
	        return undefined;
	      }return getter.call(receiver);
	    }
	  }
	};

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	  } else {
	    obj[key] = value;
	  }return obj;
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError('Cannot call a class as a function');
	  }
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== 'function' && superClass !== null) {
	    throw new TypeError('Super expression must either be null or a function, not ' + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _rcUtil = __webpack_require__(439);

	var ROW = 4;
	var COL = 3;

	function goYear(direction) {
	  var next = this.state.value.clone();
	  next.addYear(direction);
	  this.setState({
	    value: next
	  });
	}

	function chooseDecade(year, e) {
	  var next = this.state.value.clone();
	  next.setYear(year);
	  this.props.onSelect(next);
	  e.preventDefault();
	}

	var DecadePanel = function (_React$Component) {
	  _inherits(DecadePanel, _React$Component);

	  function DecadePanel(props) {
	    _classCallCheck(this, DecadePanel);

	    _get(Object.getPrototypeOf(DecadePanel.prototype), 'constructor', this).call(this, props);
	    this.state = {
	      value: props.value || props.defaultValue
	    };

	    // bind methods
	    this.prefixCls = props.rootPrefixCls + '-decade-panel';
	    this.nextCentury = goYear.bind(this, 100);
	    this.previousCentury = goYear.bind(this, -100);
	  }

	  _createClass(DecadePanel, [{
	    key: 'render',
	    value: function render() {
	      var _this = this;

	      var value = this.state.value;
	      var locale = this.props.locale;
	      var currentYear = value.getYear();
	      var startYear = parseInt(currentYear / 100, 10) * 100;
	      var preYear = startYear - 10;
	      var endYear = startYear + 99;
	      var decades = [];
	      var index = 0;
	      var prefixCls = this.prefixCls;

	      for (var i = 0; i < ROW; i++) {
	        decades[i] = [];
	        for (var j = 0; j < COL; j++) {
	          var startDecade = preYear + index * 10;
	          var endDecade = preYear + index * 10 + 9;
	          decades[i][j] = {
	            startDecade: startDecade,
	            endDecade: endDecade
	          };
	          index++;
	        }
	      }

	      var decadesEls = decades.map(function (row, decadeIndex) {
	        var tds = row.map(function (d) {
	          var _classNameMap;

	          var dStartDecade = d.startDecade;
	          var dEndDecade = d.endDecade;
	          var isLast = dStartDecade < startYear;
	          var isNext = dEndDecade > endYear;
	          var classNameMap = (_classNameMap = {}, _defineProperty(_classNameMap, prefixCls + '-cell', 1), _defineProperty(_classNameMap, prefixCls + '-selected-cell', dStartDecade <= currentYear && currentYear <= dEndDecade), _defineProperty(_classNameMap, prefixCls + '-last-century-cell', isLast), _defineProperty(_classNameMap, prefixCls + '-next-century-cell', isNext), _classNameMap);
	          var content = undefined;
	          var clickHandler = undefined;
	          if (isLast) {
	            clickHandler = _this.previousCentury;
	          } else if (isNext) {
	            clickHandler = _this.nextCentury;
	          } else {
	            content = dStartDecade + '-' + dEndDecade;
	            clickHandler = chooseDecade.bind(_this, dStartDecade);
	          }
	          return _react2['default'].createElement('td', {
	            key: dStartDecade,
	            onClick: clickHandler,
	            role: 'gridcell',
	            className: (0, _rcUtil.classSet)(classNameMap)
	          }, _react2['default'].createElement('a', {
	            className: prefixCls + '-decade' }, content));
	        });
	        return _react2['default'].createElement('tr', { key: decadeIndex, role: 'row' }, tds);
	      });

	      return _react2['default'].createElement('div', { className: this.prefixCls }, _react2['default'].createElement('div', { className: prefixCls + '-header' }, _react2['default'].createElement('a', { className: prefixCls + '-prev-century-btn',
	        role: 'button',
	        onClick: this.previousCentury,
	        title: locale.previousCentury }, '«'), _react2['default'].createElement('div', { className: prefixCls + '-century' }, startYear, '-', endYear), _react2['default'].createElement('a', { className: prefixCls + '-next-century-btn',
	        role: 'button',
	        onClick: this.nextCentury,
	        title: locale.nextCentury }, '»')), _react2['default'].createElement('div', { className: prefixCls + '-body' }, _react2['default'].createElement('table', { className: prefixCls + '-table', cellSpacing: '0', role: 'grid' }, _react2['default'].createElement('tbody', { className: prefixCls + '-tbody' }, decadesEls))));
	    }
	  }]);

	  return DecadePanel;
	}(_react2['default'].Component);

	exports['default'] = DecadePanel;

	DecadePanel.propTypes = {
	  locale: _react2['default'].PropTypes.object
	};

	DecadePanel.defaultProps = {
	  onSelect: function onSelect() {}
	};
		module.exports = exports['default'];

/***/ },
/* 459 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ('value' in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	var _get = function get(_x, _x2, _x3) {
	  var _again = true;_function: while (_again) {
	    var object = _x,
	        property = _x2,
	        receiver = _x3;desc = parent = getter = undefined;_again = false;if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
	      var parent = Object.getPrototypeOf(object);if (parent === null) {
	        return undefined;
	      } else {
	        _x = parent;_x2 = property;_x3 = receiver;_again = true;continue _function;
	      }
	    } else if ('value' in desc) {
	      return desc.value;
	    } else {
	      var getter = desc.get;if (getter === undefined) {
	        return undefined;
	      }return getter.call(receiver);
	    }
	  }
	};

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError('Cannot call a class as a function');
	  }
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== 'function' && superClass !== null) {
	    throw new TypeError('Super expression must either be null or a function, not ' + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _timeTime = __webpack_require__(460);

	var _timeTime2 = _interopRequireDefault(_timeTime);

	var _rcUtil = __webpack_require__(439);

	var _rcUtil2 = _interopRequireDefault(_rcUtil);

	var toFragment = _rcUtil2['default'].Children.mapSelf;

	var CalendarFooter = function (_React$Component) {
	  _inherits(CalendarFooter, _React$Component);

	  function CalendarFooter() {
	    _classCallCheck(this, CalendarFooter);

	    _get(Object.getPrototypeOf(CalendarFooter.prototype), 'constructor', this).apply(this, arguments);
	  }

	  _createClass(CalendarFooter, [{
	    key: 'getTodayTimeStr',
	    value: function getTodayTimeStr() {
	      var today = this.getTodayTime();
	      return this.props.dateFormatter.format(today);
	    }
	  }, {
	    key: 'getTodayTime',
	    value: function getTodayTime() {
	      var value = this.props.value;
	      var today = value.clone();
	      today.setTime(Date.now());
	      return today;
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var props = this.props;
	      var value = props.value;
	      var locale = props.locale;
	      var prefixCls = props.prefixCls;
	      var footerEl = null;
	      if (props.showToday || props.showTime) {
	        var nowEl = undefined;
	        var localeNow = locale.today;
	        if (props.showTime) {
	          localeNow = locale.now || locale.today;
	        }
	        if (props.showToday) {
	          var disabledToday = false;
	          var disabledTodayClass = '';
	          if (props.disabledDate) {
	            disabledToday = props.disabledDate(this.getTodayTime(), value);
	            if (disabledToday) {
	              disabledTodayClass = prefixCls + '-today-btn-disabled';
	            }
	          }
	          nowEl = _react2['default'].createElement('a', { className: prefixCls + '-today-btn ' + disabledTodayClass,
	            role: 'button',
	            onClick: disabledToday ? null : props.onToday,
	            title: this.getTodayTimeStr() }, localeNow);
	        }
	        var clearEl = undefined;
	        if (props.showClear) {
	          clearEl = _react2['default'].createElement('a', { className: prefixCls + '-clear-btn',
	            role: 'button',
	            onClick: props.onClear }, locale.clear);
	        }
	        var okBtn = undefined;
	        if (props.showOk) {
	          okBtn = _react2['default'].createElement('a', { className: prefixCls + '-ok-btn',
	            role: 'button',
	            onClick: props.onOk }, locale.ok);
	        }
	        var footerBtn = undefined;
	        if (nowEl || clearEl) {
	          footerBtn = _react2['default'].createElement('span', { className: prefixCls + '-footer-btn' }, toFragment([nowEl, okBtn, clearEl]));
	        }
	        var timeEl = undefined;
	        if (props.showTime) {
	          timeEl = _react2['default'].createElement(_timeTime2['default'], { value: value, prefixCls: prefixCls, locale: locale, onChange: props.onSelect });
	        }
	        footerEl = _react2['default'].createElement('div', { className: prefixCls + '-footer' }, timeEl, footerBtn);
	      }

	      return footerEl;
	    }
	  }]);

	  return CalendarFooter;
	}(_react2['default'].Component);

	exports['default'] = CalendarFooter;
	module.exports = exports['default'];

/***/ },
/* 460 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ('value' in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	var _get = function get(_x, _x2, _x3) {
	  var _again = true;_function: while (_again) {
	    var object = _x,
	        property = _x2,
	        receiver = _x3;desc = parent = getter = undefined;_again = false;if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
	      var parent = Object.getPrototypeOf(object);if (parent === null) {
	        return undefined;
	      } else {
	        _x = parent;_x2 = property;_x3 = receiver;_again = true;continue _function;
	      }
	    } else if ('value' in desc) {
	      return desc.value;
	    } else {
	      var getter = desc.get;if (getter === undefined) {
	        return undefined;
	      }return getter.call(receiver);
	    }
	  }
	};

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError('Cannot call a class as a function');
	  }
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== 'function' && superClass !== null) {
	    throw new TypeError('Super expression must either be null or a function, not ' + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _rcUtil = __webpack_require__(439);

	var _rcUtil2 = _interopRequireDefault(_rcUtil);

	var _TimePanel = __webpack_require__(461);

	var _TimePanel2 = _interopRequireDefault(_TimePanel);

	var setHourOfDay = 'setHourOfDay';
	var setMinutes = 'setMinutes';
	var setSeconds = 'setSeconds';

	function padding(number) {
	  var ret = number;
	  if (ret < 10) {
	    ret = '0' + ret;
	  }
	  return ret;
	}

	function loop(value, min, max) {
	  var ret = value;
	  if (ret === min - 1) {
	    ret = max;
	  } else if (ret === max + 1) {
	    ret = min;
	  }
	  return ret;
	}

	function keyDownWrap(method, min, max) {
	  return function onKeyDown(e) {
	    var value = e.target.value;
	    var number = parseInt(value, 10);
	    var keyCode = e.keyCode;
	    var handled = undefined;
	    if (keyCode === _rcUtil.KeyCode.DOWN) {
	      number++;
	      e.stopPropagation();
	      e.preventDefault();
	      handled = 1;
	    } else if (keyCode === _rcUtil.KeyCode.UP) {
	      number--;
	      e.stopPropagation();
	      e.preventDefault();
	      handled = 1;
	    }
	    if (handled) {
	      number = loop(number, min, max);
	      var time = this.props.value.clone();
	      time[method](number);
	      this.props.onChange(time, e);
	    }
	  };
	}

	var Time = function (_React$Component) {
	  _inherits(Time, _React$Component);

	  function Time(props) {
	    var _this = this;

	    _classCallCheck(this, Time);

	    _get(Object.getPrototypeOf(Time.prototype), 'constructor', this).call(this, props);
	    this.state = {
	      showHourPanel: 0,
	      showMinutePanel: 0,
	      showSecondPanel: 0
	    };
	    var events = ['onHourKeyDown', 'onMinuteKeyDown', 'onSecondKeyDown', 'onHourClick', 'onMinuteClick', 'onSecondClick', 'onSelectPanel'];
	    events.forEach(function (m) {
	      _this[m] = _this[m].bind(_this);
	    });
	  }

	  _createClass(Time, [{
	    key: 'shouldComponentUpdate',
	    value: function shouldComponentUpdate() {
	      return _rcUtil2['default'].PureRenderMixin.shouldComponentUpdate.apply(this, arguments);
	    }
	  }, {
	    key: 'onSelectPanel',
	    value: function onSelectPanel(value, setter) {
	      var _this2 = this;

	      this.setState({
	        showHourPanel: 0,
	        showMinutePanel: 0,
	        showSecondPanel: 0
	      }, function () {
	        // ie9 has broken focus
	        _react2['default'].findDOMNode(_this2.refs[setter]).focus();
	      });
	      this.props.onChange(value);
	    }
	  }, {
	    key: 'onHourClick',
	    value: function onHourClick() {
	      this.setState({
	        showHourPanel: 1,
	        showMinutePanel: 0,
	        showSecondPanel: 0
	      });
	    }
	  }, {
	    key: 'onMinuteClick',
	    value: function onMinuteClick() {
	      this.setState({
	        showHourPanel: 0,
	        showMinutePanel: 1,
	        showSecondPanel: 0
	      });
	    }
	  }, {
	    key: 'onSecondClick',
	    value: function onSecondClick() {
	      this.setState({
	        showHourPanel: 0,
	        showMinutePanel: 0,
	        showSecondPanel: 1
	      });
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var state = this.state;
	      var props = this.props;
	      var prefixCls = props.prefixCls;
	      var value = props.value;
	      var locale = props.locale;
	      var hour = value.getHourOfDay();
	      var minute = value.getMinutes();
	      var second = value.getSeconds();
	      var panel = undefined;
	      var commonProps = {
	        value: value,
	        onSelect: this.onSelectPanel,
	        rootPrefixCls: prefixCls
	      };
	      if (state.showHourPanel) {
	        panel = _react2['default'].createElement(_TimePanel2['default'], _extends({ rowCount: 6, colCount: 4, getter: 'getHourOfDay', setter: setHourOfDay,
	          title: locale.hourPanelTitle
	        }, commonProps));
	      } else if (state.showMinutePanel) {
	        panel = _react2['default'].createElement(_TimePanel2['default'], _extends({ rowCount: 6, colCount: 10, getter: 'getMinutes', setter: setMinutes,
	          title: locale.minutePanelTitle
	        }, commonProps));
	      } else if (state.showSecondPanel) {
	        panel = _react2['default'].createElement(_TimePanel2['default'], _extends({ rowCount: 6, colCount: 10, getter: 'getSeconds', setter: setSeconds,
	          title: locale.secondPanelTitle
	        }, commonProps));
	      }
	      return _react2['default'].createElement('span', { className: prefixCls + '-time' }, _react2['default'].createElement('input', { className: prefixCls + '-time-input',
	        title: locale.hourInput,
	        ref: setHourOfDay,
	        readOnly: true,
	        value: padding(hour),
	        onClick: this.onHourClick,
	        onKeyDown: this.onHourKeyDown }), _react2['default'].createElement('span', { className: prefixCls + '-time-minute' }, _react2['default'].createElement('span', null, ' : '), _react2['default'].createElement('input', { className: prefixCls + '-time-input',
	        title: locale.minuteInput,
	        ref: setMinutes,
	        readOnly: true,
	        value: padding(minute),
	        onClick: this.onMinuteClick,
	        onKeyDown: this.onMinuteKeyDown })), _react2['default'].createElement('span', { className: prefixCls + '-time-second' }, _react2['default'].createElement('span', null, ' : '), _react2['default'].createElement('input', { className: prefixCls + '-time-input',
	        title: locale.secondInput,
	        ref: setSeconds,
	        readOnly: true,
	        value: padding(second),
	        onClick: this.onSecondClick,
	        onKeyDown: this.onSecondKeyDown })), panel);
	    }
	  }]);

	  return Time;
	}(_react2['default'].Component);

	exports['default'] = Time;

	Time.prototype.onHourKeyDown = keyDownWrap('setHourOfDay', 0, 23);
	Time.prototype.onMinuteKeyDown = keyDownWrap('setMinutes', 0, 59);
	Time.prototype.onSecondKeyDown = keyDownWrap('setSeconds', 0, 59);

	Time.propTypes = {
	  onChange: _react2['default'].PropTypes.func
	};

	Time.defaultProps = {
	  onChange: function onChange() {}
	};
		module.exports = exports['default'];

/***/ },
/* 461 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ('value' in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	var _get = function get(_x, _x2, _x3) {
	  var _again = true;_function: while (_again) {
	    var object = _x,
	        property = _x2,
	        receiver = _x3;desc = parent = getter = undefined;_again = false;if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
	      var parent = Object.getPrototypeOf(object);if (parent === null) {
	        return undefined;
	      } else {
	        _x = parent;_x2 = property;_x3 = receiver;_again = true;continue _function;
	      }
	    } else if ('value' in desc) {
	      return desc.value;
	    } else {
	      var getter = desc.get;if (getter === undefined) {
	        return undefined;
	      }return getter.call(receiver);
	    }
	  }
	};

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	  } else {
	    obj[key] = value;
	  }return obj;
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError('Cannot call a class as a function');
	  }
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== 'function' && superClass !== null) {
	    throw new TypeError('Super expression must either be null or a function, not ' + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _rcUtil = __webpack_require__(439);

	function choose(hour, e) {
	  var next = this.state.value.clone();
	  var method = this.props.setter;
	  next[method](hour);
	  this.props.onSelect(next, method);
	  e.preventDefault();
	}

	var TimePanel = function (_React$Component) {
	  _inherits(TimePanel, _React$Component);

	  function TimePanel(props) {
	    _classCallCheck(this, TimePanel);

	    _get(Object.getPrototypeOf(TimePanel.prototype), 'constructor', this).call(this, props);
	    this.state = {
	      value: props.value
	    };
	    this.prefixCls = props.rootPrefixCls + '-time-panel';
	  }

	  _createClass(TimePanel, [{
	    key: 'render',
	    value: function render() {
	      var _this = this;

	      var value = this.state.value;
	      var props = this.props;
	      var method = props.getter;
	      var currentHour = value[method]();
	      var data = [];
	      var prefixCls = this.prefixCls;
	      var ROW = props.rowCount;
	      var COL = props.colCount;

	      for (var i = 0; i < ROW; i++) {
	        data[i] = [];
	        for (var j = 0; j < COL; j++) {
	          data[i][j] = i * COL + j;
	        }
	      }

	      var hoursEls = data.map(function (row, index) {
	        var tds = row.map(function (d) {
	          var _classNameMap;

	          var classNameMap = (_classNameMap = {}, _defineProperty(_classNameMap, prefixCls + '-cell', 1), _defineProperty(_classNameMap, prefixCls + '-selected-cell', d === currentHour), _classNameMap);
	          return _react2['default'].createElement('td', {
	            key: d,
	            onClick: choose.bind(_this, d),
	            role: 'gridcell',
	            className: (0, _rcUtil.classSet)(classNameMap) }, _react2['default'].createElement('a', {
	            className: prefixCls + '-time' }, d));
	        });
	        return _react2['default'].createElement('tr', { key: index, role: 'row' }, tds);
	      });

	      return _react2['default'].createElement('div', { className: prefixCls }, _react2['default'].createElement('div', { className: prefixCls + '-header' }, _react2['default'].createElement('div', { className: prefixCls + '-title' }, props.title)), _react2['default'].createElement('div', { className: prefixCls + '-body' }, _react2['default'].createElement('table', { className: prefixCls + '-table', cellSpacing: '0', role: 'grid' }, _react2['default'].createElement('tbody', { className: prefixCls + '-tbody' }, hoursEls))));
	    }
	  }]);

	  return TimePanel;
	}(_react2['default'].Component);

	exports['default'] = TimePanel;

	TimePanel.defaultProps = {
	  onSelect: function onSelect() {}
	};
		module.exports = exports['default'];

/***/ },
/* 462 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	  } else {
	    obj[key] = value;
	  }return obj;
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _localeEnUs = __webpack_require__(463);

	var _localeEnUs2 = _interopRequireDefault(_localeEnUs);

	var _rcUtil = __webpack_require__(439);

	var _gregorianCalendar = __webpack_require__(434);

	var _gregorianCalendar2 = _interopRequireDefault(_gregorianCalendar);

	function noop() {}

	function getNow() {
	  var value = new _gregorianCalendar2['default']();
	  value.setTime(Date.now());
	  return value;
	}

	function getNowByCurrentStateValue(value) {
	  var ret = undefined;
	  if (value) {
	    ret = value.clone();
	    ret.setTime(Date.now());
	  } else {
	    ret = getNow();
	  }
	  return ret;
	}

	var CalendarMixin = {
	  propTypes: {
	    value: _react2['default'].PropTypes.object,
	    defaultValue: _react2['default'].PropTypes.object,
	    className: _react2['default'].PropTypes.string,
	    orient: _react2['default'].PropTypes.arrayOf(_react2['default'].PropTypes.oneOf(['left', 'top', 'right', 'bottom'])),
	    locale: _react2['default'].PropTypes.object,
	    style: _react2['default'].PropTypes.object,
	    visible: _react2['default'].PropTypes.bool,
	    onSelect: _react2['default'].PropTypes.func,
	    prefixCls: _react2['default'].PropTypes.string,
	    onKeyDown: _react2['default'].PropTypes.func,
	    onChange: _react2['default'].PropTypes.func,
	    onFocus: _react2['default'].PropTypes.func,
	    onBlur: _react2['default'].PropTypes.func
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      locale: _localeEnUs2['default'],
	      style: {},
	      visible: true,
	      prefixCls: 'rc-calendar',
	      className: '',
	      onKeyDown: noop,
	      onSelect: noop,
	      onChange: noop,
	      onFocus: noop,
	      onBlur: noop
	    };
	  },

	  getInitialState: function getInitialState() {
	    var props = this.props;
	    var value = props.value || props.defaultValue || getNow();
	    return { value: value };
	  },

	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    var value = nextProps.value;
	    if (value !== undefined) {
	      value = value || nextProps.defaultValue || getNowByCurrentStateValue(this.state.value);
	      this.setState({
	        value: value
	      });
	    }
	  },

	  shouldComponentUpdate: function shouldComponentUpdate(nextProps) {
	    return this.props.visible || nextProps.visible;
	  },

	  onSelect: function onSelect(value, keyDownEvent) {
	    this.setValue(value);
	    if (!keyDownEvent) {
	      if (this.isAllowedDate(value)) {
	        this.props.onSelect(value);
	      }
	    }
	  },

	  onFocus: function onFocus() {
	    if (this._blurTimer) {
	      clearTimeout(this._blurTimer);
	      this._blurTimer = null;
	    } else {
	      this.props.onFocus();
	    }
	  },

	  onBlur: function onBlur() {
	    var _this = this;

	    if (this._blurTimer) {
	      clearTimeout(this._blurTimer);
	    }
	    this._blurTimer = setTimeout(function () {
	      _this.props.onBlur();
	    }, 100);
	  },

	  renderRoot: function renderRoot(newProps) {
	    var _className;

	    var props = this.props;
	    var state = this.state;
	    var prefixCls = props.prefixCls;

	    var className = (_className = {}, _defineProperty(_className, prefixCls, 1), _defineProperty(_className, prefixCls + '-hidden', !props.visible), _defineProperty(_className, props.className, !!props.className), _className);

	    var orient = state.orient;
	    if (orient) {
	      orient.forEach(function (o) {
	        className[prefixCls + '-orient-' + o] = 1;
	      });
	    }

	    return _react2['default'].createElement('div', { className: (0, _rcUtil.classSet)(className) + ' ' + newProps.className, style: this.props.style,
	      tabIndex: '0', onFocus: this.onFocus,
	      onBlur: this.onBlur, onKeyDown: this.onKeyDown }, newProps.children);
	  },

	  setValue: function setValue(value) {
	    if (!('value' in this.props)) {
	      this.setState({
	        value: value
	      });
	    }
	    this.props.onChange(value);
	  },

	  isAllowedDate: function isAllowedDate(value) {
	    var disabledDate = this.props.disabledDate;
	    return !disabledDate || !disabledDate(value);
	  },

	  setOrient: function setOrient(orient) {
	    // FIXME: hack to prevent breaking rc-animate
	    if (this.state.orient === orient) {
	      return;
	    }
	    this.state.orient = orient;
	    var prefixCls = this.props.prefixCls;
	    var root = _react2['default'].findDOMNode(this);
	    var className = root.className.replace(new RegExp(prefixCls + '-orient-\\w+', 'g'), '');
	    if (orient) {
	      orient.forEach(function (o) {
	        className += ' ' + prefixCls + '-orient-' + o;
	      });
	    }
	    root.className = className;
	  }
	};

	exports['default'] = CalendarMixin;
	module.exports = exports['default'];

/***/ },
/* 463 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _gregorianCalendarFormatLibLocaleEnUs = __webpack_require__(438);

	var _gregorianCalendarFormatLibLocaleEnUs2 = _interopRequireDefault(_gregorianCalendarFormatLibLocaleEnUs);

	exports['default'] = {
	  today: 'Today',
	  now: 'Now',
	  ok: 'Ok',
	  clear: 'Clear',
	  hourPanelTitle: 'Select hour',
	  minutePanelTitle: 'Select minute',
	  secondPanelTitle: 'Select second',
	  monthSelect: 'Choose a month',
	  yearSelect: 'Choose a year',
	  decadeSelect: 'Choose a decade',
	  yearFormat: 'yyyy',
	  dateFormat: 'M/d/yyyy',
	  monthFormat: 'MMMM',
	  monthBeforeYear: true,
	  previousMonth: 'Previous month (PageUp)',
	  nextMonth: 'Next month (PageDown)',
	  hourInput: 'Last hour(Up), Next hour(Down)',
	  minuteInput: 'Last minute(Up), Next minute(Down)',
	  secondInput: 'Last second(Up), Next second(Down)',
	  previousYear: 'Last year (Control + left)',
	  nextYear: 'Next year (Control + right)',
	  previousDecade: 'Last decade',
	  nextDecade: 'Next decade',
	  previousCentury: 'Last century',
	  nextCentury: 'Next century',
	  format: _gregorianCalendarFormatLibLocaleEnUs2['default']
	};
		module.exports = exports['default'];

/***/ },
/* 464 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	  } else {
	    obj[key] = value;
	  }return obj;
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _gregorianCalendarFormat = __webpack_require__(432);

	var _gregorianCalendarFormat2 = _interopRequireDefault(_gregorianCalendarFormat);

	var _rcUtil = __webpack_require__(439);

	var _rcUtil2 = _interopRequireDefault(_rcUtil);

	var _rcAlign = __webpack_require__(465);

	var _rcAlign2 = _interopRequireDefault(_rcAlign);

	var _rcAnimate = __webpack_require__(475);

	var _rcAnimate2 = _interopRequireDefault(_rcAnimate);

	var toFragment = _rcUtil2['default'].Children.mapSelf;

	var orientMap = {
	  tl: ['top', 'left'],
	  tr: ['top', 'right'],
	  bl: ['bottom', 'left'],
	  br: ['bottom', 'right']
	};

	function getImmutableOrient(orient) {
	  if (orient) {
	    for (var i in orientMap) {
	      if (orientMap.hasOwnProperty(i)) {
	        var original = orientMap[i];
	        if (original[0] === orient[0] && original[1] === orient[1]) {
	          return original;
	        }
	      }
	    }
	  }
	}

	function prevent(e) {
	  e.preventDefault();
	}

	function noop() {}

	function refFn(field, component) {
	  this[field] = component;
	}

	/**
	 * DatePicker = wrap input using Calendar
	 */
	var Picker = _react2['default'].createClass({
	  displayName: 'Picker',

	  propTypes: {
	    onChange: _react2['default'].PropTypes.func,
	    onOpen: _react2['default'].PropTypes.func,
	    onClose: _react2['default'].PropTypes.func,
	    calendar: _react2['default'].PropTypes.element,
	    style: _react2['default'].PropTypes.object,
	    open: _react2['default'].PropTypes.bool,
	    defaultOpen: _react2['default'].PropTypes.bool,
	    prefixCls: _react2['default'].PropTypes.string,
	    adjustOrientOnCalendarOverflow: _react2['default'].PropTypes.oneOfType([_react2['default'].PropTypes.bool, _react2['default'].PropTypes.object])
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      prefixCls: 'rc-calendar-picker',
	      adjustOrientOnCalendarOverflow: true,
	      style: {},
	      defaultOpen: false,
	      onChange: noop,
	      onOpen: noop,
	      onClose: noop,
	      formatter: new _gregorianCalendarFormat2['default']('yyyy-MM-dd')
	    };
	  },

	  getInitialState: function getInitialState() {
	    var props = this.props;
	    var open = undefined;
	    if ('open' in props) {
	      open = props.open;
	    } else {
	      open = props.defaultOpen;
	    }
	    var value = props.value || props.defaultValue;
	    this.saveCalendarRef = refFn.bind(this, 'calendarInstance');
	    this.saveInputRef = refFn.bind(this, 'inputInstance');
	    return { open: open, value: value };
	  },

	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    var value = nextProps.value;
	    if (value !== undefined) {
	      // null special meaning
	      value = value || nextProps.defaultValue || null;
	      this.setState({
	        value: value
	      });
	    }
	    if ('open' in nextProps) {
	      this.setState({
	        open: nextProps.open
	      });
	    }
	  },

	  componentDidUpdate: function componentDidUpdate() {
	    if (this.haveOpened) {
	      _react2['default'].render(this.getCalendarElement(), this.getCalendarContainer());
	    }
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    if (this.calendarContainer) {
	      _react2['default'].unmountComponentAtNode(this.calendarContainer);
	      this.calendarContainer.parentNode.removeChild(this.calendarContainer);
	      this.calendarContainer = null;
	    }
	  },

	  onCalendarAlign: function onCalendarAlign(node, align) {
	    var points = align.points;
	    var newOrient = orientMap[points[0]];
	    this.calendarInstance.setOrient(newOrient);
	    // focus after align
	    _react2['default'].findDOMNode(this.calendarInstance).focus();
	  },

	  onInputClick: function onInputClick() {
	    this.toggle();
	  },

	  onTriggerClick: function onTriggerClick() {
	    this.toggle();
	  },

	  onKeyDown: function onKeyDown(e) {
	    // down
	    if (e.keyCode === _rcUtil.KeyCode.DOWN) {
	      e.preventDefault();
	      this.open();
	    }
	  },

	  onCalendarKeyDown: function onCalendarKeyDown(e) {
	    if (e.keyCode === _rcUtil.KeyCode.ESC) {
	      e.stopPropagation();
	      this.close(this.focusInput);
	    }
	  },

	  onCalendarSelect: function onCalendarSelect(value) {
	    var currentValue = this.state.value;
	    this.setState({
	      value: value
	    });
	    if (!this.props.calendar.props.showTime) {
	      this.close(this.focusInput);
	    }
	    if (!currentValue || currentValue.getTime() !== value.getTime()) {
	      this.props.onChange(value);
	    }
	  },

	  onCalendarBlur: function onCalendarBlur() {
	    if (document.activeElement === this.getInputDOMNode()) {
	      return;
	    }
	    // if invisible, will not trigger blur
	    // do not set if already false, avoid ruin animate
	    this.close();
	  },

	  onCalendarOk: function onCalendarOk() {
	    this.close(this.focusInput);
	  },

	  onCalendarClear: function onCalendarClear() {
	    this.setState({
	      value: null
	    });
	    this.close(this.focusInput);
	    if (this.state.value !== null) {
	      this.props.onChange(null);
	    }
	  },

	  onCalendarChange: function onCalendarChange(value) {
	    this.calendarInstance.setState({
	      value: value
	    });
	  },

	  getInputDOMNode: function getInputDOMNode() {
	    return _react2['default'].findDOMNode(this.inputInstance);
	  },

	  getTransitionName: function getTransitionName() {
	    var props = this.props;
	    var transitionName = props.transitionName;
	    if (!transitionName && props.animation) {
	      transitionName = props.prefixCls + '-' + props.animation;
	    }
	    return transitionName;
	  },

	  getCalendarContainer: function getCalendarContainer() {
	    if (!this.calendarContainer) {
	      this.calendarContainer = document.createElement('div');
	      this.calendarContainer.className = this.props.prefixCls + '-container';
	      document.body.appendChild(this.calendarContainer);
	    }
	    return this.calendarContainer;
	  },

	  getAlign: function getAlign(orient) {
	    var points = ['tl', 'bl'];
	    var offset = [0, 5];
	    var adjustOrientOnCalendarOverflow = this.props.adjustOrientOnCalendarOverflow;
	    if (orient.indexOf('top') !== -1 && orient.indexOf('left') !== -1) {
	      points = ['tl', 'bl'];
	    } else if (orient.indexOf('top') !== -1 && orient.indexOf('right') !== -1) {
	      points = ['tr', 'br'];
	    } else if (orient.indexOf('bottom') !== -1 && orient.indexOf('left') !== -1) {
	      points = ['bl', 'tl'];
	      offset = [0, -5];
	    } else if (orient.indexOf('bottom') !== -1 && orient.indexOf('right') !== -1) {
	      points = ['br', 'tr'];
	      offset = [0, -5];
	    }
	    var adjustX = undefined;
	    var adjustY = undefined;
	    if (adjustOrientOnCalendarOverflow === true) {
	      adjustX = adjustY = true;
	    } else if (!adjustOrientOnCalendarOverflow) {
	      adjustX = adjustY = false;
	    } else {
	      adjustX = adjustOrientOnCalendarOverflow.x;
	      adjustY = adjustOrientOnCalendarOverflow.y;
	    }
	    return {
	      points: points,
	      offset: offset,
	      overflow: {
	        adjustX: adjustX,
	        adjustY: adjustY
	      }
	    };
	  },

	  getCalendarElement: function getCalendarElement() {
	    var props = this.props;
	    var state = this.state;
	    var calendarProp = props.calendar;
	    var orient = undefined;
	    // re align when open
	    if (state.open) {
	      orient = getImmutableOrient(calendarProp.props.orient) || orientMap.tl;
	    }
	    var calendarElement = _react2['default'].cloneElement(calendarProp, {
	      ref: (0, _rcUtil.createChainedFunction)(calendarProp.ref, this.saveCalendarRef),
	      value: state.value,
	      visible: state.open,
	      orient: orient,
	      onBlur: this.onCalendarBlur,
	      onKeyDown: this.onCalendarKeyDown,
	      onChange: (0, _rcUtil.createChainedFunction)(calendarProp.props.onChange, this.onCalendarChange),
	      onOk: (0, _rcUtil.createChainedFunction)(calendarProp.props.onOk, this.onCalendarOk),
	      onSelect: (0, _rcUtil.createChainedFunction)(calendarProp.props.onSelect, this.onCalendarSelect),
	      onClear: (0, _rcUtil.createChainedFunction)(calendarProp.props.onClear, this.onCalendarClear)
	    });
	    return _react2['default'].createElement(_rcAnimate2['default'], {
	      component: '',
	      exclusive: true,
	      transitionAppear: true,
	      showProp: 'calendarOpen',
	      transitionName: this.getTransitionName() }, _react2['default'].createElement(_rcAlign2['default'], { target: this.getInputDOMNode,
	      key: 'calendar',
	      onAlign: this.onCalendarAlign,
	      calendarOpen: state.open,
	      disabled: !state.open,
	      align: orient && this.getAlign(orient) }, calendarElement));
	  },

	  render: function render() {
	    var _classes;

	    var props = this.props;
	    var disabled = props.disabled;
	    var prefixCls = props.prefixCls;
	    var input = props.children;
	    var state = this.state;
	    var value = state.value;
	    this.haveOpened = this.haveOpened || state.open;
	    var inputValue = '';
	    if (value) {
	      inputValue = props.formatter.format(value);
	    }
	    input = _react2['default'].cloneElement(input, {
	      ref: (0, _rcUtil.createChainedFunction)(input.ref, this.saveInputRef),
	      disabled: disabled,
	      onChange: noop,
	      onClick: disabled ? noop : this.onInputClick,
	      value: inputValue,
	      onKeyDown: disabled ? noop : this.onKeyDown
	    });
	    var classes = (_classes = {}, _defineProperty(_classes, prefixCls, 1), _defineProperty(_classes, prefixCls + '-open', state.open), _defineProperty(_classes, prefixCls + '-disabled', disabled), _classes);
	    var trigger = props.trigger;
	    if (trigger) {
	      trigger = _react2['default'].cloneElement(trigger, {
	        unselectable: true,
	        onMouseDown: prevent,
	        onClick: disabled ? noop : this.onTriggerClick
	      });
	    }
	    return _react2['default'].createElement('span', { className: (0, _rcUtil.classSet)(classes), style: props.style }, toFragment([input, trigger]));
	  },

	  focusInput: function focusInput() {
	    if (!this.state.open) {
	      this.getInputDOMNode().focus();
	    }
	  },

	  setOpen: function setOpen(open, callback) {
	    if (this.state.open !== open) {
	      this.setState({
	        open: open
	      }, callback);
	      var _event = {
	        open: open
	      };
	      if (open) {
	        this.props.onOpen(_event);
	      } else {
	        this.props.onClose(_event);
	      }
	    }
	  },

	  toggle: function toggle() {
	    if (this.state.open) {
	      this.close();
	    } else {
	      this.open();
	    }
	  },

	  open: function open(callback) {
	    this.setOpen(true, callback);
	  },

	  close: function close(callback) {
	    this.setOpen(false, callback);
	  }
	});

	exports['default'] = Picker;
	module.exports = exports['default'];

/***/ },
/* 465 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// export this package's api

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _Align = __webpack_require__(466);

	var _Align2 = _interopRequireDefault(_Align);

	exports['default'] = _Align2['default'];
	module.exports = exports['default'];

/***/ },
/* 466 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ('value' in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	var _get = function get(_x, _x2, _x3) {
	  var _again = true;_function: while (_again) {
	    var object = _x,
	        property = _x2,
	        receiver = _x3;desc = parent = getter = undefined;_again = false;if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
	      var parent = Object.getPrototypeOf(object);if (parent === null) {
	        return undefined;
	      } else {
	        _x = parent;_x2 = property;_x3 = receiver;_again = true;continue _function;
	      }
	    } else if ('value' in desc) {
	      return desc.value;
	    } else {
	      var getter = desc.get;if (getter === undefined) {
	        return undefined;
	      }return getter.call(receiver);
	    }
	  }
	};

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError('Cannot call a class as a function');
	  }
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== 'function' && superClass !== null) {
	    throw new TypeError('Super expression must either be null or a function, not ' + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _domAlign = __webpack_require__(467);

	var _domAlign2 = _interopRequireDefault(_domAlign);

	var _rcUtil = __webpack_require__(439);

	var _rcUtil2 = _interopRequireDefault(_rcUtil);

	function isWindow(obj) {
	  /*eslint-disable eqeqeq */
	  return obj != null && obj == obj.window;
	  /*eslint-enable eqeqeq */
	}

	function buffer(fn, ms) {
	  var timer;
	  return function () {
	    if (timer) {
	      clearTimeout(timer);
	    }
	    timer = setTimeout(fn, ms);
	  };
	}

	var Align = function (_React$Component) {
	  _inherits(Align, _React$Component);

	  function Align(props) {
	    _classCallCheck(this, Align);

	    _get(Object.getPrototypeOf(Align.prototype), 'constructor', this).apply(this, arguments);
	    this.handleWindowResize = this.handleWindowResize.bind(this);
	  }

	  _createClass(Align, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      var props = this.props;
	      // if parent ref not attached .... use document.getElementById
	      if (!props.disabled) {
	        var source = _react2['default'].findDOMNode(this);
	        props.onAlign(source, (0, _domAlign2['default'])(source, props.target(), props.align));
	        if (props.monitorWindowResize) {
	          this.startMonitorWindowResize();
	        }
	      }
	    }
	  }, {
	    key: 'startMonitorWindowResize',
	    value: function startMonitorWindowResize() {
	      if (!this.resizeHandler) {
	        this.resizeHandler = _rcUtil2['default'].Dom.addEventListener(window, 'resize', buffer(this.handleWindowResize, this.props.monitorBufferTime));
	      }
	    }
	  }, {
	    key: 'stopMonitorWindowResize',
	    value: function stopMonitorWindowResize() {
	      if (this.resizeHandler) {
	        this.resizeHandler.remove();
	        this.resizeHandler = null;
	      }
	    }
	  }, {
	    key: 'handleWindowResize',
	    value: function handleWindowResize() {
	      var props = this.props;
	      if (!props.disabled) {
	        var source = _react2['default'].findDOMNode(this);
	        props.onAlign(source, (0, _domAlign2['default'])(source, props.target(), props.align));
	      }
	    }
	  }, {
	    key: 'componentWillUnmount',
	    value: function componentWillUnmount() {
	      this.stopMonitorWindowResize();
	    }
	  }, {
	    key: 'componentDidUpdate',
	    value: function componentDidUpdate(prevProps) {
	      var reAlign = false;
	      var props = this.props;
	      var currentTarget;

	      if (!props.disabled) {
	        if (prevProps.disabled || prevProps.align !== props.align) {
	          reAlign = true;
	          currentTarget = props.target();
	        } else {
	          var lastTarget = prevProps.target();
	          currentTarget = props.target();
	          if (isWindow(lastTarget) && isWindow(currentTarget)) {
	            reAlign = false;
	          } else if (lastTarget !== currentTarget) {
	            reAlign = true;
	          }
	        }
	      }

	      if (reAlign) {
	        var source = _react2['default'].findDOMNode(this);
	        props.onAlign(source, (0, _domAlign2['default'])(source, currentTarget, props.align));
	      }

	      if (props.monitorWindowResize && !props.disabled) {
	        this.startMonitorWindowResize();
	      } else {
	        this.stopMonitorWindowResize();
	      }
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      return _react2['default'].Children.only(this.props.children);
	    }
	  }]);

	  return Align;
	}(_react2['default'].Component);

	Align.defaultProps = {
	  target: function target() {
	    return window;
	  },
	  onAlign: function onAlign() {},
	  monitorBufferTime: 50,
	  monitorWindowResize: false,
	  disabled: false
	};

	Align.PropTypes = {
	  align: _react2['default'].PropTypes.object.isRequired,
	  target: _react2['default'].PropTypes.func,
	  onAlign: _react2['default'].PropTypes.func,
	  monitorBufferTime: _react2['default'].PropTypes.number,
	  monitorWindowResize: _react2['default'].PropTypes.bool,
	  disabled: _react2['default'].PropTypes.bool
	};

	exports['default'] = Align;
	module.exports = exports['default'];

/***/ },
/* 467 */
[764, 468, 469, 470, 471, 472, 473],
/* 468 */
66,
/* 469 */
[765, 468],
/* 470 */
[766, 468, 469],
/* 471 */
[767, 468],
/* 472 */
[768, 468],
/* 473 */
[769, 474],
/* 474 */
72,
/* 475 */
[770, 476],
/* 476 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	  } else {
	    obj[key] = value;
	  }return obj;
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _ChildrenUtils = __webpack_require__(477);

	var _ChildrenUtils2 = _interopRequireDefault(_ChildrenUtils);

	var _AnimateChild = __webpack_require__(478);

	var _AnimateChild2 = _interopRequireDefault(_AnimateChild);

	var _util = __webpack_require__(483);

	var _util2 = _interopRequireDefault(_util);

	var defaultKey = 'rc_animate_' + Date.now();

	function getChildrenFromProps(props) {
	  var children = props.children;
	  if (_react2['default'].isValidElement(children)) {
	    if (!children.key) {
	      return _react2['default'].cloneElement(children, {
	        key: defaultKey
	      });
	    }
	  }
	  return children;
	}

	function noop() {}

	var Animate = _react2['default'].createClass({
	  displayName: 'Animate',

	  propTypes: {
	    component: _react2['default'].PropTypes.any,
	    animation: _react2['default'].PropTypes.object,
	    transitionName: _react2['default'].PropTypes.string,
	    transitionEnter: _react2['default'].PropTypes.bool,
	    transitionAppear: _react2['default'].PropTypes.bool,
	    transitionLeave: _react2['default'].PropTypes.bool,
	    onEnd: _react2['default'].PropTypes.func,
	    onEnter: _react2['default'].PropTypes.func,
	    onLeave: _react2['default'].PropTypes.func,
	    onAppear: _react2['default'].PropTypes.func,
	    showProp: _react2['default'].PropTypes.string
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      animation: {},
	      component: 'span',
	      transitionEnter: true,
	      transitionLeave: true,
	      transitionAppear: false,
	      onEnd: noop,
	      onEnter: noop,
	      onLeave: noop,
	      onAppear: noop
	    };
	  },

	  getInitialState: function getInitialState() {
	    this.currentlyAnimatingKeys = {};
	    this.keysToEnter = [];
	    this.keysToLeave = [];
	    return {
	      children: (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(this.props))
	    };
	  },

	  componentDidMount: function componentDidMount() {
	    var _this = this;

	    var showProp = this.props.showProp;
	    var children = this.state.children;
	    if (showProp) {
	      children = children.filter(function (c) {
	        return !!c.props[showProp];
	      });
	    }
	    children.forEach(function (c) {
	      _this.performAppear(c.key);
	    });
	  },

	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    var _this2 = this;

	    var nextChildren = (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(nextProps));
	    var props = this.props;
	    var showProp = props.showProp;
	    var exclusive = props.exclusive;
	    var currentlyAnimatingKeys = this.currentlyAnimatingKeys;
	    // last props children if exclusive
	    // exclusive needs immediate response
	    var currentChildren = this.state.children;
	    // in case destroy in showProp mode
	    var newChildren = [];
	    if (showProp) {
	      currentChildren.forEach(function (currentChild) {
	        var nextChild = (0, _ChildrenUtils.findChildInChildrenByKey)(nextChildren, currentChild.key);
	        var newChild = undefined;
	        if ((!nextChild || !nextChild.props[showProp]) && currentChild.props[showProp]) {
	          newChild = _react2['default'].cloneElement(nextChild || currentChild, _defineProperty({}, showProp, true));
	        } else {
	          newChild = nextChild;
	        }
	        if (newChild) {
	          newChildren.push(newChild);
	        }
	      });
	      nextChildren.forEach(function (nextChild) {
	        if (!(0, _ChildrenUtils.findChildInChildrenByKey)(currentChildren, nextChild.key)) {
	          newChildren.push(nextChild);
	        }
	      });
	    } else {
	      newChildren = _ChildrenUtils2['default'].mergeChildren(currentChildren, nextChildren);
	    }

	    // exclusive needs immediate response
	    if (exclusive) {
	      Object.keys(currentlyAnimatingKeys).forEach(function (key) {
	        _this2.stop(key);
	      });
	      currentChildren = (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(props));
	    }

	    // need render to avoid update
	    this.setState({
	      children: newChildren
	    });

	    nextChildren.forEach(function (c) {
	      var key = c.key;
	      if (currentlyAnimatingKeys[key]) {
	        return;
	      }
	      var hasPrev = (0, _ChildrenUtils.findChildInChildrenByKey)(currentChildren, key);
	      if (showProp) {
	        var showInNext = c.props[showProp];
	        if (hasPrev) {
	          var showInNow = (0, _ChildrenUtils.findShownChildInChildrenByKey)(currentChildren, key, showProp);
	          if (!showInNow && showInNext) {
	            _this2.keysToEnter.push(key);
	          }
	        } else if (showInNext) {
	          _this2.keysToEnter.push(key);
	        }
	      } else if (!hasPrev) {
	        _this2.keysToEnter.push(key);
	      }
	    });

	    currentChildren.forEach(function (c) {
	      var key = c.key;
	      if (currentlyAnimatingKeys[key]) {
	        return;
	      }
	      var hasNext = (0, _ChildrenUtils.findChildInChildrenByKey)(nextChildren, key);
	      if (showProp) {
	        var showInNow = c.props[showProp];
	        if (hasNext) {
	          var showInNext = (0, _ChildrenUtils.findShownChildInChildrenByKey)(nextChildren, key, showProp);
	          if (!showInNext && showInNow) {
	            _this2.keysToLeave.push(key);
	          }
	        } else if (showInNow) {
	          _this2.keysToLeave.push(key);
	        }
	      } else if (!hasNext) {
	        _this2.keysToLeave.push(key);
	      }
	    });
	  },

	  componentDidUpdate: function componentDidUpdate() {
	    var keysToEnter = this.keysToEnter;
	    this.keysToEnter = [];
	    keysToEnter.forEach(this.performEnter);
	    var keysToLeave = this.keysToLeave;
	    this.keysToLeave = [];
	    keysToLeave.forEach(this.performLeave);
	  },

	  render: function render() {
	    var props = this.props;
	    var stateChildren = this.state.children;
	    var children = null;
	    if (stateChildren) {
	      children = stateChildren.map(function (child) {
	        if (!child.key) {
	          throw new Error('must set key for <rc-animate> children');
	        }
	        return _react2['default'].createElement(_AnimateChild2['default'], {
	          key: child.key,
	          ref: child.key,
	          animation: props.animation,
	          transitionName: props.transitionName,
	          transitionEnter: props.transitionEnter,
	          transitionAppear: props.transitionAppear,
	          transitionLeave: props.transitionLeave }, child);
	      });
	    }
	    var Component = props.component;
	    if (Component) {
	      return _react2['default'].createElement(Component, this.props, children);
	    }
	    return children[0] || null;
	  },

	  performEnter: function performEnter(key) {
	    // may already remove by exclusive
	    if (this.refs[key]) {
	      this.currentlyAnimatingKeys[key] = true;
	      this.refs[key].componentWillEnter(this.handleDoneAdding.bind(this, key, 'enter'));
	    }
	  },

	  performAppear: function performAppear(key) {
	    if (this.refs[key]) {
	      this.currentlyAnimatingKeys[key] = true;
	      this.refs[key].componentWillAppear(this.handleDoneAdding.bind(this, key, 'appear'));
	    }
	  },

	  handleDoneAdding: function handleDoneAdding(key, type) {
	    var props = this.props;
	    delete this.currentlyAnimatingKeys[key];
	    var currentChildren = (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(props));
	    if (!this.isValidChildByKey(currentChildren, key)) {
	      // exclusive will not need this
	      this.performLeave(key);
	    } else {
	      if (type === 'appear') {
	        if (_util2['default'].allowAppearCallback(props)) {
	          props.onAppear(key);
	          props.onEnd(key, true);
	        }
	      } else {
	        if (_util2['default'].allowEnterCallback(props)) {
	          props.onEnter(key);
	          props.onEnd(key, true);
	        }
	      }
	    }
	  },

	  performLeave: function performLeave(key) {
	    // may already remove by exclusive
	    if (this.refs[key]) {
	      this.currentlyAnimatingKeys[key] = true;
	      this.refs[key].componentWillLeave(this.handleDoneLeaving.bind(this, key));
	    }
	  },

	  handleDoneLeaving: function handleDoneLeaving(key) {
	    var props = this.props;
	    delete this.currentlyAnimatingKeys[key];
	    var currentChildren = (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(props));
	    // in case state change is too fast
	    if (this.isValidChildByKey(currentChildren, key)) {
	      this.performEnter(key);
	    } else {
	      if (_util2['default'].allowLeaveCallback(props)) {
	        props.onLeave(key);
	        props.onEnd(key, false);
	      }
	      if (this.isMounted() && !(0, _ChildrenUtils.isSameChildren)(this.state.children, currentChildren, props.showProp)) {
	        this.setState({
	          children: currentChildren
	        });
	      }
	    }
	  },

	  isValidChildByKey: function isValidChildByKey(currentChildren, key) {
	    var showProp = this.props.showProp;
	    if (showProp) {
	      return (0, _ChildrenUtils.findShownChildInChildrenByKey)(currentChildren, key, showProp);
	    }
	    return (0, _ChildrenUtils.findChildInChildrenByKey)(currentChildren, key);
	  },

	  stop: function stop(key) {
	    delete this.currentlyAnimatingKeys[key];
	    var component = this.refs[key];
	    if (component) {
	      component.stop();
	    }
	  }
	});

	exports['default'] = Animate;
	module.exports = exports['default'];

/***/ },
/* 477 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var utils = {
	  toArrayChildren: function toArrayChildren(children) {
	    var ret = [];
	    _react2['default'].Children.forEach(children, function (c) {
	      ret.push(c);
	    });
	    return ret;
	  },

	  findChildInChildrenByKey: function findChildInChildrenByKey(children, key) {
	    var ret = null;
	    if (children) {
	      children.forEach(function (c) {
	        if (ret) {
	          return;
	        }
	        if (c.key === key) {
	          ret = c;
	        }
	      });
	    }
	    return ret;
	  },

	  findShownChildInChildrenByKey: function findShownChildInChildrenByKey(children, key, showProp) {
	    var ret = null;
	    if (children) {
	      children.forEach(function (c) {
	        if (c.key === key && c.props[showProp]) {
	          if (ret) {
	            throw new Error('two child with same key for <rc-animate> children');
	          }
	          ret = c;
	        }
	      });
	    }
	    return ret;
	  },

	  findHiddenChildInChildrenByKey: function findHiddenChildInChildrenByKey(children, key, showProp) {
	    var found = 0;
	    if (children) {
	      children.forEach(function (c) {
	        if (found) {
	          return;
	        }
	        found = c.key === key && !c.props[showProp];
	      });
	    }
	    return found;
	  },

	  isSameChildren: function isSameChildren(c1, c2, showProp) {
	    var same = c1.length === c2.length;
	    if (same) {
	      c1.forEach(function (child, i) {
	        var child2 = c2[i];
	        if (child.key !== child2.key) {
	          same = false;
	        } else if (showProp && child.props[showProp] !== child2.props[showProp]) {
	          same = false;
	        }
	      });
	    }
	    return same;
	  },

	  mergeChildren: function mergeChildren(prev, next) {
	    var ret = [];

	    // For each key of `next`, the list of keys to insert before that key in
	    // the combined list
	    var nextChildrenPending = {};
	    var pendingChildren = [];
	    prev.forEach(function (c) {
	      if (utils.findChildInChildrenByKey(next, c.key)) {
	        if (pendingChildren.length) {
	          nextChildrenPending[c.key] = pendingChildren;
	          pendingChildren = [];
	        }
	      } else {
	        pendingChildren.push(c);
	      }
	    });

	    next.forEach(function (c) {
	      if (nextChildrenPending.hasOwnProperty(c.key)) {
	        ret = ret.concat(nextChildrenPending[c.key]);
	      }
	      ret.push(c);
	    });

	    ret = ret.concat(pendingChildren);

	    return ret;
	  }
	};

	exports['default'] = utils;
	module.exports = exports['default'];

/***/ },
/* 478 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _cssAnimation = __webpack_require__(479);

	var _cssAnimation2 = _interopRequireDefault(_cssAnimation);

	var _util = __webpack_require__(483);

	var _util2 = _interopRequireDefault(_util);

	var transitionMap = {
	  enter: 'transitionEnter',
	  appear: 'transitionAppear',
	  leave: 'transitionLeave'
	};

	var AnimateChild = _react2['default'].createClass({
	  displayName: 'AnimateChild',

	  propTypes: {
	    children: _react2['default'].PropTypes.any
	  },

	  transition: function transition(animationType, finishCallback) {
	    var _this = this;

	    var node = _react2['default'].findDOMNode(this);
	    var props = this.props;
	    var transitionName = props.transitionName;
	    this.stop();
	    var end = function end() {
	      _this.stopper = null;
	      finishCallback();
	    };
	    if ((_cssAnimation.isCssAnimationSupported || !props.animation[animationType]) && transitionName && props[transitionMap[animationType]]) {
	      this.stopper = (0, _cssAnimation2['default'])(node, transitionName + '-' + animationType, end);
	    } else {
	      this.stopper = props.animation[animationType](node, end);
	    }
	  },

	  stop: function stop() {
	    if (this.stopper) {
	      this.stopper.stop();
	      this.stopper = null;
	    }
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    this.stop();
	  },

	  componentWillEnter: function componentWillEnter(done) {
	    if (_util2['default'].isEnterSupported(this.props)) {
	      this.transition('enter', done);
	    } else {
	      done();
	    }
	  },

	  componentWillAppear: function componentWillAppear(done) {
	    if (_util2['default'].isAppearSupported(this.props)) {
	      this.transition('appear', done);
	    } else {
	      done();
	    }
	  },

	  componentWillLeave: function componentWillLeave(done) {
	    if (_util2['default'].isLeaveSupported(this.props)) {
	      this.transition('leave', done);
	    } else {
	      done();
	    }
	  },

	  render: function render() {
	    return this.props.children;
	  }
	});

	exports['default'] = AnimateChild;
	module.exports = exports['default'];

/***/ },
/* 479 */
[773, 480, 481],
/* 480 */
79,
/* 481 */
[774, 482, 482],
/* 482 */
81,
/* 483 */
82,
/* 484 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _monthMonthPanel = __webpack_require__(456);

	var _monthMonthPanel2 = _interopRequireDefault(_monthMonthPanel);

	var _mixinCalendarMixin = __webpack_require__(462);

	var _mixinCalendarMixin2 = _interopRequireDefault(_mixinCalendarMixin);

	var _rcUtil = __webpack_require__(439);

	var MonthCalendar = _react2['default'].createClass({
	  displayName: 'MonthCalendar',

	  mixins: [_mixinCalendarMixin2['default']],

	  onKeyDown: function onKeyDown(e) {
	    var keyCode = e.keyCode;
	    var ctrlKey = e.ctrlKey || e.metaKey;
	    var stateValue = this.state.value;
	    var value = stateValue;
	    switch (keyCode) {
	      case _rcUtil.KeyCode.DOWN:
	        value = stateValue.clone();
	        value.addMonth(3);
	        break;
	      case _rcUtil.KeyCode.UP:
	        value = stateValue.clone();
	        value.addMonth(-3);
	        break;
	      case _rcUtil.KeyCode.LEFT:
	        value = stateValue.clone();
	        if (ctrlKey) {
	          value.addYear(-1);
	        } else {
	          value.addMonth(-1);
	        }
	        break;
	      case _rcUtil.KeyCode.RIGHT:
	        value = stateValue.clone();
	        if (ctrlKey) {
	          value.addYear(1);
	        } else {
	          value.addMonth(1);
	        }
	        break;
	      case _rcUtil.KeyCode.ENTER:
	        this.onSelect(stateValue);
	        e.preventDefault();
	        return 1;
	      default:
	        return undefined;
	    }
	    if (value !== stateValue) {
	      this.setValue(value);
	      e.preventDefault();
	      return 1;
	    }
	  },

	  render: function render() {
	    var props = this.props;
	    var children = _react2['default'].createElement(_monthMonthPanel2['default'], { locale: props.locale,
	      disabledDate: props.disabledDate,
	      style: { position: 'relative' },
	      value: this.state.value,
	      rootPrefixCls: props.prefixCls,
	      onChange: this.setValue,
	      onSelect: this.onSelect });
	    return this.renderRoot({
	      children: children
	    });
	  }
	});

	exports['default'] = MonthCalendar;
	module.exports = exports['default'];

/***/ },
/* 485 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _gregorianCalendarFormat = __webpack_require__(432);

	var _gregorianCalendarFormat2 = _interopRequireDefault(_gregorianCalendarFormat);

	var _rcUtil = __webpack_require__(439);

	var _rcUtil2 = _interopRequireDefault(_rcUtil);

	var _rcAlign = __webpack_require__(465);

	var _rcAlign2 = _interopRequireDefault(_rcAlign);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}

	// import React from 'react';
	// import ReactDOM from 'react-dom';

	var toFragment = _rcUtil2["default"].Children.mapSelf;
	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var orientMap = {
	  tl: ['top', 'left'],
	  tr: ['top', 'right'],
	  bl: ['bottom', 'left'],
	  br: ['bottom', 'right']
	};

	function getImmutableOrient(orient) {
	  if (orient) {
	    for (var i in orientMap) {
	      if (orientMap.hasOwnProperty(i)) {
	        var original = orientMap[i];
	        if (original[0] === orient[0] && original[1] === orient[1]) {
	          return original;
	        }
	      }
	    }
	  }
	}

	function prevent(e) {
	  e.preventDefault();
	}

	function noop() {}

	function refFn(field, component) {
	  this[field] = component;
	}

	/**
	 * DatePicker = wrap input using Calendar
	 */
	var Picker = React.createClass({
	  displayName: 'Picker',

	  propTypes: {
	    onChange: React.PropTypes.func,
	    onOpen: React.PropTypes.func,
	    onClose: React.PropTypes.func,
	    calendar: React.PropTypes.element,
	    style: React.PropTypes.object,
	    open: React.PropTypes.bool,
	    defaultOpen: React.PropTypes.bool,
	    prefixCls: React.PropTypes.string,
	    adjustOrientOnCalendarOverflow: React.PropTypes.oneOfType([React.PropTypes.bool, React.PropTypes.object]),
	    getCalendarContainer: React.PropTypes.func
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      prefixCls: 'rc-calendar-picker',
	      adjustOrientOnCalendarOverflow: true,
	      style: {},
	      defaultOpen: false,
	      onChange: noop,
	      onOpen: noop,
	      onClose: noop,
	      formatter: new _gregorianCalendarFormat2["default"]('yyyy-MM-dd'),
	      getCalendarContainer: function getCalendarContainer() {
	        return document.body;
	      }
	    };
	  },
	  getInitialState: function getInitialState() {
	    var props = this.props;
	    var open = undefined;
	    if ('open' in props) {
	      open = props.open;
	    } else {
	      open = props.defaultOpen;
	    }
	    var value = props.value || props.defaultValue;
	    this.saveCalendarRef = refFn.bind(this, 'calendarInstance');
	    this.saveInputRef = refFn.bind(this, 'inputInstance');
	    return { open: open, value: value };
	  },
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    var value = nextProps.value;
	    if (value !== undefined) {
	      // null special meaning
	      value = value || nextProps.defaultValue || null;
	      this.setState({
	        value: value
	      });
	    }
	    if ('open' in nextProps) {
	      this.setState({
	        open: nextProps.open
	      });
	    }
	  },
	  componentDidUpdate: function componentDidUpdate() {
	    if (this.haveOpened) {
	      ReactDOM.render(this.getCalendarElement(), this.getCalendarContainer());
	    }
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    if (this.calendarContainer) {
	      React.unmountComponentAtNode(this.calendarContainer);
	      this.calendarContainer.parentNode.removeChild(this.calendarContainer);
	      this.calendarContainer = null;
	    }
	  },
	  onCalendarAlign: function onCalendarAlign(node, align) {
	    var points = align.points;
	    var newOrient = orientMap[points[0]];
	    this.calendarInstance.setOrient(newOrient);
	    // focus after align
	    ReactDOM.findDOMNode(this.calendarInstance).focus();
	  },
	  onInputClick: function onInputClick() {
	    this.toggle();
	  },
	  onTriggerClick: function onTriggerClick() {
	    this.toggle();
	  },
	  onKeyDown: function onKeyDown(e) {
	    // down
	    if (e.keyCode === _rcUtil.KeyCode.DOWN) {
	      e.preventDefault();
	      this.open();
	    }
	  },
	  onCalendarKeyDown: function onCalendarKeyDown(e) {
	    if (e.keyCode === _rcUtil.KeyCode.ESC) {
	      e.stopPropagation();
	      this.close(this.focusInput);
	    }
	  },
	  onCalendarSelect: function onCalendarSelect(value) {
	    var currentValue = this.state.value;
	    this.setState({
	      value: value
	    });
	    if (!this.props.calendar.props.showTime) {
	      this.close(this.focusInput);
	    }
	    if (!currentValue || currentValue.getTime() !== value.getTime()) {
	      this.props.onChange(value);
	    }
	  },
	  onCalendarBlur: function onCalendarBlur() {
	    if (document.activeElement === this.getInputDOMNode()) {
	      return;
	    }
	    // if invisible, will not trigger blur
	    // do not set if already false, avoid ruin animate
	    this.close();
	  },
	  onCalendarOk: function onCalendarOk() {
	    this.close(this.focusInput);
	  },
	  onCalendarClear: function onCalendarClear() {
	    this.setState({
	      value: null
	    });
	    this.close(this.focusInput);
	    if (this.state.value !== null) {
	      this.props.onChange(null);
	    }
	  },
	  onCalendarChange: function onCalendarChange(value) {
	    this.calendarInstance.setState({
	      value: value
	    });
	  },
	  getInputDOMNode: function getInputDOMNode() {
	    return ReactDOM.findDOMNode(this.inputInstance);
	  },
	  getTransitionName: function getTransitionName() {
	    var props = this.props;
	    var transitionName = props.transitionName;
	    if (!transitionName && props.animation) {
	      transitionName = props.prefixCls + '-' + props.animation;
	    }
	    return transitionName;
	  },
	  getCalendarContainer: function getCalendarContainer() {
	    if (!this.calendarContainer) {
	      this.calendarContainer = document.createElement('div');
	      this.calendarContainer.className = this.props.prefixCls + '-container';
	      this.props.getCalendarContainer().appendChild(this.calendarContainer);
	    }
	    return this.calendarContainer;
	  },
	  getAlign: function getAlign(orient) {
	    var points = ['tl', 'bl'];
	    var offset = [0, 5];
	    var adjustOrientOnCalendarOverflow = this.props.adjustOrientOnCalendarOverflow;
	    if (orient.indexOf('top') !== -1 && orient.indexOf('left') !== -1) {
	      points = ['tl', 'bl'];
	    } else if (orient.indexOf('top') !== -1 && orient.indexOf('right') !== -1) {
	      points = ['tr', 'br'];
	    } else if (orient.indexOf('bottom') !== -1 && orient.indexOf('left') !== -1) {
	      points = ['bl', 'tl'];
	      offset = [0, -5];
	    } else if (orient.indexOf('bottom') !== -1 && orient.indexOf('right') !== -1) {
	      points = ['br', 'tr'];
	      offset = [0, -5];
	    }
	    var adjustX = undefined;
	    var adjustY = undefined;
	    if (adjustOrientOnCalendarOverflow === true) {
	      adjustX = adjustY = true;
	    } else if (!adjustOrientOnCalendarOverflow) {
	      adjustX = adjustY = false;
	    } else {
	      adjustX = adjustOrientOnCalendarOverflow.x;
	      adjustY = adjustOrientOnCalendarOverflow.y;
	    }
	    return {
	      points: points,
	      offset: offset,
	      overflow: {
	        adjustX: adjustX,
	        adjustY: adjustY
	      }
	    };
	  },
	  getCalendarElement: function getCalendarElement() {
	    var props = this.props;
	    var state = this.state;
	    var calendarProp = props.calendar;
	    var orient = undefined;
	    // re align when open
	    if (state.open) {
	      orient = getImmutableOrient(calendarProp.props.orient) || orientMap.tl;
	    }
	    var calendarElement = React.cloneElement(calendarProp, {
	      ref: (0, _rcUtil.createChainedFunction)(calendarProp.ref, this.saveCalendarRef),
	      value: state.value,
	      visible: state.open,
	      orient: orient,
	      onBlur: this.onCalendarBlur,
	      onKeyDown: this.onCalendarKeyDown,
	      onChange: (0, _rcUtil.createChainedFunction)(calendarProp.props.onChange, this.onCalendarChange),
	      onOk: (0, _rcUtil.createChainedFunction)(calendarProp.props.onOk, this.onCalendarOk),
	      onSelect: (0, _rcUtil.createChainedFunction)(calendarProp.props.onSelect, this.onCalendarSelect),
	      onClear: (0, _rcUtil.createChainedFunction)(calendarProp.props.onClear, this.onCalendarClear)
	    });
	    return React.createElement(_rcAlign2["default"], { target: this.getInputDOMNode,
	      key: 'calendar',
	      onAlign: this.onCalendarAlign,
	      calendarOpen: state.open,
	      disabled: !state.open,
	      align: orient && this.getAlign(orient) }, calendarElement);
	  },
	  render: function render() {
	    var _classes;

	    var props = this.props;
	    var disabled = props.disabled;
	    var prefixCls = props.prefixCls;
	    var input = props.children;
	    var state = this.state;
	    var value = state.value;
	    this.haveOpened = this.haveOpened || state.open;
	    var inputValue = '';
	    if (value) {
	      inputValue = props.formatter.format(value);
	    }
	    input = React.cloneElement(input, {
	      ref: (0, _rcUtil.createChainedFunction)(input.ref, this.saveInputRef),
	      disabled: disabled,
	      onChange: noop,
	      onClick: disabled ? noop : this.onInputClick,
	      value: inputValue,
	      onKeyDown: disabled ? noop : this.onKeyDown
	    });
	    var classes = (_classes = {}, _classes[prefixCls] = 1, _classes[prefixCls + '-open'] = state.open, _classes[prefixCls + '-disabled'] = disabled, _classes);
	    var trigger = props.trigger;
	    if (trigger) {
	      trigger = React.cloneElement(trigger, {
	        unselectable: true,
	        onMouseDown: prevent,
	        onClick: disabled ? noop : this.onTriggerClick
	      });
	    }
	    return React.createElement('span', { className: (0, _rcUtil.classSet)(classes), style: props.style }, toFragment([input, trigger]));
	  },
	  focusInput: function focusInput() {
	    if (!this.state.open) {
	      this.getInputDOMNode().focus();
	    }
	  },
	  setOpen: function setOpen(open, callback) {
	    if (this.state.open !== open) {
	      this.setState({
	        open: open
	      }, callback);
	      var event = {
	        open: open
	      };
	      if (open) {
	        this.props.onOpen(event);
	      } else {
	        this.props.onClose(event);
	      }
	    }
	  },
	  toggle: function toggle() {
	    if (this.state.open) {
	      this.close();
	    } else {
	      this.open();
	    }
	  },
	  open: function open(callback) {
	    this.setOpen(true, callback);
	  },
	  close: function close(callback) {
	    this.setOpen(false, callback);
	  }
	});

	exports["default"] = Picker;
	module.exports = exports['default'];

/***/ },
/* 486 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _YearPanel = __webpack_require__(457);

	var _YearPanel2 = _interopRequireDefault(_YearPanel);

	var _CalendarMixin = __webpack_require__(462);

	var _CalendarMixin2 = _interopRequireDefault(_CalendarMixin);

	var _rcUtil = __webpack_require__(439);

	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { "default": obj };
	}

	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var YearCalendar = React.createClass({
	    displayName: 'YearCalendar',

	    mixins: [_CalendarMixin2["default"]],

	    onKeyDown: function onKeyDown(e) {
	        var keyCode = e.keyCode;
	        var ctrlKey = e.ctrlKey || e.metaKey;
	        var stateValue = this.state.value;
	        var value = stateValue;
	        switch (keyCode) {
	            case _rcUtil.KeyCode.DOWN:
	                value = stateValue.clone();
	                value.addMonth(3);
	                break;
	            case _rcUtil.KeyCode.UP:
	                value = stateValue.clone();
	                value.addMonth(-3);
	                break;
	            case _rcUtil.KeyCode.LEFT:
	                value = stateValue.clone();
	                if (ctrlKey) {
	                    value.addYear(-1);
	                } else {
	                    value.addMonth(-1);
	                }
	                break;
	            case _rcUtil.KeyCode.RIGHT:
	                value = stateValue.clone();
	                if (ctrlKey) {
	                    value.addYear(1);
	                } else {
	                    value.addMonth(1);
	                }
	                break;
	            case _rcUtil.KeyCode.ENTER:
	                this.onSelect(stateValue);
	                e.preventDefault();
	                return 1;
	            default:
	                return undefined;
	        }
	        if (value !== stateValue) {
	            this.setValue(value);
	            e.preventDefault();
	            return 1;
	        }
	    },
	    render: function render() {
	        var props = this.props;
	        var children = React.createElement(_YearPanel2["default"], { locale: props.locale,
	            disabledDate: props.disabledDate,
	            value: this.state.value,
	            rootPrefixCls: props.prefixCls,
	            onChange: this.setValue,
	            onSelect: this.onSelect });
	        return this.renderRoot({
	            children: children
	        });
	    }
	});

	exports["default"] = YearCalendar;
	module.exports = exports['default'];

/***/ },
/* 487 */
209,
/* 488 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _gregorianCalendarFormatLibLocaleZhCn = __webpack_require__(489);

	var _gregorianCalendarFormatLibLocaleZhCn2 = _interopRequireDefault(_gregorianCalendarFormatLibLocaleZhCn);

	exports['default'] = {
	  today: '今天',
	  now: '此刻',
	  ok: '确定',
	  clear: '清除',
	  previousMonth: '上个月 (翻页上键)',
	  nextMonth: '下个月 (翻页下键)',
	  monthSelect: '选择月份',
	  yearSelect: '选择年份',
	  decadeSelect: '选择年代',
	  hourInput: '上一小时(上方向键), 下一小时(下方向键)',
	  minuteInput: '上一分钟(上方向键), 下一分钟(下方向键)',
	  secondInput: '上一秒(上方向键), 下一小时(下方向键)',
	  hourPanelTitle: '选择小时',
	  minutePanelTitle: '选择分钟',
	  secondPanelTitle: '选择秒',
	  yearFormat: 'yyyy\'年\'',
	  monthFormat: 'M\'月\'',
	  dateFormat: 'yyyy\'年\'M\'月\'d\'日\'',
	  previousYear: '上一年 (Control键加左方向键)',
	  nextYear: '下一年 (Control键加右方向键)',
	  previousDecade: '上一年代',
	  nextDecade: '下一年代',
	  previousCentury: '上一世纪',
	  nextCentury: '下一世纪',
	  format: _gregorianCalendarFormatLibLocaleZhCn2['default']
	};
		module.exports = exports['default'];

/***/ },
/* 489 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * zh-cn locale
	 * @ignore
	 * @author yiminghe@gmail.com
	 */
	module.exports = {
	  eras: ['公元前', '公元'],
	  months: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'],
	  shortMonths: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'],
	  weekdays: ['星期天', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'],
	  shortWeekdays: ['周日', '周一', '周二', '周三', '周四', '周五', '周六'],
	  veryShortWeekdays: ['日', '一', '二', '三', '四', '五', '六'],
	  ampms: ['上午', '下午'],
	  /*jshint quotmark: false*/
	  datePatterns: ["yyyy'年'M'月'd'日' EEEE", "yyyy'年'M'月'd'日'", "yyyy-M-d", "yy-M-d"],
	  timePatterns: ["ahh'时'mm'分'ss'秒' 'GMT'Z", "ahh'时'mm'分'ss'秒'", "H:mm:ss", "ah:mm"],
	  dateTimePattern: '{date} {time}'
		};

/***/ },
/* 490 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var FormField = __webpack_require__(332);
	var Constants = __webpack_require__(222);
	var CheckboxGroup = __webpack_require__(215);
	var Item = CheckboxGroup.Item;

	var CheckboxGroupFormField = function (_FormField) {
	    _inherits(CheckboxGroupFormField, _FormField);

	    function CheckboxGroupFormField(props) {
	        _classCallCheck(this, CheckboxGroupFormField);

	        return _possibleConstructorReturn(this, _FormField.call(this, props));
	    }

	    CheckboxGroupFormField.prototype.handleChange = function handleChange(value) {
	        var me = this;
	        me.handleDataChange(value);
	    };

	    CheckboxGroupFormField.prototype.addSpecificClass = function addSpecificClass() {
	        var me = this;
	        if (me.props.jsxprefixCls == "kuma-uxform-field") {
	            return me.props.jsxprefixCls + " kuma-checkbox-group-uxform-field";
	        } else {
	            return me.props.jsxprefixCls;
	        }
	    };

	    CheckboxGroupFormField.prototype.renderField = function renderField() {
	        var me = this;
	        var mode = me.props.jsxmode || me.props.mode;
	        if (mode == Constants.MODE.EDIT) {
	            return React.createElement(CheckboxGroup, { disabled: !!me.props.jsxdisabled, onChange: me.handleChange.bind(me), value: me.state.value || [] }, me.props.children);
	        } else {
	            if (me.state.value instanceof Array) {
	                var textArr = me.props.children.filter(function (child, index) {
	                    return me.state.value.indexOf(child.props.value) != -1;
	                }).map(function (item, index) {
	                    return item.props.text;
	                });
	                return React.createElement("span", null, textArr.join(" "));
	            }
	        }
	    };

	    return CheckboxGroupFormField;
	}(FormField);

	CheckboxGroupFormField.Item = Item;
	CheckboxGroupFormField.propTypes = FormField.propTypes;
	CheckboxGroupFormField.defaultProps = FormField.defaultProps;
	CheckboxGroupFormField.displayName = "CheckboxGroupFormField";

	module.exports = CheckboxGroupFormField;

/***/ },
/* 491 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	    return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	    return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};

	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof2(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var FormField = __webpack_require__(332);
	var Constants = __webpack_require__(222);
	var Select = __webpack_require__(356);
	var Option = Select.Option;

	var assign = __webpack_require__(333);
	var update = React.addons.update;

	var CascadeSelectFormField = function (_FormField) {
	    _inherits(CascadeSelectFormField, _FormField);

	    function CascadeSelectFormField(props) {
	        _classCallCheck(this, CascadeSelectFormField);

	        return _possibleConstructorReturn(this, _FormField.call(this, props));
	    }

	    CascadeSelectFormField.prototype.getDataLength = function getDataLength() {
	        var me = this;
	        return me.props.jsxdata.length;
	    };

	    CascadeSelectFormField.prototype.handleChange = function handleChange(i, value) {
	        var me = this;
	        var values = update(me.state.value, {}) || [];
	        if (!!values[i]) {
	            values = values.slice(0, i);
	            values.push(value);
	        } else {
	            values[i] = value;
	        }
	        me.handleDataChange(values);
	    };

	    CascadeSelectFormField.prototype.addSpecificClass = function addSpecificClass() {
	        var me = this;
	        if (me.props.jsxprefixCls == "kuma-uxform-field") {
	            return me.props.jsxprefixCls + " kuma-cascade-select-uxform-field";
	        } else {
	            return me.props.jsxprefixCls;
	        }
	    };

	    CascadeSelectFormField.prototype.renderField = function renderField() {
	        var me = this;
	        var length = me.getDataLength();
	        var arr = [];
	        var data = {};
	        var mode = me.props.jsxmode || me.props.mode;
	        if (mode == Constants.MODE.EDIT) {
	            var _ret = function () {
	                try {
	                    data = me.props.jsxdata.contents;
	                } catch (e) {
	                    console.warn(e.message);
	                    return {
	                        v: void 0
	                    };
	                }

	                /*
	                 * 如果 value 存在相应的值，则填充下一级的选择，
	                 * 如果 value 不存在，则填充空数组，
	                 * 如果 data 中不包含 contents，则证明级联选择生成已结束，则跳出循环
	                 */
	                var stateValue = me.state.value || []; // 预防 value 是 undefined 的情况

	                var _loop = function _loop(i) {
	                    var options = data.map(function (item, index) {
	                        return React.createElement(Option, { key: index, value: item.value }, item.text);
	                    });

	                    var selectOptions = {
	                        ref: "el",
	                        key: "select",
	                        optionLabelProp: "children",
	                        style: me.props.jsxstyle,
	                        showSearch: me.props.jsxshowSearch,
	                        placeholder: me.props.jsxplaceholder
	                    };
	                    selectOptions.onChange = me.handleChange.bind(me, i);
	                    selectOptions.value = stateValue[i] || null;
	                    if (i != 0) {
	                        arr.push(React.createElement('span', { key: "split" + i, className: 'kuma-uxform-split' }, '-'));
	                    }
	                    arr.push(React.createElement(Select, _extends({}, selectOptions, { key: i }), options));
	                    if (!!stateValue[i]) {
	                        data = data.filter(function (item) {
	                            return item.value == stateValue[i];
	                        })[0];
	                        data = data.contents;
	                        if (!data) return 'break';
	                    } else {
	                        data = [];
	                    }
	                };

	                for (var i = 0; i < length; i++) {
	                    var _ret2 = _loop(i);

	                    if (_ret2 === 'break') break;
	                }
	            }();

	            if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
	        } else if (mode == Constants.MODE.VIEW) {
	            if (me.state.value instanceof Array) {
	                (function () {
	                    var data = me.props.jsxdata;
	                    var textArr = me.state.value.map(function (item, index) {
	                        data = data.contents.filter(function (ele, i) {
	                            return ele.value == item;
	                        })[0];
	                        return data.text;
	                    });
	                    arr.push(React.createElement('span', { key: 'cascade' }, textArr.join(" ")));
	                })();
	            }
	        }

	        return arr;
	    };

	    return CascadeSelectFormField;
	}(FormField);

	CascadeSelectFormField.propTypes = assign({}, FormField.propTypes, {
	    jsxstyle: React.PropTypes.object,
	    jsxshowSearch: React.PropTypes.bool,
	    jsxplaceholder: React.PropTypes.string,
	    jsxdata: React.PropTypes.object
	});
	CascadeSelectFormField.defaultProps = assign({}, FormField.defaultProps, {
	    jsxshowSearch: false,
	    jsxplaceholder: "请下拉选择"
	});
	CascadeSelectFormField.displayName = "CascadeSelectFormField";

	module.exports = CascadeSelectFormField;

/***/ },
/* 492 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);
	var classnames = __webpack_require__(5);
	var assign = __webpack_require__(333);

	var OtherFormField = function (_React$Component) {
	    _inherits(OtherFormField, _React$Component);

	    function OtherFormField(props) {
	        _classCallCheck(this, OtherFormField);

	        return _possibleConstructorReturn(this, _React$Component.call(this, props));
	    }

	    OtherFormField.prototype.render = function render() {
	        var _classnames;

	        var me = this;
	        return React.createElement('div', { className: classnames((_classnames = {}, _classnames[me.props.jsxprefixCls] = true, _classnames[me.props.className] = !!me.props.className, _classnames)), style: assign({}, me.props.style, {
	                display: me.props.jsxshow ? "table" : "none"
	            }) }, me.props.children);
	    };

	    return OtherFormField;
	}(React.Component);

	OtherFormField.defaultProps = {
	    jsxprefixCls: "kuma-uxform-field kuma-other-uxform-field", // 默认类名
	    jsxflex: 1, // 占 Form 的比例，类似于 css3 中的 flex-box
	    jsxshow: true
	};

	OtherFormField.propTypes = {
	    jsxprefixCls: React.PropTypes.string,
	    jsxflex: React.PropTypes.number,
	    jsxshow: React.PropTypes.bool
	};

	OtherFormField.displayName = "OtherFormField";

	module.exports = OtherFormField;

/***/ },
/* 493 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);
	var classnames = __webpack_require__(5);
	var assign = __webpack_require__(333);

	var ButtonGroupFormField = function (_React$Component) {
	    _inherits(ButtonGroupFormField, _React$Component);

	    function ButtonGroupFormField(props) {
	        _classCallCheck(this, ButtonGroupFormField);

	        return _possibleConstructorReturn(this, _React$Component.call(this, props));
	    }

	    ButtonGroupFormField.prototype._processChild = function _processChild() {
	        var me = this;
	        var length = React.Children.count(me.props.children);
	        if (!length) {
	            return false;
	        }
	        var elements = React.Children.map(me.props.children, function (child, index) {
	            var props = {};
	            if (child.props.action == "submit") {
	                props.onClick = function () {
	                    var data = me.props.getValues();
	                    child.props.onClick(data);
	                };
	            }
	            if (child.props.action == "reset") {
	                props.onClick = function () {
	                    console.log("reset");
	                    me.props.resetValues();
	                };
	            }
	            return React.cloneElement(child, props);
	        });

	        return elements;
	    };

	    ButtonGroupFormField.prototype.render = function render() {
	        var _classnames;

	        var me = this;
	        var elements = me._processChild();
	        return React.createElement('div', { className: classnames((_classnames = {}, _classnames[me.props.jsxprefixCls] = true, _classnames[me.props.className] = !!me.props.className, _classnames)), style: assign({}, me.props.style, {
	                display: me.props.jsxshow ? "table" : "none"
	            }) }, !!elements && elements);
	    };

	    return ButtonGroupFormField;
	}(React.Component);

	ButtonGroupFormField.propTypes = {
	    jsxprefixCls: React.PropTypes.string,
	    jsxflex: React.PropTypes.number,
	    jsxshow: React.PropTypes.bool
	};
	ButtonGroupFormField.defaultProps = {
	    jsxprefixCls: "kuma-uxform-field kuma-button-group-uxform-field", // 默认类名
	    jsxflex: 1, // 占 Form 的比例，类似于 css3 中的 flex-box
	    jsxshow: true
	};
	ButtonGroupFormField.displayName = "ButtonGroupFormField";

	module.exports = ButtonGroupFormField;

/***/ },
/* 494 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var FormField = __webpack_require__(332);
	var Constants = __webpack_require__(222);
	var Tinymce = __webpack_require__(495);
	var assign = __webpack_require__(333);

	var EditorFormField = function (_FormField) {
	    _inherits(EditorFormField, _FormField);

	    function EditorFormField(props) {
	        _classCallCheck(this, EditorFormField);

	        return _possibleConstructorReturn(this, _FormField.call(this, props));
	    }

	    EditorFormField.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	        var me = this;
	        if (!me._isEqual(nextProps.value, me.props.value)) {
	            me.handleDataChange(nextProps.value, true);
	        }
	    };

	    EditorFormField.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
	        var me = this;
	        var prevMode = prevProps.jsxmode || prevProps.mode;
	        var mode = me.props.jsxmode || me.props.mode;
	        if (prevMode == Constants.MODE.VIEW && mode == Constants.MODE.EDIT) {
	            me.refs.tinymce.resetValue(me.state.value);
	        }
	    };

	    EditorFormField.prototype._isEqual = function _isEqual(a, b) {
	        return JSON.stringify(a) == JSON.stringify(b);
	    };

	    EditorFormField.prototype.handleChange = function handleChange(e, editor) {
	        var me = this;
	        me.handleDataChange(editor.getContent());
	    };

	    EditorFormField.prototype.handleKeyup = function handleKeyup(e, editor) {
	        var me = this;
	        me.handleDataChange(editor.getContent());
	    };

	    EditorFormField.prototype.addSpecificClass = function addSpecificClass() {
	        var me = this;
	        if (me.props.jsxprefixCls == "kuma-uxform-field") {
	            return me.props.jsxprefixCls + " kuma-editor-uxform-field";
	        } else {
	            return me.props.jsxprefixCls;
	        }
	    };

	    EditorFormField.prototype.renderField = function renderField() {
	        var me = this;
	        var mode = me.props.jsxmode || me.props.mode;
	        if (me.state.fromReset && mode == Constants.MODE.EDIT) {
	            me.refs.tinymce.resetValue(me.props.jsxcontent);
	        }
	        if (mode == Constants.MODE.EDIT) {
	            return React.createElement(Tinymce, { ref: "tinymce",
	                config: me.props.jsxconfig,
	                content: me.state.value,
	                onChange: me.handleChange.bind(me),
	                onKeyup: me.handleKeyup.bind(me) });
	        } else {
	            return React.createElement("span", { key: "text", dangerouslySetInnerHTML: { __html: me.state.value } });
	        }
	    };

	    return EditorFormField;
	}(FormField);

	EditorFormField.propTypes = assign({}, FormField.propTypes);
	EditorFormField.defaultProps = assign({}, FormField.defaultProps, {
	    jsxconfig: {},
	    jsxcontent: ""
	});
	EditorFormField.displayName = "EditorFormField";

	module.exports = EditorFormField;

/***/ },
/* 495 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Tinymce Component for uxcore
	 * @author eternalsky
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

		module.exports = __webpack_require__(496);

/***/ },
/* 496 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	    return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	    return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof2(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	/**
	 * Tinymce Component for uxcore
	 * Inspired by react-tinymce: https://github.com/mzabriskie/react-tinymce
	 * @author eternalsky
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);
	var util = __webpack_require__(497);
	var EditorConfig = __webpack_require__(498);
	var assign = __webpack_require__(499);
	// Include all of the Native DOM and custom events from:
	// https://github.com/tinymce/tinymce/blob/master/tools/docs/tinymce.Editor.js#L5-L12
	var EVENTS = ['focusin', 'focusout', 'click', 'dblclick', 'mousedown', 'mouseup', 'mousemove', 'mouseover', 'beforepaste', 'paste', 'cut', 'copy', 'selectionchange', 'mouseout', 'mouseenter', 'mouseleave', 'keydown', 'keypress', 'keyup', 'contextmenu', 'dragend', 'dragover', 'draggesture', 'dragdrop', 'drop', 'drag', 'BeforeRenderUI', 'SetAttrib', 'PreInit', 'PostRender', 'init', 'deactivate', 'activate', 'NodeChange', 'BeforeExecCommand', 'ExecCommand', 'show', 'hide', 'ProgressState', 'LoadContent', 'SaveContent', 'BeforeSetContent', 'SetContent', 'BeforeGetContent', 'GetContent', 'VisualAid', 'remove', 'submit', 'reset', 'BeforeAddUndo', 'AddUndo', 'change', 'undo', 'redo', 'ClearUndos', 'ObjectSelected', 'ObjectResizeStart', 'ObjectResized', 'PreProcess', 'PostProcess', 'focus', 'blur'];

	// Note: because the capitalization of the events is weird, we're going to get
	// some inconsistently-named handlers, for example compare:
	// 'onMouseleave' and 'onNodeChange'
	var HANDLER_NAMES = EVENTS.map(function (event) {
	    return 'on' + util.uc_first(event);
	});

	var Tinymce = function (_React$Component) {
	    _inherits(Tinymce, _React$Component);

	    function Tinymce(props) {
	        _classCallCheck(this, Tinymce);

	        return _possibleConstructorReturn(this, _React$Component.call(this, props));
	    }

	    Tinymce.prototype.componentWillMount = function componentWillMount() {
	        if ((typeof tinymce === 'undefined' ? 'undefined' : _typeof(tinymce)) !== 'object') {
	            console.warn("TinyMCE is not found in global, init failed");
	        }
	        this.id = this.id || util.uuid();
	    };

	    Tinymce.prototype.componentDidMount = function componentDidMount() {
	        this._init(this.props.config);
	    };

	    Tinymce.prototype.componentWillUnmount = function componentWillUnmount() {
	        this._remove();
	    };

	    Tinymce.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	        if (!util.isEqual(nextProps.config, this.props.config)) {
	            this._init(nextProps.config, nextProps.content);
	        }
	    };

	    Tinymce.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
	        return !util.isEqual(this.props.content, nextProps.content) || !util.isEqual(this.props.config, nextProps.config);
	    };

	    Tinymce.prototype.resetValue = function resetValue(value) {
	        tinymce.get(this.id).setContent(value);
	    };

	    Tinymce.prototype._init = function _init(config, content) {
	        var me = this;
	        if (me._isInit) {
	            me._remove();
	        }
	        // hide the textarea until init finished
	        ReactDOM.findDOMNode(me).style.visibility = 'hidden';
	        config.selector = '#' + me.id;
	        config = assign({}, EditorConfig, config);
	        if (!config.language) {
	            config.language = 'zh_CN';
	        }
	        config.setup = function (editor) {
	            EVENTS.forEach(function (event, index) {
	                var handler = me.props[HANDLER_NAMES[index]];
	                if (typeof handler !== 'function') return;
	                editor.on(event, function (e) {
	                    // native DOM events don't have access to the editor so we pass it here
	                    handler(e, editor);
	                });
	            });
	            // need to set content here because the textarea will still have the
	            // old `this.props.content`
	            if (content) {
	                editor.on('init', function () {
	                    editor.setContent(content);
	                });
	            }
	        };
	        tinymce.baseURL = '//g.alicdn.com/uxcore/uxcore-lib/tinymce/4.2.5/';
	        tinymce.init(config);
	        ReactDOM.findDOMNode(me).style.visibility = "";
	        me._isInit = true;
	    };

	    Tinymce.prototype._remove = function _remove() {
	        tinymce.EditorManager.execCommand("mceRemoveEditor", true, this.id);
	        this._isInit = false;
	    };

	    Tinymce.prototype.render = function render() {
	        return React.createElement('textarea', { id: this.id, defaultValue: this.props.content });
	    };

	    return Tinymce;
	}(React.Component);

	Tinymce.defaultProps = {
	    config: {},
	    content: ''
	};

	// http://facebook.github.io/react/docs/reusable-components.html
	Tinymce.propTypes = {
	    config: React.PropTypes.object,
	    content: React.PropTypes.string
	};

	//add handler propTypes
	HANDLER_NAMES.forEach(function (name) {
	    Tinymce.propTypes[name] = React.PropTypes.func;
	});

	Tinymce.displayName = "Tinymce";

	module.exports = Tinymce;

/***/ },
/* 497 */
/***/ function(module, exports) {

	'use strict';

	var count = 0;

	module.exports = {
	    uc_first: function uc_first(str) {
	        return str.substring(0, 1).toUpperCase() + str.substring(1);
	    },
	    uuid: function uuid() {
	        return 'uxcore-tinymce-' + count++;
	    },
	    isEqual: function isEqual(a, b) {
	        return JSON.stringify(a) == JSON.stringify(b);
	    }
		};

/***/ },
/* 498 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	var plugins = ['lists', 'hr', 'emoticons', 'textcolor', 'insertdatetime', 'link', 'table', 'paste', 'preview', 'wordcount', 'image', 'upload'];

	exports["default"] = {
		theme: 'modern',
		height: 400,
		external_plugins: {
			'emoticons': '//g.alicdn.com/uxcore/uxcore-lib/tinymce/4.2.5/plugins/emoticons/plugin.min.js',
			'upload': '//g.alicdn.com/uxcore/uxcore-lib/tinymce/4.2.5/plugins/upload/plugin.min.js',
			'textcolor': '//g.alicdn.com/uxcore/uxcore-lib/tinymce/4.2.5/plugins/textcolor/plugin.min.js',
			'hr': '//g.alicdn.com/uxcore/uxcore-lib/tinymce/4.2.5/plugins/hr/plugin.min.js'
		},
		resize: true, // 是否可以鼠标拖动编辑器改变大小
		border_width: 1, // 编辑器的边框宽度
		convert_urls: false, // 当你insertContent的时候，取消一些节点src的转换
		visual: false, // table的虚框是否显示，由于大文本设置虚框很耗性能，所以取消掉
		keep_values: false, // 必须设置false用来提高性能
		forced_root_block: 'div', // 当空文本的时候，tinymce会设置一个根节点，默认是P，我们要改成div比较合理
		show_system_default_font: true, // 是否开启系统字体的探测。
		link_title: true, // link plugins enable title edit
		plugins: plugins,
		cssFiles: ['styles/skin.css', 'styles/skin-ext.css'],
		toolbar1: 'preview undo redo | fontselect fontsizeselect | bold italic underline strikethrough removeformat | forecolor backcolor | link | emoticons upload',
		toolbar2: 'alignleft aligncenter alignright alignjustify | bullist numlist outdent indent | table hr inserttime',
		uploadConfig: {
			"inputName": "imageUploadInput",
			"actionUrl": "http://test.alibaba-inc.com/work/xservice/http/uploadimage.json",
			"errorCallback": function errorCallback() {
				console.log('errorCallback', arguments);
			},
			"progressCallback": function progressCallback() {
				console.log('progressCallback', arguments);
			}
		},
		wordcount_countregex: /[^\x00-\xff]+/g
	};
		module.exports = exports['default'];

/***/ },
/* 499 */
33,
/* 500 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	/**
	 * Created by xy on 15/4/13.
	 */
	var SelectFormField = __webpack_require__(355);
	var Constants = __webpack_require__(222);
	var Select = __webpack_require__(356);
	var assign = __webpack_require__(333);
	var deepcopy = __webpack_require__(341);
	var classnames = __webpack_require__(5);
	var Option = Select.Option;

	var selectOptions = ['onSelect', 'onDeselect', 'getPopupContainer', 'filterOption', 'allowClear', 'searchPlaceholder', 'tags', 'disabled', 'showSearch', 'placeholder', 'optionLabelProp', 'maxTagTextLength', 'dropdownMatchSelectWidth', 'dropdownClassName', 'notFoundContent'];

	var SearchFormField = function (_SelectFormField) {
	    _inherits(SearchFormField, _SelectFormField);

	    function SearchFormField(props) {
	        _classCallCheck(this, SearchFormField);

	        return _possibleConstructorReturn(this, _SelectFormField.call(this, props));
	    }

	    SearchFormField.prototype.addSpecificClass = function addSpecificClass() {
	        var me = this;
	        if (me.props.jsxprefixCls == "kuma-uxform-field") {
	            return me.props.jsxprefixCls + " kuma-search-uxform-field";
	        } else {
	            return me.props.jsxprefixCls;
	        }
	    };

	    SearchFormField.prototype._processAdvanced = function _processAdvanced() {
	        var me = this;
	        var advancedOptions = me.props.advancedOptions;

	        return advancedOptions.map(function (item) {
	            return React.createElement(Option, { key: item.value, title: item.text }, item.text);
	        });
	    };

	    SearchFormField.prototype._processClassOptions = function _processClassOptions() {
	        var me = this;
	        var classOptions = me.props.classOptions;

	        return classOptions.map(function (item) {
	            return React.createElement(Option, { key: item.value, title: item.text }, item.text);
	        });
	    };

	    SearchFormField.prototype.handleChange = function handleChange(value, label) {
	        var me = this;
	        var stateValue = deepcopy(me.state.value) || {};
	        stateValue.main = value;
	        me.handleDataChange(stateValue, false, label);
	    };

	    SearchFormField.prototype.handleClassChange = function handleClassChange(value) {
	        var me = this;
	        var stateValue = deepcopy(me.state.value) || {};
	        var label = me.state.label;
	        stateValue["class"] = value;
	        me.handleDataChange(stateValue, false, label);
	    };

	    SearchFormField.prototype.handleAdvancedChange = function handleAdvancedChange(value) {
	        var me = this;
	        var stateValue = deepcopy(me.state.value) || {};
	        var label = me.state.label;
	        stateValue.advanced = value;
	        me.handleDataChange(stateValue, false, label);
	    };

	    SearchFormField.prototype.handleIconClick = function handleIconClick(e) {
	        var me = this;
	        me.props.onIconClick(e);
	    };

	    SearchFormField.prototype.renderField = function renderField() {
	        var _options;

	        var me = this;
	        var arr = [];
	        var mode = me.props.jsxmode || me.props.mode;

	        var options = (_options = {
	            ref: "el",
	            key: "select",
	            optionFilterProp: me.props.optionFilterProp,
	            combobox: me.props.combobox,
	            onChange: me.handleChange.bind(me),
	            onSearch: me.handleSearch.bind(me)
	        }, _options['key'] = 'search', _options);

	        selectOptions.forEach(function (item, index) {
	            if (item in me.props) {
	                options[item] = me.props[item];
	            }
	        });

	        if (Object.keys(me.props.jsxdata).length > 0) {
	            options.optionFilterProp = 'title';
	        }

	        // only jsxfetchUrl mode need pass label, for the options always change.
	        // when mounted, state.label is undefined, which cause defalutValue cannot be used.
	        if (!!me.props.jsxfetchUrl && !!me.state.label && me.state.label.length !== 0) {
	            options.label = me.state.label || [];
	        }

	        if (!me.props.combobox || me.state.fromReset) {
	            options.value = me.state.value.main || [];
	        }

	        if (!!me.props.jsxfetchUrl) {
	            options.filterOption = false;
	        }
	        if (!me.props.tidy && me.props.classOptions instanceof Array && me.props.classOptions.length > 0) {
	            arr.push(me.renderClassOptions());
	        }
	        arr.push(React.createElement(Select, options, me._processData()));

	        if (!me.props.tidy && me.props.advancedOptions instanceof Array && me.props.advancedOptions.length > 0) {
	            arr.push(me.renderAdvancedOptions());
	        }
	        arr.push(React.createElement('span', { className: classnames({
	                "kuma-search-uxform-field-icon": true,
	                "tidy-pattern": me.props.tidy
	            }), key: 'icon', onClick: me.handleIconClick.bind(me) }, React.createElement('i', { className: 'kuma-icon kuma-icon-search' })));
	        return arr;
	    };

	    SearchFormField.prototype.renderClassOptions = function renderClassOptions() {
	        var _classnames, _classnames2;

	        var me = this;
	        var _me$props$classConfig = me.props.classConfig;
	        var className = _me$props$classConfig.className;
	        var dropdownClassName = _me$props$classConfig.dropdownClassName;
	        var onChange = _me$props$classConfig.onChange;

	        var otherOptions = _objectWithoutProperties(_me$props$classConfig, ['className', 'dropdownClassName', 'onChange']);

	        var options = assign({}, {
	            showSearch: false,
	            key: 'class',
	            dropdownClassName: classnames((_classnames = {
	                "kuma-uxform-class-dropdown": true
	            }, _classnames[dropdownClassName] = !!dropdownClassName, _classnames)),
	            className: classnames((_classnames2 = {
	                "kuma-uxform-class-search": true
	            }, _classnames2[className] = !!className, _classnames2)),
	            onChange: me.handleClassChange.bind(me)
	        }, otherOptions);
	        return React.createElement(Select, options, me._processClassOptions());
	    };

	    SearchFormField.prototype.renderAdvancedOptions = function renderAdvancedOptions() {
	        var _classnames3;

	        var me = this;
	        var _me$props$advancedCon = me.props.advancedConfig;
	        var className = _me$props$advancedCon.className;
	        var onChange = _me$props$advancedCon.onChange;

	        var otherOptions = _objectWithoutProperties(_me$props$advancedCon, ['className', 'onChange']);

	        var options = assign({}, {
	            showSearch: false,
	            key: 'advanced',
	            className: classnames((_classnames3 = {
	                'kuma-uxform-advanced-search': true
	            }, _classnames3[className] = !!className, _classnames3)),
	            onChange: me.handleAdvancedChange.bind(me)
	        }, otherOptions);
	        return React.createElement(Select, options, me._processAdvanced());
	    };

	    return SearchFormField;
	}(SelectFormField);

	SearchFormField.Option = Option;
	SearchFormField.displayName = "SearchFormField";
	SearchFormField.propTypes = assign({}, SelectFormField.propTypes, {
	    advancedOptions: React.PropTypes.array,
	    advancedConfig: React.PropTypes.object,
	    classOptions: React.PropTypes.array,
	    classConfig: React.PropTypes.object,
	    tidy: React.PropTypes.bool,
	    onIconClick: React.PropTypes.func
	});
	SearchFormField.defaultProps = assign({}, SelectFormField.defaultProps, {
	    jsxshowLabel: false,
	    combobox: true,
	    advancedConfig: {},
	    classConfig: {},
	    tidy: false,
	    onIconClick: function onIconClick() {}
	});

		module.exports = SearchFormField;

/***/ },
/* 501 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Grid Component for uxcore
	 * @author eternalky
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

		module.exports = __webpack_require__(502);

/***/ },
/* 502 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};

	var _createClass = function () {
	    function defineProperties(target, props) {
	        for (var i = 0; i < props.length; i++) {
	            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	        }
	    }return function (Constructor, protoProps, staticProps) {
	        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	    };
	}();

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	/*
	 * Inspired by react-bootstrap: https://github.com/react-bootstrap/react-bootstrap/ 
	 */

	var classNames = __webpack_require__(5);
	var elementType = __webpack_require__(503);
	var Row = __webpack_require__(505);
	var Col = __webpack_require__(506);
	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var Grid = function (_React$Component) {
	    _inherits(Grid, _React$Component);

	    function Grid(props) {
	        _classCallCheck(this, Grid);

	        return _possibleConstructorReturn(this, Object.getPrototypeOf(Grid).call(this, props));
	    }

	    _createClass(Grid, [{
	        key: 'render',
	        value: function render() {
	            var ComponentClass = this.props.componentClass;
	            var className = this.props.fluid ? 'kuma-container-fluid' : 'kuma-container';

	            return React.createElement(ComponentClass, _extends({}, this.props, {
	                className: classNames(this.props.className, className) }), this.props.children);
	        }
	    }]);

	    return Grid;
	}(React.Component);

	Grid.displayName = "Grid";
	Grid.propTypes = {
	    /**
	     * Turn any fixed-width grid layout into a full-width layout by this property.
	     *
	     * Adds `container-fluid` class.
	     */
	    fluid: React.PropTypes.bool,
	    /**
	     * You can use a custom element for this component
	     */
	    componentClass: elementType
	};

	Grid.defaultProps = {
	    componentClass: 'div',
	    fluid: false
	};

	Grid.Row = Row;
	Grid.Col = Col;

	module.exports = Grid;

/***/ },
/* 503 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _common = __webpack_require__(504);

	/**
	 * Checks whether a prop provides a type of element.
	 *
	 * The type of element can be provided in two forms:
	 * - tag name (string)
	 * - a return value of React.createClass(...)
	 *
	 * @param props
	 * @param propName
	 * @param componentName
	 * @returns {Error|undefined}
	 */

	function validate(props, propName, componentName) {
	  var errBeginning = _common.errMsg(props, propName, componentName, '. Expected an Element `type`');

	  if (typeof props[propName] !== 'function') {
	    if (_react2['default'].isValidElement(props[propName])) {
	      return new Error(errBeginning + ', not an actual Element');
	    }

	    if (typeof props[propName] !== 'string') {
	      return new Error(errBeginning + ' such as a tag name or return value of React.createClass(...)');
	    }
	  }
	}

	exports['default'] = _common.createChainableTypeChecker(validate);
	module.exports = exports['default'];

/***/ },
/* 504 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	exports.errMsg = errMsg;
	exports.createChainableTypeChecker = createChainableTypeChecker;

	function errMsg(props, propName, componentName, msgContinuation) {
	  return 'Invalid prop \'' + propName + '\' of value \'' + props[propName] + '\'' + (' supplied to \'' + componentName + '\'' + msgContinuation);
	}

	/**
	 * Create chain-able isRequired validator
	 *
	 * Largely copied directly from:
	 *  https://github.com/facebook/react/blob/0.11-stable/src/core/ReactPropTypes.js#L94
	 */

	function createChainableTypeChecker(validate) {
	  function checkType(isRequired, props, propName, componentName) {
	    componentName = componentName || '<<anonymous>>';
	    if (props[propName] == null) {
	      if (isRequired) {
	        return new Error('Required prop \'' + propName + '\' was not specified in \'' + componentName + '\'.');
	      }
	    } else {
	      return validate(props, propName, componentName);
	    }
	  }

	  var chainedCheckType = checkType.bind(null, false);
	  chainedCheckType.isRequired = checkType.bind(null, true);

	  return chainedCheckType;
		}

/***/ },
/* 505 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};

	var _createClass = function () {
	    function defineProperties(target, props) {
	        for (var i = 0; i < props.length; i++) {
	            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	        }
	    }return function (Constructor, protoProps, staticProps) {
	        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	    };
	}();

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var classNames = __webpack_require__(5);
	var elementType = __webpack_require__(503);
	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var Row = function (_React$Component) {
	    _inherits(Row, _React$Component);

	    function Row(props) {
	        _classCallCheck(this, Row);

	        return _possibleConstructorReturn(this, Object.getPrototypeOf(Row).call(this, props));
	    }

	    _createClass(Row, [{
	        key: 'render',
	        value: function render() {
	            var ComponentClass = this.props.componentClass;

	            return React.createElement(ComponentClass, _extends({}, this.props, { className: classNames(this.props.className, 'kuma-row') }), this.props.children);
	        }
	    }]);

	    return Row;
	}(React.Component);

	Row.displayName = "Row";
	Row.propTypes = {
	    /**
	     * You can use a custom element for this component
	     */
	    componentClass: elementType
	};
	Row.defaultProps = {
	    componentClass: 'div'
	};
		module.exports = Row;

/***/ },
/* 506 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _possibleConstructorReturn(self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var classNames = __webpack_require__(5);
	var styleMaps = __webpack_require__(507);
	var elementType = __webpack_require__(503);
	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var Col = function (_React$Component) {
	  _inherits(Col, _React$Component);

	  function Col(props) {
	    _classCallCheck(this, Col);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(Col).call(this, props));
	  }

	  _createClass(Col, [{
	    key: 'render',
	    value: function render() {
	      var _this2 = this;

	      var ComponentClass = this.props.componentClass;
	      var classes = {};

	      Object.keys(styleMaps.SIZES).forEach(function (key) {
	        var size = styleMaps.SIZES[key];
	        var prop = size;
	        var classPart = size + '-';

	        if (_this2.props[prop]) {
	          classes['col-' + classPart + _this2.props[prop]] = true;
	        }

	        prop = size + 'Offset';
	        classPart = size + '-offset-';
	        if (_this2.props[prop] >= 0) {
	          classes['col-' + classPart + _this2.props[prop]] = true;
	        }

	        prop = size + 'Push';
	        classPart = size + '-push-';
	        if (_this2.props[prop] >= 0) {
	          classes['col-' + classPart + _this2.props[prop]] = true;
	        }

	        prop = size + 'Pull';
	        classPart = size + '-pull-';
	        if (_this2.props[prop] >= 0) {
	          classes['col-' + classPart + _this2.props[prop]] = true;
	        }
	      }, this);

	      return React.createElement(ComponentClass, _extends({}, this.props, { className: classNames(this.props.className, classes) }), this.props.children);
	    }
	  }]);

	  return Col;
	}(React.Component);

	Col.displayName = "Col";
	Col.propTypes = {
	  /**
	   * The number of columns you wish to span
	   *
	   * for Extra small devices Phones (<768px)
	   *
	   * class-prefix `col-xs-`
	   */
	  xs: React.PropTypes.number,
	  /**
	   * The number of columns you wish to span
	   *
	   * for Small devices Tablets (≥768px)
	   *
	   * class-prefix `col-sm-`
	   */
	  sm: React.PropTypes.number,
	  /**
	   * The number of columns you wish to span
	   *
	   * for Medium devices Desktops (≥992px)
	   *
	   * class-prefix `col-md-`
	   */
	  md: React.PropTypes.number,
	  /**
	   * The number of columns you wish to span
	   *
	   * for Large devices Desktops (≥1200px)
	   *
	   * class-prefix `col-lg-`
	   */
	  lg: React.PropTypes.number,
	  /**
	   * Move columns to the right
	   *
	   * for Extra small devices Phones
	   *
	   * class-prefix `col-xs-offset-`
	   */
	  xsOffset: React.PropTypes.number,
	  /**
	   * Move columns to the right
	   *
	   * for Small devices Tablets
	   *
	   * class-prefix `col-sm-offset-`
	   */
	  smOffset: React.PropTypes.number,
	  /**
	   * Move columns to the right
	   *
	   * for Medium devices Desktops
	   *
	   * class-prefix `col-md-offset-`
	   */
	  mdOffset: React.PropTypes.number,
	  /**
	   * Move columns to the right
	   *
	   * for Large devices Desktops
	   *
	   * class-prefix `col-lg-offset-`
	   */
	  lgOffset: React.PropTypes.number,
	  /**
	   * Change the order of grid columns to the right
	   *
	   * for Extra small devices Phones
	   *
	   * class-prefix `col-xs-push-`
	   */
	  xsPush: React.PropTypes.number,
	  /**
	   * Change the order of grid columns to the right
	   *
	   * for Small devices Tablets
	   *
	   * class-prefix `col-sm-push-`
	   */
	  smPush: React.PropTypes.number,
	  /**
	   * Change the order of grid columns to the right
	   *
	   * for Medium devices Desktops
	   *
	   * class-prefix `col-md-push-`
	   */
	  mdPush: React.PropTypes.number,
	  /**
	   * Change the order of grid columns to the right
	   *
	   * for Large devices Desktops
	   *
	   * class-prefix `col-lg-push-`
	   */
	  lgPush: React.PropTypes.number,
	  /**
	   * Change the order of grid columns to the left
	   *
	   * for Extra small devices Phones
	   *
	   * class-prefix `col-xs-pull-`
	   */
	  xsPull: React.PropTypes.number,
	  /**
	   * Change the order of grid columns to the left
	   *
	   * for Small devices Tablets
	   *
	   * class-prefix `col-sm-pull-`
	   */
	  smPull: React.PropTypes.number,
	  /**
	   * Change the order of grid columns to the left
	   *
	   * for Medium devices Desktops
	   *
	   * class-prefix `col-md-pull-`
	   */
	  mdPull: React.PropTypes.number,
	  /**
	   * Change the order of grid columns to the left
	   *
	   * for Large devices Desktops
	   *
	   * class-prefix `col-lg-pull-`
	   */
	  lgPull: React.PropTypes.number,
	  /**
	   * You can use a custom element for this component
	   */
	  componentClass: elementType
	};

	Col.defaultProps = {
	  componentClass: 'div'
	};

		module.exports = Col;

/***/ },
/* 507 */
/***/ function(module, exports) {

	'use strict';

	module.exports = {
	    SIZES: {
	        'large': 'lg',
	        'medium': 'md',
	        'small': 'sm',
	        'xsmall': 'xs',
	        'lg': 'lg',
	        'md': 'md',
	        'sm': 'sm',
	        'xs': 'xs'
	    }
		};

/***/ },
/* 508 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Layout Component for uxcore
	 * @author 
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

		module.exports = __webpack_require__(509);

/***/ },
/* 509 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _createClass = function () {
	    function defineProperties(target, props) {
	        for (var i = 0; i < props.length; i++) {
	            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	        }
	    }return function (Constructor, protoProps, staticProps) {
	        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	    };
	}();

	function _defineProperty(obj, key, value) {
	    if (key in obj) {
	        Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	    } else {
	        obj[key] = value;
	    }return obj;
	}

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	/**
	* @author: eternalsky
	* @time:   10/26 2015
	*/

	var Left = __webpack_require__(510);
	var Right = __webpack_require__(513);
	var classnames = __webpack_require__(5);
	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var Layout = function (_React$Component) {
	    _inherits(Layout, _React$Component);

	    function Layout(props) {
	        _classCallCheck(this, Layout);

	        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Layout).call(this, props));

	        _this.state = {};
	        return _this;
	    }

	    _createClass(Layout, [{
	        key: "processChildren",
	        value: function processChildren() {
	            var me = this;
	            var children = me.props.children;
	            var leftAdaptive = false;
	            var rightAdaptive = false;
	            React.Children.map(children, function (child) {
	                if (child && typeof child.type == 'function' && child.type.displayName == 'Left') {
	                    me.left = child;
	                    leftAdaptive = !!child.props.adaptive;
	                } else if (child && typeof child.type == 'function' && child.type.displayName == 'Right') {
	                    me.right = child;
	                    rightAdaptive = !!child.props.adaptive;
	                }
	            });

	            me.suffix = me.getSuffix(leftAdaptive, rightAdaptive);
	            if (me.suffix == 'rf') {
	                me.rightStyle = {
	                    marginLeft: -me.right.props.width
	                };
	                me.leftStyle = {
	                    paddingRight: me.right.props.width
	                };
	            } else if (me.suffix == 'lf') {
	                me.rightStyle = {
	                    paddingLeft: me.left.props.width
	                };
	                me.leftStyle = {
	                    marginRight: -me.left.props.width
	                };
	            }
	            return me.generateClass(me.suffix);
	        }
	    }, {
	        key: "getSuffix",
	        value: function getSuffix(leftAdaptive, rightAdaptive) {
	            var suffix = '';
	            // 如果都是非自适应，则为 fixed
	            if (!leftAdaptive && !rightAdaptive) {
	                suffix = 'fixed';
	            }
	            // 左侧定宽，右侧自适应，lf
	            else if (!leftAdaptive && rightAdaptive) {
	                    suffix = 'lf';
	                }
	                // 左侧自适应，右侧定宽，rf
	                else if (leftAdaptive && !rightAdaptive) {
	                        suffix = 'rf';
	                    } else {
	                        console.error("left and right cannot be both adaptive, layout generation failed");
	                    }
	            return suffix;
	        }
	    }, {
	        key: "generateClass",
	        value: function generateClass(suffix) {
	            var me = this;
	            var length = React.Children.count(me.props.children);
	            var layoutCls = '';
	            var leftCls = '';
	            var rightCls = '';

	            if (length == 2) {
	                layoutCls = 'kuma-layout-2c';
	            } else if (lengthCls == 3) {
	                layoutCls = 'kuma-layout-3c';
	            } else {
	                console.error("children length should be 2 or 3, layout generation failed");
	            }

	            leftCls = layoutCls + '-left-' + suffix;
	            rightCls = layoutCls + '-right-' + suffix;
	            return {
	                layoutCls: layoutCls,
	                leftCls: leftCls,
	                rightCls: rightCls
	            };
	        }
	    }, {
	        key: "renderLeft",
	        value: function renderLeft(cls) {
	            var me = this;
	            if (!!me.left) {
	                var _classnames;

	                return React.cloneElement(me.left, {
	                    className: classnames((_classnames = {}, _defineProperty(_classnames, me.left.props.className, !!me.left.props.className), _defineProperty(_classnames, cls.leftCls, true), _classnames)),
	                    style: me.leftStyle || {},
	                    key: 'left'
	                });
	            }
	        }
	    }, {
	        key: "renderRight",
	        value: function renderRight(cls) {
	            var me = this;
	            if (!!me.right) {
	                var _classnames2;

	                return React.cloneElement(me.right, {
	                    className: classnames((_classnames2 = {}, _defineProperty(_classnames2, me.right.props.className, !!me.right.props.className), _defineProperty(_classnames2, cls.rightCls, true), _classnames2)),
	                    style: me.rightStyle || {},
	                    key: 'right'
	                });
	            }
	        }
	    }, {
	        key: "renderLayout",
	        value: function renderLayout(cls) {
	            var me = this;
	            var arr = [];
	            if (me.suffix == 'lf') {
	                arr.push(me.renderRight(cls));
	                arr.push(me.renderLeft(cls));
	            } else {
	                arr.push(me.renderLeft(cls));
	                arr.push(me.renderRight(cls));
	            }
	            return arr;
	        }
	    }, {
	        key: "render",
	        value: function render() {
	            var _classnames3;

	            var me = this;
	            var cls = me.processChildren();
	            return React.createElement("div", { className: classnames((_classnames3 = {}, _defineProperty(_classnames3, me.props.className, !!me.props.className), _defineProperty(_classnames3, cls.layoutCls, true), _defineProperty(_classnames3, "fn-clear", true), _classnames3)) }, me.renderLayout(cls));
	        }
	    }]);

	    return Layout;
	}(React.Component);

	Layout.Left = Left;
	Layout.Right = Right;
	Layout.displayName = "Layout";
	Layout.defaultProps = {};
	Layout.propTypes = {};
	module.exports = Layout;

/***/ },
/* 510 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var Item = __webpack_require__(511);

	var Left = function (_Item) {
	    _inherits(Left, _Item);

	    function Left(props) {
	        _classCallCheck(this, Left);

	        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Left).call(this, props));

	        _this.state = {};
	        return _this;
	    }

	    return Left;
	}(Item);

	Left.displayName = "Left";
	Left.defaultProps = Item.defaultProps;
	Left.propTypes = Item.propTypes;
	module.exports = Left;

/***/ },
/* 511 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _createClass = function () {
	    function defineProperties(target, props) {
	        for (var i = 0; i < props.length; i++) {
	            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	        }
	    }return function (Constructor, protoProps, staticProps) {
	        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	    };
	}();

	function _defineProperty(obj, key, value) {
	    if (key in obj) {
	        Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	    } else {
	        obj[key] = value;
	    }return obj;
	}

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var classnames = __webpack_require__(5);
	var assign = __webpack_require__(512);
	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var LayoutItem = function (_React$Component) {
	    _inherits(LayoutItem, _React$Component);

	    function LayoutItem(props) {
	        _classCallCheck(this, LayoutItem);

	        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(LayoutItem).call(this, props));

	        _this.state = {};
	        return _this;
	    }

	    _createClass(LayoutItem, [{
	        key: 'render',
	        value: function render() {
	            var me = this;
	            var style = {};
	            if (!me.props.adaptive) {
	                style.width = me.props.width;
	            }
	            return React.createElement('div', { className: classnames(_defineProperty({}, me.props.className, !!me.props.className)), style: assign({}, style, me.props.style) }, me.props.children);
	        }
	    }]);

	    return LayoutItem;
	}(React.Component);

	LayoutItem.displayName = "LayoutItem";
	LayoutItem.defaultProps = {
	    width: 500
	};
	LayoutItem.propTypes = {
	    width: React.PropTypes.number,
	    adaptive: React.PropTypes.bool
	};
		module.exports = LayoutItem;

/***/ },
/* 512 */
33,
/* 513 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var Item = __webpack_require__(511);

	var Right = function (_Item) {
	    _inherits(Right, _Item);

	    function Right(props) {
	        _classCallCheck(this, Right);

	        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Right).call(this, props));

	        _this.state = {};
	        return _this;
	    }

	    return Right;
	}(Item);

	Right.displayName = "Right";
	Right.defaultProps = Item.defaultProps;
	Right.propTypes = Item.propTypes;
	module.exports = Right;

/***/ },
/* 514 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Mention Component for uxcore
	 * @author
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

		module.exports = __webpack_require__(515);

/***/ },
/* 515 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	exports.__esModule = true;

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(4);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _panel = __webpack_require__(516);

	var _panel2 = _interopRequireDefault(_panel);

	var _editor = __webpack_require__(517);

	var _editor2 = _interopRequireDefault(_editor);

	var _keycode = __webpack_require__(520);

	var _util = __webpack_require__(519);

	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { "default": obj };
	}

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	} /**
	   * @author: vincent.bian
	   */

	var __matchTimer = void 0;

	var Mention = function (_React$Component) {
	    _inherits(Mention, _React$Component);

	    function Mention(props) {
	        _classCallCheck(this, Mention);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.state = {
	            target: null,
	            mentionList: [],
	            cursorPosition: {
	                x: 0,
	                y: 0
	            },
	            panelVisible: false,
	            panelIdx: 0
	        };
	        return _this;
	    }

	    Mention.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
	        if (prevState.mentionList.length !== this.state.mentionList.length) {
	            this.setState({
	                panelVisible: this.state.mentionList.length > 0
	            });
	        }
	        if (!prevState.panelVisible && this.state.panelVisible) {
	            this.setState({
	                panelIdx: 0
	            });
	        }
	    };

	    Mention.prototype.selectItem = function selectItem(data) {
	        this.setState({
	            target: {
	                data: data,
	                t: new Date().getTime()
	            },
	            mentionList: []
	        });
	    };

	    Mention.prototype.runMatcher = function runMatcher(str) {
	        var _this2 = this;

	        __matchTimer && clearTimeout(__matchTimer);
	        __matchTimer = setTimeout(function () {
	            _this2._matcher(str);
	        }.bind(this), this.props.delay);
	    };

	    Mention.prototype._matcher = function _matcher(str) {
	        // console.log(`matcher run with: ${str}`);
	        var _props = this.props;
	        var source = _props.source;
	        var matchRange = _props.matchRange;

	        this.setState({
	            panelVisible: false,
	            mentionList: []
	        });
	        if (str.length >= matchRange[0] && str.length <= matchRange[1]) {
	            if (Array.isArray(source)) {
	                this._next(source.filter(function (item) {
	                    return item.indexOf(str) !== -1;
	                }));
	            } else {
	                source(str, this._next.bind(this));
	            }
	        }
	    };

	    Mention.prototype.setPanelPos = function setPanelPos(pos) {
	        var offset = (0, _util.getScrollOffset)();
	        pos = {
	            x: pos.x + offset.x,
	            y: pos.y + offset.y
	        };
	        this.setState({
	            cursorPosition: pos
	        });
	    };

	    Mention.prototype._next = function _next(matchResult) {
	        if (this.props.formatter) {
	            matchResult = this.props.formatter(matchResult);
	        }
	        this.setState({
	            mentionList: matchResult
	        });
	    };

	    Mention.prototype.onKeyup = function onKeyup(e) {
	        if (this.state.panelVisible) {
	            var count = this.state.mentionList.length;
	            switch (e.keyCode) {
	                case _keycode.KEYCODE.UP:
	                    this.setState({
	                        panelIdx: this.state.panelIdx === 0 ? count - 1 : this.state.panelIdx - 1
	                    });
	                    break;
	                case _keycode.KEYCODE.DOWN:
	                    this.setState({
	                        panelIdx: this.state.panelIdx === count - 1 ? 0 : this.state.panelIdx + 1
	                    });
	                    break;
	                case _keycode.KEYCODE.ENTER:
	                    this.selectItem(this.state.mentionList[this.state.panelIdx]);
	                    break;
	                default:
	                    this.setState({
	                        mentionList: []
	                    });
	                    break;
	            }
	        }
	    };

	    Mention.prototype.render = function render() {
	        var props = this.props;
	        var panelPosition = {
	            left: this.state.cursorPosition.x,
	            top: this.state.cursorPosition.y
	        };
	        var width = props.width;
	        var height = props.height;
	        var prefixCls = props.prefixCls;

	        return _react2["default"].createElement('div', { onKeyUp: this.onKeyup.bind(this) }, _react2["default"].createElement(_editor2["default"], {
	            width: width,
	            height: height,
	            prefixCls: prefixCls,
	            panelVisible: this.state.panelVisible,
	            matcher: this.runMatcher.bind(this),
	            mentionTarget: this.state.target,
	            setCursorPos: this.setPanelPos.bind(this),
	            formatter: props.mentionFormatter,
	            onChange: props.onChange
	        }, props.children), _react2["default"].createElement(_panel2["default"], {
	            prefixCls: prefixCls,
	            visible: this.state.panelVisible,
	            idx: this.state.panelIdx,
	            list: this.state.mentionList,
	            onSelect: this.selectItem.bind(this),
	            formatter: props.panelFormatter,
	            style: panelPosition }));
	    };

	    return Mention;
	}(_react2["default"].Component);

	exports["default"] = Mention;

	Mention.displayName = 'uxcore-mention';
	Mention.propType = {
	    prefixCls: _react2["default"].PropTypes.string,
	    width: _react2["default"].PropTypes.number,
	    height: _react2["default"].PropTypes.number,
	    source: _react2["default"].PropTypes.oneOfType([_react2["default"].PropTypes.array, _react2["default"].PropTypes.func]),
	    delay: _react2["default"].PropTypes.number,
	    matchRange: _react2["default"].PropTypes.arrayOf(_react2["default"].PropTypes.number),
	    formatter: _react2["default"].PropTypes.func,
	    panelFormatter: _react2["default"].PropTypes.func,
	    mentionFormatter: _react2["default"].PropTypes.func,
	    onChange: _react2["default"].PropTypes.func
	};
	Mention.defaultProps = {
	    prefixCls: 'kuma-mention',
	    width: 200,
	    height: 100,
	    source: [],
	    delay: 100,
	    matchRange: [2, 8],
	    formatter: function formatter(data) {
	        return data;
	    },
	    panelFormatter: function panelFormatter(data) {
	        return '' + data.text;
	    },
	    mentionFormatter: function mentionFormatter(data) {
	        return '@' + data.text;
	    },
	    onChange: function onChange(e, value) {}
	};
		module.exports = exports['default'];

/***/ },
/* 516 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	exports.__esModule = true;

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _classnames = __webpack_require__(5);

	var _classnames2 = _interopRequireDefault(_classnames);

	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : { "default": obj };
	}

	function _classCallCheck(instance, Constructor) {
		if (!(instance instanceof Constructor)) {
			throw new TypeError("Cannot call a class as a function");
		}
	}

	function _possibleConstructorReturn(self, call) {
		if (!self) {
			throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		}return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
		if (typeof superClass !== "function" && superClass !== null) {
			throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
		}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var Panel = function (_React$Component) {
		_inherits(Panel, _React$Component);

		function Panel(props) {
			_classCallCheck(this, Panel);

			return _possibleConstructorReturn(this, _React$Component.call(this, props));
		}

		Panel.prototype.render = function render() {
			var _this2 = this;

			var props = this.props;
			var onSelect = props.onSelect;
			var list = props.list;
			var style = props.style;
			var visible = props.visible;
			var idx = props.idx;
			var formatter = props.formatter;
			var prefixCls = props.prefixCls;

			var clsObj = {};
			clsObj[prefixCls + '-panel'] = true;
			clsObj[prefixCls + '-panel-visible'] = visible;
			var cls = (0, _classnames2["default"])(clsObj);
			return _react2["default"].createElement('ul', { className: cls, style: style }, list.map(function (item, index) {
				var itemClsObj = {};
				itemClsObj[prefixCls + '-panel-item'] = true;
				itemClsObj[prefixCls + '-panel-item-current'] = idx === index;
				var itemCls = (0, _classnames2["default"])(itemClsObj);
				return _react2["default"].createElement('li', { className: itemCls, key: index, onClick: onSelect.bind(_this2, item) }, _react2["default"].createElement('div', { dangerouslySetInnerHTML: { __html: formatter(item) } }));
			}));
		};

		return Panel;
	}(_react2["default"].Component);

	exports["default"] = Panel;

	Panel.displayName = 'uxcore-mention-panel';
	Panel.propType = {
		prefixCls: _react2["default"].PropTypes.string,
		list: _react2["default"].PropTypes.array,
		style: _react2["default"].PropTypes.object,
		idx: _react2["default"].PropTypes.number,
		onSelect: _react2["default"].PropTypes.func,
		formatter: _react2["default"].PropTypes.func
	};
	Panel.defaultProps = {
		prefixCls: '',
		list: [],
		style: {},
		idx: 0,
		onSelect: null,
		formatter: ''
	};
		module.exports = exports['default'];

/***/ },
/* 517 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	exports.__esModule = true;

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	__webpack_require__(518);

	var _util = __webpack_require__(519);

	var _keycode = __webpack_require__(520);

	var _classnames = __webpack_require__(5);

	var _classnames2 = _interopRequireDefault(_classnames);

	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { "default": obj };
	}

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}
	// import rangy from 'rangy';

	var __store = {};
	//webkit browsers support 'plaintext-only'
	var contentEditableValue = function () {
	    var div = document.createElement('div');
	    div.setAttribute('contenteditable', 'PLAINTEXT-ONLY');
	    return div.contentEditable === 'plaintext-only' ? 'plaintext-only' : true;
	}();

	var Editor = function (_React$Component) {
	    _inherits(Editor, _React$Component);

	    function Editor(props) {
	        _classCallCheck(this, Editor);

	        return _possibleConstructorReturn(this, _React$Component.call(this, props));
	    }

	    Editor.prototype.componentDidMount = function componentDidMount() {
	        // let editor = this.refs.editor;
	    };

	    Editor.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	        if (nextProps.mentionTarget && (!this.props.mentionTarget || this.props.mentionTarget.t !== nextProps.mentionTarget.t)) {
	            this.insertMentionTarget(nextProps.mentionTarget.data);
	        }
	    };

	    Editor.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
	        if (this.props.children !== nextProps.children) {
	            return true;
	        }
	        return false;
	    };

	    Editor.prototype.onKeydown = function onKeydown(e) {
	        switch (e.keyCode) {
	            case _keycode.KEYCODE.UP:
	            case _keycode.KEYCODE.DOWN:
	                if (this.props.panelVisible) {
	                    e.preventDefault();
	                }
	                break;
	            case _keycode.KEYCODE.ENTER:
	                // insert br at the end of line
	                e.preventDefault();
	                if (!this.props.panelVisible) {
	                    var editor = this.refs.editor;
	                    var sel = rangy.getSelection();
	                    var range = sel.getRangeAt(0);

	                    // make sure the last element of the editor is br
	                    // refer to: http://stackoverflow.com/questions/6023307/dealing-with-line-breaks-on-contenteditable-div
	                    if (!editor.lastChild || editor.lastChild.nodeName.toLowerCase() !== 'br') {
	                        editor.appendChild(document.createElement('br'));
	                    }
	                    var nodeBr = document.createElement('br');
	                    range.deleteContents();
	                    range.insertNode(nodeBr);
	                    range.setStartAfter(nodeBr);
	                    sel.setSingleRange(range);
	                }
	                break;
	                // default:
	                //     this.props.onChange('xxx');
	                break;
	        }
	    };

	    Editor.prototype.onKeyup = function onKeyup(e) {
	        // if (this.props.panelVisible) {return;}
	        switch (e.keyCode) {
	            case _keycode.KEYCODE.UP:
	            case _keycode.KEYCODE.DOWN:
	                if (this.props.panelVisible) {
	                    e.preventDefault();
	                }
	                break;
	            case _keycode.KEYCODE.ENTER:
	                break;
	            default:
	                var sel = rangy.getSelection();
	                var range = sel.getRangeAt(0);
	                if (range.commonAncestorContainer.nodeType === 3) {
	                    range.setStart(range.commonAncestorContainer, 0);
	                    var originStr = range.toString();
	                    var str = (0, _util.parseStrByDelimiter)(originStr, '@');
	                    // send str to matcher
	                    this.props.matcher(str);
	                    if (str) {
	                        this.props.setCursorPos(range.getEndClientPos());
	                        // set range's start position before delimiter
	                        range.setStart(range.commonAncestorContainer, originStr.length - str.length - 1);
	                        // save range position
	                        __store.bookmark = range.getBookmark(range.commonAncestorContainer);
	                    }
	                }
	                break;
	        }
	    };

	    Editor.prototype.insertMentionTarget = function insertMentionTarget(mentionData) {
	        // console.log(mentionData);
	        var editor = this.refs.editor;
	        var sel = rangy.getSelection();
	        var formatter = this.props.formatter;
	        if (__store.bookmark) {
	            var range = sel.getRangeAt(0);
	            range.moveToBookmark(__store.bookmark);
	            var mentionNode = document.createElement('input');
	            mentionNode.setAttribute('type', 'button');
	            mentionNode.setAttribute('tabindex', '-1');
	            mentionNode.className = this.props.prefixCls + '-node';
	            mentionNode.value = formatter(mentionData);
	            // delete origin content in range
	            range.deleteContents();
	            range.insertNode(mentionNode);
	            range.collapseAfter(mentionNode);
	            range.select();
	            setTimeout(function () {
	                editor.focus();
	            }, 0);
	        }
	    };

	    Editor.prototype.render = function render() {
	        var style = {
	            width: this.props.width,
	            height: this.props.height
	        };
	        var className = (0, _classnames2["default"])(this.props.prefixCls, this.props.prefixCls + '-editor');
	        return _react2["default"].createElement('div', { className: className, ref: 'editor',
	            onKeyUp: this.onKeyup.bind(this),
	            onKeyDown: this.onKeydown.bind(this),
	            contentEditable: contentEditableValue,
	            onInput: this.emitChange.bind(this),
	            onBlur: this.emitChange.bind(this),
	            style: style }, this.props.children);
	    };

	    Editor.prototype.emitChange = function emitChange(e) {
	        var editor = this.refs.editor;
	        var nodes = editor.childNodes;
	        var content = '';
	        for (var i = 0, len = nodes.length; i < len; i += 1) {
	            if (nodes[i].nodeType === 1) {
	                var tagName = nodes[i].tagName.toLowerCase();
	                if (tagName === 'input') {
	                    content += ' ' + nodes[i].value + ' ';
	                } else if (tagName === 'br') {
	                    content += '\n';
	                }
	            } else if (nodes[i].nodeType === 3) {
	                content += nodes[i].textContent || nodes[i].nodeValue;
	            }
	        }
	        this.props.onChange(e, content);
	    };

	    return Editor;
	}(_react2["default"].Component);

	exports["default"] = Editor;

	Editor.displayName = 'uxcore-mention-editor';
	Editor.propType = {
	    prefixCls: _react2["default"].PropTypes.string,
	    width: _react2["default"].PropTypes.number,
	    height: _react2["default"].PropTypes.number,
	    mentionTarget: _react2["default"].PropTypes.object,
	    matcher: _react2["default"].PropTypes.func,
	    setCursorPos: _react2["default"].PropTypes.func,
	    panelVisible: _react2["default"].PropTypes.bool,
	    formatter: _react2["default"].PropTypes.func,
	    onChange: _react2["default"].PropTypes.func
	};
	Editor.defaultProps = {
	    prefixCls: '',
	    width: 200,
	    height: 100,
	    mentionTarget: null,
	    matcher: function matcher() {},
	    setCursorPos: function setCursorPos() {},
	    panelVisible: false,
	    formatter: function formatter() {},
	    onChange: function onChange() {}
	};
		module.exports = exports['default'];

/***/ },
/* 518 */
/***/ function(module, exports) {

	"use strict";

	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	    return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	    return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};

	/**
	 * Position module for Rangy.
	 * Extensions to Range and Selection objects to provide access to pixel positions relative to the viewport or document.
	 *
	 * Part of Rangy, a cross-browser JavaScript range and selection library
	 * https://github.com/timdown/rangy
	 *
	 * Depends on Rangy core.
	 *
	 * Copyright %%build:year%%, Tim Down
	 * Licensed under the MIT license.
	 * Version: %%build:version%%
	 * Build date: %%build:date%%
	 */
	// import rangy from 'rangy';
	if (typeof rangy !== 'undefined') {
	    rangy.createModule("Position", ["WrappedSelection"], function (api, module) {
	        //var log = log4javascript.getLogger("rangy.position");

	        var NUMBER = "number",
	            UNDEF = "undefined";
	        var WrappedRange = api.WrappedRange;
	        var WrappedTextRange = api.WrappedTextRange;
	        var dom = api.dom,
	            util = api.util,
	            DomPosition = dom.DomPosition;

	        // Feature detection

	        //var caretPositionFromPointSupported = (typeof document.caretPositionFromPoint != UNDEF);

	        // Since Rangy can deal with multiple documents which could be in different modes, we have to do the checks every
	        // time, unless we cache a getScrollPosition function in each document. This would necessarily pollute the
	        // document's global namespace, which I'm choosing to view as a greater evil than a slight performance hit.
	        function getScrollPosition(win) {
	            var x = 0,
	                y = 0;
	            if (_typeof(win.pageXOffset) == NUMBER && _typeof(win.pageYOffset) == NUMBER) {
	                x = win.pageXOffset;
	                y = win.pageYOffset;
	            } else {
	                var doc = win.document;
	                var docEl = doc.documentElement;
	                var compatMode = doc.compatMode;
	                var scrollEl = typeof compatMode == "string" && compatMode.indexOf("CSS") >= 0 && docEl ? docEl : dom.getBody(doc);

	                if (scrollEl && _typeof(scrollEl.scrollLeft) == NUMBER && _typeof(scrollEl.scrollTop) == NUMBER) {
	                    try {
	                        x = scrollEl.scrollLeft;
	                        y = scrollEl.scrollTop;
	                    } catch (ex) {}
	                }
	            }
	            return { x: x, y: y };
	        }

	        function getAncestorElement(node, tagName) {
	            tagName = tagName.toLowerCase();
	            while (node) {
	                if (node.nodeType == 1 && node.tagName.toLowerCase() == tagName) {
	                    return node;
	                }
	                node = node.parentNode;
	            }
	            return null;
	        }

	        function Rect(top, right, bottom, left) {
	            this.top = top;
	            this.right = right;
	            this.bottom = bottom;
	            this.left = left;
	            this.width = right - left;
	            this.height = bottom - top;
	        }

	        function createRelativeRect(rect, dx, dy) {
	            return new Rect(rect.top + dy, rect.right + dx, rect.bottom + dy, rect.left + dx);
	        }

	        function adjustClientRect(rect, doc) {
	            // Older IEs have an issue with a two pixel margin on the body element
	            var dx = 0,
	                dy = 0;
	            var docEl = doc.documentElement,
	                body = dom.getBody(doc);
	            var container = docEl.clientWidth === 0 && _typeof(body.clientTop) == NUMBER ? body : docEl;
	            var clientLeft = container.clientLeft,
	                clientTop = container.clientTop;
	            if (clientLeft) {
	                dx = -clientLeft;
	            }
	            if (clientTop) {
	                dy = -clientTop;
	            }
	            return createRelativeRect(rect, dx, dy);
	        }

	        function mergeRects(rects) {
	            var tops = [],
	                bottoms = [],
	                lefts = [],
	                rights = [];
	            for (var i = 0, len = rects.length, rect; i < len; ++i) {
	                rect = rects[i];
	                if (rect) {
	                    tops.push(rect.top);
	                    bottoms.push(rect.bottom);
	                    lefts.push(rect.left);
	                    rights.push(rect.right);
	                }
	            }
	            return new Rect(Math.min.apply(Math, tops), Math.max.apply(Math, rights), Math.max.apply(Math, bottoms), Math.min.apply(Math, lefts));
	        }

	        function getTextRangePosition(doc, x, y) {
	            var textRange = dom.getBody(doc).createTextRange();
	            textRange.moveToPoint(x, y);
	            var range = new api.WrappedTextRange(textRange);
	            return new DomPosition(range.startContainer, range.startOffset);
	        }

	        function caretPositionFromPoint(doc, x, y) {
	            var pos = doc.caretPositionFromPoint(x, y);
	            return new DomPosition(pos.offsetNode, pos.offset);
	        }

	        function caretRangeFromPoint(doc, x, y) {
	            var range = doc.caretRangeFromPoint(x, y);
	            return new DomPosition(range.startContainer, range.startOffset);
	        }

	        function getLastRangeRect(range) {
	            var rects = (range.nativeRange || range).getClientRects();
	            return rects.length > 0 ? rects[rects.length - 1] : null;
	        }

	        function pointIsInOrAboveRect(x, y, rect) {
	            console.log("pointIsInOrAboveRect", x, y, Math.floor(rect.top), Math.floor(rect.right), Math.floor(rect.bottom), Math.floor(rect.left));
	            return y < rect.bottom && x >= rect.left && x <= rect.right;
	        }

	        function positionFromPoint(doc, x, y, favourPrecedingPosition) {
	            var el = doc.elementFromPoint(x, y);

	            console.log("elementFromPoint is ", el);

	            var range = api.createRange(doc);
	            range.selectNodeContents(el);
	            range.collapse(true);

	            var node = el.firstChild,
	                offset,
	                rect,
	                textLen;

	            if (!node) {
	                node = el.parentNode;
	                offset = dom.getNodeIndex(el);
	                if (!favourPrecedingPosition) {
	                    ++offset;
	                }
	            } else {
	                // Search through the text node children of el
	                main: while (node) {
	                    console.log(node);
	                    if (node.nodeType == 3) {
	                        // Go through the text node character by character
	                        for (offset = 0, textLen = node.length; offset <= textLen; ++offset) {
	                            range.setEnd(node, offset);
	                            rect = getLastRangeRect(range);
	                            if (rect && pointIsInOrAboveRect(x, y, rect)) {
	                                // We've gone past the point. Now we check which side (left or right) of the character the point is nearer to
	                                if (rect.right - x > x - rect.left) {
	                                    --offset;
	                                }
	                                break main;
	                            }
	                        }
	                    } else {
	                        // Handle elements
	                        range.setEndAfter(node);
	                        rect = getLastRangeRect(range);
	                        if (rect && pointIsInOrAboveRect(x, y, rect)) {
	                            offset = dom.getNodeIndex(node);
	                            node = el.parentNode;
	                            if (!favourPrecedingPosition) {
	                                ++offset;
	                            }
	                            break;
	                        }
	                    }

	                    node = node.nextSibling;
	                }
	                if (!node) {
	                    node = el;
	                    offset = el.childNodes.length;
	                }
	            }

	            return new DomPosition(node, offset);
	        }

	        function createCaretPositionFromPointGetter(doc) {
	            if (api.features.implementsTextRange) {
	                return getTextRangePosition;
	            } else if (_typeof(doc.caretPositionFromPoint) != UNDEF) {
	                return caretPositionFromPoint;
	            } else if (_typeof(doc.caretRangeFromPoint) != UNDEF) {
	                return caretRangeFromPoint;
	            } else if (_typeof(doc.elementFromPoint) != UNDEF && rangeSupportsGetClientRects) {
	                return positionFromPoint;
	            } else {
	                throw module.createError("createCaretPositionFromPointGetter(): Browser does not provide a recognised method to create a selection from pixel coordinates");
	            }
	        }

	        function createRangeFromPoints(startX, startY, endX, endY, doc) {
	            doc = dom.getContentDocument(doc, module, "createRangeFromPoints");
	            var positionFinder = createCaretPositionFromPointGetter(doc);
	            var startPos = positionFinder(doc, startX, startY, false);
	            var endPos = positionFinder(doc, endX, endY, true);
	            console.log(startPos.node, startPos.offset, endPos.node, endPos.offset);
	            var range = api.createRange(doc);
	            range.setStartAndEnd(startPos.node, startPos.offset, endPos.node, endPos.offset);
	            return range;
	        }

	        function moveSelectionToPoints(anchorX, anchorY, focusX, focusY, doc) {
	            var startX, startY, endX, endY;

	            // Detect backward selection for coordinates and flip start and end coordinates if necessary
	            var backward = focusY < anchorY || anchorY == focusY && focusX < anchorX;

	            if (backward) {
	                startX = focusX;
	                startY = focusY;
	                endX = anchorX;
	                endY = anchorY;
	            } else {
	                startX = anchorX;
	                startY = anchorY;
	                endX = focusX;
	                endY = focusY;
	            }

	            var sel = rangy.getSelection(doc);
	            var range = createRangeFromPoints(startX, startY, endX, endY, doc);
	            sel.setSingleRange(range);
	            return sel;
	        }

	        // Test that <span> elements support getBoundingClientRect
	        var span = document.createElement("span");
	        var elementSupportsGetBoundingClientRect = util.isHostMethod(span, "getBoundingClientRect");
	        span = null;

	        // Test for getBoundingClientRect support in Range
	        var rangeSupportsGetClientRects = false,
	            rangeSupportsGetBoundingClientRect = false;
	        if (api.features.implementsDomRange) {
	            var testRange = api.createNativeRange();
	            rangeSupportsGetClientRects = util.isHostMethod(testRange, "getClientRects");
	            rangeSupportsGetBoundingClientRect = util.isHostMethod(testRange, "getBoundingClientRect");
	        }

	        util.extend(api.features, {
	            rangeSupportsGetBoundingClientRect: rangeSupportsGetBoundingClientRect,
	            rangeSupportsGetClientRects: rangeSupportsGetClientRects,
	            elementSupportsGetBoundingClientRect: elementSupportsGetBoundingClientRect
	        });

	        var createClientBoundaryPosGetter = function createClientBoundaryPosGetter(isStart) {
	            return function () {
	                // var boundaryRange = this.cloneRange();
	                // boundaryRange.collapse(isStart);
	                // var rect = boundaryRange.getBoundingClientRect();
	                var rect = this.getBoundingClientRect();
	                return {
	                    x: rect[isStart ? "left" : "right"],
	                    y: rect[isStart ? "top" : "bottom"]
	                };
	            };
	        };

	        var rangeProto = api.rangePrototype;

	        if (api.features.implementsTextRange && elementSupportsGetBoundingClientRect) {
	            rangeProto.getBoundingClientRect = function () {
	                // We need a TextRange
	                var textRange = WrappedTextRange.rangeToTextRange(this);

	                // Work around table problems (table cell bounding rects seem not to count if TextRange spans cells)
	                var cells = this.getNodes([1], function (el) {
	                    return (/^t[dh]$/i.test(el.tagName)
	                    );
	                });

	                // Merge rects for each cell selected by the range into overall rect
	                var rect,
	                    rects = [];
	                if (cells.length > 0) {
	                    var lastTable = getAncestorElement(this.startContainer, "table");

	                    for (var i = 0, cell, tempTextRange, table, subRange; cell = cells[i]; ++i) {
	                        // Handle non-table sections of the range
	                        table = getAncestorElement(cell, "table");
	                        if (!lastTable || table != lastTable) {
	                            // There is a section of the range prior to the current table, or lying between tables.
	                            // Merge in its rect
	                            subRange = this.cloneRange();
	                            if (lastTable) {
	                                subRange.setStartAfter(lastTable);
	                            }
	                            subRange.setEndBefore(table);
	                            rects.push(WrappedTextRange.rangeToTextRange(subRange).getBoundingClientRect());
	                        }

	                        if (this.containsNode(cell)) {
	                            rects.push(cell.getBoundingClientRect());
	                        } else {
	                            tempTextRange = textRange.duplicate();
	                            tempTextRange.moveToElementText(cell);
	                            if (tempTextRange.compareEndPoints("StartToStart", textRange) == -1) {
	                                tempTextRange.setEndPoint("StartToStart", textRange);
	                            } else if (tempTextRange.compareEndPoints("EndToEnd", textRange) == 1) {
	                                tempTextRange.setEndPoint("EndToEnd", textRange);
	                            }
	                            rects.push(tempTextRange.getBoundingClientRect());
	                        }
	                        lastTable = table;
	                    }

	                    // Merge in the rect for any content lying after the final table
	                    var endTable = getAncestorElement(this.endContainer, "table");
	                    if (!endTable && lastTable) {
	                        subRange = this.cloneRange();
	                        subRange.setStartAfter(lastTable);
	                        rects.push(WrappedTextRange.rangeToTextRange(subRange).getBoundingClientRect());
	                    }
	                    rect = mergeRects(rects);
	                } else {
	                    rect = textRange.getBoundingClientRect();
	                }

	                return adjustClientRect(rect, dom.getDocument(this.startContainer));
	            };
	        } else if (api.features.implementsDomRange) {
	            var createWrappedRange = function createWrappedRange(range) {
	                return range instanceof WrappedRange ? range : new WrappedRange(range);
	            };
	            if (rangeSupportsGetBoundingClientRect) {
	                rangeProto.getBoundingClientRect = function () {
	                    var nativeRange = createWrappedRange(this).nativeRange;
	                    // Test for WebKit getBoundingClientRect bug (https://bugs.webkit.org/show_bug.cgi?id=65324)
	                    var rect = nativeRange.getBoundingClientRect() || nativeRange.getClientRects()[0];
	                    return adjustClientRect(rect, dom.getDocument(this.startContainer));
	                };

	                if (rangeSupportsGetClientRects) {

	                    createClientBoundaryPosGetter = function createClientBoundaryPosGetter(isStart) {
	                        return function () {
	                            var rect,
	                                nativeRange = createWrappedRange(this).nativeRange;
	                            var rects = nativeRange.getClientRects();

	                            if (rects.length === 0 && elementSupportsGetBoundingClientRect) {
	                                if (isStart) {}

	                                console.log(nativeRange, nativeRange.getClientRects(), nativeRange.getBoundingClientRect());
	                                if (this.collapsed && this.startContainer.nodeType === 1 && this.startOffset < this.startContainer.childNodes.length) {
	                                    var n = this.startContainer.childNodes[this.startOffset];
	                                    if (n.getClientRects) {
	                                        console.log(n, n.getClientRects(), this.startContainer.getClientRects());
	                                    }
	                                }
	                            }

	                            if (rects.length > 0) {
	                                if (isStart) {
	                                    rect = rects[0];
	                                    return { x: rect.left, y: rect.top };
	                                } else {
	                                    rect = rects[rects.length - 1];
	                                    return { x: rect.right, y: rect.bottom };
	                                }
	                            } else {
	                                throw module.createError("Cannot get position for range " + this.inspect());
	                            }
	                        };
	                    };
	                }
	            } else {
	                var getElementBoundingClientRect = elementSupportsGetBoundingClientRect ? function (el) {
	                    return adjustClientRect(el.getBoundingClientRect(), dom.getDocument(el));
	                } :

	                // This implementation is very naive. There are many browser quirks that make it extremely
	                // difficult to get accurate element coordinates in all situations
	                function (el) {
	                    var x = 0,
	                        y = 0,
	                        offsetEl = el,
	                        width = el.offsetWidth,
	                        height = el.offsetHeight;
	                    while (offsetEl) {
	                        x += offsetEl.offsetLeft;
	                        y += offsetEl.offsetTop;
	                        offsetEl = offsetEl.offsetParent;
	                    }

	                    return adjustClientRect(new Rect(y, x + width, y + height, x), dom.getDocument(el));
	                };

	                var getRectFromBoundaries = function getRectFromBoundaries(range) {
	                    var rect;
	                    range.splitBoundaries();
	                    var span = document.createElement("span");

	                    if (range.collapsed) {
	                        range.insertNode(span);
	                        rect = getElementBoundingClientRect(span);
	                        span.parentNode.removeChild(span);
	                    } else {
	                        // TODO: This isn't right. I'm not sure it can be made right sensibly. Consider what to do.
	                        // This doesn't consider all the line boxes it needs to consider.
	                        var workingRange = range.cloneRange();

	                        // Get the start rectangle
	                        workingRange.collapse(true);
	                        workingRange.insertNode(span);
	                        var startRect = getElementBoundingClientRect(span);
	                        span.parentNode.removeChild(span);

	                        // Get the end rectangle
	                        workingRange.collapseToPoint(range.endContainer, range.endOffset);
	                        workingRange.insertNode(span);
	                        var endRect = getElementBoundingClientRect(span);
	                        span.parentNode.removeChild(span);

	                        // Merge the start and end rects
	                        var rects = [startRect, endRect];

	                        // Merge in rectangles for all elements in the range
	                        var elements = range.getNodes([1], function (el) {
	                            return range.containsNode(el);
	                        });

	                        for (var i = 0, len = elements.length; i < len; ++i) {
	                            rects.push(getElementBoundingClientRect(elements[i]));
	                        }
	                        rect = mergeRects(rects);
	                    }

	                    // Clean up
	                    range.normalizeBoundaries();
	                    return rect;
	                };

	                rangeProto.getBoundingClientRect = function (range) {
	                    return getRectFromBoundaries(createWrappedRange(range));
	                };
	            }
	        }
	        function createDocumentBoundaryPosGetter(isStart) {
	            return function () {
	                var pos = this["get" + (isStart ? "Start" : "End") + "ClientPos"]();
	                var scrollPos = getScrollPosition(dom.getWindow(this.startContainer));
	                return { x: pos.x + scrollPos.x, y: pos.y + scrollPos.y };
	            };
	        }

	        util.extend(rangeProto, {
	            getBoundingDocumentRect: function getBoundingDocumentRect() {
	                var scrollPos = getScrollPosition(dom.getWindow(this.startContainer));
	                return createRelativeRect(this.getBoundingClientRect(), scrollPos.x, scrollPos.y);
	            },

	            getStartClientPos: createClientBoundaryPosGetter(true),
	            getEndClientPos: createClientBoundaryPosGetter(false),

	            getStartDocumentPos: createDocumentBoundaryPosGetter(true),
	            getEndDocumentPos: createDocumentBoundaryPosGetter(false)
	        });

	        // Add Selection methods
	        function compareRanges(r1, r2) {
	            return r1.compareBoundaryPoints(r2.START_TO_START, r2);
	        }

	        function createSelectionRectGetter(isDocument) {
	            return function () {
	                var rangeMethodName = "getBounding" + (isDocument ? "Document" : "Client") + "Rect";
	                var rects = [];
	                for (var i = 0; i < this.rangeCount; ++i) {
	                    rects.push(this.getRangeAt(i)[rangeMethodName]());
	                }
	                return mergeRects(rects);
	            };
	        }

	        function createSelectionBoundaryPosGetter(isStart, isDocument) {
	            return function () {
	                if (this.rangeCount === 0) {
	                    return null;
	                }

	                var posType = isDocument ? "Document" : "Client";

	                var ranges = this.getAllRanges();
	                if (ranges.length > 1) {
	                    // Order the ranges by position within the DOM
	                    ranges.sort(compareRanges);
	                }

	                return isStart ? ranges[0]["getStart" + posType + "Pos"]() : ranges[ranges.length - 1]["getEnd" + posType + "Pos"]();
	            };
	        }

	        util.extend(api.selectionPrototype, {
	            getBoundingClientRect: createSelectionRectGetter(false),
	            getBoundingDocumentRect: createSelectionRectGetter(true),

	            getStartClientPos: createSelectionBoundaryPosGetter(true, false),
	            getEndClientPos: createSelectionBoundaryPosGetter(false, false),

	            getStartDocumentPos: createSelectionBoundaryPosGetter(true, true),
	            getEndDocumentPos: createSelectionBoundaryPosGetter(false, true)
	        });

	        api.positionFromPoint = function (x, y, doc) {
	            doc = dom.getContentDocument(doc, module, "positionFromPoint");
	            return createCaretPositionFromPointGetter(doc)(doc, x, y);
	        };

	        api.createRangeFromPoints = createRangeFromPoints;
	        api.moveSelectionToPoints = moveSelectionToPoints;
	    });
		}

/***/ },
/* 519 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	/**
	 * [parseStrByDelimiter description]
	 * @method parseStrByDelimiter
	 * @param  {[string]} str       = ''  [origin str]
	 * @param  {[string]} delimiter = '@' [delimiter str]
	 * @return {[string]}
	 */
	function parseStrByDelimiter() {
		var str = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];
		var delimiter = arguments.length <= 1 || arguments[1] === undefined ? '@' : arguments[1];

		var idx = str.lastIndexOf(delimiter);
		if (idx !== -1) {
			str = str.substring(idx + 1);
		} else {
			str = '';
		}
		return str;
	}

	/**
	 * [get window scroll offset]
	 * @method getScrollOffset
	 */
	function getScrollOffset() {
		var offset = {};
		if (window.pageXOffset) {
			offset.x = window.pageXOffset;
		} else {
			offset.x = document.documentElement.scrollLeft;
		}
		if (window.pageYOffset) {
			offset.y = window.pageYOffset;
		} else {
			offset.y = document.documentElement.scrollTop;
		}
		return offset;
	}

	exports.parseStrByDelimiter = parseStrByDelimiter;
	exports.getScrollOffset = getScrollOffset;

/***/ },
/* 520 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;
	var KEYCODE = exports.KEYCODE = {
	   DOWN: 40,
	   UP: 38,
	   ESC: 27,
	   TAB: 9,
	   ENTER: 13,
	   CTRL: 17,
	   BACKSPACE: 8,
	   DELETE: 46
		};

/***/ },
/* 521 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Menu Component for uxcore
	 * @author vincent.bian
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

		module.exports = __webpack_require__(522);

/***/ },
/* 522 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	exports.__esModule = true;

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _rcMenu = __webpack_require__(523);

	var _rcMenu2 = _interopRequireDefault(_rcMenu);

	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { "default": obj };
	}

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	} /**
	   * Menu Component for uxcore
	   * @author vincent.bian
	   *
	   * Copyright 2014-2015, Uxcore Team, Alinw.
	   * All rights reserved.
	   */

	var Menu = function (_React$Component) {
	    _inherits(Menu, _React$Component);

	    function Menu() {
	        _classCallCheck(this, Menu);

	        return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
	    }

	    Menu.prototype.render = function render() {
	        if (this.props.mode === 'inline') {
	            return _react2["default"].createElement(_rcMenu2["default"], this.props);
	        } else {
	            return _react2["default"].createElement(_rcMenu2["default"], this.props);
	        }
	    };

	    return Menu;
	}(_react2["default"].Component);

	Menu.defaultProps = {
	    prefixCls: 'kuma-menu'
	};
	Menu.propTypes = {
	    prefixCls: _react2["default"].PropTypes.string
	};

	Menu.SubMenu = _rcMenu.SubMenu;
	Menu.Item = _rcMenu.Item;
	Menu.Divider = _rcMenu.Divider;

	exports["default"] = Menu;
	module.exports = exports['default'];

/***/ },
/* 523 */
[779, 524, 552, 564, 565, 566],
/* 524 */
[780, 525, 543, 550],
/* 525 */
[781, 526, 547, 543, 550, 551],
/* 526 */
[749, 527, 528, 530, 531, 532, 533, 538, 539, 544, 545, 546],
/* 527 */
17,
/* 528 */
[750, 529],
/* 529 */
19,
/* 530 */
[751, 529],
/* 531 */
21,
/* 532 */
[752, 533],
/* 533 */
[753, 534],
/* 534 */
[754, 535, 536, 537],
/* 535 */
25,
/* 536 */
26,
/* 537 */
27,
/* 538 */
28,
/* 539 */
[755, 540],
/* 540 */
[756, 541],
/* 541 */
[757, 542, 543],
/* 542 */
32,
/* 543 */
33,
/* 544 */
34,
/* 545 */
35,
/* 546 */
36,
/* 547 */
[782, 548],
/* 548 */
[783, 549],
/* 549 */
397,
/* 550 */
398,
/* 551 */
[784, 543],
/* 552 */
[785, 553, 526, 543, 563],
/* 553 */
[786, 525, 543, 550, 554],
/* 554 */
[770, 555],
/* 555 */
[771, 556, 557, 562],
/* 556 */
76,
/* 557 */
[772, 558, 562],
/* 558 */
[773, 559, 560],
/* 559 */
79,
/* 560 */
[774, 561, 561],
/* 561 */
81,
/* 562 */
82,
/* 563 */
[787, 526],
/* 564 */
[788, 526],
/* 565 */
404,
/* 566 */
405,
/* 567 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Multiselect Component for uxcore
	 * @author peijie.dpj
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

		module.exports = __webpack_require__(568);

/***/ },
/* 568 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _possibleConstructorReturn(self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	/**
	 * MultiSelect Component for uxcore
	 * @author peijie.dpj
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);
	var Dropdown = __webpack_require__(276);
	var CheckboxGroup = __webpack_require__(215);
	var Button = __webpack_require__(569);
	var assign = __webpack_require__(571);
	var classnames = __webpack_require__(5);

	var MultiSelect = function (_React$Component) {
	  _inherits(MultiSelect, _React$Component);

	  function MultiSelect(props) {
	    _classCallCheck(this, MultiSelect);

	    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	    _this.state = {
	      visible: false
	    };

	    _this.lastValue = _this.props.value || [];
	    return _this;
	  }

	  MultiSelect.prototype.handleChange = function handleChange(value) {
	    var me = this,
	        props = this.props;

	    var newValue = [];
	    if (props.maxSelect && value.length > props.maxSelect) {
	      newValue = me.lastValue;
	    } else {
	      newValue = value;
	      me.lastValue = value;
	    }

	    props.onChange(newValue);
	  };

	  MultiSelect.prototype.handleSelectAll = function handleSelectAll() {
	    var me = this,
	        props = this.props;

	    var valueList = [];
	    if (props.disabled) {
	      return;
	    } else {
	      React.Children.map(props.children, function (item) {
	        if (!item.props.disabled || me._hasSelected.call(me, item.props.value)) {
	          valueList.push(item.props.value);
	        }
	      });
	    }

	    props.onChange(valueList);
	  };

	  MultiSelect.prototype.handleClear = function handleClear() {
	    var me = this,
	        props = this.props;

	    var valueList = [];

	    if (props.disabled) {
	      return;
	    } else {
	      React.Children.map(props.children, function (item) {
	        if (item.props.disabled && me._hasSelected.call(me, item.props.value)) {
	          valueList.push(item.props.value);
	        }
	      });
	    }

	    props.onChange(valueList);
	  };

	  MultiSelect.prototype.handleSubmit = function handleSubmit() {
	    var me = this,
	        props = this.props;

	    var labelList = [],
	        valueList = [];

	    React.Children.map(props.children, function (item) {
	      if (me._hasSelected.call(me, item.props.value)) {
	        labelList.push(item.props[props.optionLabelProp]);
	        valueList.push(item.props.value);
	      }
	    });

	    props.onSubmit(valueList, labelList);

	    me.setState({
	      visible: false
	    });
	  };

	  MultiSelect.prototype._processLabel = function _processLabel(type) {
	    var me = this,
	        props = this.props;

	    var res = [];
	    res = React.Children.map(props.children, function (item) {
	      if (me._hasSelected.call(me, item.props.value)) {
	        switch (type) {
	          case 'content':
	            return React.createElement('span', { className: props.prefixCls + '-selection__choice__content' }, item.props[props.optionLabelProp], React.createElement('span', { className: props.prefixCls + '-selection__choice__break' }, props.titleBreakStr));
	            break;

	          case 'title':
	            return item.props[props.optionLabelProp] + props.titleBreakStr;
	            break;
	        }
	      }
	    });

	    if (res.length == 0) {
	      switch (type) {
	        case 'content':
	          res = React.createElement('span', { className: props.prefixCls + '-selection__placeholder' }, props.placeholder);
	          break;

	        case 'title':
	          res = [props.placeholder];
	          break;
	      }
	    } else {
	      if (type == 'title') {
	        var len = res.length;
	        res[len - 1] = res[len - 1].slice(0, res[len - 1].length - 1);
	      }
	    }

	    return type == 'title' ? res.join('') : res;
	  };

	  MultiSelect.prototype._hasSelected = function _hasSelected(value) {
	    var me = this;

	    return me.props.value.indexOf(value) != -1;
	  };

	  MultiSelect.prototype._handleVisbleChange = function _handleVisbleChange(visible) {
	    var props = this.props;

	    if (props.disabled) {
	      return;
	    }
	    this.setState({
	      visible: visible
	    });
	  };

	  MultiSelect.prototype.render = function render() {
	    var _classnames, _classnames2, _classnames3, _classnames4;

	    var me = this,
	        props = this.props;

	    // 检查是否可以点击 全选
	    var canSelectItemNumbers = 0;

	    React.Children.map(props.children, function (item, index) {
	      !item.props.disabled && canSelectItemNumbers++;
	    });

	    var menu = React.createElement('div', { className: props.prefixCls + '-dropdown-border' }, React.createElement('div', { className: props.prefixCls + '-content' }, React.createElement(CheckboxGroup, { onChange: me.handleChange.bind(me),
	      value: props.value }, React.Children.map(props.children, function (item, index) {
	      return React.createElement(CheckboxGroup.Item, _extends({}, item.props, { key: index, jsxdisabled: props.disabled }));
	    }))), React.createElement('div', { className: props.prefixCls + '-footer' }, !!props.maxSelect && React.createElement('p', null, '最多选', props.maxSelect, '个'), React.createElement(Button, { additionClass: classnames((_classnames = {}, _classnames[props.prefixCls + '-button'] = true, _classnames[props.prefixCls + '-button-hidden'] = !props.showSelectAll, _classnames)),
	      size: 'small',
	      disabled: props.maxSelect && props.maxSelect < canSelectItemNumbers ? true : false,
	      onClick: me.handleSelectAll.bind(me) }, '全选'), React.createElement(Button, { additionClass: classnames((_classnames2 = {}, _classnames2[props.prefixCls + '-button'] = true, _classnames2[props.prefixCls + '-button-hidden'] = !props.showClear, _classnames2)),
	      size: 'small',
	      onClick: me.handleClear.bind(me) }, '清空'), React.createElement(Button, { additionClass: props.prefixCls + '-button',
	      size: 'small',
	      onClick: me.handleSubmit.bind(me) }, '确认')));

	    return React.createElement('div', null, React.createElement(Dropdown, { overlay: menu,
	      minOverlayWidthMatchTrigger: false,
	      visible: me.state.visible,
	      onVisibleChange: me._handleVisbleChange.bind(me),
	      trigger: ["click"],
	      overlayClassName: classnames((_classnames3 = {}, _classnames3[props.prefixCls + '-dropdown'] = true, _classnames3[props.dropdownClassName] = !!props.dropdownClassName, _classnames3)) }, React.createElement('span', { className: classnames((_classnames4 = {}, _classnames4[props.prefixCls] = true, _classnames4[props.className] = !!props.className, _classnames4[props.prefixCls + '-open'] = me.state.visible, _classnames4[props.prefixCls + '-disabled'] = props.disabled, _classnames4)) }, React.createElement('span', { className: props.prefixCls + '-selection ' + props.prefixCls + '-selection--multiple' }, React.createElement('span', { className: props.prefixCls + '-selection--multiple--content', title: me._processLabel('title') }, me._processLabel('content')), React.createElement('span', { className: props.prefixCls + '-arrow' })))));
	  };

	  return MultiSelect;
	}(React.Component);

	MultiSelect.defaultProps = {
	  prefixCls: 'kuma-multi-select',
	  className: '',
	  dropdownClassName: '',
	  value: [],
	  disabled: false,
	  placeholder: '',
	  titleBreakStr: "、",
	  optionLabelProp: "text",
	  showSelectAll: true,
	  showClear: true,
	  onChange: function onChange() {},
	  onSubmit: function onSubmit() {}
	};

	MultiSelect.propTypes = {
	  prefixCls: React.PropTypes.string,
	  className: React.PropTypes.string,
	  dropdownClassName: React.PropTypes.string,
	  value: React.PropTypes.array,
	  disabled: React.PropTypes.bool,
	  maxSelect: React.PropTypes.number,
	  placeholder: React.PropTypes.string,
	  titleBreakStr: React.PropTypes.string,
	  optionLabelProp: React.PropTypes.string,
	  showSelectAll: React.PropTypes.bool,
	  showClear: React.PropTypes.bool,
	  onChange: React.PropTypes.func,
	  onSubmit: React.PropTypes.func
	};

	// http://facebook.github.io/react/docs/reusable-components.html

	MultiSelect.Item = CheckboxGroup.Item;

	MultiSelect.displayName = "MultiSelect";

	module.exports = MultiSelect;

/***/ },
/* 569 */
[791, 570],
/* 570 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _extends = Object.assign || function (target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];for (var key in source) {
				if (Object.prototype.hasOwnProperty.call(source, key)) {
					target[key] = source[key];
				}
			}
		}return target;
	};

	var _classnames = __webpack_require__(5);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(4);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : { "default": obj };
	}

	function _classCallCheck(instance, Constructor) {
		if (!(instance instanceof Constructor)) {
			throw new TypeError("Cannot call a class as a function");
		}
	}

	function _possibleConstructorReturn(self, call) {
		if (!self) {
			throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		}return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
		if (typeof superClass !== "function" && superClass !== null) {
			throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
		}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var sizeMap = {
		small: 'sm',
		medium: '',
		large: 'lg'
	},
	    typeMap = {
		primary: 'primary',
		secondary: 'secondary',
		disabled: 'disabled'
	},
	    clsPrefix = 'kuma-button';

	var Button = function (_React$Component) {
		_inherits(Button, _React$Component);

		function Button(props) {
			_classCallCheck(this, Button);

			return _possibleConstructorReturn(this, _React$Component.call(this, props));
		}

		Button.prototype.render = function render() {
			var props = this.props;
			var type = props.disabled ? 'disabled' : props.type;
			var clsObj = {};
			if (props.className) {
				clsObj[props.className] = true;
			}
			if (sizeMap[props.size]) {
				clsObj[clsPrefix + '-' + sizeMap[props.size]] = true;
			}
			var className = (0, _classnames2["default"])(clsPrefix, clsPrefix + '-' + typeMap[type], clsObj);
			var propEvents = {};
			Object.keys(props).forEach(function (key) {
				if (key.indexOf('on') === 0) {
					propEvents[key] = props[key];
				}
			});
			return _react2["default"].createElement('button', _extends({ className: className, disabled: props.disabled }, propEvents), props.children);
		};

		return Button;
	}(_react2["default"].Component);

	Button.displayName = 'uxcore-button';
	Button.propTypes = {
		size: _react2["default"].PropTypes.oneOf(Object.keys(sizeMap)),
		type: _react2["default"].PropTypes.oneOf(Object.keys(typeMap)),
		disabled: _react2["default"].PropTypes.oneOf(['disabled', true, false]),
		className: _react2["default"].PropTypes.string
	};
	Button.defaultProps = {
		size: 'medium',
		type: 'primary',
		disabled: false,
		className: ''
	};

		module.exports = Button;

/***/ },
/* 571 */
33,
/* 572 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Pagination Component for uxcore
	 * @author 
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

		module.exports = __webpack_require__(573);

/***/ },
/* 573 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _possibleConstructorReturn(self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	/**
	 * Forked from project rc-pagination
	 * @maintainer eternalsky
	 */

	var Select = __webpack_require__(356);
	var Pager = __webpack_require__(574);
	var Options = __webpack_require__(575);
	var KEYCODE = __webpack_require__(576);
	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);
	var i18n = __webpack_require__(577);

	function noop() {}

	var Pagination = function (_React$Component) {
	  _inherits(Pagination, _React$Component);

	  function Pagination(props) {
	    _classCallCheck(this, Pagination);

	    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	    _this.state = {
	      current: props.current,
	      _current: props.current,
	      pageSize: props.pageSize
	    };

	    ['render', '_handleChange', '_handleKeyUp', '_handleKeyDown', '_changePageSize', '_isValid', '_prev', '_next', '_hasPrev', '_hasNext', '_jumpPrev', '_jumpNext'].forEach(function (method) {
	      return _this[method] = _this[method].bind(_this);
	    });
	    return _this;
	  }

	  Pagination.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	    if (nextProps.current != this.props.current) {
	      this.setState({
	        current: nextProps.current,
	        _current: nextProps.current
	      });
	    }

	    if (nextProps.pageSize != this.props.pageSize) {
	      this.setState({
	        pageSize: nextProps.pageSize
	      });
	    }
	  };

	  Pagination.prototype.renderTotal = function renderTotal() {
	    var prefix = this.props.locale == 'zh-cn' ? "共" : "";
	    if (this.props.showTotal) {
	      return React.createElement('li', { className: this.props.prefixCls + "-total" }, prefix + this.props.total + i18n[this.props.locale]['item']);
	    }
	  };

	  Pagination.prototype.render = function render() {
	    var props = this.props;

	    var prefixCls = props.prefixCls;
	    var allPages = this._calcPage();
	    var pagerList = [];
	    var jumpPrev = null;
	    var jumpNext = null;
	    var firstPager = null;
	    var lastPager = null;

	    if (props.simple) {
	      return React.createElement('ul', { className: prefixCls + ' ' + prefixCls + '-simple ' + props.className }, React.createElement('div', { title: 'Page ' + this.state.current + ' of ' + allPages, className: prefixCls + '-simple-pager' }, React.createElement('span', { className: prefixCls + '-current' }, this.state._current), React.createElement('span', { className: prefixCls + '-slash' }, '/'), allPages), React.createElement('li', { title: 'Previous Page', onClick: this._prev, className: (this._hasPrev() ? '' : prefixCls + '-disabled ') + (prefixCls + '-prev') }, React.createElement('a', { className: 'kuma-icon kuma-icon-triangle-left' })), React.createElement('li', { title: 'Next Page', onClick: this._next, className: (this._hasNext() ? '' : prefixCls + '-disabled ') + (prefixCls + '-next') }, React.createElement('a', { className: 'kuma-icon kuma-icon-triangle-right' })));
	    }

	    if (allPages <= 9) {
	      for (var i = 1; i <= allPages; i++) {
	        var active = this.state.current === i;
	        pagerList.push(React.createElement(Pager, { rootPrefixCls: prefixCls, onClick: this._handleChange.bind(this, i), key: i, page: i, active: active }));
	      }
	    } else {
	      jumpPrev = React.createElement('li', { title: 'Previous 5 Page', key: 'prev', onClick: this._jumpPrev, className: prefixCls + '-jump-prev' }, React.createElement('a', null));
	      jumpNext = React.createElement('li', { title: 'Next 5 Page', key: 'next', onClick: this._jumpNext, className: prefixCls + '-jump-next' }, React.createElement('a', null));
	      lastPager = React.createElement(Pager, { last: true, rootPrefixCls: prefixCls, onClick: this._handleChange.bind(this, allPages), key: allPages, page: allPages, active: false });
	      firstPager = React.createElement(Pager, { rootPrefixCls: prefixCls, onClick: this._handleChange.bind(this, 1), key: 1, page: 1, active: false });

	      var current = this.state.current;

	      var left = Math.max(1, current - 2);
	      var right = Math.min(current + 2, allPages);

	      if (current - 1 <= 2) {
	        right = 1 + 4;
	      }

	      if (allPages - current <= 2) {
	        left = allPages - 4;
	      }

	      for (var _i = left; _i <= right; _i++) {
	        var _active = current === _i;
	        pagerList.push(React.createElement(Pager, { rootPrefixCls: prefixCls, onClick: this._handleChange.bind(this, _i), key: _i, page: _i, active: _active }));
	      }

	      if (current - 1 >= 4) {
	        pagerList.unshift(jumpPrev);
	      }
	      if (allPages - current >= 4) {
	        pagerList.push(jumpNext);
	      }

	      if (left !== 1) {
	        pagerList.unshift(firstPager);
	      }
	      if (right !== allPages) {
	        pagerList.push(lastPager);
	      }
	    }

	    return React.createElement('ul', { className: prefixCls + ' ' + props.className,
	      unselectable: 'unselectable' }, React.createElement('li', { title: 'Previous Page', onClick: this._prev, className: (this._hasPrev() ? '' : prefixCls + '-disabled ') + (prefixCls + '-prev') }, React.createElement('a', { className: 'kuma-icon kuma-icon-triangle-left' })), pagerList, React.createElement('li', { title: 'Next Page', onClick: this._next, className: (this._hasNext() ? '' : prefixCls + '-disabled ') + (prefixCls + '-next') }, React.createElement('a', { className: 'kuma-icon kuma-icon-triangle-right' })), this.renderTotal(), React.createElement(Options, { rootPrefixCls: prefixCls,
	      locale: props.locale,
	      selectComponentClass: props.selectComponentClass,
	      selectPrefixCls: props.selectPrefixCls,
	      changeSize: this.props.showSizeChanger ? this._changePageSize.bind(this) : null,
	      current: this.state.current,
	      pageSize: props.pageSize,
	      sizeOptions: props.sizeOptions,
	      quickGo: this.props.showQuickJumper ? this._handleChange.bind(this) : null }));
	  };

	  // private methods

	  Pagination.prototype._calcPage = function _calcPage(p) {
	    var pageSize = p;
	    if (typeof pageSize === 'undefined') {
	      pageSize = this.state.pageSize;
	    }
	    return Math.floor((this.props.total - 1) / pageSize) + 1;
	  };

	  Pagination.prototype._isValid = function _isValid(page) {
	    return typeof page === 'number' && page >= 1 && page !== this.state.current;
	  };

	  Pagination.prototype._handleKeyDown = function _handleKeyDown(evt) {
	    if (evt.keyCode === KEYCODE.ARROW_UP || evt.keyCode === KEYCODE.ARROW_DOWN) {
	      evt.preventDefault();
	    }
	  };

	  Pagination.prototype._handleKeyUp = function _handleKeyUp(evt) {
	    var _val = evt.target.value;
	    var val = void 0;

	    if (_val === '') {
	      val = _val;
	    } else if (isNaN(Number(_val))) {
	      val = this.state._current;
	    } else {
	      val = Number(_val);
	    }

	    this.setState({
	      _current: val
	    });

	    if (evt.keyCode === KEYCODE.ENTER) {
	      this._handleChange(val);
	    } else if (evt.keyCode === KEYCODE.ARROW_UP) {
	      this._handleChange(val - 1);
	    } else if (evt.keyCode === KEYCODE.ARROW_DOWN) {
	      this._handleChange(val + 1);
	    }
	  };

	  Pagination.prototype._changePageSize = function _changePageSize(size) {
	    if (typeof size === 'number') {
	      var current = this.state.current;

	      this.setState({
	        pageSize: size
	      });

	      if (this.state.current > this._calcPage(size)) {
	        current = this._calcPage(size);
	        this.setState({
	          current: current,
	          _current: current
	        });
	      }

	      this.props.onShowSizeChange(current, size);
	    }
	  };

	  Pagination.prototype._handleChange = function _handleChange(p) {
	    var page = p;
	    var me = this;
	    if (this._isValid(page)) {
	      if (page > this._calcPage()) {
	        page = this._calcPage();
	      }
	      this.setState({
	        current: page,
	        _current: page
	      }, function () {
	        me.props.onChange(page);
	      });

	      return page;
	    }

	    return this.state.current;
	  };

	  Pagination.prototype._prev = function _prev() {
	    if (this._hasPrev()) {
	      this._handleChange(this.state.current - 1);
	    }
	  };

	  Pagination.prototype._next = function _next() {
	    if (this._hasNext()) {
	      this._handleChange(this.state.current + 1);
	    }
	  };

	  Pagination.prototype._jumpPrev = function _jumpPrev() {
	    this._handleChange(Math.max(1, this.state.current - 5));
	  };

	  Pagination.prototype._jumpNext = function _jumpNext() {
	    this._handleChange(Math.min(this._calcPage(), this.state.current + 5));
	  };

	  Pagination.prototype._hasPrev = function _hasPrev() {
	    return this.state.current > 1;
	  };

	  Pagination.prototype._hasNext = function _hasNext() {
	    return this.state.current < this._calcPage();
	  };

	  return Pagination;
	}(React.Component);

	Pagination.propTypes = {
	  current: React.PropTypes.number,
	  total: React.PropTypes.number,
	  locale: React.PropTypes.string,
	  showTotal: React.PropTypes.bool,
	  pageSize: React.PropTypes.number,
	  sizeOptions: React.PropTypes.array,
	  onChange: React.PropTypes.func,
	  showSizeChanger: React.PropTypes.bool,
	  onShowSizeChange: React.PropTypes.func,
	  selectComponentClass: React.PropTypes.func,
	  showQuickJumper: React.PropTypes.bool
	};

	Pagination.defaultProps = {
	  current: 1,
	  total: 0,
	  locale: 'zh-cn',
	  showTotal: false,
	  pageSize: 10,
	  sizeOptions: [10, 20, 30, 40],
	  onChange: noop,
	  className: '',
	  selectPrefixCls: 'kuma-select2',
	  prefixCls: 'kuma-page',
	  selectComponentClass: Select,
	  showQuickJumper: false,
	  showSizeChanger: false,
	  onShowSizeChange: noop
	};

	Pagination.displayName = 'Pagination';

	module.exports = Pagination;

/***/ },
/* 574 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _possibleConstructorReturn(self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var Pager = function (_React$Component) {
	  _inherits(Pager, _React$Component);

	  function Pager() {
	    _classCallCheck(this, Pager);

	    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
	  }

	  Pager.prototype.render = function render() {
	    var props = this.props;
	    var prefixCls = props.rootPrefixCls + '-item';
	    var cls = prefixCls + ' ' + prefixCls + '-' + props.page;

	    if (props.active) {
	      cls = cls + ' ' + prefixCls + '-active';
	    }

	    var title = void 0;
	    if (props.page === 1) {
	      title = 'First Page';
	    } else if (props.last) {
	      title = 'Last Page: ' + props.page;
	    } else {
	      title = 'Page ' + props.page;
	    }
	    return React.createElement('li', { title: title, className: cls, onClick: props.onClick }, React.createElement('a', null, props.page));
	  };

	  return Pager;
	}(React.Component);

	Pager.propTypes = {
	  page: React.PropTypes.number,
	  active: React.PropTypes.bool,
	  last: React.PropTypes.bool
	};

		module.exports = Pager;

/***/ },
/* 575 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _possibleConstructorReturn(self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);
	var KEYCODE = __webpack_require__(576);
	var i18n = __webpack_require__(577);

	var Options = function (_React$Component) {
	  _inherits(Options, _React$Component);

	  function Options(props) {
	    _classCallCheck(this, Options);

	    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	    _this.state = {
	      current: props.current,
	      _current: props.current
	    };

	    ['_handleChange', '_changeSize', '_go'].forEach(function (method) {
	      return _this[method] = _this[method].bind(_this);
	    });
	    return _this;
	  }

	  Options.prototype.render = function render() {
	    var _this2 = this;

	    var props = this.props;
	    var state = this.state;
	    var prefixCls = props.rootPrefixCls + '-options';
	    var sizeOptions = props.sizeOptions;
	    var pageSize = props.pageSize;
	    var changeSize = props.changeSize;
	    var quickGo = props.quickGo;
	    var Select = props.selectComponentClass;
	    var changeSelect = null;
	    var goInput = null;

	    if (!(changeSize || quickGo)) {
	      return null;
	    }

	    if (changeSize && Select) {
	      (function () {
	        var Option = Select.Option;
	        changeSelect = React.createElement(Select, {
	          prefixCls: props.selectPrefixCls, showSearch: false,
	          className: prefixCls + '-size-changer',
	          optionLabelProp: 'children',
	          dropdownClassName: prefixCls + '-size-changer-dropdown',
	          defaultValue: sizeOptions.indexOf(pageSize) == -1 ? sizeOptions[0] + "" : pageSize + "",
	          onChange: _this2._changeSize }, sizeOptions.map(function (option, index) {
	          return React.createElement(Option, { key: option, value: option + "" }, option + i18n[props.locale]['items_per_page']);
	        }));
	      })();
	    }

	    if (quickGo) {
	      goInput = React.createElement('div', { title: 'Quick jump to page', className: prefixCls + '-quick-jumper' }, i18n[props.locale]['jump_to'], React.createElement('input', { type: 'text', value: state._current, onChange: this._handleChange.bind(this), onKeyUp: this._go.bind(this) }), i18n[props.locale]['page']);
	    }

	    return React.createElement('div', { className: '' + prefixCls }, changeSelect, goInput);
	  };

	  Options.prototype._changeSize = function _changeSize(value) {
	    this.props.changeSize(Number(value));
	  };

	  Options.prototype._handleChange = function _handleChange(evt) {
	    var _val = evt.target.value;

	    this.setState({
	      _current: _val
	    });
	  };

	  Options.prototype._go = function _go(e) {
	    var _val = e.target.value;
	    if (_val === '') {
	      return;
	    }
	    var val = Number(this.state._current);
	    if (isNaN(val)) {
	      val = this.state.current;
	    }
	    if (e.keyCode === KEYCODE.ENTER) {
	      var c = this.props.quickGo(val);
	      this.setState({
	        _current: c,
	        current: c
	      });
	    }
	  };

	  return Options;
	}(React.Component);

	Options.propTypes = {
	  changeSize: React.PropTypes.func,
	  quickGo: React.PropTypes.func,
	  selectComponentClass: React.PropTypes.func,
	  current: React.PropTypes.number
	};

		module.exports = Options;

/***/ },
/* 576 */
/***/ function(module, exports) {

	"use strict";

	module.exports = {
	  ZERO: 48,
	  NINE: 57,

	  NUMPAD_ZERO: 96,
	  NUMPAD_NINE: 105,

	  BACKSPACE: 8,
	  DELETE: 46,
	  ENTER: 13,

	  ARROW_UP: 38,
	  ARROW_DOWN: 40
		};

/***/ },
/* 577 */
/***/ function(module, exports) {

	'use strict';

	var locale = {
	    "en-us": {
	        items_per_page: '/page',
	        jump_to: 'Goto',
	        page: '',

	        // Pagination.js
	        item: ' entries'
	    },
	    "zh-cn": {
	        // Options.js
	        items_per_page: '条/页',
	        jump_to: '跳至',
	        page: '页',

	        // Pagination.js
	        item: '条'
	    }
	};
	locale['en'] = locale['en-us'];

	module.exports = locale;

/***/ },
/* 578 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Popover Component for uxcore
	 * @author eternalsky
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

		module.exports = __webpack_require__(579);

/***/ },
/* 579 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	/**
	 * Popover Component for uxcore
	 * @author eternalsky
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var Tooltip = __webpack_require__(580);
	var Button = __webpack_require__(630);

	var Popover = function (_React$Component) {
	    _inherits(Popover, _React$Component);

	    function Popover(props) {
	        _classCallCheck(this, Popover);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.state = {
	            visible: false
	        };
	        return _this;
	    }

	    Popover.prototype.handleOkClick = function handleOkClick() {
	        var me = this;
	        me.props.onOk(function () {
	            me.setState({
	                visible: false
	            });
	        });
	    };

	    Popover.prototype.handleCancelClick = function handleCancelClick() {
	        var me = this;
	        me.setState({
	            visible: false
	        }, function () {
	            me.props.onCancel();
	        });
	    };

	    Popover.prototype.handleVisibleChange = function handleVisibleChange(visible) {
	        this.setState({
	            visible: visible
	        });
	    };

	    Popover.prototype._renderButton = function _renderButton() {
	        var me = this;
	        if (me.props.showButton) {
	            return React.createElement('div', { className: me.props.prefixCls + "-button-group" }, React.createElement(Button, { size: 'small', type: 'primary', onClick: me.handleOkClick.bind(me) }, me.props.okText), React.createElement(Button, { size: 'small', type: 'secondary', onClick: me.handleCancelClick.bind(me) }, me.props.cancelText));
	        }
	    };

	    Popover.prototype._generateOverlay = function _generateOverlay() {
	        var me = this;
	        var arr = [];
	        if (me.props.title) {
	            arr.push(React.createElement('div', { key: 'title', className: me.props.prefixCls + '-title' }, me.props.title));
	        }
	        if (me.props.overlay) {
	            arr.push(React.createElement('div', { key: 'content', className: me.props.prefixCls + '-content' }, me.props.overlay, me._renderButton()));
	        }
	        return React.createElement('div', null, arr);
	    };

	    Popover.prototype.render = function render() {
	        var me = this;

	        return React.createElement(Tooltip, { placement: me.props.placement,
	            overlayClassName: me.props.overlayClassName,
	            prefixCls: me.props.prefixCls,
	            visible: me.state.visible,
	            onVisibleChange: me.handleVisibleChange.bind(me),
	            delay: me.props.delay,
	            transitionName: me.props.transitionName,
	            trigger: me.props.trigger,
	            overlay: me._generateOverlay() }, me.props.children);
	    };

	    return Popover;
	}(React.Component);

	Popover.defaultProps = {
	    prefixCls: 'kuma-popover',
	    delay: 0,
	    placement: "top",
	    trigger: "hover",
	    onOk: function onOk(cb) {
	        cb();
	    },
	    onCancel: function onCancel() {},
	    okText: "确定",
	    cancelText: "取消",
	    showButton: false
	};

	// http://facebook.github.io/react/docs/reusable-components.html
	Popover.propTypes = {
	    prefixCls: React.PropTypes.string,
	    delay: React.PropTypes.number,
	    overlayClassName: React.PropTypes.string,
	    placement: React.PropTypes.oneOf(['top', 'bottom', 'left', 'right', 'topLeft', 'bottomLeft', 'leftTop', 'rightTop', 'topRight', 'bottomRight', 'leftBottom', 'rightBottom']),
	    trigger: React.PropTypes.oneOf(['hover', 'click']),
	    onOk: React.PropTypes.func,
	    onCancel: React.PropTypes.func,
	    okText: React.PropTypes.string,
	    cancelText: React.PropTypes.string,
	    showButton: React.PropTypes.bool
	};

	Popover.displayName = "Popover";

	module.exports = Popover;

/***/ },
/* 580 */
[776, 581],
/* 581 */
[777, 582, 583],
/* 582 */
160,
/* 583 */
[759, 584],
/* 584 */
[760, 585, 606, 629],
/* 585 */
[749, 586, 587, 589, 590, 591, 592, 597, 598, 603, 604, 605],
/* 586 */
17,
/* 587 */
[750, 588],
/* 588 */
19,
/* 589 */
[751, 588],
/* 590 */
21,
/* 591 */
[752, 592],
/* 592 */
[753, 593],
/* 593 */
[754, 594, 595, 596],
/* 594 */
25,
/* 595 */
26,
/* 596 */
27,
/* 597 */
28,
/* 598 */
[755, 599],
/* 599 */
[756, 600],
/* 600 */
[757, 601, 602],
/* 601 */
32,
/* 602 */
33,
/* 603 */
34,
/* 604 */
35,
/* 605 */
36,
/* 606 */
[761, 607, 618, 627, 628],
/* 607 */
[762, 608],
/* 608 */
[763, 609, 585, 617],
/* 609 */
[764, 610, 611, 612, 613, 614, 615],
/* 610 */
66,
/* 611 */
[765, 610],
/* 612 */
[766, 610, 611],
/* 613 */
[767, 610],
/* 614 */
[768, 610],
/* 615 */
[769, 616],
/* 616 */
72,
/* 617 */
73,
/* 618 */
[770, 619],
/* 619 */
[771, 620, 621, 626],
/* 620 */
76,
/* 621 */
[772, 622, 626],
/* 622 */
[773, 623, 624],
/* 623 */
79,
/* 624 */
[774, 625, 625],
/* 625 */
81,
/* 626 */
82,
/* 627 */
[775, 628],
/* 628 */
84,
/* 629 */
85,
/* 630 */
[791, 631],
/* 631 */
570,
/* 632 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Progress Component for uxcore
	 * @author vicent.bian
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	module.exports = {
	  Line: __webpack_require__(633),
	  Circle: __webpack_require__(635)
		};

/***/ },
/* 633 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	exports.__esModule = true;

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(4);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _objectAssign = __webpack_require__(634);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { "default": obj };
	}

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	} /**
	   * Progress Component for uxcore
	   * @author vincent.bian
	   *
	   * Copyright 2014-2015, Uxcore Team, Alinw.
	   * All rights reserved.
	   */

	var prefixCls = 'kuma-progress';

	var Line = function (_React$Component) {
	    _inherits(Line, _React$Component);

	    function Line() {
	        _classCallCheck(this, Line);

	        return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
	    }

	    Line.prototype.render = function render() {
	        var props = (0, _objectAssign2["default"])({}, this.props);

	        if (parseInt(props.percent, 10) === 100) {
	            props.status = 'success';
	        }

	        var progressInfo = void 0;
	        var fullCls = '';

	        if (props.showInfo === true) {
	            if (props.status === 'exception') {
	                progressInfo = _react2["default"].createElement('span', { className: prefixCls + '-line-text' }, _react2["default"].createElement('i', { className: 'icon-caution' }));
	            } else if (props.status === 'success') {
	                progressInfo = _react2["default"].createElement('span', { className: prefixCls + '-line-text' }, _react2["default"].createElement('i', { className: 'icon-success' }));
	            } else {
	                progressInfo = _react2["default"].createElement('span', { className: prefixCls + '-line-text' }, props.percent, '%');
	            }
	        } else {
	            fullCls = ' ' + prefixCls + '-line-wrap-full';
	        }

	        var percentStyle = {
	            width: props.percent + '%',
	            height: props.strokeWidth
	        };

	        return _react2["default"].createElement('div', { className: prefixCls + '-line-wrap fn-clear status-' + props.status + fullCls }, progressInfo, _react2["default"].createElement('div', { className: prefixCls + '-line-outer' }, _react2["default"].createElement('div', { className: prefixCls + '-line-inner' }, _react2["default"].createElement('div', { className: prefixCls + '-line-bg', style: percentStyle }))));
	    };

	    return Line;
	}(_react2["default"].Component);

	Line.displayName = "Progress-Line";
	Line.propTypes = {
	    status: _react2["default"].PropTypes.oneOf(['normal', 'exception', 'success']),
	    showInfo: _react2["default"].PropTypes.bool,
	    percent: _react2["default"].PropTypes.number,
	    strokeWidth: _react2["default"].PropTypes.number
	};
	Line.defaultProps = {
	    percent: 0,
	    strokeWidth: 10,
	    status: 'normal', // exception active
	    showInfo: true
	};

	exports["default"] = Line;
	module.exports = exports['default'];

/***/ },
/* 634 */
33,
/* 635 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	exports.__esModule = true;

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(4);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _objectAssign = __webpack_require__(634);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { "default": obj };
	}

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var defaultProps = {
	    strokeWidth: 1,
	    trailWidth: 1
	};
	var prefixCls = 'kuma-progress';

	var Circle = function (_React$Component) {
	    _inherits(Circle, _React$Component);

	    function Circle() {
	        _classCallCheck(this, Circle);

	        return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
	    }

	    Circle.prototype.render = function render() {
	        var props = (0, _objectAssign2["default"])({}, this.props);
	        var strokeWidth = props.strokeWidth;
	        var radius = 50 - strokeWidth / 2;
	        var pathString = 'M 50,50 m 0,-' + radius + '\n            a ' + radius + ',' + radius + ' 0 1 1 0,' + 2 * radius + '\n            a ' + radius + ',' + radius + ' 0 1 1 0,-' + 2 * radius;
	        var len = Math.PI * 2 * radius;
	        var pathStyle = {
	            'strokeDasharray': len + 'px ' + len + 'px',
	            'strokeDashoffset': (100 - props.percent) / 100 * len + 'px',
	            'transition': 'stroke-dashoffset 0.6s ease 0s, stroke 0.6s ease'
	        };

	        var progressInfo = void 0,
	            textStyle = {
	            lineHeight: props.size + 'px'
	        };

	        if (props.showInfo === true) {
	            if (props.status === 'exception') {
	                progressInfo = _react2["default"].createElement('span', { style: textStyle, className: prefixCls + '-circle-text' }, _react2["default"].createElement('i', { className: 'icon-caution' }));
	            } else if (props.status === 'success') {
	                progressInfo = _react2["default"].createElement('span', { style: textStyle, className: prefixCls + '-circle-text' }, _react2["default"].createElement('i', { className: 'icon-success' }));
	            } else {
	                progressInfo = _react2["default"].createElement('span', { style: textStyle, className: prefixCls + '-circle-text' }, props.percent, '%');
	            }
	        }

	        ['strokeWidth', 'trailWidth'].forEach(function (item) {
	            if (item === 'trailWidth' && !props.trailWidth && props.strokeWidth) {
	                props.trailWidth = props.strokeWidth;
	                return;
	            }
	            if (!props[item]) {
	                props[item] = defaultProps[item];
	            }
	        });

	        return _react2["default"].createElement('div', { className: 'kuma-progress-circle-wrap status-' + props.status, style: { width: props.size, height: props.size } }, _react2["default"].createElement('svg', { className: 'kuma-progress-circle', viewBox: '0 0 100 100' }, _react2["default"].createElement('path', { className: 'kuma-progress-circle-trail', d: pathString,
	            strokeWidth: props.trailWidth, fillOpacity: '0' }), _react2["default"].createElement('path', { className: 'kuma-progress-circle-path', d: pathString, strokeLinecap: 'round', strokeWidth: props.strokeWidth, fillOpacity: '0', style: pathStyle })), progressInfo);
	    };

	    return Circle;
	}(_react2["default"].Component);

	Circle.displayName = "Progress-Circle";
	Circle.propTypes = {
	    status: _react2["default"].PropTypes.oneOf(['normal', 'exception', 'success']),
	    percent: _react2["default"].PropTypes.number,
	    strokeWidth: _react2["default"].PropTypes.number,
	    size: _react2["default"].PropTypes.number,
	    showInfo: _react2["default"].PropTypes.bool
	};
	Circle.defaultProps = {
	    status: 'normal', // exception active
	    percent: 0,
	    strokeWidth: 6,
	    size: 156,
	    showInfo: true
	};

	exports["default"] = Circle;
	module.exports = exports['default'];

/***/ },
/* 636 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Steps Component for uxcore
	 * @author vincent.bian
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

		module.exports = __webpack_require__(637);

/***/ },
/* 637 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	exports.__esModule = true;

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	/**
	 * Steps Component for uxcore
	 * @author vincent.bian
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	var Step = __webpack_require__(638);
	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var Steps = function (_React$Component) {
	    _inherits(Steps, _React$Component);

	    function Steps(props) {
	        _classCallCheck(this, Steps);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.state = {
	            init: false,
	            tailWidth: 0
	        };
	        _this._previousStepsWidth = 0;
	        _this._itemsWidth = [];
	        return _this;
	    }

	    Steps.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	        if (nextProps.children.length !== this.props.children.length) {
	            if (this.props.direction === 'vertical') {
	                return;
	            }
	            var $dom = ReactDOM.findDOMNode(this);
	            var len = nextProps.children.length - 1;
	            this._itemsWidth = new Array(len + 1);

	            var i = void 0;
	            for (i = 0; i <= len - 1; i++) {
	                this._itemsWidth[i] = nextProps.maxDescriptionWidth;
	            }
	            this._itemsWidth[i] = nextProps.maxDescriptionWidth;
	            this._update(nextProps);
	        }
	    };

	    Steps.prototype.componentDidMount = function componentDidMount() {
	        var _this2 = this;

	        if (this.props.direction === 'vertical') {
	            return;
	        }
	        var $dom = ReactDOM.findDOMNode(this);
	        var len = $dom.children.length - 1;
	        this._itemsWidth = new Array(len + 1);

	        var i = void 0;
	        for (i = 0; i <= len - 1; i++) {
	            this._itemsWidth[i] = this.props.maxDescriptionWidth;
	        }
	        this._itemsWidth[i] = this.props.maxDescriptionWidth;
	        this._previousStepsWidth = Math.floor(ReactDOM.findDOMNode(this).offsetWidth);
	        this._update();

	        /*
	         * 把最后一个元素设置为absolute，是为了防止动态添加元素后滚动条出现导致的布局问题。
	         * 未来不考虑ie8一类的浏览器后，会采用纯css来避免各种问题。
	         */
	        $dom.children[len].style.position = 'absolute';

	        /*
	         * 下面的代码是为了兼容window系统下滚动条出现后会占用宽度的问题。
	         * componentDidMount时滚动条还不一定出现了，这时候获取的宽度可能不是最终宽度。
	         * 对于滚动条不占用宽度的浏览器，下面的代码也不二次render，_resize里面会判断要不要更新。
	         */
	        setTimeout(function () {
	            _this2._resize();
	        });

	        this._resizeBind = this._resize.bind(this);

	        if (window.attachEvent) {
	            window.attachEvent('onresize', this._resizeBind);
	        } else {
	            window.addEventListener('resize', this._resizeBind);
	        }
	    };

	    Steps.prototype.componentDidUpdate = function componentDidUpdate() {
	        this._resize();
	        var $dom = ReactDOM.findDOMNode(this);

	        var len = $dom.children.length - 1;
	        /*
	         * 把最后一个元素设置为absolute，是为了防止动态添加元素后滚动条出现导致的布局问题。
	         * 未来不考虑ie8一类的浏览器后，会采用纯css来避免各种问题。
	         */
	        for (var i = 0; i <= len; i++) {
	            $dom.children[i].style.position = 'relative';
	        }
	        $dom.children[len].style.position = 'absolute';
	    };

	    Steps.prototype.componentWillUnmount = function componentWillUnmount() {
	        if (this.props.direction === 'vertical') {
	            return;
	        }
	        if (window.attachEvent) {
	            window.detachEvent('onresize', this._resizeBind);
	        } else {
	            window.removeEventListener('resize', this._resizeBind);
	        }
	    };

	    Steps.prototype._resize = function _resize() {
	        var w = Math.floor(ReactDOM.findDOMNode(this).offsetWidth);
	        if (this._previousStepsWidth === w) {
	            return;
	        }
	        this._previousStepsWidth = w;
	        this._update();
	    };

	    Steps.prototype._update = function _update(props) {
	        props = props || this.props;
	        var len = props.children.length - 1;
	        var tw = 0;
	        this._itemsWidth.forEach(function (w) {
	            tw += w;
	        });
	        var dw = Math.floor((this._previousStepsWidth - tw) / len) - 1;
	        if (dw <= 0) {
	            return;
	        }
	        this.setState({
	            init: true,
	            tailWidth: dw
	        });
	    };

	    Steps.prototype.render = function render() {
	        var props = this.props;
	        var prefixCls = props.prefixCls;
	        var children = props.children;
	        var maxDescriptionWidth = props.maxDescriptionWidth;
	        var iconPrefix = props.iconPrefix;
	        var size = props.size;
	        var direction = props.direction;
	        var showIcon = props.showIcon;
	        var current = props.current;
	        var type = props.type;

	        var len = children.length - 1;
	        var iws = this._itemsWidth;
	        var clsName = prefixCls;
	        // if (size === 'small' && showIcon) {
	        //     clsName += ` ${prefixCls}-small`;
	        // }
	        if (direction === 'vertical') {
	            clsName += ' ' + prefixCls + '-vertical';
	        } else {
	            clsName += ' ' + prefixCls + '-type-' + type;
	        }
	        if (!showIcon) {
	            clsName += ' ' + prefixCls + '-noicon';
	        }

	        return React.createElement('div', { className: clsName }, React.Children.map(children, function (ele, idx) {
	            var np = {
	                stepNumber: showIcon ? (idx + 1).toString() : '',
	                stepLast: idx === len,
	                tailWidth: iws.length === 0 || idx === len ? 'auto' : iws[idx] + this.state.tailWidth,
	                prefixCls: prefixCls,
	                iconPrefix: iconPrefix,
	                maxDescriptionWidth: maxDescriptionWidth
	            };
	            if (!ele.props.status) {
	                np.status = idx === current ? 'process' : idx < current ? 'finish' : 'wait';
	            }
	            return React.cloneElement(ele, np);
	        }, this));
	    };

	    return Steps;
	}(React.Component);

	Steps.defaultProps = {
	    prefixCls: 'kuma-step',
	    iconPrefix: '',
	    // size: 'default',
	    maxDescriptionWidth: 100,
	    current: 0,
	    direction: '',
	    showIcon: true,
	    type: 'default'
	};

	// http://facebook.github.io/react/docs/reusable-components.html
	Steps.propTypes = {
	    prefixCls: React.PropTypes.string,
	    iconPrefix: React.PropTypes.string,
	    // size: React.PropTypes.oneOf(['default', 'small']),
	    maxDescriptionWidth: React.PropTypes.number,
	    current: React.PropTypes.number,
	    direction: React.PropTypes.string,
	    showIcon: React.PropTypes.bool,
	    type: React.PropTypes.oneOf(['default', 'title-on-top', 'long-desc'])
	};

	Steps.displayName = "Steps";

	Steps.Step = Step;

	exports["default"] = Steps;
	module.exports = exports['default'];

/***/ },
/* 638 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var Step = function (_React$Component) {
	    _inherits(Step, _React$Component);

	    function Step(props) {
	        _classCallCheck(this, Step);

	        return _possibleConstructorReturn(this, _React$Component.call(this, props));
	    }

	    Step.prototype.render = function render() {
	        var props = this.props;
	        var status = props.status || 'wait';
	        var prefixCls = props.prefixCls;
	        var iconPrefix = props.iconPrefix;
	        var maxWidth = props.maxDescriptionWidth;
	        var iconName = props.icon ? props.icon : 'check';
	        var icon = void 0,
	            stepCls = prefixCls + '-item ' + prefixCls + '-status-' + status,
	            tail = void 0,
	            description = void 0;
	        if (!props.icon && status !== 'process' || !props.stepLast) {
	            icon = React.createElement('span', { className: prefixCls + '-icon' }, props.stepNumber);
	        } else {
	            icon = React.createElement('span', { className: prefixCls + '-icon ' + iconPrefix + 'icon ' + iconPrefix + 'icon-' + iconName });
	        }

	        if (props.stepLast) {
	            stepCls += ' ' + prefixCls + '-item-last';
	        } else {
	            tail = React.createElement('div', { className: prefixCls + '-tail' }, React.createElement('i', null));
	        }
	        if (props.icon) {
	            stepCls += ' ' + prefixCls + '-custom';
	        }
	        if (props.description) {
	            description = React.createElement('div', { className: prefixCls + '-description' }, props.description);
	        }

	        return React.createElement('div', { className: '' + stepCls, style: { width: props.tailWidth } }, tail, React.createElement('div', { className: prefixCls + '-head' }, React.createElement('div', { className: prefixCls + '-head-inner' }, icon)), React.createElement('div', { className: prefixCls + '-main', style: { maxWidth: maxWidth } }, React.createElement('div', { className: prefixCls + '-title' }, props.title), description));
	    };

	    return Step;
	}(React.Component);

		module.exports = Step;

/***/ },
/* 639 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Table Component for uxcore
	 * @author zhouquan.yezq
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

		module.exports = __webpack_require__(640);

/***/ },
/* 640 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	    return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	    return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};

	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};

	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof2(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	/**
	 * Table Component for uxcore
	 * @author zhouquan.yezq
	 *
	 * Copyright 2014-2015, UXCore Team, Alinw.
	 * All rights reserved.
	 */

	var Header = __webpack_require__(641);
	var Tbody = __webpack_require__(660);
	var ActionBar = __webpack_require__(675);
	var CellField = __webpack_require__(665);
	var Pagination = __webpack_require__(572);
	var Const = __webpack_require__(222);
	var assign = __webpack_require__(643);
	var deepcopy = __webpack_require__(669);
	var deepEqual = __webpack_require__(670);
	var classnames = __webpack_require__(5);

	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var Table = function (_React$Component) {
	    _inherits(Table, _React$Component);

	    function Table(props) {
	        _classCallCheck(this, Table);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.uid = 0;
	        _this.fields = {};
	        _this.state = {
	            data: _this.addValuesInData(deepcopy(_this.props.jsxdata)), // checkbox 内部交互
	            columns: _this.processColumn(), // column 内部交互
	            showMask: _this.props.showMask, // fetchData 时的内部状态改变
	            pageSize: props.pageSize, // pagination 相关
	            currentPage: props.currentPage, // pagination 相关
	            activeColumn: null,
	            searchTxt: "",
	            passedData: null,
	            params: null,
	            selected: [],
	            expanded: false
	        };
	        return _this;
	    }

	    Table.prototype.componentWillMount = function componentWillMount() {
	        if (this.props.fetchDataOnMount) {
	            this.fetchData();
	        }
	    };

	    Table.prototype.componentDidMount = function componentDidMount() {
	        var me = this;
	        me.el = ReactDOM.findDOMNode(me);
	        if (!!me.state.data && !!me.state.data.datas) {
	            console.warn("Table: 'content.data' rather than 'content.datas' is recommended, the support for 'content.datas' will be end from ver. 1.3.0");
	        }
	        if (me.props.subComp) {
	            console.warn("Table: subComp is deprecated, use renderSubComp instead.");
	        }
	    };

	    Table.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	        var me = this;
	        var newData = {};
	        if (!!nextProps.jsxdata && !!me.props.jsxdata && !me._isEqual(nextProps.jsxdata, me.props.jsxdata)) {
	            // Data has changed, so uid which is used to mark the data should be reset.
	            me.uid = 0;
	            newData['data'] = me.addValuesInData(deepcopy(nextProps.jsxdata));
	            me.data = deepcopy(newData['data']);
	        }
	        if (nextProps.pageSize != me.props.pageSize) {
	            newData['pageSize'] = nextProps.pageSize;
	        }
	        if (nextProps.currentPage != me.props.currentPage) {
	            newData['currentPage'] = nextProps.currentPage;
	        }
	        if (!!nextProps.jsxcolumns && !!me.props.jsxcolumns && !me._isEqual(nextProps.jsxcolumns, me.props.jsxcolumns)) {
	            newData['columns'] = me.processColumn(nextProps);
	        }
	        me.setState(newData);
	    };

	    Table.prototype.componentWillUnmount = function componentWillUnmount() {
	        var me = this;
	    };

	    /**
	     * For inline edit
	     * receive changes from cell field and change state.data
	     * inform users of the change with dataKey & pass
	     */

	    Table.prototype.handleDataChange = function handleDataChange(obj) {
	        var me = this;
	        var jsxid = obj.jsxid;
	        var column = obj.column;
	        var value = obj.value;
	        var text = obj.text;
	        var pass = obj.pass;

	        var dataKey = column.dataKey;
	        var editKey = column.editKey || dataKey;
	        var data = deepcopy(me.state.data);
	        var changedData = {};
	        for (var i = 0; i < data.data.length; i++) {
	            if (data.data[i].jsxid == jsxid) {
	                data.data[i][dataKey] = text;
	                data.data[i][editKey] = value;
	                changedData = data.data[i];
	            }
	        }

	        me.setState({
	            data: data
	        }, function () {
	            me.props.onChange({
	                data: me.state.data,
	                editKey: editKey,
	                dataKey: dataKey,
	                changedData: changedData,
	                pass: pass
	            });
	        });
	    };

	    /**
	     * register CellField to Table for the global validation
	     * @param field {element} the cell field to be registered
	     */

	    Table.prototype.attachCellField = function attachCellField(validate, name) {
	        var me = this;
	        if (!name) {
	            console.error("Table: name can not be empty, check the dataKey of the column config");
	        } else {
	            me.fields[name] = validate;
	        }
	    };

	    /**
	     * cancel the CellField when it is unmounted.
	     * @param field {element} the cell field to be canceled.
	     */

	    Table.prototype.detachCellField = function detachCellField(name) {
	        delete this.fields[name];
	    };

	    /**
	     * simple method to compare two datas, 
	     * only support the data which JSON can parse.
	     */

	    Table.prototype._isEqual = function _isEqual(a, b) {
	        return deepEqual(a, b);
	    };

	    /**
	     * get Query Object by combining data from searchBar, column order, pagination
	     * and fetchParams.
	     * @param from {string} used in props.beforeFetch
	     */

	    Table.prototype.getQueryObj = function getQueryObj(from) {

	        var me = this,
	            queryObj = {};
	        if (me.props.passedData) {
	            var queryKeys = me.props.queryKeys;
	            if (!queryKeys) {
	                queryObj = me.props.passedData;
	            } else {
	                queryKeys.forEach(function (key) {
	                    if (me.props.passedData[key] !== undefined) {
	                        queryObj[key] = me.props.passedData[key];
	                    }
	                });
	            }
	        }

	        // pagination
	        queryObj = assign({}, queryObj, {
	            pageSize: me.state.pageSize,
	            currentPage: me.state.currentPage
	        });

	        // column order
	        var activeColumn = me.state.activeColumn;
	        var orderType = me.state.orderType;
	        if (!!activeColumn) {
	            queryObj = assign({}, queryObj, {
	                orderColumn: activeColumn.dataKey
	            });
	            if (!!orderType && orderType != 'none') {
	                queryObj.orderType = orderType;
	            }
	        }

	        // search query
	        var searchTxt = me.state.searchTxt;
	        if (!!searchTxt) {
	            queryObj = assign({}, queryObj, {
	                searchTxt: searchTxt
	            });
	        }

	        // fetchParams has the top priority
	        if (!!me.props.fetchParams) {
	            queryObj = assign({}, queryObj, me.props.fetchParams);
	        }

	        return me.props.beforeFetch(queryObj, from);
	    };

	    /**
	     * fetch Data via Ajax
	     * @param from {string} tell fetchData where it is invoked, the param will be 
	     * passed to props.beforeFetch in order to help the user.
	     */

	    Table.prototype.fetchData = function fetchData(from) {

	        var me = this;
	        // reset uid cause table data has changed
	        me.uid = 0;

	        // fetchUrl has the top priority.
	        if (!!me.props.fetchUrl) {
	            if (me.ajax) {
	                me.ajax.abort();
	            }
	            if (!me.state.showMask) {
	                me.setState({
	                    showMask: true
	                });
	            }
	            var ajaxOptions = {
	                url: me.props.fetchUrl,
	                data: me.getQueryObj(from),
	                cache: false,
	                dataType: "json",
	                success: function success(result) {
	                    if (result.success === true || result.hasError === false) {
	                        var _data = result.content;
	                        var processedData = me.addValuesInData(me.props.processData(deepcopy(_data)));
	                        var updateObj = {
	                            data: processedData,
	                            showMask: false
	                        };
	                        if (processedData.currentPage !== undefined) {
	                            updateObj.currentPage = processedData.currentPage;
	                        }
	                        me.data = deepcopy(processedData);
	                        me.setState(updateObj);
	                    } else {
	                        me.props.onFetchError(result);
	                    }
	                }
	            };

	            if (/\.jsonp/.test(me.props.fetchUrl)) {
	                ajaxOptions.dataType = "jsonp";
	            }

	            me.ajax = $.ajax(ajaxOptions);
	        } else if (!!me.props.passedData) {

	            if (!me.props.queryKeys) {
	                var data = me.addValuesInData(me.props.processData(deepcopy(me.props.passedData)));
	                me.setState({
	                    data: data
	                });
	                me.data = deepcopy(data);
	            } else {
	                (function () {
	                    var data = {};
	                    me.props.queryKeys.forEach(function (key, index) {
	                        if (me.props.passedData[key] !== undefined) {
	                            data[key] = me.props.passedData[key];
	                        }
	                    });
	                    var processedData = me.addValuesInData(me.props.processData(deepcopy(data)));
	                    me.setState({
	                        data: processedData
	                    });
	                    me.data = deepcopy(processedData);
	                })();
	            }
	        } else if (!!this.props.jsxdata) {
	            var data = this.addValuesInData(deepcopy(this.props.jsxdata));
	            me.setState({
	                data: data
	            });
	            me.data = deepcopy(data);
	        } else {
	            //default will create one row
	            var data = {
	                data: [{
	                    jsxid: me.uid++,
	                    __mode__: Const.MODE.EDIT
	                }],
	                "currentPage": 1,
	                "totalCount": 0
	            };
	            me.data = deepcopy(data);
	            me.setState({
	                "data": deepcopy(data)
	            });
	        }
	    };

	    Table.prototype.processColumn = function processColumn(props) {

	        props = props || this.props;

	        var me = this,
	            columns = deepcopy(props.jsxcolumns),
	            hasCheckboxColumn = false;

	        columns.forEach(function (item, i) {
	            // only one rowSelector can be rendered in Table.
	            if (item.type == 'checkbox' || item.type == 'radioSelector' || item.type == 'checkboxSelector') {
	                hasCheckboxColumn = true;
	                me.checkboxColumn = item;
	                me.checkboxColumnKey = item.dataKey;
	                item.width = item.width || 32;
	                item.align = item.align || 'right';
	            }
	        });

	        // filter the column which has a dataKey 'jsxchecked' & 'jsxtreeIcon'

	        columns = columns.filter(function (item) {
	            return item.dataKey !== 'jsxchecked' && item.dataKey !== 'jsxtreeIcon';
	        });

	        // if hidden is not set, then it's false
	        columns = columns.map(function (item, index) {
	            item.hidden = !!item.hidden;
	            return item;
	        });

	        if (!!props.rowSelection & !hasCheckboxColumn) {
	            // console.warn("It will be deprecated that a checkbox(radio) in first column without column config, You should specify the column type with 'checkboxSelector' or 'radioSelector'");
	            me.checkboxColumn = {
	                dataKey: 'jsxchecked',
	                width: 32,
	                type: props.rowSelector,
	                align: 'right'
	            };
	            me.checkboxColumnKey = 'jsxchecked';

	            columns = [me.checkboxColumn].concat(columns);
	        }

	        // no rowSelection but has parentHasCheckbox, render placeholder
	        else if (!!props.parentHasCheckbox) {
	                columns = [{
	                    dataKey: 'jsxwhite',
	                    width: 46,
	                    type: 'empty'
	                }].concat(columns);
	            }

	            // no rowSelection but has parentHasCheck, render placeholder
	            else if (!!props.parentHasCheck) {
	                    columns = [{
	                        dataKey: 'jsxwhite',
	                        width: 46,
	                        type: 'empty'
	                    }].concat(columns);
	                }

	        if ((!!props.subComp || !!props.renderSubComp) && props.renderModel !== 'tree') {
	            columns = [{
	                dataKey: 'jsxtreeIcon',
	                width: 34,
	                type: 'treeIcon'
	            }].concat(columns);
	        }
	        // no subComp but has passedData, means sub mode, parent should has tree icon,
	        // render tree icon placeholder
	        else if (!!props.passedData) {
	                columns = [{
	                    dataKey: 'jsxwhite',
	                    width: 34,
	                    type: 'empty'
	                }].concat(columns);
	            }

	        return columns;
	    };

	    Table.prototype.handleColumnPickerChange = function handleColumnPickerChange(checkedKeys) {
	        var _columns = deepcopy(this.state.columns);
	        var notRenderColumns = ['jsxchecked', 'jsxtreeIcon', 'jsxwhite'];

	        _columns.forEach(function (item, index) {
	            if ('group' in item) {
	                item.columns.forEach(function (ele, idx) {
	                    if (checkedKeys.indexOf(ele.dataKey) !== -1) {
	                        ele.hidden = false;
	                    } else {
	                        ele.hidden = true;
	                    }
	                });
	            } else {
	                if (checkedKeys.indexOf(item.dataKey) !== -1 || notRenderColumns.indexOf(item.dataKey) !== -1) {
	                    item.hidden = false;
	                } else {
	                    item.hidden = true;
	                }
	            }
	        });
	        this.setState({
	            columns: _columns
	        });
	    };

	    /**
	     * change SelectedRows data via checkbox, this function will pass to the Cell
	     * @param checked {boolean} the checkbox status
	     * @param rowIndex {number} the row Index
	     * @param fromMount {boolean} onSelect is called from cell Mount is not expected.
	     */

	    Table.prototype.changeSelected = function changeSelected(checked, rowIndex, fromMount) {

	        var me = this;
	        var _content = deepcopy(this.state.data);
	        var _data = _content.datas || _content.data;

	        me.checkboxColumn.type == 'radioSelector' ? _data.map(function (item, index) {
	            if (item.jsxid == rowIndex) {
	                item[me.checkboxColumnKey] = checked;
	                return item;
	            } else if (item[me.checkboxColumnKey]) {
	                item[me.checkboxColumnKey] = false;
	                return item;
	            }
	        }) : _data.map(function (item, index) {
	            if (item.jsxid == rowIndex) {
	                item[me.checkboxColumnKey] = checked;
	                return item;
	            }
	        });

	        me.setState({
	            data: _content
	        }, function () {
	            if (!fromMount) {
	                var data = me.state.data.datas || me.state.data.data;
	                var selectedRows = data.filter(function (item, index) {
	                    return item[me.checkboxColumnKey] == true;
	                });
	                !!me.props.rowSelection && !!me.props.rowSelection.onSelect && me.props.rowSelection.onSelect(checked, data[rowIndex], selectedRows);
	            }
	        });
	    };

	    Table.prototype.selectAll = function selectAll(checked) {

	        var me = this;
	        var _content = deepcopy(me.state.data);
	        var _data = _content.datas || _content.data;
	        var rowSelection = me.props.rowSelection;

	        var selectedRows = [];
	        _data = _data.forEach(function (item, index) {
	            var column = me.checkboxColumn;
	            var key = me.checkboxColumnKey;
	            if (!('isDisable' in column) || !column.isDisable(item)) {
	                item[key] = checked;
	                selectedRows.push(item);
	            }
	        });

	        if (!!rowSelection && !!rowSelection.onSelectAll) {
	            rowSelection.onSelectAll.apply(null, [checked, checked ? selectedRows : []]);
	        }
	        me.setState({
	            data: _content
	        });
	    };

	    Table.prototype.onPageChange = function onPageChange(current) {
	        var me = this;
	        me.setState({
	            currentPage: current
	        }, function () {
	            me.fetchData("pagination");
	        });
	    };

	    Table.prototype.handleShowSizeChange = function handleShowSizeChange(current, pageSize) {
	        var me = this;
	        me.setState({
	            currentPage: current,
	            pageSize: pageSize
	        }, function () {
	            me.fetchData("pagination");
	        });
	    };

	    Table.prototype.renderPager = function renderPager() {
	        var me = this;
	        var _me$state = me.state;
	        var data = _me$state.data;
	        var currentPage = _me$state.currentPage;
	        var pageSize = _me$state.pageSize;
	        var _me$props = me.props;
	        var showPagerTotal = _me$props.showPagerTotal;
	        var showPager = _me$props.showPager;
	        var locale = _me$props.locale;

	        if (showPager && data && data.totalCount) {
	            return React.createElement("div", { className: "kuma-uxtable-page" }, React.createElement(Pagination, { className: "mini",
	                locale: locale,
	                showSizeChanger: true,
	                showTotal: showPagerTotal,
	                total: data.totalCount,
	                onShowSizeChange: me.handleShowSizeChange.bind(me),
	                onChange: me.onPageChange.bind(me),
	                current: currentPage,
	                pageSize: pageSize }));
	        }
	    };

	    Table.prototype.handleOrderColumnCB = function handleOrderColumnCB(type, column) {
	        var me = this;
	        me.setState({
	            activeColumn: column,
	            orderType: type
	        }, function () {
	            me.fetchData("order");
	        });
	    };

	    Table.prototype.handleActionBarSearch = function handleActionBarSearch(value) {
	        var me = this;
	        this.setState({
	            searchTxt: value
	        }, function () {
	            me.fetchData("search");
	        });
	    };

	    Table.prototype.getData = function getData(validate) {
	        var me = this;
	        var pass = true;
	        if (validate !== false) {
	            for (name in me.fields) {
	                var fieldPass = me.fields[name]();

	                // if one field fails to pass, the table fails to pass
	                if (pass) {
	                    pass = fieldPass;
	                }
	            }
	        }
	        if (me.props.getSavedData) {
	            // 滤除可能为空的元素
	            var data = deepcopy(me.data);
	            data.data = data.data.filter(function (item) {
	                return item != undefined;
	            });
	            return {
	                data: data,
	                pass: pass
	            };
	        } else {
	            return {
	                data: me.state.data,
	                pass: pass
	            };
	        }
	    };

	    Table.prototype.hasFixColumn = function hasFixColumn() {
	        var props = this.props;
	        var _columns = props.jsxcolumns.filter(function (item) {
	            if (item.fixed) {
	                return true;
	            }
	        });
	        if (_columns.length > 0) {
	            return true;
	        }
	        return false;
	    };

	    Table.prototype.renderHeader = function renderHeader(renderHeaderProps) {

	        if (!this.props.showHeader) {
	            return;
	        }

	        if (this.hasFixColumn()) {
	            return React.createElement("div", { className: "kuma-uxtable-header-wrapper" }, React.createElement(Header, _extends({}, renderHeaderProps, { fixedColumn: "fixed", key: "grid-header-fixed" })), React.createElement(Header, _extends({}, renderHeaderProps, { fixedColumn: "scroll", key: "grid-header-scroll" })));
	        } else {
	            return React.createElement("div", { className: "kuma-uxtable-header-wrapper" }, React.createElement(Header, _extends({}, renderHeaderProps, { fixedColumn: "no" })));
	        }
	    };

	    Table.prototype.renderTbody = function renderTbody(renderBodyProps, bodyHeight) {

	        if (this.hasFixColumn()) {
	            var subComp = renderBodyProps.subComp;

	            var fixedBodyProps = _objectWithoutProperties(renderBodyProps, ["subComp"]);

	            return React.createElement("div", { className: "kuma-uxtable-body-wrapper", style: {
	                    height: bodyHeight
	                } }, React.createElement(Tbody, _extends({}, fixedBodyProps, { fixedColumn: "fixed", key: "grid-body-fixed" })), React.createElement(Tbody, _extends({}, renderBodyProps, { fixedColumn: "scroll", key: "grid-body-scroll" })));
	        } else {
	            return React.createElement("div", { className: "kuma-uxtable-body-wrapper", style: {
	                    height: bodyHeight
	                } }, React.createElement(Tbody, _extends({}, renderBodyProps, { fixedColumn: "no" })));
	        }
	    };

	    Table.prototype.render = function render() {
	        var _classnames;

	        var props = this.props;
	        var bodyHeight = undefined;
	        // if table is in sub mode, people always want to align the parent
	        // and the sub table, so width should not be cared.
	        var headerHeight = props.headerHeight;

	        var _style = {
	            width: !!props.passedData ? "auto" : props.width,
	            height: props.height
	        };
	        var actionBarHeight = props.actionBar ? props.actionBarHeight : 0;
	        var pagerHeight = props.showPager && this.state.data && this.state.data.totalCount ? 50 : 0;

	        // decide whether the table has column groups
	        var hasGroup = false;
	        for (var i = 0; i < this.state.columns.length; i++) {
	            if ('group' in this.state.columns[i]) {
	                hasGroup = true;
	                break;
	            }
	        }

	        headerHeight = headerHeight || (hasGroup ? 80 : 40);

	        if (props.height == 'auto') {
	            bodyHeight = 'auto';
	        } else {
	            bodyHeight = props.height == "100%" ? props.height : props.height - headerHeight - actionBarHeight - pagerHeight;
	        }
	        var renderBodyProps = {
	            columns: this.state.columns,
	            data: this.state.data ? this.state.data.datas || this.state.data.data : [],
	            onModifyRow: props.onModifyRow ? props.onModifyRow : function () {},
	            rowSelection: props.rowSelection,
	            addRowClassName: props.addRowClassName,
	            subComp: props.subComp,
	            renderSubComp: props.renderSubComp,
	            mask: this.state.showMask,
	            changeSelected: this.changeSelected.bind(this),
	            rowHeight: this.props.rowHeight,
	            height: bodyHeight,
	            width: props.width,
	            root: this,
	            mode: props.mode,
	            renderModel: props.renderModel,
	            levels: props.levels,
	            handleDataChange: this.handleDataChange.bind(this),
	            attachCellField: this.attachCellField.bind(this),
	            detachCellField: this.detachCellField.bind(this),
	            key: 'grid-body'
	        },
	            renderHeaderProps = {
	            columns: this.state.columns,
	            activeColumn: this.state.activeColumn,
	            orderType: this.state.orderType,
	            checkAll: this.selectAll.bind(this),
	            columnPicker: props.showColumnPicker,
	            showHeaderBorder: props.showHeaderBorder,
	            handleColumnPickerChange: this.handleColumnPickerChange.bind(this),
	            headerHeight: props.headerHeight,
	            width: props.width,
	            mode: props.mode,
	            orderColumnCB: this.handleOrderColumnCB.bind(this),
	            key: 'grid-header'

	        };

	        var actionBar = undefined;

	        if (props.actionBar || props.showSearch) {
	            var renderActionProps = {
	                onSearch: this.handleActionBarSearch.bind(this),
	                actionBarConfig: this.props.actionBar,
	                showSearch: this.props.showSearch,
	                searchBarPlaceholder: this.props.searchBarPlaceholder,
	                key: 'grid-actionbar'
	            };
	            actionBar = React.createElement(ActionBar, renderActionProps);
	        }

	        return React.createElement("div", { className: classnames((_classnames = {}, _classnames[props.jsxprefixCls] = true, _classnames["kuma-subgrid-mode"] = !!props.passedData, _classnames)), style: _style }, actionBar, React.createElement("div", { className: "kuma-uxtable-content", style: {
	                width: !!props.passedData ? "auto" : props.width
	            } }, this.renderHeader(renderHeaderProps), this.renderTbody(renderBodyProps, bodyHeight)), this.renderPager());
	    };

	    ///////////////////////// Util Method /////////////////////////

	    /**
	     * add some specific value for each row data which will be used in manipulating data & rendering.
	     * used in record API.
	     */

	    Table.prototype.addJSXIdsForRecord = function addJSXIdsForRecord(objAux) {
	        var me = this;
	        if (objAux instanceof Array) {
	            objAux = objAux.map(function (item) {
	                if (item.jsxid == undefined || item.jsxid == null) {
	                    item.jsxid = me.uid++;
	                }
	                if (!item.__mode__) {
	                    item.__mode__ = Const.MODE.EDIT;
	                }
	                return item;
	            });
	        } else {
	            objAux.jsxid = me.uid++;
	        }
	        return objAux;
	    };

	    /**
	     * add some specific value for each row data which will be used in manipulating data & rendering.
	     * used in method fetchData
	     */

	    Table.prototype.addValuesInData = function addValuesInData(objAux) {
	        if (!objAux || !objAux.datas && !objAux.data) return;
	        var me = this;
	        var data = objAux.datas || objAux.data;
	        data.forEach(function (node) {
	            node.jsxid = me.uid++;
	            node.__mode__ = node.__mode__ || Const.MODE.VIEW;
	            me.addValuesInData(node);
	        });
	        return objAux;
	    };

	    /**
	     * merge data
	     */

	    Table.prototype.mergeData = function mergeData(data, obj) {
	        var newData = deepcopy(data);

	        // code compatible
	        if (!!newData.datas) {
	            newData.datas = newData.datas.concat(obj);
	        } else if (!!newData.data) {
	            newData.data = newData.data.concat(obj);
	        }
	        newData.totalCount++;
	        return newData;
	    };

	    /**
	     * insert some data into this.state.data
	     * @param objAux {Array or Object} datum or data need to be inserted
	     */

	    Table.prototype.insertRecords = function insertRecords(objAux) {
	        if ((typeof objAux === "undefined" ? "undefined" : _typeof(objAux)) !== "object") return;
	        var me = this;
	        if (!(objAux instanceof Array)) {
	            objAux = [objAux];
	        }

	        objAux = this.addJSXIdsForRecord(objAux);

	        // me.data = me.mergeData(me.data, objAux);
	        this.setState({
	            data: me.mergeData(me.state.data, objAux)
	        });
	    };

	    /**
	     * @param {objAux} {a:'b',c:'d',jsxid:''}
	     */

	    Table.prototype.updateRecord = function updateRecord(objAux, cb) {
	        var _data = this.state.data;

	        if (!_data) {
	            return;
	        }

	        if (_data.data || _data.datas) {
	            var data = _data.data || _data.datas;

	            data = data.map(function (item) {
	                if (item.jsxid == objAux.jsxid) {
	                    return objAux;
	                } else {
	                    return item;
	                }
	            });
	            if (!!_data.data) {
	                _data.data = data;
	            } else if (!!_data.datas) {
	                _data.datas = data;
	            }
	        }
	        this.setState({
	            data: _data
	        }, function () {
	            !!cb && cb();
	        });
	    };

	    Table.prototype.syncRecord = function syncRecord(objAux) {
	        var me = this;
	        var _data = me.data.data || me.data.datas;

	        me.updateRecord(objAux, function () {
	            var _stateData = me.state.data.data || me.state.data.datas;
	            // _data.forEach((item, index) => {
	            //     if (item.jsxid == objAux.jsxid) {
	            //         _data[index] = _stateData.filter((ele) => {
	            //             return ele.jsxid == objAux.jsxid
	            //         })[0];
	            //     }
	            // });
	            _stateData.forEach(function (item, index) {
	                if (item.jsxid == objAux.jsxid) {
	                    _data[index] = item;
	                }
	            });
	        });
	    };

	    Table.prototype.removeRecords = function removeRecords(objAux) {

	        //at least one record
	        var me = this;
	        var content = this.state.data;
	        var data = content.data || content.datas;

	        // deepcopy protect
	        var _content = deepcopy(content),
	            _data = _content.data || _content.datas;

	        if (Object.prototype.toString.call(objAux) !== "[object Array]") {
	            objAux = [objAux];
	        }

	        objAux.map(function (item) {
	            _data.forEach(function (element, index, array) {
	                if (element.jsxid == item.jsxid) {
	                    _data.splice(index, 1);
	                }
	            });
	        });

	        me.data = _content;

	        this.setState({
	            data: _content
	        });
	    };

	    //////////////////////// CURD for gird ////////////////

	    Table.prototype.addEmptyRow = function addEmptyRow() {
	        this.insertRecords({});
	    };

	    Table.prototype.addRow = function addRow(rowData) {
	        this.insertRecords(rowData);
	    };

	    Table.prototype.resetRow = function resetRow(rowData) {
	        var me = this;
	        var updateData = {};
	        var _data = me.data.datas || me.data.data;
	        for (var i = 0; i < _data.length; i++) {
	            if (_data[i].jsxid == rowData.jsxid) {
	                updateData = deepcopy(_data[i]);
	                break;
	            }
	        }
	        updateData['__mode__'] = Const.MODE.EDIT;
	        this.updateRecord(updateData);
	    };

	    Table.prototype.delRow = function delRow(rowData) {
	        this.removeRecords(rowData);
	    };

	    Table.prototype.editRow = function editRow(rowData) {
	        rowData.__mode__ = Const.MODE.EDIT;
	        this.updateRecord(rowData);
	    };

	    Table.prototype.viewRow = function viewRow(rowData) {
	        rowData.__mode__ = Const.MODE.VIEW;
	        this.updateRecord(rowData);
	    };

	    Table.prototype.saveRow = function saveRow(rowData) {
	        rowData.__mode__ = Const.MODE.VIEW;
	        rowData.__edited__ = true;
	        this.syncRecord(rowData);
	    };

	    Table.prototype.saveAllRow = function saveAllRow() {
	        var me = this;
	        var data = deepcopy(me.state.data.data || me.state.data.datas);
	        data.forEach(function (item) {
	            me.saveRow(item);
	        });
	    };

	    Table.prototype.editAllRow = function editAllRow() {
	        var me = this;
	        var data = deepcopy(me.data.data || me.data.datas);
	        data.forEach(function (item) {
	            me.editRow(item);
	        });
	    };

	    Table.prototype.toggleSubComp = function toggleSubComp(rowData) {
	        var _content = deepcopy(this.state.data);
	        var _data = _content.data || _content.datas;

	        if (_data) {
	            _data = _data.map(function (item) {
	                if (item.jsxid == rowData.jsxid) {
	                    item.showSubComp = !item.showSubComp;
	                    return item;
	                } else {
	                    return item;
	                }
	            });
	        }
	        this.setState({
	            data: _content
	        });
	    };

	    return Table;
	}(React.Component);

	;

	Table.defaultProps = {
	    jsxprefixCls: "kuma-uxtable",
	    locale: "zh-cn",
	    showHeader: true,
	    width: "auto",
	    height: "auto",
	    mode: Const.MODE.EDIT,
	    renderModel: '',
	    levels: 1,
	    actionBarHeight: 40,
	    fetchDataOnMount: true,
	    doubleClickToEdit: true,
	    rowSelector: 'checkboxSelector',
	    showPager: true,
	    showColumnPicker: true,
	    showHeaderBorder: false,
	    showPagerTotal: false,
	    showMask: false,
	    showSearch: false,
	    getSavedData: true,
	    pageSize: 10,
	    rowHeight: 76,
	    fetchParams: {},
	    currentPage: 1,
	    queryKeys: [],
	    emptyText: "暂无数据",
	    searchBarPlaceholder: "搜索表格内容",
	    processData: function processData(data) {
	        return data;
	    },
	    beforeFetch: function beforeFetch(obj) {
	        return obj;
	    },
	    onFetchError: function onFetchError() {},
	    addRowClassName: function addRowClassName() {},
	    onChange: function onChange() {}
	};

	// http://facebook.github.io/react/docs/reusable-components.html
	Table.propTypes = {
	    locale: React.PropTypes.string,
	    jsxcolumns: React.PropTypes.arrayOf(React.PropTypes.object),
	    width: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.number]),
	    height: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.number]),
	    headerHeight: React.PropTypes.number,
	    pageSize: React.PropTypes.number,
	    queryKeys: React.PropTypes.array,
	    fetchDataOnMount: React.PropTypes.bool,
	    doubleClickToEdit: React.PropTypes.bool,
	    showColumnPicker: React.PropTypes.bool,
	    showPager: React.PropTypes.bool,
	    showPagerTotal: React.PropTypes.bool,
	    showHeader: React.PropTypes.bool,
	    showHeaderBorder: React.PropTypes.bool,
	    showMask: React.PropTypes.bool,
	    showSearch: React.PropTypes.bool,
	    searchBarPlaceholder: React.PropTypes.string,
	    subComp: React.PropTypes.element,
	    emptyText: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.element]),
	    jsxdata: React.PropTypes.object,
	    fetchUrl: React.PropTypes.string,
	    fetchParams: React.PropTypes.object,
	    rowSelector: React.PropTypes.string,
	    actionBar: React.PropTypes.oneOfType([React.PropTypes.array, React.PropTypes.object]),
	    processData: React.PropTypes.func,
	    beforeFetch: React.PropTypes.func,
	    onFetchError: React.PropTypes.func,
	    addRowClassName: React.PropTypes.func,
	    passedData: React.PropTypes.object,
	    // For inline edit
	    getSavedData: React.PropTypes.bool,
	    onChange: React.PropTypes.func,
	    // For tree Mode
	    renderModel: React.PropTypes.string,
	    levels: React.PropTypes.number
	};

	Table.displayName = "Table";
	Table.CellField = CellField;
	Table.Constants = Const;

	module.exports = Table;

/***/ },
/* 641 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	/**
	 * Created by xy on 15/4/13.
	 */
	var CheckBox = __webpack_require__(642);
	var assign = __webpack_require__(643);
	var Const = __webpack_require__(222);
	var Tree = __webpack_require__(644);
	var Tooltip = __webpack_require__(156);
	var classnames = __webpack_require__(5);
	var TreeNode = Tree.TreeNode;

	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var Header = function (_React$Component) {
	    _inherits(Header, _React$Component);

	    function Header(props) {
	        _classCallCheck(this, Header);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.state = {
	            pickerDisplay: 'none'
	        };
	        return _this;
	    }

	    Header.prototype.componentDidMount = function componentDidMount() {
	        var me = this;
	        me.handleGlobalClick = this.handleGlobalClick.bind(this);
	        $(document).on('click.uxcore-grid-header', me.handleGlobalClick);
	    };

	    Header.prototype.componentWillUnmount = function componentWillUnmount() {
	        var me = this;
	        $(document).off('click.uxcore-grid-header', me.handleGlobalClick);
	    };

	    Header.prototype.handleGlobalClick = function handleGlobalClick(e) {
	        if (this.props.columnPicker) {
	            this.hideColumnPicker(e);
	        }
	    };

	    Header.prototype.hideColumnPicker = function hideColumnPicker(e) {
	        var target = e.target;

	        if ($(target).parents('.kuma-column-picker-container').length == 0 && !$(target).hasClass("kuma-column-picker-container")) {
	            this.setState({
	                pickerDisplay: 'none'
	            });
	        }
	    };

	    Header.prototype.handleCheckBoxChange = function handleCheckBoxChange() {
	        var v = this.refs.checkbox.getValue();
	        this.props.checkAll.apply(null, [v]);
	    };

	    Header.prototype.handleColumnPicker = function handleColumnPicker(e) {

	        e.stopPropagation();
	        this.setState({
	            pickerDisplay: this.state.pickerDisplay == 'block' ? 'none' : 'block'
	        });
	    };

	    Header.prototype.handlePickerCheck = function handlePickerCheck(checkedKeys) {
	        this.props.handleColumnPickerChange(checkedKeys);
	    };

	    Header.prototype.getCheckedKeys = function getCheckedKeys() {
	        var me = this;
	        var columns = me.props.columns;

	        var _columns = [];
	        var checkedKeys = [];
	        columns.forEach(function (item, index) {
	            if ('group' in item) {
	                _columns = _columns.concat(item.columns);
	            } else {
	                _columns.push(item);
	            }
	        });
	        _columns.forEach(function (item, index) {
	            if (!item.hidden) {
	                checkedKeys.push(item.dataKey);
	            }
	        });
	        return checkedKeys;
	    };

	    Header.prototype.renderColumnTree = function renderColumnTree() {
	        var me = this;
	        var columns = me.props.columns;

	        var notRenderColumns = ['jsxchecked', 'jsxtreeIcon', 'jsxwhite'];

	        var treeProps = {
	            multiple: true,
	            checkable: true,
	            defaultCheckedKeys: me.getCheckedKeys(),
	            onCheck: me.handlePickerCheck.bind(me)
	        };

	        return React.createElement(Tree, treeProps, columns.map(function (item, index) {
	            if (notRenderColumns.indexOf(item.dataKey) !== -1) return;
	            if ('group' in item) {
	                return React.createElement(TreeNode, { key: item.group, title: item.group }, item.columns.map(function (column, idx) {
	                    return React.createElement(TreeNode, { key: column.dataKey, title: column.title });
	                }));
	            } else {
	                return React.createElement(TreeNode, { key: item.dataKey, title: item.title });
	            }
	        }).filter(function (item, index) {
	            return item != undefined;
	        }));
	    };

	    Header.prototype.renderPicker = function renderPicker() {
	        var me = this;
	        var _style = {
	            display: this.state.pickerDisplay
	        };

	        return React.createElement('div', { className: classnames({
	                "kuma-column-picker-container": true,
	                "hasGroup": me.hasGroup
	            }) }, React.createElement('i', { className: 'kuma-icon kuma-icon-target-list kuma-column-picker', onClick: this.handleColumnPicker.bind(this) }), React.createElement('div', { className: 'kuma-uxtable-columnpicker', style: _style, ref: 'columnpicker' }, me.renderColumnTree()));
	    };

	    Header.prototype.handleColumnOrder = function handleColumnOrder(column) {
	        var me = this;
	        var _me$props = me.props;
	        var orderColumnCB = _me$props.orderColumnCB;
	        var activeColumn = _me$props.activeColumn;
	        var orderType = _me$props.orderType;

	        var type = 'desc';
	        var typeMap = {
	            desc: 'asc',
	            asc: 'none',
	            none: 'desc'
	        };
	        if (activeColumn && column.dataKey == activeColumn.dataKey && orderType) {
	            type = typeMap[orderType];
	        }
	        orderColumnCB && orderColumnCB(type, column);
	    };

	    Header.prototype.renderOrderIcon = function renderOrderIcon(column) {
	        var me = this;
	        var _me$props2 = me.props;
	        var orderType = _me$props2.orderType;
	        var activeColumn = _me$props2.activeColumn;

	        if (column.ordered) {
	            var _classnames, _classnames2;

	            var desc = "iconfontdown",
	                asc = "iconfontup";
	            return React.createElement('span', { className: 'kuma-uxtable-h-sort', onClick: me.handleColumnOrder.bind(me, column) }, React.createElement('i', { className: classnames((_classnames = {}, _classnames['kuma-icon kuma-icon-' + asc] = true, _classnames['active'] = activeColumn && activeColumn.dataKey === column.dataKey && orderType == 'asc', _classnames)) }), React.createElement('i', { className: classnames((_classnames2 = {}, _classnames2['kuma-icon kuma-icon-' + desc] = true, _classnames2['active'] = activeColumn && activeColumn.dataKey === column.dataKey && orderType == 'desc', _classnames2)) }));
	        }
	    };

	    Header.prototype.renderMessageIcon = function renderMessageIcon(column) {
	        if (!column.message) return;
	        return React.createElement(Tooltip, { overlay: React.createElement('div', { className: 'kuma-uxtable-column-message' }, column.message) }, React.createElement('i', { className: 'kuma-icon kuma-icon-information' }));
	    };

	    Header.prototype.renderColumn = function renderColumn(item, index, hasGroup, last) {

	        if (item.hidden) return;
	        var me = this;
	        var noBorderColumn = ['jsxchecked', 'jsxtreeIcon', 'jsxwhite'];
	        var _style = {
	            width: item.width ? item.width : 100,
	            textAlign: item.align ? item.align : "left"
	        };
	        var _v = undefined;

	        if (hasGroup) {
	            assign(_style, {
	                height: 100,
	                lineHeight: 100 + 'px'
	            });
	        }

	        if (item.type == 'checkbox' || item.type == 'checkboxSelector') {
	            assign(_style, {
	                paddingRight: 4,
	                paddingLeft: 12,
	                width: item.width ? item.width : 92,
	                borderRight: 'none'
	            });

	            var checkBoxProps = {
	                ref: 'checkbox',
	                disable: me.props.mode !== Const.MODE.VIEW ? item.disable : true,
	                onchange: me.handleCheckBoxChange.bind(me)
	            };

	            _v = React.createElement(CheckBox, checkBoxProps);
	        } else {
	            _v = React.createElement('span', { title: item.title }, item.title);
	        }

	        if (noBorderColumn.indexOf(item.dataKey) !== -1 || last) {
	            assign(_style, {
	                borderRight: 'none'
	            });
	        }

	        return React.createElement('div', { key: index, className: classnames({
	                "kuma-uxtable-cell": true,
	                "show-border": me.props.showHeaderBorder
	            }), style: _style }, _v, me.renderMessageIcon(item), me.renderOrderIcon(item));
	    };

	    Header.prototype.renderColumns = function renderColumns(_columns) {
	        var me = this;

	        var columns = _columns.map(function (item, index) {
	            var last = index == _columns.length - 1;
	            if ('group' in item) {
	                // First determine whether the group should be rendered, if all columns
	                // is hidden, the column group should not be rendered.
	                var shouldRenderGroup = item.columns.some(function (column, i) {
	                    return !column.hidden;
	                });
	                if (shouldRenderGroup) {
	                    return React.createElement('div', { className: 'kuma-uxtable-header-column-group', key: index }, React.createElement('div', { className: 'kuma-uxtable-header-group-name' }, item.group), item.columns.map(function (column, i) {
	                        return me.renderColumn(column, i, false, last);
	                    }));
	                }
	            } else {
	                return me.renderColumn(item, index, me.hasGroup, last);
	            }
	        });
	        return columns;
	    };

	    Header.prototype.render = function render() {

	        var props = this.props,
	            me = this,
	            _picker = undefined,
	            _width = 0,
	            headerWrapClassName = undefined,
	            _headerStyle = {},
	            _columns = undefined;

	        if (props.columnPicker && (props.fixedColumn == 'no' || props.fixedColumn == 'scroll')) {
	            _picker = this.renderPicker();
	        }

	        if (props.fixedColumn == 'fixed') {
	            _columns = props.columns.filter(function (item) {
	                if (item.fixed && !item.hidden) {
	                    if (!item.width) {
	                        item.width = 100;
	                    }
	                    _width = item.width * 1 + _width;
	                    return true;
	                }
	            });
	            assign(_headerStyle, {
	                width: _width,
	                minWidth: _width
	            });
	            headerWrapClassName = "kuma-uxtable-header-fixed";
	        } else if (props.fixedColumn == 'scroll') {
	            _columns = props.columns.filter(function (item) {
	                if (!item.fixed) {
	                    return true;
	                } else if (!item.hidden) {
	                    if (!item.width) {
	                        item.width = 100;
	                    }
	                    _width = item.width * 1 + _width;
	                }
	            });
	            assign(_headerStyle, {
	                width: props.width - _width - 3,
	                minWidth: props.width - _width - 3
	            });
	            headerWrapClassName = "kuma-uxtable-header-scroll";
	        } else {
	            _columns = props.columns;
	            headerWrapClassName = "kuma-uxtable-header-no";
	        }

	        me.hasGroup = false;
	        for (var i = 0; i < _columns.length; i++) {
	            if ('group' in _columns[i]) {
	                me.hasGroup = true;
	                break;
	            }
	        }

	        assign(_headerStyle, {
	            height: props.headerHeight ? props.headerHeight : me.hasGroup ? 80 : 50,
	            lineHeight: (props.headerHeight ? props.headerHeight : 50) + "px"
	        });

	        return React.createElement('div', { className: headerWrapClassName, style: _headerStyle }, React.createElement('div', { className: props.jsxprefixCls }, me.renderColumns(_columns), _picker));
	    };

	    return Header;
	}(React.Component);

	;

	Header.propTypes = {};

	Header.defaultProps = {
	    jsxprefixCls: "kuma-uxtable-header"
	};

		module.exports = Header;

/***/ },
/* 642 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	exports.__esModule = true;

	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	/**
	 * A checkbox field
	 */

	var Const = __webpack_require__(222);
	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var CheckBox = function (_React$Component) {
	    _inherits(CheckBox, _React$Component);

	    function CheckBox(props) {
	        _classCallCheck(this, CheckBox);

	        return _possibleConstructorReturn(this, _React$Component.call(this, props));
	    }

	    CheckBox.prototype.handleChange = function handleChange(e) {
	        var v = this.getValue();
	        v = v ? 'checked' : '';
	        this.props.onchange.apply(null, [e]);
	    };

	    CheckBox.prototype.getValue = function getValue() {
	        return this.refs.checkbox.checked;
	    };

	    CheckBox.prototype.render = function render() {

	        var props = this.props;

	        if (props.mode !== Const.MODE.VIEW) {
	            var renderProps = {
	                className: "kuma-checkbox",
	                checked: this.props.jsxchecked,
	                onChange: this.handleChange.bind(this)
	            };
	            if (!!props.disable) {
	                renderProps.disabled = true;
	            }
	            return React.createElement('label', { className: 'kuma-uxtable-row-selector' }, React.createElement('input', _extends({ type: 'checkbox', ref: 'checkbox' }, renderProps)), React.createElement('s', null));
	        } else {

	            var renderProps = {
	                className: "kuma-checkbox",
	                checked: this.props.jsxchecked,
	                disabled: true
	            };
	            return React.createElement('label', { className: 'kuma-uxtable-row-selector' }, React.createElement('input', _extends({ type: 'checkbox', ref: 'checkbox' }, renderProps)), React.createElement('s', null));
	        }
	    };

	    return CheckBox;
	}(React.Component);

	;

	CheckBox.propTypes = {};

	CheckBox.defaultProps = {};

	exports["default"] = CheckBox;
	module.exports = exports['default'];

/***/ },
/* 643 */
33,
/* 644 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Tree Component for uxcore
	 * @author 
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

		module.exports = __webpack_require__(645);

/***/ },
/* 645 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	exports.__esModule = true;

	var _objectAssign = __webpack_require__(646);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	var _rcTree = __webpack_require__(647);

	var _rcTree2 = _interopRequireDefault(_rcTree);

	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { "default": obj };
	}

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var Tree = function (_RcTree) {
	    _inherits(Tree, _RcTree);

	    function Tree(props) {
	        _classCallCheck(this, Tree);

	        return _possibleConstructorReturn(this, _RcTree.call(this, props));
	    }

	    return Tree;
	}(_rcTree2["default"]);

	Tree.displayName = 'Tree';
	Tree.propTypes = _rcTree2["default"].propTypes;
	Tree.defaultProps = (0, _objectAssign2["default"])(_rcTree2["default"].defaultProps, {
	    prefixCls: 'kuma-tree',
	    showIcon: false
	});

	Tree.TreeNode = _rcTree2["default"].TreeNode;

	exports["default"] = Tree;
	module.exports = exports['default'];

/***/ },
/* 646 */
33,
/* 647 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _Tree = __webpack_require__(648);

	var _Tree2 = _interopRequireDefault(_Tree);

	var _TreeNode = __webpack_require__(650);

	var _TreeNode2 = _interopRequireDefault(_TreeNode);

	_Tree2['default'].TreeNode = _TreeNode2['default'];

	exports['default'] = _Tree2['default'];
	module.exports = exports['default'];

/***/ },
/* 648 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ('value' in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	var _get = function get(_x2, _x3, _x4) {
	  var _again = true;_function: while (_again) {
	    var object = _x2,
	        property = _x3,
	        receiver = _x4;_again = false;if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
	      var parent = Object.getPrototypeOf(object);if (parent === null) {
	        return undefined;
	      } else {
	        _x2 = parent;_x3 = property;_x4 = receiver;_again = true;desc = parent = undefined;continue _function;
	      }
	    } else if ('value' in desc) {
	      return desc.value;
	    } else {
	      var getter = desc.get;if (getter === undefined) {
	        return undefined;
	      }return getter.call(receiver);
	    }
	  }
	};

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	function _toConsumableArray(arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
	      arr2[i] = arr[i];
	    }return arr2;
	  } else {
	    return Array.from(arr);
	  }
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError('Cannot call a class as a function');
	  }
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== 'function' && superClass !== null) {
	    throw new TypeError('Super expression must either be null or a function, not ' + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _objectAssign = __webpack_require__(646);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	var _classnames = __webpack_require__(5);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _util = __webpack_require__(649);

	function noop() {}

	var Tree = function (_React$Component) {
	  _inherits(Tree, _React$Component);

	  function Tree(props) {
	    var _this = this;

	    _classCallCheck(this, Tree);

	    _get(Object.getPrototypeOf(Tree.prototype), 'constructor', this).call(this, props);
	    ['onKeyDown', 'onCheck'].forEach(function (m) {
	      _this[m] = _this[m].bind(_this);
	    });
	    this.contextmenuKeys = [];

	    this.state = {
	      expandedKeys: this.getDefaultExpandedKeys(props),
	      checkedKeys: this.getDefaultCheckedKeys(props),
	      selectedKeys: this.getDefaultSelectedKeys(props),
	      dragNodesKeys: '',
	      dragOverNodeKey: '',
	      dropNodeKey: ''
	    };
	  }

	  _createClass(Tree, [{
	    key: 'componentWillReceiveProps',
	    value: function componentWillReceiveProps(nextProps) {
	      var expandedKeys = this.getDefaultExpandedKeys(nextProps, true);
	      var checkedKeys = this.getDefaultCheckedKeys(nextProps, true);
	      var selectedKeys = this.getDefaultSelectedKeys(nextProps, true);
	      var st = {};
	      if (expandedKeys) {
	        st.expandedKeys = expandedKeys;
	      }
	      if (checkedKeys) {
	        st.checkedKeys = checkedKeys;
	      }
	      if (selectedKeys) {
	        st.selectedKeys = selectedKeys;
	      }
	      this.setState(st);
	    }
	  }, {
	    key: 'onDragStart',
	    value: function onDragStart(e, treeNode) {
	      this.dragNode = treeNode;
	      this.dragNodesKeys = this.getDragNodes(treeNode);
	      var st = {
	        dragNodesKeys: this.dragNodesKeys
	      };
	      var expandedKeys = this.getExpandedKeys(treeNode, false);
	      if (expandedKeys) {
	        // Controlled expand, save and then reset
	        this.getRawExpandedKeys();
	        st.expandedKeys = expandedKeys;
	      }
	      this.setState(st);
	      this.props.onDragStart({
	        event: e,
	        node: treeNode
	      });
	    }
	  }, {
	    key: 'onDragEnterGap',
	    value: function onDragEnterGap(e, treeNode) {
	      // console.log(e.pageY, getOffset(treeNode.refs.selectHandle), treeNode.props.eventKey);
	      var offsetTop = (0, _util.getOffset)(treeNode.refs.selectHandle).top;
	      var offsetHeight = treeNode.refs.selectHandle.offsetHeight;
	      var pageY = e.pageY;
	      var gapHeight = 2;
	      if (pageY > offsetTop + offsetHeight - gapHeight) {
	        this.dropPosition = 1;
	        return 1;
	      }
	      if (pageY < offsetTop + gapHeight) {
	        this.dropPosition = -1;
	        return -1;
	      }
	      this.dropPosition = 0;
	      return 0;
	    }
	  }, {
	    key: 'onDragEnter',
	    value: function onDragEnter(e, treeNode) {
	      var enterGap = this.onDragEnterGap(e, treeNode);
	      if (this.dragNode.props.eventKey === treeNode.props.eventKey && enterGap === 0) {
	        this.setState({
	          dragOverNodeKey: ''
	        });
	        return;
	      }
	      var st = {
	        dragOverNodeKey: treeNode.props.eventKey
	      };
	      var expandedKeys = this.getExpandedKeys(treeNode, true);
	      if (expandedKeys) {
	        this.getRawExpandedKeys();
	        st.expandedKeys = expandedKeys;
	      }
	      this.setState(st);
	      this.props.onDragEnter({
	        event: e,
	        node: treeNode,
	        expandedKeys: expandedKeys && [].concat(_toConsumableArray(expandedKeys)) || [].concat(_toConsumableArray(this.state.expandedKeys))
	      });
	    }
	  }, {
	    key: 'onDragOver',
	    value: function onDragOver(e, treeNode) {
	      this.props.onDragOver({ event: e, node: treeNode });
	    }
	  }, {
	    key: 'onDragLeave',
	    value: function onDragLeave(e, treeNode) {
	      this.props.onDragLeave({ event: e, node: treeNode });
	    }
	  }, {
	    key: 'onDrop',
	    value: function onDrop(e, treeNode) {
	      var key = treeNode.props.eventKey;
	      this.setState({
	        dragOverNodeKey: '',
	        dropNodeKey: key
	      });
	      if (this.dragNodesKeys.indexOf(key) > -1) {
	        if (console.warn) {
	          console.warn('can not drop to dragNode(include it\'s children node)');
	        }
	        return false;
	      }

	      var posArr = treeNode.props.pos.split('-');
	      var res = {
	        event: e,
	        node: treeNode,
	        dragNode: this.dragNode,
	        dragNodesKeys: [].concat(_toConsumableArray(this.dragNodesKeys)),
	        dropPosition: this.dropPosition + Number(posArr[posArr.length - 1])
	      };
	      if (this.dropPosition !== 0) {
	        res.dropToGap = true;
	      }
	      if ('expandedKeys' in this.props) {
	        res.rawExpandedKeys = [].concat(_toConsumableArray(this._rawExpandedKeys)) || [].concat(_toConsumableArray(this.state.expandedKeys));
	      }
	      this.props.onDrop(res);
	    }
	  }, {
	    key: 'onExpand',
	    value: function onExpand(treeNode) {
	      var _this2 = this;

	      var expand = !treeNode.props.expanded;
	      var controlled = 'expandedKeys' in this.props;
	      var expandedKeys = [].concat(_toConsumableArray(this.state.expandedKeys));
	      var index = expandedKeys.indexOf(treeNode.props.eventKey);
	      if (!controlled) {
	        if (expand) {
	          if (index === -1) {
	            expandedKeys.push(treeNode.props.eventKey);
	          }
	        } else {
	          expandedKeys.splice(index, 1);
	        }
	        this.setState({ expandedKeys: expandedKeys });
	        // remember the return object, such as expandedKeys, must clone!!
	        // so you can avoid outer code change it.
	        this.props.onExpand(treeNode, expand, [].concat(_toConsumableArray(expandedKeys)));
	      } else {
	        this.props.onExpand(treeNode, !expand, [].concat(_toConsumableArray(expandedKeys)));
	      }

	      // after data loaded, need set new expandedKeys
	      if (expand && this.props.loadData) {
	        return this.props.loadData(treeNode).then(function () {
	          if (!controlled) {
	            _this2.setState({ expandedKeys: expandedKeys });
	          }
	        });
	      }
	    }
	  }, {
	    key: 'onCheck',
	    value: function onCheck(treeNode) {
	      var checked = !treeNode.props.checked;
	      if (treeNode.props.checkPart) {
	        checked = true;
	      }
	      var key = treeNode.key || treeNode.props.eventKey;
	      var checkedKeys = [].concat(_toConsumableArray(this.state.checkedKeys));
	      if (checked && checkedKeys.indexOf(key) === -1) {
	        checkedKeys.push(key);
	      }
	      var checkKeys = (0, _util.getTreeNodesStates)(this.props.children, checkedKeys, checked, key);
	      var newSt = {
	        event: 'check',
	        node: treeNode,
	        checked: checked,
	        checkedNodes: checkKeys.checkedNodes,
	        checkedNodesPositions: checkKeys.checkedNodesPositions
	      };
	      checkedKeys = checkKeys.checkedKeys;
	      if (!('checkedKeys' in this.props)) {
	        this.setState({
	          checkedKeys: checkedKeys
	        });
	      }
	      this.props.onCheck(checkedKeys, newSt);
	    }
	  }, {
	    key: 'onSelect',
	    value: function onSelect(treeNode) {
	      var props = this.props;
	      var selectedKeys = [].concat(_toConsumableArray(this.state.selectedKeys));
	      var eventKey = treeNode.props.eventKey;
	      var index = selectedKeys.indexOf(eventKey);
	      var selected = undefined;
	      if (index !== -1) {
	        selected = false;
	        selectedKeys.splice(index, 1);
	      } else {
	        selected = true;
	        if (!props.multiple) {
	          selectedKeys.length = 0;
	        }
	        selectedKeys.push(eventKey);
	      }
	      var selectedNodes = [];
	      if (selectedKeys.length) {
	        (0, _util.loopAllChildren)(this.props.children, function (item) {
	          if (selectedKeys.indexOf(item.key) !== -1) {
	            selectedNodes.push(item);
	          }
	        });
	      }
	      var newSt = {
	        event: 'select',
	        node: treeNode,
	        selected: selected,
	        selectedNodes: selectedNodes
	      };
	      if (!('selectedKeys' in this.props)) {
	        this.setState({
	          selectedKeys: selectedKeys
	        });
	      }
	      props.onSelect(selectedKeys, newSt);
	    }
	  }, {
	    key: 'onMouseEnter',
	    value: function onMouseEnter(e, treeNode) {
	      this.props.onMouseEnter({ event: e, node: treeNode });
	    }
	  }, {
	    key: 'onMouseLeave',
	    value: function onMouseLeave(e, treeNode) {
	      this.props.onMouseLeave({ event: e, node: treeNode });
	    }
	  }, {
	    key: 'onContextMenu',
	    value: function onContextMenu(e, treeNode) {
	      var selectedKeys = [].concat(_toConsumableArray(this.state.selectedKeys));
	      var eventKey = treeNode.props.eventKey;
	      if (this.contextmenuKeys.indexOf(eventKey) === -1) {
	        this.contextmenuKeys.push(eventKey);
	      }
	      this.contextmenuKeys.forEach(function (key) {
	        var index = selectedKeys.indexOf(key);
	        if (index !== -1) {
	          selectedKeys.splice(index, 1);
	        }
	      });
	      if (selectedKeys.indexOf(eventKey) === -1) {
	        selectedKeys.push(eventKey);
	      }
	      this.setState({
	        selectedKeys: selectedKeys
	      });
	      this.props.onRightClick({ event: e, node: treeNode });
	    }

	    // all keyboard events callbacks run from here at first
	  }, {
	    key: 'onKeyDown',
	    value: function onKeyDown(e) {
	      e.preventDefault();
	    }
	  }, {
	    key: 'getFilterExpandedKeys',
	    value: function getFilterExpandedKeys(props) {
	      var defaultExpandedKeys = props.defaultExpandedKeys;
	      var expandedPositionArr = [];
	      if (props.autoExpandParent) {
	        (0, _util.loopAllChildren)(props.children, function (item, index, pos, newKey) {
	          if (defaultExpandedKeys.indexOf(newKey) > -1) {
	            expandedPositionArr.push(pos);
	          }
	        });
	      }
	      var filterExpandedKeys = [];
	      (0, _util.loopAllChildren)(props.children, function (item, index, pos, newKey) {
	        if (props.defaultExpandAll) {
	          filterExpandedKeys.push(newKey);
	        } else if (props.autoExpandParent) {
	          expandedPositionArr.forEach(function (p) {
	            if ((p.split('-').length > pos.split('-').length && (0, _util.isInclude)(pos.split('-'), p.split('-')) || pos === p) && filterExpandedKeys.indexOf(newKey) === -1) {
	              filterExpandedKeys.push(newKey);
	            }
	          });
	        }
	      });
	      return filterExpandedKeys.length ? filterExpandedKeys : defaultExpandedKeys;
	    }
	  }, {
	    key: 'getDefaultExpandedKeys',
	    value: function getDefaultExpandedKeys(props, willReceiveProps) {
	      var expandedKeys = willReceiveProps ? undefined : this.getFilterExpandedKeys(props);
	      if ('expandedKeys' in props) {
	        expandedKeys = props.expandedKeys || [];
	      }
	      return expandedKeys;
	    }
	  }, {
	    key: 'getDefaultCheckedKeys',
	    value: function getDefaultCheckedKeys(props, willReceiveProps) {
	      var checkedKeys = willReceiveProps ? undefined : props.defaultCheckedKeys;
	      if ('checkedKeys' in props) {
	        checkedKeys = props.checkedKeys || [];
	      }
	      return checkedKeys;
	    }
	  }, {
	    key: 'getDefaultSelectedKeys',
	    value: function getDefaultSelectedKeys(props, willReceiveProps) {
	      var getKeys = function getKeys(keys) {
	        if (props.multiple) {
	          return [].concat(_toConsumableArray(keys));
	        }
	        if (keys.length) {
	          return [keys[0]];
	        }
	        return keys;
	      };
	      var selectedKeys = willReceiveProps ? undefined : getKeys(props.defaultSelectedKeys);
	      if ('selectedKeys' in props) {
	        selectedKeys = getKeys(props.selectedKeys);
	      }
	      return selectedKeys;
	    }
	  }, {
	    key: 'getRawExpandedKeys',
	    value: function getRawExpandedKeys() {
	      if (!this._rawExpandedKeys && 'expandedKeys' in this.props) {
	        this._rawExpandedKeys = [].concat(_toConsumableArray(this.state.expandedKeys));
	      }
	    }
	  }, {
	    key: 'getOpenTransitionName',
	    value: function getOpenTransitionName() {
	      var props = this.props;
	      var transitionName = props.openTransitionName;
	      var animationName = props.openAnimation;
	      if (!transitionName && typeof animationName === 'string') {
	        transitionName = props.prefixCls + '-open-' + animationName;
	      }
	      return transitionName;
	    }
	  }, {
	    key: 'getDragNodes',
	    value: function getDragNodes(treeNode) {
	      var dragNodesKeys = [];
	      var tPArr = treeNode.props.pos.split('-');
	      (0, _util.loopAllChildren)(this.props.children, function (item, index, pos, newKey) {
	        var pArr = pos.split('-');
	        if (treeNode.props.pos === pos || tPArr.length < pArr.length && (0, _util.isInclude)(tPArr, pArr)) {
	          dragNodesKeys.push(newKey);
	        }
	      });
	      return dragNodesKeys;
	    }
	  }, {
	    key: 'getExpandedKeys',
	    value: function getExpandedKeys(treeNode, expand) {
	      var key = treeNode.props.eventKey;
	      var expandedKeys = this.state.expandedKeys;
	      var expandedIndex = expandedKeys.indexOf(key);
	      var exKeys = undefined;
	      if (expandedIndex > -1 && !expand) {
	        exKeys = [].concat(_toConsumableArray(expandedKeys));
	        exKeys.splice(expandedIndex, 1);
	        return exKeys;
	      }
	      if (expand && expandedKeys.indexOf(key) === -1) {
	        return expandedKeys.concat([key]);
	      }
	    }
	  }, {
	    key: 'filterTreeNode',
	    value: function filterTreeNode(treeNode) {
	      var filterTreeNode = this.props.filterTreeNode;
	      if (typeof filterTreeNode !== 'function' || treeNode.props.disabled) {
	        return false;
	      }
	      return filterTreeNode.call(this, treeNode);
	    }
	  }, {
	    key: 'renderTreeNode',
	    value: function renderTreeNode(child, index) {
	      var level = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];

	      var pos = level + '-' + index;
	      var key = child.key || pos;
	      var state = this.state;
	      var props = this.props;
	      var cloneProps = {
	        ref: 'treeNode-' + key,
	        root: this,
	        eventKey: key,
	        pos: pos,
	        selectable: props.selectable,
	        loadData: props.loadData,
	        onMouseEnter: props.onMouseEnter,
	        onMouseLeave: props.onMouseLeave,
	        onRightClick: props.onRightClick,
	        prefixCls: props.prefixCls,
	        showLine: props.showLine,
	        showIcon: props.showIcon,
	        checkable: props.checkable,
	        draggable: props.draggable,
	        dragOver: state.dragOverNodeKey === key && this.dropPosition === 0,
	        dragOverGapTop: state.dragOverNodeKey === key && this.dropPosition === -1,
	        dragOverGapBottom: state.dragOverNodeKey === key && this.dropPosition === 1,
	        expanded: state.expandedKeys.indexOf(key) !== -1,
	        selected: state.selectedKeys.indexOf(key) !== -1,
	        checked: this.checkedKeys.indexOf(key) !== -1,
	        checkPart: this.checkPartKeys.indexOf(key) !== -1,
	        openTransitionName: this.getOpenTransitionName(),
	        openAnimation: props.openAnimation,
	        filterTreeNode: this.filterTreeNode.bind(this)
	      };
	      if (this.treeNodesStates[pos]) {
	        (0, _objectAssign2['default'])(cloneProps, this.treeNodesStates[pos].siblingPosition);
	      }
	      return _react2['default'].cloneElement(child, cloneProps);
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var props = this.props;
	      var domProps = {
	        className: (0, _classnames2['default'])(props.className, props.prefixCls),
	        role: 'tree-node'
	      };
	      if (props.focusable) {
	        domProps.tabIndex = '0';
	        domProps.onKeyDown = this.onKeyDown;
	      }
	      // console.log(this.state.expandedKeys, this._rawExpandedKeys, props.children);
	      var checkKeys = (0, _util.getTreeNodesStates)(props.children, this.state.checkedKeys, true);
	      this.checkPartKeys = checkKeys.checkPartKeys;
	      this.checkedKeys = checkKeys.checkedKeys;
	      this.treeNodesStates = checkKeys.treeNodesStates;

	      return _react2['default'].createElement('ul', _extends({}, domProps, { unselectable: true, ref: 'tree' }), _react2['default'].Children.map(props.children, this.renderTreeNode, this));
	    }
	  }]);

	  return Tree;
	}(_react2['default'].Component);

	Tree.propTypes = {
	  prefixCls: _react.PropTypes.string,
	  children: _react.PropTypes.any,
	  showLine: _react.PropTypes.bool,
	  showIcon: _react.PropTypes.bool,
	  selectable: _react.PropTypes.bool,
	  multiple: _react.PropTypes.bool,
	  checkable: _react.PropTypes.oneOfType([_react.PropTypes.bool, _react.PropTypes.node]),
	  draggable: _react.PropTypes.bool,
	  autoExpandParent: _react.PropTypes.bool,
	  defaultExpandAll: _react.PropTypes.bool,
	  expandedKeys: _react.PropTypes.arrayOf(_react.PropTypes.string),
	  defaultExpandedKeys: _react.PropTypes.arrayOf(_react.PropTypes.string),
	  checkedKeys: _react.PropTypes.arrayOf(_react.PropTypes.string),
	  defaultCheckedKeys: _react.PropTypes.arrayOf(_react.PropTypes.string),
	  selectedKeys: _react.PropTypes.arrayOf(_react.PropTypes.string),
	  defaultSelectedKeys: _react.PropTypes.arrayOf(_react.PropTypes.string),
	  onExpand: _react.PropTypes.func,
	  onCheck: _react.PropTypes.func,
	  onSelect: _react.PropTypes.func,
	  loadData: _react.PropTypes.func,
	  onMouseEnter: _react.PropTypes.func,
	  onMouseLeave: _react.PropTypes.func,
	  onRightClick: _react.PropTypes.func,
	  onDragStart: _react.PropTypes.func,
	  onDragEnter: _react.PropTypes.func,
	  onDragOver: _react.PropTypes.func,
	  onDragLeave: _react.PropTypes.func,
	  onDrop: _react.PropTypes.func,
	  filterTreeNode: _react.PropTypes.func,
	  openTransitionName: _react.PropTypes.string,
	  openAnimation: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.object])
	};

	Tree.defaultProps = {
	  prefixCls: 'rc-tree',
	  showLine: false,
	  showIcon: true,
	  selectable: true,
	  multiple: false,
	  checkable: false,
	  draggable: false,
	  autoExpandParent: true,
	  defaultExpandAll: false,
	  defaultExpandedKeys: [],
	  defaultCheckedKeys: [],
	  defaultSelectedKeys: [],
	  onExpand: noop,
	  onCheck: noop,
	  onSelect: noop,
	  onDragStart: noop,
	  onDragEnter: noop,
	  onDragOver: noop,
	  onDragLeave: noop,
	  onDrop: noop
	};

	exports['default'] = Tree;
	module.exports = exports['default'];

/***/ },
/* 649 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports.browser = browser;
	exports.getOffset = getOffset;
	exports.loopAllChildren = loopAllChildren;
	exports.isInclude = isInclude;
	exports.filterParentPosition = filterParentPosition;
	exports.getTreeNodesStates = getTreeNodesStates;

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	function browser(navigator) {
	  var tem = undefined;
	  var ua = navigator.userAgent;
	  var M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
	  if (/trident/i.test(M[1])) {
	    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
	    return 'IE ' + (tem[1] || '');
	  }
	  if (M[1] === 'Chrome') {
	    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
	    if (tem) return tem.slice(1).join(' ').replace('OPR', 'Opera');
	  }
	  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
	  tem = ua.match(/version\/(\d+)/i);
	  if (tem) {
	    M.splice(1, 1, tem[1]);
	  }
	  return M.join(' ');
	}

	// export function getOffset(el) {
	//   const obj = el.getBoundingClientRect();
	//   return {
	//     left: obj.left + document.body.scrollLeft,
	//     top: obj.top + document.body.scrollTop,
	//     width: obj.width,
	//     height: obj.height
	//   };
	// }

	// // iscroll offset
	// offset = function (el) {
	//   var left = -el.offsetLeft,
	//     top = -el.offsetTop;

	//   // jshint -W084
	//   while (el = el.offsetParent) {
	//     left -= el.offsetLeft;
	//     top -= el.offsetTop;
	//   }
	//   // jshint +W084

	//   return {
	//     left: left,
	//     top: top
	//   };
	// }

	function getOffset(ele) {
	  var el = ele;
	  var _x = 0;
	  var _y = 0;
	  while (el && !isNaN(el.offsetLeft) && !isNaN(el.offsetTop)) {
	    _x += el.offsetLeft - el.scrollLeft;
	    _y += el.offsetTop - el.scrollTop;
	    el = el.offsetParent;
	  }
	  return { top: _y, left: _x };
	}

	function getChildrenlength(children) {
	  var len = 1;
	  if (Array.isArray(children)) {
	    len = children.length;
	  }
	  return len;
	}

	function getSiblingPosition(index, len, siblingPosition) {
	  if (len === 1) {
	    siblingPosition.first = true;
	    siblingPosition.last = true;
	  } else {
	    siblingPosition.first = index === 0;
	    siblingPosition.last = index === len - 1;
	  }
	  return siblingPosition;
	}

	function loopAllChildren(childs, callback) {
	  var loop = function loop(children, level) {
	    var len = getChildrenlength(children);
	    _react2['default'].Children.forEach(children, function (item, index) {
	      var pos = level + '-' + index;
	      if (item.props.children && item.type && item.type.isTreeNode) {
	        loop(item.props.children, pos);
	      }
	      callback(item, index, pos, item.key || pos, getSiblingPosition(index, len, {}));
	    });
	  };
	  loop(childs, 0);
	}

	function isInclude(smallArray, bigArray) {
	  return smallArray.every(function (ii, i) {
	    return ii === bigArray[i];
	  });
	}

	// console.log(isInclude(['0', '1'], ['0', '10', '1']));

	function uniqueArray(arr) {
	  var obj = {};
	  arr.forEach(function (item) {
	    if (!obj[item]) {
	      obj[item] = true;
	    }
	  });
	  return Object.keys(obj);
	}
	// console.log(uniqueArray(['11', '2', '2']));

	function filterParentPosition(arr) {
	  var a = [].concat(arr);
	  arr.forEach(function (item) {
	    var itemArr = item.split('-');
	    a.forEach(function (ii, index) {
	      var iiArr = ii.split('-');
	      if (itemArr.length <= iiArr.length && isInclude(itemArr, iiArr)) {
	        a[index] = item;
	      }
	      if (itemArr.length > iiArr.length && isInclude(iiArr, itemArr)) {
	        a[index] = ii;
	      }
	    });
	  });
	  return uniqueArray(a);
	}

	// console.log(filterParentPosition(['0-2', '0-10', '0-0-1', '0-1-1', '0-0','0-1', '0-10-0']));

	// TODO 效率差, 需要缓存优化
	function handleCheckState(obj, checkedPositionArr, checkIt) {
	  var stripTail = function stripTail(str) {
	    var arr = str.match(/(.+)(-[^-]+)$/);
	    var st = '';
	    if (arr && arr.length === 3) {
	      st = arr[1];
	    }
	    return st;
	  };
	  // console.log(stripTail('0-101-000'));
	  var splitPosition = function splitPosition(pos) {
	    return pos.split('-');
	  };
	  checkedPositionArr.forEach(function (_pos) {
	    // 设置子节点，全选或全不选
	    var _posArr = splitPosition(_pos);
	    Object.keys(obj).forEach(function (i) {
	      var iArr = splitPosition(i);
	      if (iArr.length > _posArr.length && isInclude(_posArr, iArr)) {
	        obj[i].checkPart = false;
	        obj[i].checked = checkIt;
	      }
	    });
	    // 循环设置父节点的 选中 或 半选状态
	    var loop = function loop(__pos) {
	      var _posLen = splitPosition(__pos).length;
	      if (_posLen <= 2) {
	        // e.g. '0-0', '0-1'
	        return;
	      }
	      var sibling = 0;
	      var siblingChecked = 0;
	      var parentPosition = stripTail(__pos);
	      Object.keys(obj).forEach(function (i) {
	        var iArr = splitPosition(i);
	        if (iArr.length === _posLen && isInclude(splitPosition(parentPosition), iArr)) {
	          sibling++;
	          if (obj[i].checked) {
	            siblingChecked++;
	          } else if (obj[i].checkPart) {
	            siblingChecked += 0.5;
	          }
	        }
	      });
	      var parent = obj[parentPosition];
	      // sibling 不会等于0
	      // 全不选 - 全选 - 半选
	      if (siblingChecked === 0) {
	        parent.checked = false;
	        parent.checkPart = false;
	      } else if (siblingChecked === sibling) {
	        parent.checked = true;
	        parent.checkPart = false;
	      } else {
	        parent.checkPart = true;
	        parent.checked = false;
	      }
	      loop(parentPosition);
	    };
	    loop(_pos);
	  });
	}

	function getCheckKeys(treeNodesStates) {
	  var checkPartKeys = [];
	  var checkedKeys = [];
	  var checkedNodes = [];
	  var checkedNodesPositions = [];
	  Object.keys(treeNodesStates).forEach(function (item) {
	    var itemObj = treeNodesStates[item];
	    if (itemObj.checked) {
	      checkedKeys.push(itemObj.key);
	      checkedNodes.push(itemObj.node);
	      checkedNodesPositions.push({ node: itemObj.node, pos: item });
	    } else if (itemObj.checkPart) {
	      checkPartKeys.push(itemObj.key);
	    }
	  });
	  return {
	    checkPartKeys: checkPartKeys, checkedKeys: checkedKeys, checkedNodes: checkedNodes, checkedNodesPositions: checkedNodesPositions, treeNodesStates: treeNodesStates
	  };
	}

	function getTreeNodesStates(children, checkedKeys, checkIt, unCheckKey) {
	  var checkedPosition = [];
	  var treeNodesStates = {};
	  loopAllChildren(children, function (item, index, pos, keyOrPos, siblingPosition) {
	    var checked = false;
	    if (checkedKeys.indexOf(keyOrPos) !== -1) {
	      checked = true;
	      checkedPosition.push(pos);
	    }
	    treeNodesStates[pos] = {
	      node: item,
	      key: keyOrPos,
	      checked: checked,
	      checkPart: false,
	      siblingPosition: siblingPosition
	    };
	  });

	  // debugger
	  handleCheckState(treeNodesStates, filterParentPosition(checkedPosition.sort()), true);

	  if (!checkIt && unCheckKey) {
	    var pos = undefined;
	    Object.keys(treeNodesStates).forEach(function (item) {
	      var itemObj = treeNodesStates[item];
	      if (itemObj.key === unCheckKey) {
	        pos = item;
	        itemObj.checked = checkIt;
	        itemObj.checkPart = false;
	      }
	    });
	    handleCheckState(treeNodesStates, [pos], checkIt);
	  }

	  return getCheckKeys(treeNodesStates);
		}

/***/ },
/* 650 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ('value' in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	var _get = function get(_x, _x2, _x3) {
	  var _again = true;_function: while (_again) {
	    var object = _x,
	        property = _x2,
	        receiver = _x3;_again = false;if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
	      var parent = Object.getPrototypeOf(object);if (parent === null) {
	        return undefined;
	      } else {
	        _x = parent;_x2 = property;_x3 = receiver;_again = true;desc = parent = undefined;continue _function;
	      }
	    } else if ('value' in desc) {
	      return desc.value;
	    } else {
	      var getter = desc.get;if (getter === undefined) {
	        return undefined;
	      }return getter.call(receiver);
	    }
	  }
	};

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	  } else {
	    obj[key] = value;
	  }return obj;
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError('Cannot call a class as a function');
	  }
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== 'function' && superClass !== null) {
	    throw new TypeError('Super expression must either be null or a function, not ' + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _objectAssign = __webpack_require__(646);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	var _classnames = __webpack_require__(5);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _rcAnimate = __webpack_require__(651);

	var _rcAnimate2 = _interopRequireDefault(_rcAnimate);

	var _util = __webpack_require__(649);

	var browserUa = typeof window !== 'undefined' ? (0, _util.browser)(window.navigator) : '';
	var ieOrEdge = /.*(IE|Edge).+/.test(browserUa);
	// const uaArray = browserUa.split(' ');
	// const gtIE8 = uaArray.length !== 2 || uaArray[0].indexOf('IE') === -1 || Number(uaArray[1]) > 8;

	var defaultTitle = '---';

	var TreeNode = function (_React$Component) {
	  _inherits(TreeNode, _React$Component);

	  function TreeNode(props) {
	    var _this = this;

	    _classCallCheck(this, TreeNode);

	    _get(Object.getPrototypeOf(TreeNode.prototype), 'constructor', this).call(this, props);
	    ['onExpand', 'onCheck', 'onContextMenu', 'onMouseEnter', 'onMouseLeave', 'onDragStart', 'onDragEnter', 'onDragOver', 'onDragLeave', 'onDrop'].forEach(function (m) {
	      _this[m] = _this[m].bind(_this);
	    });
	    this.state = {
	      dataLoading: false,
	      dragNodeHighlight: false
	    };
	  }

	  _createClass(TreeNode, [{
	    key: 'onCheck',
	    value: function onCheck() {
	      this.props.root.onCheck(this);
	    }
	  }, {
	    key: 'onSelect',
	    value: function onSelect() {
	      this.props.root.onSelect(this);
	    }
	  }, {
	    key: 'onMouseEnter',
	    value: function onMouseEnter(e) {
	      e.preventDefault();
	      this.props.root.onMouseEnter(e, this);
	    }
	  }, {
	    key: 'onMouseLeave',
	    value: function onMouseLeave(e) {
	      e.preventDefault();
	      this.props.root.onMouseLeave(e, this);
	    }
	  }, {
	    key: 'onContextMenu',
	    value: function onContextMenu(e) {
	      e.preventDefault();
	      this.props.root.onContextMenu(e, this);
	    }
	  }, {
	    key: 'onDragStart',
	    value: function onDragStart(e) {
	      // console.log('dragstart', this.props.eventKey, e);
	      // e.preventDefault();
	      e.stopPropagation();
	      this.setState({
	        dragNodeHighlight: true
	      });
	      this.props.root.onDragStart(e, this);
	      try {
	        // ie throw error
	        e.dataTransfer.setData('text/plain', 'firefox-need-it');
	      } finally {
	        // empty
	      }
	    }
	  }, {
	    key: 'onDragEnter',
	    value: function onDragEnter(e) {
	      // console.log('dragenter', this.props.eventKey, e);
	      e.preventDefault();
	      e.stopPropagation();
	      this.props.root.onDragEnter(e, this);
	    }
	  }, {
	    key: 'onDragOver',
	    value: function onDragOver(e) {
	      // console.log(this.props.eventKey, e);
	      // todo disabled
	      e.preventDefault();
	      e.stopPropagation();
	      this.props.root.onDragOver(e, this);
	      return false;
	    }
	  }, {
	    key: 'onDragLeave',
	    value: function onDragLeave(e) {
	      // console.log(this.props.eventKey, e);
	      e.stopPropagation();
	      this.props.root.onDragLeave(e, this);
	    }
	  }, {
	    key: 'onDrop',
	    value: function onDrop(e) {
	      e.preventDefault();
	      e.stopPropagation();
	      this.setState({
	        dragNodeHighlight: false
	      });
	      this.props.root.onDrop(e, this);
	    }
	  }, {
	    key: 'onExpand',
	    value: function onExpand() {
	      var _this2 = this;

	      var callbackPromise = this.props.root.onExpand(this);
	      if (callbackPromise && (typeof callbackPromise === 'undefined' ? 'undefined' : _typeof(callbackPromise)) === 'object') {
	        (function () {
	          var setLoading = function setLoading(dataLoading) {
	            _this2.setState({ dataLoading: dataLoading });
	          };
	          setLoading(true);
	          callbackPromise.then(function () {
	            setLoading(false);
	          }, function () {
	            setLoading(false);
	          });
	        })();
	      }
	    }

	    // keyboard event support
	  }, {
	    key: 'onKeyDown',
	    value: function onKeyDown(e) {
	      e.preventDefault();
	    }
	  }, {
	    key: 'renderSwitcher',
	    value: function renderSwitcher(props, expandedState) {
	      var prefixCls = props.prefixCls;
	      var switcherCls = _defineProperty({}, prefixCls + '-switcher', true);
	      if (!props.showLine) {
	        switcherCls[prefixCls + '-noline_' + expandedState] = true;
	      } else if (props.pos === '0-0') {
	        switcherCls[prefixCls + '-roots_' + expandedState] = true;
	      } else {
	        switcherCls[prefixCls + '-center_' + expandedState] = !props.last;
	        switcherCls[prefixCls + '-bottom_' + expandedState] = props.last;
	      }
	      if (props.disabled) {
	        switcherCls[prefixCls + '-switcher-disabled'] = true;
	        return _react2['default'].createElement('span', { className: (0, _classnames2['default'])(switcherCls) });
	      }
	      return _react2['default'].createElement('span', { className: (0, _classnames2['default'])(switcherCls), onClick: this.onExpand });
	    }
	  }, {
	    key: 'renderCheckbox',
	    value: function renderCheckbox(props) {
	      var prefixCls = props.prefixCls;
	      var checkboxCls = _defineProperty({}, prefixCls + '-checkbox', true);
	      if (props.checkPart) {
	        checkboxCls[prefixCls + '-checkbox-indeterminate'] = true;
	      } else if (props.checked) {
	        checkboxCls[prefixCls + '-checkbox-checked'] = true;
	      }
	      var customEle = null;
	      if (typeof props.checkable !== 'boolean') {
	        customEle = props.checkable;
	      }
	      if (props.disabled || props.disableCheckbox) {
	        checkboxCls[prefixCls + '-checkbox-disabled'] = true;
	        return _react2['default'].createElement('span', { ref: 'checkbox', className: (0, _classnames2['default'])(checkboxCls) }, customEle);
	      }
	      return _react2['default'].createElement('span', { ref: 'checkbox', className: (0, _classnames2['default'])(checkboxCls), onClick: this.onCheck }, customEle);
	    }
	  }, {
	    key: 'renderChildren',
	    value: function renderChildren(props) {
	      var renderFirst = this.renderFirst;
	      this.renderFirst = 1;
	      var transitionAppear = true;
	      if (!renderFirst && props.expanded) {
	        transitionAppear = false;
	      }
	      var children = props.children;
	      var newChildren = children;
	      var allTreeNode = undefined;
	      if (Array.isArray(children)) {
	        allTreeNode = children.every(function (item) {
	          return item.type === TreeNode;
	        });
	      }
	      if (children && (children.type === TreeNode || allTreeNode)) {
	        var _cls;

	        var cls = (_cls = {}, _defineProperty(_cls, props.prefixCls + '-child-tree', true), _defineProperty(_cls, props.prefixCls + '-child-tree-open', props.expanded), _cls);
	        if (props.showLine) {
	          cls[props.prefixCls + '-line'] = !props.last;
	        }
	        var animProps = {};
	        if (props.openTransitionName) {
	          animProps.transitionName = props.openTransitionName;
	        } else if (_typeof(props.openAnimation) === 'object') {
	          animProps.animation = (0, _objectAssign2['default'])({}, props.openAnimation);
	          if (!transitionAppear) {
	            delete animProps.animation.appear;
	          }
	        }
	        newChildren = _react2['default'].createElement(_rcAnimate2['default'], _extends({}, animProps, {
	          showProp: 'expanded',
	          transitionAppear: transitionAppear,
	          component: '' }), _react2['default'].createElement('ul', { className: (0, _classnames2['default'])(cls), expanded: props.expanded }, _react2['default'].Children.map(children, function (item, index) {
	          return props.root.renderTreeNode(item, index, props.pos);
	        }, props.root)));
	      }
	      return newChildren;
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _iconEleCls,
	          _this3 = this;

	      var props = this.props;
	      var prefixCls = props.prefixCls;
	      var expandedState = props.expanded ? 'open' : 'close';

	      var iconEleCls = (_iconEleCls = {}, _defineProperty(_iconEleCls, prefixCls + '-iconEle', true), _defineProperty(_iconEleCls, prefixCls + '-icon_loading', this.state.dataLoading), _defineProperty(_iconEleCls, prefixCls + '-icon__' + expandedState, true), _iconEleCls);

	      var canRenderSwitcher = true;
	      var content = props.title;
	      var newChildren = this.renderChildren(props);
	      if (!newChildren || newChildren === props.children) {
	        // content = newChildren;
	        newChildren = null;
	        if (!props.loadData || props.isLeaf) {
	          canRenderSwitcher = false;
	        }
	      }
	      // 如果默认不展开，不渲染进dom，在大量数据下，能使性能有很大提升！
	      if (!props.expanded) {
	        newChildren = null;
	      }

	      var selectHandle = function selectHandle() {
	        var icon = props.showIcon || props.loadData && _this3.state.dataLoading ? _react2['default'].createElement('span', { className: (0, _classnames2['default'])(iconEleCls) }) : null;
	        var title = _react2['default'].createElement('span', { className: prefixCls + '-title' }, content);
	        var domProps = {};
	        if (!props.disabled) {
	          if (props.selected || _this3.state.dragNodeHighlight) {
	            domProps.className = prefixCls + '-node-selected';
	          }
	          domProps.onClick = function (e) {
	            e.preventDefault();
	            if (props.selectable) {
	              _this3.onSelect();
	            }
	            // not fire check event
	            // if (props.checkable) {
	            //   this.onCheck();
	            // }
	          };
	          if (props.onRightClick) {
	            domProps.onContextMenu = _this3.onContextMenu;
	          }
	          if (props.onMouseEnter) {
	            domProps.onMouseEnter = _this3.onMouseEnter;
	          }
	          if (props.onMouseLeave) {
	            domProps.onMouseLeave = _this3.onMouseLeave;
	          }
	          if (props.draggable) {
	            if (ieOrEdge) {
	              // ie bug!
	              domProps.href = '#';
	            }
	            domProps.draggable = true;
	            domProps['aria-grabbed'] = true;
	            domProps.onDragStart = _this3.onDragStart;
	          }
	        }
	        return _react2['default'].createElement('a', _extends({ ref: 'selectHandle', title: typeof content === 'string' ? content : '' }, domProps), icon, title);
	      };

	      var liProps = {};
	      if (props.draggable) {
	        liProps.onDragEnter = this.onDragEnter;
	        liProps.onDragOver = this.onDragOver;
	        liProps.onDragLeave = this.onDragLeave;
	        liProps.onDrop = this.onDrop;
	      }

	      var disabledCls = '';
	      var dragOverCls = '';
	      if (props.disabled) {
	        disabledCls = prefixCls + '-treenode-disabled';
	      } else if (props.dragOver) {
	        dragOverCls = 'drag-over';
	      } else if (props.dragOverGapTop) {
	        dragOverCls = 'drag-over-gap-top';
	      } else if (props.dragOverGapBottom) {
	        dragOverCls = 'drag-over-gap-bottom';
	      }

	      var filterCls = props.filterTreeNode(this) ? 'filter-node' : '';

	      var noopSwitcher = function noopSwitcher() {
	        var _cls2;

	        var cls = (_cls2 = {}, _defineProperty(_cls2, prefixCls + '-switcher', true), _defineProperty(_cls2, prefixCls + '-switcher-noop', true), _cls2);
	        if (props.showLine) {
	          cls[prefixCls + '-center_docu'] = !props.last;
	          cls[prefixCls + '-bottom_docu'] = props.last;
	        } else {
	          cls[prefixCls + '-noline_docu'] = true;
	        }
	        return _react2['default'].createElement('span', { className: (0, _classnames2['default'])(cls) });
	      };

	      return _react2['default'].createElement('li', _extends({}, liProps, { ref: 'li', className: (0, _classnames2['default'])(props.className, disabledCls, dragOverCls, filterCls) }), canRenderSwitcher ? this.renderSwitcher(props, expandedState) : noopSwitcher(), props.checkable ? this.renderCheckbox(props) : null, selectHandle(), newChildren);
	    }
	  }]);

	  return TreeNode;
	}(_react2['default'].Component);

	TreeNode.isTreeNode = 1;

	TreeNode.propTypes = {
	  prefixCls: _react.PropTypes.string,
	  disabled: _react.PropTypes.bool,
	  disableCheckbox: _react.PropTypes.bool,
	  expanded: _react.PropTypes.bool,
	  isLeaf: _react.PropTypes.bool,
	  root: _react.PropTypes.object,
	  onSelect: _react.PropTypes.func
	};

	TreeNode.defaultProps = {
	  title: defaultTitle
	};

	exports['default'] = TreeNode;
	module.exports = exports['default'];

/***/ },
/* 651 */
[770, 652],
/* 652 */
[771, 653, 654, 659],
/* 653 */
76,
/* 654 */
[772, 655, 659],
/* 655 */
[773, 656, 657],
/* 656 */
79,
/* 657 */
[774, 658, 658],
/* 658 */
81,
/* 659 */
82,
/* 660 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	exports.__esModule = true;

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	/**
	 * Created by xy on 15/4/13.
	 */

	var Row = __webpack_require__(661);
	var Mask = __webpack_require__(673);
	var util = __webpack_require__(674);
	var deepcopy = __webpack_require__(669);

	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var Tbody = function (_React$Component) {
	    _inherits(Tbody, _React$Component);

	    function Tbody(props) {
	        _classCallCheck(this, Tbody);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.state = {};
	        return _this;
	    }

	    Tbody.prototype.componentDidMount = function componentDidMount() {
	        var me = this;
	        me.rootEl = ReactDOM.findDOMNode(me.refs.root);
	        me.scrollHandler = me.onScroll.bind(me);
	        $(me.rootEl).on("scroll", me.scrollHandler);
	    };

	    Tbody.prototype.componentWillUnmount = function componentWillUnmount() {
	        var me = this;
	        me.resizeTimer = null;
	        $(me.rootEl).off("scroll", me.scrollHandler);
	    };

	    Tbody.prototype.renderEmptyData = function renderEmptyData() {

	        if (this.props.data.length == 0 && !this.props.mask) {
	            var _style = {
	                lineHeight: this.props.height - 10 + "px"
	            };
	            return React.createElement("div", { className: "kuma-uxtable-body-emptyword", style: _style }, this.props.root.props.emptyText);
	        }
	    };

	    Tbody.prototype.onScroll = function onScroll(e) {
	        // TODO: remove jquery animation
	        //       merge classname scroll/no/fixed

	        this.el = ReactDOM.findDOMNode(this);
	        var $tableEl = $(this.el).parents(".kuma-uxtable");
	        if (this.props.fixedColumn == 'no') {
	            $tableEl.find('.kuma-uxtable-header-no').animate({
	                scrollLeft: $tableEl.find('.kuma-uxtable-body-no').scrollLeft()
	            }, 0);
	            return;
	        }

	        var target = $(e.target);
	        if (target.hasClass('kuma-uxtable-body-scroll')) {

	            $tableEl.find('.kuma-uxtable-body-fixed').animate({
	                scrollTop: $tableEl.find('.kuma-uxtable-body-scroll').scrollTop()
	            }, 0);
	            $tableEl.find('.kuma-uxtable-header-scroll').animate({
	                scrollLeft: $tableEl.find('.kuma-uxtable-body-scroll').scrollLeft()
	            }, 0);
	        } else {
	            $tableEl.find('.kuma-uxtable-body-scroll').animate({
	                scrollTop: $tableEl.find('.kuma-uxtable-body-fixed').scrollTop()
	            }, 0);
	        }
	    };

	    Tbody.prototype.render = function render() {

	        var me = this,
	            _props = me.props,
	            _columns = _props.columns,
	            _data = _props.data.length > 0 ? _props.data : [],
	            _style = {},
	            _width = 0,
	            bodyWrapClassName = undefined;

	        if (_props.fixedColumn == 'fixed') {
	            _columns = _props.columns.filter(function (item) {
	                if (item.fixed && !item.hidden) {
	                    if (!item.width) {
	                        item.width = 100;
	                    }
	                    _width = item.width * 1 + _width;
	                    return true;
	                }
	            });
	            _style = {
	                width: _width,
	                minWidth: _width
	            };
	            bodyWrapClassName = "kuma-uxtable-body-fixed";
	        } else if (_props.fixedColumn == 'scroll') {
	            var fixedWidth = 0;
	            _columns = _props.columns.filter(function (item) {
	                if (!item.fixed) {
	                    return true;
	                } else if (!item.hidden) {
	                    if (!item.width) {
	                        item.width = 100;
	                    }
	                    _width = item.width * 1 + _width;
	                }
	            });

	            // content-box: border-box
	            var delta = 2;
	            if (util.isIE(8)) {
	                delta = 3;
	            }
	            _style = {
	                width: _props.width - _width - delta, //change 2 to 3, fix ie8 issue
	                minWidth: _props.width - _width - delta
	            };
	            bodyWrapClassName = "kuma-uxtable-body-scroll";
	        } else {
	            bodyWrapClassName = "kuma-uxtable-body-no";
	        }
	        return React.createElement("div", { className: bodyWrapClassName, ref: "root", style: _style }, React.createElement("ul", { className: this.props.jsxprefixCls }, this.renderEmptyData(), _data.map(function (item, index) {
	            var renderProps = {
	                columns: _columns,
	                rowIndex: item.jsxid, //tree mode, rowIndex need think more, so use jsxid
	                rowData: deepcopy(_data[index]),
	                index: index,
	                data: _data,
	                root: _props.root,
	                addRowClassName: _props.addRowClassName,
	                rowSelection: _props.rowSelection,
	                changeSelected: me.props.changeSelected,
	                subComp: _props.subComp,
	                renderSubComp: _props.renderSubComp,
	                actions: _props.actions,
	                key: 'row' + index,
	                mode: _props.mode,
	                renderModel: _props.renderModel,
	                fixedColumn: _props.fixedColumn,
	                level: 1,
	                levels: _props.levels,
	                handleDataChange: _props.handleDataChange,
	                attachCellField: _props.attachCellField,
	                detachCellField: _props.detachCellField,
	                visible: true
	            };
	            return React.createElement(Row, renderProps);
	        }), React.createElement(Mask, { visible: _props.mask })));
	    };

	    return Tbody;
	}(React.Component);

	;

	Tbody.propTypes = {};

	Tbody.defaultProps = {
	    jsxprefixCls: "kuma-uxtable-body"
	};

	exports["default"] = Tbody;
	module.exports = exports['default'];

/***/ },
/* 661 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	exports.__esModule = true;

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	/**
	 * Created by xy on 15/4/13.
	 */
	var Cell = __webpack_require__(662);
	var classnames = __webpack_require__(5);
	var assign = __webpack_require__(643);
	var Const = __webpack_require__(222);
	var deepEqual = __webpack_require__(670);
	var deepcopy = __webpack_require__(669);

	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var Row = function (_React$Component) {
	    _inherits(Row, _React$Component);

	    function Row(props) {
	        _classCallCheck(this, Row);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.state = {
	            expanded: _this.props.level < _this.props.levels ? true : false
	        };
	        return _this;
	    }

	    Row.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
	        // 需要考虑的 prop 包括
	        // columns, rowIndex(s), rowData, index(s), addRowClassName(f), rowSelection, subComp(f), actions
	        // mode(s), renderModel(s), fixedColumn(s), levels(s)
	        var me = this;
	        var shouldUpdate = false;
	        ['rowIndex', 'index', 'mode', 'renderModel', 'fixedColumn', 'levels', 'addRowClassName', 'subComp'].forEach(function (item) {
	            if (me.props[item] !== nextProps[item]) {
	                shouldUpdate = true;
	            }
	        });
	        if (!shouldUpdate) {
	            ['columns', 'rowData', 'rowSelection', 'actions'].forEach(function (item, index) {
	                if (!deepEqual(me.props[item], nextProps[item])) {
	                    shouldUpdate = true;
	                }
	            });
	        };
	        if (!shouldUpdate) {
	            shouldUpdate = me.state.expanded !== nextState.expanded;
	        }
	        return shouldUpdate;
	    };

	    Row.prototype.handleClick = function handleClick(rowData) {
	        var me = this;
	    };

	    Row.prototype.handleDoubleClick = function handleDoubleClick(rowData) {
	        var table = this.props.root;
	        if (table.props.doubleClickToEdit) {
	            table.editRow(deepcopy(rowData));
	        }
	    };

	    Row.prototype.showSubCompFunc = function showSubCompFunc() {
	        var me = this;
	        me.props.root.toggleSubComp(me.props.rowData);
	    };

	    Row.prototype.renderSubComp = function renderSubComp() {
	        var props = this.props;

	        if (props.renderModel == 'tree') {
	            return false;
	        } else {
	            if (props.subComp) {
	                if (props.rowData.showSubComp) {
	                    var subComp = React.cloneElement(props.subComp, {
	                        passedData: this.props.rowData,
	                        parentHasCheckbox: !!this.props.rowSelection,
	                        parentHasCheck: !!this.props.rowSelection /////
	                    });
	                    return React.createElement('div', { className: 'kuma-uxtable-subrow', ref: 'subRow' }, subComp);
	                }
	                return false;
	            } else if (props.renderSubComp) {
	                var subComp = props.renderSubComp(deepcopy(props.rowData));
	                if (subComp && props.rowData.showSubComp) {
	                    return React.createElement('div', { className: 'kuma-uxtable-subrow', ref: 'subRow' }, subComp);
	                }
	                return false;
	            } else {
	                return false;
	            }
	        }
	    };

	    Row.prototype.renderChild = function renderChild() {

	        var props = this.props,
	            me = this,
	            children = [];

	        if (props.renderModel !== 'tree') {
	            return children;
	        }
	        if (props.rowData.datas) {
	            props.rowData.datas.forEach(function (node) {
	                var renderProps = assign({}, props, {
	                    level: me.props.level + 1,
	                    rowData: node,
	                    rowIndex: node.jsxid,
	                    key: node.jsxid,
	                    showSubComp: false,
	                    visible: me.state.expanded && me.props.visible
	                });
	                children.push(React.createElement(Row, renderProps));
	            });

	            var renderProps = {
	                key: "treeRow" + this.props.rowData.jsxid,
	                className: "kuma-uxtable-tree-row"
	            };

	            children = React.createElement('ul', renderProps, children);
	        }

	        return children;
	    };

	    Row.prototype.renderExpendIcon = function renderExpendIcon(rowIndex) {

	        var expandCollapseIcon = undefined,
	            props = this.props,
	            _expandIconClass = undefined;

	        if (props.renderModel !== 'tree') {
	            return false;
	        }

	        if (props.rowData.datas) {
	            if (!this.state.expanded) {

	                _expandIconClass = {
	                    "kuma-icon": true,
	                    "kuma-icon-tree-open-2": false,
	                    "kuma-icon-tree-close-2": true
	                };
	                _expandIconClass["kuma-uxtable-expandIcon-" + props.fixedColumn + "-" + rowIndex] = true;

	                expandCollapseIcon = React.createElement('span', { className: 'kuma-uxtable-tree-icon', 'data-type': props.fixedColumn, 'data-index': rowIndex,
	                    onClick: this.toggleExpanded.bind(this) }, React.createElement('i', { className: classnames(_expandIconClass) }));
	            } else {

	                _expandIconClass = {
	                    "kuma-icon": true,
	                    "kuma-icon-tree-open-2": true,
	                    "kuma-icon-tree-close-2": false
	                };
	                _expandIconClass["kuma-uxtable-expandIcon-" + props.fixedColumn + "-" + rowIndex] = true;

	                expandCollapseIcon = React.createElement('span', { className: 'kuma-uxtable-tree-icon', 'data-type': props.fixedColumn, 'data-index': rowIndex,
	                    onClick: this.toggleExpanded.bind(this) }, React.createElement('i', { className: classnames(_expandIconClass) }));
	            }
	        } else {
	            expandCollapseIcon = React.createElement('span', { className: 'kuma-uxtable-emptyicon' });
	        }
	        return expandCollapseIcon;
	    };

	    Row.prototype.renderIndent = function renderIndent() {
	        var indents = [];
	        if (this.props.renderModel == 'tree') {
	            for (var i = 0; i < this.props.level - 1; i++) {
	                var renderProps = {
	                    className: "indent",
	                    key: 'indent' + i
	                };
	                indents.push(React.createElement('span', renderProps));
	            }
	        }

	        return indents;
	    };

	    Row.prototype.toggleExpanded = function toggleExpanded(e) {
	        this.setState({
	            expanded: !this.state.expanded
	        });
	        e.stopPropagation();
	        var t = $(e.target);
	        if (!t.hasClass('kuma-uxtable-tree-icon')) {
	            t = t.parents('.kuma-uxtable-tree-icon');
	        }
	        if (t.data('type') == 'fixed') {
	            $(".kuma-uxtable-expandIcon-scroll" + "-" + t.data('index')).trigger('click');
	        } else if (t.data('type') == 'scroll') {
	            $(".kuma-uxtable-expandIcon-fixed" + "-" + t.data('index')).trigger('click');
	        }
	    };

	    Row.prototype.render = function render() {
	        var _classnames;

	        var props = this.props,
	            _columns = [],
	            _style = {},
	            _data = props.data,
	            me = this,
	            otherCls = props.addRowClassName(_data[props.rowIndex]);

	        if (!this.props.visible) {
	            _style = {
	                display: 'none'
	            };
	        }

	        props.columns.forEach(function (column, index) {
	            if ("group" in column) {
	                _columns = _columns.concat(column.columns);
	            } else {
	                _columns.push(column);
	            }
	        });

	        var firstVisableColumn = 0;

	        return React.createElement('li', { className: classnames((_classnames = {}, _classnames[this.props.prefixCls] = true, _classnames[otherCls] = !!otherCls, _classnames['even'] = props.rowIndex % 2 == 1 ? true : false, _classnames)), style: _style,
	            onClick: this.handleClick.bind(this, props.rowData),
	            onDoubleClick: this.handleDoubleClick.bind(this, props.rowData) }, React.createElement('div', { className: this.props.prefixCls + '-cells' }, _columns.map(function (item, index) {
	            if (item.hidden) return;
	            firstVisableColumn++;
	            var renderProps = {
	                column: item,
	                root: props.root,
	                align: item.align,
	                rowData: props.rowData,
	                rowIndex: props.rowIndex,
	                index: props.index,
	                cellIndex: index,
	                hasSubComp: props.subComp ? true : props.renderSubComp ? props.renderSubComp(deepcopy(props.rowData)) : false,
	                data: _data,
	                changeSelected: me.props.changeSelected,
	                showSubCompCallback: me.showSubCompFunc.bind(me),
	                rowSelection: props.rowSelection,
	                actions: props.actions,
	                mode: props.mode,
	                handleDataChange: props.handleDataChange,
	                attachCellField: props.attachCellField,
	                detachCellField: props.detachCellField,
	                key: "cell" + index
	            };

	            if (firstVisableColumn == 1) {
	                return React.createElement(Cell, renderProps, me.renderIndent(), me.renderExpendIcon(props.rowIndex));
	            }
	            //if have vertical data structure, how to process it
	            return React.createElement(Cell, renderProps);
	        })), me.renderChild(), this.renderSubComp());
	    };

	    return Row;
	}(React.Component);

	;

	Row.propTypes = {
	    prefixCls: React.PropTypes.string,
	    showSubComp: React.PropTypes.bool
	};

	Row.defaultProps = {
	    prefixCls: "kuma-uxtable-row",
	    showSubComp: false
	};

	exports["default"] = Row;
	module.exports = exports['default'];

/***/ },
/* 662 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	exports.__esModule = true;

	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	    return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	    return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof2(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	/**
	 * Created by xy on 15/4/13.
	 */

	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);
	var Const = __webpack_require__(222);
	var Dropdown = __webpack_require__(276);
	var Menu = __webpack_require__(521);

	var CheckBox = __webpack_require__(642);
	var Radio = __webpack_require__(663);
	var TextField = __webpack_require__(664);
	var SelectField = __webpack_require__(666);
	var RadioField = __webpack_require__(667);
	var util = __webpack_require__(668);
	var classnames = __webpack_require__(5);
	var assign = __webpack_require__(643);
	var deepcopy = __webpack_require__(669);
	var fieldsMap = {
	    "select": SelectField,
	    "text": TextField,
	    "radio": RadioField
	};

	var Cell = function (_React$Component) {
	    _inherits(Cell, _React$Component);

	    function Cell(props) {
	        _classCallCheck(this, Cell);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.state = {
	            'fold': 1, // 1- fold  0-unfold
	            'checked': !!_this.getCellData()
	        };
	        return _this;
	    }

	    Cell.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	        var me = this;
	        if (me.props.column.type == "checkbox" || me.props.column.type == "checkboxSelector" || me.props.column.type == "radioSelector") {
	            me.setState({
	                checked: !!me.getCellData(nextProps)
	            });
	        }
	    };

	    Cell.prototype.componentDidMount = function componentDidMount() {
	        var me = this;
	        if (me.props.column.type == "checkbox" || me.props.column.type == "checkboxSelector" || me.props.column.type == "radioSelector") {
	            me.props.changeSelected(me.state.checked, me.props.rowIndex, true);
	        }
	    };

	    Cell.prototype.handleCheckChange = function handleCheckChange(e) {
	        var me = this,
	            _props = this.props,
	            v = _props.rowData;
	        me.props.changeSelected(e.target.checked, _props.rowIndex, false);
	    };

	    Cell.prototype.handleDropdownVisibleChange = function handleDropdownVisibleChange(visible) {
	        var me = this;
	        me.setState({
	            dropdownVisible: visible
	        });
	    };

	    Cell.prototype.showSubComp = function showSubComp() {
	        this.props.showSubCompCallback.apply();
	    };

	    /**
	     * @param actions {Array or Object}
	     */

	    Cell.prototype.getActionItems = function getActionItems(actions) {
	        if ((typeof actions === 'undefined' ? 'undefined' : _typeof(actions)) !== "object") {
	            console.error("Table: Actions should be an object or array");
	            return [];
	        } else {
	            var me = this;
	            me.items = [];
	            if (actions instanceof Array) {
	                me.items = actions;
	            } else {
	                for (var i in actions) {
	                    if (actions.hasOwnProperty(i)) {
	                        me.items.push({
	                            title: i,
	                            callback: actions[i]
	                        });
	                    }
	                }
	            }

	            return me.items;
	        }
	    };

	    Cell.prototype.getEditData = function getEditData() {
	        var me = this;
	        var column = me.props.column;
	        var editKey = column.editKey || column.dataKey;
	        return me.props.rowData[editKey];
	    };

	    Cell.prototype.getCellData = function getCellData(nextProps) {

	        var props = nextProps || this.props,
	            _column = props.column,
	            cellData = props.rowData[_column.dataKey];

	        return cellData;
	    };

	    Cell.prototype.handleActionClick = function handleActionClick(cb, e) {
	        e.stopPropagation();
	        var me = this;
	        me.setState({
	            dropdownVisible: false
	        });
	        cb && cb();
	    };

	    Cell.prototype.render = function render() {

	        var me = this,
	            props = me.props,
	            _column = props.column,
	            _width = _column.width,
	            _mode = props.rowData['__mode__'],
	            _style = {
	            width: _width ? _width : 100,
	            textAlign: props.align ? props.align : "left"
	        },
	            _v = deepcopy(props.rowData),
	            renderProps = undefined;

	        if (_column.type == 'action') {
	            _v = React.createElement('div', { className: 'action-container' }, me.renderActionItems(_column, _v, _mode));
	        } else if (_column.type == 'checkbox' || _column.type == 'checkboxSelector') {

	            _style.paddingRight = 4;
	            _style.paddingLeft = 12;

	            var checked = undefined;
	            if (me.state.checked) {
	                checked = 'checked';
	            } else {
	                checked = "";
	            }

	            var disable = false;
	            if ('disable' in _column) {
	                disable = _column.disable;
	            } else if ('isDisable' in _column) {
	                disable = !!_column.isDisable(props.rowData);
	            }
	            _v = React.createElement(CheckBox, { disable: disable, mode: props.mode, align: props.align, jsxchecked: checked, ref: 'checkbox', onchange: me.handleCheckChange.bind(me) });
	        } else if (_column.type == 'radioSelector') {
	            _style.paddingRight = 4;
	            _style.paddingLeft = 12;

	            var checked = undefined;
	            if (me.state.checked) {
	                checked = 'checked';
	            } else {
	                checked = "";
	            }

	            var disable = false;
	            if ('disable' in _column) {
	                disable = _column.disable;
	            } else if ('isDisable' in _column) {
	                disable = !!_column.isDisable(props.rowData);
	            }
	            _v = React.createElement(Radio, { disable: disable, mode: props.mode, align: props.align, jsxchecked: checked, onchange: me.handleCheckChange.bind(me) });
	        } else if (_column.type == 'treeIcon') {
	            _v = me.renderTreeIcon();
	        }

	        // inline edit mode
	        else if ((_column.type == 'custom' || _column.type in fieldsMap) && _mode == Const.MODE.EDIT && (!('canEdit' in _column) || _column.canEdit(props.rowData))) {
	                renderProps = {
	                    value: me.getEditData(),
	                    rowData: props.rowData,
	                    index: props.index,
	                    column: _column,
	                    handleDataChange: props.handleDataChange,
	                    attachCellField: props.attachCellField,
	                    detachCellField: props.detachCellField
	                };
	                var Field = undefined;

	                if (_column.type == 'custom') {
	                    Field = props.column.customField;
	                } else {
	                    Field = fieldsMap[_column.type];
	                }
	                _v = React.createElement(Field, renderProps);
	            } else if (_column.type == 'money' || _column.type == "card" || _column.type == "cnmobile") {
	                _v = React.createElement('div', { title: me.getCellData() }, util.formatValue(me.getCellData(), _column.type, _column.delimiter));
	            } else if (_column.render) {
	                _v = _column.render.apply(null, [me.getCellData(), _v]);
	            } else {
	                _v = React.createElement('div', { title: me.getCellData() }, me.getCellData());
	            }

	        var child = me.props.children;
	        return React.createElement('div', { className: props.jsxprefixCls, style: _style }, child, _v);
	    };

	    /**
	     * @param {Object} column current column config
	     * @param {Object} rowData current row data
	     * @param {String} mode current row mode: edit or view, same as rowData['__mode__'] 
	     */

	    Cell.prototype.renderActionItems = function renderActionItems(column, rowData, mode) {
	        var me = this;
	        var actions = me.getActionItems(column.actions).filter(function (item) {
	            return !('mode' in item) || item.mode == mode;
	        });
	        if (actions.length <= 2) {
	            return actions.map(function (item, index) {
	                return React.createElement('a', { href: 'javascript:void(0);', key: index, className: 'action', onClick: me.handleActionClick.bind(me, item.callback.bind(me, rowData, me.props.root)) }, !!item.render ? item.render(item.title, me.props.rowData) : item.title);
	            });
	        } else {
	            var arr = [];
	            arr.push(React.createElement('a', { href: 'javascript:void(0);', className: 'action', key: 'action', onClick: me.handleActionClick.bind(me, actions[0].callback.bind(me, rowData, me.props.root)) }, !!actions[0].render ? actions[0].render(actions[0].title, me.props.rowData) : actions[0].title));
	            var menu = React.createElement(Menu, null, actions.slice(1).map(function (action, index) {
	                return React.createElement(Menu.Item, { key: index }, React.createElement('a', { href: 'javascript:void(0);', className: 'action', key: 'action', onClick: me.handleActionClick.bind(me, action.callback.bind(me, rowData, me.props.root)) }, !!action.render ? action.render(action.title, me.props.rowData) : action.title));
	            }));
	            arr.push(React.createElement('i', { className: 'kuma-icon kuma-icon-triangle-down', key: 'icon' }));
	            var dropdownOptions = {
	                key: 'icon',
	                overlay: menu,
	                trigger: ['click'],
	                visible: me.state.dropdownVisible,
	                onVisibleChange: me.handleDropdownVisibleChange.bind(me)
	            };
	            return React.createElement(Dropdown, dropdownOptions, React.createElement('span', null, arr));
	        }
	    };

	    Cell.prototype.renderTreeIcon = function renderTreeIcon() {
	        if (this.props.cellIndex == 0 && this.props.hasSubComp) {
	            var open = this.props.rowData.showSubComp;
	            return React.createElement('span', { className: 'kuma-uxtable-tree-icon', onClick: this.showSubComp.bind(this) }, React.createElement('i', { className: classnames({
	                    "kuma-icon": true,
	                    "kuma-icon-tree-open": open,
	                    "kuma-icon-tree-close": !open
	                }) }));
	        }
	    };

	    return Cell;
	}(React.Component);

	;

	Cell.propTypes = {};

	Cell.defaultProps = {
	    jsxprefixCls: "kuma-uxtable-cell"
	};

	exports["default"] = Cell;
	module.exports = exports['default'];

/***/ },
/* 663 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	exports.__esModule = true;

	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	/**
	 * A radio field
	 */

	var Const = __webpack_require__(222);
	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var Radio = function (_React$Component) {
	    _inherits(Radio, _React$Component);

	    function Radio(props) {
	        _classCallCheck(this, Radio);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.state = {
	            checked: !!_this.props.checked
	        };
	        return _this;
	    }

	    Radio.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	        this.state.checked = !!nextProps.jsxchecked;
	    };

	    Radio.prototype.handleChange = function handleChange(e) {
	        if (e.target.checked != this.state.checked) {
	            this.state.checked = !this.state.checked;
	            this.props.onchange.apply(null, [e]);
	        }
	    };

	    Radio.prototype.getValue = function getValue() {
	        return this.refs.radio.checked;
	    };

	    Radio.prototype.render = function render() {

	        var props = this.props;

	        if (props.mode !== Const.MODE.VIEW) {
	            var renderProps = {
	                className: "kuma-checkbox",
	                checked: this.props.jsxchecked,
	                onChange: this.handleChange.bind(this)
	            };
	            if (!!props.disable) {
	                renderProps.disabled = true;
	            }
	            return React.createElement('label', { className: 'kuma-uxtable-row-selector' }, React.createElement('input', _extends({ type: 'radio', ref: 'radio' }, renderProps)), React.createElement('s', null));
	        } else {

	            var renderProps = {
	                className: "kuma-checkbox",
	                checked: this.props.jsxchecked,
	                disabled: true
	            };
	            return React.createElement('label', { className: 'kuma-uxtable-row-selector' }, React.createElement('input', _extends({ type: 'radio', ref: 'radio' }, renderProps)), React.createElement('s', null));
	        }
	    };

	    return Radio;
	}(React.Component);

	;

	Radio.propTypes = {};

	Radio.defaultProps = {};

	exports["default"] = Radio;
	module.exports = exports['default'];

/***/ },
/* 664 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	/**
	 * A editable plain text field
	 */

	var CellField = __webpack_require__(665);
	var classnames = __webpack_require__(5);
	var assign = __webpack_require__(643);
	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var TextField = function (_CellField) {
	    _inherits(TextField, _CellField);

	    function TextField(props) {
	        _classCallCheck(this, TextField);

	        return _possibleConstructorReturn(this, _CellField.call(this, props));
	    }

	    TextField.prototype.renderContent = function renderContent() {
	        var me = this;
	        var dataKey = me.props.column.dataKey;
	        var fieldProps = {
	            className: classnames({
	                "kuma-input": true
	            }),
	            onChange: function onChange(e) {
	                me.handleDataChange({
	                    jsxid: me.props.rowData['jsxid'],
	                    column: me.props.column,
	                    value: e.target.value,
	                    text: e.target.value
	                });
	            },
	            value: me.props.value
	        };
	        if (me.props.column.config) {
	            var _me$props$column$conf = me.props.column.config;
	            var className = _me$props$column$conf.className;
	            var onChange = _me$props$column$conf.onChange;

	            var customProps = _objectWithoutProperties(_me$props$column$conf, ['className', 'onChange']);

	            assign(fieldProps, customProps);
	        }
	        return React.createElement('input', fieldProps);
	    };

	    return TextField;
	}(CellField);

	;

	TextField.propTypes = assign({}, CellField.propTypes);

	TextField.defaultProps = assign({}, CellField.defaultProps);

	module.exports = TextField;

/***/ },
/* 665 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	    return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	    return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof2(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var classnames = __webpack_require__(5);
	var assgin = __webpack_require__(643);

	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var CellField = function (_React$Component) {
	    _inherits(CellField, _React$Component);

	    function CellField(props) {
	        _classCallCheck(this, CellField);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.state = {
	            pass: true
	        };

	        return _this;
	    }

	    CellField.prototype.componentDidMount = function componentDidMount() {
	        var me = this;
	        me.props.attachCellField(me.validate.bind(this), me.getName());
	    };

	    CellField.prototype.componentWillUnmount = function componentWillUnmount() {
	        var me = this;
	        me.props.detachCellField(me.getName());
	    };

	    CellField.prototype.handleDataChange = function handleDataChange(obj) {
	        var me = this;
	        var jsxid = obj.jsxid;
	        var column = obj.column;
	        var value = obj.value;
	        var text = obj.text;

	        me.validate(value, function (pass) {
	            me.props.handleDataChange(assgin({}, obj, {
	                pass: pass
	            }));
	        });
	        // me.props.handleDataChange(assgin({}, obj, {
	        //     pass: me.state.pass
	        // }));
	    };

	    CellField.prototype.getName = function getName() {
	        var me = this;
	        return me.props.column.dataKey + "." + me.props.index;
	    };

	    CellField.prototype.validate = function validate(value, cb) {
	        var me = this;
	        value = value || me.props.value;
	        var rowData = me.props.rowData;
	        var rules = me.props.column.rules;

	        var pass = true;
	        var errMsg = "";
	        if ((typeof rules === 'undefined' ? 'undefined' : _typeof(rules)) == "object" && !Array.isArray(rules)) {
	            pass = !!rules.validator(value, rowData);
	            errMsg = rules.errMsg;
	        } else if (Array.isArray(rules)) {
	            for (var i = 0; i < rules.length; i++) {
	                pass = rules[i].validator(value, rowData);
	                if (!pass) {
	                    errMsg = rules[i].errMsg;
	                    break;
	                }
	            }
	        }
	        !!cb && cb(pass);
	        me.setState({
	            pass: pass,
	            errMsg: errMsg
	        });
	        return pass;
	    };

	    CellField.prototype.renderContent = function renderContent() {};

	    CellField.prototype.addSpecificClass = function addSpecificClass() {
	        return this.props.prefixCls;
	    };

	    CellField.prototype.render = function render() {
	        var _classnames;

	        var me = this;
	        var specificCls = me.addSpecificClass();
	        return React.createElement('div', { className: classnames((_classnames = {
	                "hasError": !me.state.pass
	            }, _classnames[specificCls] = true, _classnames[me.props.className] = !!me.props.className, _classnames)) }, me.renderContent());
	    };

	    return CellField;
	}(React.Component);

	CellField.displayName = "CellField";
	CellField.propTypes = {
	    prefixCls: React.PropTypes.string
	};

	CellField.defaultProps = {
	    prefixCls: 'kuma-uxtable-cell-field'
	};

		module.exports = CellField;

/***/ },
/* 666 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var CellField = __webpack_require__(665);
	var classnames = __webpack_require__(5);
	var assign = __webpack_require__(643);
	var Select = __webpack_require__(356);
	var Option = Select.Option;

	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var SelectField = function (_CellField) {
	    _inherits(SelectField, _CellField);

	    function SelectField(props) {
	        _classCallCheck(this, SelectField);

	        return _possibleConstructorReturn(this, _CellField.call(this, props));
	    }

	    SelectField.prototype.renderContent = function renderContent() {
	        var me = this;
	        var fieldProps = {
	            onSelect: function onSelect(value, Option) {
	                me.handleDataChange({
	                    jsxid: me.props.rowData['jsxid'],
	                    column: me.props.column,
	                    text: Option.props.children,
	                    value: value
	                });
	            },
	            value: me.props.value
	        };
	        if (me.props.column.config) {
	            var _me$props$column$conf = me.props.column.config;
	            var value = _me$props$column$conf.value;
	            var onSelect = _me$props$column$conf.onSelect;

	            var customProps = _objectWithoutProperties(_me$props$column$conf, ['value', 'onSelect']);

	            assign(fieldProps, customProps);
	        }
	        return React.createElement(Select, fieldProps, me.props.column.children);
	    };

	    return SelectField;
	}(CellField);

	;

	SelectField.propTypes = assign({}, CellField.propTypes);

	SelectField.defaultProps = assign({}, CellField.defaultProps);

	module.exports = SelectField;

/***/ },
/* 667 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var CellField = __webpack_require__(665);
	var classnames = __webpack_require__(5);
	var assign = __webpack_require__(643);
	var RadioGroup = __webpack_require__(352);
	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var RadioField = function (_CellField) {
	    _inherits(RadioField, _CellField);

	    function RadioField(props) {
	        _classCallCheck(this, RadioField);

	        return _possibleConstructorReturn(this, _CellField.call(this, props));
	    }

	    RadioField.prototype.processChildren = function processChildren() {
	        var me = this;
	        var obj = {};
	        me.props.column.children.forEach(function (item) {
	            obj[item.props.value] = item.props.text;
	        });
	        return obj;
	    };

	    RadioField.prototype.renderContent = function renderContent() {
	        var me = this;
	        var dataKey = me.props.column.dataKey;
	        var textMap = me.processChildren();
	        var fieldProps = {
	            onChange: function onChange(value) {
	                me.handleDataChange({
	                    jsxid: me.props.rowData['jsxid'],
	                    column: me.props.column,
	                    text: textMap[value],
	                    value: value
	                });
	            },
	            value: me.props.value
	        };
	        if (me.props.column.config) {
	            var _me$props$column$conf = me.props.column.config;
	            var value = _me$props$column$conf.value;
	            var onChange = _me$props$column$conf.onChange;

	            var customProps = _objectWithoutProperties(_me$props$column$conf, ['value', 'onChange']);

	            assign(fieldProps, customProps);
	        }
	        return React.createElement(RadioGroup, fieldProps, me.props.column.children);
	    };

	    return RadioField;
	}(CellField);

	;

	RadioField.propTypes = assign({}, CellField.propTypes);

	RadioField.defaultProps = assign({}, CellField.defaultProps);

	module.exports = RadioField;

/***/ },
/* 668 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var Formatter = __webpack_require__(154);
	var util = {
	    formatValue: function formatValue(value, type, delimiter) {
	        delimiter = delimiter || " ";
	        if (value === null || value === undefined) {
	            return value;
	        }
	        value = value + "";
	        if (type == "money") {
	            return Formatter.money(value, delimiter);
	        } else if (type == "card") {
	            return Formatter.card(value, delimiter);
	        } else if (type == "cnmobile") {
	            return Formatter.cnmobile(value, delimiter);
	        }
	    }
	};

		module.exports = util;

/***/ },
/* 669 */
341,
/* 670 */
[778, 671, 672],
/* 671 */
335,
/* 672 */
336,
/* 673 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	exports.__esModule = true;

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	/**
	 * @author: zhouquan.yezq
	 * @time : 8/12 2015
	 */

	var classnames = __webpack_require__(5);

	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var Mask = function (_React$Component) {
	    _inherits(Mask, _React$Component);

	    function Mask(props) {
	        _classCallCheck(this, Mask);

	        return _possibleConstructorReturn(this, _React$Component.call(this, props));
	    }

	    Mask.prototype.render = function render() {
	        var _classnames;

	        var props = this.props,
	            visible = props.visible,
	            loadTips = props.tips ? props.tips : "Loading...";
	        var _className = classnames((_classnames = {}, _classnames[props.jsxprefixCls] = true, _classnames[props.jsxprefixCls + "-hide"] = !visible, _classnames));
	        return React.createElement('div', { className: _className }, React.createElement('div', { className: props.jsxprefixCls + '-centerblk' }, React.createElement('span', null, loadTips)));
	    };

	    return Mask;
	}(React.Component);

	;

	Mask.propTypes = {};

	Mask.defaultProps = {
	    jsxprefixCls: "kuma-uxmask"
	};

	exports["default"] = Mask;
	module.exports = exports['default'];

/***/ },
/* 674 */
/***/ function(module, exports) {

	"use strict";

	module.exports = {
	    isIE: function isIE(version) {
	        if (navigator.appName == "Microsoft Internet Explorer") {
	            if (!version) {
	                return true;
	            } else {
	                return navigator.appVersion.split(";")[1].replace(/[ ]/g, "") == "MSIE" + version + ".0";
	            }
	        } else {
	            return false;
	        }
	    }
		};

/***/ },
/* 675 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	    return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	    return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};

	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof2(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	/**
	 * Grid Component for uxcore
	 * @author zhouquan.yezq
	 *
	 * Copyright 2014-2015, UXCore Team, Alinw.
	 * All rights reserved.
	 */

	var SearchBar = __webpack_require__(676);
	var classnames = __webpack_require__(5);
	var Button = __webpack_require__(6);
	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var ActionBar = function (_React$Component) {
	    _inherits(ActionBar, _React$Component);

	    function ActionBar(props) {
	        _classCallCheck(this, ActionBar);

	        return _possibleConstructorReturn(this, _React$Component.call(this, props));
	    }

	    ActionBar.prototype.handleSearch = function handleSearch(value) {
	        this.props.onSearch(value);
	    };

	    ActionBar.prototype.renderActionBtn = function renderActionBtn(item, index) {
	        var me = this;
	        var itemProps = {
	            className: me.props.jsxprefixCls + "-item",
	            onClick: item.callback || function () {},
	            key: index
	        };
	        if (!!item.render && typeof item.render == "function") {
	            return React.createElement("div", itemProps, item.render(item.title));
	        } else {
	            return React.createElement(Button, _extends({ type: "outline", size: "medium" }, itemProps), item.title);
	        }
	    };

	    ActionBar.prototype.renderSearchBar = function renderSearchBar() {
	        if (this.props.showSearch) {
	            var me = this;
	            var searchBarProps = {
	                onSearch: me.handleSearch.bind(me),
	                key: 'searchbar',
	                placeholder: me.props.searchBarPlaceholder
	            };
	            return React.createElement(SearchBar, searchBarProps);
	        }
	    };

	    /**
	     *  convert ActionBar config from hash to array
	     */

	    ActionBar.prototype.getActionItem = function getActionItem(config) {
	        var items = [];
	        if (config instanceof Array) {
	            items = config;
	        } else if ((typeof config === "undefined" ? "undefined" : _typeof(config)) == "object") {
	            for (var item in config) {
	                if (config.hasOwnProperty(item)) {
	                    items.push({
	                        title: item,
	                        callback: config[item]
	                    });
	                }
	            }
	        }
	        return items;
	    };

	    ActionBar.prototype.render = function render() {
	        var _classnames;

	        var me = this,
	            _props = this.props,
	            _barConfig = _props.actionBarConfig;

	        return React.createElement("div", { className: classnames((_classnames = {}, _classnames[_props.jsxprefixCls] = _props.jsxprefixCls, _classnames["fn-clear"] = true, _classnames)) }, me.getActionItem(_barConfig).map(function (item, index) {
	            return me.renderActionBtn(item, index);
	        }), me.renderSearchBar());
	    };

	    return ActionBar;
	}(React.Component);

	;

	ActionBar.propTypes = {};

	ActionBar.defaultProps = {
	    jsxprefixCls: "kuma-uxtable-actionbar"
	};

		module.exports = ActionBar;

/***/ },
/* 676 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	/**
	 * Grid Component for uxcore
	 * @author zhouquan.yezq
	 *
	 * Copyright 2014-2015, UXCore Team, Alinw.
	 * All rights reserved.
	 */

	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var SearchBar = function (_React$Component) {
	    _inherits(SearchBar, _React$Component);

	    function SearchBar(props) {
	        _classCallCheck(this, SearchBar);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.state = {
	            searchTxt: ""
	        };
	        return _this;
	    }

	    SearchBar.prototype.doSearch = function doSearch() {
	        this.props.onSearch(this.state.searchTxt);
	    };

	    SearchBar.prototype.onKeyDown = function onKeyDown(e) {
	        if (e.keyCode == 13) {
	            this.doSearch();
	        }
	    };

	    SearchBar.prototype.handleChange = function handleChange(e) {
	        this.setState({
	            searchTxt: e.target.value
	        });
	    };

	    SearchBar.prototype.render = function render() {
	        var me = this;
	        var placeholder = me.props.placeholder;

	        return React.createElement('div', { className: this.props.jsxprefixCls }, React.createElement('input', { type: 'text', className: 'kuma-input', placeholder: placeholder, value: this.state.value, onKeyDown: this.onKeyDown.bind(this), onChange: this.handleChange.bind(this) }), React.createElement('i', { className: 'kuma-icon kuma-icon-search', onClick: this.doSearch.bind(this) }));
	    };

	    return SearchBar;
	}(React.Component);

	;

	SearchBar.propTypes = {};

	SearchBar.defaultProps = {
	    jsxprefixCls: "kuma-uxtable-searchbar",
	    onSearch: function onSearch() {}
	};

		module.exports = SearchBar;

/***/ },
/* 677 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Tabs Component for uxcore
	 * @author 
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

		module.exports = __webpack_require__(678);

/***/ },
/* 678 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	exports.__esModule = true;

	var _extends = Object.assign || function (target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];for (var key in source) {
				if (Object.prototype.hasOwnProperty.call(source, key)) {
					target[key] = source[key];
				}
			}
		}return target;
	};

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(4);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _rcTabs = __webpack_require__(679);

	var _rcTabs2 = _interopRequireDefault(_rcTabs);

	var _objectAssign = __webpack_require__(695);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : { "default": obj };
	}

	function _classCallCheck(instance, Constructor) {
		if (!(instance instanceof Constructor)) {
			throw new TypeError("Cannot call a class as a function");
		}
	}

	function _possibleConstructorReturn(self, call) {
		if (!self) {
			throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		}return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
		if (typeof superClass !== "function" && superClass !== null) {
			throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
		}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var prefixCls = 'kuma-tab';
	var TYPESUFFIX = {
		large: 'lg',
		small: 'sm',
		filter: 'filter',
		brick: 'brick'
	};

	var Tabs = function (_RcTabs) {
		_inherits(Tabs, _RcTabs);

		function Tabs() {
			_classCallCheck(this, Tabs);

			return _possibleConstructorReturn(this, _RcTabs.apply(this, arguments));
		}

		Tabs.prototype.aaa = function aaa() {};

		Tabs.prototype.render = function render() {
			var props = this.props;
			var cls = [];
			if (TYPESUFFIX[props.type]) {
				cls.push([prefixCls, TYPESUFFIX[props.type]].join('-'));
			}
			cls = cls.join(' ');
			return _react2["default"].createElement(_rcTabs2["default"], _extends({}, props, { className: cls }));
		};

		return Tabs;
	}(_rcTabs2["default"]);

	Tabs.displayName = 'uxcore-tabs';
	Tabs.defaultProps = (0, _objectAssign2["default"])(_rcTabs2["default"].defaultProps, {
		prefixCls: prefixCls,
		type: 'large'
	});
	Tabs.TabPane = _rcTabs2["default"].TabPane;

	exports["default"] = Tabs;
	module.exports = exports['default'];

/***/ },
/* 679 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.TabPane = exports.default = undefined;

	var _Tabs = __webpack_require__(680);

	var _Tabs2 = _interopRequireDefault(_Tabs);

	var _TabPane2 = __webpack_require__(682);

	var _TabPane3 = _interopRequireDefault(_TabPane2);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}

	exports.default = _Tabs2.default;
	exports.TabPane = _TabPane3.default;

/***/ },
/* 680 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _KeyCode = __webpack_require__(681);

	var _KeyCode2 = _interopRequireDefault(_KeyCode);

	var _TabPane = __webpack_require__(682);

	var _TabPane2 = _interopRequireDefault(_TabPane);

	var _Nav = __webpack_require__(683);

	var _Nav2 = _interopRequireDefault(_Nav);

	var _rcAnimate = __webpack_require__(686);

	var _rcAnimate2 = _interopRequireDefault(_rcAnimate);

	var _classnames2 = __webpack_require__(5);

	var _classnames3 = _interopRequireDefault(_classnames2);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	  } else {
	    obj[key] = value;
	  }return obj;
	}

	function noop() {}

	function getDefaultActiveKey(props) {
	  var activeKey = void 0;
	  _react2.default.Children.forEach(props.children, function (child) {
	    if (!activeKey && !child.props.disabled) {
	      activeKey = child.key;
	    }
	  });
	  return activeKey;
	}

	var Tabs = _react2.default.createClass({
	  displayName: 'Tabs',

	  propTypes: {
	    destroyInactiveTabPane: _react.PropTypes.bool,
	    onTabClick: _react.PropTypes.func,
	    onChange: _react.PropTypes.func,
	    children: _react.PropTypes.any,
	    tabBarExtraContent: _react.PropTypes.any,
	    animation: _react.PropTypes.string,
	    prefixCls: _react.PropTypes.string,
	    className: _react.PropTypes.string,
	    tabPosition: _react.PropTypes.string
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      prefixCls: 'rc-tabs',
	      destroyInactiveTabPane: false,
	      tabBarExtraContent: null,
	      onChange: noop,
	      tabPosition: 'top',
	      style: {},
	      contentStyle: {},
	      navStyle: {},
	      onTabClick: noop
	    };
	  },
	  getInitialState: function getInitialState() {
	    var props = this.props;
	    var activeKey = void 0;
	    if ('activeKey' in props) {
	      activeKey = props.activeKey;
	    } else if ('defaultActiveKey' in props) {
	      activeKey = props.defaultActiveKey;
	    } else {
	      activeKey = getDefaultActiveKey(props);
	    }
	    // cache panels
	    this.renderPanels = {};
	    return {
	      activeKey: activeKey
	    };
	  },
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    var newActiveKey = this.state.activeKey;
	    if ('activeKey' in nextProps) {
	      newActiveKey = nextProps.activeKey;
	      if (!newActiveKey) {
	        this.setState({
	          activeKey: newActiveKey
	        });
	        return;
	      }
	    }
	    var found = void 0;
	    _react2.default.Children.forEach(nextProps.children, function (child) {
	      if (child.key === newActiveKey) {
	        found = true;
	      }
	    });
	    if (found) {
	      this.setActiveKey(newActiveKey, nextProps);
	    } else {
	      this.setActiveKey(getDefaultActiveKey(nextProps), nextProps);
	    }
	  },
	  onTabDestroy: function onTabDestroy(key) {
	    delete this.renderPanels[key];
	  },
	  onTabClick: function onTabClick(key) {
	    this.setActiveKey(key);
	    this.props.onTabClick(key);
	    if (this.state.activeKey !== key) {
	      this.props.onChange(key);
	    }
	  },
	  onNavKeyDown: function onNavKeyDown(e) {
	    var eventKeyCode = e.keyCode;
	    if (eventKeyCode === _KeyCode2.default.RIGHT || eventKeyCode === _KeyCode2.default.DOWN) {
	      e.preventDefault();
	      var nextKey = this.getNextActiveKey(true);
	      this.onTabClick(nextKey);
	    } else if (eventKeyCode === _KeyCode2.default.LEFT || eventKeyCode === _KeyCode2.default.UP) {
	      e.preventDefault();
	      var previousKey = this.getNextActiveKey(false);
	      this.onTabClick(previousKey);
	    }
	  },
	  getNextActiveKey: function getNextActiveKey(next) {
	    var activeKey = this.state.activeKey;
	    var children = [];
	    _react2.default.Children.forEach(this.props.children, function (c) {
	      if (!c.props.disabled) {
	        if (next) {
	          children.push(c);
	        } else {
	          children.unshift(c);
	        }
	      }
	    });
	    var length = children.length;
	    var ret = length && children[0].key;
	    children.forEach(function (child, i) {
	      if (child.key === activeKey) {
	        if (i === length - 1) {
	          ret = children[0].key;
	        } else {
	          ret = children[i + 1].key;
	        }
	      }
	    });
	    return ret;
	  },
	  getTabPanes: function getTabPanes() {
	    var _this = this;

	    var state = this.state;
	    var props = this.props;
	    var activeKey = state.activeKey;
	    var children = props.children;
	    var newChildren = [];
	    var renderPanels = this.renderPanels;

	    _react2.default.Children.forEach(children, function (c) {
	      var child = c;
	      var key = child.key;
	      var active = activeKey === key;
	      if (active || renderPanels[key]) {
	        child = active ? child : renderPanels[key];
	        renderPanels[key] = _react2.default.cloneElement(child, {
	          active: active,
	          onDestroy: _this.onTabDestroy.bind(_this, key),
	          // eventKey: key,
	          rootPrefixCls: props.prefixCls
	        });
	        newChildren.push(renderPanels[key]);
	      } else {
	        // do not change owner ...
	        // or else will destroy and reinit
	        // newChildren.push(<TabPane active={false}
	        //  key={key}
	        //  eventKey={key}
	        //  rootPrefixCls={this.props.prefixCls}></TabPane>);
	        // return
	        // lazy load
	        newChildren.push(_react2.default.cloneElement(child, {
	          active: false,
	          // eventKey: key,
	          rootPrefixCls: props.prefixCls
	        }, []));
	      }
	    });

	    return newChildren;
	  },
	  getIndexPair: function getIndexPair(props, currentActiveKey, activeKey) {
	    var keys = [];
	    _react2.default.Children.forEach(props.children, function (c) {
	      keys.push(c.key);
	    });
	    var currentIndex = keys.indexOf(currentActiveKey);
	    var nextIndex = keys.indexOf(activeKey);
	    return {
	      currentIndex: currentIndex, nextIndex: nextIndex
	    };
	  },
	  setActiveKey: function setActiveKey(activeKey, ps) {
	    var props = ps || this.props;
	    var currentActiveKey = this.state.activeKey;
	    if (currentActiveKey === activeKey || 'activeKey' in props && props === this.props) {
	      return;
	    }
	    if (!currentActiveKey) {
	      this.setState({
	        activeKey: activeKey
	      });
	    } else {
	      var _getIndexPair = this.getIndexPair(props, currentActiveKey, activeKey);

	      var currentIndex = _getIndexPair.currentIndex;
	      var nextIndex = _getIndexPair.nextIndex;
	      // removed

	      if (currentIndex === -1) {
	        var newPair = this.getIndexPair(this.props, currentActiveKey, activeKey);
	        currentIndex = newPair.currentIndex;
	        nextIndex = newPair.nextIndex;
	      }
	      var tabMovingDirection = currentIndex > nextIndex ? 'backward' : 'forward';
	      this.setState({
	        activeKey: activeKey,
	        tabMovingDirection: tabMovingDirection
	      });
	    }
	  },
	  render: function render() {
	    var _classnames;

	    var props = this.props;
	    var destroyInactiveTabPane = props.destroyInactiveTabPane;
	    var prefixCls = props.prefixCls;
	    var tabPosition = props.tabPosition;
	    var className = props.className;
	    var animation = props.animation;

	    var cls = (0, _classnames3.default)((_classnames = {}, _defineProperty(_classnames, prefixCls, 1), _defineProperty(_classnames, prefixCls + '-' + tabPosition, 1), _defineProperty(_classnames, className, !!className), _classnames));
	    var tabMovingDirection = this.state.tabMovingDirection;
	    var tabPanes = this.getTabPanes();
	    var transitionName = void 0;
	    transitionName = props.transitionName && props.transitionName[tabMovingDirection || 'backward'];
	    if (!transitionName && animation) {
	      transitionName = prefixCls + '-' + animation + '-' + (tabMovingDirection || 'backward');
	    }
	    if (destroyInactiveTabPane) {
	      tabPanes = tabPanes.filter(function (panel) {
	        return panel.props.active;
	      });
	    }
	    if (transitionName) {
	      if (destroyInactiveTabPane) {
	        tabPanes = _react2.default.createElement(_rcAnimate2.default, {
	          exclusive: true,
	          transitionName: transitionName
	        }, tabPanes);
	      } else {
	        tabPanes = _react2.default.createElement(_rcAnimate2.default, {
	          showProp: 'active',
	          exclusive: true,
	          transitionName: transitionName
	        }, tabPanes);
	      }
	    }
	    var contents = [_react2.default.createElement(_Nav2.default, {
	      prefixCls: prefixCls,
	      key: 'nav',
	      onKeyDown: this.onNavKeyDown,
	      tabBarExtraContent: this.props.tabBarExtraContent,
	      tabPosition: tabPosition,
	      style: props.navStyle,
	      onTabClick: this.onTabClick,
	      tabMovingDirection: tabMovingDirection,
	      panels: this.props.children,
	      activeKey: this.state.activeKey
	    }), _react2.default.createElement('div', {
	      className: prefixCls + '-content',
	      style: props.contentStyle,
	      key: 'content'
	    }, tabPanes)];
	    if (tabPosition === 'bottom') {
	      contents.reverse();
	    }
	    return _react2.default.createElement('div', {
	      className: cls,
	      style: props.style
	    }, contents);
	  }
	});

	Tabs.TabPane = _TabPane2.default;

	exports.default = Tabs;
	module.exports = exports['default'];

/***/ },
/* 681 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  /**
	   * LEFT
	   */
	  LEFT: 37, // also NUM_WEST
	  /**
	   * UP
	   */
	  UP: 38, // also NUM_NORTH
	  /**
	   * RIGHT
	   */
	  RIGHT: 39, // also NUM_EAST
	  /**
	   * DOWN
	   */
	  DOWN: 40 };
	module.exports = exports['default'];

/***/ },
/* 682 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _classnames2 = __webpack_require__(5);

	var _classnames3 = _interopRequireDefault(_classnames2);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	  } else {
	    obj[key] = value;
	  }return obj;
	}

	var TabPane = _react2.default.createClass({
	  displayName: 'TabPane',

	  propTypes: {
	    onDestroy: _react2.default.PropTypes.func
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    if (this.props.onDestroy) {
	      this.props.onDestroy();
	    }
	  },
	  render: function render() {
	    var _classnames;

	    var props = this.props;
	    var prefixCls = props.rootPrefixCls + '-tabpane';
	    var cls = (0, _classnames3.default)((_classnames = {}, _defineProperty(_classnames, prefixCls + '-hidden', !props.active), _defineProperty(_classnames, prefixCls, 1), _classnames));
	    return _react2.default.createElement('div', { className: cls }, props.children);
	  }
	});

	exports.default = TabPane;
	module.exports = exports['default'];

/***/ },
/* 683 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _classnames3 = __webpack_require__(5);

	var _classnames4 = _interopRequireDefault(_classnames3);

	var _InkBarMixin = __webpack_require__(684);

	var _InkBarMixin2 = _interopRequireDefault(_InkBarMixin);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	  } else {
	    obj[key] = value;
	  }return obj;
	}

	var tabBarExtraContentStyle = {
	  float: 'right'
	};

	function noop() {}

	var Nav = _react2.default.createClass({
	  displayName: 'Nav',

	  propTypes: {
	    tabPosition: _react.PropTypes.string,
	    tabBarExtraContent: _react.PropTypes.any,
	    onTabClick: _react.PropTypes.func,
	    onKeyDown: _react.PropTypes.func
	  },

	  mixins: [_InkBarMixin2.default],

	  getInitialState: function getInitialState() {
	    return {
	      next: false,
	      offset: 0,
	      prev: false
	    };
	  },
	  componentDidMount: function componentDidMount() {
	    this.componentDidUpdate();
	  },
	  componentDidUpdate: function componentDidUpdate(prevProps) {
	    var props = this.props;
	    if (prevProps && prevProps.tabPosition !== props.tabPosition) {
	      this.setOffset(0);
	      return;
	    }
	    var navNode = this.refs.nav;
	    var navNodeWH = this.getOffsetWH(navNode);
	    var navWrapNode = this.refs.navWrap;
	    var navWrapNodeWH = this.getOffsetWH(navWrapNode);
	    var state = this.state;
	    var offset = state.offset;
	    var minOffset = navWrapNodeWH - navNodeWH;
	    var _state = this.state;
	    var next = _state.next;
	    var prev = _state.prev;

	    if (minOffset >= 0) {
	      next = false;
	      this.setOffset(0);
	      offset = 0;
	    } else if (minOffset < offset) {
	      next = true;
	    } else {
	      next = false;
	      this.setOffset(minOffset);
	      offset = minOffset;
	    }

	    if (offset < 0) {
	      prev = true;
	    } else {
	      prev = false;
	    }

	    this.setNext(next);
	    this.setPrev(prev);

	    var nextPrev = {
	      next: next,
	      prev: prev
	    };
	    // wait next,prev show hide
	    if (this.isNextPrevShown(state) !== this.isNextPrevShown(nextPrev)) {
	      this.setNextPrev({}, this.scrollToActiveTab);
	    } else {
	      // can not use props.activeKey
	      if (!prevProps || props.activeKey !== prevProps.activeKey) {
	        this.scrollToActiveTab();
	      }
	    }
	  },
	  onTabClick: function onTabClick(key) {
	    this.props.onTabClick(key);
	  },

	  // work around eslint warning
	  setNextPrev: function setNextPrev(nextPrev, callback) {
	    this.setState(nextPrev, callback);
	  },
	  getTabs: function getTabs() {
	    var _this = this;

	    var props = this.props;
	    var children = props.panels;
	    var activeKey = props.activeKey;
	    var rst = [];
	    var prefixCls = props.prefixCls;

	    _react2.default.Children.forEach(children, function (child) {
	      var key = child.key;
	      var cls = activeKey === key ? prefixCls + '-tab-active' : '';
	      cls += ' ' + prefixCls + '-tab';
	      var events = {};
	      if (child.props.disabled) {
	        cls += ' ' + prefixCls + '-tab-disabled';
	      } else {
	        events = {
	          onClick: _this.onTabClick.bind(_this, key)
	        };
	      }
	      var ref = {};
	      if (activeKey === key) {
	        ref.ref = 'activeTab';
	      }
	      rst.push(_react2.default.createElement('div', _extends({}, events, {
	        className: cls,
	        key: key
	      }, ref), _react2.default.createElement('div', { className: prefixCls + '-tab-inner' }, child.props.tab)));
	    });

	    return rst;
	  },
	  getOffsetWH: function getOffsetWH(node) {
	    var tabPosition = this.props.tabPosition;
	    var prop = 'offsetWidth';
	    if (tabPosition === 'left' || tabPosition === 'right') {
	      prop = 'offsetHeight';
	    }
	    return node[prop];
	  },
	  getOffsetLT: function getOffsetLT(node) {
	    var tabPosition = this.props.tabPosition;
	    var prop = 'left';
	    if (tabPosition === 'left' || tabPosition === 'right') {
	      prop = 'top';
	    }
	    return node.getBoundingClientRect()[prop];
	  },
	  setOffset: function setOffset(offset) {
	    var target = Math.min(0, offset);
	    if (this.state.offset !== target) {
	      this.setState({
	        offset: target
	      });
	    }
	  },
	  setPrev: function setPrev(v) {
	    if (this.state.prev !== v) {
	      this.setState({
	        prev: v
	      });
	    }
	  },
	  setNext: function setNext(v) {
	    if (this.state.next !== v) {
	      this.setState({
	        next: v
	      });
	    }
	  },
	  isNextPrevShown: function isNextPrevShown(state) {
	    return state.next || state.prev;
	  },
	  scrollToActiveTab: function scrollToActiveTab() {
	    var _refs = this.refs;
	    var activeTab = _refs.activeTab;
	    var navWrap = _refs.navWrap;

	    if (activeTab) {
	      var activeTabWH = this.getOffsetWH(activeTab);
	      var navWrapNodeWH = this.getOffsetWH(navWrap);
	      var offset = this.state.offset;

	      var wrapOffset = this.getOffsetLT(navWrap);
	      var activeTabOffset = this.getOffsetLT(activeTab);
	      if (wrapOffset > activeTabOffset) {
	        offset += wrapOffset - activeTabOffset;
	        this.setState({
	          offset: offset
	        });
	      } else if (wrapOffset + navWrapNodeWH < activeTabOffset + activeTabWH) {
	        offset -= activeTabOffset + activeTabWH - (wrapOffset + navWrapNodeWH);
	        this.setState({
	          offset: offset
	        });
	      }
	    }
	  },
	  prev: function prev() {
	    var navWrapNode = this.refs.navWrap;
	    var navWrapNodeWH = this.getOffsetWH(navWrapNode);
	    var state = this.state;
	    var offset = state.offset;
	    this.setOffset(offset + navWrapNodeWH);
	  },
	  next: function next() {
	    var navWrapNode = this.refs.navWrap;
	    var navWrapNodeWH = this.getOffsetWH(navWrapNode);
	    var state = this.state;
	    var offset = state.offset;
	    this.setOffset(offset - navWrapNodeWH);
	  },
	  render: function render() {
	    var props = this.props;
	    var state = this.state;
	    var prefixCls = props.prefixCls;
	    var tabs = this.getTabs();
	    var tabMovingDirection = props.tabMovingDirection;
	    var tabPosition = props.tabPosition;
	    var inkBarClass = prefixCls + '-ink-bar';
	    if (tabMovingDirection) {
	      inkBarClass += ' ' + prefixCls + '-ink-bar-transition-' + tabMovingDirection;
	    }
	    var nextButton = void 0;
	    var prevButton = void 0;

	    var showNextPrev = state.prev || state.next;

	    if (showNextPrev) {
	      var _classnames, _classnames2;

	      prevButton = _react2.default.createElement('span', {
	        onClick: state.prev ? this.prev : noop,
	        unselectable: 'unselectable',
	        className: (0, _classnames4.default)((_classnames = {}, _defineProperty(_classnames, prefixCls + '-tab-prev', 1), _defineProperty(_classnames, prefixCls + '-tab-btn-disabled', !state.prev), _classnames))
	      }, _react2.default.createElement('span', { className: prefixCls + '-tab-prev-icon' }));

	      nextButton = _react2.default.createElement('span', {
	        onClick: state.next ? this.next : noop,
	        unselectable: 'unselectable',
	        className: (0, _classnames4.default)((_classnames2 = {}, _defineProperty(_classnames2, prefixCls + '-tab-next', 1), _defineProperty(_classnames2, prefixCls + '-tab-btn-disabled', !state.next), _classnames2))
	      }, _react2.default.createElement('span', { className: prefixCls + '-tab-next-icon' }));
	    }

	    var navOffset = {};
	    if (tabPosition === 'left' || tabPosition === 'right') {
	      navOffset = {
	        top: state.offset
	      };
	    } else {
	      navOffset = {
	        left: state.offset
	      };
	    }

	    var tabBarExtraContent = this.props.tabBarExtraContent;

	    return _react2.default.createElement('div', {
	      className: prefixCls + '-bar',
	      tabIndex: '0',
	      onKeyDown: this.props.onKeyDown
	    }, tabBarExtraContent ? _react2.default.createElement('div', { style: tabBarExtraContentStyle }, tabBarExtraContent) : null, _react2.default.createElement('div', {
	      className: prefixCls + '-nav-container ' + (showNextPrev ? prefixCls + '-nav-container-scrolling' : ''),
	      style: props.style,
	      ref: 'container'
	    }, prevButton, nextButton, _react2.default.createElement('div', { className: prefixCls + '-nav-wrap', ref: 'navWrap' }, _react2.default.createElement('div', { className: prefixCls + '-nav-scroll' }, _react2.default.createElement('div', { className: prefixCls + '-nav', ref: 'nav', style: navOffset }, _react2.default.createElement('div', { className: inkBarClass, ref: 'inkBar' }), tabs)))));
	  }
	});

	exports.default = Nav;
	module.exports = exports['default'];

/***/ },
/* 684 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _utils = __webpack_require__(685);

	function _componentDidUpdate(component) {
	  var refs = component.refs;
	  var containerNode = refs.nav;
	  var containerOffset = (0, _utils.offset)(containerNode);
	  var inkBarNode = refs.inkBar;
	  var activeTab = refs.activeTab;
	  var tabPosition = component.props.tabPosition;
	  if (activeTab) {
	    var tabNode = activeTab;
	    var tabOffset = (0, _utils.offset)(tabNode);
	    if (tabPosition === 'top' || tabPosition === 'bottom') {
	      var left = tabOffset.left - containerOffset.left;
	      inkBarNode.style.left = left + 'px';
	      inkBarNode.style.top = '';
	      inkBarNode.style.bottom = '';
	      inkBarNode.style.right = containerNode.offsetWidth - left - tabNode.offsetWidth + 'px';
	    } else {
	      var top = tabOffset.top - containerOffset.top;
	      inkBarNode.style.left = '';
	      inkBarNode.style.right = '';
	      inkBarNode.style.top = top + 'px';
	      inkBarNode.style.bottom = containerNode.offsetHeight - top - tabNode.offsetHeight + 'px';
	    }
	  }
	  inkBarNode.style.display = activeTab ? 'block' : 'none';
	}

	exports.default = {
	  componentDidUpdate: function componentDidUpdate() {
	    _componentDidUpdate(this);
	  },
	  componentDidMount: function componentDidMount() {
	    _componentDidUpdate(this);
	  }
	};
		module.exports = exports['default'];

/***/ },
/* 685 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getScroll = getScroll;
	exports.offset = offset;
	function getScroll(w, top) {
	  var ret = w['page' + (top ? 'Y' : 'X') + 'Offset'];
	  var method = 'scroll' + (top ? 'Top' : 'Left');
	  if (typeof ret !== 'number') {
	    var d = w.document;
	    // ie6,7,8 standard mode
	    ret = d.documentElement[method];
	    if (typeof ret !== 'number') {
	      // quirks mode
	      ret = d.body[method];
	    }
	  }
	  return ret;
	}

	function offset(elem) {
	  var box = void 0;
	  var x = void 0;
	  var y = void 0;
	  var doc = elem.ownerDocument;
	  var body = doc.body;
	  var docElem = doc && doc.documentElement;
	  box = elem.getBoundingClientRect();
	  x = box.left;
	  y = box.top;
	  x -= docElem.clientLeft || body.clientLeft || 0;
	  y -= docElem.clientTop || body.clientTop || 0;
	  var w = doc.defaultView || doc.parentWindow;
	  x += getScroll(w);
	  y += getScroll(w, true);
	  return {
	    left: x, top: y
	  };
		}

/***/ },
/* 686 */
[770, 687],
/* 687 */
[771, 688, 689, 694],
/* 688 */
76,
/* 689 */
[772, 690, 694],
/* 690 */
[773, 691, 692],
/* 691 */
79,
/* 692 */
[774, 693, 693],
/* 693 */
81,
/* 694 */
82,
/* 695 */
33,
/* 696 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Totop Component for uxcore
	 * @author eternaslky
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

		module.exports = __webpack_require__(697);

/***/ },
/* 697 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	/**
	 * Totop Component for uxcore
	 * @author eternaslky
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	var classnames = __webpack_require__(5);
	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var Totop = function (_React$Component) {
	    _inherits(Totop, _React$Component);

	    function Totop(props) {
	        _classCallCheck(this, Totop);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.state = {
	            showTotop: false
	        };
	        return _this;
	    }

	    Totop.prototype.componentDidMount = function componentDidMount() {
	        var me = this;
	        $(window).on("scroll.totop", function (e) {
	            var y = window.pageYOffset !== undefined ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;
	            if (y > me.props.distance && !me.state.showTotop) {
	                me.setState({
	                    showTotop: true
	                });
	            } else if (y <= me.props.distance && me.state.showTotop) {
	                me.setState({
	                    showTotop: false
	                });
	            }
	        });
	    };

	    Totop.prototype.componentWillUnmount = function componentWillUnmount() {
	        var me = this;
	        clearTimeout(me.timer);
	        $(window).off("scroll.totop");
	    };

	    /*
	     * scroll method to action like jQuery animation.
	     * @param element {DOM} scroll element
	     * @param to {number} the final scrollTop you want
	     * @param duration {number} scroll animation time (ms)
	     */

	    Totop.prototype.scrollTo = function scrollTo(element, to, duration) {
	        var me = this;
	        if (duration <= 0) return;
	        var difference = to - element.scrollTop;
	        var perTick = difference / duration * 10;

	        me.timer = setTimeout(function () {
	            element.scrollTop = element.scrollTop + perTick;
	            if (element.scrollTop === to) return;
	            me.scrollTo(element, to, duration - 10);
	        }, 10);
	    };

	    Totop.prototype.handleGotopClick = function handleGotopClick() {
	        var me = this;
	        me.scrollTo(document.body.scrollTop != 0 ? document.body : document.documentElement, me.props.to, me.props.duration);
	    };

	    Totop.prototype.render = function render() {
	        var _classnames, _classnames2;

	        var me = this;
	        var showCls = me.props.prefixCls;
	        return React.createElement('div', { className: classnames((_classnames = {}, _classnames[me.props.prefixCls] = true, _classnames[me.props.className] = !!me.props.className, _classnames[me.props.theme] = !!me.props.theme, _classnames["fn-clear"] = true, _classnames)) }, React.createElement('a', { className: classnames({
	                "btn gotop": true,
	                "show": me.state.showTotop
	            }), onClick: me.handleGotopClick.bind(me) }), React.createElement('div', { className: classnames((_classnames2 = {}, _classnames2[me.props.prefixCls + "-other"] = true, _classnames2)) }, me.props.children));
	    };

	    return Totop;
	}(React.Component);

	Totop.defaultProps = {
	    prefixCls: 'kuma-totop',
	    to: 10,
	    duration: 600,
	    distance: 30
	};

	// http://facebook.github.io/react/docs/reusable-components.html
	Totop.propTypes = {
	    prefixCls: React.PropTypes.string,
	    className: React.PropTypes.string,
	    to: React.PropTypes.number,
	    distance: React.PropTypes.number,
	    duration: React.PropTypes.number,
	    theme: React.PropTypes.string
	};

	Totop.displayName = "Totop";

	module.exports = Totop;

/***/ },
/* 698 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	* @author:
	* @time:
	*/

		module.exports = __webpack_require__(699);

/***/ },
/* 699 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var classnames = __webpack_require__(5);
	var deepcopy = __webpack_require__(700);
	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var Transfer = function (_React$Component) {
	    _inherits(Transfer, _React$Component);

	    function Transfer(props) {
	        _classCallCheck(this, Transfer);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.state = {
	            chosen: props.data.filter(function (item) {
	                return !!item.chosen;
	            }),
	            unChosen: props.data.filter(function (item) {
	                return !item.chosen;
	            })
	        };
	        return _this;
	    }

	    Transfer.prototype.componentDidMount = function componentDidMount() {
	        var me = this;
	    };

	    Transfer.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	        var me = this;
	        if (!me._isEqual(nextProps.data, me.props.data)) {
	            me.setState({
	                chosen: nextProps.data.filter(function (item) {
	                    return !!item.chosen;
	                }),
	                unChosen: nextProps.data.filter(function (item) {
	                    return !item.chosen;
	                })
	            });
	        }
	    };

	    Transfer.prototype._isEqual = function _isEqual(a, b) {
	        return JSON.stringify(a) == JSON.stringify(b);
	    };

	    /**
	     * 抽取 arr1 的一部分给 arr2，返回变换后的两个数组
	     * @param {array} arr1
	     * @param {array} arr2
	     */

	    Transfer.prototype.selectItems = function selectItems(arr) {
	        var me = this;
	        var data = deepcopy(this.state);
	        data.chosen.forEach(function (item, index) {
	            if (arr.indexOf(item.value) != -1) {
	                item.selected = true;
	            }
	        });
	        data.unChosen.forEach(function (item, index) {
	            if (arr.indexOf(item.value) != -1) {
	                item.selected = true;
	            }
	        });
	        me.setState(data);
	    };

	    /**
	     * 重置，取消所有的用户操作
	     */

	    Transfer.prototype.reset = function reset() {
	        var me = this;
	        me.setState({
	            chosen: me.props.data.filter(function (item) {
	                return !!item.chosen;
	            }),
	            unChosen: me.props.data.filter(function (item) {
	                return !item.chosen;
	            })
	        });
	    };

	    Transfer.prototype.locateItem = function locateItem(value, position) {
	        var data = me.state[position];
	        var leftBlock = me.refs.leftBlock;
	        var leftBlockEl = ReactDOM.findDOMNode(leftBlock);
	        var rightBlock = me.refs.rightBlock;
	        var rightBlockEl = ReactDOM.findDOMNode(rightBlock);
	        var index = void 0;
	        for (var i = 0; i < data.length; i++) {
	            if (data[i].name.indexOf(value) !== -1) {
	                index = i;
	                break;
	            }
	            if (data[i].keywords instanceof Array) {
	                var keywords = data[i].keywords;
	                for (var j = 0; j < keywords.length; j++) {
	                    if (keywords[j].indexOf(value) !== -1) {
	                        index = i;
	                        break;
	                    }
	                }
	                if (index != undefined) break;
	            }
	        }
	        if (index != undefined) {
	            if (position == 'unChosen') {
	                leftBlockEl.scrollTop = 30 * index;
	            } else {
	                rightBlock.scrollTop = 30 * index;
	            }
	        }
	    };

	    Transfer.prototype._handleSearchIconClick = function _handleSearchIconClick(position) {
	        var me = this;
	        var leftSearch = me.refs.leftSearch;
	        var rightSearch = me.refs.rightSearch;
	        var value = '';
	        if (position == "unChosen") {
	            value = leftSearch.value;
	        } else {
	            value = rightSearch.value;
	        }
	        me.locateItem(value, position);
	    };

	    Transfer.prototype._handleSearch = function _handleSearch(position, e) {
	        var me = this;
	        var leftSearch = me.refs.leftSearch;
	        var rightSearch = me.refs.rightSearch;
	        var value = '';
	        if (e.keyCode == 13) {
	            if (position == "unChosen") {
	                value = leftSearch.value;
	            } else {
	                value = rightSearch.value;
	            }
	            me.locateItem(value, position);
	        }
	    };

	    Transfer.prototype._changeChosenData = function _changeChosenData(arr1, arr2) {
	        var newArr1 = arr1.filter(function (item) {
	            return !item.selected;
	        });
	        var newArr2 = arr1.filter(function (item) {
	            return item.selected;
	        }).map(function (item, index) {
	            item.chosen = !item.chosen;
	            item.selected = false;
	            item.justMoved = true;
	            return item;
	        }).concat(arr2);

	        return {
	            arr1: newArr1,
	            arr2: newArr2
	        };
	    };

	    Transfer.prototype._handleItemClick = function _handleItemClick(e) {
	        var me = this;
	        if (me.props.disabled) return;
	        var target = e.currentTarget;
	        me._removeJustMoved(function (target) {
	            var key = target.getAttribute('data-key');
	            var isChosen = JSON.parse(target.getAttribute('data-chosen'));
	            var newData = deepcopy(me.state[isChosen ? 'chosen' : 'unChosen']);
	            newData[key].selected = !newData[key].selected;
	            var newState = {};
	            newState[isChosen ? 'chosen' : 'unChosen'] = newData;
	            me.setState(newState);
	        }.bind(me, target));
	    };

	    Transfer.prototype._removeJustMoved = function _removeJustMoved(cb) {
	        var data = deepcopy(this.state);
	        data.chosen.forEach(function (item, index) {
	            item.justMoved = false;
	        });
	        data.unChosen.forEach(function (item, index) {
	            item.justMoved = false;
	        });
	        me.setState(data, function () {
	            !!cb && cb();
	        });
	    };

	    Transfer.prototype._handleButtonClick = function _handleButtonClick(e) {
	        var me = this;
	        if (me.props.disabled) return;
	        var target = e.currentTarget;
	        var direction = target.getAttribute('data-direction');
	        if (target.className.indexOf('enable') == -1) return;
	        var oldChosen = deepcopy(me.state['chosen']);
	        var oldUnChosen = deepcopy(me.state['unChosen']);
	        var newChosen = [];
	        var newUnChosen = [];
	        var newData = {};
	        if (direction == 'left') {
	            newData = me._changeChosenData(oldChosen, oldUnChosen);
	            newChosen = newData.arr1;
	            newUnChosen = newData.arr2;
	        } else {
	            newData = me._changeChosenData(oldUnChosen, oldChosen);
	            newUnChosen = newData.arr1;
	            newChosen = newData.arr2;
	        }

	        me.setState({
	            chosen: newChosen,
	            unChosen: newUnChosen
	        }, function () {
	            me.props.onChange(me.state);
	        });
	    };

	    Transfer.prototype._renderItem = function _renderItem(item, index) {
	        var me = this;
	        window.me = me;
	        return React.createElement('li', { key: index, 'data-key': index, 'data-value': item.value, 'data-chosen': item.chosen, onClick: me._handleItemClick.bind(me) }, React.createElement('a', { className: classnames({
	                "selected": !!item.selected,
	                "justMoved": !!item.justMoved
	            }), href: 'javascript:;', title: item.description }, item.name));
	    };

	    Transfer.prototype._renderUnchosen = function _renderUnchosen() {
	        var me = this;
	        var arr = me.state.unChosen.filter(function (item) {
	            return !item.chosen;
	        }).map(me._renderItem.bind(me));
	        return arr;
	    };

	    Transfer.prototype._renderChosen = function _renderChosen() {
	        var me = this;
	        var arr = me.state.chosen.filter(function (item) {
	            return item.chosen;
	        }).map(me._renderItem.bind(me));
	        return arr;
	    };

	    Transfer.prototype._renderSearch = function _renderSearch(position) {
	        var me = this;
	        if (!me.props.showSearch) return;
	        var map = {
	            "unChosen": "leftSearch",
	            "chosen": "rightSearch"
	        };
	        return React.createElement('div', { className: 'searchBar' }, React.createElement('input', { type: 'text', ref: map[position], className: 'kuma-input', placeholder: me.props.searchPlaceholder, onKeyDown: me._handleSearch.bind(me, position) }), React.createElement('i', { className: 'kuma-icon kuma-icon-search', onClick: me._handleSearchIconClick.bind(me, position) }));
	    };

	    Transfer.prototype.render = function render() {
	        var me = this;
	        return React.createElement('div', { className: classnames({
	                "uxTransfer": true,
	                "disabled": me.props.disabled
	            }) }, React.createElement('table', { className: 'kuma-uxtransfer-container' }, React.createElement('thead', { className: 'kuma-uxtransfer-head' }, React.createElement('tr', null, React.createElement('th', { className: 'fn-clear left-head' }, React.createElement('span', { className: 'title' }, me.props.leftTitle), me._renderSearch("unChosen")), React.createElement('th', null, ' '), React.createElement('th', { className: 'fn-clear right-head' }, React.createElement('span', { className: 'title' }, me.props.rightTitle), me._renderSearch("chosen")))), React.createElement('tbody', null, React.createElement('tr', null, React.createElement('td', { className: 'left-block' }, React.createElement('ul', { ref: 'leftBlock', className: classnames({
	                "kuma-uxtransfer-block": true
	            }) }, me._renderUnchosen())), React.createElement('td', { className: 'kuma-uxtransfer-buttons' }, React.createElement('a', { href: 'javascript:;', 'data-direction': 'left', className: classnames({
	                enable: me.state.chosen.some(function (item) {
	                    return !!item.selected;
	                }) && !me.props.disabled
	            }), onClick: me._handleButtonClick.bind(me) }), React.createElement('br', null), React.createElement('a', { href: 'javascript:;', 'data-direction': 'right', className: classnames({
	                enable: me.state.unChosen.some(function (item) {
	                    return !!item.selected;
	                }) && !me.props.disabled
	            }), onClick: me._handleButtonClick.bind(me) })), React.createElement('td', { className: 'right-block' }, React.createElement('ul', { ref: 'rightBlock', className: classnames({
	                "kuma-uxtransfer-block": true
	            }) }, me._renderChosen()))))));
	    };

	    return Transfer;
	}(React.Component);

	Transfer.displayName = "Transfer";
	Transfer.defaultProps = {
	    searchPlaceholder: '定位输入内容',
	    data: [],
	    leftTitle: '未选中',
	    rightTitle: '已选中',
	    disabled: false,
	    showSearch: true,
	    onChange: function onChange() {}
	};
	Transfer.propTypes = {
	    searchPlaceholder: React.PropTypes.string,
	    data: React.PropTypes.array,
	    disabled: React.PropTypes.bool,
	    showSearch: React.PropTypes.bool,
	    leftTitle: React.PropTypes.string,
	    rightTitle: React.PropTypes.string,
	    onChange: React.PropTypes.func
	};

		module.exports = Transfer;

/***/ },
/* 700 */
341,
/* 701 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(702);

/***/ },
/* 702 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var _require = __webpack_require__(703);

	var UploadCore = _require.UploadCore;
	var Events = _require.Events;
	var Status = _require.Status;

	var Progress = __webpack_require__(705);
	var util = __webpack_require__(706);
	var FileList = __webpack_require__(707);
	var Picker = __webpack_require__(711);
	var i18n = __webpack_require__(710);

	UploadCore.setSWF('https://alinw.alicdn.com/alinw/uxuploader/2.0.1/flashpicker.swf');

	var CORE_INSTANCE = {};
	function getCoreInstance(props, autoPending) {
	    var core = props.core;
	    if (core instanceof UploadCore) {
	        return core;
	    }

	    var id = core;
	    if (id && typeof id === 'string' && CORE_INSTANCE.hasOwnProperty(id)) {
	        return CORE_INSTANCE[id];
	    }

	    var options = props.options || {};
	    ['name', 'url', 'params', 'action', 'data', 'headers', 'withCredentials', 'timeout', 'chunkEnable', 'chunkSize', 'chunkRetries', 'chunkProcessThreads', 'processThreads', 'queueCapcity', 'autoPending', 'multiple', 'accept', 'sizeLimit', 'preventDuplicate'].forEach(function (key) {
	        if (props.hasOwnProperty(key)) {
	            options[key] = props[key];
	        }
	    });
	    if (autoPending != null) {
	        options.autoPending = autoPending;
	    }

	    core = new UploadCore(options);

	    for (var key in props) {
	        if (props.hasOwnProperty(key)) {
	            var m = /^on(\w+)$/i.exec(key);
	            if (!m) continue;
	            if (typeof props[key] === 'function') {
	                core.on(m[1], props[key]);
	            }
	        }
	    }

	    if (id) {
	        CORE_INSTANCE[id] = core;
	    }

	    return core;
	}

	var Uploader = function (_React$Component) {
	    _inherits(Uploader, _React$Component);

	    function Uploader(props) {
	        _classCallCheck(this, Uploader);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.core = getCoreInstance(_this.props, true);

	        _this.state = {
	            total: _this.core.getTotal()
	        };

	        var statchange = function statchange(stat) {
	            var total = stat.getTotal();
	            if (total !== _this.state.total) {
	                _this.setState({ total: total });
	            }
	        };
	        _this.core.on(Events.QUEUE_STAT_CHANGE, statchange);
	        _this.stopListen = function () {
	            _this.core.off(Events.QUEUE_STAT_CHANGE, statchange);
	        };
	        return _this;
	    }

	    Uploader.prototype.componentWillUnmount = function componentWillUnmount() {
	        this.stopListen && this.stopListen();
	    };

	    Uploader.prototype.reset = function reset() {
	        this.core.getFiles().forEach(function (file) {
	            file.cancel();
	        });
	    };

	    Uploader.prototype.render = function render() {
	        var me = this;
	        var _props = this.props;
	        var children = _props.children;
	        var locale = _props.locale;

	        if (!children || children.length < 1) {
	            children = React.createElement('button', { className: 'kuma-upload-button' }, React.createElement('i', { className: 'kuma-icon kuma-icon-uploading' }), i18n[locale]['upload_files']);
	        }
	        return React.createElement('div', { className: "kuma-uploader " + (this.props.className || '') }, React.createElement(Picker, { core: this.core }, children), this.props.tips, this.state.total > 0 ? React.createElement(FileList, { locale: this.props.locale, core: this.core, mode: 'nw' }) : null);
	    };

	    return Uploader;
	}(React.Component);

	var Dropzoom = function (_React$Component2) {
	    _inherits(Dropzoom, _React$Component2);

	    function Dropzoom(props) {
	        _classCallCheck(this, Dropzoom);

	        var _this2 = _possibleConstructorReturn(this, _React$Component2.call(this, props));

	        _this2.core = getCoreInstance(_this2.props);

	        _this2.state = {
	            blink: 0,
	            highlight: 0,
	            total: _this2.core.getTotal()
	        };

	        var statchange = function statchange(stat) {
	            var total = stat.getTotal();
	            if (total !== _this2.state.total) {
	                _this2.setState({ total: total });
	            }
	        };
	        _this2.core.on(Events.QUEUE_STAT_CHANGE, statchange);
	        _this2.stopListen = function () {
	            _this2.core.off(Events.QUEUE_STAT_CHANGE, statchange);
	        };
	        return _this2;
	    }

	    Dropzoom.prototype.reset = function reset() {
	        this.core.getFiles().forEach(function (file) {
	            file.cancel();
	        });
	    };

	    Dropzoom.prototype.componentDidMount = function componentDidMount() {
	        var _this3 = this;

	        var areaNode = ReactDOM.findDOMNode(this);

	        var dndArea = this.core.getDndCollector().addArea(areaNode);
	        dndArea.on('start', function () {
	            _this3.setState({ blink: 1 });
	        }).on('response', function (e) {
	            if (areaNode.contains(e.target)) {
	                _this3.setState({ highlight: 1 });
	            } else {
	                _this3.setState({ highlight: 0 });
	            }
	        }).on('end', function () {
	            _this3.setState({ blink: 0, highlight: 0 });
	        });
	        this.dndArea = dndArea;
	    };

	    Dropzoom.prototype.componentWillUnmount = function componentWillUnmount() {
	        this.dndArea && this.dndArea.destroy();
	        this.stopListen && this.stopListen();
	    };

	    Dropzoom.prototype.render = function render() {
	        var className = "kuma-uploader kuma-upload-dropzoom";
	        if (this.props.className) {
	            className += ' ' + this.props.className;
	        }
	        if (this.state.blink) {
	            className += ' blink';
	        }
	        if (this.state.highlight) {
	            className += ' enter';
	        }
	        var children = this.props.children;
	        if (!children || children.length < 1) {
	            children = React.createElement('i', { className: 'kuma-icon kuma-icon-add' });
	        }
	        return React.createElement('div', { className: className }, this.state.total > 0 ? React.createElement(FileList, { locale: this.props.locale, core: this.core, mode: 'icon' }) : React.createElement(Picker, { core: this.core }, children), React.createElement('div', { className: 'kuma-upload-responser' }));
	    };

	    return Dropzoom;
	}(React.Component);

	Uploader.Dropzoom = Dropzoom;

	Uploader.Events = Events;
	Uploader.Status = Status;
	Uploader.setSWF = function (swf) {
	    UploadCore.setSWF(swf);
	};

	Uploader.displayName = "Uploader";

	Uploader.defaultProps = {
	    locale: 'zh-cn'
	};

	Uploader.propTypes = {
	    locale: React.PropTypes.string
	};

		module.exports = Uploader;

/***/ },
/* 703 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	!function (e, t) {
	  "object" == ( false ? "undefined" : _typeof(exports)) && "object" == ( false ? "undefined" : _typeof(module)) ? module.exports = t() :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (t), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) ? exports.UploadCore = t() : e.UploadCore = t();
	}(undefined, function () {
	  return function (e) {
	    function t(r) {
	      if (n[r]) return n[r].exports;var i = n[r] = { exports: {}, id: r, loaded: !1 };return e[r].call(i.exports, i, i.exports, t), i.loaded = !0, i.exports;
	    }var n = {};return t.m = e, t.c = n, t.p = "", t(0);
	  }([function (e, t, n) {
	    "use strict";
	    var r = n(1),
	        i = n(4),
	        o = n(5),
	        s = o.Status;r.Events = i, r.Status = s, r.UploadCore = r, r.VERSION = "2.2.3", r.Core = r, e.exports = r;
	  }, function (e, t, n) {
	    "use strict";
	    function r(e, t) {
	      if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
	    }function i(e, t) {
	      if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t || "object" != (typeof t === "undefined" ? "undefined" : _typeof(t)) && "function" != typeof t ? e : t;
	    }function o(e, t) {
	      if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + (typeof t === "undefined" ? "undefined" : _typeof(t)));e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
	    }var s = function () {
	      function e(e, t) {
	        for (var n = 0; n < t.length; n++) {
	          var r = t[n];r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
	        }
	      }return function (t, n, r) {
	        return n && e(t.prototype, n), r && e(t, r), t;
	      };
	    }(),
	        u = n(2),
	        a = n(4),
	        c = n(5),
	        l = c.Status,
	        f = n(6),
	        h = f.QueueLimitError,
	        p = f.FilterError,
	        v = f.DuplicateError,
	        d = f.FileExtensionError,
	        y = f.FileSizeError,
	        m = n(3),
	        g = m.formatSize,
	        k = m.parseSize,
	        b = m.normalizeAccept,
	        E = n(7),
	        w = n(8),
	        _ = n(13),
	        P = n(14),
	        O = ["name", "url", "params", "action", "data", "headers", "withCredentials", "timeout", "chunkEnable", "chunkSize", "chunkRetries", "chunkProcessThreads"],
	        R = function (e) {
	      function t() {
	        var e = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0];r(this, t);var n = i(this, Object.getPrototypeOf(t).call(this));n.autoPending = e.autoPending || e.auto, n.capcity = e.capcity || e.queueCapcity || 0, n.multiple = null == e.multiple ? !0 : e.multiple, n.accept = b(e.accept), n.sizeLimit = k(e.sizeLimit || e.fileSizeLimit || 0), n.pending = new A(e.processThreads), n.stat = new L(), n.constraints = new S(), n.filters = new T(), n.multiple || (n.capcity = 1), n.capcity > 0 && n.addConstraint(function () {
	          return n.stat.getTotal() >= n.capcity;
	        }), n.accept && n.accept.length > 0 && n.addFilter(function (e) {
	          return n.accept.some(function (t) {
	            return t.extensions && t.extensions.indexOf(e.ext) > -1;
	          }) ? void 0 : new d(e, 'extension "' + e.ext + '" is not allowed');
	        }), n.sizeLimit > 0 && n.addFilter(function (e) {
	          return e.size > n.sizeLimit ? new y(e, "filesize:" + g(e.size) + " is greater than limit:" + g(n.sizeLimit)) : void 0;
	        }), e.preventDuplicate && n.addFilter(function (e) {
	          return n.stat.getFiles().some(function (t) {
	            return t.name === e.name && t.size === e.size;
	          }) ? new v(e, 'file "' + e.name + '" already in queue') : void 0;
	        }), Array.isArray(e.filters) && e.fitlers.forEach(function (e) {
	          return n.addFilter(e);
	        });var o = e.request || {};return O.forEach(function (t) {
	          e.hasOwnProperty(t) && (o[t] = e[t]);
	        }), n.requestOptions = o, n;
	      }return o(t, e), s(t, [{ key: "createFileRequest", value: function value(e) {
	          return new E(e, this.requestOptions);
	        } }, { key: "isLimit", value: function value() {
	          return this.constraints.some();
	        } }, { key: "addConstraint", value: function value(e) {
	          return this.constraints.add(e);
	        } }, { key: "addFilter", value: function value(e) {
	          return this.filters.add(e);
	        } }, { key: "add", value: function value(e) {
	          var t = this;if (this.isLimit()) return this.emit(a.QUEUE_ERROR, new h()), -1;var n = this.filters.filter(e);return n || this.stat.add(e) || (n = new v(e, 'file "' + e.name + '" already in queue')), n ? (this.emit(a.QUEUE_FILE_FILTERED, e, n), this.emit(a.QUEUE_ERROR, n), 0) : (e.setStatus(l.QUEUED), e.on(a.FILE_STATUS_CHANGE, function (n) {
	            n === l.CANCELLED ? t.stat.remove(e) : n === l.PENDING && setTimeout(function () {
	              t.pending.add(e) && 1 === t.pending.size() && t.emit(a.QUEUE_UPLOAD_START);
	            }, 1), t.emit(a.QUEUE_STAT_CHANGE, t.stat), t.stat.getFiles(l.PROCESS).length < 1 && t.emit(a.QUEUE_UPLOAD_END);
	          }), e.setCore(this), this.emit(a.QUEUE_FILE_ADDED, e), this.emit(a.QUEUE_STAT_CHANGE, this.stat), this.autoPending && e.pending(), 1);
	        } }, { key: "isMultiple", value: function value() {
	          return this.multiple;
	        } }, { key: "isFull", value: function value() {
	          return this.capcity > 0 && this.getTotal() >= this.capcity;
	        } }, { key: "isEmpty", value: function value() {
	          return this.getTotal() < 1;
	        } }, { key: "getAccept", value: function value() {
	          return this.accept;
	        } }, { key: "getStat", value: function value() {
	          return this.stat;
	        } }, { key: "getTotal", value: function value() {
	          return this.getStat().getTotal();
	        } }, { key: "getFiles", value: function value(e) {
	          return this.getStat().getFiles(e);
	        } }, { key: "stat", value: function value(e) {
	          return this.getStat().stat(e);
	        } }, { key: "getPickerCollector", value: function value() {
	          return this.picker || (this.picker = new P(this)), this.picker;
	        } }, { key: "getDndCollector", value: function value() {
	          return this.dnd || (this.dnd = new w(this)), this.dnd;
	        } }, { key: "getPasteCollector", value: function value() {
	          return this.paster || (this.paster = new _(this)), this.paster;
	        } }], [{ key: "setSWF", value: function value(e) {
	          P.setSWF(e);
	        } }]), t;
	    }(u);e.exports = R;var C = function () {
	      function e() {
	        r(this, e), this._set = [];
	      }return s(e, [{ key: "size", value: function value() {
	          return this._set.length;
	        } }, { key: "shift", value: function value() {
	          return this._set.shift();
	        } }, { key: "pop", value: function value() {
	          return this._set.pop();
	        } }, { key: "toArray", value: function value() {
	          return this._set.slice(0);
	        } }, { key: "add", value: function value(e) {
	          return this.has(e) ? !1 : (this._set.push(e), !0);
	        } }, { key: "has", value: function value(e) {
	          return this._set.indexOf(e) > -1;
	        } }, { key: "remove", value: function value(e) {
	          var t = this._set.indexOf(e);return t > -1 ? (this._set.splice(t, 1), !0) : !1;
	        } }, { key: "clear", value: function value() {
	          this._set = [];
	        } }]), e;
	    }(),
	        L = function () {
	      function e() {
	        r(this, e), this.files = new C();
	      }return s(e, [{ key: "add", value: function value(e) {
	          return this.files.add(e);
	        } }, { key: "remove", value: function value(e) {
	          this.files.remove(e);
	        } }, { key: "getTotal", value: function value() {
	          return this.files.size();
	        } }, { key: "getFiles", value: function value(e) {
	          var t = this.files.toArray();return e ? t.filter(function (t) {
	            return !!(t.getStatus() & e);
	          }) : t;
	        } }, { key: "stat", value: function value(e) {
	          var t = {},
	              n = this.getFiles(e);return n.forEach(function (e) {
	            var n = e.getStatus();t[n] = n in t ? t[n] + 1 : 1;
	          }), t.sum = n.length, t;
	        } }]), e;
	    }(),
	        S = function () {
	      function e() {
	        r(this, e), this.constraints = new C();
	      }return s(e, [{ key: "add", value: function value(e) {
	          return this.constraints.add(e), this;
	        } }, { key: "remove", value: function value(e) {
	          return this.constraints.remove(e), this;
	        } }, { key: "some", value: function value() {
	          var e = this;return this.constraints.toArray().some(function (t) {
	            return t.call(e);
	          });
	        } }]), e;
	    }(),
	        T = function () {
	      function e() {
	        r(this, e), this.filters = new C();
	      }return s(e, [{ key: "add", value: function value(e) {
	          return this.filters.add(e), this;
	        } }, { key: "remove", value: function value(e) {
	          return this.filters.remove(e), this;
	        } }, { key: "filter", value: function value(e) {
	          var t = null;return this.filters.toArray().every(function (n) {
	            var r = void 0;try {
	              r = n(e);
	            } catch (i) {
	              r = i;
	            }return "string" == typeof r ? (t = new p(e, r), !1) : r instanceof Error ? (t = r instanceof p ? r : new p(e, r.toString()), !1) : !0;
	          }), t;
	        } }]), e;
	    }(),
	        A = function () {
	      function e(t) {
	        r(this, e), this.threads = t || 2, this.heading = new C(), this.pending = new C();
	      }return s(e, [{ key: "add", value: function value(e) {
	          var t = this;return this.pending.add(e) ? (e.session().always(function () {
	            return t.pending.remove(e);
	          }), this.load(), !0) : !1;
	        } }, { key: "size", value: function value() {
	          return this.pending.size() + this.heading.size();
	        } }, { key: "process", value: function value(e) {
	          var t = this;this.heading.add(e) && e.session().always(function () {
	            t.heading.remove(e), t.load();
	          });
	        } }, { key: "load", value: function value() {
	          for (var e; this.heading.size() < this.threads && (e = this.pending.shift());) {
	            e.prepare() && this.process(e);
	          }
	        } }]), e;
	    }();
	  }, function (e, t, n) {
	    "use strict";
	    function r(e, t) {
	      if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
	    }function i(e, t, n) {
	      var r = t,
	          i = null,
	          o = void 0,
	          s = u(),
	          a = s.promise();a.abort = function () {
	        o = !0;
	      };var c = function c(e) {
	        o || (e && (i = e instanceof Error ? e : new Error(e)), s.reject(i || new Error("Unknown")));
	      },
	          l = function l() {
	        o || (null != i ? c() : s.resolve(r));
	      },
	          f = function f(e) {
	        null == e || null != r && e.constructor !== r.constructor || (r = e);
	      },
	          h = function p(t) {
	        if (!o) {
	          if (t instanceof Error && (i = t), null != i) return c();f(t);var s = e.shift();if (!s) return l();var u = void 0;try {
	            u = s.call(n, r);
	          } catch (a) {
	            return c(a);
	          }u && u.then ? u.then(p, c) : p(u);
	        }
	      };return setTimeout(h, 1), a;
	    }var o = function () {
	      function e(e, t) {
	        for (var n = 0; n < t.length; n++) {
	          var r = t[n];r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
	        }
	      }return function (t, n, r) {
	        return n && e(t.prototype, n), r && e(t, r), t;
	      };
	    }(),
	        s = n(3),
	        u = s.Deferred,
	        a = function () {
	      function e() {
	        r(this, e);
	      }return o(e, [{ key: "on", value: function value(e, t) {
	          return e = e.toLowerCase(), this._events || (this._events = {}), this._events[e] || (this._events[e] = []), this._events[e].push(t), this;
	        } }, { key: "once", value: function value(e, t) {
	          function n() {
	            r.off(e, n), t.apply(this, arguments);
	          }e = e.toLowerCase();var r = this;return n.listener = t, this.on(e, n), this;
	        } }, { key: "off", value: function value(e, t) {
	          e = e.toLowerCase();var n = void 0;if (!this._events || !(n = this._events[e])) return this;for (var r = n.length; r-- > 0;) {
	            if (n[r] === t || n[r].listener === t) {
	              n.splice(r, 1);break;
	            }
	          }return 0 === n.length && delete this._events[e], this;
	        } }, { key: "removeAllListeners", value: function value(e) {
	          return e ? delete this._events[e.toLowerCase()] : this._events = [], this;
	        } }, { key: "setPropagationTarget", value: function value(t) {
	          t instanceof e && (this.propagationTarget = t);
	        } }, { key: "emit", value: function value(e) {
	          for (var t = arguments.length, n = Array(t > 1 ? t - 1 : 0), r = 1; t > r; r++) {
	            n[r - 1] = arguments[r];
	          }this.applyEmit(e, n);
	        } }, { key: "applyEmit", value: function value(e, t) {
	          var n = this;e = e.toLowerCase();var r = void 0;if (this._events && (r = this._events[e]) && r.slice(0).forEach(function (e) {
	            return e.apply(n, t);
	          }), this.propagationTarget) {
	            var i = t.slice(0);i.unshift(this), this.propagationTarget.applyEmit(e, i);
	          }return this;
	        } }, { key: "invoke", value: function value(e, t) {
	          e = e.toLowerCase();var n = void 0;return this._events && (n = this._events[e]) || (n = []), i(n.slice(0), t, this);
	        } }]), e;
	    }();e.exports = a;
	  }, function (e, t) {
	    "use strict";
	    function n(e) {
	      return "string" != typeof e ? "" : e.toLowerCase().split(/ *[ ,;|+] */).map(function (e) {
	        var t = /^\*?\.?(\w+)$/.exec(e);return t ? t[1] : null;
	      }).filter(function (e) {
	        return null !== e;
	      });
	    }function r(e) {
	      return e ? (Array.isArray(e) || (e = [e]), e.map(function (e) {
	        if ("string" == typeof e && (e = e.toLowerCase()) && c.hasOwnProperty(e)) return c[e];var t = n(e.extensions || e);return t.length ? { title: e.title || "", extensions: t, mimeTypes: e.mimeTypes || "" } : null;
	      }).filter(function (e) {
	        return null !== e;
	      })) : null;
	    }function i(e) {
	      var t = {};return (e.match(/\S+/g) || []).forEach(function (e) {
	        t[e] = !0;
	      }), t;
	    }function o(e, t) {
	      for (var n in t) {
	        e[n] = t[n];
	      }return e;
	    }function s(e) {
	      return "function" == typeof e;
	    }function u(e) {
	      e = "string" == typeof e ? i(e) : o({}, e);var t = void 0,
	          n = void 0,
	          r = void 0,
	          u = void 0,
	          a = void 0,
	          c = void 0,
	          f = [],
	          h = void 0,
	          p = !e.once && [],
	          v = function d(i) {
	        for (n = e.memory && i, r = !0, a = c || 0, c = 0, u = f.length, t = !0; f && u > a; a++) {
	          if (f[a].apply(i[0], i[1]) === !1 && e.stopOnFalse) {
	            n = !1;break;
	          }
	        }t = !1, f && (p ? p.length && d(p.shift()) : n ? f = [] : h.disable());
	      };return h = { add: function add() {
	          if (f) {
	            var r = f.length;!function i(t) {
	              t.forEach(function (t) {
	                s(t) ? e.unique && h.has(t) || f.push(t) : Array.isArray(t) && i(t);
	              });
	            }(l(arguments)), t ? u = f.length : n && (c = r, v(n));
	          }return this;
	        }, remove: function remove() {
	          return f && l(arguments).forEach(function (e) {
	            for (var n = f.length; --n >= 0;) {
	              f[n] === e && (f.splice(n, 1), t && (u >= n && u--, a >= n && a--));
	            }
	          }), this;
	        }, has: function has(e) {
	          return e ? f.indexOf(e) > -1 : !(!f || !f.length);
	        }, empty: function empty() {
	          return f = [], u = 0, this;
	        }, disable: function disable() {
	          return f = p = n = null, this;
	        }, disabled: function disabled() {
	          return !f;
	        }, lock: function lock() {
	          return p = null, n || h.disable(), this;
	        }, locked: function locked() {
	          return !p;
	        }, fireWith: function fireWith(e, n) {
	          return !f || r && !p || (n = n || [], n = [e, n.slice ? n.slice() : n], t ? p.push(n) : v(n)), this;
	        }, fire: function fire() {
	          return h.fireWith(this, arguments), this;
	        }, fired: function fired() {
	          return !!r;
	        } };
	    }function a(e) {
	      var t = [["resolve", "done", u("once memory"), "resolved"], ["reject", "fail", u("once memory"), "rejected"], ["notify", "progress", u("memory")]],
	          n = "pending",
	          r = { state: function state() {
	          return n;
	        }, always: function always() {
	          var e = l(arguments);return i.done(e).fail(e), this;
	        }, then: function then() {
	          var e = arguments;return a(function (n) {
	            t.forEach(function (t, o) {
	              var u = s(e[o]) && e[o];i[t[1]](function () {
	                var e = u && u.apply(this, arguments);e && s(e.promise) ? e.promise().done(n.resolve).fail(n.reject).progress(n.notify) : n[t[0] + "With"](this === r ? n.promise() : this, u ? [e] : arguments);
	              });
	            }), e = null;
	          }).promise();
	        }, promise: function promise(e) {
	          return null != e ? o(e, r) : r;
	        } },
	          i = {};return r.pipe = r.then, t.forEach(function (e, o) {
	        var s = e[2],
	            u = e[3];r[e[1]] = s.add, u && s.add(function () {
	          n = u;
	        }, t[1 ^ o][2].disable, t[2][2].lock), i[e[0]] = function () {
	          return i[e[0] + "With"](this === i ? r : this, arguments), this;
	        }, i[e[0] + "With"] = s.fireWith;
	      }), r.promise(i), e && e.call(i, i), i;
	    }t.formatSize = function (e) {
	      e = parseFloat(e);var t = ["", "K", "M", "G", "T", "P", "E", "Z", "Y"],
	          n = 1024,
	          r = e ? Math.floor(Math.log(e) / Math.log(n)) : 0;r = Math.min(r, t.length - 1);var i = Math.pow(10, 2 > r ? 0 : r > 2 ? 2 : 1);return e /= Math.pow(n, r), e = Math.round(e * i) / i, e + t[r] + "B";
	    }, t.parseSize = function (e) {
	      if ("string" != typeof e) return e;var t = { t: 1099511627776, g: 1073741824, m: 1048576, k: 1024 };e = /^([0-9\.]+)([tgmk]?)b?$/i.exec(e);var n = e[2];return e = +e[1], t.hasOwnProperty(n) && (e *= t[n]), e;
	    };var c = { images: { title: "Images", extensions: ["jpg", "jpeg", "gif", "png", "bmp", "svg", "tiff", "tif", "ico", "jpe", "svgz", "pct", "psp", "ai", "psd", "raw", "webp"] }, audios: { title: "Audios", extensions: ["aac", "aif", "flac", "iff", "m4a", "m4b", "mid", "midi", "mp3", "mpa", "mpc", "oga", "ogg", "ra", "ram", "snd", "wav", "wma"] }, videos: { title: "Videos", extensions: ["avi", "divx", "flv", "m4v", "mkv", "mov", "mp4", "mpeg", "mpg", "ogm", "ogv", "ogx", "rm", "rmvb", "smil", "webm", "wmv", "xvid"] } };t.normalizeAccept = r, t.extend = o;var l = Array.from || function (e) {
	      return [].slice.call(e);
	    };t.Deferred = a;
	  }, function (e, t) {
	    "use strict";
	    e.exports = { QUEUE_UPLOAD_START: "queueuploadstart", QUEUE_UPLOAD_END: "queueuploadend", QUEUE_FILE_ADDED: "queuefileadded", QUEUE_FILE_FILTERED: "queuefilefiltered", QUEUE_ERROR: "queueerror", QUEUE_STAT_CHANGE: "statchange", FILE_UPLOAD_START: "fileuploadstart", FILE_UPLOAD_PREPARING: "fileuploadpreparing", FILE_UPLOAD_PREPARED: "fileuploadprepared", CHUNK_UPLOAD_PREPARING: "chunkuploadpreparing", CHUNK_UPLOAD_COMPLETING: "chunkuploadcompleting", FILE_UPLOAD_PROGRESS: "fileuploadprogress", FILE_UPLOAD_END: "fileuploadend", FILE_UPLOAD_COMPLETING: "fileuploadcompleting", FILE_UPLOAD_SUCCESS: "fileuploadsuccess", FILE_UPLOAD_ERROR: "fileuploaderror", FILE_UPLOAD_COMPLETED: "fileuploadcompleted", FILE_CANCEL: "filecancel", FILE_STATUS_CHANGE: "filestatuschange" };
	  }, function (e, t) {
	    "use strict";
	    t.Status = { ALL: 255, PROCESS: 31, INITED: 1, QUEUED: 2, PENDING: 4, PROGRESS: 8, END: 16, SUCCESS: 32, ERROR: 64, CANCELLED: 128 }, t.StatusName = { 1: "inited", 2: "queued", 4: "pending", 8: "progress", 16: "end", 32: "success", 64: "error", 128: "cancelled" };
	  }, function (e, t) {
	    "use strict";
	    function n(e, t) {
	      if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
	    }function r(e, t) {
	      if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t || "object" != (typeof t === "undefined" ? "undefined" : _typeof(t)) && "function" != typeof t ? e : t;
	    }function i(e, t) {
	      if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + (typeof t === "undefined" ? "undefined" : _typeof(t)));e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
	    }var o = function (e) {
	      function t(e) {
	        n(this, t);var i = r(this, Object.getPrototypeOf(t).call(this, e));return i.message = e, i;
	      }return i(t, e), t;
	    }(Error),
	        s = function (e) {
	      function t(e) {
	        n(this, t);var i = r(this, Object.getPrototypeOf(t).call(this, e));return i.name = "AbortError", i;
	      }return i(t, e), t;
	    }(o),
	        u = function (e) {
	      function t(e) {
	        n(this, t);var i = r(this, Object.getPrototypeOf(t).call(this, e));return i.name = "TimeoutError", i;
	      }return i(t, e), t;
	    }(o),
	        a = function (e) {
	      function t(e, i) {
	        n(this, t);var o = r(this, Object.getPrototypeOf(t).call(this, i));return o.name = "NetworkError", o.status = e, o;
	      }return i(t, e), t;
	    }(o),
	        c = function (e) {
	      function t() {
	        n(this, t);var e = r(this, Object.getPrototypeOf(t).call(this, "queue limit"));return e.name = "QueueLimitError", e;
	      }return i(t, e), t;
	    }(o),
	        l = function (e) {
	      function t(e, i) {
	        n(this, t);var o = r(this, Object.getPrototypeOf(t).call(this, i));return o.name = "FilterError", o.file = e, o;
	      }return i(t, e), t;
	    }(o),
	        f = function (e) {
	      function t(e, i) {
	        n(this, t);var o = r(this, Object.getPrototypeOf(t).call(this, e, i));return o.name = "DuplicateError", o;
	      }return i(t, e), t;
	    }(l),
	        h = function (e) {
	      function t(e, i) {
	        n(this, t);var o = r(this, Object.getPrototypeOf(t).call(this, e, i));return o.name = "FileExtensionError", o;
	      }return i(t, e), t;
	    }(l),
	        p = function (e) {
	      function t(e, i) {
	        n(this, t);var o = r(this, Object.getPrototypeOf(t).call(this, e, i));return o.name = "FileSizeError", o;
	      }return i(t, e), t;
	    }(l);e.exports = { AbortError: s, TimeoutError: u, NetworkError: a, QueueLimitError: c, FilterError: l, DuplicateError: f, FileExtensionError: h, FileSizeError: p };
	  }, function (e, t, n) {
	    "use strict";
	    function r(e) {
	      return e && "undefined" != typeof Symbol && e.constructor === Symbol ? "symbol" : typeof e === "undefined" ? "undefined" : _typeof(e);
	    }function i(e, t) {
	      if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
	    }var o = function () {
	      function e(e, t) {
	        for (var n = 0; n < t.length; n++) {
	          var r = t[n];r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
	        }
	      }return function (t, n, r) {
	        return n && e(t.prototype, n), r && e(t, r), t;
	      };
	    }(),
	        s = n(3),
	        u = s.parseSize,
	        a = function () {
	      function e(t, n) {
	        i(this, e), this.rawResponse = t, this.chunkRequest = n;
	      }return o(e, [{ key: "getChunkRequest", value: function value() {
	          return this.chunkRequest;
	        } }, { key: "getRawResponse", value: function value() {
	          return this.rawResponse;
	        } }, { key: "getResponse", value: function value() {
	          return this.response || this.rawResponse;
	        } }, { key: "getJson", value: function value() {
	          var e = this.getResponse();return null == e ? null : "function" == typeof e.getJson ? e.getJson() : "string" == typeof e ? "" === e ? null : JSON.parse(e) : e;
	        } }, { key: "setResponse", value: function value(e) {
	          return this.response = e, this;
	        } }]), e;
	    }(),
	        c = function () {
	      function e(t, n, r) {
	        i(this, e), this.index = t, this.blob = n, this.fileRequest = r;
	      }return o(e, [{ key: "getName", value: function value() {
	          return this.fileRequest.getName();
	        } }, { key: "getFile", value: function value() {
	          return this.fileRequest.getFile();
	        } }, { key: "getBlob", value: function value() {
	          return this.blob;
	        } }, { key: "getIndex", value: function value() {
	          return this.index;
	        } }, { key: "isMultiChunk", value: function value() {
	          return this.getFile().source !== this.blob;
	        } }, { key: "getParams", value: function value() {
	          return this.params || (this.params = this.fileRequest.getParams().clone()), this.params;
	        } }, { key: "getParam", value: function value(e) {
	          return this.getParams().getParam(e);
	        } }, { key: "setParam", value: function value(e, t) {
	          return this.getParams().setParam(e, t), this;
	        } }, { key: "getFileRequest", value: function value() {
	          return this.fileRequest;
	        } }, { key: "getUrl", value: function value() {
	          return this.url || this.fileRequest.getUrl();
	        } }, { key: "setUrl", value: function value(e) {
	          return this.url = e, this;
	        } }, { key: "getHeaders", value: function value() {
	          return this.headers || (this.headers = this.fileRequest.getHeaders().slice(0)), this.headers;
	        } }, { key: "setHeader", value: function value(e, t) {
	          var n = this.getHeaders();return n.push({ name: e, value: t }), this;
	        } }, { key: "isWithCredentials", value: function value() {
	          return this.fileRequest.isWithCredentials();
	        } }, { key: "getTimeout", value: function value() {
	          return this.fileRequest.getTimeout();
	        } }, { key: "createChunkResponse", value: function value(e) {
	          return new a(e, this);
	        } }]), e;
	    }(),
	        l = function () {
	      function e(t, n) {
	        i(this, e), this.rawResponse = t, this.fileRequest = n;
	      }return o(e, [{ key: "isFromMultiChunkResponse", value: function value() {
	          return this.rawResponse instanceof a ? this.rawResponse.getChunkRequest().isMultiChunk() : !1;
	        } }, { key: "getFileRequest", value: function value() {
	          return this.fileRequest;
	        } }, { key: "getRawResponse", value: function value() {
	          return this.rawResponse;
	        } }, { key: "getResponse", value: function value() {
	          return null != this.response ? this.response : this.rawResponse instanceof a ? this.rawResponse.getResponse() : this.rawResponse;
	        } }, { key: "getJson", value: function value() {
	          var e = this.getResponse();return null == e ? null : "function" == typeof e.getJson ? e.getJson() : "string" == typeof e ? "" === e ? null : JSON.parse(e) : e;
	        } }, { key: "setResponse", value: function value(e) {
	          return this.response = e, this;
	        } }]), e;
	    }(),
	        f = function () {
	      function e(t) {
	        if (i(this, e), Array.isArray(t)) this.params = t.slice(0);else if ("object" === ("undefined" == typeof t ? "undefined" : r(t))) {
	          this.params = [];for (var n in t) {
	            t.hasOwnProperty(n) && this.params.push({ name: n, value: t[n] });
	          }
	        } else this.params = [];
	      }return o(e, [{ key: "setParam", value: function value(e, t) {
	          this.removeParam(e), this.addParam(e, t);
	        } }, { key: "addParam", value: function value(e, t) {
	          this.params.push({ name: e, value: t });
	        } }, { key: "removeParam", value: function value(e) {
	          this.params = this.params.filter(function (t) {
	            return t.name !== e;
	          });
	        } }, { key: "getParam", value: function value(e, t) {
	          var n = this.params.filter(function (t) {
	            return t.name === e;
	          }).map(function (e) {
	            return e.value;
	          });return t ? n.shift() : n;
	        } }, { key: "clone", value: function value() {
	          return new e(this.params);
	        } }, { key: "toArray", value: function value() {
	          return this.params;
	        } }, { key: "toString", value: function value() {
	          var e = this.params.map(function (e) {
	            return encodeURIComponent(e.name) + "=" + (null == e.value ? "" : encodeURIComponent(e.value));
	          });return e.join("&");
	        } }]), e;
	    }(),
	        h = 262144,
	        p = function () {
	      function e(t) {
	        var n = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1];i(this, e), this.file = t, this.name = n.name || "file", this.url = n.url || n.action, this.params = new f(n.params || n.data), this.headers = n.headers || [], this.withCredentials = n.withCredentials, this.timeout = n.timeout || 0, this.chunkSize = n.chunkSize || 0, this.chunkRetries = n.chunkRetries || 0, this.chunkEnable = n.chunkEnable || !1, this.chunkProcessThreads = n.chunkProcessThreads || 2;
	      }return o(e, [{ key: "getFile", value: function value() {
	          return this.file;
	        } }, { key: "getUrl", value: function value() {
	          return this.url || "";
	        } }, { key: "getName", value: function value() {
	          return this.name;
	        } }, { key: "setName", value: function value(e) {
	          return this.name = e, this;
	        } }, { key: "setUrl", value: function value(e) {
	          return this.url = e, this;
	        } }, { key: "getParams", value: function value() {
	          return this.params;
	        } }, { key: "getParam", value: function value(e) {
	          return this.getParams().getParam(e);
	        } }, { key: "setParam", value: function value(e, t) {
	          return this.params.setParam(e, t), this;
	        } }, { key: "getHeaders", value: function value() {
	          return this.headers;
	        } }, { key: "setHeader", value: function value(e, t) {
	          this.headers.push({ name: e, value: t });
	        } }, { key: "isWithCredentials", value: function value() {
	          return this.withCredentials;
	        } }, { key: "setWithCredentials", value: function value(e) {
	          return this.withCredentials = e, this;
	        } }, { key: "getTimeout", value: function value() {
	          return this.timeout;
	        } }, { key: "setTimeout", value: function value(e) {
	          return this.timeout = e, this;
	        } }, { key: "getChunkSize", value: function value() {
	          return u(this.chunkSize);
	        } }, { key: "setChunkSize", value: function value(e) {
	          return this.chunkSize = e, this;
	        } }, { key: "getChunkRetries", value: function value() {
	          return this.chunkRetries;
	        } }, { key: "setChunkRetries", value: function value(e) {
	          return this.chunkRetries = e, 0;
	        } }, { key: "isChunkEnable", value: function value() {
	          var e = this.getChunkSize();return this.chunkEnable && e > h && this.file.getRuntime().canSlice() && this.file.size > e;
	        } }, { key: "setChunkEnable", value: function value(e) {
	          return this.chunkEnable = e, this;
	        } }, { key: "getChunkProcessThreads", value: function value() {
	          return this.chunkProcessThreads;
	        } }, { key: "setChunkProcessThreads", value: function value(e) {
	          return this.chunkProcessThreads = e, this;
	        } }, { key: "createChunkRequest", value: function value(e, t) {
	          return new c(e, t, this);
	        } }, { key: "createFileResponse", value: function value(e) {
	          return new l(e, this);
	        } }]), e;
	    }();e.exports = p;
	  }, function (e, t, n) {
	    "use strict";
	    function r(e, t) {
	      if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
	    }function i(e, t) {
	      if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t || "object" != (typeof t === "undefined" ? "undefined" : _typeof(t)) && "function" != typeof t ? e : t;
	    }function o(e, t) {
	      if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + (typeof t === "undefined" ? "undefined" : _typeof(t)));e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
	    }function s(e) {
	      return function (t, n) {
	        function r(t) {
	          return --a < 0 || !e(t, n) ? (c = !0, !1) : !0;
	        }function i(e) {
	          c || (e.isFile ? e.file(function (e) {
	            c || r(e);
	          }) : e.isDirectory && e.createReader().readEntries(function (e) {
	            if (!c) for (var t = 0, n = e.length; n > t && !c; t++) {
	              i(e[t]);
	            }
	          }));
	        }for (var o = t.items, s = t.files, u = void 0, a = h, c = !1, l = 0, f = s.length; f > l && !c; l++) {
	          u = o && o[l];var p = u && u.webkitGetAsEntry && u.webkitGetAsEntry();if (p && p.isDirectory) i(p);else if (!r(s[l])) break;
	        }
	      };
	    }function u() {
	      if ("DataTransfer" in window && "FileList" in window && document.addEventListener) {
	        var e = l.getInstance(),
	            t = 0,
	            n = 0,
	            r = void 0,
	            i = s(function (t, n) {
	          if (!n || n.length < 1) return !1;t = new f(e, t);var r = n.length;return n.some(function (e) {
	            var n = e.recieve(t);return n > 0 ? !0 : (0 > n && (r -= 1), !1);
	          }) || r > 0;
	        }),
	            o = function o(e) {
	          t = 1, v.forEach(function (t) {
	            return t.start(e);
	          });
	        },
	            u = function u(e) {
	          var t = v.filter(function (t) {
	            return t.response(e);
	          }).length > 0,
	              n = e.dataTransfer;n && (n.dropEffect = t ? "copy" : "none"), e.preventDefault();
	        },
	            a = function a(e) {
	          t = 0, n = 0, v.forEach(function (t) {
	            return t.end(e);
	          });
	        },
	            c = function c(e) {
	          clearTimeout(r);var n = "dragleave" === e.type;n || t || o(e), u(e), n && (r = setTimeout(function () {
	            return a(e);
	          }, 100));
	        },
	            h = function h(e) {
	          e.preventDefault(), clearTimeout(r), a(e);var t = v.filter(function (t) {
	            return t.contains(e.target);
	          });if (!(t.length < 1)) {
	            var n = e.dataTransfer;try {
	              if (n.getData("text/html")) return;
	            } catch (o) {}i(n, t);
	          }
	        };document.addEventListener("dragenter", c, !1), document.addEventListener("dragover", c, !1), document.addEventListener("dragleave", c, !1), document.addEventListener("drop", h, !1);
	      }
	    }var a = function () {
	      function e(e, t) {
	        for (var n = 0; n < t.length; n++) {
	          var r = t[n];r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
	        }
	      }return function (t, n, r) {
	        return n && e(t.prototype, n), r && e(t, r), t;
	      };
	    }(),
	        c = n(2),
	        l = n(9),
	        f = n(12),
	        h = 100,
	        p = function (e) {
	      function t(e) {
	        r(this, t);var n = i(this, Object.getPrototypeOf(t).call(this));return n.areaElement = e, n;
	      }return o(t, e), a(t, [{ key: "contains", value: function value(e) {
	          return this.areaElement.contains(e);
	        } }, { key: "start", value: function value(e, t) {
	          this.emit("start", e, t);
	        } }, { key: "response", value: function value(e, t) {
	          return t = t && this.contains(e.target), this.emit("response", e, t), t;
	        } }, { key: "end", value: function value(e) {
	          this.emit("end", e);
	        } }]), t;
	    }(c),
	        v = [],
	        d = function () {
	      function e(t) {
	        r(this, e), v.length < 1 && u(), v.push(this), this.core = t, this.areas = [];
	      }return a(e, [{ key: "addArea", value: function value(e) {
	          var t = this;return e = new p(e), this.areas.push(e), e.destroy = function () {
	            e.removeAllListeners();var n = t.areas.indexOf(e);n > -1 && t.areas.splice(n, 1);
	          }, e;
	        } }, { key: "contains", value: function value(e) {
	          return this.areas.some(function (t) {
	            return t.contains(e);
	          });
	        } }, { key: "start", value: function value(e) {
	          this.areas.forEach(function (t) {
	            return t.start(e);
	          });
	        } }, { key: "response", value: function value(e) {
	          return this.areas.map(function (t) {
	            return t.response(e);
	          }).some(function (e) {
	            return e !== !1;
	          });
	        } }, { key: "recieve", value: function value(e) {
	          var t = this.core.add(e);return t > 0 && !this.core.isMultiple() ? -1 : t;
	        } }, { key: "end", value: function value(e) {
	          this.areas.forEach(function (t) {
	            return t.end(e);
	          });
	        } }]), e;
	    }();e.exports = d;
	  }, function (e, t, n) {
	    "use strict";
	    function r(e, t) {
	      if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
	    }function i(e, t) {
	      if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t || "object" != (typeof t === "undefined" ? "undefined" : _typeof(t)) && "function" != typeof t ? e : t;
	    }function o(e, t) {
	      if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + (typeof t === "undefined" ? "undefined" : _typeof(t)));e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
	    }var s = function () {
	      function e(e, t) {
	        for (var n = 0; n < t.length; n++) {
	          var r = t[n];r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
	        }
	      }return function (t, n, r) {
	        return n && e(t.prototype, n), r && e(t, r), t;
	      };
	    }(),
	        u = n(10),
	        a = n(3),
	        c = a.Deferred,
	        l = n(11),
	        f = void 0,
	        h = function (e) {
	      function t() {
	        return r(this, t), i(this, Object.getPrototypeOf(t).apply(this, arguments));
	      }return o(t, e), s(t, [{ key: "getAsDataUrl", value: function value(e, t) {
	          var n = c(),
	              r = new FileReader(),
	              i = void 0;r.onloadend = function () {
	            r.readyState == FileReader.DONE ? n.resolve(r.result) : n.reject(), clearTimeout(i), r.onloadend = null;
	          }, r.readAsDataURL(e);var o = function o() {
	            r && r.abort(), r = null;
	          };t && (i = setTimeout(o, t));var s = n.promise();return s.abort = o, s;
	        } }, { key: "getTransport", value: function value() {
	          return this.transport || (this.transport = new l(this)), this.transport;
	        } }, { key: "canSlice", value: function value() {
	          return !!(Blob.prototype.slice || Blob.prototype.mozSlice || Blob.prototype.webkitSlice);
	        } }, { key: "slice", value: function value(e, t, n) {
	          var r = e.slice || e.mozSlice || e.webkitSlice;return r.call(e, t, n);
	        } }, { key: "md5", value: function value(e) {
	          var t = c();if (!window.SparkMD5) return t.reject(), t.promise();var n = 2097152,
	              r = Math.ceil(e.size / n),
	              i = 0,
	              o = new SparkMD5.ArrayBuffer(),
	              s = e.mozSlice || e.webkitSlice || e.slice,
	              u = new FileReader(),
	              _a = function a() {
	            if (u) {
	              var c = void 0,
	                  l = void 0;c = i * n, l = Math.min(c + n, e.size), u.onload = function () {
	                o && o.append(u.result);
	              }, u.onloadend = function () {
	                u && (u.readyState == FileReader.DONE ? ++i < r ? setTimeout(_a, 1) : setTimeout(function () {
	                  o && t.resolve(o.end()), _a = e = o = null;
	                }, 50) : t.reject(), u.onloadend = u.onload = null);
	              }, u.readAsArrayBuffer(s.call(e, c, l));
	            }
	          };_a();var l = t.promise();return l.abort = function () {
	            u && u.abort(), o = null, u = null;
	          }, l;
	        } }], [{ key: "getInstance", value: function value() {
	          return f || (f = new t()), f;
	        } }]), t;
	    }(u);e.exports = h;
	  }, function (e, t, n) {
	    "use strict";
	    function r(e, t) {
	      if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
	    }function i(e, t) {
	      if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t || "object" != (typeof t === "undefined" ? "undefined" : _typeof(t)) && "function" != typeof t ? e : t;
	    }function o(e, t) {
	      if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + (typeof t === "undefined" ? "undefined" : _typeof(t)));e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
	    }var s = function () {
	      function e(e, t) {
	        for (var n = 0; n < t.length; n++) {
	          var r = t[n];r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
	        }
	      }return function (t, n, r) {
	        return n && e(t.prototype, n), r && e(t, r), t;
	      };
	    }(),
	        u = n(2),
	        a = n(4),
	        c = n(3),
	        l = c.Deferred,
	        f = n(6),
	        h = f.NetworkError,
	        p = function (e) {
	      function t() {
	        return r(this, t), i(this, Object.getPrototypeOf(t).apply(this, arguments));
	      }return o(t, e), s(t, [{ key: "md5", value: function value(e) {
	          var t = l();return t.reject(), t.promise();
	        } }, { key: "getAsDataUrl", value: function value(e, t) {
	          var n = l();return n.reject(), n.promise();
	        } }, { key: "getTransport", value: function value() {
	          return null;
	        } }, { key: "getUploading", value: function value() {
	          return this.uploading || (this.uploading = new v(this)), this.uploading;
	        } }, { key: "canSlice", value: function value() {
	          return !1;
	        } }, { key: "slice", value: function value(e) {
	          throw new Error("this runtime current not support slice");
	        } }, { key: "cancel", value: function value(e) {} }]), t;
	    }(u);e.exports = p;var v = function () {
	      function e(t) {
	        r(this, e), this.runtime = t;
	      }return s(e, [{ key: "generate", value: function value(e) {
	          var t = this,
	              n = l(),
	              r = e.getFile(),
	              i = this.runtime,
	              o = r.getSource(),
	              s = r.size,
	              u = e.getChunkSize(),
	              a = e.isChunkEnable(),
	              c = Math.max(e.getChunkProcessThreads(), 1),
	              f = 0,
	              h = 0,
	              p = [],
	              v = function v() {
	            return p.reduce(function (e, t) {
	              return e + ("pending" === t.state() ? 1 : 0);
	            }, 0);
	          },
	              d = function d() {
	            for (var n = void 0, r = void 0, a = void 0; s > h && v() < c;) {
	              f = h, h = Math.min(h + u, s), a = i.slice(o, f, h), r = e.createChunkRequest(p.length, a), r.setHeader("Content-Range", "bytes " + f + "-" + (h - 1) + "/" + s), n = t.slot(r, e.getChunkRetries()), n.progress(y).done(m).fail(k), p.push(n);
	            }
	          },
	              y = function y() {
	            var e = s - h,
	                t = 0;p.forEach(function (n) {
	              e += n.total, t += n.loaded;
	            }), n.notify({ total: e, loaded: t });
	          },
	              m = function m(e) {
	            a && d(), h >= s && p.every(function (e) {
	              return "resolved" === e.state();
	            }) && n.resolve(e);
	          },
	              g = function g() {
	            p.forEach(function (e) {
	              return e.abort();
	            });
	          },
	              k = function k(e) {
	            n.reject(e), g();
	          };if (a) d();else {
	            h = s;var b = this.slot(e.createChunkRequest(0, o), 0);b.progress(y).done(m).fail(k), p.push(b);
	          }var E = n.promise();return E.abort = g, E;
	        } }, { key: "slot", value: function value(e, t) {
	          var n = l(),
	              r = this.runtime,
	              i = e.getFile().getCore(),
	              o = n.promise(),
	              s = function s(e) {
	            e.total && (o.total = e.total), e.loaded && (o.loaded = e.loaded), n.notify(e);
	          },
	              u = function u() {
	            var t, u, l;o.abort = function () {
	              t && t.abort(), u && u.abort(), l && l.abort();
	            }, o.total = e.getBlob().size, o.loaded = 0, t = i.invoke(a.CHUNK_UPLOAD_PREPARING, e), t.then(function (e) {
	              return u = r.getTransport().generate(e), u.progress(s), u;
	            }).then(function (t) {
	              return l = i.invoke(a.CHUNK_UPLOAD_COMPLETING, e.createChunkResponse(t));
	            }).done(n.resolve).fail(c);
	          },
	              c = function c(e) {
	            e instanceof h && t-- > 0 ? setTimeout(u, 500) : n.reject(e), o.abort();
	          };return u(), o;
	        } }]), e;
	    }();
	  }, function (e, t, n) {
	    "use strict";
	    function r(e, t) {
	      if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
	    }var i = function () {
	      function e(e, t) {
	        for (var n = 0; n < t.length; n++) {
	          var r = t[n];r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
	        }
	      }return function (t, n, r) {
	        return n && e(t.prototype, n), r && e(t, r), t;
	      };
	    }(),
	        o = n(3),
	        s = o.Deferred,
	        u = n(6),
	        a = u.TimeoutError,
	        c = u.AbortError,
	        l = u.NetworkError,
	        f = function () {
	      function e() {
	        r(this, e);
	      }return i(e, [{ key: "generate", value: function value(e) {
	          var t = s(),
	              n = new XMLHttpRequest(),
	              r = void 0,
	              i = function i() {
	            n.onload = n.onerror = null, n.upload && (n.upload.onprogress = null), r && clearTimeout(r);
	          },
	              o = function o() {
	            i();try {
	              n.abort();
	            } catch (e) {}
	          },
	              u = function u(e) {
	            return i(), n.status || "error" !== e.type ? 0 === n.status || 304 === n.status || n.status >= 200 && n.status < 300 ? t.resolve(n.responseText) : t.reject(new l(n.status, n.statusText)) : t.reject(new c(e.message));
	          };n.upload && (n.upload.onprogress = function (e) {
	            return t.notify(e);
	          }), n.onerror = u, n.onload = u;var f = e.getTimeout();f > 0 && (r = setTimeout(function () {
	            o(), t.reject(new a("timeout:" + f));
	          }, f));try {
	            !function () {
	              n.open("POST", e.getUrl(), !0), e.isWithCredentials() && (n.withCredentials = !0), e.getHeaders().forEach(function (e) {
	                return n.setRequestHeader(e.name, e.value);
	              });var t = new FormData(),
	                  r = e.getBlob();e.getParams().toArray().forEach(function (e) {
	                return t.append(e.name, e.value);
	              }), t.append(e.getName(), r, r.name || "blob"), n.send(t);
	            }();
	          } catch (h) {
	            o(), t.reject(new c(h.message));
	          }var p = t.promise();return p.abort = o, p;
	        } }]), e;
	    }();e.exports = f;
	  }, function (e, t, n) {
	    "use strict";
	    function r(e, t) {
	      if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t || "object" != (typeof t === "undefined" ? "undefined" : _typeof(t)) && "function" != typeof t ? e : t;
	    }function i(e, t) {
	      if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + (typeof t === "undefined" ? "undefined" : _typeof(t)));e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
	    }function o(e, t) {
	      if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
	    }function s() {
	      return "FILE-" + (m++).toString(16).toUpperCase();
	    }function u(e) {
	      var t = e.name && g.exec(e.name);return t ? t[1] : (t = e.type && k.exec(e.type), t ? t[1] : "");
	    }function a(e) {
	      return ["jpg", "jpeg", "png", "gif", "bmp", "webp"].indexOf(e.toLowerCase()) > -1 ? "image/" + ("jpg" === e ? "jpeg" : e) : null;
	    }var c = function () {
	      function e(e, t) {
	        for (var n = 0; n < t.length; n++) {
	          var r = t[n];r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
	        }
	      }return function (t, n, r) {
	        return n && e(t.prototype, n), r && e(t, r), t;
	      };
	    }(),
	        l = n(2),
	        f = n(4),
	        h = n(3),
	        p = h.Deferred,
	        v = n(5),
	        d = v.Status,
	        y = v.StatusName,
	        m = 0,
	        g = /\.([^.]+)$/,
	        k = /^image\/(jpg|jpeg|png|gif|bmp|webp)$/i,
	        b = function () {
	      function e(t, n) {
	        o(this, e), this.change(t, n);
	      }return c(e, [{ key: "change", value: function value(e, t) {
	          this.total = e, this.loaded = t || 0, this.percentage = this.loaded === this.total ? 100 : Math.ceil(this.loaded / this.total * 100);
	        } }, { key: "done", value: function value() {
	          this.change(this.total, this.total);
	        } }]), e;
	    }(),
	        E = function (e) {
	      function t(e, n, i) {
	        o(this, t);var c = r(this, Object.getPrototypeOf(t).call(this));c.id = s(), c.name = n.name || i || c.id;var l = u(n).toLowerCase();return l && !g.test(c.name) && (c.name += "." + l), c.ext = l, c.type = n.type || a(c.ext) || "application/octet-stream", c.lastModified = n.lastModified || +new Date(), c.size = n.size || 0, c.runtime = e, c.source = n, c.status = d.INITED, c.progress = new b(c.size, 0), c;
	      }return i(t, e), c(t, [{ key: "getCore", value: function value() {
	          return this.core;
	        } }, { key: "setCore", value: function value(e) {
	          this.core = e, this.setPropagationTarget(e);
	        } }, { key: "getRuntime", value: function value() {
	          return this.runtime;
	        } }, { key: "isImage", value: function value() {
	          return k.test(this.type);
	        } }, { key: "setStatus", value: function value(e) {
	          var t = this.status;t !== d.CANCELLED && e !== t && (this.status = e, this.emit(f.FILE_STATUS_CHANGE, e, t));
	        } }, { key: "getStatus", value: function value() {
	          return this.status;
	        } }, { key: "getStatusName", value: function value() {
	          return this.status in y ? y[this.status] : "unknow";
	        } }, { key: "getSource", value: function value() {
	          return this.source;
	        } }, { key: "getAsDataUrl", value: function value(e) {
	          return this._dataUrlPromise || (this._dataUrlPromise = this.runtime.getAsDataUrl(this.source, e)), this._dataUrlPromise;
	        } }, { key: "md5", value: function value() {
	          return this._md5Promise || (this._md5Promise = this.runtime.md5(this.source)), this._md5Promise;
	        } }, { key: "session", value: function value() {
	          var e = this;if (this._sessionPromise) return this._sessionPromise;var t = p();return t.progress(function (t) {
	            e.setStatus(d.PROGRESS), e.emit(f.FILE_UPLOAD_PROGRESS, t);
	          }).done(function (t) {
	            e.response = t, e._session = null, e._sessionPromise = null, e._flows = [], e.setStatus(d.SUCCESS), e.emit(f.FILE_UPLOAD_SUCCESS, t);
	          }).fail(function (t) {
	            e._session = null, e._sessionPromise = null;for (var n = void 0; n = e._flows.shift();) {
	              n.abort();
	            }t instanceof Error && (e.setStatus(d.ERROR), e.emit(f.FILE_UPLOAD_ERROR, t));
	          }).always(function () {
	            e.emit(f.FILE_UPLOAD_COMPLETED, e.getStatus());
	          }), this._flows = [], this._session = t, this._sessionPromise = t.promise(), this._sessionPromise;
	        } }, { key: "prepare", value: function value() {
	          var e = this;if (this.status !== d.PENDING || !this.core) return !1;this.session(), this.setStatus(d.PROGRESS), this.emit(f.FILE_UPLOAD_START), this.request = this.core.createFileRequest(this);var t = this.core.invoke(f.FILE_UPLOAD_PREPARING, this.request);return this._flows.push(t), t.then(function (t) {
	            e.emit(f.FILE_UPLOAD_PREPARED, t);var n = e.runtime.getUploading().generate(t);return e._flows.push(n), n.progress(function (t) {
	              e.progress.change(t.total, t.loaded), e._session.notify(e.progress);
	            }), n;
	          }).then(function (t) {
	            return e.complete(t);
	          }, this._session.reject), !0;
	        } }, { key: "complete", value: function value(e) {
	          if (this.status === d.PROGRESS) {
	            for (var t = void 0; t = this._flows.shift();) {
	              t.abort();
	            }this.progress.done(), this._session.notify(this.progress), e = this.request.createFileResponse(e), this.setStatus(d.END), this.emit(f.FILE_UPLOAD_END);var n = this.core.invoke(f.FILE_UPLOAD_COMPLETING, e);this._flows.push(n), n.then(this._session.resolve, this._session.reject);
	          }
	        } }, { key: "pending", value: function value() {
	          (this.status === d.ERROR || this.status === d.QUEUED) && (this.progress.change(this.size, 0), this.setStatus(d.PENDING));
	        } }, { key: "abort", value: function value() {
	          this._session && this._session.reject(), this._session = null, this._sessionPromise = null;
	        } }, { key: "cancel", value: function value() {
	          this.setStatus(d.CANCELLED), this.emit(f.FILE_CANCEL), this.abort(), this.runtime.cancel(this.source), this._dataUrlPromise && this._dataUrlPromise.abort(), this._md5Promise && this._md5Promise.abort && this._md5Promise.abort(), this.removeAllListeners();
	        } }, { key: "destroy", value: function value() {
	          this.cancel();
	        } }]), t;
	    }(l);e.exports = E;
	  }, function (e, t, n) {
	    "use strict";
	    function r(e, t) {
	      if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
	    }var i = function () {
	      function e(e, t) {
	        for (var n = 0; n < t.length; n++) {
	          var r = t[n];r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
	        }
	      }return function (t, n, r) {
	        return n && e(t.prototype, n), r && e(t, r), t;
	      };
	    }(),
	        o = n(2),
	        s = n(9),
	        u = n(12),
	        a = function () {
	      function e(t) {
	        r(this, e), this.core = t, this.runtime = s.getInstance();
	      }return i(e, [{ key: "addArea", value: function value(e) {
	          var t = this.core,
	              n = this.runtime,
	              r = new o(),
	              i = function i(e) {
	            var i = e.clipboardData || window.clipboardData,
	                o = i.items,
	                s = i.files;if (s || o) {
	              var a = void 0,
	                  c = void 0,
	                  l = void 0,
	                  f = void 0,
	                  h = void 0,
	                  p = void 0;if (s && s.length) for (a = s.length > 0, c = 0, l = s.length; l > c && (f = new u(n, s[c]), a = 1, p = t.add(f), !(0 > p || p > 0 && !t.isMultiple())); c++) {} else if (o && o.length) {
	                var v = i.getData("text/plain");for (c = 0, l = o.length; l > c && !t.isLimit() && (h = o[c], !("file" === h.kind && (f = h.getAsFile()) && (f = new u(n, f, v), v = null, a = 1, p = t.add(f), 0 > p || p > 0 && !t.isMultiple()))); c++) {}
	              }a && (e.preventDefault(), e.stopPropagation(), r.emit("paste", i));
	            }
	          };return "DataTransfer" in window && "FileList" in window && e.addEventListener && e.addEventListener("paste", i, !1), r.destroy = function () {
	            r.removeAllListeners(), e.removeEventListener && e.removeEventListener("paste", i, !1);
	          }, r;
	        } }]), e;
	    }();e.exports = a;
	  }, function (e, t, n) {
	    "use strict";
	    function r(e, t) {
	      if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t || "object" != (typeof t === "undefined" ? "undefined" : _typeof(t)) && "function" != typeof t ? e : t;
	    }function i(e, t) {
	      if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + (typeof t === "undefined" ? "undefined" : _typeof(t)));e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
	    }function o(e, t) {
	      if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
	    }var s = function () {
	      function e(e, t) {
	        for (var n = 0; n < t.length; n++) {
	          var r = t[n];r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
	        }
	      }return function (t, n, r) {
	        return n && e(t.prototype, n), r && e(t, r), t;
	      };
	    }(),
	        u = n(2),
	        a = n(9),
	        c = n(15),
	        l = n(12),
	        f = n(3),
	        h = f.extend,
	        p = "",
	        v = function () {
	      var e = document.createElement("div");return function (t) {
	        return e.innerHTML = t, t = e.firstChild, e.removeChild(t), t;
	      };
	    }(),
	        d = function () {
	      function e(t, n) {
	        var r = this;o(this, e);var i = v('<label style="position:fixed;left:-100px;top:-100px;width:50px;height:50px;display:block;cursor:pointer;overflow:hidden;z-index:99999;opacity:0;filter:alpha(opacity=0)"></label>'),
	            s = new c(i, p, function () {
	          return { accept: t.getAccept(), multiple: t.isMultiple() };
	        });s.on("select", function (e) {
	          n(e.files, s), r.current && r.current.emit("files", e.files, s);
	        }), s.on("rollOut", function () {
	          return r.hideOverlay();
	        }), document.body.appendChild(i), this.overlay = i;
	      }return s(e, [{ key: "hideOverlay", value: function value() {
	          h(this.overlay.style, { left: "-100px", top: "-100px", width: "50px", height: "50px" }), this.current && (this.current.emit("rollOut"), this.current = null);
	        } }, { key: "add", value: function value(e) {
	          var t = this,
	              n = this.overlay,
	              r = new u(),
	              i = function i() {
	            var i = e.getBoundingClientRect();h(n.style, { left: i.left + "px", top: i.top + "px", width: i.right - i.left + "px", height: i.bottom - i.top + "px" }), r.emit("rollOver"), t.current && t.current !== r && t.current.emit("rollOut"), t.current = r;
	          };return e.addEventListener ? e.addEventListener("mouseover", i, !1) : e.attachEvent && e.attachEvent("onmouseover", i), r.destroy = function () {
	            t.current === r && t.hideOverlay(), r.removeAllListeners(), e.removeEventListener ? e.removeEventListener("mouseover", i, !1) : e.detachEvent && e.detachEvent("onmouseover", i);
	          }, r;
	        } }]), e;
	    }(),
	        y = function (e) {
	      function t(e, n, i) {
	        o(this, t);var s = r(this, Object.getPrototypeOf(t).call(this));return s.trigger = e, s.core = n, s.label = v('<label style="position:absolute;top:0;left:0;width:100%;height:100%;display:inline-block;cursor:pointer;background:#fff;overflow:hidden;opacity:0"></label>'), s.onChange = function (e) {
	          i(e.target.files), s.destroyInput(), s.createInput();
	        }, e.appendChild(s.label), s.createInput(), s;
	      }return i(t, e), s(t, [{ key: "createInput", value: function value() {
	          var e = v('<input type="file" style="position:absolute;clip:rect(1px 1px 1px 1px);" />'),
	              t = this.core.getAccept();t && t.length > 0 && (t = t.map(function (e) {
	            return e.mimeTypes || "." + e.extensions.join(",.");
	          }), e.setAttribute("accept", t.join(","))), this.core.isMultiple() && e.setAttribute("multiple", "multiple"), e.addEventListener("change", this.onChange, !1), this.label.appendChild(e), this.input = e;
	        } }, { key: "destroyInput", value: function value() {
	          this.input && (this.input.removeEventListener("change", this.onChange, !1), this.label.removeChild(this.input), this.input = null);
	        } }, { key: "destroy", value: function value() {
	          this.destroyInput(), this.removeAllListeners(), this.trigger.removeChild(this.label);
	        } }]), t;
	    }(u),
	        m = function () {
	      function e(t, n) {
	        o(this, e);var r = a.getInstance();this.core = t, this.onFiles = function (e) {
	          n(e, r);
	        };
	      }return s(e, [{ key: "add", value: function value(e) {
	          return new y(e, this.core, this.onFiles);
	        } }]), e;
	    }(),
	        g = function () {
	      function e(t) {
	        o(this, e);var n = function n(e, _n) {
	          for (var r = 0, i = e.length; i > r && !(t.add(new l(_n, e[r])) < 0); r++) {}
	        };"DataTransfer" in window && "FileList" in window ? this.triggerCollection = new m(t, n) : this.triggerCollection = new d(t, n);
	      }return s(e, null, [{ key: "setSWF", value: function value(e) {
	          p = e;
	        } }]), s(e, [{ key: "addArea", value: function value(e) {
	          return this.triggerCollection.add(e);
	        } }]), e;
	    }();e.exports = g;
	  }, function (e, t, n) {
	    "use strict";
	    function r(e, t) {
	      if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
	    }function i(e, t) {
	      if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t || "object" != (typeof t === "undefined" ? "undefined" : _typeof(t)) && "function" != typeof t ? e : t;
	    }function o(e, t) {
	      if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + (typeof t === "undefined" ? "undefined" : _typeof(t)));e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
	    }function s() {
	      var e = void 0;try {
	        e = navigator.plugins["Shockwave Flash"], e = e.description;
	      } catch (t) {
	        try {
	          e = new ActiveXObject("ShockwaveFlash.ShockwaveFlash").GetVariable("$version");
	        } catch (n) {
	          e = "0.0";
	        }
	      }return e = e.match(/\d+/g), parseFloat(e[0] + "." + e[1]);
	    }function u(e, t, n) {
	      try {
	        e.CallFunction('<invoke name="' + t + '" returntype="javascript">' + __flash__argumentsToXML(n || [], 0) + "</invoke>");
	      } catch (r) {
	        throw "Call to " + t + " failed";
	      }
	    }function a(e, t) {
	      if (s() < 11.4) throw "flash player is not available";var n = document.createElement("div"),
	          r = e + (e.indexOf("?") > 0 ? "&" : "?") + "callInterface=" + encodeURIComponent(t),
	          i = ['id="' + t + '-Picker"', 'type="application/x-shockwave-flash"', 'data="' + r + '"', 'width="100%" height="100%"', 'style="position:absolute;left:0;top:0;display:block;z-index:1;outline:0"'];return window.ActiveXObject && i.push('classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000"'), n.innerHTML = "<object " + i.join(" ") + '><param name="movie" value="' + r + '" /><param name="wmode" value="transparent" /><param name="allowscriptaccess" value="always" /></object>', n.firstChild;
	    }function c(e) {
	      var t = e + (p++).toString(16);return t in window ? c(e) : t;
	    }var l = function () {
	      function e(e, t) {
	        for (var n = 0; n < t.length; n++) {
	          var r = t[n];r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
	        }
	      }return function (t, n, r) {
	        return n && e(t.prototype, n), r && e(t, r), t;
	      };
	    }(),
	        f = n(10),
	        h = n(16),
	        p = +new Date(),
	        v = function (e) {
	      function t(e, n, o) {
	        function s() {
	          var t = e.offsetWidth,
	              r = e.offsetHeight,
	              i = void 0;return t && r && (i = a(n, l)) ? void e.appendChild(f.flash = i) : void setTimeout(s, 1e3);
	        }r(this, t);var u = i(this, Object.getPrototypeOf(t).call(this)),
	            l = c("FlashRuntime");u.callInterface = l, window[l] = u, u.options = o;var f = u;return s(), u;
	      }return o(t, e), l(t, [{ key: "getOptions", value: function value() {
	          var e = this.options;return "function" == typeof e && (e = e()), e;
	        } }, { key: "getTransport", value: function value(e, t, n) {
	          return new h(this, e, t, n);
	        } }, { key: "send", value: function value(e, t, n, r) {
	          u(this.flash, "exec", ["send", e, t.id, n, r]);
	        } }, { key: "abort", value: function value(e) {
	          try {
	            u(this.flash, "exec", ["abort", e.id]);
	          } catch (t) {}
	        } }, { key: "cancel", value: function value(e) {
	          u(this.flash, "exec", ["cancel", e.id]);
	        } }, { key: "ping", value: function value() {
	          u(this.flash, "exec", ["pang"]);
	        } }, { key: "destroy", value: function value() {
	          delete window[this.callInterface];
	        } }]), t;
	    }(f);e.exports = v;
	  }, function (e, t, n) {
	    "use strict";
	    function r(e, t) {
	      if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
	    }var i = function () {
	      function e(e, t) {
	        for (var n = 0; n < t.length; n++) {
	          var r = t[n];r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
	        }
	      }return function (t, n, r) {
	        return n && e(t.prototype, n), r && e(t, r), t;
	      };
	    }(),
	        o = n(3),
	        s = o.Deferred,
	        u = n(6),
	        a = u.TimeoutError,
	        c = u.AbortError,
	        l = u.NetworkError,
	        f = function () {
	      function e(t) {
	        r(this, e), this.flashRuntime = t;
	      }return i(e, [{ key: "generate", value: function value(e) {
	          var t = s(),
	              n = this.flashRuntime,
	              r = e.getBlob(),
	              i = void 0,
	              o = function o() {
	            n.off("uploadprogress", f), n.off("uploadcomplete", h), n.off("uploaderror", p), i && clearTimeout(i);
	          },
	              u = function u() {
	            o(), n.abort(r.id);
	          },
	              f = function f(e) {
	            e.id === r.id && t.notify(e);
	          },
	              h = function h(e) {
	            return e.id === r.id ? (o(), 304 === e.status || e.status >= 200 && e.status < 300 ? (n.cancel(r), t.resolve(e.response)) : t.reject(new l(e.status, e.response))) : void 0;
	          },
	              p = function p(e) {
	            e.id === r.id && (o(), t.reject(new c(e.message)));
	          };n.on("uploadprogress", f), n.on("uploadcomplete", h), n.on("uploaderror", p);var v = e.getTimeout();v > 0 && (i = setTimeout(function () {
	            u(), t.reject(new a("timeout:" + v));
	          }, v));try {
	            n.send(e.getName(), r, e.getUrl(), e.getParams().toString());
	          } catch (d) {
	            u(), t.reject(new c(d.message));
	          }var y = t.promise();return y.abort = u, y;
	        } }]), e;
	    }();e.exports = f;
	  }]);
		});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(704)(module)))

/***/ },
/* 704 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 705 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);
	var util = __webpack_require__(706);

	var Progress = function (_React$Component) {
	    _inherits(Progress, _React$Component);

	    function Progress(props) {
	        _classCallCheck(this, Progress);

	        return _possibleConstructorReturn(this, _React$Component.call(this, props));
	    }

	    Progress.prototype.render = function render() {
	        var percentage = this.props.percentage || 0;
	        if (util.TRANSFORM_PROPERTY && this.props.mode !== 'bar') {
	            var items = [0, 1];
	            var ret = items.map(function (i) {
	                return Math.floor(Math.min(Math.max(0, (percentage - i * 50) * 3.6), 180));
	            }).map(function (rotate) {
	                var _ref;

	                return _ref = {}, _ref[util.TRANSFORM_PROPERTY] = 'rotate(' + rotate + 'deg)', _ref;
	            });

	            return React.createElement('div', { className: 'kuma-upload-progresspin' }, React.createElement('div', { className: 'spin spin2-1' }, React.createElement('div', { className: 'inner', style: ret[0] })), React.createElement('div', { className: 'spin spin2-2' }, React.createElement('div', { className: 'inner', style: ret[1] })));
	        } else {
	            return React.createElement('div', { className: 'kuma-upload-progressbar', style: { width: percentage + '%' } });
	        }
	    };

	    return Progress;
	}(React.Component);

	Progress.isSupport = util.TRANSFORM_PROPERTY !== false;

	Progress.propTypes = {
	    percentage: React.PropTypes.number
	};
	Progress.defaultProps = {
	    percentage: 0
	};

		module.exports = Progress;

/***/ },
/* 706 */
/***/ function(module, exports) {

	'use strict';

	module.exports = {
	    humanSizeFormat: function humanSizeFormat(size) {
	        size = parseFloat(size);
	        var prefixesSI = ['', 'k', 'm', 'g', 't', 'p', 'e', 'z', 'y'];
	        var base = 1000,
	            index = size ? Math.floor(Math.log(size) / Math.log(base)) : 0;
	        index = Math.min(index, prefixesSI.length - 1);
	        var powedPrecision = Math.pow(10, index < 2 ? 0 : index > 2 ? 2 : 1);
	        size = size / Math.pow(base, index);
	        size = Math.round(size * powedPrecision) / powedPrecision;
	        if (size > 500) {
	            size = Math.round(size / 100) / 10;
	            index++;
	        }
	        return size + prefixesSI[index];
	    },
	    natcut: function natcut(title, len) {
	        var max = len * 2,
	            length = title.length,
	            l = 0,
	            i = 0,
	            part = void 0,
	            s = void 0;
	        for (i = 0; i < length && l <= max; i++) {
	            l += title.charCodeAt(i) > 255 ? 2 : 1;
	        }
	        if (l <= max) {
	            return title;
	        }
	        i = 0;
	        l = 0;
	        len -= 2;
	        while (l < len) {
	            s = title.charCodeAt(i) > 255 ? 2 : 1;
	            if (l + s > len) {
	                break;
	            } else {
	                i++;
	                l += s;
	            }
	        }
	        part = title.substr(0, i);
	        l += 3;

	        i = length;
	        while (l < max) {
	            s = title.charCodeAt(i - 1) > 255 ? 2 : 1;
	            if (l + s > max) {
	                break;
	            } else {
	                i--;
	                l += s;
	            }
	        }
	        return part + '...' + title.substring(Math.min(i, length - 1), length);
	    },
	    TRANSFORM_PROPERTY: function () {
	        var style = document.createElement("div").style;
	        var properties = ["transform", "WebkitTransform", "MozTransform", "msTransform"];
	        for (var i = 0, l = properties.length; i < l; i++) {
	            if (properties[i] in style) {
	                return properties[i];
	            }
	        }
	        return false;
	    }()
		};

/***/ },
/* 707 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var FileItem = __webpack_require__(708);
	var Picker = __webpack_require__(711);

	var _require = __webpack_require__(703);

	var Events = _require.Events;

	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var FileList = function (_React$Component) {
	    _inherits(FileList, _React$Component);

	    function FileList(props) {
	        _classCallCheck(this, FileList);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.core = _this.props.core;

	        _this.state = {
	            items: _this.core.getStat().getFiles()
	        };
	        return _this;
	    }

	    FileList.prototype.componentDidMount = function componentDidMount() {
	        var _this2 = this;

	        var statchange = function statchange(stat) {
	            _this2.setState({
	                items: stat.getFiles()
	            });
	        };
	        this.core.on(Events.QUEUE_STAT_CHANGE, statchange);
	        this.stopListen = function () {
	            _this2.core.off(Events.QUEUE_STAT_CHANGE, statchange);
	        };
	    };

	    FileList.prototype.componentWillUnmount = function componentWillUnmount() {
	        this.stopListen && this.stopListen();
	    };

	    FileList.prototype.render = function render() {
	        var _this3 = this;

	        return React.createElement('div', { className: "kuma-upload-filelist " + (this.props.mode === 'nw' ? 'nwmode' : this.props.mode === 'mini' ? 'minimode' : 'iconmode') }, React.createElement('div', { className: 'inner' }, this.state.items.map(function (file) {
	            return React.createElement(FileItem, { locale: _this3.props.locale, key: file.id, file: file, mode: _this3.props.mode });
	        }), !this.core.isFull() && this.props.mode === 'icon' ? React.createElement(Picker, { core: this.core }, React.createElement('i', { className: 'kuma-icon kuma-icon-add' })) : null));
	    };

	    return FileList;
	}(React.Component);

	FileList.defaultProps = {
	    mode: 'mini'
	};

		module.exports = FileList;

/***/ },
/* 708 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var Preview = __webpack_require__(709);
	var util = __webpack_require__(706);

	var _require = __webpack_require__(703);

	var Events = _require.Events;

	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);
	var i18n = __webpack_require__(710);

	var FileItem = function (_React$Component) {
	    _inherits(FileItem, _React$Component);

	    function FileItem(props) {
	        _classCallCheck(this, FileItem);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        var file = _this.props.file;
	        _this.file = file;

	        _this.state = {
	            percentage: file.progress ? file.progress.percentage : 0,
	            status: file.getStatusName()
	        };
	        return _this;
	    }

	    FileItem.prototype.componentDidMount = function componentDidMount() {
	        var _this2 = this;

	        var file = this.file;
	        var statuschange = function statuschange() {
	            var state = {
	                status: file.getStatusName()
	            };
	            if (state.status === 'error') {
	                state.percentage = 0;
	            }
	            _this2.setState(state);
	        };
	        var progress = function progress(_progress) {
	            _this2.setState({
	                percentage: _progress.percentage
	            });
	        };
	        file.on(Events.FILE_STATUS_CHANGE, statuschange);
	        file.on(Events.FILE_UPLOAD_PROGRESS, progress);

	        this.stopListen = function () {
	            file.off(Events.FILE_STATUS_CHANGE, statuschange);
	            file.off(Events.FILE_UPLOAD_PROGRESS, progress);
	        };
	    };

	    FileItem.prototype.componentWillUnmount = function componentWillUnmount() {
	        this.stopListen && this.stopListen();
	    };

	    FileItem.prototype.onPending = function onPending() {
	        this.file.pending();
	    };

	    FileItem.prototype.onCancel = function onCancel() {
	        this.file.cancel();
	    };

	    FileItem.prototype.render = function render() {
	        var me = this;
	        var locale = me.props.locale;

	        if (this.props.mode === 'icon') {
	            return React.createElement('div', { className: "kuma-upload-fileitem status-" + this.state.status }, React.createElement('a', { className: 'kuma-upload-action action-remove', onClick: this.onCancel.bind(this), title: i18n[locale]['remove'] }, React.createElement('i', { className: 'kuma-icon kuma-icon-close' })), React.createElement('div', { className: 'filepreview' }, React.createElement(Preview, { file: this.props.file }), this.state.status === 'error' ? React.createElement('a', { className: 'kuma-upload-action action-retry', onClick: this.onPending.bind(this), title: i18n[locale]['retry'] }, React.createElement('i', { className: 'kuma-icon kuma-icon-refresh' })) : null, this.state.status === 'queued' ? React.createElement('a', { className: 'kuma-upload-action action-upload', onClick: this.onPending.bind(this), title: i18n[locale]['upload'] }, React.createElement('i', { className: 'kuma-icon kuma-icon-triangle-right' })) : null, this.state.status === 'progress' || this.state.status === 'pending' ? React.createElement(Progress, { percentage: this.state.percentage }) : null), this.state.status === 'error' ? React.createElement('a', { className: 'kuma-upload-status status-error', title: i18n[locale]['upload_failed'] }, React.createElement('i', { className: 'kuma-icon kuma-icon-caution' })) : null, this.state.status === 'success' ? React.createElement('a', { className: 'kuma-upload-status status-success' }, React.createElement('i', { className: 'kuma-icon kuma-icon-choose' })) : null, React.createElement('div', { className: 'filename', title: this.file.name }, util.natcut(this.file.name, 10)));
	        } else if (this.props.mode === 'nw') {
	            var downloadUrl = void 0,
	                previewUrl = void 0;
	            if (this.state.status === 'success') {
	                var json = this.file.response.getJson();
	                try {
	                    downloadUrl = json.data.downloadUrl || json.data.file || json.data.url;
	                    previewUrl = json.data.previewUrl || downloadUrl;
	                } catch (e) {}
	            }
	            return React.createElement('div', { className: "kuma-upload-fileitem status-" + this.state.status }, React.createElement('label', { className: 'field-info' }, this.state.status === 'error' ? React.createElement('i', { className: 'kuma-icon kuma-icon-caution' }) : null, this.state.status !== 'error' && this.state.status !== 'success' ? React.createElement('i', { className: 'kuma-loading' }) : null, this.state.status === 'success' ? React.createElement('i', { className: 'kuma-upload-fileicon', 'data-ext': this.file.ext, 'data-type': this.file.type }) : null, React.createElement('span', { className: 'filename' }, this.file.name)), React.createElement('label', { className: 'field-status' }, this.state.status === 'error' ? React.createElement('a', { className: 'kuma-upload-status status-error' }, i18n[locale]['upload_failed']) : null, this.state.status !== 'error' && this.state.status !== 'success' ? React.createElement('a', { className: 'kuma-upload-status status-progress' }, i18n[locale]['uploading'] + '...') : null, this.state.status === 'success' && previewUrl ? React.createElement('a', { className: 'kuma-upload-action', target: '_blank', href: previewUrl }, i18n[locale]['preview']) : null, this.state.status === 'success' && downloadUrl ? React.createElement('a', { className: 'kuma-upload-action', target: '_blank', href: downloadUrl }, i18n[locale]['download']) : null, React.createElement('a', { className: 'kuma-upload-action', onClick: this.onCancel.bind(this) }, i18n[locale]['remove'])));
	        } else {
	            var size = util.humanSizeFormat(this.file.size);
	            return React.createElement('div', { className: "kuma-upload-fileitem status-" + this.state.status }, React.createElement('label', { className: 'field-info' }, React.createElement('i', { className: 'kuma-upload-fileicon', 'data-ext': this.file.ext, 'data-type': this.file.type }), React.createElement('span', { className: 'filename', title: this.file.name }, util.natcut(this.file.name, 12)), React.createElement('span', { className: 'filesize' }, '/' + size)), React.createElement('label', { className: 'field-status' }, this.state.status === 'error' ? React.createElement('a', { className: 'kuma-upload-status status-error', title: i18n[locale]['upload_failed'] }, React.createElement('i', { className: 'kuma-icon kuma-icon-caution' })) : null, this.state.status === 'success' ? React.createElement('a', { className: 'kuma-upload-status status-success' }, React.createElement('i', { className: 'kuma-icon kuma-icon-choose' })) : null, this.state.status === 'error' ? React.createElement('a', { className: 'kuma-upload-action action-retry', onClick: this.onPending.bind(this), title: i18n[locale]['retry'] }, React.createElement('i', { className: 'kuma-icon kuma-icon-refresh' })) : null, this.state.status === 'queued' ? React.createElement('a', { className: 'kuma-upload-action action-upload', onClick: this.onPending.bind(this), title: i18n[locale]['upload'] }, React.createElement('i', { className: 'kuma-icon kuma-icon-triangle-right' })) : null, React.createElement('a', { className: 'kuma-upload-action action-remove', onClick: this.onCancel.bind(this), title: i18n[locale]['remove'] }, React.createElement('i', { className: 'kuma-icon kuma-icon-close' }))), React.createElement(Progress, { percentage: this.state.percentage, mode: 'bar' }));
	        }
	    };

	    return FileItem;
	}(React.Component);

	FileItem.defaultProps = {
	    mode: 'mini'
	};

		module.exports = FileItem;

/***/ },
/* 709 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var Preview = function (_React$Component) {
	    _inherits(Preview, _React$Component);

	    function Preview(props) {
	        _classCallCheck(this, Preview);

	        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	        _this.state = {};

	        var file = _this.props.file;
	        if (file.isImage()) {
	            file.getAsDataUrl(1000).done(function (url) {
	                return _this.setState({ url: url });
	            });
	        }
	        return _this;
	    }

	    Preview.prototype.render = function render() {
	        return React.createElement('div', { className: 'previewer' }, this.state.url ? React.createElement('img', { src: this.state.url }) : React.createElement('i', { className: 'kuma-upload-fileicon', 'data-ext': this.props.file.ext, 'data-type': this.props.file.type }));
	    };

	    return Preview;
	}(React.Component);

		module.exports = Preview;

/***/ },
/* 710 */
/***/ function(module, exports) {

	"use strict";

	var locale = {
	    "en-us": {
	        "download": "download",
	        "preview": "preview",
	        "remove": "remove",
	        "retry": "retry",
	        "upload": "upload",
	        "uploading": "uploading",
	        "upload_failed": "upload failed",
	        "upload_files": "upload files"
	    },
	    "zh-cn": {
	        "download": "下载",
	        "preview": "预览",
	        "remove": "移除",
	        "retry": "重传",
	        "upload": "上传",
	        "uploading": "上传中",
	        "upload_failed": "上传失败",
	        "upload_files": "添加文件"
	    }
	};

	locale['en'] = locale['en-us'];

	module.exports = locale;

/***/ },
/* 711 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var Picker = function (_React$Component) {
	    _inherits(Picker, _React$Component);

	    function Picker() {
	        _classCallCheck(this, Picker);

	        return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
	    }

	    Picker.prototype.componentDidMount = function componentDidMount() {
	        this.area = this.props.core.getPickerCollector().addArea(ReactDOM.findDOMNode(this));
	    };

	    Picker.prototype.componentWillUnmount = function componentWillUnmount() {
	        this.area && this.area.destroy();
	    };

	    Picker.prototype.render = function render() {
	        return React.createElement('div', { className: 'kuma-upload-picker' }, this.props.children);
	    };

	    return Picker;
	}(React.Component);

		module.exports = Picker;

/***/ },
/* 712 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Message Component for uxcore
	 * @author eternaslky
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

		module.exports = __webpack_require__(713);

/***/ },
/* 713 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Notification = __webpack_require__(714);
	var classnames = __webpack_require__(5);
	var defaultDuration = 1.5;
	var messageInstance = void 0;
	var key = 1;
	var prefixCls = 'kuma-message';
	var transitionName = 'moveUp';
	var className = void 0;

	function getMessageInstance() {
	    messageInstance = messageInstance || Notification.newInstance({
	        prefixCls: prefixCls,
	        className: className,
	        transitionName: transitionName,
	        style: {
	            left: '50%'
	        } // 覆盖原来的样式
	    });
	    return messageInstance;
	}

	function notice(content) {
	    var duration = arguments.length <= 1 || arguments[1] === undefined ? defaultDuration : arguments[1];

	    var _classnames;

	    var type = arguments[2];
	    var onClose = arguments[3];

	    var iconClass = {
	        'info': 'kuma-icon kuma-icon-information',
	        'success': 'kuma-icon kuma-icon-success',
	        'error': 'kuma-icon kuma-icon-error',
	        'loading': 'kuma-loading'
	    }[type];

	    var instance = getMessageInstance();
	    instance.notice({
	        key: key,
	        duration: duration,
	        style: {
	            right: '50%'
	        },
	        content: React.createElement('div', { className: classnames((_classnames = {}, _classnames[prefixCls + '-container ' + prefixCls + '-container-' + type] = true, _classnames['fn-clear'] = true, _classnames)) }, React.createElement('i', { className: iconClass }), React.createElement('div', { className: prefixCls + '-content' }, content)),
	        onClose: onClose
	    });
	    return function () {
	        var target = key++;
	        return function () {
	            instance.removeNotice(target);
	        };
	    }();
	}

	module.exports = {
	    info: function info(content, duration, onClose) {
	        return notice(content, duration, 'info', onClose);
	    },
	    success: function success(content, duration, onClose) {
	        return notice(content, duration, 'success', onClose);
	    },
	    error: function error(content, duration, onClose) {
	        return notice(content, duration, 'error', onClose);
	    },
	    loading: function loading(content, duration, onClose) {
	        return notice(content, duration, 'loading', onClose);
	    },
	    config: function config(options) {
	        prefixCls = options.prefixCls || prefixCls;
	        transitionName = options.transitionName || transitionName;
	        className = options.className || className;
	    }
		};

/***/ },
/* 714 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _Notification = __webpack_require__(715);

	var _Notification2 = _interopRequireDefault(_Notification);

	exports['default'] = _Notification2['default'];
	module.exports = exports['default'];

/***/ },
/* 715 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	  } else {
	    obj[key] = value;
	  }return obj;
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(4);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _rcAnimate = __webpack_require__(716);

	var _rcAnimate2 = _interopRequireDefault(_rcAnimate);

	var _rcUtil = __webpack_require__(725);

	var _Notice = __webpack_require__(741);

	var _Notice2 = _interopRequireDefault(_Notice);

	var seed = 0;
	var now = Date.now();

	function getUuid() {
	  return 'rcNotification_' + now + '_' + seed++;
	}

	var Notification = _react2['default'].createClass({
	  displayName: 'Notification',

	  getDefaultProps: function getDefaultProps() {
	    return {
	      prefixCls: 'rc-notification',
	      animation: 'fade',
	      style: {
	        'top': 65,
	        left: '50%'
	      }
	    };
	  },

	  getInitialState: function getInitialState() {
	    return {
	      notices: []
	    };
	  },

	  getTransitionName: function getTransitionName() {
	    var props = this.props;
	    var transitionName = props.transitionName;
	    if (!transitionName && props.animation) {
	      transitionName = props.prefixCls + '-' + props.animation;
	    }
	    return transitionName;
	  },

	  add: function add(notice) {
	    var key = notice.key = notice.key || getUuid();
	    var notices = this.state.notices;
	    if (!notices.filter(function (v) {
	      return v.key === key;
	    }).length) {
	      this.setState({
	        notices: notices.concat(notice)
	      });
	    }
	  },

	  remove: function remove(key) {
	    var notices = this.state.notices.filter(function (notice) {
	      return notice.key !== key;
	    });
	    this.setState({
	      notices: notices
	    });
	  },

	  render: function render() {
	    var _className,
	        _this = this;

	    var props = this.props;
	    var noticeNodes = this.state.notices.map(function (notice) {
	      var onClose = (0, _rcUtil.createChainedFunction)(_this.remove.bind(_this, notice.key), notice.onClose);
	      return _react2['default'].createElement(_Notice2['default'], _extends({ prefixCls: props.prefixCls }, notice, { onClose: onClose }), notice.content);
	    });
	    var className = (_className = {}, _defineProperty(_className, props.prefixCls, 1), _defineProperty(_className, props.className, !!props.className), _className);
	    return _react2['default'].createElement('div', { className: (0, _rcUtil.classSet)(className), style: props.style }, _react2['default'].createElement(_rcAnimate2['default'], { transitionName: this.getTransitionName() }, noticeNodes));
	  }
	});

	Notification.newInstance = function (properties) {
	  var props = properties || {};
	  var div = document.createElement('div');
	  document.body.appendChild(div);
	  var notification = _reactDom2['default'].render(_react2['default'].createElement(Notification, props), div);
	  return {
	    notice: function notice(noticeProps) {
	      notification.add(noticeProps);
	    },
	    removeNotice: function removeNotice(key) {
	      notification.remove(key);
	    },
	    component: notification,
	    destroy: function destroy() {
	      _reactDom2['default'].unmountComponentAtNode(div);
	      document.body.removeChild(div);
	    }
	  };
	};

	exports['default'] = Notification;
	module.exports = exports['default'];

/***/ },
/* 716 */
[770, 717],
/* 717 */
[771, 718, 719, 724],
/* 718 */
76,
/* 719 */
[772, 720, 724],
/* 720 */
[773, 721, 722],
/* 721 */
79,
/* 722 */
[774, 723, 723],
/* 723 */
81,
/* 724 */
82,
/* 725 */
[789, 726, 727, 728, 729, 730, 731, 732, 733, 738, 739, 740],
/* 726 */
440,
/* 727 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

		module.exports = __webpack_require__(5);

/***/ },
/* 728 */
442,
/* 729 */
443,
/* 730 */
[790, 731],
/* 731 */
445,
/* 732 */
446,
/* 733 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var addDOMEventListener = __webpack_require__(734);

	module.exports = addDOMEventListener['default'] || addDOMEventListener;

/***/ },
/* 734 */
[756, 735],
/* 735 */
[757, 736, 737],
/* 736 */
32,
/* 737 */
33,
/* 738 */
448,
/* 739 */
449,
/* 740 */
450,
/* 741 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	  } else {
	    obj[key] = value;
	  }return obj;
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _rcUtil = __webpack_require__(725);

	var Notice = _react2['default'].createClass({
	  displayName: 'Notice',

	  propTypes: {
	    duration: _react2['default'].PropTypes.number,
	    onClose: _react2['default'].PropTypes.func,
	    children: _react2['default'].PropTypes.any
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      onEnd: function onEnd() {},
	      duration: 1.5,
	      style: {
	        right: '50%'
	      }
	    };
	  },

	  componentDidMount: function componentDidMount() {
	    var _this = this;

	    this.clearCloseTimer();
	    if (this.props.duration) {
	      this.closeTimer = setTimeout(function () {
	        _this.close();
	      }, this.props.duration * 1000);
	    }
	  },

	  componentDidUpdate: function componentDidUpdate() {
	    this.componentDidMount();
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    this.clearCloseTimer();
	  },

	  clearCloseTimer: function clearCloseTimer() {
	    if (this.closeTimer) {
	      clearTimeout(this.closeTimer);
	      this.closeTimer = null;
	    }
	  },

	  close: function close() {
	    this.clearCloseTimer();
	    this.props.onClose();
	  },

	  render: function render() {
	    var _className;

	    var props = this.props;
	    var componentClass = props.prefixCls + '-notice';
	    var className = (_className = {}, _defineProperty(_className, '' + componentClass, 1), _defineProperty(_className, componentClass + '-closable', props.closable), _defineProperty(_className, props.className, !!props.className), _className);
	    return _react2['default'].createElement('div', { className: (0, _rcUtil.classSet)(className), style: props.style }, _react2['default'].createElement('div', { className: componentClass + '-content' }, this.props.children), props.closable ? _react2['default'].createElement('a', { tabIndex: '0', onClick: this.close, className: componentClass + '-close' }, _react2['default'].createElement('span', { className: componentClass + '-close-x' })) : null);
	  }
	});

	exports['default'] = Notice;
	module.exports = exports['default'];

/***/ },
/* 742 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Pickable Component for uxcore
	 * @author onbing
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

		module.exports = __webpack_require__(743);

/***/ },
/* 743 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	function _possibleConstructorReturn(self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	/**
	 * Pickable Component for uxcore
	 * @author onbing
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

	var classnames = __webpack_require__(5);
	var React = __webpack_require__(3);
	var ReactDOM = __webpack_require__(4);

	var Items = function () {
	  function Items(props, onChange) {
	    _classCallCheck(this, Items);

	    this.onChange = onChange;
	    this.initItems(props.items || []);
	  }

	  Items.prototype.initItems = function initItems(items) {
	    var _this = this;

	    this.items = items ? items.map(function (item) {
	      return new Item(_this, item);
	    }) : [];
	  };

	  Items.prototype.getItems = function getItems() {
	    return this.items;
	  };

	  Items.prototype.removeItem = function removeItem(item) {
	    // trigger
	    var i = this.items.indexOf(item);
	    if (i < 0) {
	      return;
	    }
	    this.items.splice(i, 1);
	    this.onChange(this.getValues(), this.items);
	  };

	  Items.prototype.clear = function clear() {
	    this.items = [];
	    this.onChange([], []);
	  };

	  Items.prototype.checkChange = function checkChange() {
	    this.onChange(this.getCheckedValues(), this.items.map(function (item) {
	      return {
	        text: item.getText(),
	        value: item.getValue(),
	        checked: item.isChecked()
	      };
	    }));
	  };

	  Items.prototype.clearCheck = function clearCheck() {
	    this.items.forEach(function (item) {
	      return item.unCheck();
	    });
	    this.checkChange();
	  };

	  Items.prototype.getCheckedValues = function getCheckedValues() {
	    return this.items.filter(function (item) {
	      return item.isChecked();
	    }).map(function (item) {
	      return item.getValue();
	    });
	  };

	  Items.prototype.getValues = function getValues() {
	    return this.items.map(function (item) {
	      return item.getValue();
	    });
	  };

	  return Items;
	}();

	var Item = function () {
	  function Item(items, options) {
	    _classCallCheck(this, Item);

	    this.value = options.value;
	    this.text = options.text;
	    this.checked = options.checked;
	    this.items = items;
	  }

	  Item.prototype.getKey = function getKey() {
	    return JSON.stringify(this.value) + "-" + this.text;
	  };

	  Item.prototype.remove = function remove() {
	    this.items.removeItem(this);
	  };

	  Item.prototype.unCheck = function unCheck() {
	    this.checked = false;
	  };

	  Item.prototype.isChecked = function isChecked() {
	    return this.checked;
	  };

	  Item.prototype.toggle = function toggle() {
	    if (this.checked) {
	      this.checked = false;
	    } else {
	      this.checked = true;
	    }
	    this.items.checkChange();
	  };

	  Item.prototype.getText = function getText() {
	    return this.text;
	  };

	  Item.prototype.getValue = function getValue() {
	    return this.value;
	  };

	  return Item;
	}();

	var Pickable = function (_React$Component) {
	  _inherits(Pickable, _React$Component);

	  function Pickable(props) {
	    _classCallCheck(this, Pickable);

	    var _this2 = _possibleConstructorReturn(this, _React$Component.call(this, props));

	    _this2.items = new Items(_this2.props, _this2.onChange.bind(_this2));
	    return _this2;
	  }

	  Pickable.prototype.onChange = function onChange(values, items) {
	    this.props.onChange && this.props.onChange(values, items);
	    this.setState({});
	  };

	  Pickable.prototype.values = function values() {
	    return this.items.getCheckedValues();
	  };

	  Pickable.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	    if (nextProps.items) {
	      this.items.initItems(nextProps.items);
	    }
	  };

	  Pickable.prototype.render = function render() {
	    var _this3 = this;

	    var items = this.items.getCheckedValues();
	    var hideClear = this.props.autoHideClear && items.length < 1;
	    return React.createElement('ul', { className: classnames("kuma-pickable", this.props.className) }, this.items.getItems().map(function (item) {
	      return React.createElement('li', { key: item.getKey(), className: classnames("kuma-pickable-item", item.isChecked() && "checked"), onClick: function onClick() {
	          item.toggle();
	        } }, React.createElement('span', { className: 'kuma-pickable-text' }, item.getText()), item.isChecked() && React.createElement('i', { className: 'kuma-icon kuma-icon-choose badge' }));
	    }), this.props.hasClear && !hideClear && React.createElement('li', { className: 'kuma-pickable-clear', onClick: function onClick() {
	        _this3.items.clearCheck();
	      } }, '清除所选'));
	  };

	  return Pickable;
	}(React.Component);

	var Removeable = function (_React$Component2) {
	  _inherits(Removeable, _React$Component2);

	  function Removeable(props) {
	    _classCallCheck(this, Removeable);

	    var _this4 = _possibleConstructorReturn(this, _React$Component2.call(this, props));

	    _this4.items = new Items(_this4.props, _this4.onChange.bind(_this4));
	    return _this4;
	  }

	  Removeable.prototype.onChange = function onChange(values, items) {
	    this.props.onChange && this.props.onChange(values, items);
	    this.setState({});
	  };

	  Removeable.prototype.values = function values() {
	    return this.items.getValues();
	  };

	  Removeable.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	    if (nextProps.items) {
	      this.items.initItems(nextProps.items);
	    }
	  };

	  Removeable.prototype.render = function render() {
	    var _this5 = this;

	    var items = this.items.getItems();
	    var hideClear = this.props.autoHideClear && items.length < 1;
	    return React.createElement('ul', { className: classnames("kuma-pickable", "kuma-pickable-removeable", this.props.className) }, items.map(function (item) {
	      return React.createElement('li', { key: item.getKey(), className: 'kuma-pickable-item' }, React.createElement('span', { className: 'kuma-pickable-text' }, item.getText()), React.createElement('i', { className: 'kuma-icon kuma-icon-close remover', onClick: function onClick() {
	          return item.remove();
	        } }));
	    }), this.props.hasClear && !hideClear && React.createElement('li', { className: 'kuma-pickable-clear', onClick: function onClick() {
	        _this5.items.clear();
	      } }, '清除所选'));
	  };

	  return Removeable;
	}(React.Component);

	Removeable.defaultProps = {
	  items: null,
	  hasClear: true,
	  autoHideClear: true,
	  onChange: null
	};

	// http://facebook.github.io/react/docs/reusable-components.html
	Removeable.propTypes = {
	  hasClear: React.PropTypes.bool,
	  autoHideClear: React.PropTypes.bool,
	  items: React.PropTypes.array,
	  onChange: React.PropTypes.func
	};

	Removeable.displayName = "Removeable";

	Pickable.Removeable = Removeable;

	Pickable.defaultProps = {
	  items: null,
	  hasClear: true,
	  autoHideClear: true,
	  onChange: null
	};

	// http://facebook.github.io/react/docs/reusable-components.html
	Pickable.propTypes = {
	  hasClear: React.PropTypes.bool,
	  autoHideClear: React.PropTypes.bool,
	  items: React.PropTypes.array,
	  onChange: React.PropTypes.func
	};

	Pickable.displayName = "Pickable";

	module.exports = Pickable;

/***/ },
/* 744 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * PrimaryNav Component for uxcore
	 * @author eternaslky
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

		module.exports = __webpack_require__(745);

/***/ },
/* 745 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _classnames = __webpack_require__(5);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _uxcoreMenu = __webpack_require__(521);

	var _uxcoreMenu2 = _interopRequireDefault(_uxcoreMenu);

	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { "default": obj };
	}

	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}

	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	} /**
	   * PrimaryNav Component for uxcore
	   * @author eternaslky
	   *
	   * Copyright 2014-2015, Uxcore Team, Alinw.
	   * All rights reserved.
	   */

	var PrimaryNav = function (_React$Component) {
	    _inherits(PrimaryNav, _React$Component);

	    function PrimaryNav(props) {
	        _classCallCheck(this, PrimaryNav);

	        return _possibleConstructorReturn(this, _React$Component.call(this, props));
	    }

	    PrimaryNav.prototype.onSwitchLang = function onSwitchLang(e) {
	        e.preventDefault();
	        this.props.onChangeI18n(this.props.lang, e);
	    };

	    PrimaryNav.prototype.getPrimaryMenu = function getPrimaryMenu() {
	        var props = this.props;
	        return _react2["default"].createElement(_uxcoreMenu2["default"], { mode: 'horizontal', prefixCls: 'main-menu', selectedKeys: props.selectedKeys, defaultSelectedKeys: props.defaultSelectedKeys }, props.primaryNavItems.map(function (item, idx) {
	            var menuItem = void 0;
	            if (item.subItems && item.subItems.length > 0) {
	                menuItem = _react2["default"].createElement(_uxcoreMenu.SubMenu, { title: item.text, key: 'primary_item_' + idx }, item.subItems.map(function (subItem, subIdx) {
	                    return _react2["default"].createElement(_uxcoreMenu.Item, { key: 'primary_item_' + idx + '_' + subIdx }, subItem.text);
	                }));
	            } else {
	                menuItem = _react2["default"].createElement(_uxcoreMenu.Item, { key: 'primary_item_' + idx }, item.text);
	            }
	            return menuItem;
	        }));
	    };

	    PrimaryNav.prototype.getSecondaryMenu = function getSecondaryMenu() {
	        var props = this.props;
	        return _react2["default"].createElement(_uxcoreMenu2["default"], { mode: 'horizontal', prefixCls: 'secondary-menu' }, props.secondaryNavItems.map(function (item, idx) {
	            return _react2["default"].createElement(_uxcoreMenu.Item, { key: 'secondary_item_' + idx }, item.text);
	        }));
	    };

	    PrimaryNav.prototype.onClickSearchButton = function onClickSearchButton(e) {
	        var searchField = this.refs.searchField;
	        this.props.onSearch(searchField.value, searchField);
	    };

	    PrimaryNav.prototype.onPressField = function onPressField(e) {
	        if (e.keyCode === 13) {
	            var searchField = this.refs.searchField;
	            this.props.onSearch(searchField.value, searchField);
	        }
	    };

	    PrimaryNav.prototype.render = function render() {
	        var props = this.props,
	            langSwitch = void 0,
	            ret = void 0,
	            navClass = void 0,
	            searchField = void 0;
	        if (props.hasGlobalSearch) {
	            searchField = _react2["default"].createElement('div', { className: 'navigation-search' }, _react2["default"].createElement('input', {
	                ref: 'searchField',
	                type: 'text',
	                className: 'navigation-search-field',
	                onKeyUp: this.onPressField.bind(this),
	                placeholder: props.searchPlaceholder }), _react2["default"].createElement('button', { className: 'navigation-search-button', onClick: this.onClickSearchButton.bind(this) }, _react2["default"].createElement('i', { className: 'kuma-icon kuma-icon-search' })));
	        }
	        if (props.fullWidth) {
	            if (props.showLangSwitch) {
	                langSwitch = _react2["default"].createElement('a', { href: '#', onClick: this.onSwitchLang.bind(this), className: 'lang-switch' }, props.lang);
	            } else {
	                langSwitch = null;
	            }
	            navClass = (0, _classnames2["default"])({
	                'kuma-container-full': true,
	                'kuma-primary-navigation': true,
	                'kuma-primary-navigation-search': props.hasGlobalSearch,
	                'kuma-nw-uxcore': true,
	                'lang-en': props.locale === 'en',
	                'logo_ali': props.logoType === 'ali'
	            });
	            ret = _react2["default"].createElement('div', { className: navClass }, _react2["default"].createElement('div', { className: 'kuma-pn-brand' }, _react2["default"].createElement('a', { href: 'https://work.alibaba-inc.com', className: 'site-logo', target: '_blank' }), _react2["default"].createElement('h2', { className: 'site-brand' }, _react2["default"].createElement('a', { href: props.systemLink }, props.systemName))), _react2["default"].createElement('div', { className: 'kuma-pn-main' }, searchField, _react2["default"].createElement('div', { className: 'kuma-pn-menu' }, this.getPrimaryMenu()), _react2["default"].createElement('div', { className: 'kuma-pn-lang' }, langSwitch), _react2["default"].createElement('div', { className: 'kuma-pn-secondary-menu' }, this.getSecondaryMenu())));
	        } else {
	            if (props.showLangSwitch) {
	                langSwitch = _react2["default"].createElement('a', { href: '#', onClick: this.onSwitchLang.bind(this), className: 'lang-switch' }, props.lang);
	            } else {
	                langSwitch = null;
	            }
	            navClass = (0, _classnames2["default"])({
	                'fn-border-box': true,
	                'kuma-primary-navigation': true,
	                'kuma-primary-navigation-search': props.hasGlobalSearch,
	                'kuma-nw-uxcore': true,
	                'lang-en': props.locale === 'en',
	                'logo_ali': props.logoType === 'ali'
	            });
	            var content = void 0;
	            if (props.hasGlobalSearch) {
	                ret = _react2["default"].createElement('div', { className: navClass }, _react2["default"].createElement('div', { className: 'kuma-container-1180' }, _react2["default"].createElement('div', { className: 'kuma-row' }, _react2["default"].createElement('div', { className: 'col-xs-7' }, _react2["default"].createElement('a', { href: 'https://work.alibaba-inc.com', className: 'site-logo', target: '_blank' }), _react2["default"].createElement('h2', { className: 'site-brand' }, _react2["default"].createElement('a', { href: props.systemLink }, props.systemName))), _react2["default"].createElement('div', { className: 'col-xs-7' }, searchField), _react2["default"].createElement('div', { className: 'col-xs-8' }, this.getPrimaryMenu()), _react2["default"].createElement('div', { className: 'col-xs-2' }, _react2["default"].createElement('div', { className: 'site-right' }, langSwitch)))));
	            } else {
	                ret = _react2["default"].createElement('div', { className: navClass }, _react2["default"].createElement('div', { className: 'kuma-container-1180' }, _react2["default"].createElement('div', { className: 'kuma-row' }, _react2["default"].createElement('div', { className: 'col-xs-7' }, _react2["default"].createElement('a', { href: 'https://work.alibaba-inc.com', className: 'site-logo', target: '_blank' }), _react2["default"].createElement('h2', { className: 'site-brand' }, _react2["default"].createElement('a', { href: props.systemLink }, props.systemName))), _react2["default"].createElement('div', { className: 'col-xs-11' }, this.getPrimaryMenu()), _react2["default"].createElement('div', { className: 'col-xs-6' }, _react2["default"].createElement('div', { className: 'site-right' }, this.getSecondaryMenu(), langSwitch)))));
	            }
	        }
	        return ret;
	    };

	    return PrimaryNav;
	}(_react2["default"].Component);

	PrimaryNav.defaultProps = {
	    systemName: '系统名称',
	    primaryNavItems: [],
	    secondaryNavItems: [],
	    showLangSwitch: true,
	    lang: 'EN',
	    fullWidth: false,
	    onChangeI18n: function onChangeI18n(lang, e) {},
	    locale: 'zh-cn',
	    systemLink: '#',
	    hasGlobalSearch: false,
	    searchPlaceholder: '搜索',
	    onSearch: function onSearch(value, input) {},
	    selectedKeys: [],
	    defaultSelectedKeys: [],
	    logoType: 'default'
	};

	// http://facebook.github.io/react/docs/reusable-components.html
	PrimaryNav.propTypes = {
	    systemName: _react2["default"].PropTypes.string,
	    primaryNavItems: _react2["default"].PropTypes.array,
	    secondaryNavItems: _react2["default"].PropTypes.array,
	    showLangSwitch: _react2["default"].PropTypes.bool,
	    fullWidth: _react2["default"].PropTypes.bool,
	    lang: _react2["default"].PropTypes.string,
	    onChangeI18n: _react2["default"].PropTypes.func,
	    locale: _react2["default"].PropTypes.oneOf(['zh-cn', 'en']),
	    systemLink: _react2["default"].PropTypes.string,
	    hasGlobalSearch: _react2["default"].PropTypes.bool,
	    searchPlaceholder: _react2["default"].PropTypes.string,
	    onSearch: _react2["default"].PropTypes.func,
	    selectedKeys: _react2["default"].PropTypes.array,
	    defaultSelectedKeys: _react2["default"].PropTypes.array,
	    logoType: _react2["default"].PropTypes.oneOf(['default', 'ali'])
	};

	PrimaryNav.displayName = 'PrimaryNav';

	module.exports = PrimaryNav;

/***/ },
/* 746 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	/**
	 * Calendar Component for uxcore
	 * @author 
	 *
	 * Copyright 2014-2015, Uxcore Team, Alinw.
	 * All rights reserved.
	 */

		module.exports = __webpack_require__(__webpack_module_template_argument_0__);

/***/ },
/* 747 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__) {

	/*
	 * GregorianCalendar class
	 * @ignore
	 * @author yiminghe@gmail.com
	 */
	'use strict';

	var toInt = parseInt;
	var Utils = __webpack_require__(__webpack_module_template_argument_0__);
	var defaultLocale = __webpack_require__(__webpack_module_template_argument_1__);
	var Const = __webpack_require__(__webpack_module_template_argument_2__);

	/*
	 * GregorianCalendar class.
	 *
	 * - no arguments:
	 *   Constructs a default GregorianCalendar using the current time
	 *   in the default time zone with the default locale.
	 * - one argument locale:
	 *   Constructs a GregorianCalendar
	 *   based on the current time in the default time zone with the given locale.
	 *
	 * @class Date.Gregorian
	 */
	function GregorianCalendar(loc) {
	  var locale = loc || defaultLocale;

	  this.locale = locale;

	  this.fields = [];

	  /*
	   * The currently set time for this date.
	   * @protected
	   * @type Number|undefined
	   */
	  this.time = undefined;
	  /*
	   * The timezoneOffset in minutes used by this date.
	   * @type Number
	   * @protected
	   */

	  this.timezoneOffset = locale.timezoneOffset;

	  /*
	   * The first day of the week
	   * @type Number
	   * @protected
	   */
	  this.firstDayOfWeek = locale.firstDayOfWeek;

	  /*
	   * The number of days required for the first week in a month or year,
	   * with possible values from 1 to 7.
	   * @@protected
	   * @type Number
	   */
	  this.minimalDaysInFirstWeek = locale.minimalDaysInFirstWeek;

	  this.fieldsComputed = false;
	}

	Utils.mix(GregorianCalendar, Const);

	Utils.mix(GregorianCalendar, {
	  Utils: Utils,

	  defaultLocale: defaultLocale,

	  /*
	   * Determines if the given year is a leap year.
	   * Returns true if the given year is a leap year. To specify BC year numbers,
	   * 1 - year number must be given. For example, year BC 4 is specified as -3.
	   * @param {Number} year the given year.
	   * @returns {Boolean} true if the given year is a leap year; false otherwise.
	   * @static
	   * @method
	   */
	  isLeapYear: Utils.isLeapYear,

	  /*
	   * Enum indicating year field of date
	   * @type Number
	   */
	  YEAR: 1,
	  /*
	   * Enum indicating month field of date
	   * @type Number
	   */
	  MONTH: 2,
	  /*
	   * Enum indicating the day of the month
	   * @type Number
	   */
	  DAY_OF_MONTH: 3,
	  /*
	   * Enum indicating the hour (24).
	   * @type Number
	   */
	  HOUR_OF_DAY: 4,
	  /*
	   * Enum indicating the minute of the day
	   * @type Number
	   */
	  MINUTES: 5,
	  /*
	   * Enum indicating the second of the day
	   * @type Number
	   */
	  SECONDS: 6,
	  /*
	   * Enum indicating the millisecond of the day
	   * @type Number
	   */
	  MILLISECONDS: 7,
	  /*
	   * Enum indicating the week number within the current year
	   * @type Number
	   */
	  WEEK_OF_YEAR: 8,
	  /*
	   * Enum indicating the week number within the current month
	   * @type Number
	   */
	  WEEK_OF_MONTH: 9,

	  /*
	   * Enum indicating the day of the day number within the current year
	   * @type Number
	   */
	  DAY_OF_YEAR: 10,
	  /*
	   * Enum indicating the day of the week
	   * @type Number
	   */
	  DAY_OF_WEEK: 11,
	  /*
	   * Enum indicating the day of the ordinal number of the day of the week
	   * @type Number
	   */
	  DAY_OF_WEEK_IN_MONTH: 12,

	  /*
	   * Enum indicating am
	   * @type Number
	   */
	  AM: 0,
	  /*
	   * Enum indicating pm
	   * @type Number
	   */
	  PM: 1
	});

	var FIELDS = ['', 'Year', 'Month', 'DayOfMonth', 'HourOfDay', 'Minutes', 'Seconds', 'Milliseconds', 'WeekOfYear', 'WeekOfMonth', 'DayOfYear', 'DayOfWeek', 'DayOfWeekInMonth'];

	var YEAR = GregorianCalendar.YEAR;
	var MONTH = GregorianCalendar.MONTH;
	var DAY_OF_MONTH = GregorianCalendar.DAY_OF_MONTH;
	var HOUR_OF_DAY = GregorianCalendar.HOUR_OF_DAY;
	var MINUTE = GregorianCalendar.MINUTES;
	var SECONDS = GregorianCalendar.SECONDS;

	var MILLISECONDS = GregorianCalendar.MILLISECONDS;
	var DAY_OF_WEEK_IN_MONTH = GregorianCalendar.DAY_OF_WEEK_IN_MONTH;
	var DAY_OF_YEAR = GregorianCalendar.DAY_OF_YEAR;
	var DAY_OF_WEEK = GregorianCalendar.DAY_OF_WEEK;

	var WEEK_OF_MONTH = GregorianCalendar.WEEK_OF_MONTH;
	var WEEK_OF_YEAR = GregorianCalendar.WEEK_OF_YEAR;

	var MONTH_LENGTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; // 0-based
	var LEAP_MONTH_LENGTH = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; // 0-based

	var ONE_SECOND = 1000;
	var ONE_MINUTE = 60 * ONE_SECOND;
	var ONE_HOUR = 60 * ONE_MINUTE;
	var ONE_DAY = 24 * ONE_HOUR;
	var ONE_WEEK = ONE_DAY * 7;

	var EPOCH_OFFSET = 719163; // Fixed date of January 1, 1970 (Gregorian)

	var mod = Utils.mod;
	var _isLeapYear = Utils.isLeapYear;
	var floorDivide = Math.floor;

	var MIN_VALUES = [undefined, 1, // YEAR
	GregorianCalendar.JANUARY, // MONTH
	1, // DAY_OF_MONTH
	0, // HOUR_OF_DAY
	0, // MINUTE
	0, // SECONDS
	0, // MILLISECONDS

	1, // WEEK_OF_YEAR
	undefined, // WEEK_OF_MONTH

	1, // DAY_OF_YEAR
	GregorianCalendar.SUNDAY, // DAY_OF_WEEK
	1];

	// DAY_OF_WEEK_IN_MONTH
	var MAX_VALUES = [undefined, 292278994, // YEAR
	GregorianCalendar.DECEMBER, // MONTH
	undefined, // DAY_OF_MONTH
	23, // HOUR_OF_DAY
	59, // MINUTE
	59, // SECONDS
	999, // MILLISECONDS
	undefined, // WEEK_OF_YEAR
	undefined, // WEEK_OF_MONTH
	undefined, // DAY_OF_YEAR
	GregorianCalendar.SATURDAY, // DAY_OF_WEEK
	undefined];

	// ------------------- private start

	// DAY_OF_WEEK_IN_MONTH
	function getMonthLength(year, month) {
	  return _isLeapYear(year) ? LEAP_MONTH_LENGTH[month] : MONTH_LENGTH[month];
	}

	function getYearLength(year) {
	  return _isLeapYear(year) ? 366 : 365;
	}

	function adjustDayOfMonth(self) {
	  var fields = self.fields;
	  var year = fields[YEAR];
	  var month = fields[MONTH];
	  var monthLen = getMonthLength(year, month);
	  var dayOfMonth = fields[DAY_OF_MONTH];
	  if (dayOfMonth > monthLen) {
	    self.set(DAY_OF_MONTH, monthLen);
	  }
	}

	function getDayOfWeekDateOnOrBefore(fixedDate, dayOfWeek) {
	  // 1.1.1 is monday
	  // one week has 7 days
	  return fixedDate - mod(fixedDate - dayOfWeek, 7);
	}

	function getWeekNumber(self, fixedDay1, fixedDate) {
	  var fixedDay1st = getDayOfWeekDateOnOrBefore(fixedDay1 + 6, self.firstDayOfWeek);
	  var nDays = fixedDay1st - fixedDay1;
	  if (nDays >= self.minimalDaysInFirstWeek) {
	    fixedDay1st -= 7;
	  }
	  var normalizedDayOfPeriod = fixedDate - fixedDay1st;
	  return floorDivide(normalizedDayOfPeriod / 7) + 1;
	}

	// ------------------- private end

	GregorianCalendar.prototype = {
	  constructor: GregorianCalendar,

	  isGregorianCalendar: 1,

	  /*
	   * Determines if current year is a leap year.
	   * Returns true if the given year is a leap year. To specify BC year numbers,
	   * 1 - year number must be given. For example, year BC 4 is specified as -3.
	   * @returns {Boolean} true if the given year is a leap year; false otherwise.
	   * @method
	   * @member Date.Gregorian
	   */
	  isLeapYear: function isLeapYear() {
	    return _isLeapYear(this.getYear());
	  },

	  /*
	   * Return local info for current date instance
	   * @returns {Object}
	   */
	  getLocale: function getLocale() {
	    return this.locale;
	  },

	  /*
	   * Returns the minimum value for
	   * the given calendar field of this GregorianCalendar instance.
	   * The minimum value is defined as the smallest value
	   * returned by the get method for any possible time value,
	   * taking into consideration the current values of the getFirstDayOfWeek,
	   * getMinimalDaysInFirstWeek.
	   * @param field the calendar field.
	   * @returns {Number} the minimum value for the given calendar field.
	   */
	  getActualMinimum: function getActualMinimum(field) {
	    if (MIN_VALUES[field] !== undefined) {
	      return MIN_VALUES[field];
	    }
	    if (field === WEEK_OF_MONTH) {
	      var cal = this.clone();
	      cal.clear();
	      cal.set(this.fields[YEAR], this.fields[MONTH], 1);
	      return cal.get(WEEK_OF_MONTH);
	    }

	    throw new Error('minimum value not defined!');
	  },

	  /*
	   * Returns the maximum value for the given calendar field
	   * of this GregorianCalendar instance.
	   * The maximum value is defined as the largest value returned
	   * by the get method for any possible time value, taking into consideration
	   * the current values of the getFirstDayOfWeek, getMinimalDaysInFirstWeek methods.
	   * @param field the calendar field.
	   * @returns {Number} the maximum value for the given calendar field.
	   */
	  getActualMaximum: function getActualMaximum(field) {
	    if (MAX_VALUES[field] !== undefined) {
	      return MAX_VALUES[field];
	    }
	    var value = undefined;
	    var fields = this.fields;
	    switch (field) {
	      case DAY_OF_MONTH:
	        value = getMonthLength(fields[YEAR], fields[MONTH]);
	        break;

	      case WEEK_OF_YEAR:
	        var endOfYear = this.clone();
	        endOfYear.clear();
	        endOfYear.set(fields[YEAR], GregorianCalendar.DECEMBER, 31);
	        value = endOfYear.get(WEEK_OF_YEAR);
	        if (value === 1) {
	          value = 52;
	        }
	        break;

	      case WEEK_OF_MONTH:
	        var endOfMonth = this.clone();
	        endOfMonth.clear();
	        endOfMonth.set(fields[YEAR], fields[MONTH], getMonthLength(fields[YEAR], fields[MONTH]));
	        value = endOfMonth.get(WEEK_OF_MONTH);
	        break;

	      case DAY_OF_YEAR:
	        value = getYearLength(fields[YEAR]);
	        break;

	      case DAY_OF_WEEK_IN_MONTH:
	        value = toInt((getMonthLength(fields[YEAR], fields[MONTH]) - 1) / 7) + 1;
	        break;
	      default:
	        break;
	    }
	    if (value === undefined) {
	      throw new Error('maximum value not defined!');
	    }
	    return value;
	  },

	  /*
	   * Determines if the given calendar field has a value set,
	   * including cases that the value has been set by internal fields calculations
	   * triggered by a get method call.
	   * @param field the calendar field to be cleared.
	   * @returns {boolean} true if the given calendar field has a value set; false otherwise.
	   */
	  isSet: function isSet(field) {
	    return this.fields[field] !== undefined;
	  },

	  /*
	   * Converts the time value (millisecond offset from the Epoch)
	   * to calendar field values.
	   * @protected
	   */
	  computeFields: function computeFields() {
	    var time = this.time;
	    var timezoneOffset = this.timezoneOffset * ONE_MINUTE;
	    var fixedDate = toInt(timezoneOffset / ONE_DAY);
	    var timeOfDay = timezoneOffset % ONE_DAY;
	    fixedDate += toInt(time / ONE_DAY);
	    timeOfDay += time % ONE_DAY;
	    if (timeOfDay >= ONE_DAY) {
	      timeOfDay -= ONE_DAY;
	      fixedDate++;
	    } else {
	      while (timeOfDay < 0) {
	        timeOfDay += ONE_DAY;
	        fixedDate--;
	      }
	    }

	    fixedDate += EPOCH_OFFSET;

	    var date = Utils.getGregorianDateFromFixedDate(fixedDate);

	    var year = date.year;

	    var fields = this.fields;
	    fields[YEAR] = year;
	    fields[MONTH] = date.month;
	    fields[DAY_OF_MONTH] = date.dayOfMonth;
	    fields[DAY_OF_WEEK] = date.dayOfWeek;

	    if (timeOfDay !== 0) {
	      fields[HOUR_OF_DAY] = toInt(timeOfDay / ONE_HOUR);
	      var r = timeOfDay % ONE_HOUR;
	      fields[MINUTE] = toInt(r / ONE_MINUTE);
	      r %= ONE_MINUTE;
	      fields[SECONDS] = toInt(r / ONE_SECOND);
	      fields[MILLISECONDS] = r % ONE_SECOND;
	    } else {
	      fields[HOUR_OF_DAY] = fields[MINUTE] = fields[SECONDS] = fields[MILLISECONDS] = 0;
	    }

	    var fixedDateJan1 = Utils.getFixedDate(year, GregorianCalendar.JANUARY, 1);
	    var dayOfYear = fixedDate - fixedDateJan1 + 1;
	    var fixDateMonth1 = fixedDate - date.dayOfMonth + 1;

	    fields[DAY_OF_YEAR] = dayOfYear;
	    fields[DAY_OF_WEEK_IN_MONTH] = toInt((date.dayOfMonth - 1) / 7) + 1;

	    var weekOfYear = getWeekNumber(this, fixedDateJan1, fixedDate);

	    // 本周没有足够的时间在当前年
	    if (weekOfYear === 0) {
	      // If the date belongs to the last week of the
	      // previous year, use the week number of "12/31" of
	      // the "previous" year.
	      var fixedDec31 = fixedDateJan1 - 1;
	      var prevJan1 = fixedDateJan1 - getYearLength(year - 1);
	      weekOfYear = getWeekNumber(this, prevJan1, fixedDec31);
	    } else
	      // 本周是年末最后一周，可能有足够的时间在新的一年
	      if (weekOfYear >= 52) {
	        var nextJan1 = fixedDateJan1 + getYearLength(year);
	        var nextJan1st = getDayOfWeekDateOnOrBefore(nextJan1 + 6, this.firstDayOfWeek);
	        var nDays = nextJan1st - nextJan1;
	        // 本周有足够天数在新的一年
	        if (nDays >= this.minimalDaysInFirstWeek &&
	        // 当天确实在本周，weekOfYear === 53 时是不需要这个判断
	        fixedDate >= nextJan1st - 7) {
	          weekOfYear = 1;
	        }
	      }

	    fields[WEEK_OF_YEAR] = weekOfYear;
	    fields[WEEK_OF_MONTH] = getWeekNumber(this, fixDateMonth1, fixedDate);

	    this.fieldsComputed = true;
	  },

	  /*
	   * Converts calendar field values to the time value
	   * (millisecond offset from the Epoch).
	   * @protected
	   */
	  computeTime: function computeTime() {
	    var year = undefined;
	    var fields = this.fields;
	    if (this.isSet(YEAR)) {
	      year = fields[YEAR];
	    } else {
	      year = new Date().getFullYear();
	    }
	    var timeOfDay = 0;
	    if (this.isSet(HOUR_OF_DAY)) {
	      timeOfDay += fields[HOUR_OF_DAY];
	    }
	    timeOfDay *= 60;
	    timeOfDay += fields[MINUTE] || 0;
	    timeOfDay *= 60;
	    timeOfDay += fields[SECONDS] || 0;
	    timeOfDay *= 1000;
	    timeOfDay += fields[MILLISECONDS] || 0;
	    var fixedDate = 0;
	    fields[YEAR] = year;
	    fixedDate = fixedDate + this.getFixedDate();
	    // millis represents local wall-clock time in milliseconds.
	    var millis = (fixedDate - EPOCH_OFFSET) * ONE_DAY + timeOfDay;
	    millis -= this.timezoneOffset * ONE_MINUTE;
	    this.time = millis;
	    this.computeFields();
	  },

	  /*
	   * Fills in any unset fields in the calendar fields. First,
	   * the computeTime() method is called if the time value (millisecond offset from the Epoch)
	   * has not been calculated from calendar field values.
	   * Then, the computeFields() method is called to calculate all calendar field values.
	   * @protected
	   */
	  complete: function complete() {
	    if (this.time === undefined) {
	      this.computeTime();
	    }
	    if (!this.fieldsComputed) {
	      this.computeFields();
	    }
	  },

	  getFixedDate: function getFixedDate() {
	    var self = this;

	    var fields = self.fields;

	    var firstDayOfWeekCfg = self.firstDayOfWeek;

	    var year = fields[YEAR];

	    var month = GregorianCalendar.JANUARY;

	    if (self.isSet(MONTH)) {
	      month = fields[MONTH];
	      if (month > GregorianCalendar.DECEMBER) {
	        year += toInt(month / 12);
	        month %= 12;
	      } else if (month < GregorianCalendar.JANUARY) {
	        year += floorDivide(month / 12);
	        month = mod(month, 12);
	      }
	    }

	    // Get the fixed date since Jan 1, 1 (Gregorian). We are on
	    // the first day of either `month' or January in 'year'.
	    var fixedDate = Utils.getFixedDate(year, month, 1);
	    var firstDayOfWeek = undefined;
	    var dayOfWeek = self.firstDayOfWeek;

	    if (self.isSet(DAY_OF_WEEK)) {
	      dayOfWeek = fields[DAY_OF_WEEK];
	    }

	    if (self.isSet(MONTH)) {
	      if (self.isSet(DAY_OF_MONTH)) {
	        fixedDate += fields[DAY_OF_MONTH] - 1;
	      } else {
	        if (self.isSet(WEEK_OF_MONTH)) {
	          firstDayOfWeek = getDayOfWeekDateOnOrBefore(fixedDate + 6, firstDayOfWeekCfg);

	          // If we have enough days in the first week, then
	          // move to the previous week.
	          if (firstDayOfWeek - fixedDate >= self.minimalDaysInFirstWeek) {
	            firstDayOfWeek -= 7;
	          }

	          if (dayOfWeek !== firstDayOfWeekCfg) {
	            firstDayOfWeek = getDayOfWeekDateOnOrBefore(firstDayOfWeek + 6, dayOfWeek);
	          }

	          fixedDate = firstDayOfWeek + 7 * (fields[WEEK_OF_MONTH] - 1);
	        } else {
	          var dowim = undefined;
	          if (self.isSet(DAY_OF_WEEK_IN_MONTH)) {
	            dowim = fields[DAY_OF_WEEK_IN_MONTH];
	          } else {
	            dowim = 1;
	          }
	          var lastDate = 7 * dowim;
	          if (dowim < 0) {
	            lastDate = getMonthLength(year, month) + 7 * (dowim + 1);
	          }
	          fixedDate = getDayOfWeekDateOnOrBefore(fixedDate + lastDate - 1, dayOfWeek);
	        }
	      }
	    } else {
	      // We are on the first day of the year.
	      if (self.isSet(DAY_OF_YEAR)) {
	        fixedDate += fields[DAY_OF_YEAR] - 1;
	      } else if (self.isSet(WEEK_OF_YEAR)) {
	        firstDayOfWeek = getDayOfWeekDateOnOrBefore(fixedDate + 6, firstDayOfWeekCfg);
	        // If we have enough days in the first week, then move
	        // to the previous week.
	        if (firstDayOfWeek - fixedDate >= self.minimalDaysInFirstWeek) {
	          firstDayOfWeek -= 7;
	        }
	        if (dayOfWeek !== firstDayOfWeekCfg) {
	          firstDayOfWeek = getDayOfWeekDateOnOrBefore(firstDayOfWeek + 6, dayOfWeek);
	        }
	        fixedDate = firstDayOfWeek + 7 * (fields[WEEK_OF_YEAR] - 1);
	      }
	    }

	    return fixedDate;
	  },

	  /*
	   * Returns this Calendar's time value in milliseconds
	   * @member Date.Gregorian
	   * @returns {Number} the current time as UTC milliseconds from the epoch.
	   */
	  getTime: function getTime() {
	    if (this.time === undefined) {
	      this.computeTime();
	    }
	    return this.time;
	  },

	  /*
	   * Sets this Calendar's current time from the given long value.
	   * @param time the new time in UTC milliseconds from the epoch.
	   */
	  setTime: function setTime(time) {
	    this.time = time;
	    this.fieldsComputed = false;
	    this.complete();
	  },

	  /*
	   * Returns the value of the given calendar field.
	   * @param field the given calendar field.
	   * @returns {Number} the value for the given calendar field.
	   */
	  get: function get(field) {
	    this.complete();
	    return this.fields[field];
	  },

	  /*
	   * Returns the year of the given calendar field.
	   * @method getYear
	   * @returns {Number} the year for the given calendar field.
	   */

	  /*
	   * Returns the month of the given calendar field.
	   * @method getMonth
	   * @returns {Number} the month for the given calendar field.
	   */

	  /*
	   * Returns the day of month of the given calendar field.
	   * @method getDayOfMonth
	   * @returns {Number} the day of month for the given calendar field.
	   */

	  /*
	   * Returns the hour of day of the given calendar field.
	   * @method getHourOfDay
	   * @returns {Number} the hour of day for the given calendar field.
	   */

	  /*
	   * Returns the minute of the given calendar field.
	   * @method getMinute
	   * @returns {Number} the minute for the given calendar field.
	   */

	  /*
	   * Returns the second of the given calendar field.
	   * @method getSecond
	   * @returns {Number} the second for the given calendar field.
	   */

	  /*
	   * Returns the millisecond of the given calendar field.
	   * @method getMilliSecond
	   * @returns {Number} the millisecond for the given calendar field.
	   */

	  /*
	   * Returns the week of year of the given calendar field.
	   * @method getWeekOfYear
	   * @returns {Number} the week of year for the given calendar field.
	   */

	  /*
	   * Returns the week of month of the given calendar field.
	   * @method getWeekOfMonth
	   * @returns {Number} the week of month for the given calendar field.
	   */

	  /*
	   * Returns the day of year of the given calendar field.
	   * @method getDayOfYear
	   * @returns {Number} the day of year for the given calendar field.
	   */

	  /*
	   * Returns the day of week of the given calendar field.
	   * @method getDayOfWeek
	   * @returns {Number} the day of week for the given calendar field.
	   */

	  /*
	   * Returns the day of week in month of the given calendar field.
	   * @method getDayOfWeekInMonth
	   * @returns {Number} the day of week in month for the given calendar field.
	   */

	  /*
	   * Sets the given calendar field to the given value.
	   * @param field the given calendar field.
	   * @param v the value to be set for the given calendar field.
	   */
	  set: function set(field, v) {
	    var len = arguments.length;
	    if (len === 2) {
	      this.fields[field] = v;
	    } else if (len < MILLISECONDS + 1) {
	      for (var i = 0; i < len; i++) {
	        this.fields[YEAR + i] = arguments[i];
	      }
	    } else {
	      throw new Error('illegal arguments for GregorianCalendar set');
	    }
	    this.time = undefined;
	  },

	  /*
	   * Set the year of the given calendar field.
	   * @method setYear
	   */

	  /*
	   * Set the month of the given calendar field.
	   * @method setMonth
	   */

	  /*
	   * Set the day of month of the given calendar field.
	   * @method setDayOfMonth
	   */

	  /*
	   * Set the hour of day of the given calendar field.
	   * @method setHourOfDay
	   */

	  /*
	   * Set the minute of the given calendar field.
	   * @method setMinute
	   */

	  /*
	   * Set the second of the given calendar field.
	   * @method setSecond
	   */

	  /*
	   * Set the millisecond of the given calendar field.
	   * @method setMilliSecond
	   */

	  /*
	   * Set the week of year of the given calendar field.
	   * @method setWeekOfYear
	   */

	  /*
	   * Set the week of month of the given calendar field.
	   * @method setWeekOfMonth
	   */

	  /*
	   * Set the day of year of the given calendar field.
	   * @method setDayOfYear
	   */

	  /*
	   * Set the day of week of the given calendar field.
	   * @method setDayOfWeek
	   */

	  /*
	   * Set the day of week in month of the given calendar field.
	   * @method setDayOfWeekInMonth
	   */

	  /*
	   * add for specified field based on two rules:
	   *
	   *  - Add rule 1. The value of field after the call minus the value of field before the
	   *  call is amount, modulo any overflow that has occurred in field
	   *  Overflow occurs when a field value exceeds its range and,
	   *  as a result, the next larger field is incremented or
	   *  decremented and the field value is adjusted back into its range.
	   *
	   *  - Add rule 2. If a smaller field is expected to be invariant,
	   *  but it is impossible for it to be equal to its
	   *  prior value because of changes in its minimum or maximum after
	   *  field is changed, then its value is adjusted to be as close
	   *  as possible to its expected value. A smaller field represents a
	   *  smaller unit of time. HOUR_OF_DAY is a smaller field than
	   *  DAY_OF_MONTH. No adjustment is made to smaller fields
	   *  that are not expected to be invariant. The calendar system
	   *  determines what fields are expected to be invariant.
	   *
	   *
	   *      @example
	   *      use('date/gregorian',function(S, GregorianCalendar){
	   *          const d = new GregorianCalendar();
	   *          d.set(2012, GregorianCalendar.JANUARY, 31);
	   *          d.add(Gregorian.MONTH,1);
	   *          // 2012-2-29
	   *          document.writeln('<p>'+d.getYear()+'-'+d.getMonth()+'-'+d.getDayOfWeek())
	   *          d.add(Gregorian.MONTH,12);
	   *          // 2013-2-28
	   *          document.writeln('<p>'+d.getYear()+'-'+d.getMonth()+'-'+d.getDayOfWeek())
	   *      });
	   *
	   * @param field the calendar field.
	   * @param {Number} amount he amount of date or time to be added to the field.
	   */
	  add: function add(field, a) {
	    if (!a) {
	      return;
	    }
	    var amount = a;
	    var self = this;
	    var fields = self.fields;
	    // computer and retrieve original value
	    var value = self.get(field);
	    if (field === YEAR) {
	      value += amount;
	      self.set(YEAR, value);
	      adjustDayOfMonth(self);
	    } else if (field === MONTH) {
	      value += amount;
	      var yearAmount = floorDivide(value / 12);
	      value = mod(value, 12);
	      if (yearAmount) {
	        self.set(YEAR, fields[YEAR] + yearAmount);
	      }
	      self.set(MONTH, value);
	      adjustDayOfMonth(self);
	    } else {
	      switch (field) {
	        case HOUR_OF_DAY:
	          amount *= ONE_HOUR;
	          break;
	        case MINUTE:
	          amount *= ONE_MINUTE;
	          break;
	        case SECONDS:
	          amount *= ONE_SECOND;
	          break;
	        case MILLISECONDS:
	          break;
	        case WEEK_OF_MONTH:
	        case WEEK_OF_YEAR:
	        case DAY_OF_WEEK_IN_MONTH:
	          amount *= ONE_WEEK;
	          break;
	        case DAY_OF_WEEK:
	        case DAY_OF_YEAR:
	        case DAY_OF_MONTH:
	          amount *= ONE_DAY;
	          break;
	        default:
	          throw new Error('illegal field for add');
	      }
	      self.setTime(self.time + amount);
	    }
	  },

	  /*
	   * add the year of the given calendar field.
	   * @method addYear
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * add the month of the given calendar field.
	   * @method addMonth
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * add the day of month of the given calendar field.
	   * @method addDayOfMonth
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * add the hour of day of the given calendar field.
	   * @method addHourOfDay
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * add the minute of the given calendar field.
	   * @method addMinute
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * add the second of the given calendar field.
	   * @method addSecond
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * add the millisecond of the given calendar field.
	   * @method addMilliSecond
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * add the week of year of the given calendar field.
	   * @method addWeekOfYear
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * add the week of month of the given calendar field.
	   * @method addWeekOfMonth
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * add the day of year of the given calendar field.
	   * @method addDayOfYear
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * add the day of week of the given calendar field.
	   * @method addDayOfWeek
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * add the day of week in month of the given calendar field.
	   * @method addDayOfWeekInMonth
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * Get rolled value for the field
	   * @protected
	   */
	  getRolledValue: function getRolledValue(value, a, min, max) {
	    var amount = a;
	    var diff = value - min;
	    var range = max - min + 1;
	    amount %= range;
	    return min + (diff + amount + range) % range;
	  },

	  /*
	   * Adds a signed amount to the specified calendar field without changing larger fields.
	   * A negative roll amount means to subtract from field without changing
	   * larger fields. If the specified amount is 0, this method performs nothing.
	   *
	   *
	   *
	   *      @example
	   *      const d = new GregorianCalendar();
	   *      d.set(1999, GregorianCalendar.AUGUST, 31);
	   *      // 1999-4-30
	   *      // Tuesday June 1, 1999
	   *      d.set(1999, GregorianCalendar.JUNE, 1);
	   *      d.add(Gregorian.WEEK_OF_MONTH,-1); // === d.add(Gregorian.WEEK_OF_MONTH,
	   *      d.get(Gregorian.WEEK_OF_MONTH));
	   *      // 1999-06-29
	   *
	   *
	   * @param field the calendar field.
	   * @param {Number} amount the signed amount to add to field.
	   */
	  roll: function roll(field, amount) {
	    if (!amount) {
	      return;
	    }
	    var self = this;
	    // computer and retrieve original value
	    var value = self.get(field);
	    var min = self.getActualMinimum(field);
	    var max = self.getActualMaximum(field);
	    value = self.getRolledValue(value, amount, min, max);

	    self.set(field, value);

	    // consider compute time priority
	    switch (field) {
	      case MONTH:
	        adjustDayOfMonth(self);
	        break;
	      default:
	        // other fields are set already when get
	        self.updateFieldsBySet(field);
	        break;
	    }
	  },

	  /*
	   * keep field stable.
	   *
	   * 2015-09-29 setMonth 2 vs rollSetMonth 2
	   *
	   */
	  rollSet: function rollSet(field, v) {
	    this.set(field, v);
	    switch (field) {
	      case MONTH:
	        adjustDayOfMonth(this);
	        break;
	      default:
	        // other fields are set already when get
	        this.updateFieldsBySet(field);
	        break;
	    }
	  },

	  /*
	   * roll the year of the given calendar field.
	   * @method rollYear
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * roll the month of the given calendar field.
	   * @param {Number} amount the signed amount to add to field.
	   * @method rollMonth
	   */

	  /*
	   * roll the day of month of the given calendar field.
	   * @method rollDayOfMonth
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * roll the hour of day of the given calendar field.
	   * @method rollHourOfDay
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * roll the minute of the given calendar field.
	   * @method rollMinute
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * roll the second of the given calendar field.
	   * @method rollSecond
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * roll the millisecond of the given calendar field.
	   * @method rollMilliSecond
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * roll the week of year of the given calendar field.
	   * @method rollWeekOfYear
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * roll the week of month of the given calendar field.
	   * @method rollWeekOfMonth
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * roll the day of year of the given calendar field.
	   * @method rollDayOfYear
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * roll the day of week of the given calendar field.
	   * @method rollDayOfWeek
	   * @param {Number} amount the signed amount to add to field.
	   */

	  /*
	   * remove other priority fields when call getFixedDate
	   * precondition: other fields are all set or computed
	   * @protected
	   */
	  updateFieldsBySet: function updateFieldsBySet(field) {
	    var fields = this.fields;
	    switch (field) {
	      case WEEK_OF_MONTH:
	        fields[DAY_OF_MONTH] = undefined;
	        break;
	      case DAY_OF_YEAR:
	        fields[MONTH] = undefined;
	        break;
	      case DAY_OF_WEEK:
	        fields[DAY_OF_MONTH] = undefined;
	        break;
	      case WEEK_OF_YEAR:
	        fields[DAY_OF_YEAR] = undefined;
	        fields[MONTH] = undefined;
	        break;
	      default:
	        break;
	    }
	  },

	  /*
	   * get current date instance's timezone offset
	   * @returns {Number}
	   */
	  getTimezoneOffset: function getTimezoneOffset() {
	    return this.timezoneOffset;
	  },

	  /*
	   * set current date instance's timezone offset
	   */
	  setTimezoneOffset: function setTimezoneOffset(timezoneOffset) {
	    if (this.timezoneOffset !== timezoneOffset) {
	      this.fieldsComputed = undefined;
	      this.timezoneOffset = timezoneOffset;
	    }
	  },

	  /*
	   * set first day of week for current date instance
	   */
	  setFirstDayOfWeek: function setFirstDayOfWeek(firstDayOfWeek) {
	    if (this.firstDayOfWeek !== firstDayOfWeek) {
	      this.firstDayOfWeek = firstDayOfWeek;
	      this.fieldsComputed = false;
	    }
	  },

	  /*
	   * Gets what the first day of the week is; e.g., SUNDAY in the U.S., MONDAY in France.
	   * @returns {Number} the first day of the week.
	   */
	  getFirstDayOfWeek: function getFirstDayOfWeek() {
	    return this.firstDayOfWeek;
	  },

	  /*
	   * Sets what the minimal days required in the first week of the year are; For example,
	   * if the first week is defined as one that contains the first day of the first month of a year,
	   * call this method with value 1.
	   * If it must be a full week, use value 7.
	   * @param minimalDaysInFirstWeek the given minimal days required in the first week of the year.
	   */
	  setMinimalDaysInFirstWeek: function setMinimalDaysInFirstWeek(minimalDaysInFirstWeek) {
	    if (this.minimalDaysInFirstWeek !== minimalDaysInFirstWeek) {
	      this.minimalDaysInFirstWeek = minimalDaysInFirstWeek;
	      this.fieldsComputed = false;
	    }
	  },

	  /*
	   * Gets what the minimal days required in the first week of the year are; e.g.,
	   * if the first week is defined as one that contains the first day of the first month of a year,
	   * this method returns 1.
	   * If the minimal days required must be a full week, this method returns 7.
	   * @returns {Number} the minimal days required in the first week of the year.
	   */
	  getMinimalDaysInFirstWeek: function getMinimalDaysInFirstWeek() {
	    return this.minimalDaysInFirstWeek;
	  },

	  /*
	   * Returns the number of weeks in the week year
	   * represented by this GregorianCalendar.
	   *
	   * For example, if this GregorianCalendar's date is
	   * December 31, 2008 with the ISO
	   * 8601 compatible setting, this method will return 53 for the
	   * period: December 29, 2008 to January 3, 2010
	   * while getActualMaximum(WEEK_OF_YEAR) will return
	   * 52 for the period: December 31, 2007 to December 28, 2008.
	   *
	   * @return {Number} the number of weeks in the week year.
	   */
	  getWeeksInWeekYear: function getWeeksInWeekYear() {
	    var weekYear = this.getWeekYear();
	    if (weekYear === this.get(YEAR)) {
	      return this.getActualMaximum(WEEK_OF_YEAR);
	    }
	    // Use the 2nd week for calculating the max of WEEK_OF_YEAR
	    var gc = this.clone();
	    gc.clear();
	    gc.setWeekDate(weekYear, 2, this.get(DAY_OF_WEEK));
	    return gc.getActualMaximum(WEEK_OF_YEAR);
	  },

	  /*
	   * Returns the week year represented by this GregorianCalendar.
	   * The dates in the weeks between 1 and the
	   * maximum week number of the week year have the same week year value
	   * that may be one year before or after the calendar year value.
	   *
	   * @return {Number} the week year represented by this GregorianCalendar.
	   */
	  getWeekYear: function getWeekYear() {
	    var year = this.get(YEAR); // implicitly  complete
	    var weekOfYear = this.get(WEEK_OF_YEAR);
	    var month = this.get(MONTH);
	    if (month === GregorianCalendar.JANUARY) {
	      if (weekOfYear >= 52) {
	        --year;
	      }
	    } else if (month === GregorianCalendar.DECEMBER) {
	      if (weekOfYear === 1) {
	        ++year;
	      }
	    }
	    return year;
	  },
	  /*
	   * Sets this GregorianCalendar to the date given by the date specifiers - weekYear,
	   * weekOfYear, and dayOfWeek. weekOfYear follows the WEEK_OF_YEAR numbering.
	   * The dayOfWeek value must be one of the DAY_OF_WEEK values: SUNDAY to SATURDAY.
	   *
	   * @param weekYear    the week year
	   * @param weekOfYear  the week number based on weekYear
	   * @param dayOfWeek   the day of week value
	   */
	  setWeekDate: function setWeekDate(weekYear, weekOfYear, dayOfWeek) {
	    if (dayOfWeek < GregorianCalendar.SUNDAY || dayOfWeek > GregorianCalendar.SATURDAY) {
	      throw new Error('invalid dayOfWeek: ' + dayOfWeek);
	    }
	    var fields = this.fields;
	    // To avoid changing the time of day fields by date
	    // calculations, use a clone with the GMT time zone.
	    var gc = this.clone();
	    gc.clear();
	    gc.setTimezoneOffset(0);
	    gc.set(YEAR, weekYear);
	    gc.set(WEEK_OF_YEAR, 1);
	    gc.set(DAY_OF_WEEK, this.getFirstDayOfWeek());
	    var days = dayOfWeek - this.getFirstDayOfWeek();
	    if (days < 0) {
	      days += 7;
	    }
	    days += 7 * (weekOfYear - 1);
	    if (days !== 0) {
	      gc.add(DAY_OF_YEAR, days);
	    } else {
	      gc.complete();
	    }
	    fields[YEAR] = gc.get(YEAR);
	    fields[MONTH] = gc.get(MONTH);
	    fields[DAY_OF_MONTH] = gc.get(DAY_OF_MONTH);
	    this.complete();
	  },
	  /*
	   * Creates and returns a copy of this object.
	   * @returns {Date.Gregorian}
	   */
	  clone: function clone() {
	    if (this.time === undefined) {
	      this.computeTime();
	    }
	    var cal = new GregorianCalendar(this.locale);
	    cal.setTimezoneOffset(cal.getTimezoneOffset());
	    cal.setFirstDayOfWeek(cal.getFirstDayOfWeek());
	    cal.setMinimalDaysInFirstWeek(cal.getMinimalDaysInFirstWeek());
	    cal.setTime(this.time);
	    return cal;
	  },

	  /*
	   * Compares this GregorianCalendar to the specified Object.
	   * The result is true if and only if the argument is a GregorianCalendar object
	   * that represents the same time value (millisecond offset from the Epoch)
	   * under the same Calendar parameters and Gregorian change date as this object.
	   * @param {Date.Gregorian} obj the object to compare with.
	   * @returns {boolean} true if this object is equal to obj; false otherwise.
	   */
	  equals: function equals(obj) {
	    return this.getTime() === obj.getTime() && this.firstDayOfWeek === obj.firstDayOfWeek && this.timezoneOffset === obj.timezoneOffset && this.minimalDaysInFirstWeek === obj.minimalDaysInFirstWeek;
	  },

	  compareToDay: function compareToDay(d2) {
	    var d1Year = this.getYear();
	    var d2Year = d2.getYear();
	    var d1Month = this.getMonth();
	    var d2Month = d2.getMonth();
	    var d1Day = this.getDayOfMonth();
	    var d2Day = d2.getDayOfMonth();
	    if (d1Year !== d2Year) {
	      return d1Year - d2Year;
	    }
	    if (d1Month !== d2Month) {
	      return d1Month - d2Month;
	    }
	    return d1Day - d2Day;
	  },

	  /*
	   * Sets all the calendar field values or specified field and the time value
	   * (millisecond offset from the Epoch) of this Calendar undefined.
	   * This means that isSet() will return false for all the calendar fields,
	   * and the date and time calculations will treat the fields as if they had never been set.
	   * @param [field] the calendar field to be cleared.
	   */
	  clear: function clear(field) {
	    if (field === undefined) {
	      this.field = [];
	    } else {
	      this.fields[field] = undefined;
	    }
	    this.time = undefined;
	    this.fieldsComputed = false;
	  },

	  toString: function toString() {
	    // for debug
	    var v = this;
	    return '[GregorianCalendar]: ' + v.getYear() + '/' + v.getMonth() + '/' + v.getDayOfMonth() + ' ' + v.getHourOfDay() + ':' + v.getMinutes() + ':' + v.getSeconds();
	  }
	};

	var GregorianCalendarProto = GregorianCalendar.prototype;

	Utils.each(FIELDS, function (f, index) {
	  if (f) {
	    GregorianCalendarProto['get' + f] = function get() {
	      return this.get(index);
	    };

	    GregorianCalendarProto['isSet' + f] = function isSet() {
	      return this.isSet(index);
	    };

	    GregorianCalendarProto['set' + f] = function set(v) {
	      return this.set(index, v);
	    };

	    GregorianCalendarProto['add' + f] = function add(v) {
	      return this.add(index, v);
	    };

	    GregorianCalendarProto['roll' + f] = function roll(v) {
	      return this.roll(index, v);
	    };

	    GregorianCalendarProto['rollSet' + f] = function rollSet(v) {
	      return this.rollSet(index, v);
	    };
	  }
	});

	module.exports = GregorianCalendar;
	/*
	 http://docs.oracle.com/javase/7/docs/api/java/util/GregorianCalendar.html

	 TODO
	 - day saving time
	 - i18n
	 - julian calendar
	 */

/***/ },
/* 748 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	/*
	 * utils for gregorian date
	 * @ignore
	 * @author yiminghe@gmail.com
	 */

	'use strict';

	var Const = __webpack_require__(__webpack_module_template_argument_0__);
	var floor = Math.floor;
	var ACCUMULATED_DAYS_IN_MONTH
	//   1/1 2/1 3/1 4/1 5/1 6/1 7/1 8/1 9/1 10/1 11/1 12/1
	= [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];

	var ACCUMULATED_DAYS_IN_MONTH_LEAP
	//   1/1 2/1   3/1   4/1   5/1   6/1   7/1   8/1   9/1
	// 10/1   11/1   12/1
	= [0, 31, 59 + 1, 90 + 1, 120 + 1, 151 + 1, 181 + 1, 212 + 1, 243 + 1, 273 + 1, 304 + 1, 334 + 1];

	var DAYS_OF_YEAR = 365;
	var DAYS_OF_4YEAR = 365 * 4 + 1;
	var DAYS_OF_100YEAR = DAYS_OF_4YEAR * 25 - 1;
	var DAYS_OF_400YEAR = DAYS_OF_100YEAR * 4 + 1;
	var _exports = {};

	function getDayOfYear(year, month, dayOfMonth) {
	  return dayOfMonth + (_exports.isLeapYear(year) ? ACCUMULATED_DAYS_IN_MONTH_LEAP[month] : ACCUMULATED_DAYS_IN_MONTH[month]);
	}

	function getDayOfWeekFromFixedDate(fixedDate) {
	  // The fixed day 1 (January 1, 1 Gregorian) is Monday.
	  if (fixedDate >= 0) {
	    return fixedDate % 7;
	  }
	  return _exports.mod(fixedDate, 7);
	}

	function getGregorianYearFromFixedDate(fixedDate) {
	  var d0 = undefined;
	  var d1 = undefined;
	  var d2 = undefined;
	  var d3 = undefined;
	  var n400 = undefined;
	  var n100 = undefined;
	  var n4 = undefined;
	  var n1 = undefined;
	  var year = undefined;
	  d0 = fixedDate - 1;

	  n400 = floor(d0 / DAYS_OF_400YEAR);
	  d1 = _exports.mod(d0, DAYS_OF_400YEAR);
	  n100 = floor(d1 / DAYS_OF_100YEAR);
	  d2 = _exports.mod(d1, DAYS_OF_100YEAR);
	  n4 = floor(d2 / DAYS_OF_4YEAR);
	  d3 = _exports.mod(d2, DAYS_OF_4YEAR);
	  n1 = floor(d3 / DAYS_OF_YEAR);

	  year = 400 * n400 + 100 * n100 + 4 * n4 + n1;

	  // ?
	  if (!(n100 === 4 || n1 === 4)) {
	    ++year;
	  }

	  return year;
	}

	_exports = module.exports = {
	  each: function each(arr, fn) {
	    for (var i = 0, len = arr.length; i < len; i++) {
	      if (fn(arr[i], i, arr) === false) {
	        break;
	      }
	    }
	  },

	  mix: function mix(t, s) {
	    for (var p in s) {
	      if (s.hasOwnProperty(p)) {
	        t[p] = s[p];
	      }
	    }
	  },

	  isLeapYear: function isLeapYear(year) {
	    if ((year & 3) !== 0) {
	      return false;
	    }
	    return year % 100 !== 0 || year % 400 === 0;
	  },

	  mod: function mod(x, y) {
	    // 负数时不是镜像关系
	    return x - y * floor(x / y);
	  },

	  // month: 0 based
	  getFixedDate: function getFixedDate(year, month, dayOfMonth) {
	    var prevYear = year - 1;
	    // 考虑公元前
	    return DAYS_OF_YEAR * prevYear + floor(prevYear / 4) - floor(prevYear / 100) + floor(prevYear / 400) + getDayOfYear(year, month, dayOfMonth);
	  },

	  getGregorianDateFromFixedDate: function getGregorianDateFromFixedDate(fixedDate) {
	    var year = getGregorianYearFromFixedDate(fixedDate);
	    var jan1 = _exports.getFixedDate(year, Const.JANUARY, 1);
	    var isLeap = _exports.isLeapYear(year);
	    var ACCUMULATED_DAYS = isLeap ? ACCUMULATED_DAYS_IN_MONTH_LEAP : ACCUMULATED_DAYS_IN_MONTH;
	    var daysDiff = fixedDate - jan1;
	    var month = undefined;

	    for (var i = 0; i < ACCUMULATED_DAYS.length; i++) {
	      if (ACCUMULATED_DAYS[i] <= daysDiff) {
	        month = i;
	      } else {
	        break;
	      }
	    }

	    var dayOfMonth = fixedDate - jan1 - ACCUMULATED_DAYS[month] + 1;
	    var dayOfWeek = getDayOfWeekFromFixedDate(fixedDate);

	    return {
	      year: year,
	      month: month,
	      dayOfMonth: dayOfMonth,
	      dayOfWeek: dayOfWeek,
	      isLeap: isLeap
	    };
	  }
		};

/***/ },
/* 749 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__, __webpack_module_template_argument_3__, __webpack_module_template_argument_4__, __webpack_module_template_argument_5__, __webpack_module_template_argument_6__, __webpack_module_template_argument_7__, __webpack_module_template_argument_8__, __webpack_module_template_argument_9__, __webpack_module_template_argument_10__) {

	'use strict';

	module.exports = {
	  guid: __webpack_require__(__webpack_module_template_argument_0__),
	  classSet: __webpack_require__(__webpack_module_template_argument_1__),
	  joinClasses: __webpack_require__(__webpack_module_template_argument_2__),
	  KeyCode: __webpack_require__(__webpack_module_template_argument_3__),
	  PureRenderMixin: __webpack_require__(__webpack_module_template_argument_4__),
	  shallowEqual: __webpack_require__(__webpack_module_template_argument_5__),
	  createChainedFunction: __webpack_require__(__webpack_module_template_argument_6__),
	  Dom: {
	    addEventListener: __webpack_require__(__webpack_module_template_argument_7__),
	    contains: __webpack_require__(__webpack_module_template_argument_8__)
	  },
	  Children: {
	    toArray: __webpack_require__(__webpack_module_template_argument_9__),
	    mapSelf: __webpack_require__(__webpack_module_template_argument_10__)
	  }
		};

/***/ },
/* 750 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	var deprecate = __webpack_require__(__webpack_module_template_argument_0__);
	var classNames = __webpack_require__(5);

	module.exports = deprecate(classNames, '`rcUtil.classSet()` is deprecated, use `classNames()` by `require(\'classnames\')` instead');

/***/ },
/* 751 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	var deprecate = __webpack_require__(__webpack_module_template_argument_0__);
	var classNames = __webpack_require__(5);

	module.exports = deprecate(classNames, '`rcUtil.joinClasses()` is deprecated, use `classNames()` by `require(\'classnames\')` instead');

/***/ },
/* 752 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	var shallowEqual = __webpack_require__(__webpack_module_template_argument_0__);

	/**
	 * If your React component's render function is "pure", e.g. it will render the
	 * same result given the same props and state, provide this Mixin for a
	 * considerable performance boost.
	 *
	 * Most React components have pure render functions.
	 *
	 * Example:
	 *
	 *   const ReactComponentWithPureRenderMixin =
	 *     require('ReactComponentWithPureRenderMixin');
	 *   React.createClass({
	 *     mixins: [ReactComponentWithPureRenderMixin],
	 *
	 *     render: function() {
	 *       return <div className={this.props.className}>foo</div>;
	 *     }
	 *   });
	 *
	 * Note: This only checks shallow equality for props and state. If these contain
	 * complex data structures this mixin may have false-negatives for deeper
	 * differences. Only mixin to components which have simple props and state, or
	 * use `forceUpdate()` when you know deep data structures have changed.
	 */
	var ReactComponentWithPureRenderMixin = {
	  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
	    return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState);
	  }
	};

		module.exports = ReactComponentWithPureRenderMixin;

/***/ },
/* 753 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var fetchKeys = __webpack_require__(__webpack_module_template_argument_0__);

	module.exports = function shallowEqual(objA, objB, compare, compareContext) {

	    var ret = compare ? compare.call(compareContext, objA, objB) : void 0;

	    if (ret !== void 0) {
	        return !!ret;
	    }

	    if (objA === objB) {
	        return true;
	    }

	    if ((typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object' || objB === null) {
	        return false;
	    }

	    var keysA = fetchKeys(objA);
	    var keysB = fetchKeys(objB);

	    var len = keysA.length;
	    if (len !== keysB.length) {
	        return false;
	    }

	    compareContext = compareContext || null;

	    // Test for A's keys different from B.
	    var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
	    for (var i = 0; i < len; i++) {
	        var key = keysA[i];
	        if (!bHasOwnProperty(key)) {
	            return false;
	        }
	        var valueA = objA[key];
	        var valueB = objB[key];

	        var _ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;
	        if (_ret === false || _ret === void 0 && valueA !== valueB) {
	            return false;
	        }
	    }

	    return true;
		};

/***/ },
/* 754 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	/**
	 * lodash 3.1.2 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	var getNative = __webpack_require__(__webpack_module_template_argument_0__),
	    isArguments = __webpack_require__(__webpack_module_template_argument_1__),
	    isArray = __webpack_require__(__webpack_module_template_argument_2__);

	/** Used to detect unsigned integer values. */
	var reIsUint = /^\d+$/;

	/** Used for native method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/* Native method references for those with the same name as other `lodash` methods. */
	var nativeKeys = getNative(Object, 'keys');

	/**
	 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
	 * of an array-like value.
	 */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new function.
	 */
	function baseProperty(key) {
	  return function (object) {
	    return object == null ? undefined : object[key];
	  };
	}

	/**
	 * Gets the "length" property value of `object`.
	 *
	 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
	 * that affects Safari on at least iOS 8.1-8.3 ARM64.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {*} Returns the "length" value.
	 */
	var getLength = baseProperty('length');

	/**
	 * Checks if `value` is array-like.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 */
	function isArrayLike(value) {
	  return value != null && isLength(getLength(value));
	}

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  value = typeof value == 'number' || reIsUint.test(value) ? +value : -1;
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return value > -1 && value % 1 == 0 && value < length;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 */
	function isLength(value) {
	  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * A fallback implementation of `Object.keys` which creates an array of the
	 * own enumerable property names of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function shimKeys(object) {
	  var props = keysIn(object),
	      propsLength = props.length,
	      length = propsLength && object.length;

	  var allowIndexes = !!length && isLength(length) && (isArray(object) || isArguments(object));

	  var index = -1,
	      result = [];

	  while (++index < propsLength) {
	    var key = props[index];
	    if (allowIndexes && isIndex(key, length) || hasOwnProperty.call(object, key)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	var keys = !nativeKeys ? shimKeys : function (object) {
	  var Ctor = object == null ? undefined : object.constructor;
	  if (typeof Ctor == 'function' && Ctor.prototype === object || typeof object != 'function' && isArrayLike(object)) {
	    return shimKeys(object);
	  }
	  return isObject(object) ? nativeKeys(object) : [];
	};

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn(object) {
	  if (object == null) {
	    return [];
	  }
	  if (!isObject(object)) {
	    object = Object(object);
	  }
	  var length = object.length;
	  length = length && isLength(length) && (isArray(object) || isArguments(object)) && length || 0;

	  var Ctor = object.constructor,
	      index = -1,
	      isProto = typeof Ctor == 'function' && Ctor.prototype === object,
	      result = Array(length),
	      skipIndexes = length > 0;

	  while (++index < length) {
	    result[index] = index + '';
	  }
	  for (var key in object) {
	    if (!(skipIndexes && isIndex(key, length)) && !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

		module.exports = keys;

/***/ },
/* 755 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = addEventListenerWrap;

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _addDomEventListener = __webpack_require__(__webpack_module_template_argument_0__);

	var _addDomEventListener2 = _interopRequireDefault(_addDomEventListener);

	var _reactDom = __webpack_require__(4);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	function addEventListenerWrap(target, eventType, cb) {
	  /* eslint camelcase: 2 */
	  var callback = _reactDom2['default'].unstable_batchedUpdates ? function run(e) {
	    _reactDom2['default'].unstable_batchedUpdates(cb, e);
	  } : cb;
	  return (0, _addDomEventListener2['default'])(target, eventType, callback);
	}

		module.exports = exports['default'];

/***/ },
/* 756 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = addEventListener;

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _EventObject = __webpack_require__(__webpack_module_template_argument_0__);

	var _EventObject2 = _interopRequireDefault(_EventObject);

	function addEventListener(target, eventType, callback) {
	  function wrapCallback(e) {
	    var ne = new _EventObject2['default'](e);
	    callback.call(target, ne);
	  }

	  if (target.addEventListener) {
	    target.addEventListener(eventType, wrapCallback, false);
	    return {
	      remove: function remove() {
	        target.removeEventListener(eventType, wrapCallback, false);
	      }
	    };
	  } else if (target.attachEvent) {
	    target.attachEvent('on' + eventType, wrapCallback);
	    return {
	      remove: function remove() {
	        target.detachEvent('on' + eventType, wrapCallback);
	      }
	    };
	  }
	}

		module.exports = exports['default'];

/***/ },
/* 757 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__) {

	/**
	 * @ignore
	 * event object for dom
	 * @author yiminghe@gmail.com
	 */

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _EventBaseObject = __webpack_require__(__webpack_module_template_argument_0__);

	var _EventBaseObject2 = _interopRequireDefault(_EventBaseObject);

	var _objectAssign = __webpack_require__(__webpack_module_template_argument_1__);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	var TRUE = true;
	var FALSE = false;
	var commonProps = ['altKey', 'bubbles', 'cancelable', 'ctrlKey', 'currentTarget', 'eventPhase', 'metaKey', 'shiftKey', 'target', 'timeStamp', 'view', 'type'];

	function isNullOrUndefined(w) {
	  return w === null || w === undefined;
	}

	var eventNormalizers = [{
	  reg: /^key/,
	  props: ['char', 'charCode', 'key', 'keyCode', 'which'],
	  fix: function fix(event, nativeEvent) {
	    if (isNullOrUndefined(event.which)) {
	      event.which = !isNullOrUndefined(nativeEvent.charCode) ? nativeEvent.charCode : nativeEvent.keyCode;
	    }

	    // add metaKey to non-Mac browsers (use ctrl for PC 's and Meta for Macs)
	    if (event.metaKey === undefined) {
	      event.metaKey = event.ctrlKey;
	    }
	  }
	}, {
	  reg: /^touch/,
	  props: ['touches', 'changedTouches', 'targetTouches']
	}, {
	  reg: /^hashchange$/,
	  props: ['newURL', 'oldURL']
	}, {
	  reg: /^gesturechange$/i,
	  props: ['rotation', 'scale']
	}, {
	  reg: /^(mousewheel|DOMMouseScroll)$/,
	  props: [],
	  fix: function fix(event, nativeEvent) {
	    var deltaX = undefined;
	    var deltaY = undefined;
	    var delta = undefined;
	    var wheelDelta = nativeEvent.wheelDelta;
	    var axis = nativeEvent.axis;
	    var wheelDeltaY = nativeEvent.wheelDeltaY;
	    var wheelDeltaX = nativeEvent.wheelDeltaX;
	    var detail = nativeEvent.detail;

	    // ie/webkit
	    if (wheelDelta) {
	      delta = wheelDelta / 120;
	    }

	    // gecko
	    if (detail) {
	      // press control e.detail == 1 else e.detail == 3
	      delta = 0 - (detail % 3 === 0 ? detail / 3 : detail);
	    }

	    // Gecko
	    if (axis !== undefined) {
	      if (axis === event.HORIZONTAL_AXIS) {
	        deltaY = 0;
	        deltaX = 0 - delta;
	      } else if (axis === event.VERTICAL_AXIS) {
	        deltaX = 0;
	        deltaY = delta;
	      }
	    }

	    // Webkit
	    if (wheelDeltaY !== undefined) {
	      deltaY = wheelDeltaY / 120;
	    }
	    if (wheelDeltaX !== undefined) {
	      deltaX = -1 * wheelDeltaX / 120;
	    }

	    // 默认 deltaY (ie)
	    if (!deltaX && !deltaY) {
	      deltaY = delta;
	    }

	    if (deltaX !== undefined) {
	      /**
	       * deltaX of mousewheel event
	       * @property deltaX
	       * @member Event.DomEvent.Object
	       */
	      event.deltaX = deltaX;
	    }

	    if (deltaY !== undefined) {
	      /**
	       * deltaY of mousewheel event
	       * @property deltaY
	       * @member Event.DomEvent.Object
	       */
	      event.deltaY = deltaY;
	    }

	    if (delta !== undefined) {
	      /**
	       * delta of mousewheel event
	       * @property delta
	       * @member Event.DomEvent.Object
	       */
	      event.delta = delta;
	    }
	  }
	}, {
	  reg: /^mouse|contextmenu|click|mspointer|(^DOMMouseScroll$)/i,
	  props: ['buttons', 'clientX', 'clientY', 'button', 'offsetX', 'relatedTarget', 'which', 'fromElement', 'toElement', 'offsetY', 'pageX', 'pageY', 'screenX', 'screenY'],
	  fix: function fix(event, nativeEvent) {
	    var eventDoc = undefined;
	    var doc = undefined;
	    var body = undefined;
	    var target = event.target;
	    var button = nativeEvent.button;

	    // Calculate pageX/Y if missing and clientX/Y available
	    if (target && isNullOrUndefined(event.pageX) && !isNullOrUndefined(nativeEvent.clientX)) {
	      eventDoc = target.ownerDocument || document;
	      doc = eventDoc.documentElement;
	      body = eventDoc.body;
	      event.pageX = nativeEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
	      event.pageY = nativeEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
	    }

	    // which for click: 1 === left; 2 === middle; 3 === right
	    // do not use button
	    if (!event.which && button !== undefined) {
	      if (button & 1) {
	        event.which = 1;
	      } else if (button & 2) {
	        event.which = 3;
	      } else if (button & 4) {
	        event.which = 2;
	      } else {
	        event.which = 0;
	      }
	    }

	    // add relatedTarget, if necessary
	    if (!event.relatedTarget && event.fromElement) {
	      event.relatedTarget = event.fromElement === target ? event.toElement : event.fromElement;
	    }

	    return event;
	  }
	}];

	function retTrue() {
	  return TRUE;
	}

	function retFalse() {
	  return FALSE;
	}

	function DomEventObject(nativeEvent) {
	  var type = nativeEvent.type;

	  var isNative = typeof nativeEvent.stopPropagation === 'function' || typeof nativeEvent.cancelBubble === 'boolean';

	  _EventBaseObject2['default'].call(this);

	  this.nativeEvent = nativeEvent;

	  // in case dom event has been mark as default prevented by lower dom node
	  var isDefaultPrevented = retFalse;
	  if ('defaultPrevented' in nativeEvent) {
	    isDefaultPrevented = nativeEvent.defaultPrevented ? retTrue : retFalse;
	  } else if ('getPreventDefault' in nativeEvent) {
	    // https://bugzilla.mozilla.org/show_bug.cgi?id=691151
	    isDefaultPrevented = nativeEvent.getPreventDefault() ? retTrue : retFalse;
	  } else if ('returnValue' in nativeEvent) {
	    isDefaultPrevented = nativeEvent.returnValue === FALSE ? retTrue : retFalse;
	  }

	  this.isDefaultPrevented = isDefaultPrevented;

	  var fixFns = [];
	  var fixFn = undefined;
	  var l = undefined;
	  var prop = undefined;
	  var props = commonProps.concat();

	  eventNormalizers.forEach(function (normalizer) {
	    if (type.match(normalizer.reg)) {
	      props = props.concat(normalizer.props);
	      if (normalizer.fix) {
	        fixFns.push(normalizer.fix);
	      }
	    }
	  });

	  l = props.length;

	  // clone properties of the original event object
	  while (l) {
	    prop = props[--l];
	    this[prop] = nativeEvent[prop];
	  }

	  // fix target property, if necessary
	  if (!this.target && isNative) {
	    this.target = nativeEvent.srcElement || document; // srcElement might not be defined either
	  }

	  // check if target is a text node (safari)
	  if (this.target && this.target.nodeType === 3) {
	    this.target = this.target.parentNode;
	  }

	  l = fixFns.length;

	  while (l) {
	    fixFn = fixFns[--l];
	    fixFn(this, nativeEvent);
	  }

	  this.timeStamp = nativeEvent.timeStamp || Date.now();
	}

	var EventBaseObjectProto = _EventBaseObject2['default'].prototype;

	(0, _objectAssign2['default'])(DomEventObject.prototype, EventBaseObjectProto, {
	  constructor: DomEventObject,

	  preventDefault: function preventDefault() {
	    var e = this.nativeEvent;

	    // if preventDefault exists run it on the original event
	    if (e.preventDefault) {
	      e.preventDefault();
	    } else {
	      // otherwise set the returnValue property of the original event to FALSE (IE)
	      e.returnValue = FALSE;
	    }

	    EventBaseObjectProto.preventDefault.call(this);
	  },

	  stopPropagation: function stopPropagation() {
	    var e = this.nativeEvent;

	    // if stopPropagation exists run it on the original event
	    if (e.stopPropagation) {
	      e.stopPropagation();
	    } else {
	      // otherwise set the cancelBubble property of the original event to TRUE (IE)
	      e.cancelBubble = TRUE;
	    }

	    EventBaseObjectProto.stopPropagation.call(this);
	  }
	});

	exports['default'] = DomEventObject;
	module.exports = exports['default'];

/***/ },
/* 758 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__) {

	/**
	 * @ignore
	 * DateTimeFormat for
	 * Inspired by DateTimeFormat from JDK.
	 * @author yiminghe@gmail.com
	 */

	'use strict';

	var GregorianCalendar = __webpack_require__(__webpack_module_template_argument_0__);
	var enUsLocale = __webpack_require__(__webpack_module_template_argument_1__);
	var MAX_VALUE = Number.MAX_VALUE;
	var warning = __webpack_require__(__webpack_module_template_argument_2__);

	/**
	 * date or time style enum
	 * @enum {Number} Date.Formatter.Style
	 */
	var DateTimeStyle = {
	  /**
	   * full style
	   */
	  FULL: 0,
	  /**
	   * long style
	   */
	  LONG: 1,
	  /**
	   * medium style
	   */
	  MEDIUM: 2,
	  /**
	   * short style
	   */
	  SHORT: 3
	};

	/*
	 Letter    Date or Time Component    Presentation    Examples
	 G    Era designator    Text    AD
	 y    Year    Year    1996; 96
	 Y    WeekYear    WeekYear    1996; 96
	 M    Month in year    Month    July; Jul; 07
	 w    Week in year    Number    27
	 W    Week in month    Number    2
	 D    Day in year    Number    189
	 d    Day in month    Number    10
	 F    Day of week in month    Number    2
	 E    Day in week    Text    Tuesday; Tue
	 a    Am/pm marker    Text    PM
	 H    Hour in day (0-23)    Number    0
	 k    Hour in day (1-24)    Number    24
	 K    Hour in am/pm (0-11)    Number    0
	 h    Hour in am/pm (1-12)    Number    12
	 m    Minute in hour    Number    30
	 s    Second in minute    Number    55
	 S    Millisecond    Number    978
	 x z    Time zone    General time zone    Pacific Standard Time; PST; GMT-08:00
	 Z    Time zone    RFC 822 time zone    -0800
	 */

	var patternChars = new Array(GregorianCalendar.DAY_OF_WEEK_IN_MONTH + 2).join('1');
	var ERA = 0;
	var calendarIndexMap = {};

	patternChars = patternChars.split('');
	patternChars[ERA] = 'G';
	patternChars[GregorianCalendar.YEAR] = 'y';
	patternChars[GregorianCalendar.MONTH] = 'M';
	patternChars[GregorianCalendar.DAY_OF_MONTH] = 'd';
	patternChars[GregorianCalendar.HOUR_OF_DAY] = 'H';
	patternChars[GregorianCalendar.MINUTES] = 'm';
	patternChars[GregorianCalendar.SECONDS] = 's';
	patternChars[GregorianCalendar.MILLISECONDS] = 'S';
	patternChars[GregorianCalendar.WEEK_OF_YEAR] = 'w';
	patternChars[GregorianCalendar.WEEK_OF_MONTH] = 'W';
	patternChars[GregorianCalendar.DAY_OF_YEAR] = 'D';
	patternChars[GregorianCalendar.DAY_OF_WEEK_IN_MONTH] = 'F';
	patternChars.push('Y');

	patternChars.forEach(function (v, key) {
	  var k = key;
	  if (v === 'Y') {
	    k = GregorianCalendar.YEAR;
	  }
	  if (v) {
	    calendarIndexMap[v] = k;
	  }
	});

	function mix(t, s) {
	  for (var p in s) {
	    if (s.hasOwnProperty(p)) {
	      t[p] = s[p];
	    }
	  }
	}

	var SUBSTITUTE_REG = /\\?\{([^{}]+)\}/g;
	var EMPTY = '';

	function substitute(str, o, regexp) {
	  if (typeof str !== 'string' || !o) {
	    return str;
	  }

	  return str.replace(regexp || SUBSTITUTE_REG, function (match, name) {
	    if (match.charAt(0) === '\\') {
	      return match.slice(1);
	    }
	    return o[name] === undefined ? EMPTY : o[name];
	  });
	}

	patternChars = patternChars.join('') + 'ahkKZE';

	function encode(lastField, count, compiledPattern) {
	  compiledPattern.push({
	    field: lastField,
	    count: count
	  });
	}

	function compile(pattern) {
	  var length = pattern.length;
	  var inQuote = false;
	  var compiledPattern = [];
	  var tmpBuffer = null;
	  var count = 0;
	  var lastField = -1;

	  for (var i = 0; i < length; i++) {
	    var c = pattern.charAt(i);

	    if (c === '\'') {
	      // '' is treated as a single quote regardless of being
	      // in a quoted section.
	      if (i + 1 < length) {
	        c = pattern.charAt(i + 1);
	        if (c === '\'') {
	          i++;
	          if (count !== 0) {
	            encode(lastField, count, compiledPattern);
	            lastField = -1;
	            count = 0;
	          }
	          if (inQuote) {
	            tmpBuffer += c;
	          }
	          continue;
	        }
	      }
	      if (!inQuote) {
	        if (count !== 0) {
	          encode(lastField, count, compiledPattern);
	          lastField = -1;
	          count = 0;
	        }
	        tmpBuffer = '';
	        inQuote = true;
	      } else {
	        compiledPattern.push({
	          text: tmpBuffer
	        });
	        inQuote = false;
	      }
	      continue;
	    }
	    if (inQuote) {
	      tmpBuffer += c;
	      continue;
	    }
	    if (!(c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z')) {
	      if (count !== 0) {
	        encode(lastField, count, compiledPattern);
	        lastField = -1;
	        count = 0;
	      }
	      compiledPattern.push({
	        text: c
	      });
	      continue;
	    }

	    if (patternChars.indexOf(c) === -1) {
	      throw new Error('Illegal pattern character "' + c + '"');
	    }

	    if (lastField === -1 || lastField === c) {
	      lastField = c;
	      count++;
	      continue;
	    }
	    encode(lastField, count, compiledPattern);
	    lastField = c;
	    count = 1;
	  }

	  if (inQuote) {
	    throw new Error('Unterminated quote');
	  }

	  if (count !== 0) {
	    encode(lastField, count, compiledPattern);
	  }

	  return compiledPattern;
	}

	var zeroDigit = '0';

	// TODO zeroDigit localization??
	function zeroPaddingNumber(_x, _x2, _x3, _x4) {
	  var _again = true;

	  _function: while (_again) {
	    var value = _x,
	        minDigits = _x2,
	        maxDigits_ = _x3,
	        b = _x4;
	    _again = false;

	    // Optimization for 1, 2 and 4 digit numbers. This should
	    // cover most cases of formatting date/time related items.
	    // Note: This optimization code assumes that maxDigits is
	    // either 2 or Integer.MAX_VALUE (maxIntCount in format()).
	    var buffer = b || [];
	    var maxDigits = maxDigits_ || MAX_VALUE;
	    if (value >= 0) {
	      if (value < 100 && minDigits >= 1 && minDigits <= 2) {
	        if (value < 10 && minDigits === 2) {
	          buffer.push(zeroDigit);
	        }
	        buffer.push(value);
	        return buffer.join('');
	      } else if (value >= 1000 && value < 10000) {
	        if (minDigits === 4) {
	          buffer.push(value);
	          return buffer.join('');
	        }
	        if (minDigits === 2 && maxDigits === 2) {
	          _x = value % 100;
	          _x2 = 2;
	          _x3 = 2;
	          _x4 = buffer;
	          _again = true;
	          buffer = maxDigits = undefined;
	          continue _function;
	        }
	      }
	    }
	    buffer.push(value + '');
	    return buffer.join('');
	  }
	}

	/**
	 *
	 * date time formatter for GregorianCalendar
	 *
	 *      @example
	 *
	 *          const calendar = new GregorianCalendar(2013,9,24);
	 *          // ' to escape
	 *          const formatter = new GregorianCalendarFormat("'today is' ''yyyy/MM/dd a''");
	 *          document.write(formatter.format(calendar));
	 *
	 * @class GregorianCalendarFormat
	 * @param {String} pattern patter string of date formatter
	 *
	 * <table border="1">
	 * <thead valign="bottom">
	 * <tr><th class="head">Letter</th>
	 * <th class="head">Date or Time Component</th>
	 * <th class="head">Presentation</th>
	 * <th class="head">Examples</th>
	 * </tr>
	 * </thead>
	 * <tbody valign="top">
	 * <tr><td>G</td>
	 * <td>Era designator</td>
	 * <td>Text</td>
	 * <td>AD</td>
	 * </tr>
	 * <tr><td>y</td>
	 * <td>Year</td>
	 * <td>Year</td>
	 * <td>1996; 96</td>
	 * </tr>
	 * <tr><td>M</td>
	 * <td>Month in year</td>
	 * <td>Month</td>
	 * <td>July; Jul; 07</td>
	 * </tr>
	 * <tr><td>w</td>
	 * <td>Week in year</td>
	 * <td>Number</td>
	 * <td>27</td>
	 * </tr>
	 * <tr><td>W</td>
	 * <td>Week in month</td>
	 * <td>Number</td>
	 * <td>2</td>
	 * </tr>
	 * <tr><td>D</td>
	 * <td>Day in year</td>
	 * <td>Number</td>
	 * <td>189</td>
	 * </tr>
	 * <tr><td>d</td>
	 * <td>Day in month</td>
	 * <td>Number</td>
	 * <td>10</td>
	 * </tr>
	 * <tr><td>F</td>
	 * <td>Day of week in month</td>
	 * <td>Number</td>
	 * <td>2</td>
	 * </tr>
	 * <tr><td>E</td>
	 * <td>Day in week</td>
	 * <td>Text</td>
	 * <td>Tuesday; Tue</td>
	 * </tr>
	 * <tr><td>a</td>
	 * <td>Am/pm marker</td>
	 * <td>Text</td>
	 * <td>PM</td>
	 * </tr>
	 * <tr><td>H</td>
	 *       <td>Hour in day (0-23)</td>
	 * <td>Number</td>
	 * <td>0</td>
	 * </tr>
	 * <tr><td>k</td>
	 *       <td>Hour in day (1-24)</td>
	 * <td>Number</td>
	 * <td>24</td>
	 * </tr>
	 * <tr><td>K</td>
	 * <td>Hour in am/pm (0-11)</td>
	 * <td>Number</td>
	 * <td>0</td>
	 * </tr>
	 * <tr><td>h</td>
	 * <td>Hour in am/pm (1-12)</td>
	 * <td>Number</td>
	 * <td>12</td>
	 * </tr>
	 * <tr><td>m</td>
	 * <td>Minute in hour</td>
	 * <td>Number</td>
	 * <td>30</td>
	 * </tr>
	 * <tr><td>s</td>
	 * <td>Second in minute</td>
	 * <td>Number</td>
	 * <td>55</td>
	 * </tr>
	 * <tr><td>S</td>
	 * <td>Millisecond</td>
	 * <td>Number</td>
	 * <td>978</td>
	 * </tr>
	 * <tr><td>x/z</td>
	 * <td>Time zone</td>
	 * <td>General time zone</td>
	 * <td>Pacific Standard Time; PST; GMT-08:00</td>
	 * </tr>
	 * <tr><td>Z</td>
	 * <td>Time zone</td>
	 * <td>RFC 822 time zone</td>
	 * <td>-0800</td>
	 * </tr>
	 * </tbody>
	 * </table>

	 * @param {Object} locale format locale
	 */
	function DateTimeFormat(pattern, locale) {
	  this.locale = locale || enUsLocale;
	  this.originalPattern = pattern;
	  this.pattern = compile(pattern);
	}

	function formatField(field, count, locale, calendar) {
	  var current = undefined;
	  var value = undefined;
	  switch (field) {
	    case 'G':
	      value = calendar.getYear() > 0 ? 1 : 0;
	      current = locale.eras[value];
	      break;
	    case 'Y':
	      value = calendar.getWeekYear();
	      if (value <= 0) {
	        value = 1 - value;
	      }
	      current = zeroPaddingNumber(value, 2, count !== 2 ? MAX_VALUE : 2);
	      break;
	    case 'y':
	      value = calendar.getYear();
	      if (value <= 0) {
	        value = 1 - value;
	      }
	      current = zeroPaddingNumber(value, 2, count !== 2 ? MAX_VALUE : 2);
	      break;
	    case 'M':
	      value = calendar.getMonth();
	      if (count >= 4) {
	        current = locale.months[value];
	      } else if (count === 3) {
	        current = locale.shortMonths[value];
	      } else {
	        current = zeroPaddingNumber(value + 1, count);
	      }
	      break;
	    case 'k':
	      current = zeroPaddingNumber(calendar.getHourOfDay() || 24, count);
	      break;
	    case 'E':
	      value = calendar.getDayOfWeek();
	      current = count >= 4 ? locale.weekdays[value] : locale.shortWeekdays[value];
	      break;
	    case 'a':
	      current = locale.ampms[calendar.getHourOfDay() >= 12 ? 1 : 0];
	      break;
	    case 'h':
	      current = zeroPaddingNumber(calendar.getHourOfDay() % 12 || 12, count);
	      break;
	    case 'K':
	      current = zeroPaddingNumber(calendar.getHourOfDay() % 12, count);
	      break;
	    case 'Z':
	      var offset = calendar.getTimezoneOffset();
	      var parts = [offset < 0 ? '-' : '+'];
	      offset = Math.abs(offset);
	      parts.push(zeroPaddingNumber(Math.floor(offset / 60) % 100, 2), zeroPaddingNumber(offset % 60, 2));
	      current = parts.join('');
	      break;
	    default:
	      // case 'd':
	      // case 'H':
	      // case 'm':
	      // case 's':
	      // case 'S':
	      // case 'D':
	      // case 'F':
	      // case 'w':
	      // case 'W':
	      var index = calendarIndexMap[field];
	      value = calendar.get(index);
	      current = zeroPaddingNumber(value, count);
	  }
	  return current;
	}

	function matchPartString(dateStr, startIndex, match, mLen) {
	  for (var i = 0; i < mLen; i++) {
	    if (dateStr.charAt(startIndex + i) !== match.charAt(i)) {
	      return false;
	    }
	  }
	  return true;
	}

	function matchField(dateStr, startIndex, matches) {
	  var matchedLen = -1;
	  var index = -1;
	  var i = undefined;
	  var len = matches.length;
	  for (i = 0; i < len; i++) {
	    var m = matches[i];
	    var mLen = m.length;
	    if (mLen > matchedLen && matchPartString(dateStr, startIndex, m, mLen)) {
	      matchedLen = mLen;
	      index = i;
	    }
	  }
	  return index >= 0 ? {
	    value: index,
	    startIndex: startIndex + matchedLen
	  } : null;
	}

	function getLeadingNumberLen(str) {
	  var i = undefined;
	  var c = undefined;
	  var len = str.length;
	  for (i = 0; i < len; i++) {
	    c = str.charAt(i);
	    if (c < '0' || c > '9') {
	      break;
	    }
	  }
	  return i;
	}

	function matchNumber(dateStr, startIndex, count, obeyCount) {
	  var str = dateStr;
	  var n = undefined;
	  if (obeyCount) {
	    if (dateStr.length < startIndex + count) {
	      return null;
	    }
	    str = dateStr.slice(startIndex, startIndex + count);
	    if (!str.match(/^\d+$/)) {
	      throw new Error('GregorianCalendarFormat parse error, dateStr: ' + dateStr + ', patter: ' + this.originalPattern);
	    }
	  } else {
	    str = str.slice(startIndex);
	  }
	  n = parseInt(str, 10);
	  if (isNaN(n)) {
	    throw new Error('GregorianCalendarFormat parse error, dateStr: ' + dateStr + ', patter: ' + this.originalPattern);
	  }
	  return {
	    value: n,
	    startIndex: startIndex + getLeadingNumberLen(str)
	  };
	}

	function parseField(calendar, dateStr, startIndex_, field, count, obeyCount, tmp) {
	  var match = undefined;
	  var year = undefined;
	  var hour = undefined;
	  var startIndex = startIndex_;
	  if (dateStr.length <= startIndex) {
	    return startIndex;
	  }
	  var locale = this.locale;
	  switch (field) {
	    case 'G':
	      match = matchField(dateStr, startIndex, locale.eras);
	      if (match) {
	        if (calendar.isSetYear()) {
	          if (match.value === 0) {
	            year = calendar.getYear();
	            calendar.setYear(1 - year);
	          }
	        } else {
	          tmp.era = match.value;
	        }
	      }
	      break;
	    case 'y':
	      match = matchNumber.call(this, dateStr, startIndex, count, obeyCount);
	      if (match) {
	        year = match.value;
	        if ('era' in tmp) {
	          if (tmp.era === 0) {
	            year = 1 - year;
	          }
	        }
	        calendar.setYear(year);
	      }
	      break;
	    case 'M':
	      var month = undefined;
	      if (count >= 3) {
	        match = matchField(dateStr, startIndex, locale[count === 3 ? 'shortMonths' : 'months']);
	        if (match) {
	          month = match.value;
	        }
	      } else {
	        match = matchNumber.call(this, dateStr, startIndex, count, obeyCount);
	        if (match) {
	          month = match.value - 1;
	        }
	      }
	      if (match) {
	        calendar.setMonth(month);
	      }
	      break;
	    case 'k':
	      match = matchNumber.call(this, dateStr, startIndex, count, obeyCount);
	      if (match) {
	        calendar.setHourOfDay(match.value % 24);
	      }
	      break;
	    case 'E':
	      match = matchField(dateStr, startIndex, locale[count > 3 ? 'weekdays' : 'shortWeekdays']);
	      if (match) {
	        calendar.setDayOfWeek(match.value);
	      }
	      break;
	    case 'a':
	      match = matchField(dateStr, startIndex, locale.ampms);
	      if (match) {
	        if (calendar.isSetHourOfDay()) {
	          if (match.value) {
	            hour = calendar.getHourOfDay();
	            if (hour < 12) {
	              calendar.setHourOfDay((hour + 12) % 24);
	            }
	          }
	        } else {
	          tmp.ampm = match.value;
	        }
	      }
	      break;
	    case 'h':
	      match = matchNumber.call(this, dateStr, startIndex, count, obeyCount);
	      if (match) {
	        hour = match.value %= 12;
	        if (tmp.ampm) {
	          hour += 12;
	        }
	        calendar.setHourOfDay(hour);
	      }
	      break;
	    case 'K':
	      match = matchNumber.call(this, dateStr, startIndex, count, obeyCount);
	      if (match) {
	        hour = match.value;
	        if (tmp.ampm) {
	          hour += 12;
	        }
	        calendar.setHourOfDay(hour);
	      }
	      break;
	    case 'Z':
	      // let sign = 1;
	      var zoneChar = dateStr.charAt(startIndex);
	      if (zoneChar === '-') {
	        // sign = -1;
	        startIndex++;
	      } else if (zoneChar === '+') {
	        startIndex++;
	      } else {
	        break;
	      }
	      match = matchNumber.call(this, dateStr, startIndex, 2, true);
	      if (match) {
	        var zoneOffset = match.value * 60;
	        startIndex = match.startIndex;
	        match = matchNumber.call(this, dateStr, startIndex, 2, true);
	        if (match) {
	          zoneOffset += match.value;
	        }
	        calendar.setTimezoneOffset(zoneOffset);
	      }
	      break;
	    default:
	      // case 'd':
	      // case 'H':
	      // case 'm':
	      // case 's':
	      // case 'S':
	      // case 'D':
	      // case 'F':
	      // case 'w':
	      // case 'W'
	      match = matchNumber.call(this, dateStr, startIndex, count, obeyCount);
	      if (match) {
	        var index = calendarIndexMap[field];
	        calendar.set(index, match.value);
	      }
	  }
	  if (match) {
	    startIndex = match.startIndex;
	  }
	  return startIndex;
	}

	mix(DateTimeFormat.prototype, {
	  /*
	   * format a GregorianDate instance according to specified pattern
	   * @param {GregorianCalendar} calendar GregorianDate instance
	   * @returns {string} formatted string of GregorianDate instance
	   */
	  format: function format(calendar) {
	    if (!calendar.isGregorianCalendar) {
	      throw new Error('calendar must be type of GregorianCalendar');
	    }
	    var i = undefined;
	    var ret = [];
	    var pattern = this.pattern;
	    var len = pattern.length;
	    for (i = 0; i < len; i++) {
	      var comp = pattern[i];
	      if (comp.text) {
	        ret.push(comp.text);
	      } else if ('field' in comp) {
	        ret.push(formatField(comp.field, comp.count, this.locale, calendar));
	      }
	    }
	    return ret.join('');
	  },

	  /*
	   * parse a formatted string of GregorianDate instance according to specified pattern
	   * @param {String} dateStr formatted string of GregorianDate
	   * @returns {GregorianCalendar}
	   */
	  parse: function parse(dateStr, option_) {
	    var option = option_ || {};
	    var calendarLocale = option.locale;
	    var calendar = new GregorianCalendar(calendarLocale);
	    var i = undefined;
	    var j = undefined;
	    var tmp = {};
	    var obeyCount = option.obeyCount || false;
	    var dateStrLen = dateStr.length;
	    var errorIndex = -1;
	    var startIndex = 0;
	    var oldStartIndex = 0;
	    var pattern = this.pattern;
	    var len = pattern.length;
	    /* eslint no-labels: 0 no-empty-label:0 */
	    loopPattern: {
	      for (i = 0; errorIndex < 0 && i < len; i++) {
	        var comp = pattern[i];
	        var text = undefined;
	        var textLen = undefined;
	        oldStartIndex = startIndex;
	        text = comp.text;
	        if (text) {
	          textLen = text.length;
	          if (textLen + startIndex > dateStrLen) {
	            errorIndex = startIndex;
	          } else {
	            for (j = 0; j < textLen; j++) {
	              if (text.charAt(j) !== dateStr.charAt(j + startIndex)) {
	                errorIndex = startIndex;
	                break loopPattern;
	              }
	            }
	            startIndex += textLen;
	          }
	        } else if ('field' in comp) {
	          if (!option.obeyCount) {
	            var nextComp = pattern[i + 1];
	            obeyCount = false;
	            if (nextComp) {
	              if ('field' in nextComp) {
	                obeyCount = true;
	              } else {
	                var c = nextComp.text.charAt(0);
	                if (c >= '0' && c <= '9') {
	                  obeyCount = true;
	                }
	              }
	            }
	          }
	          startIndex = parseField.call(this, calendar, dateStr, startIndex, comp.field, comp.count, obeyCount, tmp);
	          if (startIndex === oldStartIndex) {
	            errorIndex = startIndex;
	          }
	        }
	      }
	    }

	    if (errorIndex >= 0) {
	      warning(false, 'error when parsing date: ' + dateStr + ', position: ' + dateStr.slice(0, errorIndex) + '^');
	      return undefined;
	    }
	    return calendar;
	  }
	});

	mix(DateTimeFormat, {
	  Style: DateTimeStyle,

	  /*
	   * get a formatter instance of short style pattern.
	   * en-us: M/d/yy h:mm a
	   * zh-cn: yy-M-d ah:mm
	   * @param {Object} locale locale object
	   * @returns {GregorianCalendar}
	   * @static
	   */
	  getInstance: function getInstance(locale) {
	    return this.getDateTimeInstance(DateTimeStyle.SHORT, DateTimeStyle.SHORT, locale);
	  },

	  /*
	   * get a formatter instance of specified date style.
	   * @param {Date.Formatter.Style} dateStyle date format style
	   * @param {Object} locale
	   * @returns {GregorianCalendar}
	   * @static
	   */
	  getDateInstance: function getDateInstance(dateStyle, locale) {
	    return this.getDateTimeInstance(dateStyle, undefined, locale);
	  },

	  /*
	   * get a formatter instance of specified date style and time style.
	   * @param {Date.Formatter.Style} dateStyle date format style
	   * @param {Date.Formatter.Style} timeStyle time format style
	   * @param {Object} locale
	   * @returns {GregorianCalendar}
	   * @static
	   */
	  getDateTimeInstance: function getDateTimeInstance(dateStyle, timeStyle, locale_) {
	    var locale = locale_ || enUsLocale;
	    var datePattern = '';
	    if (dateStyle !== undefined) {
	      datePattern = locale.datePatterns[dateStyle];
	    }
	    var timePattern = '';
	    if (timeStyle !== undefined) {
	      timePattern = locale.timePatterns[timeStyle];
	    }
	    var pattern = datePattern;
	    if (timePattern) {
	      if (datePattern) {
	        pattern = substitute(locale.dateTimePattern, {
	          date: datePattern,
	          time: timePattern
	        });
	      } else {
	        pattern = timePattern;
	      }
	    }
	    return new DateTimeFormat(pattern, locale);
	  },

	  /*
	   * get a formatter instance of specified time style.
	   * @param {Date.Formatter.Style} timeStyle time format style
	   * @param {Object} locale
	   * @returns {GregorianCalendar}
	   * @static
	   */
	  getTimeInstance: function getTimeInstance(timeStyle, locale) {
	    return this.getDateTimeInstance(undefined, timeStyle, locale);
	  }
	});

	module.exports = DateTimeFormat;

	DateTimeFormat.version = '@VERSION@';

	// gc_format@163.com

/***/ },
/* 759 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	module.exports = __webpack_require__(__webpack_module_template_argument_0__);

/***/ },
/* 760 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__) {

	'use strict';

	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};

	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(4);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _rcUtil = __webpack_require__(__webpack_module_template_argument_0__);

	var _Popup = __webpack_require__(__webpack_module_template_argument_1__);

	var _Popup2 = _interopRequireDefault(_Popup);

	var _utils = __webpack_require__(__webpack_module_template_argument_2__);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}

	function noop() {}

	function returnEmptyString() {
	  return '';
	}

	var ALL_HANDLERS = ['onClick', 'onMouseDown', 'onTouchStart', 'onMouseEnter', 'onMouseLeave', 'onFocus', 'onBlur'];

	var Trigger = _react2["default"].createClass({
	  displayName: 'Trigger',

	  propTypes: {
	    action: _react.PropTypes.any,
	    showAction: _react.PropTypes.any,
	    hideAction: _react.PropTypes.any,
	    getPopupClassNameFromAlign: _react.PropTypes.any,
	    onPopupVisibleChange: _react.PropTypes.func,
	    afterPopupVisibleChange: _react.PropTypes.func,
	    popup: _react.PropTypes.node.isRequired,
	    popupStyle: _react.PropTypes.object,
	    prefixCls: _react.PropTypes.string,
	    popupClassName: _react.PropTypes.string,
	    popupPlacement: _react.PropTypes.string,
	    builtinPlacements: _react.PropTypes.object,
	    popupTransitionName: _react.PropTypes.string,
	    popupAnimation: _react.PropTypes.any,
	    mouseEnterDelay: _react.PropTypes.number,
	    mouseLeaveDelay: _react.PropTypes.number,
	    zIndex: _react.PropTypes.number,
	    focusDelay: _react.PropTypes.number,
	    blurDelay: _react.PropTypes.number,
	    getPopupContainer: _react.PropTypes.func,
	    destroyPopupOnHide: _react.PropTypes.bool,
	    mask: _react.PropTypes.bool,
	    onPopupAlign: _react.PropTypes.func,
	    popupAlign: _react.PropTypes.object,
	    popupVisible: _react.PropTypes.bool,
	    maskTransitionName: _react.PropTypes.string,
	    maskAnimation: _react.PropTypes.string
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      prefixCls: 'rc-trigger-popup',
	      getPopupClassNameFromAlign: returnEmptyString,
	      onPopupVisibleChange: noop,
	      afterPopupVisibleChange: noop,
	      onPopupAlign: noop,
	      popupClassName: '',
	      mouseEnterDelay: 0,
	      mouseLeaveDelay: 0.1,
	      focusDelay: 0,
	      blurDelay: 0.15,
	      popupStyle: {},
	      destroyPopupOnHide: false,
	      popupAlign: {},
	      defaultPopupVisible: false,
	      mask: false,
	      action: [],
	      showAction: [],
	      hideAction: []
	    };
	  },
	  getInitialState: function getInitialState() {
	    var props = this.props;
	    var popupVisible = void 0;
	    if ('popupVisible' in props) {
	      popupVisible = !!props.popupVisible;
	    } else {
	      popupVisible = !!props.defaultPopupVisible;
	    }
	    return {
	      popupVisible: popupVisible
	    };
	  },
	  componentDidMount: function componentDidMount() {
	    this.componentDidUpdate({}, {
	      popupVisible: this.state.popupVisible
	    });
	  },
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    if ('popupVisible' in nextProps) {
	      this.setState({
	        popupVisible: !!nextProps.popupVisible
	      });
	    }
	  },
	  componentDidUpdate: function componentDidUpdate(prevProps, prevState) {
	    var _this = this;

	    var props = this.props;
	    var state = this.state;
	    if (this.popupRendered) {
	      var _ret = function () {
	        var self = _this;
	        _reactDom2["default"].unstable_renderSubtreeIntoContainer(_this, _this.getPopupElement(), _this.getPopupContainer(), function renderPopup() {
	          /* eslint react/no-is-mounted:0 */
	          if (this.isMounted()) {
	            self.popupDomNode = this.getPopupDomNode();
	          } else {
	            self.popupDomNode = null;
	          }
	          if (prevState.popupVisible !== state.popupVisible) {
	            props.afterPopupVisibleChange(state.popupVisible);
	          }
	        });
	        if (props.action.indexOf('click') !== -1) {
	          if (state.popupVisible) {
	            if (!_this.clickOutsideHandler) {
	              _this.clickOutsideHandler = _rcUtil.Dom.addEventListener(document, 'mousedown', _this.onDocumentClick);
	              _this.touchOutsideHandler = _rcUtil.Dom.addEventListener(document, 'touchstart', _this.onDocumentClick);
	            }
	            return {
	              v: void 0
	            };
	          }
	        }
	        if (_this.clickOutsideHandler) {
	          _this.clickOutsideHandler.remove();
	          _this.touchOutsideHandler.remove();
	          _this.clickOutsideHandler = null;
	          _this.touchOutsideHandler = null;
	        }
	      }();

	      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
	    }
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    var popupContainer = this.popupContainer;
	    if (popupContainer) {
	      _reactDom2["default"].unmountComponentAtNode(popupContainer);
	      popupContainer.parentNode.removeChild(popupContainer);
	      this.popupContainer = null;
	    }
	    this.clearDelayTimer();
	    if (this.clickOutsideHandler) {
	      this.clickOutsideHandler.remove();
	      this.touchOutsideHandler.remove();
	      this.clickOutsideHandler = null;
	      this.touchOutsideHandler = null;
	    }
	  },
	  onMouseEnter: function onMouseEnter() {
	    this.delaySetPopupVisible(true, this.props.mouseEnterDelay);
	  },
	  onMouseLeave: function onMouseLeave() {
	    this.delaySetPopupVisible(false, this.props.mouseLeaveDelay);
	  },
	  onFocus: function onFocus() {
	    this.focusTime = Date.now();
	    this.delaySetPopupVisible(true, this.props.focusDelay);
	  },
	  onMouseDown: function onMouseDown() {
	    this.preClickTime = Date.now();
	  },
	  onTouchStart: function onTouchStart() {
	    this.preTouchTime = Date.now();
	  },
	  onBlur: function onBlur() {
	    this.delaySetPopupVisible(false, this.props.blurDelay);
	  },
	  onClick: function onClick(event) {
	    // focus will trigger click
	    if (this.focusTime) {
	      var preTime = void 0;
	      if (this.preClickTime && this.preTouchTime) {
	        preTime = Math.min(this.preClickTime, this.preTouchTime);
	      } else if (this.preClickTime) {
	        preTime = this.preClickTime;
	      } else if (this.preTouchTime) {
	        preTime = this.preTouchTime;
	      }
	      if (Math.abs(preTime - this.focusTime) < 20) {
	        return;
	      }
	      this.focusTime = 0;
	    }
	    this.preClickTime = 0;
	    this.preTouchTime = 0;
	    event.preventDefault();
	    var nextVisible = !this.state.popupVisible;
	    if (this.isClickToHide() && !nextVisible || nextVisible && this.isClickToShow()) {
	      this.setPopupVisible(!this.state.popupVisible);
	    }
	  },
	  onDocumentClick: function onDocumentClick(event) {
	    var target = event.target;
	    var root = (0, _reactDom.findDOMNode)(this);
	    var popupNode = this.getPopupDomNode();
	    if (!_rcUtil.Dom.contains(root, target) && !_rcUtil.Dom.contains(popupNode, target)) {
	      this.setPopupVisible(false);
	    }
	  },
	  getPopupDomNode: function getPopupDomNode() {
	    // for test
	    return this.popupDomNode;
	  },
	  getRootDomNode: function getRootDomNode() {
	    return _reactDom2["default"].findDOMNode(this);
	  },
	  getPopupContainer: function getPopupContainer() {
	    if (!this.popupContainer) {
	      this.popupContainer = document.createElement('div');
	      var mountNode = this.props.getPopupContainer ? this.props.getPopupContainer((0, _reactDom.findDOMNode)(this)) : document.body;
	      mountNode.appendChild(this.popupContainer);
	    }
	    return this.popupContainer;
	  },
	  getPopupClassNameFromAlign: function getPopupClassNameFromAlign(align) {
	    var className = [];
	    var props = this.props;
	    var popupPlacement = props.popupPlacement;
	    var builtinPlacements = props.builtinPlacements;
	    var prefixCls = props.prefixCls;

	    if (popupPlacement && builtinPlacements) {
	      className.push((0, _utils.getPopupClassNameFromAlign)(builtinPlacements, prefixCls, align));
	    }
	    if (props.getPopupClassNameFromAlign) {
	      className.push(props.getPopupClassNameFromAlign(align));
	    }
	    return className.join(' ');
	  },
	  getPopupAlign: function getPopupAlign() {
	    var props = this.props;
	    var popupPlacement = props.popupPlacement;
	    var popupAlign = props.popupAlign;
	    var builtinPlacements = props.builtinPlacements;

	    if (popupPlacement && builtinPlacements) {
	      return (0, _utils.getAlignFromPlacement)(builtinPlacements, popupPlacement, popupAlign);
	    }
	    return popupAlign;
	  },
	  getPopupElement: function getPopupElement() {
	    var props = this.props;
	    var state = this.state;
	    var mouseProps = {};
	    if (props.action.indexOf('hover') !== -1) {
	      mouseProps.onMouseEnter = this.onMouseEnter;
	      mouseProps.onMouseLeave = this.onMouseLeave;
	    }
	    return _react2["default"].createElement(_Popup2["default"], _extends({
	      prefixCls: props.prefixCls,
	      destroyPopupOnHide: props.destroyPopupOnHide,
	      visible: state.popupVisible,
	      className: props.popupClassName,
	      action: props.action,
	      align: this.getPopupAlign(),
	      onAlign: props.onPopupAlign,
	      animation: props.popupAnimation,
	      getClassNameFromAlign: this.getPopupClassNameFromAlign
	    }, mouseProps, {
	      getRootDomNode: this.getRootDomNode,
	      style: props.popupStyle,
	      mask: props.mask,
	      zIndex: props.zIndex,
	      transitionName: props.popupTransitionName,
	      maskAnimation: props.maskAnimation,
	      maskTransitionName: props.maskTransitionName
	    }), props.popup);
	  },
	  setPopupVisible: function setPopupVisible(popupVisible) {
	    this.clearDelayTimer();
	    if (this.state.popupVisible !== popupVisible) {
	      if (!('popupVisible' in this.props)) {
	        this.setState({
	          popupVisible: popupVisible
	        });
	      }
	      this.props.onPopupVisibleChange(popupVisible);
	    }
	  },
	  delaySetPopupVisible: function delaySetPopupVisible(visible, delayS) {
	    var _this2 = this;

	    var delay = delayS * 1000;
	    this.clearDelayTimer();
	    if (delay) {
	      this.delayTimer = setTimeout(function () {
	        _this2.setPopupVisible(visible);
	        _this2.clearDelayTimer();
	      }, delay);
	    } else {
	      this.setPopupVisible(visible);
	    }
	  },
	  clearDelayTimer: function clearDelayTimer() {
	    if (this.delayTimer) {
	      clearTimeout(this.delayTimer);
	      this.delayTimer = null;
	    }
	  },
	  isClickToShow: function isClickToShow() {
	    var _props = this.props;
	    var action = _props.action;
	    var showAction = _props.showAction;

	    return action.indexOf('click') !== -1 || showAction.indexOf('click') !== -1;
	  },
	  isClickToHide: function isClickToHide() {
	    var _props2 = this.props;
	    var action = _props2.action;
	    var hideAction = _props2.hideAction;

	    return action.indexOf('click') !== -1 || hideAction.indexOf('click') !== -1;
	  },
	  isMouseEnterToShow: function isMouseEnterToShow() {
	    var _props3 = this.props;
	    var action = _props3.action;
	    var showAction = _props3.showAction;

	    return action.indexOf('hover') !== -1 || showAction.indexOf('mouseEnter') !== -1;
	  },
	  isMouseLeaveToHide: function isMouseLeaveToHide() {
	    var _props4 = this.props;
	    var action = _props4.action;
	    var hideAction = _props4.hideAction;

	    return action.indexOf('hover') !== -1 || hideAction.indexOf('mouseLeave') !== -1;
	  },
	  isFocusToShow: function isFocusToShow() {
	    var _props5 = this.props;
	    var action = _props5.action;
	    var showAction = _props5.showAction;

	    return action.indexOf('focus') !== -1 || showAction.indexOf('focus') !== -1;
	  },
	  isBlurToHide: function isBlurToHide() {
	    var _props6 = this.props;
	    var action = _props6.action;
	    var hideAction = _props6.hideAction;

	    return action.indexOf('focus') !== -1 || hideAction.indexOf('blur') !== -1;
	  },
	  render: function render() {
	    this.popupRendered = this.popupRendered || this.state.popupVisible;
	    var props = this.props;
	    var children = props.children;
	    var child = _react2["default"].Children.only(children);
	    var childProps = child.props || {};
	    var newChildProps = {};

	    if (this.isClickToHide() || this.isClickToShow()) {
	      newChildProps.onClick = (0, _rcUtil.createChainedFunction)(this.onClick, childProps.onClick);
	      newChildProps.onMouseDown = (0, _rcUtil.createChainedFunction)(this.onMouseDown, childProps.onMouseDown);
	      newChildProps.onTouchStart = (0, _rcUtil.createChainedFunction)(this.onTouchStart, childProps.onTouchStart);
	    }
	    if (this.isMouseEnterToShow()) {
	      newChildProps.onMouseEnter = (0, _rcUtil.createChainedFunction)(this.onMouseEnter, childProps.onMouseEnter);
	    }
	    if (this.isMouseLeaveToHide()) {
	      newChildProps.onMouseLeave = (0, _rcUtil.createChainedFunction)(this.onMouseLeave, childProps.onMouseLeave);
	    }
	    if (this.isFocusToShow()) {
	      newChildProps.onFocus = (0, _rcUtil.createChainedFunction)(this.onFocus, childProps.onFocus);
	    }
	    if (this.isBlurToHide()) {
	      newChildProps.onBlur = (0, _rcUtil.createChainedFunction)(this.onBlur, childProps.onBlur);
	    }

	    ALL_HANDLERS.forEach(function (handler) {
	      var newFn = void 0;
	      if (props[handler] && newChildProps[handler]) {
	        newFn = (0, _rcUtil.createChainedFunction)(props[handler], newChildProps[handler]);
	      } else {
	        newFn = props[handler] || newChildProps[handler];
	      }
	      if (newFn) {
	        newChildProps[handler] = newFn;
	      }
	    });

	    return _react2["default"].cloneElement(child, newChildProps);
	  }
	});

	exports["default"] = Trigger;
	module.exports = exports['default'];

/***/ },
/* 761 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__, __webpack_module_template_argument_3__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(4);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _rcAlign = __webpack_require__(__webpack_module_template_argument_0__);

	var _rcAlign2 = _interopRequireDefault(_rcAlign);

	var _rcAnimate = __webpack_require__(__webpack_module_template_argument_1__);

	var _rcAnimate2 = _interopRequireDefault(_rcAnimate);

	var _PopupInner = __webpack_require__(__webpack_module_template_argument_2__);

	var _PopupInner2 = _interopRequireDefault(_PopupInner);

	var _LazyRenderBox = __webpack_require__(__webpack_module_template_argument_3__);

	var _LazyRenderBox2 = _interopRequireDefault(_LazyRenderBox);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}

	var Popup = _react2["default"].createClass({
	  displayName: 'Popup',

	  propTypes: {
	    visible: _react.PropTypes.bool,
	    style: _react.PropTypes.object,
	    getClassNameFromAlign: _react.PropTypes.func,
	    onAlign: _react.PropTypes.func,
	    getRootDomNode: _react.PropTypes.func,
	    onMouseEnter: _react.PropTypes.func,
	    align: _react.PropTypes.any,
	    destroyPopupOnHide: _react.PropTypes.bool,
	    className: _react.PropTypes.string,
	    prefixCls: _react.PropTypes.string,
	    onMouseLeave: _react.PropTypes.func
	  },

	  componentDidMount: function componentDidMount() {
	    this.rootNode = this.getPopupDomNode();
	  },
	  onAlign: function onAlign(popupDomNode, align) {
	    var props = this.props;
	    var alignClassName = props.getClassNameFromAlign(props.align);
	    var currentAlignClassName = props.getClassNameFromAlign(align);
	    if (alignClassName !== currentAlignClassName) {
	      this.currentAlignClassName = currentAlignClassName;
	      popupDomNode.className = this.getClassName(currentAlignClassName);
	    }
	    props.onAlign(popupDomNode, align);
	  },
	  getPopupDomNode: function getPopupDomNode() {
	    return _reactDom2["default"].findDOMNode(this.refs.popup);
	  },
	  getTarget: function getTarget() {
	    return this.props.getRootDomNode();
	  },
	  getMaskTransitionName: function getMaskTransitionName() {
	    var props = this.props;
	    var transitionName = props.maskTransitionName;
	    var animation = props.maskAnimation;
	    if (!transitionName && animation) {
	      transitionName = props.prefixCls + '-' + animation;
	    }
	    return transitionName;
	  },
	  getTransitionName: function getTransitionName() {
	    var props = this.props;
	    var transitionName = props.transitionName;
	    if (!transitionName && props.animation) {
	      transitionName = props.prefixCls + '-' + props.animation;
	    }
	    return transitionName;
	  },
	  getClassName: function getClassName(currentAlignClassName) {
	    return this.props.prefixCls + ' ' + this.props.className + ' ' + currentAlignClassName;
	  },
	  getPopupElement: function getPopupElement() {
	    var props = this.props;
	    var align = props.align;
	    var style = props.style;
	    var visible = props.visible;
	    var prefixCls = props.prefixCls;
	    var destroyPopupOnHide = props.destroyPopupOnHide;

	    var className = this.getClassName(this.currentAlignClassName || props.getClassNameFromAlign(align));
	    var hiddenClassName = prefixCls + '-hidden';
	    if (!visible) {
	      this.currentAlignClassName = null;
	    }
	    var newStyle = _extends({}, style, this.getZIndexStyle());
	    var popupInnerProps = {
	      className: className,
	      prefixCls: prefixCls,
	      ref: 'popup',
	      onMouseEnter: props.onMouseEnter,
	      onMouseLeave: props.onMouseLeave,
	      style: newStyle
	    };
	    if (destroyPopupOnHide) {
	      return _react2["default"].createElement(_rcAnimate2["default"], {
	        component: '',
	        exclusive: true,
	        transitionAppear: true,
	        transitionName: this.getTransitionName()
	      }, visible ? _react2["default"].createElement(_rcAlign2["default"], {
	        target: this.getTarget,
	        key: 'popup',
	        monitorWindowResize: true,
	        align: align,
	        onAlign: this.onAlign
	      }, _react2["default"].createElement(_PopupInner2["default"], _extends({
	        visible: true
	      }, popupInnerProps), props.children)) : null);
	    }
	    return _react2["default"].createElement(_rcAnimate2["default"], {
	      component: '',
	      exclusive: true,
	      transitionAppear: true,
	      transitionName: this.getTransitionName(),
	      showProp: 'xVisible'
	    }, _react2["default"].createElement(_rcAlign2["default"], {
	      target: this.getTarget,
	      key: 'popup',
	      monitorWindowResize: true,
	      xVisible: visible,
	      childrenProps: { visible: 'xVisible' },
	      disabled: !visible,
	      align: align,
	      onAlign: this.onAlign
	    }, _react2["default"].createElement(_PopupInner2["default"], _extends({
	      hiddenClassName: hiddenClassName
	    }, popupInnerProps), props.children)));
	  },
	  getZIndexStyle: function getZIndexStyle() {
	    var style = {};
	    var props = this.props;
	    if (props.zIndex !== undefined) {
	      style.zIndex = props.zIndex;
	    }
	    return style;
	  },
	  getMaskElement: function getMaskElement() {
	    var props = this.props;
	    var maskElement = void 0;
	    if (props.mask) {
	      var maskTransition = this.getMaskTransitionName();
	      maskElement = _react2["default"].createElement(_LazyRenderBox2["default"], {
	        style: this.getZIndexStyle(),
	        key: 'mask',
	        className: props.prefixCls + '-mask',
	        hiddenClassName: props.prefixCls + '-mask-hidden',
	        visible: props.visible
	      });
	      if (maskTransition) {
	        maskElement = _react2["default"].createElement(_rcAnimate2["default"], {
	          key: 'mask',
	          showProp: 'visible',
	          transitionAppear: true,
	          component: '',
	          transitionName: maskTransition
	        }, maskElement);
	      }
	    }
	    return maskElement;
	  },
	  render: function render() {
	    return _react2["default"].createElement('div', null, this.getMaskElement(), this.getPopupElement());
	  }
	});

	exports["default"] = Popup;
	module.exports = exports['default'];

/***/ },
/* 762 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	// export this package's api
	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _Align = __webpack_require__(__webpack_module_template_argument_0__);

	var _Align2 = _interopRequireDefault(_Align);

	exports['default'] = _Align2['default'];
	module.exports = exports['default'];

/***/ },
/* 763 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(4);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _domAlign = __webpack_require__(__webpack_module_template_argument_0__);

	var _domAlign2 = _interopRequireDefault(_domAlign);

	var _rcUtil = __webpack_require__(__webpack_module_template_argument_1__);

	var _isWindow = __webpack_require__(__webpack_module_template_argument_2__);

	var _isWindow2 = _interopRequireDefault(_isWindow);

	function buffer(fn, ms) {
	  var timer = undefined;
	  return function bufferFn() {
	    if (timer) {
	      clearTimeout(timer);
	    }
	    timer = setTimeout(fn, ms);
	  };
	}

	var Align = _react2['default'].createClass({
	  displayName: 'Align',

	  propTypes: {
	    childrenProps: _react.PropTypes.object,
	    align: _react.PropTypes.object.isRequired,
	    target: _react.PropTypes.func,
	    onAlign: _react.PropTypes.func,
	    monitorBufferTime: _react.PropTypes.number,
	    monitorWindowResize: _react.PropTypes.bool,
	    disabled: _react.PropTypes.bool,
	    children: _react.PropTypes.any
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      target: function target() {
	        return window;
	      },
	      onAlign: function onAlign() {},
	      monitorBufferTime: 50,
	      monitorWindowResize: false,
	      disabled: false
	    };
	  },

	  componentDidMount: function componentDidMount() {
	    var props = this.props;
	    // if parent ref not attached .... use document.getElementById
	    if (!props.disabled) {
	      var source = _reactDom2['default'].findDOMNode(this);
	      props.onAlign(source, (0, _domAlign2['default'])(source, props.target(), props.align));
	      if (props.monitorWindowResize) {
	        this.startMonitorWindowResize();
	      }
	    }
	  },

	  componentDidUpdate: function componentDidUpdate(prevProps) {
	    var reAlign = false;
	    var props = this.props;
	    var currentTarget = undefined;

	    if (!props.disabled) {
	      if (prevProps.disabled || prevProps.align !== props.align) {
	        reAlign = true;
	        currentTarget = props.target();
	      } else {
	        var lastTarget = prevProps.target();
	        currentTarget = props.target();
	        if ((0, _isWindow2['default'])(lastTarget) && (0, _isWindow2['default'])(currentTarget)) {
	          reAlign = false;
	        } else if (lastTarget !== currentTarget) {
	          reAlign = true;
	        }
	      }
	    }

	    if (reAlign) {
	      var source = _reactDom2['default'].findDOMNode(this);
	      props.onAlign(source, (0, _domAlign2['default'])(source, currentTarget, props.align));
	    }

	    if (props.monitorWindowResize && !props.disabled) {
	      this.startMonitorWindowResize();
	    } else {
	      this.stopMonitorWindowResize();
	    }
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    this.stopMonitorWindowResize();
	  },

	  onWindowResize: function onWindowResize() {
	    var props = this.props;
	    if (!props.disabled) {
	      var source = _reactDom2['default'].findDOMNode(this);
	      props.onAlign(source, (0, _domAlign2['default'])(source, props.target(), props.align));
	    }
	  },

	  startMonitorWindowResize: function startMonitorWindowResize() {
	    if (!this.resizeHandler) {
	      this.resizeHandler = _rcUtil.Dom.addEventListener(window, 'resize', buffer(this.onWindowResize, this.props.monitorBufferTime));
	    }
	  },

	  stopMonitorWindowResize: function stopMonitorWindowResize() {
	    if (this.resizeHandler) {
	      this.resizeHandler.remove();
	      this.resizeHandler = null;
	    }
	  },

	  render: function render() {
	    var _props = this.props;
	    var childrenProps = _props.childrenProps;
	    var children = _props.children;

	    var child = _react2['default'].Children.only(children);
	    if (childrenProps) {
	      var newProps = {};
	      for (var prop in childrenProps) {
	        if (childrenProps.hasOwnProperty(prop)) {
	          newProps[prop] = this.props[childrenProps[prop]];
	        }
	      }
	      return _react2['default'].cloneElement(child, newProps);
	    }
	    return child;
	  }
	});

	exports['default'] = Align;
	module.exports = exports['default'];

/***/ },
/* 764 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__, __webpack_module_template_argument_3__, __webpack_module_template_argument_4__, __webpack_module_template_argument_5__) {

	/**
	 * align dom node flexibly
	 * @author yiminghe@gmail.com
	 */

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _utils = __webpack_require__(__webpack_module_template_argument_0__);

	var _utils2 = _interopRequireDefault(_utils);

	var _getOffsetParent = __webpack_require__(__webpack_module_template_argument_1__);

	var _getOffsetParent2 = _interopRequireDefault(_getOffsetParent);

	var _getVisibleRectForElement = __webpack_require__(__webpack_module_template_argument_2__);

	var _getVisibleRectForElement2 = _interopRequireDefault(_getVisibleRectForElement);

	var _adjustForViewport = __webpack_require__(__webpack_module_template_argument_3__);

	var _adjustForViewport2 = _interopRequireDefault(_adjustForViewport);

	var _getRegion = __webpack_require__(__webpack_module_template_argument_4__);

	var _getRegion2 = _interopRequireDefault(_getRegion);

	var _getElFuturePos = __webpack_require__(__webpack_module_template_argument_5__);

	var _getElFuturePos2 = _interopRequireDefault(_getElFuturePos);

	// http://yiminghe.iteye.com/blog/1124720

	function isFailX(elFuturePos, elRegion, visibleRect) {
	  return elFuturePos.left < visibleRect.left || elFuturePos.left + elRegion.width > visibleRect.right;
	}

	function isFailY(elFuturePos, elRegion, visibleRect) {
	  return elFuturePos.top < visibleRect.top || elFuturePos.top + elRegion.height > visibleRect.bottom;
	}

	function isCompleteFailX(elFuturePos, elRegion, visibleRect) {
	  return elFuturePos.left > visibleRect.right || elFuturePos.left + elRegion.width < visibleRect.left;
	}

	function isCompleteFailY(elFuturePos, elRegion, visibleRect) {
	  return elFuturePos.top > visibleRect.bottom || elFuturePos.top + elRegion.height < visibleRect.top;
	}

	function flip(points, reg, map) {
	  var ret = [];
	  _utils2['default'].each(points, function (p) {
	    ret.push(p.replace(reg, function (m) {
	      return map[m];
	    }));
	  });
	  return ret;
	}

	function flipOffset(offset, index) {
	  offset[index] = -offset[index];
	  return offset;
	}

	function convertOffset(str, offsetLen) {
	  var n = undefined;
	  if (/%$/.test(str)) {
	    n = parseInt(str.substring(0, str.length - 1), 10) / 100 * offsetLen;
	  } else {
	    n = parseInt(str, 10);
	  }
	  return n || 0;
	}

	function normalizeOffset(offset, el) {
	  offset[0] = convertOffset(offset[0], el.width);
	  offset[1] = convertOffset(offset[1], el.height);
	}

	function domAlign(el, refNode, align) {
	  var points = align.points;
	  var offset = align.offset || [0, 0];
	  var targetOffset = align.targetOffset || [0, 0];
	  var overflow = align.overflow;
	  var target = align.target || refNode;
	  var source = align.source || el;
	  offset = [].concat(offset);
	  targetOffset = [].concat(targetOffset);
	  overflow = overflow || {};
	  var newOverflowCfg = {};

	  var fail = 0;
	  // 当前节点可以被放置的显示区域
	  var visibleRect = (0, _getVisibleRectForElement2['default'])(source);
	  // 当前节点所占的区域, left/top/width/height
	  var elRegion = (0, _getRegion2['default'])(source);
	  // 参照节点所占的区域, left/top/width/height
	  var refNodeRegion = (0, _getRegion2['default'])(target);
	  // 将 offset 转换成数值，支持百分比
	  normalizeOffset(offset, elRegion);
	  normalizeOffset(targetOffset, refNodeRegion);
	  // 当前节点将要被放置的位置
	  var elFuturePos = (0, _getElFuturePos2['default'])(elRegion, refNodeRegion, points, offset, targetOffset);
	  // 当前节点将要所处的区域
	  var newElRegion = _utils2['default'].merge(elRegion, elFuturePos);

	  // 如果可视区域不能完全放置当前节点时允许调整
	  if (visibleRect && (overflow.adjustX || overflow.adjustY)) {
	    if (overflow.adjustX) {
	      // 如果横向不能放下
	      if (isFailX(elFuturePos, elRegion, visibleRect)) {
	        // 对齐位置反下
	        var newPoints = flip(points, /[lr]/ig, {
	          l: 'r',
	          r: 'l'
	        });
	        // 偏移量也反下
	        var newOffset = flipOffset(offset, 0);
	        var newTargetOffset = flipOffset(targetOffset, 0);
	        var newElFuturePos = (0, _getElFuturePos2['default'])(elRegion, refNodeRegion, newPoints, newOffset, newTargetOffset);
	        if (!isCompleteFailX(newElFuturePos, elRegion, visibleRect)) {
	          fail = 1;
	          points = newPoints;
	          offset = newOffset;
	          targetOffset = newTargetOffset;
	        }
	      }
	    }

	    if (overflow.adjustY) {
	      // 如果纵向不能放下
	      if (isFailY(elFuturePos, elRegion, visibleRect)) {
	        // 对齐位置反下
	        var newPoints = flip(points, /[tb]/ig, {
	          t: 'b',
	          b: 't'
	        });
	        // 偏移量也反下
	        var newOffset = flipOffset(offset, 1);
	        var newTargetOffset = flipOffset(targetOffset, 1);
	        var newElFuturePos = (0, _getElFuturePos2['default'])(elRegion, refNodeRegion, newPoints, newOffset, newTargetOffset);
	        if (!isCompleteFailY(newElFuturePos, elRegion, visibleRect)) {
	          fail = 1;
	          points = newPoints;
	          offset = newOffset;
	          targetOffset = newTargetOffset;
	        }
	      }
	    }

	    // 如果失败，重新计算当前节点将要被放置的位置
	    if (fail) {
	      elFuturePos = (0, _getElFuturePos2['default'])(elRegion, refNodeRegion, points, offset, targetOffset);
	      _utils2['default'].mix(newElRegion, elFuturePos);
	    }

	    // 检查反下后的位置是否可以放下了
	    // 如果仍然放不下只有指定了可以调整当前方向才调整
	    newOverflowCfg.adjustX = overflow.adjustX && isFailX(elFuturePos, elRegion, visibleRect);

	    newOverflowCfg.adjustY = overflow.adjustY && isFailY(elFuturePos, elRegion, visibleRect);

	    // 确实要调整，甚至可能会调整高度宽度
	    if (newOverflowCfg.adjustX || newOverflowCfg.adjustY) {
	      newElRegion = (0, _adjustForViewport2['default'])(elFuturePos, elRegion, visibleRect, newOverflowCfg);
	    }
	  }

	  // need judge to in case set fixed with in css on height auto element
	  if (newElRegion.width !== elRegion.width) {
	    _utils2['default'].css(source, 'width', source.width() + newElRegion.width - elRegion.width);
	  }

	  if (newElRegion.height !== elRegion.height) {
	    _utils2['default'].css(source, 'height', source.height() + newElRegion.height - elRegion.height);
	  }

	  // https://github.com/kissyteam/kissy/issues/190
	  // http://localhost:8888/kissy/src/overlay/demo/other/relative_align/align.html
	  // 相对于屏幕位置没变，而 left/top 变了
	  // 例如 <div 'relative'><el absolute></div>
	  _utils2['default'].offset(source, {
	    left: newElRegion.left,
	    top: newElRegion.top
	  }, {
	    useCssRight: align.useCssRight,
	    useCssBottom: align.useCssBottom
	  });

	  return {
	    points: points,
	    offset: offset,
	    targetOffset: targetOffset,
	    overflow: newOverflowCfg
	  };
	}

	domAlign.__getOffsetParent = _getOffsetParent2['default'];

	domAlign.__getVisibleRectForElement = _getVisibleRectForElement2['default'];

	exports['default'] = domAlign;

	/**
	 *  2012-04-26 yiminghe@gmail.com
	 *   - 优化智能对齐算法
	 *   - 慎用 resizeXX
	 *
	 *  2011-07-13 yiminghe@gmail.com note:
	 *   - 增加智能对齐，以及大小调整选项
	 **/
		module.exports = exports['default'];

/***/ },
/* 765 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _utils = __webpack_require__(__webpack_module_template_argument_0__);

	var _utils2 = _interopRequireDefault(_utils);

	/**
	 * 得到会导致元素显示不全的祖先元素
	 */

	function getOffsetParent(element) {
	  // ie 这个也不是完全可行
	  /*
	   <div style="width: 50px;height: 100px;overflow: hidden">
	   <div style="width: 50px;height: 100px;position: relative;" id="d6">
	   元素 6 高 100px 宽 50px<br/>
	   </div>
	   </div>
	   */
	  // element.offsetParent does the right thing in ie7 and below. Return parent with layout!
	  //  In other browsers it only includes elements with position absolute, relative or
	  // fixed, not elements with overflow set to auto or scroll.
	  //        if (UA.ie && ieMode < 8) {
	  //            return element.offsetParent;
	  //        }
	  // 统一的 offsetParent 方法
	  var doc = element.ownerDocument;
	  var body = doc.body;
	  var parent = undefined;
	  var positionStyle = _utils2['default'].css(element, 'position');
	  var skipStatic = positionStyle === 'fixed' || positionStyle === 'absolute';

	  if (!skipStatic) {
	    return element.nodeName.toLowerCase() === 'html' ? null : element.parentNode;
	  }

	  for (parent = element.parentNode; parent && parent !== body; parent = parent.parentNode) {
	    positionStyle = _utils2['default'].css(parent, 'position');
	    if (positionStyle !== 'static') {
	      return parent;
	    }
	  }
	  return null;
	}

	exports['default'] = getOffsetParent;
	module.exports = exports['default'];

/***/ },
/* 766 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _utils = __webpack_require__(__webpack_module_template_argument_0__);

	var _utils2 = _interopRequireDefault(_utils);

	var _getOffsetParent = __webpack_require__(__webpack_module_template_argument_1__);

	var _getOffsetParent2 = _interopRequireDefault(_getOffsetParent);

	/**
	 * 获得元素的显示部分的区域
	 */
	function getVisibleRectForElement(element) {
	  var visibleRect = {
	    left: 0,
	    right: Infinity,
	    top: 0,
	    bottom: Infinity
	  };
	  var el = (0, _getOffsetParent2['default'])(element);
	  var scrollX = undefined;
	  var scrollY = undefined;
	  var winSize = undefined;
	  var doc = element.ownerDocument;
	  var win = doc.defaultView || doc.parentWindow;
	  var body = doc.body;
	  var documentElement = doc.documentElement;

	  // Determine the size of the visible rect by climbing the dom accounting for
	  // all scrollable containers.
	  while (el) {
	    // clientWidth is zero for inline block elements in ie.
	    if ((navigator.userAgent.indexOf('MSIE') === -1 || el.clientWidth !== 0) &&
	    // body may have overflow set on it, yet we still get the entire
	    // viewport. In some browsers, el.offsetParent may be
	    // document.documentElement, so check for that too.
	    el !== body && el !== documentElement && _utils2['default'].css(el, 'overflow') !== 'visible') {
	      var pos = _utils2['default'].offset(el);
	      // add border
	      pos.left += el.clientLeft;
	      pos.top += el.clientTop;
	      visibleRect.top = Math.max(visibleRect.top, pos.top);
	      visibleRect.right = Math.min(visibleRect.right,
	      // consider area without scrollBar
	      pos.left + el.clientWidth);
	      visibleRect.bottom = Math.min(visibleRect.bottom, pos.top + el.clientHeight);
	      visibleRect.left = Math.max(visibleRect.left, pos.left);
	    } else if (el === body || el === documentElement) {
	      break;
	    }
	    el = (0, _getOffsetParent2['default'])(el);
	  }

	  // Clip by window's viewport.
	  scrollX = _utils2['default'].getWindowScrollLeft(win);
	  scrollY = _utils2['default'].getWindowScrollTop(win);
	  visibleRect.left = Math.max(visibleRect.left, scrollX);
	  visibleRect.top = Math.max(visibleRect.top, scrollY);
	  winSize = {
	    width: _utils2['default'].viewportWidth(win),
	    height: _utils2['default'].viewportHeight(win)
	  };
	  visibleRect.right = Math.min(visibleRect.right, scrollX + winSize.width);
	  visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + winSize.height);
	  return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null;
	}

	exports['default'] = getVisibleRectForElement;
	module.exports = exports['default'];

/***/ },
/* 767 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _utils = __webpack_require__(__webpack_module_template_argument_0__);

	var _utils2 = _interopRequireDefault(_utils);

	function adjustForViewport(elFuturePos, elRegion, visibleRect, overflow) {
	  var pos = _utils2['default'].clone(elFuturePos);
	  var size = {
	    width: elRegion.width,
	    height: elRegion.height
	  };

	  if (overflow.adjustX && pos.left < visibleRect.left) {
	    pos.left = visibleRect.left;
	  }

	  // Left edge inside and right edge outside viewport, try to resize it.
	  if (overflow.resizeWidth && pos.left >= visibleRect.left && pos.left + size.width > visibleRect.right) {
	    size.width -= pos.left + size.width - visibleRect.right;
	  }

	  // Right edge outside viewport, try to move it.
	  if (overflow.adjustX && pos.left + size.width > visibleRect.right) {
	    // 保证左边界和可视区域左边界对齐
	    pos.left = Math.max(visibleRect.right - size.width, visibleRect.left);
	  }

	  // Top edge outside viewport, try to move it.
	  if (overflow.adjustY && pos.top < visibleRect.top) {
	    pos.top = visibleRect.top;
	  }

	  // Top edge inside and bottom edge outside viewport, try to resize it.
	  if (overflow.resizeHeight && pos.top >= visibleRect.top && pos.top + size.height > visibleRect.bottom) {
	    size.height -= pos.top + size.height - visibleRect.bottom;
	  }

	  // Bottom edge outside viewport, try to move it.
	  if (overflow.adjustY && pos.top + size.height > visibleRect.bottom) {
	    // 保证上边界和可视区域上边界对齐
	    pos.top = Math.max(visibleRect.bottom - size.height, visibleRect.top);
	  }

	  return _utils2['default'].mix(pos, size);
	}

	exports['default'] = adjustForViewport;
	module.exports = exports['default'];

/***/ },
/* 768 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _utils = __webpack_require__(__webpack_module_template_argument_0__);

	var _utils2 = _interopRequireDefault(_utils);

	function getRegion(node) {
	  var offset = undefined;
	  var w = undefined;
	  var h = undefined;
	  if (!_utils2['default'].isWindow(node) && node.nodeType !== 9) {
	    offset = _utils2['default'].offset(node);
	    w = _utils2['default'].outerWidth(node);
	    h = _utils2['default'].outerHeight(node);
	  } else {
	    var win = _utils2['default'].getWindow(node);
	    offset = {
	      left: _utils2['default'].getWindowScrollLeft(win),
	      top: _utils2['default'].getWindowScrollTop(win)
	    };
	    w = _utils2['default'].viewportWidth(win);
	    h = _utils2['default'].viewportHeight(win);
	  }
	  offset.width = w;
	  offset.height = h;
	  return offset;
	}

	exports['default'] = getRegion;
	module.exports = exports['default'];

/***/ },
/* 769 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _getAlignOffset = __webpack_require__(__webpack_module_template_argument_0__);

	var _getAlignOffset2 = _interopRequireDefault(_getAlignOffset);

	function getElFuturePos(elRegion, refNodeRegion, points, offset, targetOffset) {
	  var xy = undefined;
	  var diff = undefined;
	  var p1 = undefined;
	  var p2 = undefined;

	  xy = {
	    left: elRegion.left,
	    top: elRegion.top
	  };

	  p1 = (0, _getAlignOffset2['default'])(refNodeRegion, points[1]);
	  p2 = (0, _getAlignOffset2['default'])(elRegion, points[0]);

	  diff = [p2.left - p1.left, p2.top - p1.top];

	  return {
	    left: xy.left - diff[0] + offset[0] - targetOffset[0],
	    top: xy.top - diff[1] + offset[1] - targetOffset[1]
	  };
	}

	exports['default'] = getElFuturePos;
	module.exports = exports['default'];

/***/ },
/* 770 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	// export this package's api
	'use strict';

	module.exports = __webpack_require__(__webpack_module_template_argument_0__);

/***/ },
/* 771 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	  } else {
	    obj[key] = value;
	  }return obj;
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _ChildrenUtils = __webpack_require__(__webpack_module_template_argument_0__);

	var _AnimateChild = __webpack_require__(__webpack_module_template_argument_1__);

	var _AnimateChild2 = _interopRequireDefault(_AnimateChild);

	var _util = __webpack_require__(__webpack_module_template_argument_2__);

	var _util2 = _interopRequireDefault(_util);

	var defaultKey = 'rc_animate_' + Date.now();

	function getChildrenFromProps(props) {
	  var children = props.children;
	  if (_react2['default'].isValidElement(children)) {
	    if (!children.key) {
	      return _react2['default'].cloneElement(children, {
	        key: defaultKey
	      });
	    }
	  }
	  return children;
	}

	function noop() {}

	var Animate = _react2['default'].createClass({
	  displayName: 'Animate',

	  propTypes: {
	    component: _react2['default'].PropTypes.any,
	    animation: _react2['default'].PropTypes.object,
	    transitionName: _react2['default'].PropTypes.string,
	    transitionEnter: _react2['default'].PropTypes.bool,
	    transitionAppear: _react2['default'].PropTypes.bool,
	    exclusive: _react2['default'].PropTypes.bool,
	    transitionLeave: _react2['default'].PropTypes.bool,
	    onEnd: _react2['default'].PropTypes.func,
	    onEnter: _react2['default'].PropTypes.func,
	    onLeave: _react2['default'].PropTypes.func,
	    onAppear: _react2['default'].PropTypes.func,
	    showProp: _react2['default'].PropTypes.string
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      animation: {},
	      component: 'span',
	      transitionEnter: true,
	      transitionLeave: true,
	      transitionAppear: false,
	      onEnd: noop,
	      onEnter: noop,
	      onLeave: noop,
	      onAppear: noop
	    };
	  },

	  getInitialState: function getInitialState() {
	    this.currentlyAnimatingKeys = {};
	    this.keysToEnter = [];
	    this.keysToLeave = [];
	    return {
	      children: (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(this.props))
	    };
	  },

	  componentDidMount: function componentDidMount() {
	    var _this = this;

	    var showProp = this.props.showProp;
	    var children = this.state.children;
	    if (showProp) {
	      children = children.filter(function (child) {
	        return !!child.props[showProp];
	      });
	    }
	    children.forEach(function (child) {
	      _this.performAppear(child.key);
	    });
	  },

	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    var _this2 = this;

	    this.nextProps = nextProps;
	    var nextChildren = (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(nextProps));
	    var props = this.props;
	    // exclusive needs immediate response
	    if (props.exclusive) {
	      Object.keys(this.currentlyAnimatingKeys).forEach(function (key) {
	        _this2.stop(key);
	      });
	    }
	    var showProp = props.showProp;
	    var currentlyAnimatingKeys = this.currentlyAnimatingKeys;
	    // last props children if exclusive
	    var currentChildren = props.exclusive ? (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(props)) : this.state.children;
	    // in case destroy in showProp mode
	    var newChildren = [];
	    if (showProp) {
	      currentChildren.forEach(function (currentChild) {
	        var nextChild = (0, _ChildrenUtils.findChildInChildrenByKey)(nextChildren, currentChild.key);
	        var newChild = undefined;
	        if ((!nextChild || !nextChild.props[showProp]) && currentChild.props[showProp]) {
	          newChild = _react2['default'].cloneElement(nextChild || currentChild, _defineProperty({}, showProp, true));
	        } else {
	          newChild = nextChild;
	        }
	        if (newChild) {
	          newChildren.push(newChild);
	        }
	      });
	      nextChildren.forEach(function (nextChild) {
	        if (!(0, _ChildrenUtils.findChildInChildrenByKey)(currentChildren, nextChild.key)) {
	          newChildren.push(nextChild);
	        }
	      });
	    } else {
	      newChildren = (0, _ChildrenUtils.mergeChildren)(currentChildren, nextChildren);
	    }

	    // need render to avoid update
	    this.setState({
	      children: newChildren
	    });

	    nextChildren.forEach(function (child) {
	      var key = child.key;
	      if (currentlyAnimatingKeys[key]) {
	        return;
	      }
	      var hasPrev = (0, _ChildrenUtils.findChildInChildrenByKey)(currentChildren, key);
	      if (showProp) {
	        var showInNext = child.props[showProp];
	        if (hasPrev) {
	          var showInNow = (0, _ChildrenUtils.findShownChildInChildrenByKey)(currentChildren, key, showProp);
	          if (!showInNow && showInNext) {
	            _this2.keysToEnter.push(key);
	          }
	        } else if (showInNext) {
	          _this2.keysToEnter.push(key);
	        }
	      } else if (!hasPrev) {
	        _this2.keysToEnter.push(key);
	      }
	    });

	    currentChildren.forEach(function (child) {
	      var key = child.key;
	      if (currentlyAnimatingKeys[key]) {
	        return;
	      }
	      var hasNext = (0, _ChildrenUtils.findChildInChildrenByKey)(nextChildren, key);
	      if (showProp) {
	        var showInNow = child.props[showProp];
	        if (hasNext) {
	          var showInNext = (0, _ChildrenUtils.findShownChildInChildrenByKey)(nextChildren, key, showProp);
	          if (!showInNext && showInNow) {
	            _this2.keysToLeave.push(key);
	          }
	        } else if (showInNow) {
	          _this2.keysToLeave.push(key);
	        }
	      } else if (!hasNext) {
	        _this2.keysToLeave.push(key);
	      }
	    });
	  },

	  componentDidUpdate: function componentDidUpdate() {
	    if (this.isMounted()) {
	      var keysToEnter = this.keysToEnter;
	      this.keysToEnter = [];
	      keysToEnter.forEach(this.performEnter);
	      var keysToLeave = this.keysToLeave;
	      this.keysToLeave = [];
	      keysToLeave.forEach(this.performLeave);
	    }
	  },

	  performEnter: function performEnter(key) {
	    // may already remove by exclusive
	    if (this.refs[key]) {
	      this.currentlyAnimatingKeys[key] = true;
	      this.refs[key].componentWillEnter(this.handleDoneAdding.bind(this, key, 'enter'));
	    }
	  },

	  performAppear: function performAppear(key) {
	    if (this.refs[key]) {
	      this.currentlyAnimatingKeys[key] = true;
	      this.refs[key].componentWillAppear(this.handleDoneAdding.bind(this, key, 'appear'));
	    }
	  },

	  handleDoneAdding: function handleDoneAdding(key, type) {
	    var props = this.props;
	    delete this.currentlyAnimatingKeys[key];
	    // if update on exclusive mode, skip check
	    if (props.exclusive && props !== this.nextProps) {
	      return;
	    }
	    var currentChildren = (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(props));
	    if (!this.isValidChildByKey(currentChildren, key)) {
	      // exclusive will not need this
	      this.performLeave(key);
	    } else {
	      if (type === 'appear') {
	        if (_util2['default'].allowAppearCallback(props)) {
	          props.onAppear(key);
	          props.onEnd(key, true);
	        }
	      } else {
	        if (_util2['default'].allowEnterCallback(props)) {
	          props.onEnter(key);
	          props.onEnd(key, true);
	        }
	      }
	    }
	  },

	  performLeave: function performLeave(key) {
	    // may already remove by exclusive
	    if (this.refs[key]) {
	      this.currentlyAnimatingKeys[key] = true;
	      this.refs[key].componentWillLeave(this.handleDoneLeaving.bind(this, key));
	    }
	  },

	  handleDoneLeaving: function handleDoneLeaving(key) {
	    var props = this.props;
	    delete this.currentlyAnimatingKeys[key];
	    // if update on exclusive mode, skip check
	    if (props.exclusive && props !== this.nextProps) {
	      return;
	    }
	    var currentChildren = (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(props));
	    // in case state change is too fast
	    if (this.isValidChildByKey(currentChildren, key)) {
	      this.performEnter(key);
	    } else {
	      if (_util2['default'].allowLeaveCallback(props)) {
	        props.onLeave(key);
	        props.onEnd(key, false);
	      }
	      if (this.isMounted() && !(0, _ChildrenUtils.isSameChildren)(this.state.children, currentChildren, props.showProp)) {
	        this.setState({
	          children: currentChildren
	        });
	      }
	    }
	  },

	  isValidChildByKey: function isValidChildByKey(currentChildren, key) {
	    var showProp = this.props.showProp;
	    if (showProp) {
	      return (0, _ChildrenUtils.findShownChildInChildrenByKey)(currentChildren, key, showProp);
	    }
	    return (0, _ChildrenUtils.findChildInChildrenByKey)(currentChildren, key);
	  },

	  stop: function stop(key) {
	    delete this.currentlyAnimatingKeys[key];
	    var component = this.refs[key];
	    if (component) {
	      component.stop();
	    }
	  },

	  render: function render() {
	    var props = this.props;
	    this.nextProps = props;
	    var stateChildren = this.state.children;
	    var children = null;
	    if (stateChildren) {
	      children = stateChildren.map(function (child) {
	        if (child === null) {
	          return child;
	        }
	        if (!child.key) {
	          throw new Error('must set key for <rc-animate> children');
	        }
	        return _react2['default'].createElement(_AnimateChild2['default'], {
	          key: child.key,
	          ref: child.key,
	          animation: props.animation,
	          transitionName: props.transitionName,
	          transitionEnter: props.transitionEnter,
	          transitionAppear: props.transitionAppear,
	          transitionLeave: props.transitionLeave }, child);
	      });
	    }
	    var Component = props.component;
	    if (Component) {
	      return _react2['default'].createElement(Component, this.props, children);
	    }
	    return children[0] || null;
	  }
	});

	exports['default'] = Animate;
	module.exports = exports['default'];

/***/ },
/* 772 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(4);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _cssAnimation = __webpack_require__(__webpack_module_template_argument_0__);

	var _cssAnimation2 = _interopRequireDefault(_cssAnimation);

	var _util = __webpack_require__(__webpack_module_template_argument_1__);

	var _util2 = _interopRequireDefault(_util);

	var transitionMap = {
	  enter: 'transitionEnter',
	  appear: 'transitionAppear',
	  leave: 'transitionLeave'
	};

	var AnimateChild = _react2['default'].createClass({
	  displayName: 'AnimateChild',

	  propTypes: {
	    children: _react2['default'].PropTypes.any
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    this.stop();
	  },

	  componentWillEnter: function componentWillEnter(done) {
	    if (_util2['default'].isEnterSupported(this.props)) {
	      this.transition('enter', done);
	    } else {
	      done();
	    }
	  },

	  componentWillAppear: function componentWillAppear(done) {
	    if (_util2['default'].isAppearSupported(this.props)) {
	      this.transition('appear', done);
	    } else {
	      done();
	    }
	  },

	  componentWillLeave: function componentWillLeave(done) {
	    if (_util2['default'].isLeaveSupported(this.props)) {
	      this.transition('leave', done);
	    } else {
	      done();
	    }
	  },

	  transition: function transition(animationType, finishCallback) {
	    var _this = this;

	    var node = _reactDom2['default'].findDOMNode(this);
	    var props = this.props;
	    var transitionName = props.transitionName;
	    this.stop();
	    var end = function end() {
	      _this.stopper = null;
	      finishCallback();
	    };
	    if ((_cssAnimation.isCssAnimationSupported || !props.animation[animationType]) && transitionName && props[transitionMap[animationType]]) {
	      this.stopper = (0, _cssAnimation2['default'])(node, transitionName + '-' + animationType, end);
	    } else {
	      this.stopper = props.animation[animationType](node, end);
	    }
	  },

	  stop: function stop() {
	    var stopper = this.stopper;
	    if (stopper) {
	      this.stopper = null;
	      stopper.stop();
	    }
	  },

	  render: function render() {
	    return this.props.children;
	  }
	});

	exports['default'] = AnimateChild;
	module.exports = exports['default'];

/***/ },
/* 773 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Event = __webpack_require__(__webpack_module_template_argument_0__);

	var _Event2 = _interopRequireDefault(_Event);

	var _componentClasses = __webpack_require__(__webpack_module_template_argument_1__);

	var _componentClasses2 = _interopRequireDefault(_componentClasses);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}

	var isCssAnimationSupported = _Event2["default"].endEvents.length !== 0;

	var capitalPrefixes = ['Webkit', 'Moz', 'O',
	// ms is special .... !
	'ms'];
	var prefixes = ['-webkit-', '-moz-', '-o-', 'ms-', ''];

	function getDuration(node, name) {
	  var style = window.getComputedStyle(node);

	  var ret = '';
	  for (var i = 0; i < prefixes.length; i++) {
	    ret = style.getPropertyValue(prefixes[i] + name);
	    if (ret) {
	      break;
	    }
	  }
	  return ret;
	}

	function fixBrowserByTimeout(node) {
	  if (isCssAnimationSupported) {
	    var transitionDuration = parseFloat(getDuration(node, 'transition-duration')) || 0;
	    var animationDuration = parseFloat(getDuration(node, 'animation-duration')) || 0;
	    var time = Math.max(transitionDuration, animationDuration);
	    // sometimes, browser bug
	    node.rcEndAnimTimeout = setTimeout(function () {
	      node.rcEndAnimTimeout = null;
	      if (node.rcEndListener) {
	        node.rcEndListener();
	      }
	    }, time * 1000 + 200);
	  }
	}

	function clearBrowserBugTimeout(node) {
	  if (node.rcEndAnimTimeout) {
	    clearTimeout(node.rcEndAnimTimeout);
	    node.rcEndAnimTimeout = null;
	  }
	}

	var cssAnimation = function cssAnimation(node, transitionName, endCallback) {
	  var className = transitionName;
	  var activeClassName = className + '-active';
	  var end = endCallback;
	  var start = void 0;
	  var active = void 0;
	  var nodeClasses = (0, _componentClasses2["default"])(node);

	  if (endCallback && Object.prototype.toString.call(endCallback) === '[object Object]') {
	    end = endCallback.end;
	    start = endCallback.start;
	    active = endCallback.active;
	  }

	  if (node.rcEndListener) {
	    node.rcEndListener();
	  }

	  node.rcEndListener = function (e) {
	    if (e && e.target !== node) {
	      return;
	    }

	    if (node.rcAnimTimeout) {
	      clearTimeout(node.rcAnimTimeout);
	      node.rcAnimTimeout = null;
	    }

	    clearBrowserBugTimeout(node);

	    nodeClasses.remove(className);
	    nodeClasses.remove(activeClassName);

	    _Event2["default"].removeEndEventListener(node, node.rcEndListener);
	    node.rcEndListener = null;

	    // Usually this optional end is used for informing an owner of
	    // a leave animation and telling it to remove the child.
	    if (end) {
	      end();
	    }
	  };

	  _Event2["default"].addEndEventListener(node, node.rcEndListener);

	  nodeClasses.add(className);

	  if (start) {
	    start();
	  }

	  node.rcAnimTimeout = setTimeout(function () {
	    node.rcAnimTimeout = null;
	    nodeClasses.add(activeClassName);
	    if (active) {
	      active();
	    }
	    fixBrowserByTimeout(node);
	  }, 0);

	  return {
	    stop: function stop() {
	      if (node.rcEndListener) {
	        node.rcEndListener();
	      }
	    }
	  };
	};

	cssAnimation.style = function (node, style, callback) {
	  if (node.rcEndListener) {
	    node.rcEndListener();
	  }

	  node.rcEndListener = function (e) {
	    if (e && e.target !== node) {
	      return;
	    }

	    if (node.rcAnimTimeout) {
	      clearTimeout(node.rcAnimTimeout);
	      node.rcAnimTimeout = null;
	    }

	    clearBrowserBugTimeout(node);

	    _Event2["default"].removeEndEventListener(node, node.rcEndListener);
	    node.rcEndListener = null;

	    // Usually this optional callback is used for informing an owner of
	    // a leave animation and telling it to remove the child.
	    if (callback) {
	      callback();
	    }
	  };

	  _Event2["default"].addEndEventListener(node, node.rcEndListener);

	  node.rcAnimTimeout = setTimeout(function () {
	    for (var s in style) {
	      if (style.hasOwnProperty(s)) {
	        node.style[s] = style[s];
	      }
	    }
	    node.rcAnimTimeout = null;
	    fixBrowserByTimeout(node);
	  }, 0);
	};

	cssAnimation.setTransition = function (node, p, value) {
	  var property = p;
	  var v = value;
	  if (value === undefined) {
	    v = property;
	    property = '';
	  }
	  property = property || '';
	  capitalPrefixes.forEach(function (prefix) {
	    node.style[prefix + 'Transition' + property] = v;
	  });
	};

	cssAnimation.isCssAnimationSupported = isCssAnimationSupported;

	exports["default"] = cssAnimation;
	module.exports = exports['default'];

/***/ },
/* 774 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__) {

	'use strict';

	/**
	 * Module dependencies.
	 */

	try {
	  var index = __webpack_require__(__webpack_module_template_argument_0__);
	} catch (err) {
	  var index = __webpack_require__(__webpack_module_template_argument_1__);
	}

	/**
	 * Whitespace regexp.
	 */

	var re = /\s+/;

	/**
	 * toString reference.
	 */

	var toString = Object.prototype.toString;

	/**
	 * Wrap `el` in a `ClassList`.
	 *
	 * @param {Element} el
	 * @return {ClassList}
	 * @api public
	 */

	module.exports = function (el) {
	  return new ClassList(el);
	};

	/**
	 * Initialize a new ClassList for `el`.
	 *
	 * @param {Element} el
	 * @api private
	 */

	function ClassList(el) {
	  if (!el || !el.nodeType) {
	    throw new Error('A DOM element reference is required');
	  }
	  this.el = el;
	  this.list = el.classList;
	}

	/**
	 * Add class `name` if not already present.
	 *
	 * @param {String} name
	 * @return {ClassList}
	 * @api public
	 */

	ClassList.prototype.add = function (name) {
	  // classList
	  if (this.list) {
	    this.list.add(name);
	    return this;
	  }

	  // fallback
	  var arr = this.array();
	  var i = index(arr, name);
	  if (! ~i) arr.push(name);
	  this.el.className = arr.join(' ');
	  return this;
	};

	/**
	 * Remove class `name` when present, or
	 * pass a regular expression to remove
	 * any which match.
	 *
	 * @param {String|RegExp} name
	 * @return {ClassList}
	 * @api public
	 */

	ClassList.prototype.remove = function (name) {
	  if ('[object RegExp]' == toString.call(name)) {
	    return this.removeMatching(name);
	  }

	  // classList
	  if (this.list) {
	    this.list.remove(name);
	    return this;
	  }

	  // fallback
	  var arr = this.array();
	  var i = index(arr, name);
	  if (~i) arr.splice(i, 1);
	  this.el.className = arr.join(' ');
	  return this;
	};

	/**
	 * Remove all classes matching `re`.
	 *
	 * @param {RegExp} re
	 * @return {ClassList}
	 * @api private
	 */

	ClassList.prototype.removeMatching = function (re) {
	  var arr = this.array();
	  for (var i = 0; i < arr.length; i++) {
	    if (re.test(arr[i])) {
	      this.remove(arr[i]);
	    }
	  }
	  return this;
	};

	/**
	 * Toggle class `name`, can force state via `force`.
	 *
	 * For browsers that support classList, but do not support `force` yet,
	 * the mistake will be detected and corrected.
	 *
	 * @param {String} name
	 * @param {Boolean} force
	 * @return {ClassList}
	 * @api public
	 */

	ClassList.prototype.toggle = function (name, force) {
	  // classList
	  if (this.list) {
	    if ("undefined" !== typeof force) {
	      if (force !== this.list.toggle(name, force)) {
	        this.list.toggle(name); // toggle again to correct
	      }
	    } else {
	        this.list.toggle(name);
	      }
	    return this;
	  }

	  // fallback
	  if ("undefined" !== typeof force) {
	    if (!force) {
	      this.remove(name);
	    } else {
	      this.add(name);
	    }
	  } else {
	    if (this.has(name)) {
	      this.remove(name);
	    } else {
	      this.add(name);
	    }
	  }

	  return this;
	};

	/**
	 * Return an array of classes.
	 *
	 * @return {Array}
	 * @api public
	 */

	ClassList.prototype.array = function () {
	  var className = this.el.getAttribute('class') || '';
	  var str = className.replace(/^\s+|\s+$/g, '');
	  var arr = str.split(re);
	  if ('' === arr[0]) arr.shift();
	  return arr;
	};

	/**
	 * Check if class `name` is present.
	 *
	 * @param {String} name
	 * @return {ClassList}
	 * @api public
	 */

	ClassList.prototype.has = ClassList.prototype.contains = function (name) {
	  return this.list ? this.list.contains(name) : !! ~index(this.array(), name);
		};

/***/ },
/* 775 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _LazyRenderBox = __webpack_require__(__webpack_module_template_argument_0__);

	var _LazyRenderBox2 = _interopRequireDefault(_LazyRenderBox);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}

	var PopupInner = _react2["default"].createClass({
	  displayName: 'PopupInner',

	  propTypes: {
	    hiddenClassName: _react.PropTypes.string,
	    className: _react.PropTypes.string,
	    prefixCls: _react.PropTypes.string,
	    onMouseEnter: _react.PropTypes.func,
	    onMouseLeave: _react.PropTypes.func,
	    children: _react.PropTypes.any
	  },
	  render: function render() {
	    var props = this.props;
	    var className = props.className;
	    if (!props.visible) {
	      className += ' ' + props.hiddenClassName;
	    }
	    return _react2["default"].createElement('div', {
	      className: className,
	      onMouseEnter: props.onMouseEnter,
	      onMouseLeave: props.onMouseLeave,
	      style: props.style
	    }, _react2["default"].createElement(_LazyRenderBox2["default"], { className: props.prefixCls + '-content', visible: props.visible }, props.children));
	  }
	});

	exports["default"] = PopupInner;
	module.exports = exports['default'];

/***/ },
/* 776 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	module.exports = __webpack_require__(__webpack_module_template_argument_0__);

/***/ },
/* 777 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	function _objectWithoutProperties(obj, keys) {
	  var target = {};for (var i in obj) {
	    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	  }return target;
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _placements = __webpack_require__(__webpack_module_template_argument_0__);

	var _rcTrigger = __webpack_require__(__webpack_module_template_argument_1__);

	var _rcTrigger2 = _interopRequireDefault(_rcTrigger);

	var Tooltip = _react2['default'].createClass({
	  displayName: 'Tooltip',

	  propTypes: {
	    trigger: _react.PropTypes.any,
	    children: _react.PropTypes.any,
	    defaultVisible: _react.PropTypes.bool,
	    visible: _react.PropTypes.bool,
	    placement: _react.PropTypes.string,
	    transitionName: _react.PropTypes.string,
	    animation: _react.PropTypes.any,
	    onVisibleChange: _react.PropTypes.func,
	    afterVisibleChange: _react.PropTypes.func,
	    overlay: _react.PropTypes.node.isRequired,
	    overlayStyle: _react.PropTypes.object,
	    overlayClassName: _react.PropTypes.string,
	    prefixCls: _react.PropTypes.string,
	    mouseEnterDelay: _react.PropTypes.number,
	    mouseLeaveDelay: _react.PropTypes.number,
	    getTooltipContainer: _react.PropTypes.func,
	    destroyTooltipOnHide: _react.PropTypes.bool,
	    align: _react.PropTypes.shape({
	      offset: _react.PropTypes.array,
	      targetOffset: _react.PropTypes.array
	    }),
	    arrowContent: _react.PropTypes.any
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      prefixCls: 'rc-tooltip',
	      mouseEnterDelay: 0,
	      destroyTooltipOnHide: false,
	      mouseLeaveDelay: 0.1,
	      align: {},
	      placement: 'right',
	      trigger: ['hover'],
	      arrowContent: null
	    };
	  },

	  getPopupElement: function getPopupElement() {
	    var _props = this.props;
	    var arrowContent = _props.arrowContent;
	    var overlay = _props.overlay;
	    var prefixCls = _props.prefixCls;

	    return [_react2['default'].createElement('div', { className: prefixCls + '-arrow', key: 'arrow' }, arrowContent), _react2['default'].createElement('div', { className: prefixCls + '-inner', key: 'content' }, overlay)];
	  },

	  getPopupDomNode: function getPopupDomNode() {
	    return this.refs.trigger.popupDomNode;
	  },

	  render: function render() {
	    var _props2 = this.props;
	    var overlayClassName = _props2.overlayClassName;
	    var trigger = _props2.trigger;
	    var mouseEnterDelay = _props2.mouseEnterDelay;
	    var mouseLeaveDelay = _props2.mouseLeaveDelay;
	    var overlayStyle = _props2.overlayStyle;
	    var prefixCls = _props2.prefixCls;
	    var children = _props2.children;
	    var onVisibleChange = _props2.onVisibleChange;
	    var transitionName = _props2.transitionName;
	    var animation = _props2.animation;
	    var placement = _props2.placement;
	    var align = _props2.align;
	    var destroyTooltipOnHide = _props2.destroyTooltipOnHide;
	    var defaultVisible = _props2.defaultVisible;
	    var getTooltipContainer = _props2.getTooltipContainer;

	    var restProps = _objectWithoutProperties(_props2, ['overlayClassName', 'trigger', 'mouseEnterDelay', 'mouseLeaveDelay', 'overlayStyle', 'prefixCls', 'children', 'onVisibleChange', 'transitionName', 'animation', 'placement', 'align', 'destroyTooltipOnHide', 'defaultVisible', 'getTooltipContainer']);

	    var extraProps = _extends({}, restProps);
	    if ('visible' in this.props) {
	      extraProps.popupVisible = this.props.visible;
	    }
	    return _react2['default'].createElement(_rcTrigger2['default'], _extends({ popupClassName: overlayClassName,
	      ref: 'trigger',
	      prefixCls: prefixCls,
	      popup: this.getPopupElement(),
	      action: trigger,
	      builtinPlacements: _placements.placements,
	      popupPlacement: placement,
	      popupAlign: align,
	      getPopupContainer: getTooltipContainer,
	      onPopupVisibleChange: onVisibleChange,
	      popupTransitionName: transitionName,
	      popupAnimation: animation,
	      defaultPopupVisible: defaultVisible,
	      destroyPopupOnHide: destroyTooltipOnHide,
	      mouseLeaveDelay: mouseLeaveDelay,
	      popupStyle: overlayStyle,
	      mouseEnterDelay: mouseEnterDelay
	    }, extraProps), children);
	  }
	});

	exports['default'] = Tooltip;
	module.exports = exports['default'];

/***/ },
/* 778 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var pSlice = Array.prototype.slice;
	var objectKeys = __webpack_require__(__webpack_module_template_argument_0__);
	var isArguments = __webpack_require__(__webpack_module_template_argument_1__);

	var deepEqual = module.exports = function (actual, expected, opts) {
	  if (!opts) opts = {};
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;
	  } else if (actual instanceof Date && expected instanceof Date) {
	    return actual.getTime() === expected.getTime();

	    // 7.3. Other pairs that do not both pass typeof value == 'object',
	    // equivalence is determined by ==.
	  } else if (!actual || !expected || (typeof actual === 'undefined' ? 'undefined' : _typeof(actual)) != 'object' && (typeof expected === 'undefined' ? 'undefined' : _typeof(expected)) != 'object') {
	      return opts.strict ? actual === expected : actual == expected;

	      // 7.4. For all other Object pairs, including Array objects, equivalence is
	      // determined by having the same number of owned properties (as verified
	      // with Object.prototype.hasOwnProperty.call), the same set of keys
	      // (although not necessarily the same order), equivalent values for every
	      // corresponding key, and an identical 'prototype' property. Note: this
	      // accounts for both named and indexed properties on Arrays.
	    } else {
	        return objEquiv(actual, expected, opts);
	      }
	};

	function isUndefinedOrNull(value) {
	  return value === null || value === undefined;
	}

	function isBuffer(x) {
	  if (!x || (typeof x === 'undefined' ? 'undefined' : _typeof(x)) !== 'object' || typeof x.length !== 'number') return false;
	  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
	    return false;
	  }
	  if (x.length > 0 && typeof x[0] !== 'number') return false;
	  return true;
	}

	function objEquiv(a, b, opts) {
	  var i, key;
	  if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) return false;
	  // an identical 'prototype' property.
	  if (a.prototype !== b.prototype) return false;
	  //~~~I've managed to break Object.keys through screwy arguments passing.
	  //   Converting to array solves the problem.
	  if (isArguments(a)) {
	    if (!isArguments(b)) {
	      return false;
	    }
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return deepEqual(a, b, opts);
	  }
	  if (isBuffer(a)) {
	    if (!isBuffer(b)) {
	      return false;
	    }
	    if (a.length !== b.length) return false;
	    for (i = 0; i < a.length; i++) {
	      if (a[i] !== b[i]) return false;
	    }
	    return true;
	  }
	  try {
	    var ka = objectKeys(a),
	        kb = objectKeys(b);
	  } catch (e) {
	    //happens when one is a string literal and the other isn't
	    return false;
	  }
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length != kb.length) return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] != kb[i]) return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!deepEqual(a[key], b[key], opts)) return false;
	  }
	  return (typeof a === 'undefined' ? 'undefined' : _typeof(a)) === (typeof b === 'undefined' ? 'undefined' : _typeof(b));
		}

/***/ },
/* 779 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__, __webpack_module_template_argument_3__, __webpack_module_template_argument_4__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _Menu = __webpack_require__(__webpack_module_template_argument_0__);

	var _Menu2 = _interopRequireDefault(_Menu);

	var _SubMenu = __webpack_require__(__webpack_module_template_argument_1__);

	var _SubMenu2 = _interopRequireDefault(_SubMenu);

	var _MenuItem = __webpack_require__(__webpack_module_template_argument_2__);

	var _MenuItem2 = _interopRequireDefault(_MenuItem);

	var _MenuItemGroup = __webpack_require__(__webpack_module_template_argument_3__);

	var _MenuItemGroup2 = _interopRequireDefault(_MenuItemGroup);

	var _Divider = __webpack_require__(__webpack_module_template_argument_4__);

	var _Divider2 = _interopRequireDefault(_Divider);

	exports.SubMenu = _SubMenu2['default'];
	exports.Item = _MenuItem2['default'];
	exports.MenuItem = _MenuItem2['default'];
	exports.MenuItemGroup = _MenuItemGroup2['default'];
	exports.ItemGroup = _MenuItemGroup2['default'];
	exports.Divider = _Divider2['default'];
	exports['default'] = _Menu2['default'];

/***/ },
/* 780 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _MenuMixin = __webpack_require__(__webpack_module_template_argument_0__);

	var _MenuMixin2 = _interopRequireDefault(_MenuMixin);

	var _objectAssign = __webpack_require__(__webpack_module_template_argument_1__);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	var _util = __webpack_require__(__webpack_module_template_argument_2__);

	var Menu = _react2['default'].createClass({
	  displayName: 'Menu',

	  propTypes: {
	    openSubMenuOnMouseEnter: _react2['default'].PropTypes.bool,
	    closeSubMenuOnMouseLeave: _react2['default'].PropTypes.bool,
	    selectedKeys: _react2['default'].PropTypes.arrayOf(_react2['default'].PropTypes.string),
	    defaultSelectedKeys: _react2['default'].PropTypes.arrayOf(_react2['default'].PropTypes.string),
	    defaultOpenKeys: _react2['default'].PropTypes.arrayOf(_react2['default'].PropTypes.string),
	    openKeys: _react2['default'].PropTypes.arrayOf(_react2['default'].PropTypes.string),
	    mode: _react2['default'].PropTypes.string,
	    onClick: _react2['default'].PropTypes.func,
	    onSelect: _react2['default'].PropTypes.func,
	    onDeselect: _react2['default'].PropTypes.func,
	    onDestroy: _react2['default'].PropTypes.func,
	    openTransitionName: _react2['default'].PropTypes.string,
	    openAnimation: _react2['default'].PropTypes.oneOfType([_react2['default'].PropTypes.string, _react2['default'].PropTypes.object]),
	    level: _react2['default'].PropTypes.number,
	    eventKey: _react2['default'].PropTypes.string,
	    selectable: _react2['default'].PropTypes.bool,
	    children: _react2['default'].PropTypes.any
	  },

	  mixins: [_MenuMixin2['default']],

	  getDefaultProps: function getDefaultProps() {
	    return {
	      openSubMenuOnMouseEnter: true,
	      closeSubMenuOnMouseLeave: true,
	      selectable: true,
	      onClick: _util.noop,
	      onSelect: _util.noop,
	      onOpen: _util.noop,
	      onClose: _util.noop,
	      onDeselect: _util.noop,
	      defaultSelectedKeys: [],
	      defaultOpenKeys: []
	    };
	  },

	  getInitialState: function getInitialState() {
	    var props = this.props;
	    var selectedKeys = props.defaultSelectedKeys;
	    var openKeys = props.defaultOpenKeys;
	    if ('selectedKeys' in props) {
	      selectedKeys = props.selectedKeys || [];
	    }
	    if ('openKeys' in props) {
	      openKeys = props.openKeys || [];
	    }
	    return {
	      selectedKeys: selectedKeys, openKeys: openKeys
	    };
	  },

	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    var props = {};
	    if ('selectedKeys' in nextProps) {
	      props.selectedKeys = nextProps.selectedKeys;
	    }
	    if ('openKeys' in nextProps) {
	      props.openKeys = nextProps.openKeys;
	    }
	    this.setState(props);
	  },

	  onDestroy: function onDestroy(key) {
	    var state = this.state;
	    var props = this.props;
	    var selectedKeys = state.selectedKeys;
	    var openKeys = state.openKeys;
	    var index = selectedKeys.indexOf(key);
	    if (!('selectedKeys' in props) && index !== -1) {
	      selectedKeys.splice(index, 1);
	    }
	    index = openKeys.indexOf(key);
	    if (!('openKeys' in props) && index !== -1) {
	      openKeys.splice(index, 1);
	    }
	  },

	  onItemHover: function onItemHover(e) {
	    var _this = this;

	    var item = e.item;

	    // special for top sub menu
	    if (this.props.mode !== 'inline' && !this.props.closeSubMenuOnMouseLeave && item.isSubMenu) {
	      (function () {
	        var activeKey = _this.state.activeKey;
	        var activeItem = _this.getFlatInstanceArray().filter(function (c) {
	          return c && c.props.eventKey === activeKey;
	        })[0];
	        if (activeItem && activeItem.props.open) {
	          _this.onOpenChange({
	            key: item.props.eventKey,
	            item: e.item,
	            open: true
	          });
	        }
	      })();
	    }

	    this.onCommonItemHover(e);
	  },

	  onSelect: function onSelect(selectInfo) {
	    var props = this.props;
	    if (props.selectable) {
	      // root menu
	      var selectedKeys = this.state.selectedKeys;
	      var selectedKey = selectInfo.key;
	      if (props.multiple) {
	        selectedKeys = selectedKeys.concat([selectedKey]);
	      } else {
	        selectedKeys = [selectedKey];
	      }
	      if (!('selectedKeys' in props)) {
	        this.setState({
	          selectedKeys: selectedKeys
	        });
	      }
	      props.onSelect((0, _objectAssign2['default'])({}, selectInfo, {
	        selectedKeys: selectedKeys
	      }));
	    }
	  },

	  onClick: function onClick(e) {
	    var props = this.props;
	    props.onClick(e);
	  },

	  onOpenChange: function onOpenChange(e) {
	    var openKeys = this.state.openKeys;
	    var props = this.props;
	    var changed = true;
	    if (e.open) {
	      changed = openKeys.indexOf(e.key) === -1;
	      if (changed) {
	        openKeys = openKeys.concat(e.key);
	      }
	    } else {
	      var index = openKeys.indexOf(e.key);
	      changed = index !== -1;
	      if (changed) {
	        openKeys = openKeys.concat();
	        openKeys.splice(index, 1);
	      }
	    }
	    if (changed) {
	      if (!('openKeys' in this.props)) {
	        // hack: batch does not update state
	        this.state.openKeys = openKeys;
	        this.setState({ openKeys: openKeys });
	      }
	      var info = (0, _objectAssign2['default'])({ openKeys: openKeys }, e);
	      if (e.open) {
	        props.onOpen(info);
	      } else {
	        props.onClose(info);
	      }
	    }
	  },

	  onDeselect: function onDeselect(selectInfo) {
	    var props = this.props;
	    if (props.selectable) {
	      var selectedKeys = this.state.selectedKeys.concat();
	      var selectedKey = selectInfo.key;
	      var index = selectedKeys.indexOf(selectedKey);
	      if (index !== -1) {
	        selectedKeys.splice(index, 1);
	      }
	      if (!('selectedKeys' in props)) {
	        this.setState({
	          selectedKeys: selectedKeys
	        });
	      }
	      props.onDeselect((0, _objectAssign2['default'])({}, selectInfo, {
	        selectedKeys: selectedKeys
	      }));
	    }
	  },

	  getOpenTransitionName: function getOpenTransitionName() {
	    var props = this.props;
	    var transitionName = props.openTransitionName;
	    var animationName = props.openAnimation;
	    if (!transitionName && typeof animationName === 'string') {
	      transitionName = props.prefixCls + '-open-' + animationName;
	    }
	    return transitionName;
	  },

	  isInlineMode: function isInlineMode() {
	    return this.props.mode === 'inline';
	  },

	  lastOpenSubMenu: function lastOpenSubMenu() {
	    var _this2 = this;

	    var lastOpen = [];
	    if (this.state.openKeys.length) {
	      lastOpen = this.getFlatInstanceArray().filter(function (c) {
	        return c && _this2.state.openKeys.indexOf(c.props.eventKey) !== -1;
	      });
	    }
	    return lastOpen[0];
	  },

	  renderMenuItem: function renderMenuItem(c, i, subIndex) {
	    var key = (0, _util.getKeyFromChildrenIndex)(c, this.props.eventKey, i);
	    var state = this.state;
	    var extraProps = {
	      openKeys: state.openKeys,
	      open: state.openKeys.indexOf(key) !== -1,
	      selectedKeys: state.selectedKeys,
	      selected: state.selectedKeys.indexOf(key) !== -1,
	      openSubMenuOnMouseEnter: this.props.openSubMenuOnMouseEnter
	    };
	    return this.renderCommonMenuItem(c, i, subIndex, extraProps);
	  },

	  render: function render() {
	    var props = (0, _objectAssign2['default'])({}, this.props);
	    props.className += ' ' + props.prefixCls + '-root';
	    return this.renderRoot(props);
	  }
	});

	exports['default'] = Menu;
	module.exports = exports['default'];

/***/ },
/* 781 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__, __webpack_module_template_argument_3__, __webpack_module_template_argument_4__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	  } else {
	    obj[key] = value;
	  }return obj;
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(4);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _rcUtil = __webpack_require__(__webpack_module_template_argument_0__);

	var _classnames = __webpack_require__(5);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _domScrollIntoView = __webpack_require__(__webpack_module_template_argument_1__);

	var _domScrollIntoView2 = _interopRequireDefault(_domScrollIntoView);

	var _objectAssign = __webpack_require__(__webpack_module_template_argument_2__);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	var _util = __webpack_require__(__webpack_module_template_argument_3__);

	var _DOMWrap = __webpack_require__(__webpack_module_template_argument_4__);

	var _DOMWrap2 = _interopRequireDefault(_DOMWrap);

	function allDisabled(arr) {
	  if (!arr.length) {
	    return true;
	  }
	  return arr.every(function (c) {
	    return !!c.props.disabled;
	  });
	}

	function getActiveKey(props, originalActiveKey) {
	  var activeKey = originalActiveKey;
	  var children = props.children;
	  var eventKey = props.eventKey;
	  if (activeKey) {
	    var found = undefined;
	    (0, _util.loopMenuItem)(children, function (c, i) {
	      if (!c.props.disabled && activeKey === (0, _util.getKeyFromChildrenIndex)(c, eventKey, i)) {
	        found = true;
	      }
	    });
	    if (found) {
	      return activeKey;
	    }
	  }
	  activeKey = null;
	  if (props.defaultActiveFirst) {
	    (0, _util.loopMenuItem)(children, function (c, i) {
	      if (!activeKey && !c.props.disabled) {
	        activeKey = (0, _util.getKeyFromChildrenIndex)(c, eventKey, i);
	      }
	    });
	    return activeKey;
	  }
	  return activeKey;
	}

	function saveRef(index, subIndex, c) {
	  if (c) {
	    if (subIndex !== undefined) {
	      this.instanceArray[index] = this.instanceArray[index] || [];
	      this.instanceArray[index][subIndex] = c;
	    } else {
	      this.instanceArray[index] = c;
	    }
	  }
	}

	var MenuMixin = {
	  propTypes: {
	    focusable: _react2['default'].PropTypes.bool,
	    multiple: _react2['default'].PropTypes.bool,
	    style: _react2['default'].PropTypes.object,
	    defaultActiveFirst: _react2['default'].PropTypes.bool,
	    visible: _react2['default'].PropTypes.bool,
	    activeKey: _react2['default'].PropTypes.string,
	    selectedKeys: _react2['default'].PropTypes.arrayOf(_react2['default'].PropTypes.string),
	    defaultSelectedKeys: _react2['default'].PropTypes.arrayOf(_react2['default'].PropTypes.string),
	    defaultOpenKeys: _react2['default'].PropTypes.arrayOf(_react2['default'].PropTypes.string),
	    openKeys: _react2['default'].PropTypes.arrayOf(_react2['default'].PropTypes.string),
	    children: _react2['default'].PropTypes.any
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      prefixCls: 'rc-menu',
	      className: '',
	      mode: 'vertical',
	      level: 1,
	      inlineIndent: 24,
	      visible: true,
	      focusable: true,
	      style: {}
	    };
	  },

	  getInitialState: function getInitialState() {
	    var props = this.props;
	    return {
	      activeKey: getActiveKey(props, props.activeKey)
	    };
	  },

	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    var props = undefined;
	    if ('activeKey' in nextProps) {
	      props = {
	        activeKey: getActiveKey(nextProps, nextProps.activeKey)
	      };
	    } else {
	      var originalActiveKey = this.state.activeKey;
	      var activeKey = getActiveKey(nextProps, originalActiveKey);
	      // fix: this.setState(), parent.render(),
	      if (activeKey !== originalActiveKey) {
	        props = {
	          activeKey: activeKey
	        };
	      }
	    }
	    if (props) {
	      this.setState(props);
	    }
	  },

	  shouldComponentUpdate: function shouldComponentUpdate(nextProps) {
	    return this.props.visible || nextProps.visible;
	  },

	  componentWillMount: function componentWillMount() {
	    this.instanceArray = [];
	  },

	  // all keyboard events callbacks run from here at first
	  onKeyDown: function onKeyDown(e) {
	    var _this = this;

	    var keyCode = e.keyCode;
	    var handled = undefined;
	    this.getFlatInstanceArray().forEach(function (obj) {
	      if (obj && obj.props.active) {
	        handled = obj.onKeyDown(e);
	      }
	    });
	    if (handled) {
	      return 1;
	    }
	    var activeItem = null;
	    if (keyCode === _rcUtil.KeyCode.UP || keyCode === _rcUtil.KeyCode.DOWN) {
	      activeItem = this.step(keyCode === _rcUtil.KeyCode.UP ? -1 : 1);
	    }
	    if (activeItem) {
	      e.preventDefault();
	      this.setState({
	        activeKey: activeItem.props.eventKey
	      }, function () {
	        (0, _domScrollIntoView2['default'])(_reactDom2['default'].findDOMNode(activeItem), _reactDom2['default'].findDOMNode(_this), {
	          onlyScrollIfNeeded: true
	        });
	      });
	      return 1;
	    } else if (activeItem === undefined) {
	      e.preventDefault();
	      this.setState({
	        activeKey: null
	      });
	      return 1;
	    }
	  },

	  onCommonItemHover: function onCommonItemHover(e) {
	    var mode = this.props.mode;
	    var key = e.key;
	    var hover = e.hover;
	    var trigger = e.trigger;

	    var activeKey = this.state.activeKey;
	    if (!trigger || hover || this.props.closeSubMenuOnMouseLeave || !e.item.isSubMenu || mode === 'inline') {
	      this.setState({
	        activeKey: hover ? key : null
	      });
	    } else {}
	    // keep active for sub menu for click active
	    // empty

	    // clear last open status
	    if (hover && mode !== 'inline') {
	      var activeItem = this.getFlatInstanceArray().filter(function (c) {
	        return c && c.props.eventKey === activeKey;
	      })[0];
	      if (activeItem && activeItem.isSubMenu && activeItem.props.eventKey !== key) {
	        this.onOpenChange({
	          item: activeItem,
	          key: activeItem.props.eventKey,
	          open: false
	        });
	      }
	    }
	  },

	  getFlatInstanceArray: function getFlatInstanceArray() {
	    var instanceArray = this.instanceArray;
	    var hasInnerArray = instanceArray.some(function (a) {
	      return Array.isArray(a);
	    });
	    if (hasInnerArray) {
	      instanceArray = [];
	      this.instanceArray.forEach(function (a) {
	        if (Array.isArray(a)) {
	          instanceArray.push.apply(instanceArray, a);
	        } else {
	          instanceArray.push(a);
	        }
	      });
	      this.instanceArray = instanceArray;
	    }
	    return instanceArray;
	  },

	  renderCommonMenuItem: function renderCommonMenuItem(child, i, subIndex, extraProps) {
	    var state = this.state;
	    var props = this.props;
	    var key = (0, _util.getKeyFromChildrenIndex)(child, props.eventKey, i);
	    var childProps = child.props;
	    var newChildProps = (0, _objectAssign2['default'])({
	      mode: props.mode,
	      level: props.level,
	      inlineIndent: props.inlineIndent,
	      renderMenuItem: this.renderMenuItem,
	      rootPrefixCls: props.prefixCls,
	      index: i,
	      parentMenu: this,
	      ref: childProps.disabled ? undefined : (0, _rcUtil.createChainedFunction)(child.ref, saveRef.bind(this, i, subIndex)),
	      eventKey: key,
	      closeSubMenuOnMouseLeave: props.closeSubMenuOnMouseLeave,
	      onItemHover: this.onItemHover,
	      active: !childProps.disabled && key === state.activeKey,
	      multiple: props.multiple,
	      onClick: this.onClick,
	      openTransitionName: this.getOpenTransitionName(),
	      openAnimation: props.openAnimation,
	      onOpenChange: this.onOpenChange,
	      onDeselect: this.onDeselect,
	      onDestroy: this.onDestroy,
	      onSelect: this.onSelect
	    }, extraProps);
	    if (props.mode === 'inline') {
	      newChildProps.closeSubMenuOnMouseLeave = newChildProps.openSubMenuOnMouseEnter = false;
	    }
	    return _react2['default'].cloneElement(child, newChildProps);
	  },

	  renderRoot: function renderRoot(props) {
	    var _classes;

	    this.instanceArray = [];
	    var classes = (_classes = {}, _defineProperty(_classes, props.prefixCls, 1), _defineProperty(_classes, props.prefixCls + '-' + props.mode, 1), _defineProperty(_classes, props.className, !!props.className), _classes);
	    var domProps = {
	      className: (0, _classnames2['default'])(classes),
	      role: 'menu',
	      'aria-activedescendant': ''
	    };
	    if (props.id) {
	      domProps.id = props.id;
	    }
	    if (props.focusable) {
	      domProps.tabIndex = '0';
	      domProps.onKeyDown = this.onKeyDown;
	    }
	    return(
	      // ESLint is not smart enough to know that the type of `children` was checked.
	      /* eslint-disable */
	      _react2['default'].createElement(_DOMWrap2['default'], _extends({ style: props.style,
	        tag: 'ul',
	        hiddenClassName: props.prefixCls + '-hidden',
	        visible: props.visible
	      }, domProps), _react2['default'].Children.map(props.children, this.renderMenuItem))
	      /*eslint-enable */

	    );
	  },

	  step: function step(direction) {
	    var children = this.getFlatInstanceArray();
	    var activeKey = this.state.activeKey;
	    var len = children.length;
	    if (direction < 0) {
	      children = children.concat().reverse();
	    }
	    // find current activeIndex
	    var activeIndex = -1;
	    children.every(function (c, ci) {
	      if (c && c.props.eventKey === activeKey) {
	        activeIndex = ci;
	        return false;
	      }
	      return true;
	    });
	    if (!this.props.defaultActiveFirst && activeIndex !== -1) {
	      if (allDisabled(children.slice(activeIndex, len - 1))) {
	        return undefined;
	      }
	    }
	    var start = (activeIndex + 1) % len;
	    var i = start;
	    for (;;) {
	      var child = children[i];
	      if (!child || child.props.disabled) {
	        i = (i + 1 + len) % len;
	        // complete a loop
	        if (i === start) {
	          return null;
	        }
	      } else {
	        return child;
	      }
	    }
	  }
	};

	exports['default'] = MenuMixin;
	module.exports = exports['default'];

/***/ },
/* 782 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	module.exports = __webpack_require__(__webpack_module_template_argument_0__);

/***/ },
/* 783 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	var util = __webpack_require__(__webpack_module_template_argument_0__);

	function scrollIntoView(elem, container, config) {
	  config = config || {};
	  // document 归一化到 window
	  if (container.nodeType === 9) {
	    container = util.getWindow(container);
	  }

	  var allowHorizontalScroll = config.allowHorizontalScroll;
	  var onlyScrollIfNeeded = config.onlyScrollIfNeeded;
	  var alignWithTop = config.alignWithTop;
	  var alignWithLeft = config.alignWithLeft;
	  var offsetTop = config.offsetTop || 0;
	  var offsetLeft = config.offsetLeft || 0;
	  var offsetBottom = config.offsetBottom || 0;
	  var offsetRight = config.offsetRight || 0;

	  allowHorizontalScroll = allowHorizontalScroll === undefined ? true : allowHorizontalScroll;

	  var isWin = util.isWindow(container);
	  var elemOffset = util.offset(elem);
	  var eh = util.outerHeight(elem);
	  var ew = util.outerWidth(elem);
	  var containerOffset = undefined;
	  var ch = undefined;
	  var cw = undefined;
	  var containerScroll = undefined;
	  var diffTop = undefined;
	  var diffBottom = undefined;
	  var win = undefined;
	  var winScroll = undefined;
	  var ww = undefined;
	  var wh = undefined;

	  if (isWin) {
	    win = container;
	    wh = util.height(win);
	    ww = util.width(win);
	    winScroll = {
	      left: util.scrollLeft(win),
	      top: util.scrollTop(win)
	    };
	    // elem 相对 container 可视视窗的距离
	    diffTop = {
	      left: elemOffset.left - winScroll.left - offsetLeft,
	      top: elemOffset.top - winScroll.top - offsetTop
	    };
	    diffBottom = {
	      left: elemOffset.left + ew - (winScroll.left + ww) + offsetRight,
	      top: elemOffset.top + eh - (winScroll.top + wh) + offsetBottom
	    };
	    containerScroll = winScroll;
	  } else {
	    containerOffset = util.offset(container);
	    ch = container.clientHeight;
	    cw = container.clientWidth;
	    containerScroll = {
	      left: container.scrollLeft,
	      top: container.scrollTop
	    };
	    // elem 相对 container 可视视窗的距离
	    // 注意边框, offset 是边框到根节点
	    diffTop = {
	      left: elemOffset.left - (containerOffset.left + (parseFloat(util.css(container, 'borderLeftWidth')) || 0)) - offsetLeft,
	      top: elemOffset.top - (containerOffset.top + (parseFloat(util.css(container, 'borderTopWidth')) || 0)) - offsetTop
	    };
	    diffBottom = {
	      left: elemOffset.left + ew - (containerOffset.left + cw + (parseFloat(util.css(container, 'borderRightWidth')) || 0)) + offsetRight,
	      top: elemOffset.top + eh - (containerOffset.top + ch + (parseFloat(util.css(container, 'borderBottomWidth')) || 0)) + offsetBottom
	    };
	  }

	  if (diffTop.top < 0 || diffBottom.top > 0) {
	    // 强制向上
	    if (alignWithTop === true) {
	      util.scrollTop(container, containerScroll.top + diffTop.top);
	    } else if (alignWithTop === false) {
	      util.scrollTop(container, containerScroll.top + diffBottom.top);
	    } else {
	      // 自动调整
	      if (diffTop.top < 0) {
	        util.scrollTop(container, containerScroll.top + diffTop.top);
	      } else {
	        util.scrollTop(container, containerScroll.top + diffBottom.top);
	      }
	    }
	  } else {
	    if (!onlyScrollIfNeeded) {
	      alignWithTop = alignWithTop === undefined ? true : !!alignWithTop;
	      if (alignWithTop) {
	        util.scrollTop(container, containerScroll.top + diffTop.top);
	      } else {
	        util.scrollTop(container, containerScroll.top + diffBottom.top);
	      }
	    }
	  }

	  if (allowHorizontalScroll) {
	    if (diffTop.left < 0 || diffBottom.left > 0) {
	      // 强制向上
	      if (alignWithLeft === true) {
	        util.scrollLeft(container, containerScroll.left + diffTop.left);
	      } else if (alignWithLeft === false) {
	        util.scrollLeft(container, containerScroll.left + diffBottom.left);
	      } else {
	        // 自动调整
	        if (diffTop.left < 0) {
	          util.scrollLeft(container, containerScroll.left + diffTop.left);
	        } else {
	          util.scrollLeft(container, containerScroll.left + diffBottom.left);
	        }
	      }
	    } else {
	      if (!onlyScrollIfNeeded) {
	        alignWithLeft = alignWithLeft === undefined ? true : !!alignWithLeft;
	        if (alignWithLeft) {
	          util.scrollLeft(container, containerScroll.left + diffTop.left);
	        } else {
	          util.scrollLeft(container, containerScroll.left + diffBottom.left);
	        }
	      }
	    }
	  }
	}

		module.exports = scrollIntoView;

/***/ },
/* 784 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _objectAssign = __webpack_require__(__webpack_module_template_argument_0__);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	var DOMWrap = _react2['default'].createClass({
	  displayName: 'DOMWrap',

	  propTypes: {
	    tag: _react2['default'].PropTypes.string
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      tag: 'div'
	    };
	  },

	  render: function render() {
	    var props = (0, _objectAssign2['default'])({}, this.props);
	    if (!props.visible) {
	      props.className = props.className || '';
	      props.className += ' ' + props.hiddenClassName;
	    }
	    var Tag = props.tag;
	    return _react2['default'].createElement(Tag, props);
	  }
	});

	exports['default'] = DOMWrap;
	module.exports = exports['default'];

/***/ },
/* 785 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__, __webpack_module_template_argument_3__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	  } else {
	    obj[key] = value;
	  }return obj;
	}

	var _SubPopupMenu = __webpack_require__(__webpack_module_template_argument_0__);

	var _SubPopupMenu2 = _interopRequireDefault(_SubPopupMenu);

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _rcUtil = __webpack_require__(__webpack_module_template_argument_1__);

	var _classnames = __webpack_require__(5);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _objectAssign = __webpack_require__(__webpack_module_template_argument_2__);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	var SubMenu = _react2['default'].createClass({
	  displayName: 'SubMenu',

	  propTypes: {
	    parentMenu: _react2['default'].PropTypes.object,
	    title: _react2['default'].PropTypes.node,
	    onClick: _react2['default'].PropTypes.func,
	    onOpenChange: _react2['default'].PropTypes.func,
	    rootPrefixCls: _react2['default'].PropTypes.string,
	    eventKey: _react2['default'].PropTypes.string,
	    multiple: _react2['default'].PropTypes.bool,
	    active: _react2['default'].PropTypes.bool,
	    open: _react2['default'].PropTypes.bool,
	    onSelect: _react2['default'].PropTypes.func,
	    closeSubMenuOnMouseLeave: _react2['default'].PropTypes.bool,
	    openSubMenuOnMouseEnter: _react2['default'].PropTypes.bool,
	    onDeselect: _react2['default'].PropTypes.func,
	    onDestroy: _react2['default'].PropTypes.func,
	    onItemHover: _react2['default'].PropTypes.func
	  },

	  mixins: [__webpack_require__(__webpack_module_template_argument_3__)],

	  getDefaultProps: function getDefaultProps() {
	    return {
	      onMouseEnter: function onMouseEnter() {},
	      title: ''
	    };
	  },

	  getInitialState: function getInitialState() {
	    this.isSubMenu = 1;
	    return {
	      defaultActiveFirst: false
	    };
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    var props = this.props;
	    if (props.onDestroy) {
	      props.onDestroy(props.eventKey);
	    }
	  },

	  onDestroy: function onDestroy(key) {
	    this.props.onDestroy(key);
	  },

	  onKeyDown: function onKeyDown(e) {
	    var keyCode = e.keyCode;
	    var menu = this.menuInstance;

	    if (keyCode === _rcUtil.KeyCode.ENTER) {
	      this.onClick(e);
	      this.setState({
	        defaultActiveFirst: true
	      });
	      return true;
	    }

	    if (keyCode === _rcUtil.KeyCode.RIGHT) {
	      if (this.props.open) {
	        menu.onKeyDown(e);
	      } else {
	        this.triggerOpenChange(true);
	        this.setState({
	          defaultActiveFirst: true
	        });
	      }
	      return true;
	    }
	    if (keyCode === _rcUtil.KeyCode.LEFT) {
	      var handled = undefined;
	      if (this.props.open) {
	        handled = menu.onKeyDown(e);
	      } else {
	        return undefined;
	      }
	      if (!handled) {
	        this.triggerOpenChange(false);
	        handled = true;
	      }
	      return handled;
	    }

	    if (this.props.open && (keyCode === _rcUtil.KeyCode.UP || keyCode === _rcUtil.KeyCode.DOWN)) {
	      return menu.onKeyDown(e);
	    }
	  },

	  onSubTreeMouseEnter: function onSubTreeMouseEnter() {
	    if (this.leaveTimer) {
	      clearTimeout(this.leaveTimer);
	      this.leaveTimer = null;
	    }
	  },

	  onOpenChange: function onOpenChange(e) {
	    this.props.onOpenChange(this.addKeyPath(e));
	  },

	  onMouseEnter: function onMouseEnter() {
	    if (this.leaveTimer) {
	      clearTimeout(this.leaveTimer);
	      this.leaveTimer = null;
	    }
	    var props = this.props;
	    var parentMenu = props.parentMenu;
	    if (parentMenu.menuItemMouseLeaveTimer) {
	      clearTimeout(parentMenu.menuItemMouseLeaveTimer);
	      parentMenu.menuItemMouseLeaveTimer = null;
	    }
	    props.onItemHover({
	      key: this.props.eventKey,
	      item: this,
	      hover: true,
	      trigger: 'mouseenter'
	    });
	    if (props.openSubMenuOnMouseEnter) {
	      this.triggerOpenChange(true);
	    }
	    this.setState({
	      defaultActiveFirst: false
	    });
	  },

	  onMouseLeave: function onMouseLeave() {
	    var _this = this;

	    // prevent popup menu and submenu gap
	    this.leaveTimer = setTimeout(function () {
	      // leave whole sub tree
	      // still active
	      if (_this.isMounted() && _this.props.active) {
	        _this.props.onItemHover({
	          key: _this.props.eventKey,
	          item: _this,
	          hover: false,
	          trigger: 'mouseleave'
	        });
	      }
	      if (_this.isMounted() && _this.props.open) {
	        if (_this.props.closeSubMenuOnMouseLeave) {
	          _this.triggerOpenChange(false);
	        }
	      }
	    }, 100);
	  },

	  onClick: function onClick() {
	    if (this.props.openSubMenuOnMouseEnter) {
	      return;
	    }
	    this.triggerOpenChange(!this.props.open, 'click');
	    this.setState({
	      defaultActiveFirst: false
	    });
	  },

	  onSubMenuClick: function onSubMenuClick(info) {
	    this.props.onClick(this.addKeyPath(info));
	  },

	  onSelect: function onSelect(info) {
	    this.props.onSelect(info);
	  },

	  onDeselect: function onDeselect(info) {
	    this.props.onDeselect(info);
	  },

	  getPrefixCls: function getPrefixCls() {
	    return this.props.rootPrefixCls + '-submenu';
	  },

	  getActiveClassName: function getActiveClassName() {
	    return this.getPrefixCls() + '-active';
	  },

	  getDisabledClassName: function getDisabledClassName() {
	    return this.getPrefixCls() + '-disabled';
	  },

	  getOpenClassName: function getOpenClassName() {
	    return this.props.rootPrefixCls + '-submenu-open';
	  },

	  saveMenuInstance: function saveMenuInstance(c) {
	    this.menuInstance = c;
	  },

	  addKeyPath: function addKeyPath(info) {
	    return (0, _objectAssign2['default'])({}, info, {
	      keyPath: (info.keyPath || []).concat(this.props.eventKey)
	    });
	  },

	  triggerOpenChange: function triggerOpenChange(open, type) {
	    var key = this.props.eventKey;
	    this.onOpenChange({
	      key: key,
	      item: this,
	      trigger: type,
	      open: open
	    });
	  },

	  renderChildren: function renderChildren(children) {
	    var props = this.props;
	    var baseProps = {
	      mode: props.mode === 'horizontal' ? 'vertical' : props.mode,
	      visible: props.open,
	      level: props.level + 1,
	      inlineIndent: props.inlineIndent,
	      focusable: false,
	      onClick: this.onSubMenuClick,
	      onSelect: this.onSelect,
	      onDeselect: this.onDeselect,
	      onDestroy: this.onDestroy,
	      selectedKeys: props.selectedKeys,
	      eventKey: props.eventKey + '-menu-',
	      openKeys: props.openKeys,
	      openTransitionName: props.openTransitionName,
	      openAnimation: props.openAnimation,
	      onOpenChange: this.onOpenChange,
	      closeSubMenuOnMouseLeave: props.closeSubMenuOnMouseLeave,
	      defaultActiveFirst: this.state.defaultActiveFirst,
	      multiple: props.multiple,
	      prefixCls: props.rootPrefixCls,
	      id: this._menuId,
	      ref: this.saveMenuInstance
	    };
	    return _react2['default'].createElement(_SubPopupMenu2['default'], baseProps, children);
	  },

	  render: function render() {
	    var _classes;

	    this.haveOpen = this.haveOpen || this.props.open;
	    var props = this.props;
	    var prefixCls = this.getPrefixCls();
	    var classes = (_classes = {}, _defineProperty(_classes, props.className, !!props.className), _defineProperty(_classes, prefixCls + '-' + props.mode, 1), _classes);

	    classes[this.getOpenClassName()] = this.props.open;
	    classes[this.getActiveClassName()] = props.active;
	    classes[this.getDisabledClassName()] = props.disabled;
	    this._menuId = this._menuId || (0, _rcUtil.guid)();
	    classes[prefixCls] = true;
	    classes[prefixCls + '-' + props.mode] = 1;
	    var clickEvents = {};
	    var mouseEvents = {};
	    var titleMouseEvents = {};
	    if (!props.disabled) {
	      clickEvents = {
	        onClick: this.onClick
	      };
	      mouseEvents = {
	        onMouseLeave: this.onMouseLeave,
	        onMouseEnter: this.onSubTreeMouseEnter
	      };
	      // only works in title, not outer li
	      titleMouseEvents = {
	        onMouseEnter: this.onMouseEnter
	      };
	    }
	    var style = {};
	    if (props.mode === 'inline') {
	      style.paddingLeft = props.inlineIndent * props.level;
	    }
	    return _react2['default'].createElement('li', _extends({ className: (0, _classnames2['default'])(classes) }, mouseEvents), _react2['default'].createElement('div', _extends({
	      style: style,
	      className: prefixCls + '-title'
	    }, titleMouseEvents, clickEvents, {
	      'aria-open': props.open,
	      'aria-owns': this._menuId,
	      'aria-haspopup': 'true'
	    }), props.title), this.renderChildren(props.children));
	  }
	});

	exports['default'] = SubMenu;
	module.exports = exports['default'];

/***/ },
/* 786 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__, __webpack_module_template_argument_3__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _MenuMixin = __webpack_require__(__webpack_module_template_argument_0__);

	var _MenuMixin2 = _interopRequireDefault(_MenuMixin);

	var _objectAssign = __webpack_require__(__webpack_module_template_argument_1__);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	var _util = __webpack_require__(__webpack_module_template_argument_2__);

	var _rcAnimate = __webpack_require__(__webpack_module_template_argument_3__);

	var _rcAnimate2 = _interopRequireDefault(_rcAnimate);

	var SubPopupMenu = _react2['default'].createClass({
	  displayName: 'SubPopupMenu',

	  propTypes: {
	    onSelect: _react2['default'].PropTypes.func,
	    onClick: _react2['default'].PropTypes.func,
	    onDeselect: _react2['default'].PropTypes.func,
	    onOpenChange: _react2['default'].PropTypes.func,
	    onDestroy: _react2['default'].PropTypes.func,
	    openTransitionName: _react2['default'].PropTypes.string,
	    openAnimation: _react2['default'].PropTypes.oneOfType([_react2['default'].PropTypes.string, _react2['default'].PropTypes.object]),
	    openKeys: _react2['default'].PropTypes.arrayOf(_react2['default'].PropTypes.string),
	    closeSubMenuOnMouseLeave: _react2['default'].PropTypes.bool,
	    visible: _react2['default'].PropTypes.bool,
	    children: _react2['default'].PropTypes.any
	  },

	  mixins: [_MenuMixin2['default']],

	  onDeselect: function onDeselect(selectInfo) {
	    this.props.onDeselect(selectInfo);
	  },

	  onSelect: function onSelect(selectInfo) {
	    this.props.onSelect(selectInfo);
	  },

	  onClick: function onClick(e) {
	    this.props.onClick(e);
	  },

	  onOpenChange: function onOpenChange(e) {
	    this.props.onOpenChange(e);
	  },

	  onDestroy: function onDestroy(key) {
	    this.props.onDestroy(key);
	  },

	  onItemHover: function onItemHover(e) {
	    this.onCommonItemHover(e);
	  },

	  getOpenTransitionName: function getOpenTransitionName() {
	    return this.props.openTransitionName;
	  },

	  renderMenuItem: function renderMenuItem(c, i, subIndex) {
	    var props = this.props;
	    var key = (0, _util.getKeyFromChildrenIndex)(c, props.eventKey, i);
	    var extraProps = {
	      openKeys: props.openKeys,
	      selectedKeys: props.selectedKeys,
	      open: props.openKeys.indexOf(key) !== -1,
	      selected: props.selectedKeys.indexOf(key) !== -1,
	      openSubMenuOnMouseEnter: true
	    };
	    return this.renderCommonMenuItem(c, i, subIndex, extraProps);
	  },

	  render: function render() {
	    var renderFirst = this.renderFirst;
	    this.renderFirst = 1;
	    this.haveOpened = this.haveOpened || this.props.visible;
	    if (!this.haveOpened) {
	      return null;
	    }
	    var transitionAppear = true;
	    if (!renderFirst && this.props.visible) {
	      transitionAppear = false;
	    }
	    var props = (0, _objectAssign2['default'])({}, this.props);
	    props.className += ' ' + props.prefixCls + '-sub';
	    var animProps = {};
	    if (props.openTransitionName) {
	      animProps.transitionName = props.openTransitionName;
	    } else if (_typeof(props.openAnimation) === 'object') {
	      animProps.animation = (0, _objectAssign2['default'])({}, props.openAnimation);
	      if (!transitionAppear) {
	        delete animProps.animation.appear;
	      }
	    }
	    return _react2['default'].createElement(_rcAnimate2['default'], _extends({}, animProps, {
	      showProp: 'visible',
	      component: '',
	      transitionAppear: transitionAppear }), this.renderRoot(props));
	  }
	});

	exports['default'] = SubPopupMenu;
	module.exports = exports['default'];

/***/ },
/* 787 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _rcUtil = __webpack_require__(__webpack_module_template_argument_0__);

	var _rcUtil2 = _interopRequireDefault(_rcUtil);

	var _reactDom = __webpack_require__(4);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	exports['default'] = {
	  componentDidMount: function componentDidMount() {
	    this.componentDidUpdate();
	  },

	  componentDidUpdate: function componentDidUpdate() {
	    if (this.props.mode !== 'inline') {
	      if (this.props.open) {
	        this.bindRootCloseHandlers();
	      } else {
	        this.unbindRootCloseHandlers();
	      }
	    }
	  },

	  handleDocumentKeyUp: function handleDocumentKeyUp(e) {
	    if (e.keyCode === _rcUtil.KeyCode.ESC) {
	      this.props.onItemHover({
	        key: this.props.eventKey,
	        item: this,
	        hover: false
	      });
	    }
	  },

	  handleDocumentClick: function handleDocumentClick(e) {
	    // If the click originated from within this component
	    // don't do anything.
	    if (_rcUtil2['default'].Dom.contains(_reactDom2['default'].findDOMNode(this), e.target)) {
	      return;
	    }
	    var props = this.props;
	    props.onItemHover({
	      hover: false,
	      item: this,
	      key: this.props.eventKey
	    });
	    this.triggerOpenChange(false);
	  },

	  bindRootCloseHandlers: function bindRootCloseHandlers() {
	    if (!this._onDocumentClickListener) {
	      this._onDocumentClickListener = _rcUtil2['default'].Dom.addEventListener(document, 'click', this.handleDocumentClick);
	      this._onDocumentKeyupListener = _rcUtil2['default'].Dom.addEventListener(document, 'keyup', this.handleDocumentKeyUp);
	    }
	  },

	  unbindRootCloseHandlers: function unbindRootCloseHandlers() {
	    if (this._onDocumentClickListener) {
	      this._onDocumentClickListener.remove();
	      this._onDocumentClickListener = null;
	    }

	    if (this._onDocumentKeyupListener) {
	      this._onDocumentKeyupListener.remove();
	      this._onDocumentKeyupListener = null;
	    }
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    this.unbindRootCloseHandlers();
	  }
	};
		module.exports = exports['default'];

/***/ },
/* 788 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _rcUtil = __webpack_require__(__webpack_module_template_argument_0__);

	var _classnames = __webpack_require__(5);

	var _classnames2 = _interopRequireDefault(_classnames);

	var MenuItem = _react2['default'].createClass({
	  displayName: 'MenuItem',

	  propTypes: {
	    rootPrefixCls: _react2['default'].PropTypes.string,
	    eventKey: _react2['default'].PropTypes.string,
	    active: _react2['default'].PropTypes.bool,
	    selected: _react2['default'].PropTypes.bool,
	    disabled: _react2['default'].PropTypes.bool,
	    title: _react2['default'].PropTypes.string,
	    onSelect: _react2['default'].PropTypes.func,
	    onClick: _react2['default'].PropTypes.func,
	    onDeselect: _react2['default'].PropTypes.func,
	    parentMenu: _react2['default'].PropTypes.object,
	    onItemHover: _react2['default'].PropTypes.func,
	    onDestroy: _react2['default'].PropTypes.func
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      onSelect: function onSelect() {},
	      onMouseEnter: function onMouseEnter() {}
	    };
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    var props = this.props;
	    if (props.onDestroy) {
	      props.onDestroy(props.eventKey);
	    }
	  },

	  onKeyDown: function onKeyDown(e) {
	    var keyCode = e.keyCode;
	    if (keyCode === _rcUtil.KeyCode.ENTER) {
	      this.onClick(e);
	      return true;
	    }
	  },

	  onMouseLeave: function onMouseLeave() {
	    var _this = this;

	    var eventKey = this.props.eventKey;
	    var parentMenu = this.props.parentMenu;
	    parentMenu.menuItemMouseLeaveTimer = setTimeout(function () {
	      if (_this.isMounted() && _this.props.active) {
	        _this.props.onItemHover({
	          key: eventKey,
	          item: _this,
	          hover: false,
	          trigger: 'mouseleave'
	        });
	      }
	    }, 30);
	  },

	  onMouseEnter: function onMouseEnter() {
	    var props = this.props;
	    var parentMenu = this.props.parentMenu;
	    if (parentMenu.menuItemMouseLeaveTimer) {
	      clearTimeout(parentMenu.menuItemMouseLeaveTimer);
	      parentMenu.menuItemMouseLeaveTimer = null;
	    }
	    var eventKey = props.eventKey;
	    props.onItemHover({
	      key: eventKey,
	      item: this,
	      hover: true,
	      trigger: 'mouseenter'
	    });
	  },

	  onClick: function onClick(e) {
	    var props = this.props;
	    var eventKey = props.eventKey;
	    var info = {
	      key: eventKey,
	      keyPath: [eventKey],
	      item: this,
	      domEvent: e
	    };
	    props.onClick(info);
	    if (props.multiple) {
	      if (props.selected) {
	        props.onDeselect(info);
	      } else {
	        props.onSelect(info);
	      }
	    } else if (!props.selected) {
	      props.onSelect(info);
	    }
	  },

	  getPrefixCls: function getPrefixCls() {
	    return this.props.rootPrefixCls + '-item';
	  },

	  getActiveClassName: function getActiveClassName() {
	    return this.getPrefixCls() + '-active';
	  },

	  getSelectedClassName: function getSelectedClassName() {
	    return this.getPrefixCls() + '-selected';
	  },

	  getDisabledClassName: function getDisabledClassName() {
	    return this.getPrefixCls() + '-disabled';
	  },

	  render: function render() {
	    var props = this.props;
	    var classes = {};
	    classes[this.getActiveClassName()] = !props.disabled && props.active;
	    classes[this.getSelectedClassName()] = props.selected;
	    classes[this.getDisabledClassName()] = props.disabled;
	    classes[this.getPrefixCls()] = true;
	    classes[props.className] = !!props.className;
	    var attrs = _extends({}, props.attribute, {
	      title: props.title,
	      className: (0, _classnames2['default'])(classes),
	      role: 'menuitem',
	      'aria-selected': props.selected,
	      'aria-disabled': props.disabled
	    });
	    var mouseEvent = {};
	    if (!props.disabled) {
	      mouseEvent = {
	        onClick: this.onClick,
	        onMouseLeave: this.onMouseLeave,
	        onMouseEnter: this.onMouseEnter
	      };
	    }
	    var style = _extends({}, props.style);
	    if (props.mode === 'inline') {
	      style.paddingLeft = props.inlineIndent * props.level;
	    }
	    return _react2['default'].createElement('li', _extends({ style: style
	    }, attrs, mouseEvent), props.children);
	  }
	});

	exports['default'] = MenuItem;
	module.exports = exports['default'];

/***/ },
/* 789 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__, __webpack_module_template_argument_3__, __webpack_module_template_argument_4__, __webpack_module_template_argument_5__, __webpack_module_template_argument_6__, __webpack_module_template_argument_7__, __webpack_module_template_argument_8__, __webpack_module_template_argument_9__, __webpack_module_template_argument_10__) {

	'use strict';

	module.exports = {
	  guid: __webpack_require__(__webpack_module_template_argument_0__),
	  classSet: __webpack_require__(__webpack_module_template_argument_1__),
	  joinClasses: __webpack_require__(__webpack_module_template_argument_2__),
	  KeyCode: __webpack_require__(__webpack_module_template_argument_3__),
	  PureRenderMixin: __webpack_require__(__webpack_module_template_argument_4__),
	  shallowEqual: __webpack_require__(__webpack_module_template_argument_5__),
	  createChainedFunction: __webpack_require__(__webpack_module_template_argument_6__),
	  Dom: {
	    addEventListener: __webpack_require__(__webpack_module_template_argument_7__),
	    contains: __webpack_require__(__webpack_module_template_argument_8__)
	  },
	  Children: {
	    toArray: __webpack_require__(__webpack_module_template_argument_9__),
	    mapSelf: __webpack_require__(__webpack_module_template_argument_10__)
	  }
		};

/***/ },
/* 790 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	/**
	 * Copyright 2013-2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	* @providesModule ReactComponentWithPureRenderMixin
	*/

	"use strict";

	var shallowEqual = __webpack_require__(__webpack_module_template_argument_0__);

	/**
	 * If your React component's render function is "pure", e.g. it will render the
	 * same result given the same props and state, provide this Mixin for a
	 * considerable performance boost.
	 *
	 * Most React components have pure render functions.
	 *
	 * Example:
	 *
	 *   var ReactComponentWithPureRenderMixin =
	 *     require('ReactComponentWithPureRenderMixin');
	 *   React.createClass({
	 *     mixins: [ReactComponentWithPureRenderMixin],
	 *
	 *     render: function() {
	 *       return <div className={this.props.className}>foo</div>;
	 *     }
	 *   });
	 *
	 * Note: This only checks shallow equality for props and state. If these contain
	 * complex data structures this mixin may have false-negatives for deeper
	 * differences. Only mixin to components which have simple props and state, or
	 * use `forceUpdate()` when you know deep data structures have changed.
	 */
	var ReactComponentWithPureRenderMixin = {
	  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
	    return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState);
	  }
	};

		module.exports = ReactComponentWithPureRenderMixin;

/***/ },
/* 791 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';

	var _Button = __webpack_require__(__webpack_module_template_argument_0__);

	var _Button2 = _interopRequireDefault(_Button);

	function _interopRequireDefault(obj) {
	                                    return obj && obj.__esModule ? obj : { "default": obj };
	}

	module.exports = _Button2["default"]; /**
	                                      * Button Component for uxcore
	                                      * @author
	                                      *
	                                      * Copyright 2014-2015, Uxcore Team, Alinw.
	                                      * All rights reserved.
	                                      */

/***/ }
/******/ ])));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXhjb3JlLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3dlYnBhY2svYm9vdHN0cmFwIDUxNjg2MmMwMzcwZWNlZGM0ZTk5Iiwid2VicGFjazovLy9saWJfX3V4Y29yZS5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1hbGVydC9idWlsZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1hbGVydC9idWlsZC9BbGVydC5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ3aW5kb3cuUmVhY3RcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ3aW5kb3cuUmVhY3RET00gfHwgd2luZG93LlJlYWN0XCIiLCJ3ZWJwYWNrOi8vLy4vfi9jbGFzc25hbWVzL2luZGV4LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWJ1dHRvbi9idWlsZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1idXR0b24vYnVpbGQvQnV0dG9uLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWJ1dHRvbi9idWlsZC9CdXR0b25Hcm91cC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9idWlsZC9DYWxlbmRhci5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9idWlsZC9SY0NhbGVuZGFyLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vZ3JlZ29yaWFuLWNhbGVuZGFyL2xpYi9jb25zdC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L2dyZWdvcmlhbi1jYWxlbmRhci9saWIvbG9jYWxlL2VuX1VTLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtdXRpbC9saWIvZ3VpZC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLXV0aWwvfi91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtdXRpbC9saWIvS2V5Q29kZS5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLXV0aWwvfi9zaGFsbG93ZXF1YWwvfi9sb2Rhc2gua2V5cy9+L2xvZGFzaC5fZ2V0bmF0aXZlL2luZGV4LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtdXRpbC9+L3NoYWxsb3dlcXVhbC9+L2xvZGFzaC5rZXlzL34vbG9kYXNoLmlzYXJndW1lbnRzL2luZGV4LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtdXRpbC9+L3NoYWxsb3dlcXVhbC9+L2xvZGFzaC5rZXlzL34vbG9kYXNoLmlzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy11dGlsL2xpYi9jcmVhdGVDaGFpbmVkRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy11dGlsL34vYWRkLWRvbS1ldmVudC1saXN0ZW5lci9saWIvRXZlbnRCYXNlT2JqZWN0LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLXV0aWwvbGliL0RvbS9jb250YWlucy5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLXV0aWwvbGliL0NoaWxkcmVuL3RvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy11dGlsL2xpYi9DaGlsZHJlbi9tYXBTZWxmLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL2J1aWxkL2RhdGUvRGF0ZVRhYmxlLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL2RhdGUvRGF0ZVRIZWFkLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL2RhdGUvRGF0ZUNvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9idWlsZC9kYXRlL0RhdGVUQm9keS5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi91dGlsL2luZGV4LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vZ3JlZ29yaWFuLWNhbGVuZGFyLWZvcm1hdC9saWIvbG9jYWxlL2VuX1VTLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vZ3JlZ29yaWFuLWNhbGVuZGFyLWZvcm1hdC9+L3dhcm5pbmcvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL34vbm9kZS1saWJzLWJyb3dzZXIvfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9saWIvY2FsZW5kYXIvQ2FsZW5kYXJIZWFkZXIuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9saWIvbW9udGgvTW9udGhQYW5lbC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi95ZWFyL1llYXJQYW5lbC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9kZWNhZGUvRGVjYWRlUGFuZWwuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9saWIvbW9udGgvTW9udGhUYWJsZS5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9jYWxlbmRhci9DYWxlbmRhckZvb3Rlci5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9jYWxlbmRhci9Ub2RheUJ1dHRvbi5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9jYWxlbmRhci9Pa0J1dHRvbi5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9taXhpbi9DYWxlbmRhck1peGluLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL21peGluL0NvbW1vbk1peGluLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL2xvY2FsZS9lbl9VUy5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9kYXRlL0RhdGVJbnB1dC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9QaWNrZXIuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9saWIvcGlja2VyL3BsYWNlbWVudHMuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9+L3JjLXRyaWdnZXIvfi9yYy1hbGlnbi9+L2RvbS1hbGlnbi9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9+L3JjLXRyaWdnZXIvfi9yYy1hbGlnbi9+L2RvbS1hbGlnbi9saWIvZ2V0QWxpZ25PZmZzZXQuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9+L3JjLXRyaWdnZXIvfi9yYy1hbGlnbi9saWIvaXNXaW5kb3cuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9+L3JjLXRyaWdnZXIvfi9yYy1hbmltYXRlL2xpYi9DaGlsZHJlblV0aWxzLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvfi9yYy10cmlnZ2VyL34vcmMtYW5pbWF0ZS9+L2Nzcy1hbmltYXRpb24vbGliL0V2ZW50LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvfi9yYy10cmlnZ2VyL34vcmMtYW5pbWF0ZS9+L2Nzcy1hbmltYXRpb24vfi9jb21wb25lbnQtY2xhc3Nlcy9+L2NvbXBvbmVudC1pbmRleG9mL2luZGV4LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvfi9yYy10cmlnZ2VyL34vcmMtYW5pbWF0ZS9saWIvdXRpbC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL34vcmMtdHJpZ2dlci9saWIvTGF6eVJlbmRlckJveC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL34vcmMtdHJpZ2dlci9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9saWIvTW9udGhDYWxlbmRhci5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9idWlsZC9ZZWFyQ2FsZW5kYXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYy10aW1lLXBpY2tlci9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYy10aW1lLXBpY2tlci9saWIvVGltZVBpY2tlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JjLXRpbWUtcGlja2VyL34vcmMtdHJpZ2dlci9saWIvVHJpZ2dlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JjLXRpbWUtcGlja2VyL34vcmMtdHJpZ2dlci9+L3JjLXV0aWwvfi91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vcmMtdGltZS1waWNrZXIvfi9yYy10cmlnZ2VyL34vcmMtdXRpbC9+L3NoYWxsb3dlcXVhbC9tb2R1bGVzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmMtdGltZS1waWNrZXIvfi9yYy10cmlnZ2VyL34vcmMtdXRpbC9+L3NoYWxsb3dlcXVhbC9+L2xvZGFzaC5rZXlzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmMtdGltZS1waWNrZXIvfi9yYy10cmlnZ2VyL34vcmMtdXRpbC9+L3NoYWxsb3dlcXVhbC9+L2xvZGFzaC5rZXlzL34vbG9kYXNoLl9nZXRuYXRpdmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYy10aW1lLXBpY2tlci9+L3JjLXRyaWdnZXIvfi9yYy11dGlsL34vc2hhbGxvd2VxdWFsL34vbG9kYXNoLmtleXMvfi9sb2Rhc2guaXNhcmd1bWVudHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYy10aW1lLXBpY2tlci9+L3JjLXRyaWdnZXIvfi9yYy11dGlsL34vc2hhbGxvd2VxdWFsL34vbG9kYXNoLmtleXMvfi9sb2Rhc2guaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JjLXRpbWUtcGlja2VyL34vcmMtdHJpZ2dlci9+L3JjLXV0aWwvbGliL0RvbS9hZGRFdmVudExpc3RlbmVyLmpzIiwid2VicGFjazovLy8uL34vcmMtdGltZS1waWNrZXIvfi9yYy10cmlnZ2VyL34vcmMtdXRpbC9+L2FkZC1kb20tZXZlbnQtbGlzdGVuZXIvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmMtdGltZS1waWNrZXIvfi9yYy10cmlnZ2VyL34vcmMtdXRpbC9+L2FkZC1kb20tZXZlbnQtbGlzdGVuZXIvbGliL0V2ZW50T2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vcmMtdGltZS1waWNrZXIvfi9yYy10cmlnZ2VyL34vcmMtdXRpbC9+L2FkZC1kb20tZXZlbnQtbGlzdGVuZXIvfi9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmMtdGltZS1waWNrZXIvfi9yYy10cmlnZ2VyL2xpYi9Qb3B1cC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JjLXRpbWUtcGlja2VyL34vcmMtdHJpZ2dlci9+L3JjLWFsaWduL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JjLXRpbWUtcGlja2VyL34vcmMtdHJpZ2dlci9+L3JjLWFsaWduL2xpYi9BbGlnbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JjLXRpbWUtcGlja2VyL34vcmMtdHJpZ2dlci9+L3JjLWFsaWduL34vZG9tLWFsaWduL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JjLXRpbWUtcGlja2VyL34vcmMtdHJpZ2dlci9+L3JjLWFsaWduL34vZG9tLWFsaWduL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JjLXRpbWUtcGlja2VyL34vcmMtdHJpZ2dlci9+L3JjLWFsaWduL34vZG9tLWFsaWduL2xpYi9nZXRPZmZzZXRQYXJlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYy10aW1lLXBpY2tlci9+L3JjLXRyaWdnZXIvfi9yYy1hbGlnbi9+L2RvbS1hbGlnbi9saWIvZ2V0VmlzaWJsZVJlY3RGb3JFbGVtZW50LmpzIiwid2VicGFjazovLy8uL34vcmMtdGltZS1waWNrZXIvfi9yYy10cmlnZ2VyL34vcmMtYWxpZ24vfi9kb20tYWxpZ24vbGliL2FkanVzdEZvclZpZXdwb3J0LmpzIiwid2VicGFjazovLy8uL34vcmMtdGltZS1waWNrZXIvfi9yYy10cmlnZ2VyL34vcmMtYWxpZ24vfi9kb20tYWxpZ24vbGliL2dldFJlZ2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JjLXRpbWUtcGlja2VyL34vcmMtdHJpZ2dlci9+L3JjLWFsaWduL34vZG9tLWFsaWduL2xpYi9nZXRFbEZ1dHVyZVBvcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JjLXRpbWUtcGlja2VyL34vcmMtdHJpZ2dlci9+L3JjLWFuaW1hdGUvbGliL0FuaW1hdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYy10aW1lLXBpY2tlci9+L3JjLXRyaWdnZXIvfi9yYy1hbmltYXRlL2xpYi9DaGlsZHJlblV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmMtdGltZS1waWNrZXIvfi9yYy10cmlnZ2VyL34vcmMtYW5pbWF0ZS9saWIvQW5pbWF0ZUNoaWxkLmpzIiwid2VicGFjazovLy8uL34vcmMtdGltZS1waWNrZXIvfi9yYy10cmlnZ2VyL34vcmMtYW5pbWF0ZS9+L2Nzcy1hbmltYXRpb24vbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmMtdGltZS1waWNrZXIvfi9yYy10cmlnZ2VyL34vcmMtYW5pbWF0ZS9+L2Nzcy1hbmltYXRpb24vbGliL0V2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmMtdGltZS1waWNrZXIvfi9yYy10cmlnZ2VyL34vcmMtYW5pbWF0ZS9+L2Nzcy1hbmltYXRpb24vfi9jb21wb25lbnQtY2xhc3Nlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JjLXRpbWUtcGlja2VyL34vcmMtdHJpZ2dlci9+L3JjLWFuaW1hdGUvfi9jc3MtYW5pbWF0aW9uL34vY29tcG9uZW50LWNsYXNzZXMvfi9jb21wb25lbnQtaW5kZXhvZi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JjLXRpbWUtcGlja2VyL34vcmMtdHJpZ2dlci9saWIvUG9wdXBJbm5lci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JjLXRpbWUtcGlja2VyL34vcmMtdHJpZ2dlci9saWIvTGF6eVJlbmRlckJveC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JjLXRpbWUtcGlja2VyL34vcmMtdHJpZ2dlci9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYy10aW1lLXBpY2tlci9saWIvbW9kdWxlL1BhbmVsLmpzIiwid2VicGFjazovLy8uL34vcmMtdGltZS1waWNrZXIvbGliL21peGluL0NvbW1vbk1peGluLmpzIiwid2VicGFjazovLy8uL34vcmMtdGltZS1waWNrZXIvbGliL2xvY2FsZS9lbl9VUy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JjLXRpbWUtcGlja2VyL2xpYi9tb2R1bGUvSGVhZGVyLmpzIiwid2VicGFjazovLy8uL34vcmMtdGltZS1waWNrZXIvbGliL3V0aWwvc2VsZWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmMtdGltZS1waWNrZXIvbGliL21vZHVsZS9Db21ib2JveC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JjLXRpbWUtcGlja2VyL2xpYi9tb2R1bGUvU2VsZWN0LmpzIiwid2VicGFjazovLy8uL34vcmMtdGltZS1waWNrZXIvbGliL3V0aWwvcGxhY2VtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JjLXRpbWUtcGlja2VyL2xpYi91dGlsL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmMtdGltZS1waWNrZXIvfi9ncmVnb3JpYW4tY2FsZW5kYXItZm9ybWF0L34vd2FybmluZy9icm93c2VyLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL2J1aWxkL3V0aWwuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtZm9ybWF0dGVyL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtYXR0ZXIvc3JjL0Zvcm1hdHRlci5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS10b29sdGlwL2J1aWxkL2luZGV4LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXRvb2x0aXAvYnVpbGQvVG9vbHRpcC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS10b29sdGlwL34vcmMtdG9vbHRpcC9saWIvcGxhY2VtZW50cy5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9idWlsZC9sb2NhbGUuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9ncmVnb3JpYW4tY2FsZW5kYXIvbGliL2xvY2FsZS96aF9DTi5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9sb2NhbGUvemhfQ04uanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9ncmVnb3JpYW4tY2FsZW5kYXItZm9ybWF0L2xpYi9sb2NhbGUvemhfQ04uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYy10aW1lLXBpY2tlci9saWIvbG9jYWxlL3poX0NOLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNoZWNrYm94LWdyb3VwL2J1aWxkL2luZGV4LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNoZWNrYm94LWdyb3VwL2J1aWxkL0NoZWNrYm94R3JvdXAuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtY2hlY2tib3gtZ3JvdXAvYnVpbGQvQ2hlY2tib3hJdGVtLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNvbGxhcHNlL2J1aWxkL2luZGV4LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNvbGxhcHNlL2J1aWxkL0NvbGxhcHNlLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNvbGxhcHNlL2J1aWxkL1BhbmVsLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNvbnN0L3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1jb25zdC9zcmMvQ29uc3QuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtY3J1bWIvYnVpbGQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtY3J1bWIvYnVpbGQvQ3J1bWIuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtY3J1bWIvYnVpbGQvQ3J1bWJJdGVtLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWRpYWxvZy9idWlsZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1kaWFsb2cvYnVpbGQvRGlhbG9nLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWRpYWxvZy9+L3JjLWRpYWxvZy9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtZGlhbG9nL34vcmMtZGlhbG9nL2xpYi9EaWFsb2dXcmFwLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWRpYWxvZy9+L3JjLWRpYWxvZy9saWIvRGlhbG9nLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWRpYWxvZy9+L3JjLWRpYWxvZy9saWIvRE9NV3JhcC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1kaWFsb2cvYnVpbGQvY29uZmlybS5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1kaWFsb2cvYnVpbGQvaTE4bi5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1kcm9wZG93bi9idWlsZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1kcm9wZG93bi9idWlsZC9Ecm9wZG93bi5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1kcm9wZG93bi9+L3JjLWRyb3Bkb3duL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1kcm9wZG93bi9+L3JjLWRyb3Bkb3duL2xpYi9Ecm9wZG93bi5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1kcm9wZG93bi9+L3JjLWRyb3Bkb3duL2xpYi9wbGFjZW1lbnRzLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vYnVpbGQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9idWlsZC9Gb3JtLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vYnVpbGQvRm9ybVJvdy5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL2J1aWxkL0Zvcm1Sb3dUaXRsZS5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL2J1aWxkL0Zvcm1GaWVsZC9Gb3JtRmllbGQuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9+L2RlZXAtZXF1YWwvbGliL2tleXMuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9+L2RlZXAtZXF1YWwvbGliL2lzX2FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL2J1aWxkL1ZhbGlkYXRvcnMuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtdmFsaWRhdG9yL2J1aWxkL2luZGV4LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXZhbGlkYXRvci9idWlsZC9WYWxpZGF0b3IuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9idWlsZC9LZXlDb2RlLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vfi9kZWVwY29weS9kZWVwY29weS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL34vbm9kZS1saWJzLWJyb3dzZXIvfi9idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9+L25vZGUtbGlicy1icm93c2VyL34vYnVmZmVyL34vYmFzZTY0LWpzL2xpYi9iNjQuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9+L25vZGUtbGlicy1icm93c2VyL34vYnVmZmVyL34vaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL34vbm9kZS1saWJzLWJyb3dzZXIvfi9idWZmZXIvfi9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8od2VicGFjaykvfi9ub2RlLWxpYnMtYnJvd3Nlci9+L3V0aWwvdXRpbC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL34vbm9kZS1saWJzLWJyb3dzZXIvfi91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwid2VicGFjazovLy8od2VicGFjaykvfi9ub2RlLWxpYnMtYnJvd3Nlci9+L3V0aWwvfi9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vYnVpbGQvRm9ybUZpZWxkL1RleHRBcmVhRm9ybUZpZWxkLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vYnVpbGQvRm9ybUZpZWxkL0lucHV0Rm9ybUZpZWxkLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vYnVpbGQvRm9ybUZpZWxkL1JhZGlvR3JvdXBGb3JtRmllbGQuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtcmFkaW9ncm91cC9idWlsZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1yYWRpb2dyb3VwL2J1aWxkL1JhZGlvZ3JvdXAuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtcmFkaW9ncm91cC9idWlsZC9SYWRpb2dyb3VwSXRlbS5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL2J1aWxkL0Zvcm1GaWVsZC9TZWxlY3RGb3JtRmllbGQuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtc2VsZWN0Mi9idWlsZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1zZWxlY3QyL2J1aWxkL1NlbGVjdDIuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtc2VsZWN0Mi9+L3JjLXNlbGVjdC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtc2VsZWN0Mi9+L3JjLXNlbGVjdC9saWIvU2VsZWN0LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3QvbGliL09wdEdyb3VwLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3QvbGliL3V0aWwuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtc2VsZWN0Mi9+L3JjLXNlbGVjdC9+L2RvbS1zY3JvbGwtaW50by12aWV3L2xpYi91dGlsLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3Qvfi9yYy1tZW51L2xpYi91dGlsLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3Qvfi9yYy1tZW51L2xpYi9NZW51SXRlbUdyb3VwLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3Qvfi9yYy1tZW51L2xpYi9EaXZpZGVyLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3QvbGliL1NlbGVjdFRyaWdnZXIuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtc2VsZWN0Mi9+L3JjLXNlbGVjdC9saWIvRHJvcGRvd25NZW51LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3QvbGliL09wdGlvbi5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL2J1aWxkL0Zvcm1GaWVsZC9OdW1iZXJJbnB1dEZvcm1GaWVsZC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL2J1aWxkL0Zvcm1GaWVsZC9EYXRlRm9ybUZpZWxkLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vfi91eGNvcmUtY2FsZW5kYXIvYnVpbGQvQ2FsZW5kYXIuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL0NhbGVuZGFyLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vfi91eGNvcmUtY2FsZW5kYXIvfi9ncmVnb3JpYW4tY2FsZW5kYXItZm9ybWF0L2luZGV4LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vfi91eGNvcmUtY2FsZW5kYXIvfi9ncmVnb3JpYW4tY2FsZW5kYXItZm9ybWF0L2xpYi9ncmVnb3JpYW4tY2FsZW5kYXItZm9ybWF0LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vfi91eGNvcmUtY2FsZW5kYXIvfi9ncmVnb3JpYW4tY2FsZW5kYXIvbGliL2dyZWdvcmlhbi1jYWxlbmRhci5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL34vZ3JlZ29yaWFuLWNhbGVuZGFyLWZvcm1hdC9saWIvbG9jYWxlL2VuLXVzLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vfi91eGNvcmUtY2FsZW5kYXIvfi9yYy11dGlsL2xpYi9ndWlkLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vfi91eGNvcmUtY2FsZW5kYXIvfi9yYy11dGlsL2xpYi9jbGFzc1NldC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtdXRpbC9saWIvam9pbkNsYXNzZXMuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLXV0aWwvbGliL0tleUNvZGUuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLXV0aWwvbGliL3NoYWxsb3dFcXVhbC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtdXRpbC9saWIvY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vfi91eGNvcmUtY2FsZW5kYXIvfi9yYy11dGlsL2xpYi9Eb20vYWRkRXZlbnRMaXN0ZW5lci5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtdXRpbC9saWIvRG9tL2NvbnRhaW5zLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vfi91eGNvcmUtY2FsZW5kYXIvfi9yYy11dGlsL2xpYi9DaGlsZHJlbi90b0FycmF5LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vfi91eGNvcmUtY2FsZW5kYXIvfi9yYy11dGlsL2xpYi9DaGlsZHJlbi9tYXBTZWxmLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vfi91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9saWIvZGF0ZS9EYXRlVGFibGUuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9kYXRlL0RhdGVUSGVhZC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL2RhdGUvRGF0ZUNvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL2RhdGUvRGF0ZVRCb2R5LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vfi91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9saWIvY2FsZW5kYXIvQ2FsZW5kYXJIZWFkZXIuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9tb250aC9Nb250aFBhbmVsLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vfi91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9saWIveWVhci9ZZWFyUGFuZWwuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9kZWNhZGUvRGVjYWRlUGFuZWwuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9jYWxlbmRhci9DYWxlbmRhckZvb3Rlci5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL3RpbWUvVGltZS5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL3RpbWUvVGltZVBhbmVsLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vfi91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9saWIvbWl4aW4vQ2FsZW5kYXJNaXhpbi5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL2xvY2FsZS9lbi11cy5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL1BpY2tlci5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtYWxpZ24vbGliL2luZGV4LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vfi91eGNvcmUtY2FsZW5kYXIvfi9yYy1hbGlnbi9saWIvQWxpZ24uanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL34vcmMtYW5pbWF0ZS9saWIvQW5pbWF0ZS5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvfi9yYy1hbmltYXRlL2xpYi9DaGlsZHJlblV0aWxzLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vfi91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9+L3JjLWFuaW1hdGUvbGliL0FuaW1hdGVDaGlsZC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL01vbnRoQ2FsZW5kYXIuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9+L3V4Y29yZS1jYWxlbmRhci9idWlsZC9QaWNrZXIuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9+L3V4Y29yZS1jYWxlbmRhci9idWlsZC9ZZWFyQ2FsZW5kYXIuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9sb2NhbGUvemgtY24uanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9+L3V4Y29yZS1jYWxlbmRhci9+L2dyZWdvcmlhbi1jYWxlbmRhci1mb3JtYXQvbGliL2xvY2FsZS96aC1jbi5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL2J1aWxkL0Zvcm1GaWVsZC9DaGVja2JveEdyb3VwRm9ybUZpZWxkLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vYnVpbGQvRm9ybUZpZWxkL0Nhc2NhZGVTZWxlY3RGb3JtRmllbGQuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9idWlsZC9Gb3JtRmllbGQvT3RoZXJGb3JtRmllbGQuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9idWlsZC9Gb3JtRmllbGQvQnV0dG9uR3JvdXBGb3JtRmllbGQuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9idWlsZC9Gb3JtRmllbGQvRWRpdG9yRm9ybUZpZWxkLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXRpbnltY2UvYnVpbGQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtdGlueW1jZS9idWlsZC9UaW55bWNlLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXRpbnltY2UvYnVpbGQvdXRpbC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS10aW55bWNlL2J1aWxkL2VkaXRvckNvbmZpZy5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL2J1aWxkL0Zvcm1GaWVsZC9TZWFyY2hGb3JtRmllbGQuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtZ3JpZC9idWlsZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1ncmlkL2J1aWxkL0dyaWQuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtZ3JpZC9+L3JlYWN0LXByb3AtdHlwZXMvbGliL2VsZW1lbnRUeXBlLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWdyaWQvfi9yZWFjdC1wcm9wLXR5cGVzL2xpYi9jb21tb24uanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtZ3JpZC9idWlsZC9Sb3cuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtZ3JpZC9idWlsZC9Db2wuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtZ3JpZC9idWlsZC9TdHlsZU1hcHMuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtbGF5b3V0L2J1aWxkL2luZGV4LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWxheW91dC9idWlsZC9MYXlvdXQuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtbGF5b3V0L2J1aWxkL0xlZnQuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtbGF5b3V0L2J1aWxkL0xheW91dEl0ZW0uanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtbGF5b3V0L2J1aWxkL1JpZ2h0LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLW1lbnRpb24vYnVpbGQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtbWVudGlvbi9idWlsZC9NZW50aW9uLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLW1lbnRpb24vYnVpbGQvcGFuZWwuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtbWVudGlvbi9idWlsZC9lZGl0b3IuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtbWVudGlvbi9idWlsZC9yYW5neS1wb3NpdGlvbi5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1tZW50aW9uL2J1aWxkL3V0aWwuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtbWVudGlvbi9idWlsZC9rZXljb2RlLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLW1lbnUvYnVpbGQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtbWVudS9idWlsZC9NZW51LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLW11bHRpLXNlbGVjdC9idWlsZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1tdWx0aS1zZWxlY3QvYnVpbGQvTXVsdGlTZWxlY3QuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtbXVsdGktc2VsZWN0L34vdXhjb3JlLWJ1dHRvbi9idWlsZC9CdXR0b24uanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtcGFnaW5hdGlvbi9idWlsZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1wYWdpbmF0aW9uL2J1aWxkL1BhZ2luYXRpb24uanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtcGFnaW5hdGlvbi9idWlsZC9QYWdlci5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1wYWdpbmF0aW9uL2J1aWxkL09wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtcGFnaW5hdGlvbi9idWlsZC9LZXlDb2RlLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXBhZ2luYXRpb24vYnVpbGQvbG9jYWxlLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXBvcG92ZXIvYnVpbGQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtcG9wb3Zlci9idWlsZC9Qb3BvdmVyLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXByb2dyZXNzL2J1aWxkL2luZGV4LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXByb2dyZXNzL2J1aWxkL1Byb2dyZXNzLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXByb2dyZXNzL2J1aWxkL0NpcmNsZS5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1zdGVwcy9idWlsZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1zdGVwcy9idWlsZC9TdGVwcy5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1zdGVwcy9idWlsZC9TdGVwLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXRhYmxlL2J1aWxkL2luZGV4LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXRhYmxlL2J1aWxkL1RhYmxlLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXRhYmxlL2J1aWxkL0hlYWRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS10YWJsZS9idWlsZC9DZWxsL0NoZWNrQm94LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXRyZWUvYnVpbGQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtdHJlZS9idWlsZC9UcmVlLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXRyZWUvfi9yYy10cmVlL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS10cmVlL34vcmMtdHJlZS9saWIvVHJlZS5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS10cmVlL34vcmMtdHJlZS9saWIvdXRpbC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS10cmVlL34vcmMtdHJlZS9saWIvVHJlZU5vZGUuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtdGFibGUvYnVpbGQvVGJvZHkuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtdGFibGUvYnVpbGQvUm93LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXRhYmxlL2J1aWxkL0NlbGwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtdGFibGUvYnVpbGQvQ2VsbC9SYWRpby5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS10YWJsZS9idWlsZC9DZWxsL1RleHRGaWVsZC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS10YWJsZS9idWlsZC9DZWxsL0NlbGxGaWVsZC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS10YWJsZS9idWlsZC9DZWxsL1NlbGVjdEZpZWxkLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXRhYmxlL2J1aWxkL0NlbGwvUmFkaW9GaWVsZC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS10YWJsZS9idWlsZC9DZWxsL1V0aWwuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtdGFibGUvYnVpbGQvTWFzay5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS10YWJsZS9idWlsZC91dGlsLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXRhYmxlL2J1aWxkL0FjdGlvbkJhci5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS10YWJsZS9idWlsZC9TZWFyY2hCYXIuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtdGFicy9idWlsZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS10YWJzL2J1aWxkL1RhYnMuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtdGFicy9+L3JjLXRhYnMvbGliL2luZGV4LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXRhYnMvfi9yYy10YWJzL2xpYi9UYWJzLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXRhYnMvfi9yYy10YWJzL2xpYi9LZXlDb2RlLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXRhYnMvfi9yYy10YWJzL2xpYi9UYWJQYW5lLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXRhYnMvfi9yYy10YWJzL2xpYi9OYXYuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtdGFicy9+L3JjLXRhYnMvbGliL0lua0Jhck1peGluLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXRhYnMvfi9yYy10YWJzL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS10b3RvcC9idWlsZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS10b3RvcC9idWlsZC9Ub3RvcC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS10cmFuc2Zlci9idWlsZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS10cmFuc2Zlci9idWlsZC9UcmFuc2Zlci5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS11cGxvYWRlci9idWlsZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS11cGxvYWRlci9idWlsZC9VcGxvYWRlci5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS11cGxvYWRlci9+L3VwbG9hZGNvcmUvZGlzdC91cGxvYWRjb3JlLm1pbi5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXVwbG9hZGVyL2J1aWxkL1Byb2dyZXNzLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXVwbG9hZGVyL2J1aWxkL3V0aWwuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtdXBsb2FkZXIvYnVpbGQvRmlsZUxpc3QuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtdXBsb2FkZXIvYnVpbGQvRmlsZUl0ZW0uanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtdXBsb2FkZXIvYnVpbGQvUHJldmlldy5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS11cGxvYWRlci9idWlsZC9sb2NhbGUuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtdXBsb2FkZXIvYnVpbGQvUGlja2VyLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLW1lc3NhZ2UvYnVpbGQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtbWVzc2FnZS9idWlsZC9NZXNzYWdlLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLW1lc3NhZ2Uvfi9yYy1ub3RpZmljYXRpb24vbGliL2luZGV4LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLW1lc3NhZ2Uvfi9yYy1ub3RpZmljYXRpb24vbGliL05vdGlmaWNhdGlvbi5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1tZXNzYWdlL34vcmMtbm90aWZpY2F0aW9uL34vcmMtdXRpbC9saWIvY2xhc3NTZXQuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtbWVzc2FnZS9+L3JjLW5vdGlmaWNhdGlvbi9+L3JjLXV0aWwvbGliL0RvbS9hZGRFdmVudExpc3RlbmVyLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLW1lc3NhZ2Uvfi9yYy1ub3RpZmljYXRpb24vbGliL05vdGljZS5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1waWNrYWJsZS9idWlsZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1waWNrYWJsZS9idWlsZC9QaWNrYWJsZS5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL0BhbGkvdXhjb3JlLXByaW1hcnktbmF2L2J1aWxkL2luZGV4LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvQGFsaS91eGNvcmUtcHJpbWFyeS1uYXYvYnVpbGQvUHJpbWFyeU5hdi5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9idWlsZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L2dyZWdvcmlhbi1jYWxlbmRhci9saWIvZ3JlZ29yaWFuLWNhbGVuZGFyLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vZ3JlZ29yaWFuLWNhbGVuZGFyL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLXV0aWwvbGliL2luZGV4LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtdXRpbC9saWIvY2xhc3NTZXQuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy11dGlsL2xpYi9qb2luQ2xhc3Nlcy5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLXV0aWwvbGliL1B1cmVSZW5kZXJNaXhpbi5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLXV0aWwvfi9zaGFsbG93ZXF1YWwvbW9kdWxlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLXV0aWwvfi9zaGFsbG93ZXF1YWwvfi9sb2Rhc2gua2V5cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLXV0aWwvbGliL0RvbS9hZGRFdmVudExpc3RlbmVyLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtdXRpbC9+L2FkZC1kb20tZXZlbnQtbGlzdGVuZXIvbGliL2luZGV4LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtdXRpbC9+L2FkZC1kb20tZXZlbnQtbGlzdGVuZXIvbGliL0V2ZW50T2JqZWN0LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vZ3JlZ29yaWFuLWNhbGVuZGFyLWZvcm1hdC9saWIvZ3JlZ29yaWFuLWNhbGVuZGFyLWZvcm1hdC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL34vcmMtdHJpZ2dlci9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9+L3JjLXRyaWdnZXIvbGliL1RyaWdnZXIuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9+L3JjLXRyaWdnZXIvbGliL1BvcHVwLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvfi9yYy10cmlnZ2VyL34vcmMtYWxpZ24vbGliL2luZGV4LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvfi9yYy10cmlnZ2VyL34vcmMtYWxpZ24vbGliL0FsaWduLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvfi9yYy10cmlnZ2VyL34vcmMtYWxpZ24vfi9kb20tYWxpZ24vbGliL2luZGV4LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvfi9yYy10cmlnZ2VyL34vcmMtYWxpZ24vfi9kb20tYWxpZ24vbGliL2dldE9mZnNldFBhcmVudC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL34vcmMtdHJpZ2dlci9+L3JjLWFsaWduL34vZG9tLWFsaWduL2xpYi9nZXRWaXNpYmxlUmVjdEZvckVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9+L3JjLXRyaWdnZXIvfi9yYy1hbGlnbi9+L2RvbS1hbGlnbi9saWIvYWRqdXN0Rm9yVmlld3BvcnQuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9+L3JjLXRyaWdnZXIvfi9yYy1hbGlnbi9+L2RvbS1hbGlnbi9saWIvZ2V0UmVnaW9uLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvfi9yYy10cmlnZ2VyL34vcmMtYWxpZ24vfi9kb20tYWxpZ24vbGliL2dldEVsRnV0dXJlUG9zLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvfi9yYy10cmlnZ2VyL34vcmMtYW5pbWF0ZS9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9+L3JjLXRyaWdnZXIvfi9yYy1hbmltYXRlL2xpYi9BbmltYXRlLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvfi9yYy10cmlnZ2VyL34vcmMtYW5pbWF0ZS9saWIvQW5pbWF0ZUNoaWxkLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvfi9yYy10cmlnZ2VyL34vcmMtYW5pbWF0ZS9+L2Nzcy1hbmltYXRpb24vbGliL2luZGV4LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvfi9yYy10cmlnZ2VyL34vcmMtYW5pbWF0ZS9+L2Nzcy1hbmltYXRpb24vfi9jb21wb25lbnQtY2xhc3Nlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL34vcmMtdHJpZ2dlci9saWIvUG9wdXBJbm5lci5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS10b29sdGlwL34vcmMtdG9vbHRpcC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtdG9vbHRpcC9+L3JjLXRvb2x0aXAvbGliL1Rvb2x0aXAuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9+L2RlZXAtZXF1YWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtc2VsZWN0Mi9+L3JjLXNlbGVjdC9+L3JjLW1lbnUvbGliL2luZGV4LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3Qvfi9yYy1tZW51L2xpYi9NZW51LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3Qvfi9yYy1tZW51L2xpYi9NZW51TWl4aW4uanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtc2VsZWN0Mi9+L3JjLXNlbGVjdC9+L2RvbS1zY3JvbGwtaW50by12aWV3L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1zZWxlY3QyL34vcmMtc2VsZWN0L34vZG9tLXNjcm9sbC1pbnRvLXZpZXcvbGliL2RvbS1zY3JvbGwtaW50by12aWV3LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3Qvfi9yYy1tZW51L2xpYi9ET01XcmFwLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3Qvfi9yYy1tZW51L2xpYi9TdWJNZW51LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3Qvfi9yYy1tZW51L2xpYi9TdWJQb3B1cE1lbnUuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy91eGNvcmUtc2VsZWN0Mi9+L3JjLXNlbGVjdC9+L3JjLW1lbnUvbGliL1N1Yk1lbnVTdGF0ZU1peGluLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3Qvfi9yYy1tZW51L2xpYi9NZW51SXRlbS5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtdXRpbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtdXRpbC9saWIvUHVyZVJlbmRlck1peGluLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXhjb3JlLW11bHRpLXNlbGVjdC9+L3V4Y29yZS1idXR0b24vYnVpbGQvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB3ZWJwYWNrL2Jvb3RzdHJhcCA1MTY4NjJjMDM3MGVjZWRjNGU5OVxuICoqLyIsIndpbmRvd1tcIlV4Y29yZVwiXT17XG5cIkFsZXJ0XCI6cmVxdWlyZShcInV4Y29yZS1hbGVydFwiKSxcblwiQnV0dG9uXCI6cmVxdWlyZShcInV4Y29yZS1idXR0b25cIiksXG5cIkNhbGVuZGFyXCI6cmVxdWlyZShcInV4Y29yZS1jYWxlbmRhclwiKSxcblwiQ2hlY2tib3hHcm91cFwiOnJlcXVpcmUoXCJ1eGNvcmUtY2hlY2tib3gtZ3JvdXBcIiksXG5cIkNvbGxhcHNlXCI6cmVxdWlyZShcInV4Y29yZS1jb2xsYXBzZVwiKSxcblwiQ29uc3RcIjpyZXF1aXJlKFwidXhjb3JlLWNvbnN0XCIpLFxuXCJDcnVtYlwiOnJlcXVpcmUoXCJ1eGNvcmUtY3J1bWJcIiksXG5cIkRpYWxvZ1wiOnJlcXVpcmUoXCJ1eGNvcmUtZGlhbG9nXCIpLFxuXCJEcm9wZG93blwiOnJlcXVpcmUoXCJ1eGNvcmUtZHJvcGRvd25cIiksXG5cIkZvcm1cIjpyZXF1aXJlKFwidXhjb3JlLWZvcm1cIiksXG5cIkZvcm1hdHRlclwiOnJlcXVpcmUoXCJ1eGNvcmUtZm9ybWF0dGVyXCIpLFxuXCJHcmlkXCI6cmVxdWlyZShcInV4Y29yZS1ncmlkXCIpLFxuXCJMYXlvdXRcIjpyZXF1aXJlKFwidXhjb3JlLWxheW91dFwiKSxcblwiTWVudGlvblwiOnJlcXVpcmUoXCJ1eGNvcmUtbWVudGlvblwiKSxcblwiTWVudVwiOnJlcXVpcmUoXCJ1eGNvcmUtbWVudVwiKSxcblwiTXVsdGlTZWxlY3RcIjpyZXF1aXJlKFwidXhjb3JlLW11bHRpLXNlbGVjdFwiKSxcblwiUGFnaW5hdGlvblwiOnJlcXVpcmUoXCJ1eGNvcmUtcGFnaW5hdGlvblwiKSxcblwiUG9wb3ZlclwiOnJlcXVpcmUoXCJ1eGNvcmUtcG9wb3ZlclwiKSxcblwiUHJvZ3Jlc3NcIjpyZXF1aXJlKFwidXhjb3JlLXByb2dyZXNzXCIpLFxuXCJSYWRpb2dyb3VwXCI6cmVxdWlyZShcInV4Y29yZS1yYWRpb2dyb3VwXCIpLFxuXCJTZWxlY3QyXCI6cmVxdWlyZShcInV4Y29yZS1zZWxlY3QyXCIpLFxuXCJTdGVwc1wiOnJlcXVpcmUoXCJ1eGNvcmUtc3RlcHNcIiksXG5cIlRhYmxlXCI6cmVxdWlyZShcInV4Y29yZS10YWJsZVwiKSxcblwiVGFic1wiOnJlcXVpcmUoXCJ1eGNvcmUtdGFic1wiKSxcblwiVGlueW1jZVwiOnJlcXVpcmUoXCJ1eGNvcmUtdGlueW1jZVwiKSxcblwiVG9vbHRpcFwiOnJlcXVpcmUoXCJ1eGNvcmUtdG9vbHRpcFwiKSxcblwiVG90b3BcIjpyZXF1aXJlKFwidXhjb3JlLXRvdG9wXCIpLFxuXCJUcmFuc2ZlclwiOnJlcXVpcmUoXCJ1eGNvcmUtdHJhbnNmZXJcIiksXG5cIlRyZWVcIjpyZXF1aXJlKFwidXhjb3JlLXRyZWVcIiksXG5cIlVwbG9hZGVyXCI6cmVxdWlyZShcInV4Y29yZS11cGxvYWRlclwiKSxcblwiVmFsaWRhdG9yXCI6cmVxdWlyZShcInV4Y29yZS12YWxpZGF0b3JcIiksXG5cIk1lc3NhZ2VcIjpyZXF1aXJlKFwidXhjb3JlLW1lc3NhZ2VcIiksXG5cIlBpY2thYmxlXCI6cmVxdWlyZShcInV4Y29yZS1waWNrYWJsZVwiKSxcblwiUHJpbWFyeU5hdlwiOnJlcXVpcmUoXCJAYWxpL3V4Y29yZS1wcmltYXJ5LW5hdlwiKSxcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbGliX191eGNvcmUuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQWxlcnQgQ29tcG9uZW50IGZvciB1eGNvcmVcbiAqIEBhdXRob3IgZXRlcm5hc2xreVxuICpcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIFV4Y29yZSBUZWFtLCBBbGludy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL0FsZXJ0Jyk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1hbGVydC9idWlsZC9pbmRleC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIEFsZXJ0IENvbXBvbmVudCBmb3IgdXhjb3JlXG4gKiBAYXV0aG9yIGV0ZXJuYXNsa3lcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBVeGNvcmUgVGVhbSwgQWxpbncuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcbnZhciBjbGFzc25hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xuXG52YXIgQWxlcnQgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhBbGVydCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBBbGVydChwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWxlcnQpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgY2xvc2VkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgQWxlcnQucHJvdG90eXBlLnRvZ2dsZVNob3cgPSBmdW5jdGlvbiB0b2dnbGVTaG93KCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGNsb3NlZDogIXRoaXMuc3RhdGUuY2xvc2VkXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBBbGVydC5wcm90b3R5cGUuaGFuZGxlQ2xvc2UgPSBmdW5jdGlvbiBoYW5kbGVDbG9zZShlKSB7XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBjbG9zZWQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHJvcHMub25DbG9zZS5jYWxsKHRoaXMsIGUpO1xuICAgIH07XG5cbiAgICBBbGVydC5wcm90b3R5cGUucmVuZGVyQ29udGVudCA9IGZ1bmN0aW9uIHJlbmRlckNvbnRlbnQoKSB7XG4gICAgICAgIHZhciBfY2xhc3NuYW1lcztcblxuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgaWNvbk1hcCA9IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdpbmZvcm1hdGlvbicsXG4gICAgICAgICAgICBlcnJvcjogJ2Vycm9yJyxcbiAgICAgICAgICAgIHdhcm5pbmc6ICdjYXV0aW9uJyxcbiAgICAgICAgICAgIHN1Y2Nlc3M6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgIHF1ZXN0aW9uOiAncXVlcnknLFxuICAgICAgICAgICAgc3RvcDogJ3Byb2hpYml0aW9uJyxcbiAgICAgICAgICAgIHdhaXQ6ICd3YWl0J1xuICAgICAgICB9O1xuICAgICAgICB2YXIgX21lJHByb3BzID0gbWUucHJvcHM7XG4gICAgICAgIHZhciBwcmVmaXhDbHMgPSBfbWUkcHJvcHMucHJlZml4Q2xzO1xuICAgICAgICB2YXIgaWNvblByZWZpeENscyA9IF9tZSRwcm9wcy5pY29uUHJlZml4Q2xzO1xuICAgICAgICB2YXIgdHlwZSA9IF9tZSRwcm9wcy50eXBlO1xuICAgICAgICB2YXIgY2xvc2FibGUgPSBfbWUkcHJvcHMuY2xvc2FibGU7XG4gICAgICAgIHZhciBkZXNjcmlwdGlvbiA9IF9tZSRwcm9wcy5kZXNjcmlwdGlvbjtcbiAgICAgICAgdmFyIGhhc0NvbnRhaW5lciA9IF9tZSRwcm9wcy5oYXNDb250YWluZXI7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSBfbWUkcHJvcHMuY2xhc3NOYW1lO1xuXG4gICAgICAgIHZhciBpY29uVHlwZSA9IHR5cGU7XG4gICAgICAgIGlmIChpY29uUHJlZml4Q2xzID09ICdrdW1hLWljb24nKSB7XG4gICAgICAgICAgICBpY29uVHlwZSA9IGljb25NYXBbaWNvblR5cGVdO1xuICAgICAgICB9XG4gICAgICAgIC8vIOS/neivgSBjbGFzc05hbWUg5Yqg5Zyo5pyA5aSW5bGC5a655Zmo5LiKXG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ3AnLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6IGNsYXNzbmFtZXMoKF9jbGFzc25hbWVzID0ge30sIF9jbGFzc25hbWVzW3ByZWZpeENscyArICcgJyArIHByZWZpeENscyArICctJyArIHR5cGVdID0gdHJ1ZSwgX2NsYXNzbmFtZXNbY2xhc3NOYW1lXSA9ICEhY2xhc3NOYW1lICYmICFjbG9zYWJsZSAmJiAhZGVzY3JpcHRpb24gJiYgIWhhc0NvbnRhaW5lciwgX2NsYXNzbmFtZXMpKSB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnaScsIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWljb24gJyArIGljb25QcmVmaXhDbHMgKyAnICcgKyBpY29uUHJlZml4Q2xzICsgJy0nICsgaWNvblR5cGUgfSksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIG1lLnByb3BzLm1lc3NhZ2VcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgQWxlcnQucHJvdG90eXBlLnJlbmRlckRlcyA9IGZ1bmN0aW9uIHJlbmRlckRlcygpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIF9tZSRwcm9wczIgPSBtZS5wcm9wcztcbiAgICAgICAgdmFyIGRlc2NyaXB0aW9uID0gX21lJHByb3BzMi5kZXNjcmlwdGlvbjtcbiAgICAgICAgdmFyIHByZWZpeENscyA9IF9tZSRwcm9wczIucHJlZml4Q2xzO1xuXG4gICAgICAgIGlmICghIWRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAncCcsXG4gICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICcgJyArIHByZWZpeENscyArICctZm9sbG93JyB9LFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEFsZXJ0LnByb3RvdHlwZS5yZW5kZXJDbG9zZSA9IGZ1bmN0aW9uIHJlbmRlckNsb3NlKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgX21lJHByb3BzMyA9IG1lLnByb3BzO1xuICAgICAgICB2YXIgcHJlZml4Q2xzID0gX21lJHByb3BzMy5wcmVmaXhDbHM7XG4gICAgICAgIHZhciBpY29uUHJlZml4Q2xzID0gX21lJHByb3BzMy5pY29uUHJlZml4Q2xzO1xuXG4gICAgICAgIGlmIChtZS5wcm9wcy5jbG9zYWJsZSkge1xuICAgICAgICAgICAgaWYgKG1lLnByb3BzLmNsb3NlVGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWNsb3NlJywgb25DbGljazogbWUuaGFuZGxlQ2xvc2UuYmluZChtZSkgfSxcbiAgICAgICAgICAgICAgICAgICAgbWUucHJvcHMuY2xvc2VUZXh0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2knLCB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1jbG9zZSAnICsgaWNvblByZWZpeENscyArICcgJyArIGljb25QcmVmaXhDbHMgKyAnLWNsb3NlJywgb25DbGljazogbWUuaGFuZGxlQ2xvc2UuYmluZChtZSkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQWxlcnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIF9tZSRwcm9wczQgPSBtZS5wcm9wcztcbiAgICAgICAgdmFyIHByZWZpeENscyA9IF9tZSRwcm9wczQucHJlZml4Q2xzO1xuICAgICAgICB2YXIgdHlwZSA9IF9tZSRwcm9wczQudHlwZTtcbiAgICAgICAgdmFyIGNsb3NhYmxlID0gX21lJHByb3BzNC5jbG9zYWJsZTtcbiAgICAgICAgdmFyIGhhc0NvbnRhaW5lciA9IF9tZSRwcm9wczQuaGFzQ29udGFpbmVyO1xuICAgICAgICB2YXIgZGVzY3JpcHRpb24gPSBfbWUkcHJvcHM0LmRlc2NyaXB0aW9uO1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gX21lJHByb3BzNC5jbGFzc05hbWU7XG4gICAgICAgIHZhciBzaXplID0gX21lJHByb3BzNC5zaXplO1xuXG4gICAgICAgIHZhciBodG1sID0gdm9pZCAwO1xuICAgICAgICB2YXIgY29udGVudCA9IG1lLnJlbmRlckNvbnRlbnQoKTtcbiAgICAgICAgaWYgKGhhc0NvbnRhaW5lciB8fCBjbG9zYWJsZSB8fCAhIWRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB2YXIgX2NsYXNzbmFtZXMyO1xuXG4gICAgICAgICAgICBodG1sID0gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogY2xhc3NuYW1lcygoX2NsYXNzbmFtZXMyID0ge30sIF9jbGFzc25hbWVzMltwcmVmaXhDbHMgKyAnLWNvbnRhaW5lciAnICsgcHJlZml4Q2xzICsgJy1jb250YWluZXItJyArIHR5cGVdID0gdHJ1ZSwgX2NsYXNzbmFtZXMyW3ByZWZpeENscyArICctY29udGFpbmVyLWNsb3NhYmxlJ10gPSBjbG9zYWJsZSwgX2NsYXNzbmFtZXMyW2NsYXNzTmFtZV0gPSAhIWNsYXNzTmFtZSwgX2NsYXNzbmFtZXMyW3ByZWZpeENscyArICctc2l6ZS1sYXJnZSddID0gc2l6ZSA9PT0gJ2xhcmdlJywgX2NsYXNzbmFtZXMyKSkgfSxcbiAgICAgICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgICAgIG1lLnJlbmRlckRlcygpLFxuICAgICAgICAgICAgICAgIG1lLnJlbmRlckNsb3NlKClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBodG1sID0gY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5jbG9zZWQgPyBudWxsIDogaHRtbDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEFsZXJ0O1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5BbGVydC5kZWZhdWx0UHJvcHMgPSB7XG4gICAgcHJlZml4Q2xzOiAna3VtYS1hbGVydCcsXG4gICAgaWNvblByZWZpeENsczogJ2t1bWEtaWNvbicsXG4gICAgdHlwZTogJ21lc3NhZ2UnLFxuICAgIG9uQ2xvc2U6IGZ1bmN0aW9uIG9uQ2xvc2UoKSB7fSxcbiAgICBoYXNDb250YWluZXI6IGZhbHNlLFxuICAgIHNpemU6ICdub3JtYWwnXG59O1xuXG4vLyBodHRwOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvcmV1c2FibGUtY29tcG9uZW50cy5odG1sXG5BbGVydC5wcm9wVHlwZXMgPSB7XG4gICAgcHJlZml4Q2xzOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGljb25QcmVmaXhDbHM6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgdHlwZTogUmVhY3QuUHJvcFR5cGVzLm9uZU9mKFsnbWVzc2FnZScsICdlcnJvcicsICd3YXJuaW5nJywgJ3N1Y2Nlc3MnLCAncXVlc3Rpb24nLCAnc3RvcCcsICd3YWl0J10pLFxuICAgIGNsb3NhYmxlOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBoYXNDb250YWluZXI6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGNsb3NlVGV4dDogUmVhY3QuUHJvcFR5cGVzLm9uZU9mVHlwZShbUmVhY3QuUHJvcFR5cGVzLmVsZW1lbnQsIFJlYWN0LlByb3BUeXBlcy5zdHJpbmddKSxcbiAgICBtZXNzYWdlOiBSZWFjdC5Qcm9wVHlwZXMub25lT2ZUeXBlKFtSZWFjdC5Qcm9wVHlwZXMuZWxlbWVudCwgUmVhY3QuUHJvcFR5cGVzLnN0cmluZ10pLFxuICAgIGRlc2NyaXB0aW9uOiBSZWFjdC5Qcm9wVHlwZXMub25lT2ZUeXBlKFtSZWFjdC5Qcm9wVHlwZXMuZWxlbWVudCwgUmVhY3QuUHJvcFR5cGVzLnN0cmluZ10pLFxuICAgIG9uQ2xvc2U6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIHNpemU6IFJlYWN0LlByb3BUeXBlcy5vbmVPZihbJ25vcm1hbCcsICdsYXJnZSddKVxuXG59O1xuXG5BbGVydC5kaXNwbGF5TmFtZSA9IFwiQWxlcnRcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBBbGVydDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWFsZXJ0L2J1aWxkL0FsZXJ0LmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB3aW5kb3cuUmVhY3Q7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiBleHRlcm5hbCBcIndpbmRvdy5SZWFjdFwiXG4gKiogbW9kdWxlIGlkID0gM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB3aW5kb3cuUmVhY3RET00gfHwgd2luZG93LlJlYWN0O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogZXh0ZXJuYWwgXCJ3aW5kb3cuUmVhY3RET00gfHwgd2luZG93LlJlYWN0XCJcbiAqKiBtb2R1bGUgaWQgPSA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiFcbiAgQ29weXJpZ2h0IChjKSAyMDE2IEplZCBXYXRzb24uXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgc2VlXG4gIGh0dHA6Ly9qZWR3YXRzb24uZ2l0aHViLmlvL2NsYXNzbmFtZXNcbiovXG4vKiBnbG9iYWwgZGVmaW5lICovXG5cbihmdW5jdGlvbiAoKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgaGFzT3duID0ge30uaGFzT3duUHJvcGVydHk7XG5cblx0ZnVuY3Rpb24gY2xhc3NOYW1lcyAoKSB7XG5cdFx0dmFyIGNsYXNzZXMgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYgKCFhcmcpIGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyB8fCBhcmdUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goYXJnKTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaChjbGFzc05hbWVzLmFwcGx5KG51bGwsIGFyZykpO1xuXHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gYXJnKSB7XG5cdFx0XHRcdFx0aWYgKGhhc093bi5jYWxsKGFyZywga2V5KSAmJiBhcmdba2V5XSkge1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXMuam9pbignICcpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBjbGFzc05hbWVzO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyByZWdpc3RlciBhcyAnY2xhc3NuYW1lcycsIGNvbnNpc3RlbnQgd2l0aCBucG0gcGFja2FnZSBuYW1lXG5cdFx0ZGVmaW5lKCdjbGFzc25hbWVzJywgW10sIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBjbGFzc05hbWVzO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdy5jbGFzc05hbWVzID0gY2xhc3NOYW1lcztcblx0fVxufSgpKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NsYXNzbmFtZXMvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBfQnV0dG9uID0gcmVxdWlyZSgnLi9CdXR0b24nKTtcblxudmFyIF9CdXR0b24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQnV0dG9uKTtcblxudmFyIF9CdXR0b25Hcm91cCA9IHJlcXVpcmUoJy4vQnV0dG9uR3JvdXAnKTtcblxudmFyIF9CdXR0b25Hcm91cDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CdXR0b25Hcm91cCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG4vKipcbiAqIEJ1dHRvbiBDb21wb25lbnQgZm9yIHV4Y29yZVxuICogQGF1dGhvclxuICpcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIFV4Y29yZSBUZWFtLCBBbGludy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxuX0J1dHRvbjJbXCJkZWZhdWx0XCJdLkJ1dHRvbkdyb3VwID0gX0J1dHRvbkdyb3VwMltcImRlZmF1bHRcIl07XG5tb2R1bGUuZXhwb3J0cyA9IF9CdXR0b24yW1wiZGVmYXVsdFwiXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWJ1dHRvbi9idWlsZC9pbmRleC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JlYWN0RG9tID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBfcmVhY3REb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3REb20pO1xuXG52YXIgX2NsYXNzbmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG5cbnZhciBfY2xhc3NuYW1lczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc25hbWVzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIHNpemVNYXAgPSB7XG5cdHNtYWxsOiAnc20nLFxuXHRtZWRpdW06ICcnLFxuXHRsYXJnZTogJ2xnJ1xufSxcbiAgICB0eXBlTWFwID0ge1xuXHRwcmltYXJ5OiAncHJpbWFyeScsXG5cdHNlY29uZGFyeTogJ3NlY29uZGFyeScsXG5cdG91dGxpbmU6ICdvdXRsaW5lJyxcblx0ZGlzYWJsZWQ6ICdkaXNhYmxlZCdcbn0sXG4gICAgY2xzUHJlZml4ID0gJ2t1bWEtYnV0dG9uJztcblxudmFyIEJ1dHRvbiA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG5cdF9pbmhlcml0cyhCdXR0b24sIF9SZWFjdCRDb21wb25lbnQpO1xuXG5cdGZ1bmN0aW9uIEJ1dHRvbihwcm9wcykge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdXR0b24pO1xuXG5cdFx0cmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuXHR9XG5cblx0QnV0dG9uLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG5cdFx0dmFyIHByb3BzID0gdGhpcy5wcm9wcztcblx0XHR2YXIgdHlwZSA9IHByb3BzLmRpc2FibGVkID8gJ2Rpc2FibGVkJyA6IHByb3BzLnR5cGU7XG5cdFx0dmFyIGNsc09iaiA9IHt9O1xuXHRcdGlmIChwcm9wcy5jbGFzc05hbWUpIHtcblx0XHRcdGNsc09ialtwcm9wcy5jbGFzc05hbWVdID0gdHJ1ZTtcblx0XHR9XG5cdFx0aWYgKHNpemVNYXBbcHJvcHMuc2l6ZV0pIHtcblx0XHRcdGNsc09ialtjbHNQcmVmaXggKyAnLScgKyBzaXplTWFwW3Byb3BzLnNpemVdXSA9IHRydWU7XG5cdFx0fVxuXHRcdHZhciBjbGFzc05hbWUgPSAoMCwgX2NsYXNzbmFtZXMyW1wiZGVmYXVsdFwiXSkoY2xzUHJlZml4LCBjbHNQcmVmaXggKyAnLScgKyB0eXBlTWFwW3R5cGVdLCBjbHNPYmopO1xuXHRcdHZhciBwcm9wRXZlbnRzID0ge307XG5cdFx0T2JqZWN0LmtleXMocHJvcHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0aWYgKGtleS5pbmRleE9mKCdvbicpID09PSAwKSB7XG5cdFx0XHRcdHByb3BFdmVudHNba2V5XSA9IHByb3BzW2tleV07XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG5cdFx0XHQnYnV0dG9uJyxcblx0XHRcdF9leHRlbmRzKHsgY2xhc3NOYW1lOiBjbGFzc05hbWUsIGRpc2FibGVkOiBwcm9wcy5kaXNhYmxlZCB9LCBwcm9wRXZlbnRzKSxcblx0XHRcdHByb3BzLmNoaWxkcmVuXG5cdFx0KTtcblx0fTtcblxuXHRyZXR1cm4gQnV0dG9uO1xufShfcmVhY3QyW1wiZGVmYXVsdFwiXS5Db21wb25lbnQpO1xuXG5CdXR0b24uZGlzcGxheU5hbWUgPSAndXhjb3JlLWJ1dHRvbic7XG5CdXR0b24ucHJvcFR5cGVzID0ge1xuXHRzaXplOiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMub25lT2YoT2JqZWN0LmtleXMoc2l6ZU1hcCkpLFxuXHR0eXBlOiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMub25lT2YoT2JqZWN0LmtleXModHlwZU1hcCkpLFxuXHRkaXNhYmxlZDogX3JlYWN0MltcImRlZmF1bHRcIl0uUHJvcFR5cGVzLm9uZU9mKFsnZGlzYWJsZWQnLCB0cnVlLCBmYWxzZV0pLFxuXHRjbGFzc05hbWU6IF9yZWFjdDJbXCJkZWZhdWx0XCJdLlByb3BUeXBlcy5zdHJpbmdcbn07XG5CdXR0b24uZGVmYXVsdFByb3BzID0ge1xuXHRzaXplOiAnbWVkaXVtJyxcblx0dHlwZTogJ3ByaW1hcnknLFxuXHRkaXNhYmxlZDogZmFsc2UsXG5cdGNsYXNzTmFtZTogJydcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQnV0dG9uO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtYnV0dG9uL2J1aWxkL0J1dHRvbi5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JlYWN0RG9tID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBfcmVhY3REb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3REb20pO1xuXG52YXIgX2NsYXNzbmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG5cbnZhciBfY2xhc3NuYW1lczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc25hbWVzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEJ1dHRvbkdyb3VwID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcblx0X2luaGVyaXRzKEJ1dHRvbkdyb3VwLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuXHRmdW5jdGlvbiBCdXR0b25Hcm91cChwcm9wcykge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdXR0b25Hcm91cCk7XG5cblx0XHRyZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSk7XG5cdH1cblxuXHRCdXR0b25Hcm91cC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuXHRcdHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuXHRcdFx0J2RpdicsXG5cdFx0XHR7IGNsYXNzTmFtZTogJ2t1bWEtYnV0dG9uLWdyb3VwJyB9LFxuXHRcdFx0dGhpcy5wcm9wcy5jaGlsZHJlblxuXHRcdCk7XG5cdH07XG5cblx0cmV0dXJuIEJ1dHRvbkdyb3VwO1xufShfcmVhY3QyW1wiZGVmYXVsdFwiXS5Db21wb25lbnQpO1xuXG5CdXR0b25Hcm91cC5kaXNwbGF5TmFtZSA9ICdCdXR0b25Hcm91cCc7XG5CdXR0b25Hcm91cC5wcm9wVHlwZXMgPSB7fTtcbkJ1dHRvbkdyb3VwLmRlZmF1bHRQcm9wcyA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1dHRvbkdyb3VwO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtYnV0dG9uL2J1aWxkL0J1dHRvbkdyb3VwLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBSY0NhbGVuZGFyID0gcmVxdWlyZSgnLi9SY0NhbGVuZGFyJyk7XG52YXIgR3JlZ29yaWFuQ2FsZW5kYXIgPSByZXF1aXJlKCdncmVnb3JpYW4tY2FsZW5kYXInKTtcbnZhciBEYXRlVGltZUZvcm1hdCA9IHJlcXVpcmUoJ2dyZWdvcmlhbi1jYWxlbmRhci1mb3JtYXQnKTtcbnZhciBEYXRlcGlja2VyID0gcmVxdWlyZSgncmMtY2FsZW5kYXIvbGliL1BpY2tlcicpO1xudmFyIFJjTW9udGhDYWxlbmRhciA9IHJlcXVpcmUoJ3JjLWNhbGVuZGFyL2xpYi9Nb250aENhbGVuZGFyJyk7XG52YXIgUmNZZWFyQ2FsZW5kYXIgPSByZXF1aXJlKCcuL1llYXJDYWxlbmRhcicpO1xudmFyIFRpbWVQaWNrZXIgPSByZXF1aXJlKCdyYy10aW1lLXBpY2tlcicpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIGRlZmF1bHRWYWx1ZUxvY2FsZSA9IHt9O1xudmFyIENhbGVuZGFyTG9jYWxlID0ge307XG52YXIgVGltZVBpY2tlckxvY2FsZSA9IHt9O1xuZGVmYXVsdFZhbHVlTG9jYWxlWyd6aC1jbiddID0gcmVxdWlyZSgnZ3JlZ29yaWFuLWNhbGVuZGFyL2xpYi9sb2NhbGUvemhfQ04nKTtcbmRlZmF1bHRWYWx1ZUxvY2FsZVsnZW4tdXMnXSA9IHJlcXVpcmUoJ2dyZWdvcmlhbi1jYWxlbmRhci9saWIvbG9jYWxlL2VuX1VTJyk7XG5DYWxlbmRhckxvY2FsZVsnemgtY24nXSA9IHJlcXVpcmUoJ3JjLWNhbGVuZGFyL2xpYi9sb2NhbGUvemhfQ04nKTtcbkNhbGVuZGFyTG9jYWxlWydlbi11cyddID0gcmVxdWlyZSgncmMtY2FsZW5kYXIvbGliL2xvY2FsZS9lbl9VUycpO1xuVGltZVBpY2tlckxvY2FsZVsnemgtY24nXSA9IHJlcXVpcmUoJ3JjLXRpbWUtcGlja2VyL2xpYi9sb2NhbGUvemhfQ04nKTtcblRpbWVQaWNrZXJMb2NhbGVbJ2VuLXVzJ10gPSByZXF1aXJlKCdyYy10aW1lLXBpY2tlci9saWIvbG9jYWxlL2VuX1VTJyk7XG5cbmZ1bmN0aW9uIGdldEdyZWdvcmlhbkNhbGVuZGFyRGF0ZShkYXRlLCBsb2NhbGUpIHtcbiAgICBkZWZhdWx0VmFsdWVMb2NhbGVbbG9jYWxlXS50aW1lem9uZU9mZnNldCA9IC1uZXcgRGF0ZSgpLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgdmFyIHZhbHVlID0gbmV3IEdyZWdvcmlhbkNhbGVuZGFyKGRlZmF1bHRWYWx1ZUxvY2FsZVtsb2NhbGVdKTtcbiAgICB2YWx1ZS5zZXRUaW1lKG5ldyBEYXRlKGRhdGUpLnZhbHVlT2YoKSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBnZXRDYWxlbmRhckNvbnRhaW5lcigpIHtcbiAgICB2YXIgYyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGMuY2xhc3NOYW1lID0gJ3V4Y29yZSc7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjKTtcbiAgICByZXR1cm4gYztcbn1cblxudmFyIENhbGVuZGFyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoQ2FsZW5kYXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gQ2FsZW5kYXIocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhbGVuZGFyKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgICAgICBfdGhpcy5zdGF0ZSA9IHt9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgbWUuVGltZVBpY2tlckVsZW1lbnQgPSBSZWFjdC5jcmVhdGVFbGVtZW50KFRpbWVQaWNrZXIsIHsgcHJlZml4Q2xzOiAna3VtYS10aW1lLXBpY2tlcicsIGxvY2FsZTogVGltZVBpY2tlckxvY2FsZVttZS5wcm9wcy5sb2NhbGVdIH0pO1xuICAgIH07XG5cbiAgICBDYWxlbmRhci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgcCA9IG1lLnByb3BzO1xuICAgICAgICB2YXIgZm9ybWF0dGVyID0gbmV3IERhdGVUaW1lRm9ybWF0KHAuZm9ybWF0KTtcbiAgICAgICAgdmFyIGNhbGVuZGFyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogcC5jbGFzc05hbWUsXG4gICAgICAgICAgICBzdHlsZTogcC5zdHlsZSxcbiAgICAgICAgICAgIGNvbnRlbnRSZW5kZXI6IHAuY29udGVudFJlbmRlcixcbiAgICAgICAgICAgIGRpc2FibGVkRGF0ZTogcC5kaXNhYmxlZERhdGUsXG4gICAgICAgICAgICBzaG93V2Vla051bWJlcjogcC5zaG93V2Vla051bWJlcixcbiAgICAgICAgICAgIHNob3dUb2RheTogcC5zaG93VG9kYXksXG4gICAgICAgICAgICB0aW1lUGlja2VyOiBwLnNob3dUaW1lID8gbWUuVGltZVBpY2tlckVsZW1lbnQgOiBudWxsLFxuICAgICAgICAgICAgc2hvd0RhdGVJbnB1dDogcC5zaG93RGF0ZUlucHV0LFxuICAgICAgICAgICAgbG9jYWxlOiBDYWxlbmRhckxvY2FsZVtwLmxvY2FsZV0sXG4gICAgICAgICAgICBwcmVmaXhDbHM6ICdrdW1hLWNhbGVuZGFyJ1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcGlja2VyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGRpc2FibGVkOiBwLmRpc2FibGVkLFxuICAgICAgICAgICAgZm9ybWF0dGVyOiBmb3JtYXR0ZXIsXG4gICAgICAgICAgICB0cmFuc2l0aW9uTmFtZTogcC50cmFuc2l0aW9uTmFtZSxcbiAgICAgICAgICAgIGFkanVzdE9yaWVudE9uQ2FsZW5kYXJPdmVyZmxvdzogZmFsc2UsXG4gICAgICAgICAgICBwcmVmaXhDbHM6ICdrdW1hLWNhbGVuZGFyLXBpY2tlcicsXG4gICAgICAgICAgICBwbGFjZW1lbnQ6ICdib3R0b21MZWZ0JyxcbiAgICAgICAgICAgIGdldENhbGVuZGFyQ29udGFpbmVyOiBnZXRDYWxlbmRhckNvbnRhaW5lclxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChwLnZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBnZXRHcmVnb3JpYW5DYWxlbmRhckRhdGUocC52YWx1ZSwgcC5sb2NhbGUpO1xuICAgICAgICAgICAgcGlja2VyT3B0aW9ucy52YWx1ZSA9IGNhbGVuZGFyT3B0aW9ucy5kZWZhdWx0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBpY2tlck9wdGlvbnMudmFsdWUgPSBjYWxlbmRhck9wdGlvbnMuZGVmYXVsdFZhbHVlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwLmRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZ2V0R3JlZ29yaWFuQ2FsZW5kYXJEYXRlKHAuZGVmYXVsdFZhbHVlLCBwLmxvY2FsZSk7XG4gICAgICAgICAgICBjYWxlbmRhck9wdGlvbnMuZGVmYXVsdFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBwaWNrZXJPcHRpb25zLmRlZmF1bHRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZ2V0R3JlZ29yaWFuQ2FsZW5kYXJEYXRlKG5ldyBEYXRlKCkuZ2V0VGltZSgpLCBwLmxvY2FsZSk7XG4gICAgICAgICAgICBjYWxlbmRhck9wdGlvbnMuZGVmYXVsdFZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAuaGFzVHJpZ2dlcikge1xuICAgICAgICAgICAgcGlja2VyT3B0aW9ucy50cmlnZ2VyID0gUmVhY3QuY3JlYXRlRWxlbWVudCgnaScsIHsgY2xhc3NOYW1lOiAna3VtYS1pY29uIGt1bWEtaWNvbi1jYWxlbmRlcicgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FsZW5kYXIgPSBSZWFjdC5jcmVhdGVFbGVtZW50KFJjQ2FsZW5kYXIsIGNhbGVuZGFyT3B0aW9ucyk7XG5cbiAgICAgICAgZnVuY3Rpb24gX29uQ2hhbmdlKHYpIHtcbiAgICAgICAgICAgIHZhciBkYXRlID0gdi5nZXRUaW1lKCk7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBnZXRHcmVnb3JpYW5DYWxlbmRhckRhdGUoZGF0ZSwgcC5sb2NhbGUpO1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vblNlbGVjdChuZXcgRGF0ZShkYXRlKSwgZm9ybWF0dGVyLmZvcm1hdCh2YWx1ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBEYXRlcGlja2VyLFxuICAgICAgICAgICAgX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgIGNhbGVuZGFyOiBjYWxlbmRhcixcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogX29uQ2hhbmdlLmJpbmQobWUpXG4gICAgICAgICAgICB9LCBwaWNrZXJPcHRpb25zKSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gX3JlZi52YWx1ZTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdpbnB1dCcsIHsgdmFsdWU6IHZhbHVlICYmIGZvcm1hdHRlci5mb3JtYXQodmFsdWUpLCByZWFkT25seTogdHJ1ZSwgZGlzYWJsZWQ6IG1lLnByb3BzLmRpc2FibGVkLCBwbGFjZWhvbGRlcjogX3RoaXMyLnByb3BzLnBsYWNlaG9sZGVyLCBjbGFzc05hbWU6ICdrdW1hLWNhbGVuZGFyLXBpY2tlci1pbnB1dCBrdW1hLWlucHV0JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENhbGVuZGFyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5DYWxlbmRhci5kaXNwbGF5TmFtZSA9ICdDYWxlbmRhcic7XG5DYWxlbmRhci5kZWZhdWx0UHJvcHMgPSB7XG4gICAgZm9ybWF0OiAneXl5eS1NTS1kZCcsXG4gICAgcGxhY2Vob2xkZXI6ICfor7fpgInmi6nml6XmnJ8nLFxuICAgIG9uU2VsZWN0OiBmdW5jdGlvbiBvblNlbGVjdCgpIHt9LFxuICAgIGxvY2FsZTogJ3poLWNuJyxcbiAgICBzaG93RGF0ZUlucHV0OiBmYWxzZSxcbiAgICBoYXNUcmlnZ2VyOiBmYWxzZVxufTtcbkNhbGVuZGFyLnByb3BUeXBlcyA9IHtcbiAgICBmb3JtYXQ6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgcGxhY2Vob2xkZXI6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgb25TZWxlY3Q6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIGxvY2FsZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBoYXNUcmlnZ2VyOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbFxufTtcblxudmFyIE1vbnRoQ2FsZW5kYXIgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudDIpIHtcbiAgICBfaW5oZXJpdHMoTW9udGhDYWxlbmRhciwgX1JlYWN0JENvbXBvbmVudDIpO1xuXG4gICAgZnVuY3Rpb24gTW9udGhDYWxlbmRhcihwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTW9udGhDYWxlbmRhcik7XG5cbiAgICAgICAgdmFyIF90aGlzMyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQyLmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgICAgICBfdGhpczMuc3RhdGUgPSB7fTtcbiAgICAgICAgcmV0dXJuIF90aGlzMztcbiAgICB9XG5cbiAgICBNb250aENhbGVuZGFyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBwID0gbWUucHJvcHM7XG4gICAgICAgIHZhciBmb3JtYXR0ZXIgPSBuZXcgRGF0ZVRpbWVGb3JtYXQocC5mb3JtYXQpO1xuICAgICAgICB2YXIgY2FsZW5kYXJPcHRpb25zID0ge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBwLmNsYXNzTmFtZSxcbiAgICAgICAgICAgIHN0eWxlOiBwLnN0eWxlLFxuICAgICAgICAgICAgbG9jYWxlOiBDYWxlbmRhckxvY2FsZVtwLmxvY2FsZV0sXG4gICAgICAgICAgICBvcmllbnQ6IFsndG9wJywgJ2xlZnQnXSxcbiAgICAgICAgICAgIHByZWZpeENsczogJ2t1bWEtY2FsZW5kYXInXG4gICAgICAgIH07XG4gICAgICAgIHZhciBwaWNrZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgZGlzYWJsZWQ6IHAuZGlzYWJsZWQsXG4gICAgICAgICAgICB0cmFuc2l0aW9uTmFtZTogcC50cmFuc2l0aW9uTmFtZSxcbiAgICAgICAgICAgIGZvcm1hdHRlcjogZm9ybWF0dGVyLFxuICAgICAgICAgICAgYWRqdXN0T3JpZW50T25DYWxlbmRhck92ZXJmbG93OiBmYWxzZSxcbiAgICAgICAgICAgIHByZWZpeENsczogJ2t1bWEtY2FsZW5kYXItcGlja2VyJyxcbiAgICAgICAgICAgIGdldENhbGVuZGFyQ29udGFpbmVyOiBnZXRDYWxlbmRhckNvbnRhaW5lclxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChwLnZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBnZXRHcmVnb3JpYW5DYWxlbmRhckRhdGUocC52YWx1ZSwgcC5sb2NhbGUpO1xuICAgICAgICAgICAgcGlja2VyT3B0aW9ucy52YWx1ZSA9IGNhbGVuZGFyT3B0aW9ucy5kZWZhdWx0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBpY2tlck9wdGlvbnMudmFsdWUgPSBjYWxlbmRhck9wdGlvbnMuZGVmYXVsdFZhbHVlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwLmRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZ2V0R3JlZ29yaWFuQ2FsZW5kYXJEYXRlKHAuZGVmYXVsdFZhbHVlLCBwLmxvY2FsZSk7XG4gICAgICAgICAgICBjYWxlbmRhck9wdGlvbnMuZGVmYXVsdFZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbGVuZGFyID0gUmVhY3QuY3JlYXRlRWxlbWVudChSY01vbnRoQ2FsZW5kYXIsIGNhbGVuZGFyT3B0aW9ucyk7XG5cbiAgICAgICAgZnVuY3Rpb24gX29uQ2hhbmdlKHYpIHtcbiAgICAgICAgICAgIHZhciBkYXRlID0gdi5nZXRUaW1lKCk7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBnZXRHcmVnb3JpYW5DYWxlbmRhckRhdGUoZGF0ZSwgcC5sb2NhbGUpO1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vblNlbGVjdChuZXcgRGF0ZShkYXRlKSwgZm9ybWF0dGVyLmZvcm1hdCh2YWx1ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBEYXRlcGlja2VyLFxuICAgICAgICAgICAgX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgIGNhbGVuZGFyOiBjYWxlbmRhcixcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogX29uQ2hhbmdlLmJpbmQobWUpXG4gICAgICAgICAgICB9LCBwaWNrZXJPcHRpb25zKSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IF9yZWYyLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JywgeyByZWFkT25seTogdHJ1ZSwgdmFsdWU6IHZhbHVlICYmIGZvcm1hdHRlci5mb3JtYXQodmFsdWUpLCBkaXNhYmxlZDogbWUucHJvcHMuZGlzYWJsZWQsIHBsYWNlaG9sZGVyOiBfdGhpczQucHJvcHMucGxhY2Vob2xkZXIsIGNsYXNzTmFtZTogJ2t1bWEtY2FsZW5kYXItcGlja2VyLWlucHV0IGt1bWEtaW5wdXQnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gTW9udGhDYWxlbmRhcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuTW9udGhDYWxlbmRhci5kaXNwbGF5TmFtZSA9ICdNb250aENhbGVuZGFyJztcbk1vbnRoQ2FsZW5kYXIuZGVmYXVsdFByb3BzID0ge1xuICAgIGZvcm1hdDogJ3l5eXktTU0nLFxuICAgIHBsYWNlaG9sZGVyOiAn6K+36YCJ5oup5pyI5Lu9JyxcbiAgICBvblNlbGVjdDogZnVuY3Rpb24gb25TZWxlY3QoKSB7fSxcbiAgICBsb2NhbGU6ICd6aC1jbidcbn07XG5Nb250aENhbGVuZGFyLnByb3BUeXBlcyA9IHtcbiAgICBmb3JtYXQ6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgcGxhY2Vob2xkZXI6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgb25TZWxlY3Q6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIGxvY2FsZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZ1xufTtcblxudmFyIFllYXJDYWxlbmRhciA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50Mykge1xuICAgIF9pbmhlcml0cyhZZWFyQ2FsZW5kYXIsIF9SZWFjdCRDb21wb25lbnQzKTtcblxuICAgIGZ1bmN0aW9uIFllYXJDYWxlbmRhcihwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgWWVhckNhbGVuZGFyKTtcblxuICAgICAgICB2YXIgX3RoaXM1ID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudDMuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgICAgIF90aGlzNS5zdGF0ZSA9IHt9O1xuICAgICAgICByZXR1cm4gX3RoaXM1O1xuICAgIH1cblxuICAgIFllYXJDYWxlbmRhci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgcCA9IG1lLnByb3BzO1xuICAgICAgICB2YXIgZm9ybWF0dGVyID0gbmV3IERhdGVUaW1lRm9ybWF0KHAuZm9ybWF0KTtcbiAgICAgICAgdmFyIGNhbGVuZGFyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogcC5jbGFzc05hbWUsXG4gICAgICAgICAgICBzdHlsZTogcC5zdHlsZSxcbiAgICAgICAgICAgIGxvY2FsZTogQ2FsZW5kYXJMb2NhbGVbcC5sb2NhbGVdLFxuICAgICAgICAgICAgb3JpZW50OiBbJ3RvcCcsICdsZWZ0J10sXG4gICAgICAgICAgICBwcmVmaXhDbHM6ICdrdW1hLWNhbGVuZGFyJ1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcGlja2VyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGRpc2FibGVkOiBwLmRpc2FibGVkLFxuICAgICAgICAgICAgZm9ybWF0dGVyOiBmb3JtYXR0ZXIsXG4gICAgICAgICAgICB0cmFuc2l0aW9uTmFtZTogcC50cmFuc2l0aW9uTmFtZSxcbiAgICAgICAgICAgIGFkanVzdE9yaWVudE9uQ2FsZW5kYXJPdmVyZmxvdzogZmFsc2UsXG4gICAgICAgICAgICBwcmVmaXhDbHM6ICdrdW1hLWNhbGVuZGFyLXBpY2tlcicsXG4gICAgICAgICAgICBnZXRDYWxlbmRhckNvbnRhaW5lcjogZ2V0Q2FsZW5kYXJDb250YWluZXJcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAocC52YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZ2V0R3JlZ29yaWFuQ2FsZW5kYXJEYXRlKHAudmFsdWUsIHAubG9jYWxlKTtcbiAgICAgICAgICAgIHBpY2tlck9wdGlvbnMudmFsdWUgPSBjYWxlbmRhck9wdGlvbnMuZGVmYXVsdFZhbHVlID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwaWNrZXJPcHRpb25zLnZhbHVlID0gY2FsZW5kYXJPcHRpb25zLmRlZmF1bHRWYWx1ZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocC5kZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGdldEdyZWdvcmlhbkNhbGVuZGFyRGF0ZShwLmRlZmF1bHRWYWx1ZSwgcC5sb2NhbGUpO1xuICAgICAgICAgICAgY2FsZW5kYXJPcHRpb25zLmRlZmF1bHRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYWxlbmRhciA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmNZZWFyQ2FsZW5kYXIsIGNhbGVuZGFyT3B0aW9ucyk7XG5cbiAgICAgICAgZnVuY3Rpb24gX29uQ2hhbmdlKHYpIHtcbiAgICAgICAgICAgIHZhciBkYXRlID0gdi5nZXRUaW1lKCk7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBnZXRHcmVnb3JpYW5DYWxlbmRhckRhdGUoZGF0ZSwgcC5sb2NhbGUpO1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vblNlbGVjdChuZXcgRGF0ZShkYXRlKSwgZm9ybWF0dGVyLmZvcm1hdCh2YWx1ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBEYXRlcGlja2VyLFxuICAgICAgICAgICAgX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgIGNhbGVuZGFyOiBjYWxlbmRhcixcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogX29uQ2hhbmdlLmJpbmQobWUpXG4gICAgICAgICAgICB9LCBwaWNrZXJPcHRpb25zKSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IF9yZWYzLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JywgeyB2YWx1ZTogdmFsdWUgJiYgZm9ybWF0dGVyLmZvcm1hdCh2YWx1ZSksIHJlYWRPbmx5OiB0cnVlLCBkaXNhYmxlZDogbWUucHJvcHMuZGlzYWJsZWQsIHBsYWNlaG9sZGVyOiBfdGhpczYucHJvcHMucGxhY2Vob2xkZXIsIGNsYXNzTmFtZTogJ2t1bWEtY2FsZW5kYXItcGlja2VyLWlucHV0IGt1bWEtaW5wdXQnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gWWVhckNhbGVuZGFyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5ZZWFyQ2FsZW5kYXIuZGlzcGxheU5hbWUgPSAnWWVhckNhbGVuZGFyJztcblllYXJDYWxlbmRhci5kZWZhdWx0UHJvcHMgPSB7XG4gICAgZm9ybWF0OiAneXl5eScsXG4gICAgcGxhY2Vob2xkZXI6ICfor7fpgInmi6nlubTku70nLFxuICAgIG9uU2VsZWN0OiBmdW5jdGlvbiBvblNlbGVjdCgpIHt9LFxuICAgIGxvY2FsZTogJ3poLWNuJ1xufTtcblllYXJDYWxlbmRhci5wcm9wVHlwZXMgPSB7XG4gICAgZm9ybWF0OiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHBsYWNlaG9sZGVyOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9uU2VsZWN0OiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBsb2NhbGU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmdcbn07XG5cbkNhbGVuZGFyLk1vbnRoQ2FsZW5kYXIgPSBNb250aENhbGVuZGFyO1xuQ2FsZW5kYXIuWWVhckNhbGVuZGFyID0gWWVhckNhbGVuZGFyO1xuQ2FsZW5kYXIuQ2FsZW5kYXJQYW5lbCA9IFJjQ2FsZW5kYXI7XG5DYWxlbmRhci51dGlsID0gdXRpbDtcblxubW9kdWxlLmV4cG9ydHMgPSBDYWxlbmRhcjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL2J1aWxkL0NhbGVuZGFyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfZ3JlZ29yaWFuQ2FsZW5kYXIgPSByZXF1aXJlKCdncmVnb3JpYW4tY2FsZW5kYXInKTtcblxudmFyIF9ncmVnb3JpYW5DYWxlbmRhcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ncmVnb3JpYW5DYWxlbmRhcik7XG5cbnZhciBfcmNVdGlsID0gcmVxdWlyZSgncmMtdXRpbCcpO1xuXG52YXIgX0RhdGVUYWJsZSA9IHJlcXVpcmUoJy4vZGF0ZS9EYXRlVGFibGUnKTtcblxudmFyIF9EYXRlVGFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRGF0ZVRhYmxlKTtcblxudmFyIF9DYWxlbmRhckhlYWRlciA9IHJlcXVpcmUoJ3JjLWNhbGVuZGFyL2xpYi9jYWxlbmRhci9DYWxlbmRhckhlYWRlcicpO1xuXG52YXIgX0NhbGVuZGFySGVhZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NhbGVuZGFySGVhZGVyKTtcblxudmFyIF9DYWxlbmRhckZvb3RlciA9IHJlcXVpcmUoJ3JjLWNhbGVuZGFyL2xpYi9jYWxlbmRhci9DYWxlbmRhckZvb3RlcicpO1xuXG52YXIgX0NhbGVuZGFyRm9vdGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NhbGVuZGFyRm9vdGVyKTtcblxudmFyIF9DYWxlbmRhck1peGluID0gcmVxdWlyZSgncmMtY2FsZW5kYXIvbGliL21peGluL0NhbGVuZGFyTWl4aW4nKTtcblxudmFyIF9DYWxlbmRhck1peGluMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NhbGVuZGFyTWl4aW4pO1xuXG52YXIgX0NvbW1vbk1peGluID0gcmVxdWlyZSgncmMtY2FsZW5kYXIvbGliL21peGluL0NvbW1vbk1peGluJyk7XG5cbnZhciBfQ29tbW9uTWl4aW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ29tbW9uTWl4aW4pO1xuXG52YXIgX0RhdGVJbnB1dCA9IHJlcXVpcmUoJ3JjLWNhbGVuZGFyL2xpYi9kYXRlL0RhdGVJbnB1dCcpO1xuXG52YXIgX0RhdGVJbnB1dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EYXRlSW5wdXQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gbm9vcCgpIHt9IC8vIGN1c3RvbWl6ZWQgcmMtY2FsZW5kYXIgaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0LWNvbXBvbmVudC9jYWxlbmRhci9ibG9iL21hc3Rlci9zcmMvQ2FsZW5kYXIuanN4XG5cbmZ1bmN0aW9uIGdvU3RhcnRNb250aCgpIHtcbiAgdmFyIG5leHQgPSB0aGlzLnN0YXRlLnZhbHVlLmNsb25lKCk7XG4gIG5leHQuc2V0RGF5T2ZNb250aCgxKTtcbiAgdGhpcy5zZXRWYWx1ZShuZXh0KTtcbn1cblxuZnVuY3Rpb24gZ29FbmRNb250aCgpIHtcbiAgdmFyIG5leHQgPSB0aGlzLnN0YXRlLnZhbHVlLmNsb25lKCk7XG4gIG5leHQuc2V0RGF5T2ZNb250aChuZXh0LmdldEFjdHVhbE1heGltdW0oX2dyZWdvcmlhbkNhbGVuZGFyMltcImRlZmF1bHRcIl0uTU9OVEgpKTtcbiAgdGhpcy5zZXRWYWx1ZShuZXh0KTtcbn1cblxuZnVuY3Rpb24gZ29Nb250aChkaXJlY3Rpb24pIHtcbiAgdmFyIG5leHQgPSB0aGlzLnN0YXRlLnZhbHVlLmNsb25lKCk7XG4gIG5leHQuYWRkTW9udGgoZGlyZWN0aW9uKTtcbiAgdGhpcy5zZXRWYWx1ZShuZXh0KTtcbn1cblxuZnVuY3Rpb24gZ29ZZWFyKGRpcmVjdGlvbikge1xuICB2YXIgbmV4dCA9IHRoaXMuc3RhdGUudmFsdWUuY2xvbmUoKTtcbiAgbmV4dC5hZGRZZWFyKGRpcmVjdGlvbik7XG4gIHRoaXMuc2V0VmFsdWUobmV4dCk7XG59XG5cbmZ1bmN0aW9uIGdvV2VlayhkaXJlY3Rpb24pIHtcbiAgdmFyIG5leHQgPSB0aGlzLnN0YXRlLnZhbHVlLmNsb25lKCk7XG4gIG5leHQuYWRkV2Vla09mWWVhcihkaXJlY3Rpb24pO1xuICB0aGlzLnNldFZhbHVlKG5leHQpO1xufVxuXG5mdW5jdGlvbiBnb0RheShkaXJlY3Rpb24pIHtcbiAgdmFyIG5leHQgPSB0aGlzLnN0YXRlLnZhbHVlLmNsb25lKCk7XG4gIG5leHQuYWRkRGF5T2ZNb250aChkaXJlY3Rpb24pO1xuICB0aGlzLnNldFZhbHVlKG5leHQpO1xufVxuXG52YXIgQ2FsZW5kYXIgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnQ2FsZW5kYXInLFxuXG4gIHByb3BUeXBlczoge1xuICAgIGRpc2FibGVkRGF0ZTogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIGRpc2FibGVkVGltZTogX3JlYWN0LlByb3BUeXBlcy5hbnksXG4gICAgdmFsdWU6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIHNlbGVjdGVkVmFsdWU6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIGRlZmF1bHRWYWx1ZTogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgY2xhc3NOYW1lOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBsb2NhbGU6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIHNob3dXZWVrTnVtYmVyOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgc3R5bGU6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIHNob3dUb2RheTogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIHNob3dEYXRlSW5wdXQ6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICB2aXNpYmxlOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgb25TZWxlY3Q6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbk9rOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgc2hvd09rOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgcHJlZml4Q2xzOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBvbktleURvd246IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICB0aW1lUGlja2VyOiBfcmVhY3QuUHJvcFR5cGVzLmVsZW1lbnQsXG4gICAgZGF0ZUlucHV0UGxhY2Vob2xkZXI6IF9yZWFjdC5Qcm9wVHlwZXMuYW55LFxuICAgIG9uQ2xlYXI6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNoYW5nZTogX3JlYWN0LlByb3BUeXBlcy5mdW5jXG4gIH0sXG5cbiAgbWl4aW5zOiBbX0NvbW1vbk1peGluMltcImRlZmF1bHRcIl0sIF9DYWxlbmRhck1peGluMltcImRlZmF1bHRcIl1dLFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzaG93VG9kYXk6IHRydWUsXG4gICAgICBzaG93RGF0ZUlucHV0OiB0cnVlLFxuICAgICAgdGltZVBpY2tlcjogbnVsbCxcbiAgICAgIG9uT2s6IG5vb3BcbiAgICB9O1xuICB9LFxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgICAvLyBiaW5kIG1ldGhvZHNcbiAgICB0aGlzLm5leHRNb250aCA9IGdvTW9udGguYmluZCh0aGlzLCAxKTtcbiAgICB0aGlzLnByZXZpb3VzTW9udGggPSBnb01vbnRoLmJpbmQodGhpcywgLTEpO1xuICAgIHRoaXMubmV4dFllYXIgPSBnb1llYXIuYmluZCh0aGlzLCAxKTtcbiAgICB0aGlzLnByZXZpb3VzWWVhciA9IGdvWWVhci5iaW5kKHRoaXMsIC0xKTtcbiAgICByZXR1cm4ge307XG4gIH0sXG4gIG9uS2V5RG93bjogZnVuY3Rpb24gb25LZXlEb3duKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB2YXIga2V5Q29kZSA9IGV2ZW50LmtleUNvZGU7XG4gICAgLy8gbWFjXG4gICAgdmFyIGN0cmxLZXkgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7XG4gICAgc3dpdGNoIChrZXlDb2RlKSB7XG4gICAgICBjYXNlIF9yY1V0aWwuS2V5Q29kZS5ET1dOOlxuICAgICAgICBnb1dlZWsuY2FsbCh0aGlzLCAxKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBjYXNlIF9yY1V0aWwuS2V5Q29kZS5VUDpcbiAgICAgICAgZ29XZWVrLmNhbGwodGhpcywgLTEpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGNhc2UgX3JjVXRpbC5LZXlDb2RlLkxFRlQ6XG4gICAgICAgIGlmIChjdHJsS2V5KSB7XG4gICAgICAgICAgdGhpcy5wcmV2aW91c1llYXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnb0RheS5jYWxsKHRoaXMsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGNhc2UgX3JjVXRpbC5LZXlDb2RlLlJJR0hUOlxuICAgICAgICBpZiAoY3RybEtleSkge1xuICAgICAgICAgIHRoaXMubmV4dFllYXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnb0RheS5jYWxsKHRoaXMsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgY2FzZSBfcmNVdGlsLktleUNvZGUuSE9NRTpcbiAgICAgICAgZ29TdGFydE1vbnRoLmNhbGwodGhpcyk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgY2FzZSBfcmNVdGlsLktleUNvZGUuRU5EOlxuICAgICAgICBnb0VuZE1vbnRoLmNhbGwodGhpcyk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgY2FzZSBfcmNVdGlsLktleUNvZGUuUEFHRV9ET1dOOlxuICAgICAgICB0aGlzLm5leHRNb250aCgpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGNhc2UgX3JjVXRpbC5LZXlDb2RlLlBBR0VfVVA6XG4gICAgICAgIHRoaXMucHJldmlvdXNNb250aCgpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGNhc2UgX3JjVXRpbC5LZXlDb2RlLkVOVEVSOlxuICAgICAgICB0aGlzLm9uU2VsZWN0KHRoaXMuc3RhdGUudmFsdWUpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMucHJvcHMub25LZXlEb3duKGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9LFxuICBvbkNsZWFyOiBmdW5jdGlvbiBvbkNsZWFyKCkge1xuICAgIHRoaXMub25TZWxlY3QobnVsbCk7XG4gICAgdGhpcy5wcm9wcy5vbkNsZWFyKCk7XG4gIH0sXG4gIG9uT2s6IGZ1bmN0aW9uIG9uT2soKSB7XG4gICAgdmFyIHNlbGVjdGVkVmFsdWUgPSB0aGlzLnN0YXRlLnNlbGVjdGVkVmFsdWU7XG5cbiAgICBpZiAodGhpcy5pc0FsbG93ZWREYXRlKHNlbGVjdGVkVmFsdWUpKSB7XG4gICAgICB0aGlzLnByb3BzLm9uT2soc2VsZWN0ZWRWYWx1ZSk7XG4gICAgfVxuICB9LFxuICBvbkRhdGVJbnB1dENoYW5nZTogZnVuY3Rpb24gb25EYXRlSW5wdXRDaGFuZ2UodmFsdWUpIHtcbiAgICB0aGlzLm9uU2VsZWN0KHZhbHVlLCB7XG4gICAgICBzb3VyY2U6ICdkYXRlSW5wdXQnXG4gICAgfSk7XG4gIH0sXG4gIG9uRGF0ZVRhYmxlU2VsZWN0OiBmdW5jdGlvbiBvbkRhdGVUYWJsZVNlbGVjdCh2YWx1ZSkge1xuICAgIHRoaXMub25TZWxlY3QodmFsdWUpO1xuICB9LFxuICBjaG9vc2VUb2RheTogZnVuY3Rpb24gY2hvb3NlVG9kYXkoKSB7XG4gICAgdmFyIHRvZGF5ID0gdGhpcy5zdGF0ZS52YWx1ZS5jbG9uZSgpO1xuICAgIHRvZGF5LnNldFRpbWUoRGF0ZS5ub3coKSk7XG4gICAgdGhpcy5vblNlbGVjdCh0b2RheSk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGxvY2FsZSA9IHByb3BzLmxvY2FsZTtcbiAgICB2YXIgcHJlZml4Q2xzID0gcHJvcHMucHJlZml4Q2xzO1xuICAgIHZhciBkaXNhYmxlZERhdGUgPSBwcm9wcy5kaXNhYmxlZERhdGU7XG4gICAgdmFyIGRhdGVJbnB1dFBsYWNlaG9sZGVyID0gcHJvcHMuZGF0ZUlucHV0UGxhY2Vob2xkZXI7XG4gICAgdmFyIHRpbWVQaWNrZXIgPSBwcm9wcy50aW1lUGlja2VyO1xuICAgIHZhciBkaXNhYmxlZFRpbWUgPSBwcm9wcy5kaXNhYmxlZFRpbWU7XG5cbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHZhciB2YWx1ZSA9IHN0YXRlLnZhbHVlO1xuICAgIHZhciBzZWxlY3RlZFZhbHVlID0gc3RhdGUuc2VsZWN0ZWRWYWx1ZTtcblxuICAgIHZhciBkYXRlSW5wdXRFbGVtZW50ID0gcHJvcHMuc2hvd0RhdGVJbnB1dCA/IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0RhdGVJbnB1dDJbXCJkZWZhdWx0XCJdLCB7XG4gICAgICBmb3JtYXR0ZXI6IHRoaXMuZ2V0Rm9ybWF0dGVyKCksXG4gICAgICBrZXk6ICdkYXRlLWlucHV0JyxcbiAgICAgIHRpbWVQaWNrZXI6IHRpbWVQaWNrZXIsXG4gICAgICBncmVnb3JpYW5DYWxlbmRhckxvY2FsZTogdmFsdWUubG9jYWxlLFxuICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICBwbGFjZWhvbGRlcjogZGF0ZUlucHV0UGxhY2Vob2xkZXIsXG4gICAgICBzaG93Q2xlYXI6IHRydWUsXG4gICAgICBkaXNhYmxlZFRpbWU6IGRpc2FibGVkVGltZSxcbiAgICAgIGRpc2FibGVkRGF0ZTogZGlzYWJsZWREYXRlLFxuICAgICAgb25DbGVhcjogdGhpcy5vbkNsZWFyLFxuICAgICAgcHJlZml4Q2xzOiBwcmVmaXhDbHMsXG4gICAgICBzZWxlY3RlZFZhbHVlOiBzZWxlY3RlZFZhbHVlLFxuICAgICAgb25DaGFuZ2U6IHRoaXMub25EYXRlSW5wdXRDaGFuZ2VcbiAgICB9KSA6IG51bGw7XG4gICAgdmFyIGNoaWxkcmVuID0gW2RhdGVJbnB1dEVsZW1lbnQsIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnZGl2JyxcbiAgICAgIHtcbiAgICAgICAga2V5OiAnZGF0ZS1wYW5lbCcsXG4gICAgICAgIGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1kYXRlLXBhbmVsJ1xuICAgICAgfSxcbiAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0NhbGVuZGFySGVhZGVyMltcImRlZmF1bHRcIl0sIHtcbiAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgIG9uVmFsdWVDaGFuZ2U6IHRoaXMuc2V0VmFsdWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgcHJlZml4Q2xzOiBwcmVmaXhDbHNcbiAgICAgIH0pLFxuICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWNhbGVuZGFyLWJvZHknIH0sXG4gICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0RhdGVUYWJsZTJbXCJkZWZhdWx0XCJdLCB7XG4gICAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIHNlbGVjdGVkVmFsdWU6IHNlbGVjdGVkVmFsdWUsXG4gICAgICAgICAgcHJlZml4Q2xzOiBwcmVmaXhDbHMsXG4gICAgICAgICAgZGF0ZVJlbmRlcjogcHJvcHMuZGF0ZVJlbmRlcixcbiAgICAgICAgICBjb250ZW50UmVuZGVyOiBwcm9wcy5jb250ZW50UmVuZGVyLFxuICAgICAgICAgIG9uU2VsZWN0OiB0aGlzLm9uRGF0ZVRhYmxlU2VsZWN0LFxuICAgICAgICAgIGRpc2FibGVkRGF0ZTogZGlzYWJsZWREYXRlLFxuICAgICAgICAgIHNob3dXZWVrTnVtYmVyOiBwcm9wcy5zaG93V2Vla051bWJlclxuICAgICAgICB9KVxuICAgICAgKSxcbiAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0NhbGVuZGFyRm9vdGVyMltcImRlZmF1bHRcIl0sIHtcbiAgICAgICAgc2hvd09rOiBwcm9wcy5zaG93T2ssXG4gICAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgICBwcmVmaXhDbHM6IHByZWZpeENscyxcbiAgICAgICAgc2hvd1RvZGF5OiBwcm9wcy5zaG93VG9kYXksXG4gICAgICAgIGRpc2FibGVkVGltZTogZGlzYWJsZWRUaW1lLFxuICAgICAgICBncmVnb3JpYW5DYWxlbmRhckxvY2FsZTogdmFsdWUubG9jYWxlLFxuICAgICAgICBzaG93RGF0ZUlucHV0OiBwcm9wcy5zaG93RGF0ZUlucHV0LFxuICAgICAgICB0aW1lUGlja2VyOiB0aW1lUGlja2VyLFxuICAgICAgICBzZWxlY3RlZFZhbHVlOiBzZWxlY3RlZFZhbHVlLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGRpc2FibGVkRGF0ZTogZGlzYWJsZWREYXRlLFxuICAgICAgICBvbk9rOiB0aGlzLm9uT2ssXG4gICAgICAgIG9uU2VsZWN0OiB0aGlzLm9uU2VsZWN0LFxuICAgICAgICBvblRvZGF5OiB0aGlzLmNob29zZVRvZGF5XG4gICAgICB9KVxuICAgICldO1xuXG4gICAgcmV0dXJuIHRoaXMucmVuZGVyUm9vdCh7XG4gICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICBjbGFzc05hbWU6IHByb3BzLnNob3dXZWVrTnVtYmVyID8gcHJlZml4Q2xzICsgJy13ZWVrLW51bWJlcicgOiAnJ1xuICAgIH0pO1xuICB9XG59KTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBDYWxlbmRhcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvYnVpbGQvUmNDYWxlbmRhci5qc1xuICoqLyIsIi8qXG4gKiBAaWdub3JlXG4gKiBjb25zdCBmb3IgZ3JlZ29yaWFuIGRhdGVcbiAqIEBhdXRob3IgeWltaW5naGVAZ21haWwuY29tXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKlxuICAgKiBFbnVtIGluZGljYXRpbmcgc3VuZGF5XG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAbWVtYmVyIERhdGUuR3JlZ29yaWFuXG4gICAqL1xuICBTVU5EQVk6IDAsXG4gIC8qXG4gICAqIEVudW0gaW5kaWNhdGluZyBtb25kYXlcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBtZW1iZXIgRGF0ZS5HcmVnb3JpYW5cbiAgICovXG4gIE1PTkRBWTogMSxcbiAgLypcbiAgICogRW51bSBpbmRpY2F0aW5nIHR1ZXNkYXlcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBtZW1iZXIgRGF0ZS5HcmVnb3JpYW5cbiAgICovXG4gIFRVRVNEQVk6IDIsXG4gIC8qXG4gICAqIEVudW0gaW5kaWNhdGluZyB3ZWRuZXNkYXlcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBtZW1iZXIgRGF0ZS5HcmVnb3JpYW5cbiAgICovXG4gIFdFRE5FU0RBWTogMyxcbiAgLypcbiAgICogRW51bSBpbmRpY2F0aW5nIHRodXJzZGF5XG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAbWVtYmVyIERhdGUuR3JlZ29yaWFuXG4gICAqL1xuICBUSFVSU0RBWTogNCxcbiAgLypcbiAgICogRW51bSBpbmRpY2F0aW5nIGZyaWRheVxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQG1lbWJlciBEYXRlLkdyZWdvcmlhblxuICAgKi9cbiAgRlJJREFZOiA1LFxuICAvKlxuICAgKiBFbnVtIGluZGljYXRpbmcgc2F0dXJkYXlcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBtZW1iZXIgRGF0ZS5HcmVnb3JpYW5cbiAgICovXG4gIFNBVFVSREFZOiA2LFxuICAvKlxuICAgKiBFbnVtIGluZGljYXRpbmcgamFudWFyeVxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQG1lbWJlciBEYXRlLkdyZWdvcmlhblxuICAgKi9cbiAgSkFOVUFSWTogMCxcbiAgLypcbiAgICogRW51bSBpbmRpY2F0aW5nIGZlYnJ1YXJ5XG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAbWVtYmVyIERhdGUuR3JlZ29yaWFuXG4gICAqL1xuICBGRUJSVUFSWTogMSxcbiAgLypcbiAgICogRW51bSBpbmRpY2F0aW5nIG1hcmNoXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAbWVtYmVyIERhdGUuR3JlZ29yaWFuXG4gICAqL1xuICBNQVJDSDogMixcbiAgLypcbiAgICogRW51bSBpbmRpY2F0aW5nIGFwcmlsXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAbWVtYmVyIERhdGUuR3JlZ29yaWFuXG4gICAqL1xuICBBUFJJTDogMyxcbiAgLypcbiAgICogRW51bSBpbmRpY2F0aW5nIG1heVxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQG1lbWJlciBEYXRlLkdyZWdvcmlhblxuICAgKi9cbiAgTUFZOiA0LFxuICAvKlxuICAgKiBFbnVtIGluZGljYXRpbmcganVuZVxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQG1lbWJlciBEYXRlLkdyZWdvcmlhblxuICAgKi9cbiAgSlVORTogNSxcbiAgLypcbiAgICogRW51bSBpbmRpY2F0aW5nIGp1bHlcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBtZW1iZXIgRGF0ZS5HcmVnb3JpYW5cbiAgICovXG4gIEpVTFk6IDYsXG4gIC8qXG4gICAqIEVudW0gaW5kaWNhdGluZyBhdWd1c3RcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBtZW1iZXIgRGF0ZS5HcmVnb3JpYW5cbiAgICovXG4gIEFVR1VTVDogNyxcbiAgLypcbiAgICogRW51bSBpbmRpY2F0aW5nIHNlcHRlbWJlclxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQG1lbWJlciBEYXRlLkdyZWdvcmlhblxuICAgKi9cbiAgU0VQVEVNQkVSOiA4LFxuICAvKlxuICAgKiBFbnVtIGluZGljYXRpbmcgb2N0b2JlclxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQG1lbWJlciBEYXRlLkdyZWdvcmlhblxuICAgKi9cbiAgT0NUT0JFUjogOSxcbiAgLypcbiAgICogRW51bSBpbmRpY2F0aW5nIG5vdmVtYmVyXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAbWVtYmVyIERhdGUuR3JlZ29yaWFuXG4gICAqL1xuICBOT1ZFTUJFUjogMTAsXG4gIC8qXG4gICAqIEVudW0gaW5kaWNhdGluZyBkZWNlbWJlclxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQG1lbWJlciBEYXRlLkdyZWdvcmlhblxuICAgKi9cbiAgREVDRU1CRVI6IDExXG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9ncmVnb3JpYW4tY2FsZW5kYXIvbGliL2NvbnN0LmpzXG4gKiovIiwiLypcbiAqIGVuLXVzIGxvY2FsZVxuICogQGlnbm9yZVxuICogQGF1dGhvciB5aW1pbmdoZUBnbWFpbC5jb21cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBpbiBtaW51dGVzXG4gIHRpbWV6b25lT2Zmc2V0OiAtOCAqIDYwLFxuICBmaXJzdERheU9mV2VlazogMCxcbiAgbWluaW1hbERheXNJbkZpcnN0V2VlazogMVxufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vZ3JlZ29yaWFuLWNhbGVuZGFyL2xpYi9sb2NhbGUvZW5fVVMuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzZWVkID0gMDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ3VpZCgpIHtcbiAgcmV0dXJuIERhdGUubm93KCkgKyAnXycgKyBzZWVkKys7XG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy11dGlsL2xpYi9ndWlkLmpzXG4gKiovIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xuXG4vKipcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXCJkZXByZWNhdGVkXCIgdmVyc2lvbiBvZiBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XG4gIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzXG4gIHRyeSB7XG4gICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLXV0aWwvfi91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzXG4gKiovIiwiLyoqXG4gKiBAaWdub3JlXG4gKiBzb21lIGtleS1jb2RlcyBkZWZpbml0aW9uIGFuZCB1dGlscyBmcm9tIGNsb3N1cmUtbGlicmFyeVxuICogQGF1dGhvciB5aW1pbmdoZUBnbWFpbC5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBLZXlDb2RlID0ge1xuICAvKipcbiAgICogTUFDX0VOVEVSXG4gICAqL1xuICBNQUNfRU5URVI6IDMsXG4gIC8qKlxuICAgKiBCQUNLU1BBQ0VcbiAgICovXG4gIEJBQ0tTUEFDRTogOCxcbiAgLyoqXG4gICAqIFRBQlxuICAgKi9cbiAgVEFCOiA5LFxuICAvKipcbiAgICogTlVNTE9DSyBvbiBGRi9TYWZhcmkgTWFjXG4gICAqL1xuICBOVU1fQ0VOVEVSOiAxMiwgLy8gTlVNTE9DSyBvbiBGRi9TYWZhcmkgTWFjXG4gIC8qKlxuICAgKiBFTlRFUlxuICAgKi9cbiAgRU5URVI6IDEzLFxuICAvKipcbiAgICogU0hJRlRcbiAgICovXG4gIFNISUZUOiAxNixcbiAgLyoqXG4gICAqIENUUkxcbiAgICovXG4gIENUUkw6IDE3LFxuICAvKipcbiAgICogQUxUXG4gICAqL1xuICBBTFQ6IDE4LFxuICAvKipcbiAgICogUEFVU0VcbiAgICovXG4gIFBBVVNFOiAxOSxcbiAgLyoqXG4gICAqIENBUFNfTE9DS1xuICAgKi9cbiAgQ0FQU19MT0NLOiAyMCxcbiAgLyoqXG4gICAqIEVTQ1xuICAgKi9cbiAgRVNDOiAyNyxcbiAgLyoqXG4gICAqIFNQQUNFXG4gICAqL1xuICBTUEFDRTogMzIsXG4gIC8qKlxuICAgKiBQQUdFX1VQXG4gICAqL1xuICBQQUdFX1VQOiAzMywgLy8gYWxzbyBOVU1fTk9SVEhfRUFTVFxuICAvKipcbiAgICogUEFHRV9ET1dOXG4gICAqL1xuICBQQUdFX0RPV046IDM0LCAvLyBhbHNvIE5VTV9TT1VUSF9FQVNUXG4gIC8qKlxuICAgKiBFTkRcbiAgICovXG4gIEVORDogMzUsIC8vIGFsc28gTlVNX1NPVVRIX1dFU1RcbiAgLyoqXG4gICAqIEhPTUVcbiAgICovXG4gIEhPTUU6IDM2LCAvLyBhbHNvIE5VTV9OT1JUSF9XRVNUXG4gIC8qKlxuICAgKiBMRUZUXG4gICAqL1xuICBMRUZUOiAzNywgLy8gYWxzbyBOVU1fV0VTVFxuICAvKipcbiAgICogVVBcbiAgICovXG4gIFVQOiAzOCwgLy8gYWxzbyBOVU1fTk9SVEhcbiAgLyoqXG4gICAqIFJJR0hUXG4gICAqL1xuICBSSUdIVDogMzksIC8vIGFsc28gTlVNX0VBU1RcbiAgLyoqXG4gICAqIERPV05cbiAgICovXG4gIERPV046IDQwLCAvLyBhbHNvIE5VTV9TT1VUSFxuICAvKipcbiAgICogUFJJTlRfU0NSRUVOXG4gICAqL1xuICBQUklOVF9TQ1JFRU46IDQ0LFxuICAvKipcbiAgICogSU5TRVJUXG4gICAqL1xuICBJTlNFUlQ6IDQ1LCAvLyBhbHNvIE5VTV9JTlNFUlRcbiAgLyoqXG4gICAqIERFTEVURVxuICAgKi9cbiAgREVMRVRFOiA0NiwgLy8gYWxzbyBOVU1fREVMRVRFXG4gIC8qKlxuICAgKiBaRVJPXG4gICAqL1xuICBaRVJPOiA0OCxcbiAgLyoqXG4gICAqIE9ORVxuICAgKi9cbiAgT05FOiA0OSxcbiAgLyoqXG4gICAqIFRXT1xuICAgKi9cbiAgVFdPOiA1MCxcbiAgLyoqXG4gICAqIFRIUkVFXG4gICAqL1xuICBUSFJFRTogNTEsXG4gIC8qKlxuICAgKiBGT1VSXG4gICAqL1xuICBGT1VSOiA1MixcbiAgLyoqXG4gICAqIEZJVkVcbiAgICovXG4gIEZJVkU6IDUzLFxuICAvKipcbiAgICogU0lYXG4gICAqL1xuICBTSVg6IDU0LFxuICAvKipcbiAgICogU0VWRU5cbiAgICovXG4gIFNFVkVOOiA1NSxcbiAgLyoqXG4gICAqIEVJR0hUXG4gICAqL1xuICBFSUdIVDogNTYsXG4gIC8qKlxuICAgKiBOSU5FXG4gICAqL1xuICBOSU5FOiA1NyxcbiAgLyoqXG4gICAqIFFVRVNUSU9OX01BUktcbiAgICovXG4gIFFVRVNUSU9OX01BUks6IDYzLCAvLyBuZWVkcyBsb2NhbGl6YXRpb25cbiAgLyoqXG4gICAqIEFcbiAgICovXG4gIEE6IDY1LFxuICAvKipcbiAgICogQlxuICAgKi9cbiAgQjogNjYsXG4gIC8qKlxuICAgKiBDXG4gICAqL1xuICBDOiA2NyxcbiAgLyoqXG4gICAqIERcbiAgICovXG4gIEQ6IDY4LFxuICAvKipcbiAgICogRVxuICAgKi9cbiAgRTogNjksXG4gIC8qKlxuICAgKiBGXG4gICAqL1xuICBGOiA3MCxcbiAgLyoqXG4gICAqIEdcbiAgICovXG4gIEc6IDcxLFxuICAvKipcbiAgICogSFxuICAgKi9cbiAgSDogNzIsXG4gIC8qKlxuICAgKiBJXG4gICAqL1xuICBJOiA3MyxcbiAgLyoqXG4gICAqIEpcbiAgICovXG4gIEo6IDc0LFxuICAvKipcbiAgICogS1xuICAgKi9cbiAgSzogNzUsXG4gIC8qKlxuICAgKiBMXG4gICAqL1xuICBMOiA3NixcbiAgLyoqXG4gICAqIE1cbiAgICovXG4gIE06IDc3LFxuICAvKipcbiAgICogTlxuICAgKi9cbiAgTjogNzgsXG4gIC8qKlxuICAgKiBPXG4gICAqL1xuICBPOiA3OSxcbiAgLyoqXG4gICAqIFBcbiAgICovXG4gIFA6IDgwLFxuICAvKipcbiAgICogUVxuICAgKi9cbiAgUTogODEsXG4gIC8qKlxuICAgKiBSXG4gICAqL1xuICBSOiA4MixcbiAgLyoqXG4gICAqIFNcbiAgICovXG4gIFM6IDgzLFxuICAvKipcbiAgICogVFxuICAgKi9cbiAgVDogODQsXG4gIC8qKlxuICAgKiBVXG4gICAqL1xuICBVOiA4NSxcbiAgLyoqXG4gICAqIFZcbiAgICovXG4gIFY6IDg2LFxuICAvKipcbiAgICogV1xuICAgKi9cbiAgVzogODcsXG4gIC8qKlxuICAgKiBYXG4gICAqL1xuICBYOiA4OCxcbiAgLyoqXG4gICAqIFlcbiAgICovXG4gIFk6IDg5LFxuICAvKipcbiAgICogWlxuICAgKi9cbiAgWjogOTAsXG4gIC8qKlxuICAgKiBNRVRBXG4gICAqL1xuICBNRVRBOiA5MSwgLy8gV0lOX0tFWV9MRUZUXG4gIC8qKlxuICAgKiBXSU5fS0VZX1JJR0hUXG4gICAqL1xuICBXSU5fS0VZX1JJR0hUOiA5MixcbiAgLyoqXG4gICAqIENPTlRFWFRfTUVOVVxuICAgKi9cbiAgQ09OVEVYVF9NRU5VOiA5MyxcbiAgLyoqXG4gICAqIE5VTV9aRVJPXG4gICAqL1xuICBOVU1fWkVSTzogOTYsXG4gIC8qKlxuICAgKiBOVU1fT05FXG4gICAqL1xuICBOVU1fT05FOiA5NyxcbiAgLyoqXG4gICAqIE5VTV9UV09cbiAgICovXG4gIE5VTV9UV086IDk4LFxuICAvKipcbiAgICogTlVNX1RIUkVFXG4gICAqL1xuICBOVU1fVEhSRUU6IDk5LFxuICAvKipcbiAgICogTlVNX0ZPVVJcbiAgICovXG4gIE5VTV9GT1VSOiAxMDAsXG4gIC8qKlxuICAgKiBOVU1fRklWRVxuICAgKi9cbiAgTlVNX0ZJVkU6IDEwMSxcbiAgLyoqXG4gICAqIE5VTV9TSVhcbiAgICovXG4gIE5VTV9TSVg6IDEwMixcbiAgLyoqXG4gICAqIE5VTV9TRVZFTlxuICAgKi9cbiAgTlVNX1NFVkVOOiAxMDMsXG4gIC8qKlxuICAgKiBOVU1fRUlHSFRcbiAgICovXG4gIE5VTV9FSUdIVDogMTA0LFxuICAvKipcbiAgICogTlVNX05JTkVcbiAgICovXG4gIE5VTV9OSU5FOiAxMDUsXG4gIC8qKlxuICAgKiBOVU1fTVVMVElQTFlcbiAgICovXG4gIE5VTV9NVUxUSVBMWTogMTA2LFxuICAvKipcbiAgICogTlVNX1BMVVNcbiAgICovXG4gIE5VTV9QTFVTOiAxMDcsXG4gIC8qKlxuICAgKiBOVU1fTUlOVVNcbiAgICovXG4gIE5VTV9NSU5VUzogMTA5LFxuICAvKipcbiAgICogTlVNX1BFUklPRFxuICAgKi9cbiAgTlVNX1BFUklPRDogMTEwLFxuICAvKipcbiAgICogTlVNX0RJVklTSU9OXG4gICAqL1xuICBOVU1fRElWSVNJT046IDExMSxcbiAgLyoqXG4gICAqIEYxXG4gICAqL1xuICBGMTogMTEyLFxuICAvKipcbiAgICogRjJcbiAgICovXG4gIEYyOiAxMTMsXG4gIC8qKlxuICAgKiBGM1xuICAgKi9cbiAgRjM6IDExNCxcbiAgLyoqXG4gICAqIEY0XG4gICAqL1xuICBGNDogMTE1LFxuICAvKipcbiAgICogRjVcbiAgICovXG4gIEY1OiAxMTYsXG4gIC8qKlxuICAgKiBGNlxuICAgKi9cbiAgRjY6IDExNyxcbiAgLyoqXG4gICAqIEY3XG4gICAqL1xuICBGNzogMTE4LFxuICAvKipcbiAgICogRjhcbiAgICovXG4gIEY4OiAxMTksXG4gIC8qKlxuICAgKiBGOVxuICAgKi9cbiAgRjk6IDEyMCxcbiAgLyoqXG4gICAqIEYxMFxuICAgKi9cbiAgRjEwOiAxMjEsXG4gIC8qKlxuICAgKiBGMTFcbiAgICovXG4gIEYxMTogMTIyLFxuICAvKipcbiAgICogRjEyXG4gICAqL1xuICBGMTI6IDEyMyxcbiAgLyoqXG4gICAqIE5VTUxPQ0tcbiAgICovXG4gIE5VTUxPQ0s6IDE0NCxcbiAgLyoqXG4gICAqIFNFTUlDT0xPTlxuICAgKi9cbiAgU0VNSUNPTE9OOiAxODYsIC8vIG5lZWRzIGxvY2FsaXphdGlvblxuICAvKipcbiAgICogREFTSFxuICAgKi9cbiAgREFTSDogMTg5LCAvLyBuZWVkcyBsb2NhbGl6YXRpb25cbiAgLyoqXG4gICAqIEVRVUFMU1xuICAgKi9cbiAgRVFVQUxTOiAxODcsIC8vIG5lZWRzIGxvY2FsaXphdGlvblxuICAvKipcbiAgICogQ09NTUFcbiAgICovXG4gIENPTU1BOiAxODgsIC8vIG5lZWRzIGxvY2FsaXphdGlvblxuICAvKipcbiAgICogUEVSSU9EXG4gICAqL1xuICBQRVJJT0Q6IDE5MCwgLy8gbmVlZHMgbG9jYWxpemF0aW9uXG4gIC8qKlxuICAgKiBTTEFTSFxuICAgKi9cbiAgU0xBU0g6IDE5MSwgLy8gbmVlZHMgbG9jYWxpemF0aW9uXG4gIC8qKlxuICAgKiBBUE9TVFJPUEhFXG4gICAqL1xuICBBUE9TVFJPUEhFOiAxOTIsIC8vIG5lZWRzIGxvY2FsaXphdGlvblxuICAvKipcbiAgICogU0lOR0xFX1FVT1RFXG4gICAqL1xuICBTSU5HTEVfUVVPVEU6IDIyMiwgLy8gbmVlZHMgbG9jYWxpemF0aW9uXG4gIC8qKlxuICAgKiBPUEVOX1NRVUFSRV9CUkFDS0VUXG4gICAqL1xuICBPUEVOX1NRVUFSRV9CUkFDS0VUOiAyMTksIC8vIG5lZWRzIGxvY2FsaXphdGlvblxuICAvKipcbiAgICogQkFDS1NMQVNIXG4gICAqL1xuICBCQUNLU0xBU0g6IDIyMCwgLy8gbmVlZHMgbG9jYWxpemF0aW9uXG4gIC8qKlxuICAgKiBDTE9TRV9TUVVBUkVfQlJBQ0tFVFxuICAgKi9cbiAgQ0xPU0VfU1FVQVJFX0JSQUNLRVQ6IDIyMSwgLy8gbmVlZHMgbG9jYWxpemF0aW9uXG4gIC8qKlxuICAgKiBXSU5fS0VZXG4gICAqL1xuICBXSU5fS0VZOiAyMjQsXG4gIC8qKlxuICAgKiBNQUNfRkZfTUVUQVxuICAgKi9cbiAgTUFDX0ZGX01FVEE6IDIyNCwgLy8gRmlyZWZveCAoR2Vja28pIGZpcmVzIHRoaXMgZm9yIHRoZSBtZXRhIGtleSBpbnN0ZWFkIG9mIDkxXG4gIC8qKlxuICAgKiBXSU5fSU1FXG4gICAqL1xuICBXSU5fSU1FOiAyMjlcbn07XG5cbi8qXG4gd2hldGhlciB0ZXh0IGFuZCBtb2RpZmllZCBrZXkgaXMgZW50ZXJlZCBhdCB0aGUgc2FtZSB0aW1lLlxuICovXG5LZXlDb2RlLmlzVGV4dE1vZGlmeWluZ0tleUV2ZW50ID0gZnVuY3Rpb24gaXNUZXh0TW9kaWZ5aW5nS2V5RXZlbnQoZSkge1xuICB2YXIga2V5Q29kZSA9IGUua2V5Q29kZTtcbiAgaWYgKGUuYWx0S2V5ICYmICFlLmN0cmxLZXkgfHwgZS5tZXRhS2V5IHx8XG4gIC8vIEZ1bmN0aW9uIGtleXMgZG9uJ3QgZ2VuZXJhdGUgdGV4dFxuICBrZXlDb2RlID49IEtleUNvZGUuRjEgJiYga2V5Q29kZSA8PSBLZXlDb2RlLkYxMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRoZSBmb2xsb3dpbmcga2V5cyBhcmUgcXVpdGUgaGFybWxlc3MsIGV2ZW4gaW4gY29tYmluYXRpb24gd2l0aFxuICAvLyBDVFJMLCBBTFQgb3IgU0hJRlQuXG4gIHN3aXRjaCAoa2V5Q29kZSkge1xuICAgIGNhc2UgS2V5Q29kZS5BTFQ6XG4gICAgY2FzZSBLZXlDb2RlLkNBUFNfTE9DSzpcbiAgICBjYXNlIEtleUNvZGUuQ09OVEVYVF9NRU5VOlxuICAgIGNhc2UgS2V5Q29kZS5DVFJMOlxuICAgIGNhc2UgS2V5Q29kZS5ET1dOOlxuICAgIGNhc2UgS2V5Q29kZS5FTkQ6XG4gICAgY2FzZSBLZXlDb2RlLkVTQzpcbiAgICBjYXNlIEtleUNvZGUuSE9NRTpcbiAgICBjYXNlIEtleUNvZGUuSU5TRVJUOlxuICAgIGNhc2UgS2V5Q29kZS5MRUZUOlxuICAgIGNhc2UgS2V5Q29kZS5NQUNfRkZfTUVUQTpcbiAgICBjYXNlIEtleUNvZGUuTUVUQTpcbiAgICBjYXNlIEtleUNvZGUuTlVNTE9DSzpcbiAgICBjYXNlIEtleUNvZGUuTlVNX0NFTlRFUjpcbiAgICBjYXNlIEtleUNvZGUuUEFHRV9ET1dOOlxuICAgIGNhc2UgS2V5Q29kZS5QQUdFX1VQOlxuICAgIGNhc2UgS2V5Q29kZS5QQVVTRTpcbiAgICBjYXNlIEtleUNvZGUuUFJJTlRfU0NSRUVOOlxuICAgIGNhc2UgS2V5Q29kZS5SSUdIVDpcbiAgICBjYXNlIEtleUNvZGUuU0hJRlQ6XG4gICAgY2FzZSBLZXlDb2RlLlVQOlxuICAgIGNhc2UgS2V5Q29kZS5XSU5fS0VZOlxuICAgIGNhc2UgS2V5Q29kZS5XSU5fS0VZX1JJR0hUOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuLypcbiB3aGV0aGVyIGNoYXJhY3RlciBpcyBlbnRlcmVkLlxuICovXG5LZXlDb2RlLmlzQ2hhcmFjdGVyS2V5ID0gZnVuY3Rpb24gaXNDaGFyYWN0ZXJLZXkoa2V5Q29kZSkge1xuICBpZiAoa2V5Q29kZSA+PSBLZXlDb2RlLlpFUk8gJiYga2V5Q29kZSA8PSBLZXlDb2RlLk5JTkUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChrZXlDb2RlID49IEtleUNvZGUuTlVNX1pFUk8gJiYga2V5Q29kZSA8PSBLZXlDb2RlLk5VTV9NVUxUSVBMWSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGtleUNvZGUgPj0gS2V5Q29kZS5BICYmIGtleUNvZGUgPD0gS2V5Q29kZS5aKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBTYWZhcmkgc2VuZHMgemVybyBrZXkgY29kZSBmb3Igbm9uLWxhdGluIGNoYXJhY3RlcnMuXG4gIGlmICh3aW5kb3cubmF2aWdhdGlvbi51c2VyQWdlbnQuaW5kZXhPZignV2ViS2l0JykgIT09IC0xICYmIGtleUNvZGUgPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHN3aXRjaCAoa2V5Q29kZSkge1xuICAgIGNhc2UgS2V5Q29kZS5TUEFDRTpcbiAgICBjYXNlIEtleUNvZGUuUVVFU1RJT05fTUFSSzpcbiAgICBjYXNlIEtleUNvZGUuTlVNX1BMVVM6XG4gICAgY2FzZSBLZXlDb2RlLk5VTV9NSU5VUzpcbiAgICBjYXNlIEtleUNvZGUuTlVNX1BFUklPRDpcbiAgICBjYXNlIEtleUNvZGUuTlVNX0RJVklTSU9OOlxuICAgIGNhc2UgS2V5Q29kZS5TRU1JQ09MT046XG4gICAgY2FzZSBLZXlDb2RlLkRBU0g6XG4gICAgY2FzZSBLZXlDb2RlLkVRVUFMUzpcbiAgICBjYXNlIEtleUNvZGUuQ09NTUE6XG4gICAgY2FzZSBLZXlDb2RlLlBFUklPRDpcbiAgICBjYXNlIEtleUNvZGUuU0xBU0g6XG4gICAgY2FzZSBLZXlDb2RlLkFQT1NUUk9QSEU6XG4gICAgY2FzZSBLZXlDb2RlLlNJTkdMRV9RVU9URTpcbiAgICBjYXNlIEtleUNvZGUuT1BFTl9TUVVBUkVfQlJBQ0tFVDpcbiAgICBjYXNlIEtleUNvZGUuQkFDS1NMQVNIOlxuICAgIGNhc2UgS2V5Q29kZS5DTE9TRV9TUVVBUkVfQlJBQ0tFVDpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gS2V5Q29kZTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtdXRpbC9saWIvS2V5Q29kZS5qc1xuICoqLyIsIi8qKlxuICogbG9kYXNoIDMuOS4xIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkgPiA1KS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZm5Ub1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqVG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZuVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZSgvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICByZXR1cm4gaXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIG9sZGVyIHZlcnNpb25zIG9mIENocm9tZSBhbmQgU2FmYXJpIHdoaWNoIHJldHVybiAnZnVuY3Rpb24nIGZvciByZWdleGVzXG4gIC8vIGFuZCBTYWZhcmkgOCBlcXVpdmFsZW50cyB3aGljaCByZXR1cm4gJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9ycy5cbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBmdW5jVGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBbbGFuZ3VhZ2UgdHlwZV0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4OCkgb2YgYE9iamVjdGAuXG4gKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTmF0aXZlKEFycmF5LnByb3RvdHlwZS5wdXNoKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTmF0aXZlKF8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgcmV0dXJuIHJlSXNOYXRpdmUudGVzdChmblRvU3RyaW5nLmNhbGwodmFsdWUpKTtcbiAgfVxuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiByZUlzSG9zdEN0b3IudGVzdCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TmF0aXZlO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLXV0aWwvfi9zaGFsbG93ZXF1YWwvfi9sb2Rhc2gua2V5cy9+L2xvZGFzaC5fZ2V0bmF0aXZlL2luZGV4LmpzXG4gKiovIiwiLyoqXG4gKiBsb2Rhc2ggMy4wLjggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTYgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNiBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgdmFsdWUgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBhdm9pZCBhIFtKSVQgYnVnXShodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQyNzkyKVxuICogdGhhdCBhZmZlY3RzIFNhZmFyaSBvbiBhdCBsZWFzdCBpT1MgOC4xLTguMyBBUk02NC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIFwibGVuZ3RoXCIgdmFsdWUuXG4gKi9cbnZhciBnZXRMZW5ndGggPSBiYXNlUHJvcGVydHkoJ2xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgLy8gU2FmYXJpIDguMSBpbmNvcnJlY3RseSBtYWtlcyBgYXJndW1lbnRzLmNhbGxlZWAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAoIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKSB8fCBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcmdzVGFnKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKGdldExlbmd0aCh2YWx1ZSkpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gKiBpcyBhbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA4IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGFuZCB3ZWFrIG1hcCBjb25zdHJ1Y3RvcnMsXG4gIC8vIGFuZCBQaGFudG9tSlMgMS45IHdoaWNoIHJldHVybnMgJ2Z1bmN0aW9uJyBmb3IgYE5vZGVMaXN0YCBpbnN0YW5jZXMuXG4gIHZhciB0YWcgPSBpc09iamVjdCh2YWx1ZSkgPyBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIGxvb3NlbHkgYmFzZWQgb24gW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgW2xhbmd1YWdlIHR5cGVdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDgpIG9mIGBPYmplY3RgLlxuICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJndW1lbnRzO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLXV0aWwvfi9zaGFsbG93ZXF1YWwvfi9sb2Rhc2gua2V5cy9+L2xvZGFzaC5pc2FyZ3VtZW50cy9pbmRleC5qc1xuICoqLyIsIi8qKlxuICogbG9kYXNoIDMuMC40IChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpID4gNSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZuVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmblRvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UoL1tcXFxcXiQuKis/KClbXFxde318XS9nLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQXJyYXkgPSBnZXROYXRpdmUoQXJyYXksICdpc0FycmF5Jyk7XG5cbi8qKlxuICogVXNlZCBhcyB0aGUgW21heGltdW0gbGVuZ3RoXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIubWF4X3NhZmVfaW50ZWdlcilcbiAqIG9mIGFuIGFycmF5LWxpa2UgdmFsdWUuXG4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIHJldHVybiBpc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJyYXlUYWc7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBvbGRlciB2ZXJzaW9ucyBvZiBDaHJvbWUgYW5kIFNhZmFyaSB3aGljaCByZXR1cm4gJ2Z1bmN0aW9uJyBmb3IgcmVnZXhlc1xuICAvLyBhbmQgU2FmYXJpIDggZXF1aXZhbGVudHMgd2hpY2ggcmV0dXJuICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvcnMuXG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gZnVuY1RhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgW2xhbmd1YWdlIHR5cGVdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDgpIG9mIGBPYmplY3RgLlxuICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdCgxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIC8vIEF2b2lkIGEgVjggSklUIGJ1ZyBpbiBDaHJvbWUgMTktMjAuXG4gIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc05hdGl2ZShBcnJheS5wcm90b3R5cGUucHVzaCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc05hdGl2ZShfKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHJldHVybiByZUlzTmF0aXZlLnRlc3QoZm5Ub1N0cmluZy5jYWxsKHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgcmVJc0hvc3RDdG9yLnRlc3QodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtdXRpbC9+L3NoYWxsb3dlcXVhbC9+L2xvZGFzaC5rZXlzL34vbG9kYXNoLmlzYXJyYXkvaW5kZXguanNcbiAqKi8iLCIvKipcbiAqIFNhZmUgY2hhaW5lZCBmdW5jdGlvblxuICpcbiAqIFdpbGwgb25seSBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gaWYgbmVlZGVkLFxuICogb3RoZXJ3aXNlIHdpbGwgcGFzcyBiYWNrIGV4aXN0aW5nIGZ1bmN0aW9ucyBvciBudWxsLlxuICpcbiAqIEByZXR1cm5zIHtmdW5jdGlvbnxudWxsfVxuICovXG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKCkge1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgcmV0dXJuIGZ1bmN0aW9uIGNoYWluZWRGdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhcmdzW2ldICYmIGFyZ3NbaV0uYXBwbHkpIHtcbiAgICAgICAgYXJnc1tpXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVDaGFpbmVkRnVuY3Rpb247XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLXV0aWwvbGliL2NyZWF0ZUNoYWluZWRGdW5jdGlvbi5qc1xuICoqLyIsIi8qKlxuICogQGlnbm9yZVxuICogYmFzZSBldmVudCBvYmplY3QgZm9yIGN1c3RvbSBhbmQgZG9tIGV2ZW50LlxuICogQGF1dGhvciB5aW1pbmdoZUBnbWFpbC5jb21cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEJhc2VPYmplY3QoKSB7XG4gIHRoaXMudGltZVN0YW1wID0gRGF0ZS5ub3coKTtcbiAgdGhpcy50YXJnZXQgPSB1bmRlZmluZWQ7XG4gIHRoaXMuY3VycmVudFRhcmdldCA9IHVuZGVmaW5lZDtcbn1cblxuRXZlbnRCYXNlT2JqZWN0LnByb3RvdHlwZSA9IHtcbiAgaXNFdmVudE9iamVjdDogMSxcblxuICBjb25zdHJ1Y3RvcjogRXZlbnRCYXNlT2JqZWN0LFxuXG4gIGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG5cbiAgaXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXG4gIGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblxuICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gcHJldmVudERlZmF1bHQoKSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuICB9LFxuXG4gIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuICB9LFxuXG4gIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24gc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkge1xuICAgIHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuICAgIC8vIGZpeGVkIDEuMlxuICAgIC8vIGNhbGwgc3RvcFByb3BhZ2F0aW9uIGltcGxpY2l0bHlcbiAgICB0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9LFxuXG4gIGhhbHQ6IGZ1bmN0aW9uIGhhbHQoaW1tZWRpYXRlKSB7XG4gICAgaWYgKGltbWVkaWF0ZSkge1xuICAgICAgdGhpcy5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gICAgdGhpcy5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG59O1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IEV2ZW50QmFzZU9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLXV0aWwvfi9hZGQtZG9tLWV2ZW50LWxpc3RlbmVyL2xpYi9FdmVudEJhc2VPYmplY3QuanNcbiAqKi8iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L29iamVjdC1hc3NpZ24vaW5kZXguanNcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb250YWlucyhyb290LCBuKSB7XG4gIHZhciBub2RlID0gbjtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZSA9PT0gcm9vdCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy11dGlsL2xpYi9Eb20vY29udGFpbnMuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICB2YXIgcmV0ID0gW107XG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIGVhY2goYykge1xuICAgIHJldC5wdXNoKGMpO1xuICB9KTtcbiAgcmV0dXJuIHJldDtcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLXV0aWwvbGliL0NoaWxkcmVuL3RvQXJyYXkuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbmZ1bmN0aW9uIG1pcnJvcihvKSB7XG4gIHJldHVybiBvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1hcFNlbGYoY2hpbGRyZW4pIHtcbiAgLy8gcmV0dXJuIFJlYWN0RnJhZ21lbnRcbiAgcmV0dXJuIFJlYWN0LkNoaWxkcmVuLm1hcChjaGlsZHJlbiwgbWlycm9yKTtcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLXV0aWwvbGliL0NoaWxkcmVuL21hcFNlbGYuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9EYXRlVEhlYWQgPSByZXF1aXJlKCdyYy1jYWxlbmRhci9saWIvZGF0ZS9EYXRlVEhlYWQnKTtcblxudmFyIF9EYXRlVEhlYWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRGF0ZVRIZWFkKTtcblxudmFyIF9EYXRlVEJvZHkgPSByZXF1aXJlKCcuL0RhdGVUQm9keScpO1xuXG52YXIgX0RhdGVUQm9keTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EYXRlVEJvZHkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfSAvLyBjdXN0b21pemVkIHJjLWNhbGVuZGFyIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdC1jb21wb25lbnQvY2FsZW5kYXIvYmxvYi9tYXN0ZXIvXG5cbnZhciBEYXRlVGFibGUgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoRGF0ZVRhYmxlLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBEYXRlVGFibGUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERhdGVUYWJsZSk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIERhdGVUYWJsZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHByZWZpeENscyA9IHByb3BzLnByZWZpeENscztcbiAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICd0YWJsZScsXG4gICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy10YWJsZScsIGNlbGxTcGFjaW5nOiAnMCcsIHJvbGU6ICdncmlkJyB9LFxuICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfRGF0ZVRIZWFkMltcImRlZmF1bHRcIl0sIHByb3BzKSxcbiAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0RhdGVUQm9keTJbXCJkZWZhdWx0XCJdLCBwcm9wcylcbiAgICApO1xuICB9O1xuXG4gIHJldHVybiBEYXRlVGFibGU7XG59KF9yZWFjdDJbXCJkZWZhdWx0XCJdLkNvbXBvbmVudCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gRGF0ZVRhYmxlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9idWlsZC9kYXRlL0RhdGVUYWJsZS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX0RhdGVDb25zdGFudHMgPSByZXF1aXJlKCcuL0RhdGVDb25zdGFudHMnKTtcblxudmFyIF9EYXRlQ29uc3RhbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RhdGVDb25zdGFudHMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgRGF0ZVRIZWFkID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKERhdGVUSGVhZCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gRGF0ZVRIZWFkKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEYXRlVEhlYWQpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihEYXRlVEhlYWQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKERhdGVUSGVhZCwgW3tcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gICAgICB2YXIgbG9jYWxlID0gcHJvcHMubG9jYWxlO1xuICAgICAgdmFyIHByZWZpeENscyA9IHByb3BzLnByZWZpeENscztcbiAgICAgIHZhciB2ZXJ5U2hvcnRXZWVrZGF5cyA9IFtdO1xuICAgICAgdmFyIHdlZWtEYXlzID0gW107XG4gICAgICB2YXIgZmlyc3REYXlPZldlZWsgPSB2YWx1ZS5nZXRGaXJzdERheU9mV2VlaygpO1xuICAgICAgdmFyIHNob3dXZWVrTnVtYmVyRWwgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGZvciAodmFyIGRhdGVDb2xJbmRleCA9IDA7IGRhdGVDb2xJbmRleCA8IF9EYXRlQ29uc3RhbnRzMltcImRlZmF1bHRcIl0uREFURV9DT0xfQ09VTlQ7IGRhdGVDb2xJbmRleCsrKSB7XG4gICAgICAgIHZhciBpbmRleCA9IChmaXJzdERheU9mV2VlayArIGRhdGVDb2xJbmRleCkgJSBfRGF0ZUNvbnN0YW50czJbXCJkZWZhdWx0XCJdLkRBVEVfQ09MX0NPVU5UO1xuICAgICAgICB2ZXJ5U2hvcnRXZWVrZGF5c1tkYXRlQ29sSW5kZXhdID0gbG9jYWxlLmZvcm1hdC52ZXJ5U2hvcnRXZWVrZGF5c1tpbmRleF07XG4gICAgICAgIHdlZWtEYXlzW2RhdGVDb2xJbmRleF0gPSBsb2NhbGUuZm9ybWF0LndlZWtkYXlzW2luZGV4XTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3BzLnNob3dXZWVrTnVtYmVyKSB7XG4gICAgICAgIHNob3dXZWVrTnVtYmVyRWwgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICd0aCcsXG4gICAgICAgICAge1xuICAgICAgICAgICAgcm9sZTogJ2NvbHVtbmhlYWRlcicsXG4gICAgICAgICAgICBjbGFzc05hbWU6IHByZWZpeENscyArICctY29sdW1uLWhlYWRlciAnICsgcHJlZml4Q2xzICsgJy13ZWVrLW51bWJlci1oZWFkZXInXG4gICAgICAgICAgfSxcbiAgICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctY29sdW1uLWhlYWRlci1pbm5lcicgfSxcbiAgICAgICAgICAgICd4J1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZhciB3ZWVrRGF5c0VscyA9IHdlZWtEYXlzLm1hcChmdW5jdGlvbiAoZGF5LCB4aW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ3RoJyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IHhpbmRleCxcbiAgICAgICAgICAgIHJvbGU6ICdjb2x1bW5oZWFkZXInLFxuICAgICAgICAgICAgdGl0bGU6IGRheSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1jb2x1bW4taGVhZGVyJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWNvbHVtbi1oZWFkZXItaW5uZXInIH0sXG4gICAgICAgICAgICB2ZXJ5U2hvcnRXZWVrZGF5c1t4aW5kZXhdXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ3RoZWFkJyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAndHInLFxuICAgICAgICAgIHsgcm9sZTogJ3JvdycgfSxcbiAgICAgICAgICBzaG93V2Vla051bWJlckVsLFxuICAgICAgICAgIHdlZWtEYXlzRWxzXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERhdGVUSGVhZDtcbn0oX3JlYWN0MltcImRlZmF1bHRcIl0uQ29tcG9uZW50KTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBEYXRlVEhlYWQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL2RhdGUvRGF0ZVRIZWFkLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHtcbiAgREFURV9ST1dfQ09VTlQ6IDYsXG4gIERBVEVfQ09MX0NPVU5UOiA3XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9kYXRlL0RhdGVDb25zdGFudHMuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9EYXRlQ29uc3RhbnRzID0gcmVxdWlyZSgncmMtY2FsZW5kYXIvbGliL2RhdGUvRGF0ZUNvbnN0YW50cycpO1xuXG52YXIgX0RhdGVDb25zdGFudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRGF0ZUNvbnN0YW50cyk7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoJ3JjLWNhbGVuZGFyL2xpYi91dGlsLycpO1xuXG52YXIgX2NsYXNzbmFtZXMyID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xuXG52YXIgX2NsYXNzbmFtZXMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NuYW1lczIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuLy8gY3VzdG9taXplZCByYy1jYWxlbmRhciBodHRwczovL2dpdGh1Yi5jb20vcmVhY3QtY29tcG9uZW50L2NhbGVuZGFyL2Jsb2IvbWFzdGVyL1xuXG5mdW5jdGlvbiBpc1NhbWVEYXkob25lLCB0d28pIHtcbiAgcmV0dXJuIG9uZSAmJiB0d28gJiYgb25lLmNvbXBhcmVUb0RheSh0d28pID09PSAwO1xufVxuXG5mdW5jdGlvbiBiZWZvcmVDdXJyZW50TW9udGhZZWFyKGN1cnJlbnQsIHRvZGF5KSB7XG4gIGlmIChjdXJyZW50LmdldFllYXIoKSA8IHRvZGF5LmdldFllYXIoKSkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiBjdXJyZW50LmdldFllYXIoKSA9PT0gdG9kYXkuZ2V0WWVhcigpICYmIGN1cnJlbnQuZ2V0TW9udGgoKSA8IHRvZGF5LmdldE1vbnRoKCk7XG59XG5cbmZ1bmN0aW9uIGFmdGVyQ3VycmVudE1vbnRoWWVhcihjdXJyZW50LCB0b2RheSkge1xuICBpZiAoY3VycmVudC5nZXRZZWFyKCkgPiB0b2RheS5nZXRZZWFyKCkpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gY3VycmVudC5nZXRZZWFyKCkgPT09IHRvZGF5LmdldFllYXIoKSAmJiBjdXJyZW50LmdldE1vbnRoKCkgPiB0b2RheS5nZXRNb250aCgpO1xufVxuXG5mdW5jdGlvbiBnZXRJZEZyb21EYXRlKGRhdGUpIHtcbiAgcmV0dXJuICdyYy1jYWxlbmRhci0nICsgZGF0ZS5nZXRZZWFyKCkgKyAnLScgKyBkYXRlLmdldE1vbnRoKCkgKyAnLScgKyBkYXRlLmdldERheU9mTW9udGgoKTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGhhbmRsZURheUNsaWNrKGN1cnJlbnQpIHtcbiAgdGhpcy5wcm9wcy5vblNlbGVjdChjdXJyZW50KTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlQ2VsbE1vdXNlRW50ZXIoY3VycmVudCkge1xuICB0aGlzLnByb3BzLm9uRGF5SG92ZXIoY3VycmVudCk7XG59XG5cbnZhciBEYXRlVEJvZHkgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnRGF0ZVRCb2R5JyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBjb250ZW50UmVuZGVyOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgZGF0ZVJlbmRlcjogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIGRpc2FibGVkRGF0ZTogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIHByZWZpeENsczogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgc2VsZWN0ZWRWYWx1ZTogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgdmFsdWU6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIHNob3dXZWVrTnVtYmVyOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2xcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb25EYXlIb3Zlcjogbm9vcFxuICAgIH07XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGNvbnRlbnRSZW5kZXIgPSBwcm9wcy5jb250ZW50UmVuZGVyO1xuICAgIHZhciBwcmVmaXhDbHMgPSBwcm9wcy5wcmVmaXhDbHM7XG4gICAgdmFyIHNlbGVjdGVkVmFsdWUgPSBwcm9wcy5zZWxlY3RlZFZhbHVlO1xuICAgIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuICAgIHZhciBzaG93V2Vla051bWJlciA9IHByb3BzLnNob3dXZWVrTnVtYmVyO1xuICAgIHZhciBkYXRlUmVuZGVyID0gcHJvcHMuZGF0ZVJlbmRlcjtcbiAgICB2YXIgZGlzYWJsZWREYXRlID0gcHJvcHMuZGlzYWJsZWREYXRlO1xuXG4gICAgdmFyIGlJbmRleCA9IHVuZGVmaW5lZDtcbiAgICB2YXIgakluZGV4ID0gdW5kZWZpbmVkO1xuICAgIHZhciBjdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgIHZhciBkYXRlVGFibGUgPSBbXTtcbiAgICB2YXIgdG9kYXkgPSB2YWx1ZS5jbG9uZSgpO1xuICAgIHZhciBjZWxsQ2xhc3MgPSBwcmVmaXhDbHMgKyAnLWNlbGwnO1xuICAgIHZhciB3ZWVrTnVtYmVyQ2VsbENsYXNzID0gcHJlZml4Q2xzICsgJy13ZWVrLW51bWJlci1jZWxsJztcbiAgICB2YXIgZGF0ZUNsYXNzID0gcHJlZml4Q2xzICsgJy1kYXRlJztcbiAgICB2YXIgdG9kYXlDbGFzcyA9IHByZWZpeENscyArICctdG9kYXknO1xuICAgIHZhciBzZWxlY3RlZENsYXNzID0gcHJlZml4Q2xzICsgJy1zZWxlY3RlZC1kYXknO1xuICAgIHZhciBpblJhbmdlQ2xhc3MgPSBwcmVmaXhDbHMgKyAnLWluLXJhbmdlLWNlbGwnO1xuICAgIHZhciBsYXN0TW9udGhEYXlDbGFzcyA9IHByZWZpeENscyArICctbGFzdC1tb250aC1jZWxsJztcbiAgICB2YXIgbmV4dE1vbnRoRGF5Q2xhc3MgPSBwcmVmaXhDbHMgKyAnLW5leHQtbW9udGgtYnRuLWRheSc7XG4gICAgdmFyIGRpc2FibGVkQ2xhc3MgPSBwcmVmaXhDbHMgKyAnLWRpc2FibGVkLWNlbGwnO1xuICAgIHZhciBmaXJzdERpc2FibGVDbGFzcyA9IHByZWZpeENscyArICctZGlzYWJsZWQtY2VsbC1maXJzdC1vZi1yb3cnO1xuICAgIHZhciBsYXN0RGlzYWJsZUNsYXNzID0gcHJlZml4Q2xzICsgJy1kaXNhYmxlZC1jZWxsLWxhc3Qtb2Ytcm93JztcbiAgICB0b2RheS5zZXRUaW1lKERhdGUubm93KCkpO1xuICAgIHZhciBtb250aDEgPSB2YWx1ZS5jbG9uZSgpO1xuICAgIG1vbnRoMS5zZXQodmFsdWUuZ2V0WWVhcigpLCB2YWx1ZS5nZXRNb250aCgpLCAxKTtcbiAgICB2YXIgZGF5ID0gbW9udGgxLmdldERheU9mV2VlaygpO1xuICAgIHZhciBsYXN0TW9udGhEaWZmRGF5ID0gKGRheSArIDcgLSB2YWx1ZS5nZXRGaXJzdERheU9mV2VlaygpKSAlIDc7XG4gICAgLy8gY2FsY3VsYXRlIGxhc3QgbW9udGhcbiAgICB2YXIgbGFzdE1vbnRoMSA9IG1vbnRoMS5jbG9uZSgpO1xuICAgIGxhc3RNb250aDEuYWRkRGF5T2ZNb250aCgwIC0gbGFzdE1vbnRoRGlmZkRheSk7XG4gICAgdmFyIHBhc3NlZCA9IDA7XG4gICAgZm9yIChpSW5kZXggPSAwOyBpSW5kZXggPCBfRGF0ZUNvbnN0YW50czJbXCJkZWZhdWx0XCJdLkRBVEVfUk9XX0NPVU5UOyBpSW5kZXgrKykge1xuICAgICAgZm9yIChqSW5kZXggPSAwOyBqSW5kZXggPCBfRGF0ZUNvbnN0YW50czJbXCJkZWZhdWx0XCJdLkRBVEVfQ09MX0NPVU5UOyBqSW5kZXgrKykge1xuICAgICAgICBjdXJyZW50ID0gbGFzdE1vbnRoMTtcbiAgICAgICAgaWYgKHBhc3NlZCkge1xuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmNsb25lKCk7XG4gICAgICAgICAgY3VycmVudC5hZGREYXlPZk1vbnRoKHBhc3NlZCk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0ZVRhYmxlLnB1c2goY3VycmVudCk7XG4gICAgICAgIHBhc3NlZCsrO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdGFibGVIdG1sID0gW107XG4gICAgcGFzc2VkID0gMDtcbiAgICBmb3IgKGlJbmRleCA9IDA7IGlJbmRleCA8IF9EYXRlQ29uc3RhbnRzMltcImRlZmF1bHRcIl0uREFURV9ST1dfQ09VTlQ7IGlJbmRleCsrKSB7XG4gICAgICB2YXIgd2Vla051bWJlckNlbGwgPSB1bmRlZmluZWQ7XG4gICAgICB2YXIgZGF0ZUNlbGxzID0gW107XG4gICAgICBpZiAoc2hvd1dlZWtOdW1iZXIpIHtcbiAgICAgICAgd2Vla051bWJlckNlbGwgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICd0ZCcsXG4gICAgICAgICAge1xuICAgICAgICAgICAga2V5OiBkYXRlVGFibGVbcGFzc2VkXS5nZXRXZWVrT2ZZZWFyKCksXG4gICAgICAgICAgICByb2xlOiAnZ3JpZGNlbGwnLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiB3ZWVrTnVtYmVyQ2VsbENsYXNzXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkYXRlVGFibGVbcGFzc2VkXS5nZXRXZWVrT2ZZZWFyKClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGZvciAoakluZGV4ID0gMDsgakluZGV4IDwgX0RhdGVDb25zdGFudHMyW1wiZGVmYXVsdFwiXS5EQVRFX0NPTF9DT1VOVDsgakluZGV4KyspIHtcbiAgICAgICAgdmFyIG5leHQgPSBudWxsO1xuICAgICAgICB2YXIgbGFzdCA9IG51bGw7XG4gICAgICAgIGN1cnJlbnQgPSBkYXRlVGFibGVbcGFzc2VkXTtcbiAgICAgICAgaWYgKGpJbmRleCA8IF9EYXRlQ29uc3RhbnRzMltcImRlZmF1bHRcIl0uREFURV9DT0xfQ09VTlQgLSAxKSB7XG4gICAgICAgICAgbmV4dCA9IGRhdGVUYWJsZVtwYXNzZWQgKyAxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoakluZGV4ID4gMCkge1xuICAgICAgICAgIGxhc3QgPSBkYXRlVGFibGVbcGFzc2VkIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNscyA9IGNlbGxDbGFzcztcbiAgICAgICAgdmFyIGRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBzZWxlY3RlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChpc1NhbWVEYXkoY3VycmVudCwgdG9kYXkpKSB7XG4gICAgICAgICAgY2xzICs9ICcgJyArIHRvZGF5Q2xhc3M7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXNCZWZvcmVDdXJyZW50TW9udGhZZWFyID0gYmVmb3JlQ3VycmVudE1vbnRoWWVhcihjdXJyZW50LCB2YWx1ZSk7XG4gICAgICAgIHZhciBpc0FmdGVyQ3VycmVudE1vbnRoWWVhciA9IGFmdGVyQ3VycmVudE1vbnRoWWVhcihjdXJyZW50LCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKHNlbGVjdGVkVmFsdWUgJiYgQXJyYXkuaXNBcnJheShzZWxlY3RlZFZhbHVlKSkge1xuICAgICAgICAgIGlmICghaXNCZWZvcmVDdXJyZW50TW9udGhZZWFyICYmICFpc0FmdGVyQ3VycmVudE1vbnRoWWVhcikge1xuICAgICAgICAgICAgdmFyIHN0YXJ0VmFsdWUgPSBzZWxlY3RlZFZhbHVlWzBdO1xuICAgICAgICAgICAgdmFyIGVuZFZhbHVlID0gc2VsZWN0ZWRWYWx1ZVsxXTtcbiAgICAgICAgICAgIGlmIChzdGFydFZhbHVlKSB7XG4gICAgICAgICAgICAgIGlmIChpc1NhbWVEYXkoY3VycmVudCwgc3RhcnRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFydFZhbHVlICYmIGVuZFZhbHVlKSB7XG4gICAgICAgICAgICAgIGlmIChpc1NhbWVEYXkoY3VycmVudCwgZW5kVmFsdWUpICYmICFzZWxlY3RlZFZhbHVlLmhvdmVyaW5nKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnQuY29tcGFyZVRvRGF5KHN0YXJ0VmFsdWUpID4gMCAmJiBjdXJyZW50LmNvbXBhcmVUb0RheShlbmRWYWx1ZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgY2xzICs9ICcgJyArIGluUmFuZ2VDbGFzcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc1NhbWVEYXkoY3VycmVudCwgc2VsZWN0ZWRWYWx1ZSkpIHtcbiAgICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQmVmb3JlQ3VycmVudE1vbnRoWWVhcikge1xuICAgICAgICAgIGNscyArPSAnICcgKyBsYXN0TW9udGhEYXlDbGFzcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBZnRlckN1cnJlbnRNb250aFllYXIpIHtcbiAgICAgICAgICBjbHMgKz0gJyAnICsgbmV4dE1vbnRoRGF5Q2xhc3M7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGlzYWJsZWREYXRlKSB7XG4gICAgICAgICAgaWYgKGRpc2FibGVkRGF0ZShjdXJyZW50LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIGRpc2FibGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKCFsYXN0IHx8ICFkaXNhYmxlZERhdGUobGFzdCwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgIGNscyArPSAnICcgKyBmaXJzdERpc2FibGVDbGFzcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFuZXh0IHx8ICFkaXNhYmxlZERhdGUobmV4dCwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgIGNscyArPSAnICcgKyBsYXN0RGlzYWJsZUNsYXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgIGNscyArPSAnICcgKyBzZWxlY3RlZENsYXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgICAgY2xzICs9ICcgJyArIGRpc2FibGVkQ2xhc3M7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0ZUh0bWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChkYXRlUmVuZGVyKSB7XG4gICAgICAgICAgZGF0ZUh0bWwgPSBkYXRlUmVuZGVyKGN1cnJlbnQsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2NsYXNzbmFtZXM7XG5cbiAgICAgICAgICB2YXIgY29udGVudCA9IGNvbnRlbnRSZW5kZXIgPyBjb250ZW50UmVuZGVyKGN1cnJlbnQsIHZhbHVlKSA6IGN1cnJlbnQuZ2V0RGF5T2ZNb250aCgpO1xuICAgICAgICAgIHZhciBkYXlPZldlZWsgPSBjdXJyZW50LmdldERheU9mV2VlaygpO1xuICAgICAgICAgIGRhdGVIdG1sID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBrZXk6IGdldElkRnJvbURhdGUoY3VycmVudCksXG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogKDAsIF9jbGFzc25hbWVzM1tcImRlZmF1bHRcIl0pKChfY2xhc3NuYW1lcyA9IHt9LCBfY2xhc3NuYW1lc1tkYXRlQ2xhc3NdID0gdHJ1ZSwgX2NsYXNzbmFtZXMud2Vla2VuZCA9IGRheU9mV2VlayA9PSAwIHx8IGRheU9mV2VlayA9PSA2LCBfY2xhc3NuYW1lcykpLFxuICAgICAgICAgICAgICAnYXJpYS1zZWxlY3RlZCc6IHNlbGVjdGVkLFxuICAgICAgICAgICAgICAnYXJpYS1kaXNhYmxlZCc6IGRpc2FibGVkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udGVudFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRlQ2VsbHMucHVzaChfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICd0ZCcsXG4gICAgICAgICAge1xuICAgICAgICAgICAga2V5OiBwYXNzZWQsXG4gICAgICAgICAgICBvbkNsaWNrOiBkaXNhYmxlZCA/IG5vb3AgOiBoYW5kbGVEYXlDbGljay5iaW5kKHRoaXMsIGN1cnJlbnQpLFxuICAgICAgICAgICAgb25Nb3VzZUVudGVyOiBkaXNhYmxlZCA/IG5vb3AgOiBoYW5kbGVDZWxsTW91c2VFbnRlci5iaW5kKHRoaXMsIGN1cnJlbnQpLFxuICAgICAgICAgICAgcm9sZTogJ2dyaWRjZWxsJyxcbiAgICAgICAgICAgIHRpdGxlOiAoMCwgX3V0aWwuZ2V0VGl0bGVTdHJpbmcpKGN1cnJlbnQpLCBjbGFzc05hbWU6IGNsc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZGF0ZUh0bWxcbiAgICAgICAgKSk7XG5cbiAgICAgICAgcGFzc2VkKys7XG4gICAgICB9XG4gICAgICB0YWJsZUh0bWwucHVzaChfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAndHInLFxuICAgICAgICB7XG4gICAgICAgICAga2V5OiBpSW5kZXgsXG4gICAgICAgICAgcm9sZTogJ3JvdydcbiAgICAgICAgfSxcbiAgICAgICAgd2Vla051bWJlckNlbGwsXG4gICAgICAgIGRhdGVDZWxsc1xuICAgICAgKSk7XG4gICAgfVxuICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgJ3Rib2R5JyxcbiAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAndGJvZHknIH0sXG4gICAgICB0YWJsZUh0bWxcbiAgICApO1xuICB9XG59KTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBEYXRlVEJvZHk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL2J1aWxkL2RhdGUvRGF0ZVRCb2R5LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzLmdldFRvZGF5VGltZSA9IGdldFRvZGF5VGltZTtcbmV4cG9ydHMuZ2V0VGl0bGVTdHJpbmcgPSBnZXRUaXRsZVN0cmluZztcbmV4cG9ydHMuZ2V0VG9kYXlUaW1lU3RyID0gZ2V0VG9kYXlUaW1lU3RyO1xuZXhwb3J0cy5nZXRGb3JtYXR0ZXIgPSBnZXRGb3JtYXR0ZXI7XG5leHBvcnRzLnN5bmNUaW1lID0gc3luY1RpbWU7XG5leHBvcnRzLmdldFRpbWVDb25maWcgPSBnZXRUaW1lQ29uZmlnO1xuZXhwb3J0cy5pc1RpbWVWYWxpZEJ5Q29uZmlnID0gaXNUaW1lVmFsaWRCeUNvbmZpZztcbmV4cG9ydHMuaXNUaW1lVmFsaWQgPSBpc1RpbWVWYWxpZDtcbmV4cG9ydHMuaXNBbGxvd2VkRGF0ZSA9IGlzQWxsb3dlZERhdGU7XG5cbnZhciBfZ3JlZ29yaWFuQ2FsZW5kYXJGb3JtYXQgPSByZXF1aXJlKCdncmVnb3JpYW4tY2FsZW5kYXItZm9ybWF0Jyk7XG5cbnZhciBfZ3JlZ29yaWFuQ2FsZW5kYXJGb3JtYXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ3JlZ29yaWFuQ2FsZW5kYXJGb3JtYXQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxudmFyIGRlZmF1bHREaXNhYmxlZFRpbWUgPSB7XG4gIGRpc2FibGVkSG91cnM6IGZ1bmN0aW9uIGRpc2FibGVkSG91cnMoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9LFxuICBkaXNhYmxlZE1pbnV0ZXM6IGZ1bmN0aW9uIGRpc2FibGVkTWludXRlcygpIHtcbiAgICByZXR1cm4gW107XG4gIH0sXG4gIGRpc2FibGVkU2Vjb25kczogZnVuY3Rpb24gZGlzYWJsZWRTZWNvbmRzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0VG9kYXlUaW1lKHZhbHVlKSB7XG4gIHZhciB0b2RheSA9IHZhbHVlLmNsb25lKCk7XG4gIHRvZGF5LnNldFRpbWUoRGF0ZS5ub3coKSk7XG4gIHJldHVybiB0b2RheTtcbn1cblxuZnVuY3Rpb24gZ2V0VGl0bGVTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLmdldFllYXIoKSArICctJyArICh2YWx1ZS5nZXRNb250aCgpICsgMSkgKyAnLScgKyB2YWx1ZS5nZXREYXlPZk1vbnRoKCk7XG59XG5cbmZ1bmN0aW9uIGdldFRvZGF5VGltZVN0cih2YWx1ZSkge1xuICB2YXIgdG9kYXkgPSBnZXRUb2RheVRpbWUodmFsdWUpO1xuICByZXR1cm4gZ2V0VGl0bGVTdHJpbmcodG9kYXkpO1xufVxuXG5mdW5jdGlvbiBnZXRGb3JtYXR0ZXIoZm9ybWF0LCBsb2NhbGUpIHtcbiAgaWYgKHR5cGVvZiBmb3JtYXQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG5ldyBfZ3JlZ29yaWFuQ2FsZW5kYXJGb3JtYXQyW1wiZGVmYXVsdFwiXShmb3JtYXQsIGxvY2FsZS5mb3JtYXQpO1xuICB9XG4gIHJldHVybiBmb3JtYXQ7XG59XG5cbmZ1bmN0aW9uIHN5bmNUaW1lKGZyb20sIHRvKSB7XG4gIHRvLnNldEhvdXJPZkRheShmcm9tLmdldEhvdXJPZkRheSgpKTtcbiAgdG8uc2V0TWludXRlcyhmcm9tLmdldE1pbnV0ZXMoKSk7XG4gIHRvLnNldFNlY29uZHMoZnJvbS5nZXRTZWNvbmRzKCkpO1xufVxuXG5mdW5jdGlvbiBnZXRUaW1lQ29uZmlnKHZhbHVlLCBkaXNhYmxlZFRpbWUpIHtcbiAgdmFyIGRpc2FibGVkVGltZUNvbmZpZyA9IGRpc2FibGVkVGltZSA/IGRpc2FibGVkVGltZSh2YWx1ZSkgOiB7fTtcbiAgZGlzYWJsZWRUaW1lQ29uZmlnID0gX2V4dGVuZHMoe30sIGRlZmF1bHREaXNhYmxlZFRpbWUsIGRpc2FibGVkVGltZUNvbmZpZyk7XG4gIHJldHVybiBkaXNhYmxlZFRpbWVDb25maWc7XG59XG5cbmZ1bmN0aW9uIGlzVGltZVZhbGlkQnlDb25maWcodmFsdWUsIGRpc2FibGVkVGltZUNvbmZpZykge1xuICB2YXIgaW52YWxpZFRpbWUgPSBmYWxzZTtcbiAgaWYgKHZhbHVlKSB7XG4gICAgdmFyIGhvdXIgPSB2YWx1ZS5nZXRIb3VyT2ZEYXkoKTtcbiAgICB2YXIgbWludXRlcyA9IHZhbHVlLmdldE1pbnV0ZXMoKTtcbiAgICB2YXIgc2Vjb25kcyA9IHZhbHVlLmdldFNlY29uZHMoKTtcbiAgICB2YXIgZGlzYWJsZWRIb3VycyA9IGRpc2FibGVkVGltZUNvbmZpZy5kaXNhYmxlZEhvdXJzKCk7XG4gICAgaWYgKGRpc2FibGVkSG91cnMuaW5kZXhPZihob3VyKSA9PT0gLTEpIHtcbiAgICAgIHZhciBkaXNhYmxlZE1pbnV0ZXMgPSBkaXNhYmxlZFRpbWVDb25maWcuZGlzYWJsZWRNaW51dGVzKGhvdXIpO1xuICAgICAgaWYgKGRpc2FibGVkTWludXRlcy5pbmRleE9mKG1pbnV0ZXMpID09PSAtMSkge1xuICAgICAgICB2YXIgZGlzYWJsZWRTZWNvbmRzID0gZGlzYWJsZWRUaW1lQ29uZmlnLmRpc2FibGVkU2Vjb25kcyhob3VyLCBtaW51dGVzKTtcbiAgICAgICAgaW52YWxpZFRpbWUgPSBkaXNhYmxlZFNlY29uZHMuaW5kZXhPZihzZWNvbmRzKSAhPT0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZhbGlkVGltZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFsaWRUaW1lID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICFpbnZhbGlkVGltZTtcbn1cblxuZnVuY3Rpb24gaXNUaW1lVmFsaWQodmFsdWUsIGRpc2FibGVkVGltZSkge1xuICB2YXIgZGlzYWJsZWRUaW1lQ29uZmlnID0gZ2V0VGltZUNvbmZpZyh2YWx1ZSwgZGlzYWJsZWRUaW1lKTtcbiAgcmV0dXJuIGlzVGltZVZhbGlkQnlDb25maWcodmFsdWUsIGRpc2FibGVkVGltZUNvbmZpZyk7XG59XG5cbmZ1bmN0aW9uIGlzQWxsb3dlZERhdGUodmFsdWUsIGRpc2FibGVkRGF0ZSwgZGlzYWJsZWRUaW1lKSB7XG4gIGlmIChkaXNhYmxlZERhdGUpIHtcbiAgICBpZiAoZGlzYWJsZWREYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoZGlzYWJsZWRUaW1lKSB7XG4gICAgaWYgKCFpc1RpbWVWYWxpZCh2YWx1ZSwgZGlzYWJsZWRUaW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL3V0aWwvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBlcmFzOiBbJ0JDJywgJ0FEJ10sXG4gIG1vbnRoczogWydKYW51YXJ5JywgJ0ZlYnJ1YXJ5JywgJ01hcmNoJywgJ0FwcmlsJywgJ01heScsICdKdW5lJywgJ0p1bHknLCAnQXVndXN0JywgJ1NlcHRlbWJlcicsICdPY3RvYmVyJywgJ05vdmVtYmVyJywgJ0RlY2VtYmVyJ10sXG4gIHNob3J0TW9udGhzOiBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJ10sXG4gIHdlZWtkYXlzOiBbJ1N1bmRheScsICdNb25kYXknLCAnVHVlc2RheScsICdXZWRuZXNkYXknLCAnVGh1cnNkYXknLCAnRnJpZGF5JywgJ1NhdHVyZGF5J10sXG4gIHNob3J0V2Vla2RheXM6IFsnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0J10sXG4gIHZlcnlTaG9ydFdlZWtkYXlzOiBbJ1N1JywgJ01vJywgJ1R1JywgJ1dlJywgJ1RoJywgJ0ZyJywgJ1NhJ10sXG4gIGFtcG1zOiBbJ0FNJywgJ1BNJ10sXG4gIGRhdGVQYXR0ZXJuczogWydFRUVFLCBNTU1NIGQsIHl5eXknLCAnTU1NTSBkLCB5eXl5JywgJ01NTSBkLCB5eXl5JywgJ00vZC95eSddLFxuICB0aW1lUGF0dGVybnM6IFsnaDptbTpzcyBhIFxcJ0dNVFxcJ1onLCAnaDptbTpzcyBhJywgJ2g6bW06c3MgYScsICdoOm1tIGEnXSxcbiAgZGF0ZVRpbWVQYXR0ZXJuOiAne2RhdGV9IHt0aW1lfSdcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L2dyZWdvcmlhbi1jYWxlbmRhci1mb3JtYXQvbGliL2xvY2FsZS9lbl9VUy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB3YXJuaW5nID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGFyZ3MpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiA+IDIgPyBsZW4gLSAyIDogMCk7XG4gICAgZm9yICh2YXIga2V5ID0gMjsga2V5IDwgbGVuOyBrZXkrKykge1xuICAgICAgYXJnc1trZXkgLSAyXSA9IGFyZ3VtZW50c1trZXldO1xuICAgIH1cbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgK1xuICAgICAgICAnbWVzc2FnZSBhcmd1bWVudCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdC5sZW5ndGggPCAxMCB8fCAoL15bc1xcV10qJC8pLnRlc3QoZm9ybWF0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVGhlIHdhcm5pbmcgZm9ybWF0IHNob3VsZCBiZSBhYmxlIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgJyArXG4gICAgICAgICd3YXJuaW5nLiBQbGVhc2UsIHVzZSBhIG1vcmUgZGVzY3JpcHRpdmUgZm9ybWF0IHRoYW46ICcgKyBmb3JtYXRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICtcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfSBjYXRjaCh4KSB7fVxuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L2dyZWdvcmlhbi1jYWxlbmRhci1mb3JtYXQvfi93YXJuaW5nL2Jyb3dzZXIuanNcbiAqKi8iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spL34vbm9kZS1saWJzLWJyb3dzZXIvfi9wcm9jZXNzL2Jyb3dzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA0NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfTW9udGhQYW5lbCA9IHJlcXVpcmUoJy4uL21vbnRoL01vbnRoUGFuZWwnKTtcblxudmFyIF9Nb250aFBhbmVsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01vbnRoUGFuZWwpO1xuXG52YXIgX2luZGV4ID0gcmVxdWlyZSgnLi4vdXRpbC9pbmRleCcpO1xuXG52YXIgX1llYXJQYW5lbCA9IHJlcXVpcmUoJy4uL3llYXIvWWVhclBhbmVsJyk7XG5cbnZhciBfWWVhclBhbmVsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1llYXJQYW5lbCk7XG5cbnZhciBfcmNVdGlsID0gcmVxdWlyZSgncmMtdXRpbCcpO1xuXG52YXIgX3JjVXRpbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yY1V0aWwpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxudmFyIHRvRnJhZ21lbnQgPSBfcmNVdGlsMltcImRlZmF1bHRcIl0uQ2hpbGRyZW4ubWFwU2VsZjtcblxuZnVuY3Rpb24gZ29Nb250aChkaXJlY3Rpb24pIHtcbiAgdmFyIG5leHQgPSB0aGlzLnByb3BzLnZhbHVlLmNsb25lKCk7XG4gIG5leHQuYWRkTW9udGgoZGlyZWN0aW9uKTtcbiAgdGhpcy5wcm9wcy5vblZhbHVlQ2hhbmdlKG5leHQpO1xufVxuXG5mdW5jdGlvbiBnb1llYXIoZGlyZWN0aW9uKSB7XG4gIHZhciBuZXh0ID0gdGhpcy5wcm9wcy52YWx1ZS5jbG9uZSgpO1xuICBuZXh0LmFkZFllYXIoZGlyZWN0aW9uKTtcbiAgdGhpcy5wcm9wcy5vblZhbHVlQ2hhbmdlKG5leHQpO1xufVxuXG52YXIgQ2FsZW5kYXJIZWFkZXIgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnQ2FsZW5kYXJIZWFkZXInLFxuXG4gIHByb3BUeXBlczoge1xuICAgIGVuYWJsZVByZXY6IF9yZWFjdC5Qcm9wVHlwZXMuYW55LFxuICAgIGVuYWJsZU5leHQ6IF9yZWFjdC5Qcm9wVHlwZXMuYW55LFxuICAgIHByZWZpeENsczogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgbG9jYWxlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICB2YWx1ZTogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgb25WYWx1ZUNoYW5nZTogX3JlYWN0LlByb3BUeXBlcy5mdW5jXG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiBnZXREZWZhdWx0UHJvcHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVuYWJsZU5leHQ6IDEsXG4gICAgICBlbmFibGVQcmV2OiAxXG4gICAgfTtcbiAgfSxcbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB0aGlzLnllYXJGb3JtYXR0ZXIgPSAoMCwgX2luZGV4LmdldEZvcm1hdHRlcikocHJvcHMubG9jYWxlLnllYXJGb3JtYXQsIHByb3BzLmxvY2FsZSk7XG4gICAgdGhpcy5tb250aEZvcm1hdHRlciA9ICgwLCBfaW5kZXguZ2V0Rm9ybWF0dGVyKShwcm9wcy5sb2NhbGUubW9udGhGb3JtYXQsIHByb3BzLmxvY2FsZSk7XG4gICAgdGhpcy5uZXh0TW9udGggPSBnb01vbnRoLmJpbmQodGhpcywgMSk7XG4gICAgdGhpcy5wcmV2aW91c01vbnRoID0gZ29Nb250aC5iaW5kKHRoaXMsIC0xKTtcbiAgICB0aGlzLm5leHRZZWFyID0gZ29ZZWFyLmJpbmQodGhpcywgMSk7XG4gICAgdGhpcy5wcmV2aW91c1llYXIgPSBnb1llYXIuYmluZCh0aGlzLCAtMSk7XG4gICAgcmV0dXJuIHt9O1xuICB9LFxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIHZhciBsb2NhbGUgPSB0aGlzLnByb3BzLmxvY2FsZTtcbiAgICB2YXIgbmV4dExvY2FsZSA9IG5leHRQcm9wcy5sb2NhbGU7XG5cbiAgICBpZiAobmV4dExvY2FsZSAhPT0gbG9jYWxlKSB7XG4gICAgICB0aGlzLnllYXJGb3JtYXR0ZXIgPSAoMCwgX2luZGV4LmdldEZvcm1hdHRlcikobmV4dExvY2FsZS55ZWFyRm9ybWF0LCBuZXh0TG9jYWxlKTtcbiAgICAgIHRoaXMubW9udGhGb3JtYXR0ZXIgPSAoMCwgX2luZGV4LmdldEZvcm1hdHRlcikobmV4dExvY2FsZS5tb250aEZvcm1hdCwgbmV4dExvY2FsZSk7XG4gICAgfVxuICB9LFxuICBvblNlbGVjdDogZnVuY3Rpb24gb25TZWxlY3QodmFsdWUpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHNob3dNb250aFBhbmVsOiAwLFxuICAgICAgc2hvd1llYXJQYW5lbDogMFxuICAgIH0pO1xuICAgIHRoaXMucHJvcHMub25WYWx1ZUNoYW5nZSh2YWx1ZSk7XG4gIH0sXG4gIGdldE1vbnRoWWVhckVsZW1lbnQ6IGZ1bmN0aW9uIGdldE1vbnRoWWVhckVsZW1lbnQoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcHJlZml4Q2xzID0gcHJvcHMucHJlZml4Q2xzO1xuICAgIHZhciBsb2NhbGUgPSBwcm9wcy5sb2NhbGU7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5wcm9wcy52YWx1ZTtcbiAgICB2YXIgbW9udGhCZWZvcmVZZWFyID0gbG9jYWxlLm1vbnRoQmVmb3JlWWVhcjtcbiAgICB2YXIgc2VsZWN0Q2xhc3NOYW1lID0gcHJlZml4Q2xzICsgJy0nICsgKG1vbnRoQmVmb3JlWWVhciA/ICdteS1zZWxlY3QnIDogJ3ltLXNlbGVjdCcpO1xuICAgIHZhciB5ZWFyID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICdhJyxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLXllYXItc2VsZWN0JyxcbiAgICAgICAgcm9sZTogJ2J1dHRvbicsXG4gICAgICAgIG9uQ2xpY2s6IHRoaXMuc2hvd1llYXJQYW5lbCxcbiAgICAgICAgdGl0bGU6IGxvY2FsZS5tb250aFNlbGVjdFxuICAgICAgfSxcbiAgICAgIHRoaXMueWVhckZvcm1hdHRlci5mb3JtYXQodmFsdWUpXG4gICAgKTtcbiAgICB2YXIgbW9udGggPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgJ2EnLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6IHByZWZpeENscyArICctbW9udGgtc2VsZWN0JyxcbiAgICAgICAgcm9sZTogJ2J1dHRvbicsXG4gICAgICAgIG9uQ2xpY2s6IHRoaXMuc2hvd01vbnRoUGFuZWwsXG4gICAgICAgIHRpdGxlOiBsb2NhbGUubW9udGhTZWxlY3RcbiAgICAgIH0sXG4gICAgICB0aGlzLm1vbnRoRm9ybWF0dGVyLmZvcm1hdCh2YWx1ZSlcbiAgICApO1xuICAgIHZhciBteSA9IFtdO1xuICAgIGlmIChtb250aEJlZm9yZVllYXIpIHtcbiAgICAgIG15ID0gW21vbnRoLCB5ZWFyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbXkgPSBbeWVhciwgbW9udGhdO1xuICAgIH1cbiAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICdzcGFuJyxcbiAgICAgIHsgY2xhc3NOYW1lOiBzZWxlY3RDbGFzc05hbWUgfSxcbiAgICAgIHRvRnJhZ21lbnQobXkpXG4gICAgKTtcbiAgfSxcbiAgc2hvd0lmOiBmdW5jdGlvbiBzaG93SWYoY29uZGl0aW9uLCBlbCkge1xuICAgIHJldHVybiBjb25kaXRpb24gPyBlbCA6IG51bGw7XG4gIH0sXG4gIHNob3dNb250aFBhbmVsOiBmdW5jdGlvbiBzaG93TW9udGhQYW5lbCgpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHNob3dNb250aFBhbmVsOiAxLFxuICAgICAgc2hvd1llYXJQYW5lbDogMFxuICAgIH0pO1xuICB9LFxuICBzaG93WWVhclBhbmVsOiBmdW5jdGlvbiBzaG93WWVhclBhbmVsKCkge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgc2hvd01vbnRoUGFuZWw6IDAsXG4gICAgICBzaG93WWVhclBhbmVsOiAxXG4gICAgfSk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGVuYWJsZU5leHQgPSBwcm9wcy5lbmFibGVOZXh0O1xuICAgIHZhciBlbmFibGVQcmV2ID0gcHJvcHMuZW5hYmxlUHJldjtcbiAgICB2YXIgcHJlZml4Q2xzID0gcHJvcHMucHJlZml4Q2xzO1xuICAgIHZhciBsb2NhbGUgPSBwcm9wcy5sb2NhbGU7XG4gICAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG5cbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHZhciBQYW5lbENsYXNzID0gbnVsbDtcbiAgICBpZiAoc3RhdGUuc2hvd01vbnRoUGFuZWwpIHtcbiAgICAgIFBhbmVsQ2xhc3MgPSBfTW9udGhQYW5lbDJbXCJkZWZhdWx0XCJdO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuc2hvd1llYXJQYW5lbCkge1xuICAgICAgUGFuZWxDbGFzcyA9IF9ZZWFyUGFuZWwyW1wiZGVmYXVsdFwiXTtcbiAgICB9XG4gICAgdmFyIHBhbmVsID0gdW5kZWZpbmVkO1xuICAgIGlmIChQYW5lbENsYXNzKSB7XG4gICAgICBwYW5lbCA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoUGFuZWxDbGFzcywge1xuICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB2YWx1ZSxcbiAgICAgICAgcm9vdFByZWZpeENsczogcHJlZml4Q2xzLFxuICAgICAgICBvblNlbGVjdDogdGhpcy5vblNlbGVjdFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgJ2RpdicsXG4gICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1oZWFkZXInIH0sXG4gICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgeyBzdHlsZTogeyBwb3NpdGlvbjogJ3JlbGF0aXZlJyB9IH0sXG4gICAgICAgIHRoaXMuc2hvd0lmKGVuYWJsZVByZXYsIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ2EnLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1wcmV2LXllYXItYnRuJyxcbiAgICAgICAgICAgIHJvbGU6ICdidXR0b24nLFxuICAgICAgICAgICAgb25DbGljazogdGhpcy5wcmV2aW91c1llYXIsXG4gICAgICAgICAgICB0aXRsZTogbG9jYWxlLnByZXZpb3VzWWVhclxuICAgICAgICAgIH0sXG4gICAgICAgICAgJ8KrJ1xuICAgICAgICApKSxcbiAgICAgICAgdGhpcy5zaG93SWYoZW5hYmxlUHJldiwgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnYScsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLXByZXYtbW9udGgtYnRuJyxcbiAgICAgICAgICAgIHJvbGU6ICdidXR0b24nLFxuICAgICAgICAgICAgb25DbGljazogdGhpcy5wcmV2aW91c01vbnRoLFxuICAgICAgICAgICAgdGl0bGU6IGxvY2FsZS5wcmV2aW91c01vbnRoXG4gICAgICAgICAgfSxcbiAgICAgICAgICAn4oC5J1xuICAgICAgICApKSxcbiAgICAgICAgdGhpcy5nZXRNb250aFllYXJFbGVtZW50KCksXG4gICAgICAgIHRoaXMuc2hvd0lmKGVuYWJsZU5leHQsIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ2EnLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1uZXh0LW1vbnRoLWJ0bicsXG4gICAgICAgICAgICBvbkNsaWNrOiB0aGlzLm5leHRNb250aCxcbiAgICAgICAgICAgIHRpdGxlOiBsb2NhbGUubmV4dE1vbnRoXG4gICAgICAgICAgfSxcbiAgICAgICAgICAn4oC6J1xuICAgICAgICApKSxcbiAgICAgICAgdGhpcy5zaG93SWYoZW5hYmxlTmV4dCwgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnYScsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLW5leHQteWVhci1idG4nLFxuICAgICAgICAgICAgb25DbGljazogdGhpcy5uZXh0WWVhcixcbiAgICAgICAgICAgIHRpdGxlOiBsb2NhbGUubmV4dFllYXJcbiAgICAgICAgICB9LFxuICAgICAgICAgICfCuydcbiAgICAgICAgKSlcbiAgICAgICksXG4gICAgICBwYW5lbFxuICAgICk7XG4gIH1cbn0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IENhbGVuZGFySGVhZGVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9jYWxlbmRhci9DYWxlbmRhckhlYWRlci5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX1llYXJQYW5lbCA9IHJlcXVpcmUoJy4uL3llYXIvWWVhclBhbmVsJyk7XG5cbnZhciBfWWVhclBhbmVsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1llYXJQYW5lbCk7XG5cbnZhciBfTW9udGhUYWJsZSA9IHJlcXVpcmUoJy4vTW9udGhUYWJsZScpO1xuXG52YXIgX01vbnRoVGFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTW9udGhUYWJsZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBnb1llYXIoZGlyZWN0aW9uKSB7XG4gIHZhciBuZXh0ID0gdGhpcy5zdGF0ZS52YWx1ZS5jbG9uZSgpO1xuICBuZXh0LmFkZFllYXIoZGlyZWN0aW9uKTtcbiAgdGhpcy5zZXRBbmRDaGFuZ2VWYWx1ZShuZXh0KTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBNb250aFBhbmVsID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ01vbnRoUGFuZWwnLFxuXG4gIHByb3BUeXBlczoge1xuICAgIG9uQ2hhbmdlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgZGlzYWJsZWREYXRlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25TZWxlY3Q6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuY1xuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvbkNoYW5nZTogbm9vcCxcbiAgICAgIG9uU2VsZWN0OiBub29wXG4gICAgfTtcbiAgfSxcbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAvLyBiaW5kIG1ldGhvZHNcbiAgICB0aGlzLm5leHRZZWFyID0gZ29ZZWFyLmJpbmQodGhpcywgMSk7XG4gICAgdGhpcy5wcmV2aW91c1llYXIgPSBnb1llYXIuYmluZCh0aGlzLCAtMSk7XG4gICAgdGhpcy5wcmVmaXhDbHMgPSBwcm9wcy5yb290UHJlZml4Q2xzICsgJy1tb250aC1wYW5lbCc7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBwcm9wcy52YWx1ZSB8fCBwcm9wcy5kZWZhdWx0VmFsdWVcbiAgICB9O1xuICB9LFxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIGlmICgndmFsdWUnIGluIG5leHRQcm9wcykge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHZhbHVlOiBuZXh0UHJvcHMudmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgb25ZZWFyUGFuZWxTZWxlY3Q6IGZ1bmN0aW9uIG9uWWVhclBhbmVsU2VsZWN0KGN1cnJlbnQpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHNob3dZZWFyUGFuZWw6IDBcbiAgICB9KTtcbiAgICB0aGlzLnNldEFuZENoYW5nZVZhbHVlKGN1cnJlbnQpO1xuICB9LFxuICBzZXRBbmRDaGFuZ2VWYWx1ZTogZnVuY3Rpb24gc2V0QW5kQ2hhbmdlVmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLnNldFZhbHVlKHZhbHVlKTtcbiAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHZhbHVlKTtcbiAgfSxcbiAgc2V0QW5kU2VsZWN0VmFsdWU6IGZ1bmN0aW9uIHNldEFuZFNlbGVjdFZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgdGhpcy5wcm9wcy5vblNlbGVjdCh2YWx1ZSk7XG4gIH0sXG4gIHNldFZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICghKCd2YWx1ZScgaW4gdGhpcy5wcm9wcykpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgc2hvd1llYXJQYW5lbDogZnVuY3Rpb24gc2hvd1llYXJQYW5lbCgpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHNob3dZZWFyUGFuZWw6IDFcbiAgICB9KTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgIHZhciBsb2NhbGUgPSBwcm9wcy5sb2NhbGU7XG4gICAgdmFyIHllYXIgPSB2YWx1ZS5nZXRZZWFyKCk7XG4gICAgdmFyIHByZWZpeENscyA9IHRoaXMucHJlZml4Q2xzO1xuICAgIHZhciB5ZWFyUGFuZWwgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHRoaXMuc3RhdGUuc2hvd1llYXJQYW5lbCkge1xuICAgICAgeWVhclBhbmVsID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfWWVhclBhbmVsMltcImRlZmF1bHRcIl0sIHtcbiAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgcm9vdFByZWZpeENsczogcHJvcHMucm9vdFByZWZpeENscyxcbiAgICAgICAgb25TZWxlY3Q6IHRoaXMub25ZZWFyUGFuZWxTZWxlY3RcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICdkaXYnLFxuICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscywgc3R5bGU6IHByb3BzLnN0eWxlIH0sXG4gICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1oZWFkZXInIH0sXG4gICAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLXByZXYteWVhci1idG4nLFxuICAgICAgICAgICAgICByb2xlOiAnYnV0dG9uJyxcbiAgICAgICAgICAgICAgb25DbGljazogdGhpcy5wcmV2aW91c1llYXIsXG4gICAgICAgICAgICAgIHRpdGxlOiBsb2NhbGUucHJldmlvdXNZZWFyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ8KrJ1xuICAgICAgICAgICksXG4gICAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLXllYXItc2VsZWN0JyxcbiAgICAgICAgICAgICAgcm9sZTogJ2J1dHRvbicsXG4gICAgICAgICAgICAgIG9uQ2xpY2s6IHRoaXMuc2hvd1llYXJQYW5lbCxcbiAgICAgICAgICAgICAgdGl0bGU6IGxvY2FsZS55ZWFyU2VsZWN0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy15ZWFyLXNlbGVjdC1jb250ZW50JyB9LFxuICAgICAgICAgICAgICB5ZWFyXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy15ZWFyLXNlbGVjdC1hcnJvdycgfSxcbiAgICAgICAgICAgICAgJ3gnXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSxcbiAgICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6IHByZWZpeENscyArICctbmV4dC15ZWFyLWJ0bicsXG4gICAgICAgICAgICAgIHJvbGU6ICdidXR0b24nLFxuICAgICAgICAgICAgICBvbkNsaWNrOiB0aGlzLm5leHRZZWFyLFxuICAgICAgICAgICAgICB0aXRsZTogbG9jYWxlLm5leHRZZWFyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ8K7J1xuICAgICAgICAgIClcbiAgICAgICAgKSxcbiAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1ib2R5JyB9LFxuICAgICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX01vbnRoVGFibGUyW1wiZGVmYXVsdFwiXSwge1xuICAgICAgICAgICAgZGlzYWJsZWREYXRlOiBwcm9wcy5kaXNhYmxlZERhdGUsXG4gICAgICAgICAgICBvblNlbGVjdDogdGhpcy5zZXRBbmRTZWxlY3RWYWx1ZSxcbiAgICAgICAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgcHJlZml4Q2xzOiBwcmVmaXhDbHNcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApLFxuICAgICAgeWVhclBhbmVsXG4gICAgKTtcbiAgfVxufSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gTW9udGhQYW5lbDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9saWIvbW9udGgvTW9udGhQYW5lbC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX2NsYXNzbmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG5cbnZhciBfY2xhc3NuYW1lczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc25hbWVzKTtcblxudmFyIF9EZWNhZGVQYW5lbCA9IHJlcXVpcmUoJy4uL2RlY2FkZS9EZWNhZGVQYW5lbCcpO1xuXG52YXIgX0RlY2FkZVBhbmVsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RlY2FkZVBhbmVsKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFJPVyA9IDQ7XG52YXIgQ09MID0gMztcblxuZnVuY3Rpb24gZ29ZZWFyKGRpcmVjdGlvbikge1xuICB2YXIgdmFsdWUgPSB0aGlzLnN0YXRlLnZhbHVlLmNsb25lKCk7XG4gIHZhbHVlLmFkZFllYXIoZGlyZWN0aW9uKTtcbiAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgdmFsdWU6IHZhbHVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjaG9vc2VZZWFyKHllYXIpIHtcbiAgdmFyIHZhbHVlID0gdGhpcy5zdGF0ZS52YWx1ZS5jbG9uZSgpO1xuICB2YWx1ZS5zZXRZZWFyKHllYXIpO1xuICB2YWx1ZS5yb2xsU2V0TW9udGgodGhpcy5zdGF0ZS52YWx1ZS5nZXRNb250aCgpKTtcbiAgdGhpcy5wcm9wcy5vblNlbGVjdCh2YWx1ZSk7XG59XG5cbnZhciBZZWFyUGFuZWwgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoWWVhclBhbmVsLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBZZWFyUGFuZWwocHJvcHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgWWVhclBhbmVsKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihZZWFyUGFuZWwpLmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgIF90aGlzLnByZWZpeENscyA9IHByb3BzLnJvb3RQcmVmaXhDbHMgKyAnLXllYXItcGFuZWwnO1xuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgdmFsdWU6IHByb3BzLnZhbHVlIHx8IHByb3BzLmRlZmF1bHRWYWx1ZVxuICAgIH07XG4gICAgX3RoaXMubmV4dERlY2FkZSA9IGdvWWVhci5iaW5kKF90aGlzLCAxMCk7XG4gICAgX3RoaXMucHJldmlvdXNEZWNhZGUgPSBnb1llYXIuYmluZChfdGhpcywgLTEwKTtcbiAgICBbJ3Nob3dEZWNhZGVQYW5lbCcsICdvbkRlY2FkZVBhbmVsU2VsZWN0J10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICBfdGhpc1ttZXRob2RdID0gX3RoaXNbbWV0aG9kXS5iaW5kKF90aGlzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoWWVhclBhbmVsLCBbe1xuICAgIGtleTogJ29uRGVjYWRlUGFuZWxTZWxlY3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkRlY2FkZVBhbmVsU2VsZWN0KGN1cnJlbnQpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICB2YWx1ZTogY3VycmVudCxcbiAgICAgICAgc2hvd0RlY2FkZVBhbmVsOiAwXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRZZWFycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFllYXJzKCkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICAgIHZhciBjdXJyZW50WWVhciA9IHZhbHVlLmdldFllYXIoKTtcbiAgICAgIHZhciBzdGFydFllYXIgPSBwYXJzZUludChjdXJyZW50WWVhciAvIDEwLCAxMCkgKiAxMDtcbiAgICAgIHZhciBwcmV2aW91c1llYXIgPSBzdGFydFllYXIgLSAxO1xuICAgICAgdmFyIGVuZFllYXIgPSBzdGFydFllYXIgKyA5O1xuICAgICAgdmFyIHllYXJzID0gW107XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgZm9yICh2YXIgcm93SW5kZXggPSAwOyByb3dJbmRleCA8IFJPVzsgcm93SW5kZXgrKykge1xuICAgICAgICB5ZWFyc1tyb3dJbmRleF0gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgY29sSW5kZXggPSAwOyBjb2xJbmRleCA8IENPTDsgY29sSW5kZXgrKykge1xuICAgICAgICAgIHZhciB5ZWFyID0gcHJldmlvdXNZZWFyICsgaW5kZXg7XG4gICAgICAgICAgdmFyIGNvbnRlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKHllYXIgPCBzdGFydFllYXIpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSAnJztcbiAgICAgICAgICB9IGVsc2UgaWYgKHllYXIgPiBlbmRZZWFyKSB7XG4gICAgICAgICAgICBjb250ZW50ID0gJyc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBTdHJpbmcoeWVhcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHllYXJzW3Jvd0luZGV4XVtjb2xJbmRleF0gPSB7XG4gICAgICAgICAgICBjb250ZW50OiBjb250ZW50LFxuICAgICAgICAgICAgeWVhcjogeWVhcixcbiAgICAgICAgICAgIHRpdGxlOiBjb250ZW50XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geWVhcnM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2hvd0RlY2FkZVBhbmVsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvd0RlY2FkZVBhbmVsKCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHNob3dEZWNhZGVQYW5lbDogMVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVuZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgdmFyIGxvY2FsZSA9IHByb3BzLmxvY2FsZTtcbiAgICAgIHZhciB5ZWFycyA9IHRoaXMuZ2V0WWVhcnMoKTtcbiAgICAgIHZhciBjdXJyZW50WWVhciA9IHZhbHVlLmdldFllYXIoKTtcbiAgICAgIHZhciBzdGFydFllYXIgPSBwYXJzZUludChjdXJyZW50WWVhciAvIDEwLCAxMCkgKiAxMDtcbiAgICAgIHZhciBlbmRZZWFyID0gc3RhcnRZZWFyICsgOTtcbiAgICAgIHZhciBwcmVmaXhDbHMgPSB0aGlzLnByZWZpeENscztcblxuICAgICAgdmFyIHllYXNFbHMgPSB5ZWFycy5tYXAoZnVuY3Rpb24gKHJvdywgaW5kZXgpIHtcbiAgICAgICAgdmFyIHRkcyA9IHJvdy5tYXAoZnVuY3Rpb24gKHllYXJEYXRhKSB7XG4gICAgICAgICAgdmFyIF9jbGFzc05hbWVNYXA7XG5cbiAgICAgICAgICB2YXIgY2xhc3NOYW1lTWFwID0gKF9jbGFzc05hbWVNYXAgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWVNYXAsIHByZWZpeENscyArICctY2VsbCcsIDEpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzTmFtZU1hcCwgcHJlZml4Q2xzICsgJy1zZWxlY3RlZC1jZWxsJywgeWVhckRhdGEueWVhciA9PT0gY3VycmVudFllYXIpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzTmFtZU1hcCwgcHJlZml4Q2xzICsgJy1sYXN0LWRlY2FkZS1jZWxsJywgeWVhckRhdGEueWVhciA8IHN0YXJ0WWVhciksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NOYW1lTWFwLCBwcmVmaXhDbHMgKyAnLW5leHQtZGVjYWRlLWNlbGwnLCB5ZWFyRGF0YS55ZWFyID4gZW5kWWVhciksIF9jbGFzc05hbWVNYXApO1xuICAgICAgICAgIHZhciBjbGlja0hhbmRsZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKHllYXJEYXRhLnllYXIgPCBzdGFydFllYXIpIHtcbiAgICAgICAgICAgIGNsaWNrSGFuZGxlciA9IF90aGlzMi5wcmV2aW91c0RlY2FkZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHllYXJEYXRhLnllYXIgPiBlbmRZZWFyKSB7XG4gICAgICAgICAgICBjbGlja0hhbmRsZXIgPSBfdGhpczIubmV4dERlY2FkZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xpY2tIYW5kbGVyID0gY2hvb3NlWWVhci5iaW5kKF90aGlzMiwgeWVhckRhdGEueWVhcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ3RkJyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcm9sZTogJ2dyaWRjZWxsJyxcbiAgICAgICAgICAgICAgdGl0bGU6IHllYXJEYXRhLnRpdGxlLFxuICAgICAgICAgICAgICBrZXk6IHllYXJEYXRhLmNvbnRlbnQsXG4gICAgICAgICAgICAgIG9uQ2xpY2s6IGNsaWNrSGFuZGxlcixcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiAoMCwgX2NsYXNzbmFtZXMyW1wiZGVmYXVsdFwiXSkoY2xhc3NOYW1lTWFwKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy15ZWFyJ1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB5ZWFyRGF0YS5jb250ZW50XG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICd0cicsXG4gICAgICAgICAgeyBrZXk6IGluZGV4LCByb2xlOiAncm93JyB9LFxuICAgICAgICAgIHRkc1xuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBkZWNhZGVQYW5lbCA9IHVuZGVmaW5lZDtcbiAgICAgIGlmICh0aGlzLnN0YXRlLnNob3dEZWNhZGVQYW5lbCkge1xuICAgICAgICBkZWNhZGVQYW5lbCA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0RlY2FkZVBhbmVsMltcImRlZmF1bHRcIl0sIHtcbiAgICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgcm9vdFByZWZpeENsczogcHJvcHMucm9vdFByZWZpeENscyxcbiAgICAgICAgICBvblNlbGVjdDogdGhpcy5vbkRlY2FkZVBhbmVsU2VsZWN0XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIHsgY2xhc3NOYW1lOiB0aGlzLnByZWZpeENscyB9LFxuICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICdkaXYnLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctaGVhZGVyJyB9LFxuICAgICAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLXByZXYtZGVjYWRlLWJ0bicsXG4gICAgICAgICAgICAgICAgcm9sZTogJ2J1dHRvbicsXG4gICAgICAgICAgICAgICAgb25DbGljazogdGhpcy5wcmV2aW91c0RlY2FkZSxcbiAgICAgICAgICAgICAgICB0aXRsZTogbG9jYWxlLnByZXZpb3VzRGVjYWRlXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICfCqydcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAnYScsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IHByZWZpeENscyArICctZGVjYWRlLXNlbGVjdCcsXG4gICAgICAgICAgICAgICAgcm9sZTogJ2J1dHRvbicsXG4gICAgICAgICAgICAgICAgb25DbGljazogdGhpcy5zaG93RGVjYWRlUGFuZWwsXG4gICAgICAgICAgICAgICAgdGl0bGU6IGxvY2FsZS5kZWNhZGVTZWxlY3RcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctZGVjYWRlLXNlbGVjdC1jb250ZW50JyB9LFxuICAgICAgICAgICAgICAgIHN0YXJ0WWVhcixcbiAgICAgICAgICAgICAgICAnLScsXG4gICAgICAgICAgICAgICAgZW5kWWVhclxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1kZWNhZGUtc2VsZWN0LWFycm93JyB9LFxuICAgICAgICAgICAgICAgICd4J1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLW5leHQtZGVjYWRlLWJ0bicsXG4gICAgICAgICAgICAgICAgcm9sZTogJ2J1dHRvbicsXG4gICAgICAgICAgICAgICAgb25DbGljazogdGhpcy5uZXh0RGVjYWRlLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBsb2NhbGUubmV4dERlY2FkZVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAnwrsnXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSxcbiAgICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1ib2R5JyB9LFxuICAgICAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgJ3RhYmxlJyxcbiAgICAgICAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctdGFibGUnLCBjZWxsU3BhY2luZzogJzAnLCByb2xlOiAnZ3JpZCcgfSxcbiAgICAgICAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAndGJvZHknLFxuICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLXRib2R5JyB9LFxuICAgICAgICAgICAgICAgIHllYXNFbHNcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgKSxcbiAgICAgICAgZGVjYWRlUGFuZWxcbiAgICAgICk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFllYXJQYW5lbDtcbn0oX3JlYWN0MltcImRlZmF1bHRcIl0uQ29tcG9uZW50KTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBZZWFyUGFuZWw7XG5cblxuWWVhclBhbmVsLnByb3BUeXBlcyA9IHtcbiAgcm9vdFByZWZpeENsczogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gIHZhbHVlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgZGVmYXVsdFZhbHVlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdFxufTtcblxuWWVhclBhbmVsLmRlZmF1bHRQcm9wcyA9IHtcbiAgb25TZWxlY3Q6IGZ1bmN0aW9uIG9uU2VsZWN0KCkge31cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL3llYXIvWWVhclBhbmVsLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfY2xhc3NuYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcblxudmFyIF9jbGFzc25hbWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzbmFtZXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgUk9XID0gNDtcbnZhciBDT0wgPSAzO1xuXG5cbmZ1bmN0aW9uIGdvWWVhcihkaXJlY3Rpb24pIHtcbiAgdmFyIG5leHQgPSB0aGlzLnN0YXRlLnZhbHVlLmNsb25lKCk7XG4gIG5leHQuYWRkWWVhcihkaXJlY3Rpb24pO1xuICB0aGlzLnNldFN0YXRlKHtcbiAgICB2YWx1ZTogbmV4dFxuICB9KTtcbn1cblxuZnVuY3Rpb24gY2hvb3NlRGVjYWRlKHllYXIsIGV2ZW50KSB7XG4gIHZhciBuZXh0ID0gdGhpcy5zdGF0ZS52YWx1ZS5jbG9uZSgpO1xuICBuZXh0LnNldFllYXIoeWVhcik7XG4gIG5leHQucm9sbFNldE1vbnRoKHRoaXMuc3RhdGUudmFsdWUuZ2V0TW9udGgoKSk7XG4gIHRoaXMucHJvcHMub25TZWxlY3QobmV4dCk7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59XG5cbnZhciBEZWNhZGVQYW5lbCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhEZWNhZGVQYW5lbCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gRGVjYWRlUGFuZWwocHJvcHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGVjYWRlUGFuZWwpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKERlY2FkZVBhbmVsKS5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHZhbHVlOiBwcm9wcy52YWx1ZSB8fCBwcm9wcy5kZWZhdWx0VmFsdWVcbiAgICB9O1xuXG4gICAgLy8gYmluZCBtZXRob2RzXG4gICAgX3RoaXMucHJlZml4Q2xzID0gcHJvcHMucm9vdFByZWZpeENscyArICctZGVjYWRlLXBhbmVsJztcbiAgICBfdGhpcy5uZXh0Q2VudHVyeSA9IGdvWWVhci5iaW5kKF90aGlzLCAxMDApO1xuICAgIF90aGlzLnByZXZpb3VzQ2VudHVyeSA9IGdvWWVhci5iaW5kKF90aGlzLCAtMTAwKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRGVjYWRlUGFuZWwsIFt7XG4gICAga2V5OiAncmVuZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgICB2YXIgbG9jYWxlID0gdGhpcy5wcm9wcy5sb2NhbGU7XG4gICAgICB2YXIgY3VycmVudFllYXIgPSB2YWx1ZS5nZXRZZWFyKCk7XG4gICAgICB2YXIgc3RhcnRZZWFyID0gcGFyc2VJbnQoY3VycmVudFllYXIgLyAxMDAsIDEwKSAqIDEwMDtcbiAgICAgIHZhciBwcmVZZWFyID0gc3RhcnRZZWFyIC0gMTA7XG4gICAgICB2YXIgZW5kWWVhciA9IHN0YXJ0WWVhciArIDk5O1xuICAgICAgdmFyIGRlY2FkZXMgPSBbXTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgcHJlZml4Q2xzID0gdGhpcy5wcmVmaXhDbHM7XG5cbiAgICAgIGZvciAodmFyIHJvd0luZGV4ID0gMDsgcm93SW5kZXggPCBST1c7IHJvd0luZGV4KyspIHtcbiAgICAgICAgZGVjYWRlc1tyb3dJbmRleF0gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgY29sSW5kZXggPSAwOyBjb2xJbmRleCA8IENPTDsgY29sSW5kZXgrKykge1xuICAgICAgICAgIHZhciBzdGFydERlY2FkZSA9IHByZVllYXIgKyBpbmRleCAqIDEwO1xuICAgICAgICAgIHZhciBlbmREZWNhZGUgPSBwcmVZZWFyICsgaW5kZXggKiAxMCArIDk7XG4gICAgICAgICAgZGVjYWRlc1tyb3dJbmRleF1bY29sSW5kZXhdID0ge1xuICAgICAgICAgICAgc3RhcnREZWNhZGU6IHN0YXJ0RGVjYWRlLFxuICAgICAgICAgICAgZW5kRGVjYWRlOiBlbmREZWNhZGVcbiAgICAgICAgICB9O1xuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGRlY2FkZXNFbHMgPSBkZWNhZGVzLm1hcChmdW5jdGlvbiAocm93LCBkZWNhZGVJbmRleCkge1xuICAgICAgICB2YXIgdGRzID0gcm93Lm1hcChmdW5jdGlvbiAoZGVjYWRlRGF0YSkge1xuICAgICAgICAgIHZhciBfY2xhc3NOYW1lTWFwO1xuXG4gICAgICAgICAgdmFyIGRTdGFydERlY2FkZSA9IGRlY2FkZURhdGEuc3RhcnREZWNhZGU7XG4gICAgICAgICAgdmFyIGRFbmREZWNhZGUgPSBkZWNhZGVEYXRhLmVuZERlY2FkZTtcbiAgICAgICAgICB2YXIgaXNMYXN0ID0gZFN0YXJ0RGVjYWRlIDwgc3RhcnRZZWFyO1xuICAgICAgICAgIHZhciBpc05leHQgPSBkRW5kRGVjYWRlID4gZW5kWWVhcjtcbiAgICAgICAgICB2YXIgY2xhc3NOYW1lTWFwID0gKF9jbGFzc05hbWVNYXAgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWVNYXAsIHByZWZpeENscyArICctY2VsbCcsIDEpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzTmFtZU1hcCwgcHJlZml4Q2xzICsgJy1zZWxlY3RlZC1jZWxsJywgZFN0YXJ0RGVjYWRlIDw9IGN1cnJlbnRZZWFyICYmIGN1cnJlbnRZZWFyIDw9IGRFbmREZWNhZGUpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzTmFtZU1hcCwgcHJlZml4Q2xzICsgJy1sYXN0LWNlbnR1cnktY2VsbCcsIGlzTGFzdCksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NOYW1lTWFwLCBwcmVmaXhDbHMgKyAnLW5leHQtY2VudHVyeS1jZWxsJywgaXNOZXh0KSwgX2NsYXNzTmFtZU1hcCk7XG4gICAgICAgICAgdmFyIGNvbnRlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdmFyIGNsaWNrSGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAoaXNMYXN0KSB7XG4gICAgICAgICAgICBjbGlja0hhbmRsZXIgPSBfdGhpczIucHJldmlvdXNDZW50dXJ5O1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNOZXh0KSB7XG4gICAgICAgICAgICBjbGlja0hhbmRsZXIgPSBfdGhpczIubmV4dENlbnR1cnk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBkU3RhcnREZWNhZGUgKyAnLScgKyBkRW5kRGVjYWRlO1xuICAgICAgICAgICAgY2xpY2tIYW5kbGVyID0gY2hvb3NlRGVjYWRlLmJpbmQoX3RoaXMyLCBkU3RhcnREZWNhZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICd0ZCcsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGtleTogZFN0YXJ0RGVjYWRlLFxuICAgICAgICAgICAgICBvbkNsaWNrOiBjbGlja0hhbmRsZXIsXG4gICAgICAgICAgICAgIHJvbGU6ICdncmlkY2VsbCcsXG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogKDAsIF9jbGFzc25hbWVzMltcImRlZmF1bHRcIl0pKGNsYXNzTmFtZU1hcClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAnYScsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IHByZWZpeENscyArICctZGVjYWRlJ1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBjb250ZW50XG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICd0cicsXG4gICAgICAgICAgeyBrZXk6IGRlY2FkZUluZGV4LCByb2xlOiAncm93JyB9LFxuICAgICAgICAgIHRkc1xuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgeyBjbGFzc05hbWU6IHRoaXMucHJlZml4Q2xzIH0sXG4gICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctaGVhZGVyJyB9LFxuICAgICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnYScsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1wcmV2LWNlbnR1cnktYnRuJyxcbiAgICAgICAgICAgICAgcm9sZTogJ2J1dHRvbicsXG4gICAgICAgICAgICAgIG9uQ2xpY2s6IHRoaXMucHJldmlvdXNDZW50dXJ5LFxuICAgICAgICAgICAgICB0aXRsZTogbG9jYWxlLnByZXZpb3VzQ2VudHVyeVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICfCqydcbiAgICAgICAgICApLFxuICAgICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWNlbnR1cnknIH0sXG4gICAgICAgICAgICBzdGFydFllYXIsXG4gICAgICAgICAgICAnLScsXG4gICAgICAgICAgICBlbmRZZWFyXG4gICAgICAgICAgKSxcbiAgICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6IHByZWZpeENscyArICctbmV4dC1jZW50dXJ5LWJ0bicsXG4gICAgICAgICAgICAgIHJvbGU6ICdidXR0b24nLFxuICAgICAgICAgICAgICBvbkNsaWNrOiB0aGlzLm5leHRDZW50dXJ5LFxuICAgICAgICAgICAgICB0aXRsZTogbG9jYWxlLm5leHRDZW50dXJ5XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ8K7J1xuICAgICAgICAgIClcbiAgICAgICAgKSxcbiAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1ib2R5JyB9LFxuICAgICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAndGFibGUnLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctdGFibGUnLCBjZWxsU3BhY2luZzogJzAnLCByb2xlOiAnZ3JpZCcgfSxcbiAgICAgICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICd0Ym9keScsXG4gICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLXRib2R5JyB9LFxuICAgICAgICAgICAgICBkZWNhZGVzRWxzXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEZWNhZGVQYW5lbDtcbn0oX3JlYWN0MltcImRlZmF1bHRcIl0uQ29tcG9uZW50KTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBEZWNhZGVQYW5lbDtcblxuXG5EZWNhZGVQYW5lbC5wcm9wVHlwZXMgPSB7XG4gIGxvY2FsZTogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gIHZhbHVlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgZGVmYXVsdFZhbHVlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgcm9vdFByZWZpeENsczogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmdcbn07XG5cbkRlY2FkZVBhbmVsLmRlZmF1bHRQcm9wcyA9IHtcbiAgb25TZWxlY3Q6IGZ1bmN0aW9uIG9uU2VsZWN0KCkge31cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL2RlY2FkZS9EZWNhZGVQYW5lbC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX2NsYXNzbmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG5cbnZhciBfY2xhc3NuYW1lczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc25hbWVzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFJPVyA9IDQ7XG52YXIgQ09MID0gMztcblxuZnVuY3Rpb24gY2hvb3NlTW9udGgobW9udGgpIHtcbiAgdmFyIG5leHQgPSB0aGlzLnN0YXRlLnZhbHVlLmNsb25lKCk7XG4gIG5leHQucm9sbFNldE1vbnRoKG1vbnRoKTtcbiAgdGhpcy5zZXRBbmRTZWxlY3RWYWx1ZShuZXh0KTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBNb250aFRhYmxlID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzKE1vbnRoVGFibGUsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIE1vbnRoVGFibGUocHJvcHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTW9udGhUYWJsZSk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTW9udGhUYWJsZSkuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICB2YWx1ZTogcHJvcHMudmFsdWVcbiAgICB9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNb250aFRhYmxlLCBbe1xuICAgIGtleTogJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgaWYgKCd2YWx1ZScgaW4gbmV4dFByb3BzKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIHZhbHVlOiBuZXh0UHJvcHMudmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0TW9udGhzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TW9udGhzKCkge1xuICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgICB2YXIgY3VycmVudCA9IHZhbHVlLmNsb25lKCk7XG4gICAgICB2YXIgbG9jYWxlID0gcHJvcHMubG9jYWxlO1xuICAgICAgdmFyIG1vbnRocyA9IFtdO1xuICAgICAgdmFyIHNob3J0TW9udGhzID0gbG9jYWxlLmZvcm1hdC5zaG9ydE1vbnRocztcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICBmb3IgKHZhciByb3dJbmRleCA9IDA7IHJvd0luZGV4IDwgUk9XOyByb3dJbmRleCsrKSB7XG4gICAgICAgIG1vbnRoc1tyb3dJbmRleF0gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgY29sSW5kZXggPSAwOyBjb2xJbmRleCA8IENPTDsgY29sSW5kZXgrKykge1xuICAgICAgICAgIGN1cnJlbnQucm9sbFNldE1vbnRoKGluZGV4KTtcbiAgICAgICAgICBtb250aHNbcm93SW5kZXhdW2NvbEluZGV4XSA9IHtcbiAgICAgICAgICAgIHZhbHVlOiBpbmRleCxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHNob3J0TW9udGhzW2luZGV4XSxcbiAgICAgICAgICAgIHRpdGxlOiBzaG9ydE1vbnRoc1tpbmRleF1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtb250aHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0QW5kU2VsZWN0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRBbmRTZWxlY3RWYWx1ZSh2YWx1ZSkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgICB0aGlzLnByb3BzLm9uU2VsZWN0KHZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgICB2YXIgdG9kYXkgPSB2YWx1ZS5jbG9uZSgpO1xuICAgICAgdG9kYXkuc2V0VGltZShEYXRlLm5vdygpKTtcbiAgICAgIHZhciBtb250aHMgPSB0aGlzLmdldE1vbnRocygpO1xuICAgICAgdmFyIGN1cnJlbnRNb250aCA9IHZhbHVlLmdldE1vbnRoKCk7XG4gICAgICB2YXIgcHJlZml4Q2xzID0gcHJvcHMucHJlZml4Q2xzO1xuICAgICAgdmFyIGxvY2FsZSA9IHByb3BzLmxvY2FsZTtcbiAgICAgIHZhciBjb250ZW50UmVuZGVyID0gcHJvcHMuY29udGVudFJlbmRlcjtcbiAgICAgIHZhciBjZWxsUmVuZGVyID0gcHJvcHMuY2VsbFJlbmRlcjtcblxuICAgICAgdmFyIG1vbnRoc0VscyA9IG1vbnRocy5tYXAoZnVuY3Rpb24gKG1vbnRoLCBpbmRleCkge1xuICAgICAgICB2YXIgdGRzID0gbW9udGgubWFwKGZ1bmN0aW9uIChtb250aERhdGEpIHtcbiAgICAgICAgICB2YXIgX2NsYXNzTmFtZU1hcDtcblxuICAgICAgICAgIHZhciBkaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgIGlmIChwcm9wcy5kaXNhYmxlZERhdGUpIHtcbiAgICAgICAgICAgIHZhciB0ZXN0VmFsdWUgPSB2YWx1ZS5jbG9uZSgpO1xuICAgICAgICAgICAgdGVzdFZhbHVlLnJvbGxTZXRNb250aChtb250aERhdGEudmFsdWUpO1xuICAgICAgICAgICAgZGlzYWJsZWQgPSBwcm9wcy5kaXNhYmxlZERhdGUodGVzdFZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNsYXNzTmFtZU1hcCA9IChfY2xhc3NOYW1lTWFwID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NOYW1lTWFwLCBwcmVmaXhDbHMgKyAnLWNlbGwnLCAxKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWVNYXAsIHByZWZpeENscyArICctY2VsbC1kaXNhYmxlZCcsIGRpc2FibGVkKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWVNYXAsIHByZWZpeENscyArICctc2VsZWN0ZWQtY2VsbCcsIG1vbnRoRGF0YS52YWx1ZSA9PT0gY3VycmVudE1vbnRoKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWVNYXAsIHByZWZpeENscyArICctY3VycmVudC1jZWxsJywgdG9kYXkuZ2V0WWVhcigpID09PSB2YWx1ZS5nZXRZZWFyKCkgJiYgbW9udGhEYXRhLnZhbHVlID09PSB0b2RheS5nZXRNb250aCgpKSwgX2NsYXNzTmFtZU1hcCk7XG4gICAgICAgICAgdmFyIGNlbGxFbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAoY2VsbFJlbmRlcikge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IHZhbHVlLmNsb25lKCk7XG4gICAgICAgICAgICBjdXJyZW50VmFsdWUucm9sbFNldE1vbnRoKG1vbnRoRGF0YS52YWx1ZSk7XG4gICAgICAgICAgICBjZWxsRWwgPSBjZWxsUmVuZGVyKGN1cnJlbnRWYWx1ZSwgbG9jYWxlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoY29udGVudFJlbmRlcikge1xuICAgICAgICAgICAgICB2YXIgX2N1cnJlbnRWYWx1ZSA9IHZhbHVlLmNsb25lKCk7XG4gICAgICAgICAgICAgIF9jdXJyZW50VmFsdWUucm9sbFNldE1vbnRoKG1vbnRoRGF0YS52YWx1ZSk7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50UmVuZGVyKF9jdXJyZW50VmFsdWUsIGxvY2FsZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb250ZW50ID0gbW9udGhEYXRhLmNvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZWxsRWwgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctbW9udGgnIH0sXG4gICAgICAgICAgICAgIGNvbnRlbnRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ3RkJyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcm9sZTogJ2dyaWRjZWxsJyxcbiAgICAgICAgICAgICAga2V5OiBtb250aERhdGEudmFsdWUsXG4gICAgICAgICAgICAgIG9uQ2xpY2s6IGRpc2FibGVkID8gbnVsbCA6IGNob29zZU1vbnRoLmJpbmQoX3RoaXMyLCBtb250aERhdGEudmFsdWUpLFxuICAgICAgICAgICAgICB0aXRsZTogbW9udGhEYXRhLnRpdGxlLFxuICAgICAgICAgICAgICBjbGFzc05hbWU6ICgwLCBfY2xhc3NuYW1lczJbXCJkZWZhdWx0XCJdKShjbGFzc05hbWVNYXApXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2VsbEVsXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICd0cicsXG4gICAgICAgICAgeyBrZXk6IGluZGV4LCByb2xlOiAncm93JyB9LFxuICAgICAgICAgIHRkc1xuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAndGFibGUnLFxuICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy10YWJsZScsIGNlbGxTcGFjaW5nOiAnMCcsIHJvbGU6ICdncmlkJyB9LFxuICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICd0Ym9keScsXG4gICAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctdGJvZHknIH0sXG4gICAgICAgICAgbW9udGhzRWxzXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1vbnRoVGFibGU7XG59KF9yZWFjdC5Db21wb25lbnQpO1xuXG5Nb250aFRhYmxlLmRlZmF1bHRQcm9wcyA9IHtcbiAgb25TZWxlY3Q6IG5vb3Bcbn07XG5Nb250aFRhYmxlLnByb3BUeXBlcyA9IHtcbiAgb25TZWxlY3Q6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgY2VsbFJlbmRlcjogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICBwcmVmaXhDbHM6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICB2YWx1ZTogX3JlYWN0LlByb3BUeXBlcy5vYmplY3Rcbn07XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IE1vbnRoVGFibGU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL21vbnRoL01vbnRoVGFibGUuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yZWFjdERvbSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgX3JlYWN0RG9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0RG9tKTtcblxudmFyIF9yY1V0aWwgPSByZXF1aXJlKCdyYy11dGlsJyk7XG5cbnZhciBfcmNVdGlsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JjVXRpbCk7XG5cbnZhciBfVG9kYXlCdXR0b24gPSByZXF1aXJlKCcuLi9jYWxlbmRhci9Ub2RheUJ1dHRvbicpO1xuXG52YXIgX1RvZGF5QnV0dG9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1RvZGF5QnV0dG9uKTtcblxudmFyIF9Pa0J1dHRvbiA9IHJlcXVpcmUoJy4uL2NhbGVuZGFyL09rQnV0dG9uJyk7XG5cbnZhciBfT2tCdXR0b24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfT2tCdXR0b24pO1xuXG52YXIgX2luZGV4ID0gcmVxdWlyZSgnLi4vdXRpbC9pbmRleCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxudmFyIHRvRnJhZ21lbnQgPSBfcmNVdGlsMltcImRlZmF1bHRcIl0uQ2hpbGRyZW4ubWFwU2VsZjtcblxuXG52YXIgQ2FsZW5kYXJGb290ZXIgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnQ2FsZW5kYXJGb290ZXInLFxuXG4gIHByb3BUeXBlczoge1xuICAgIHByZWZpeENsczogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgc2hvd0RhdGVJbnB1dDogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGRpc2FibGVkVGltZTogX3JlYWN0LlByb3BUeXBlcy5hbnksXG4gICAgZ3JlZ29yaWFuQ2FsZW5kYXJMb2NhbGU6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIHNlbGVjdGVkVmFsdWU6IF9yZWFjdC5Qcm9wVHlwZXMuYW55LFxuICAgIHNob3dPazogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIG9uU2VsZWN0OiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgdmFsdWU6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIGRlZmF1bHRWYWx1ZTogX3JlYWN0LlByb3BUeXBlcy5vYmplY3RcbiAgfSxcblxuICBvblNlbGVjdDogZnVuY3Rpb24gb25TZWxlY3QodmFsdWUpIHtcbiAgICB0aGlzLnByb3BzLm9uU2VsZWN0KHZhbHVlKTtcbiAgfSxcbiAgZ2V0Um9vdERPTU5vZGU6IGZ1bmN0aW9uIGdldFJvb3RET01Ob2RlKCkge1xuICAgIHJldHVybiBfcmVhY3REb20yW1wiZGVmYXVsdFwiXS5maW5kRE9NTm9kZSh0aGlzKTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgICB2YXIgcHJlZml4Q2xzID0gcHJvcHMucHJlZml4Q2xzO1xuICAgIHZhciBzaG93RGF0ZUlucHV0ID0gcHJvcHMuc2hvd0RhdGVJbnB1dDtcbiAgICB2YXIgZGlzYWJsZWRUaW1lID0gcHJvcHMuZGlzYWJsZWRUaW1lO1xuICAgIHZhciBncmVnb3JpYW5DYWxlbmRhckxvY2FsZSA9IHByb3BzLmdyZWdvcmlhbkNhbGVuZGFyTG9jYWxlO1xuICAgIHZhciBzZWxlY3RlZFZhbHVlID0gcHJvcHMuc2VsZWN0ZWRWYWx1ZTtcbiAgICB2YXIgc2hvd09rID0gcHJvcHMuc2hvd09rO1xuXG4gICAgdmFyIHRpbWVQaWNrZXIgPSAhc2hvd0RhdGVJbnB1dCAmJiBwcm9wcy50aW1lUGlja2VyIHx8IG51bGw7XG4gICAgdmFyIGRpc2FibGVkVGltZUNvbmZpZyA9IGRpc2FibGVkVGltZSAmJiB0aW1lUGlja2VyID8gKDAsIF9pbmRleC5nZXRUaW1lQ29uZmlnKShzZWxlY3RlZFZhbHVlLCBkaXNhYmxlZFRpbWUpIDogbnVsbDtcbiAgICB2YXIgZm9vdGVyRWwgPSBudWxsO1xuICAgIGlmIChwcm9wcy5zaG93VG9kYXkgfHwgdGltZVBpY2tlcikge1xuICAgICAgdmFyIG5vd0VsID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKHByb3BzLnNob3dUb2RheSkge1xuICAgICAgICBub3dFbCA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX1RvZGF5QnV0dG9uMltcImRlZmF1bHRcIl0sIF9leHRlbmRzKHt9LCBwcm9wcywgeyB2YWx1ZTogdmFsdWUgfSkpO1xuICAgICAgfVxuICAgICAgdmFyIG9rQnRuID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKHNob3dPayA9PT0gdHJ1ZSB8fCBzaG93T2sgIT09IGZhbHNlICYmICEhcHJvcHMudGltZVBpY2tlcikge1xuICAgICAgICBva0J0biA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX09rQnV0dG9uMltcImRlZmF1bHRcIl0sIHByb3BzKTtcbiAgICAgIH1cbiAgICAgIHZhciBmb290ZXJCdG4gPSB1bmRlZmluZWQ7XG4gICAgICBpZiAobm93RWwgfHwgb2tCdG4pIHtcbiAgICAgICAgZm9vdGVyQnRuID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctZm9vdGVyLWJ0bicgfSxcbiAgICAgICAgICB0b0ZyYWdtZW50KFtub3dFbCwgb2tCdG5dKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHRpbWVQaWNrZXIpIHtcbiAgICAgICAgdGltZVBpY2tlciA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNsb25lRWxlbWVudCh0aW1lUGlja2VyLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgb25DaGFuZ2U6IHRoaXMub25TZWxlY3QsXG4gICAgICAgICAgYWxsb3dFbXB0eTogZmFsc2UsXG4gICAgICAgICAgZ3JlZ29yaWFuQ2FsZW5kYXJMb2NhbGU6IGdyZWdvcmlhbkNhbGVuZGFyTG9jYWxlXG4gICAgICAgIH0sIGRpc2FibGVkVGltZUNvbmZpZywge1xuICAgICAgICAgIGdldFBvcHVwQ29udGFpbmVyOiB0aGlzLmdldFJvb3RET01Ob2RlLFxuICAgICAgICAgIHZhbHVlOiBzZWxlY3RlZFZhbHVlXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIGZvb3RlckVsID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWZvb3RlcicgfSxcbiAgICAgICAgdGltZVBpY2tlcixcbiAgICAgICAgZm9vdGVyQnRuXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBmb290ZXJFbDtcbiAgfVxufSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQ2FsZW5kYXJGb290ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL2NhbGVuZGFyL0NhbGVuZGFyRm9vdGVyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBUb2RheUJ1dHRvbjtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKCcuLi91dGlsLycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gVG9kYXlCdXR0b24oX3JlZikge1xuICB2YXIgcHJlZml4Q2xzID0gX3JlZi5wcmVmaXhDbHM7XG4gIHZhciBsb2NhbGUgPSBfcmVmLmxvY2FsZTtcbiAgdmFyIHZhbHVlID0gX3JlZi52YWx1ZTtcbiAgdmFyIHRpbWVQaWNrZXIgPSBfcmVmLnRpbWVQaWNrZXI7XG4gIHZhciBkaXNhYmxlZERhdGUgPSBfcmVmLmRpc2FibGVkRGF0ZTtcbiAgdmFyIGRpc2FibGVkVGltZSA9IF9yZWYuZGlzYWJsZWRUaW1lO1xuICB2YXIgb25Ub2RheSA9IF9yZWYub25Ub2RheTtcblxuICB2YXIgZGlzYWJsZWRUb2RheSA9IGZhbHNlO1xuICB2YXIgbG9jYWxlTm93ID0gbG9jYWxlLnRvZGF5O1xuICBpZiAodGltZVBpY2tlcikge1xuICAgIGxvY2FsZU5vdyA9IGxvY2FsZS5ub3cgfHwgbG9jYWxlLnRvZGF5O1xuICB9XG4gIHZhciBkaXNhYmxlZFRvZGF5Q2xhc3MgPSAnJztcbiAgaWYgKGRpc2FibGVkRGF0ZSkge1xuICAgIGRpc2FibGVkVG9kYXkgPSAhKDAsIF91dGlsLmlzQWxsb3dlZERhdGUpKCgwLCBfdXRpbC5nZXRUb2RheVRpbWUpKHZhbHVlKSwgZGlzYWJsZWREYXRlLCBkaXNhYmxlZFRpbWUpO1xuICAgIGlmIChkaXNhYmxlZFRvZGF5KSB7XG4gICAgICBkaXNhYmxlZFRvZGF5Q2xhc3MgPSBwcmVmaXhDbHMgKyAnLXRvZGF5LWJ0bi1kaXNhYmxlZCc7XG4gICAgfVxuICB9XG4gIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICdhJyxcbiAgICB7XG4gICAgICBjbGFzc05hbWU6IHByZWZpeENscyArICctdG9kYXktYnRuICcgKyBkaXNhYmxlZFRvZGF5Q2xhc3MsXG4gICAgICByb2xlOiAnYnV0dG9uJyxcbiAgICAgIG9uQ2xpY2s6IGRpc2FibGVkVG9kYXkgPyBudWxsIDogb25Ub2RheSxcbiAgICAgIHRpdGxlOiAoMCwgX3V0aWwuZ2V0VG9kYXlUaW1lU3RyKSh2YWx1ZSlcbiAgICB9LFxuICAgIGxvY2FsZU5vd1xuICApO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9jYWxlbmRhci9Ub2RheUJ1dHRvbi5qc1xuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBPa0J1dHRvbjtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBPa0J1dHRvbihfcmVmKSB7XG4gIHZhciBwcmVmaXhDbHMgPSBfcmVmLnByZWZpeENscztcbiAgdmFyIGxvY2FsZSA9IF9yZWYubG9jYWxlO1xuICB2YXIgb2tEaXNhYmxlZCA9IF9yZWYub2tEaXNhYmxlZDtcbiAgdmFyIG9uT2sgPSBfcmVmLm9uT2s7XG5cbiAgdmFyIGNsYXNzTmFtZSA9IHByZWZpeENscyArIFwiLW9rLWJ0blwiO1xuICBpZiAob2tEaXNhYmxlZCkge1xuICAgIGNsYXNzTmFtZSArPSBcIiBcIiArIHByZWZpeENscyArIFwiLW9rLWJ0bi1kaXNhYmxlZFwiO1xuICB9XG4gIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgIFwiYVwiLFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgcm9sZTogXCJidXR0b25cIixcbiAgICAgIG9uQ2xpY2s6IG9rRGlzYWJsZWQgPyBudWxsIDogb25Pa1xuICAgIH0sXG4gICAgbG9jYWxlLm9rXG4gICk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL2NhbGVuZGFyL09rQnV0dG9uLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfY2xhc3NuYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcblxudmFyIF9jbGFzc25hbWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzbmFtZXMpO1xuXG52YXIgX2dyZWdvcmlhbkNhbGVuZGFyID0gcmVxdWlyZSgnZ3JlZ29yaWFuLWNhbGVuZGFyJyk7XG5cbnZhciBfZ3JlZ29yaWFuQ2FsZW5kYXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ3JlZ29yaWFuQ2FsZW5kYXIpO1xuXG52YXIgX2luZGV4ID0gcmVxdWlyZSgnLi4vdXRpbC9pbmRleCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGdldE5vdygpIHtcbiAgdmFyIHZhbHVlID0gbmV3IF9ncmVnb3JpYW5DYWxlbmRhcjJbXCJkZWZhdWx0XCJdKCk7XG4gIHZhbHVlLnNldFRpbWUoRGF0ZS5ub3coKSk7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm93QnlDdXJyZW50U3RhdGVWYWx1ZSh2YWx1ZSkge1xuICB2YXIgcmV0ID0gdW5kZWZpbmVkO1xuICBpZiAodmFsdWUpIHtcbiAgICByZXQgPSB2YWx1ZS5jbG9uZSgpO1xuICAgIHJldC5zZXRUaW1lKERhdGUubm93KCkpO1xuICB9IGVsc2Uge1xuICAgIHJldCA9IGdldE5vdygpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbnZhciBDYWxlbmRhck1peGluID0ge1xuICBwcm9wVHlwZXM6IHtcbiAgICB2YWx1ZTogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgZGVmYXVsdFZhbHVlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBvbktleURvd246IF9yZWFjdC5Qcm9wVHlwZXMuZnVuY1xuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvbktleURvd246IG5vb3BcbiAgICB9O1xuICB9LFxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlIHx8IHByb3BzLmRlZmF1bHRWYWx1ZSB8fCBnZXROb3coKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgc2VsZWN0ZWRWYWx1ZTogcHJvcHMuc2VsZWN0ZWRWYWx1ZSB8fCBwcm9wcy5kZWZhdWx0U2VsZWN0ZWRWYWx1ZVxuICAgIH07XG4gIH0sXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgdmFyIHZhbHVlID0gbmV4dFByb3BzLnZhbHVlO1xuICAgIHZhciBzZWxlY3RlZFZhbHVlID0gbmV4dFByb3BzLnNlbGVjdGVkVmFsdWU7XG5cbiAgICBpZiAoJ3ZhbHVlJyBpbiBuZXh0UHJvcHMpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUgfHwgbmV4dFByb3BzLmRlZmF1bHRWYWx1ZSB8fCBnZXROb3dCeUN1cnJlbnRTdGF0ZVZhbHVlKHRoaXMuc3RhdGUudmFsdWUpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICgnc2VsZWN0ZWRWYWx1ZScgaW4gbmV4dFByb3BzKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgc2VsZWN0ZWRWYWx1ZTogc2VsZWN0ZWRWYWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBvblNlbGVjdDogZnVuY3Rpb24gb25TZWxlY3QodmFsdWUsIGNhdXNlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLnNldFZhbHVlKHZhbHVlKTtcbiAgICB9XG4gICAgdGhpcy5zZXRTZWxlY3RlZFZhbHVlKHZhbHVlLCBjYXVzZSk7XG4gIH0sXG4gIHJlbmRlclJvb3Q6IGZ1bmN0aW9uIHJlbmRlclJvb3QobmV3UHJvcHMpIHtcbiAgICB2YXIgX2NsYXNzTmFtZTtcblxuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHByZWZpeENscyA9IHByb3BzLnByZWZpeENscztcblxuICAgIHZhciBjbGFzc05hbWUgPSAoX2NsYXNzTmFtZSA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzTmFtZSwgcHJlZml4Q2xzLCAxKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWUsIHByZWZpeENscyArICctaGlkZGVuJywgIXByb3BzLnZpc2libGUpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzTmFtZSwgcHJvcHMuY2xhc3NOYW1lLCAhIXByb3BzLmNsYXNzTmFtZSksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NOYW1lLCBuZXdQcm9wcy5jbGFzc05hbWUsICEhbmV3UHJvcHMuY2xhc3NOYW1lKSwgX2NsYXNzTmFtZSk7XG5cbiAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICdkaXYnLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICcnICsgKDAsIF9jbGFzc25hbWVzMltcImRlZmF1bHRcIl0pKGNsYXNzTmFtZSksXG4gICAgICAgIHN0eWxlOiB0aGlzLnByb3BzLnN0eWxlLFxuICAgICAgICB0YWJJbmRleDogJzAnLCBvbktleURvd246IHRoaXMub25LZXlEb3duXG4gICAgICB9LFxuICAgICAgbmV3UHJvcHMuY2hpbGRyZW5cbiAgICApO1xuICB9LFxuICBzZXRTZWxlY3RlZFZhbHVlOiBmdW5jdGlvbiBzZXRTZWxlY3RlZFZhbHVlKHNlbGVjdGVkVmFsdWUsIGNhdXNlKSB7XG4gICAgaWYgKHRoaXMuaXNBbGxvd2VkRGF0ZShzZWxlY3RlZFZhbHVlKSkge1xuICAgICAgaWYgKCEoJ3NlbGVjdGVkVmFsdWUnIGluIHRoaXMucHJvcHMpKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIHNlbGVjdGVkVmFsdWU6IHNlbGVjdGVkVmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLnByb3BzLm9uU2VsZWN0KHNlbGVjdGVkVmFsdWUsIGNhdXNlKTtcbiAgICB9XG4gIH0sXG4gIHNldFZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgIHZhciBvcmlnaW5hbFZhbHVlID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICBpZiAoISgndmFsdWUnIGluIHRoaXMucHJvcHMpKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG9yaWdpbmFsVmFsdWUgJiYgdmFsdWUgJiYgb3JpZ2luYWxWYWx1ZS5nZXRUaW1lKCkgIT09IHZhbHVlLmdldFRpbWUoKSB8fCAhb3JpZ2luYWxWYWx1ZSAmJiB2YWx1ZSB8fCBvcmlnaW5hbFZhbHVlICYmICF2YWx1ZSkge1xuICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh2YWx1ZSk7XG4gICAgfVxuICB9LFxuICBpc0FsbG93ZWREYXRlOiBmdW5jdGlvbiBpc0FsbG93ZWREYXRlKHZhbHVlKSB7XG4gICAgdmFyIGRpc2FibGVkRGF0ZSA9IHRoaXMucHJvcHMuZGlzYWJsZWREYXRlO1xuICAgIHZhciBkaXNhYmxlZFRpbWUgPSB0aGlzLnByb3BzLmRpc2FibGVkVGltZTtcbiAgICByZXR1cm4gKDAsIF9pbmRleC5pc0FsbG93ZWREYXRlKSh2YWx1ZSwgZGlzYWJsZWREYXRlLCBkaXNhYmxlZFRpbWUpO1xuICB9XG59O1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IENhbGVuZGFyTWl4aW47XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL21peGluL0NhbGVuZGFyTWl4aW4uanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX2VuX1VTID0gcmVxdWlyZSgnLi4vbG9jYWxlL2VuX1VTJyk7XG5cbnZhciBfZW5fVVMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZW5fVVMpO1xuXG52YXIgX2luZGV4ID0gcmVxdWlyZSgnLi4vdXRpbC9pbmRleCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0ge1xuICBwcm9wVHlwZXM6IHtcbiAgICBjbGFzc05hbWU6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGxvY2FsZTogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgc3R5bGU6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIHZpc2libGU6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBvblNlbGVjdDogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIHByZWZpeENsczogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgb25DaGFuZ2U6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbk9rOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmNcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbG9jYWxlOiBfZW5fVVMyW1wiZGVmYXVsdFwiXSxcbiAgICAgIHN0eWxlOiB7fSxcbiAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICBwcmVmaXhDbHM6ICdyYy1jYWxlbmRhcicsXG4gICAgICBmb3JtYXR0ZXI6ICd5eXl5LU1NLWRkJyxcbiAgICAgIGNsYXNzTmFtZTogJycsXG4gICAgICBvblNlbGVjdDogbm9vcCxcbiAgICAgIG9uQ2hhbmdlOiBub29wLFxuICAgICAgb25DbGVhcjogbm9vcFxuICAgIH07XG4gIH0sXG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24gc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcykge1xuICAgIHJldHVybiB0aGlzLnByb3BzLnZpc2libGUgfHwgbmV4dFByb3BzLnZpc2libGU7XG4gIH0sXG4gIGdldEZvcm1hdHRlcjogZnVuY3Rpb24gZ2V0Rm9ybWF0dGVyKCkge1xuICAgIHZhciBmb3JtYXR0ZXIgPSB0aGlzLnByb3BzLmZvcm1hdHRlcjtcbiAgICB2YXIgbG9jYWxlID0gdGhpcy5wcm9wcy5sb2NhbGU7XG4gICAgaWYgKHRoaXMubm9ybWFsRm9ybWF0dGVyICYmIGZvcm1hdHRlciA9PT0gdGhpcy5sYXN0Rm9ybWF0dGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub3JtYWxGb3JtYXR0ZXI7XG4gICAgfVxuICAgIHRoaXMubm9ybWFsRm9ybWF0dGVyID0gKDAsIF9pbmRleC5nZXRGb3JtYXR0ZXIpKGZvcm1hdHRlciwgbG9jYWxlKTtcbiAgICB0aGlzLmxhc3RGb3JtYXR0ZXIgPSBmb3JtYXR0ZXI7XG4gICAgcmV0dXJuIHRoaXMubm9ybWFsRm9ybWF0dGVyO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9taXhpbi9Db21tb25NaXhpbi5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9lbl9VUyA9IHJlcXVpcmUoJ2dyZWdvcmlhbi1jYWxlbmRhci1mb3JtYXQvbGliL2xvY2FsZS9lbl9VUycpO1xuXG52YXIgX2VuX1VTMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VuX1VTKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0ge1xuICB0b2RheTogJ1RvZGF5JyxcbiAgbm93OiAnTm93JyxcbiAgb2s6ICdPaycsXG4gIGNsZWFyOiAnQ2xlYXInLFxuICBtb250aDogJ01vbnRoJyxcbiAgeWVhcjogJ1llYXInLFxuICBtb250aFNlbGVjdDogJ0Nob29zZSBhIG1vbnRoJyxcbiAgeWVhclNlbGVjdDogJ0Nob29zZSBhIHllYXInLFxuICBkZWNhZGVTZWxlY3Q6ICdDaG9vc2UgYSBkZWNhZGUnLFxuICB5ZWFyRm9ybWF0OiAneXl5eScsXG4gIGRhdGVGb3JtYXQ6ICdNL2QveXl5eScsXG4gIG1vbnRoRm9ybWF0OiAnTU1NTScsXG4gIG1vbnRoQmVmb3JlWWVhcjogdHJ1ZSxcbiAgcHJldmlvdXNNb250aDogJ1ByZXZpb3VzIG1vbnRoIChQYWdlVXApJyxcbiAgbmV4dE1vbnRoOiAnTmV4dCBtb250aCAoUGFnZURvd24pJyxcbiAgcHJldmlvdXNZZWFyOiAnTGFzdCB5ZWFyIChDb250cm9sICsgbGVmdCknLFxuICBuZXh0WWVhcjogJ05leHQgeWVhciAoQ29udHJvbCArIHJpZ2h0KScsXG4gIHByZXZpb3VzRGVjYWRlOiAnTGFzdCBkZWNhZGUnLFxuICBuZXh0RGVjYWRlOiAnTmV4dCBkZWNhZGUnLFxuICBwcmV2aW91c0NlbnR1cnk6ICdMYXN0IGNlbnR1cnknLFxuICBuZXh0Q2VudHVyeTogJ05leHQgY2VudHVyeScsXG4gIGZvcm1hdDogX2VuX1VTMltcImRlZmF1bHRcIl1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL2xvY2FsZS9lbl9VUy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JlYWN0RG9tID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBfcmVhY3REb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3REb20pO1xuXG52YXIgX2luZGV4ID0gcmVxdWlyZSgnLi4vdXRpbC9pbmRleCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gY29weVRpbWUodGFyZ2V0LCBzb3VyY2UpIHtcbiAgaWYgKHNvdXJjZSkge1xuICAgIHRhcmdldC5zZXRIb3VyT2ZEYXkoc291cmNlLmdldEhvdXJPZkRheSgpKTtcbiAgICB0YXJnZXQuc2V0TWludXRlcyhzb3VyY2UuZ2V0TWludXRlcygpKTtcbiAgICB0YXJnZXQuc2V0U2Vjb25kcyhzb3VyY2UuZ2V0U2Vjb25kcygpKTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG52YXIgRGF0ZUlucHV0ID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ0RhdGVJbnB1dCcsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgcHJlZml4Q2xzOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICB0aW1lUGlja2VyOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBkaXNhYmxlZFRpbWU6IF9yZWFjdC5Qcm9wVHlwZXMuYW55LFxuICAgIGZvcm1hdHRlcjogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgbG9jYWxlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBncmVnb3JpYW5DYWxlbmRhckxvY2FsZTogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgZGlzYWJsZWREYXRlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25DaGFuZ2U6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNsZWFyOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgcGxhY2Vob2xkZXI6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9uU2VsZWN0OiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgc2VsZWN0ZWRWYWx1ZTogX3JlYWN0LlByb3BUeXBlcy5vYmplY3RcbiAgfSxcblxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgICB2YXIgc2VsZWN0ZWRWYWx1ZSA9IHRoaXMucHJvcHMuc2VsZWN0ZWRWYWx1ZTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RyOiBzZWxlY3RlZFZhbHVlICYmIHRoaXMucHJvcHMuZm9ybWF0dGVyLmZvcm1hdChzZWxlY3RlZFZhbHVlKSB8fCAnJyxcbiAgICAgIGludmFsaWQ6IGZhbHNlXG4gICAgfTtcbiAgfSxcbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAvLyB3aGVuIHBvcHVwIHNob3csIGNsaWNrIGJvZHkgd2lsbCBjYWxsIHRoaXMsIGJ1ZyFcbiAgICB2YXIgc2VsZWN0ZWRWYWx1ZSA9IG5leHRQcm9wcy5zZWxlY3RlZFZhbHVlO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgc3RyOiBzZWxlY3RlZFZhbHVlICYmIG5leHRQcm9wcy5mb3JtYXR0ZXIuZm9ybWF0KHNlbGVjdGVkVmFsdWUpIHx8ICcnLFxuICAgICAgaW52YWxpZDogZmFsc2VcbiAgICB9KTtcbiAgfSxcbiAgb25JbnB1dENoYW5nZTogZnVuY3Rpb24gb25JbnB1dENoYW5nZShldmVudCkge1xuICAgIHZhciBzdHIgPSBldmVudC50YXJnZXQudmFsdWU7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBzdHI6IHN0clxuICAgIH0pO1xuICAgIHZhciB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgZGlzYWJsZWREYXRlID0gX3Byb3BzLmRpc2FibGVkRGF0ZTtcbiAgICB2YXIgZm9ybWF0dGVyID0gX3Byb3BzLmZvcm1hdHRlcjtcbiAgICB2YXIgZ3JlZ29yaWFuQ2FsZW5kYXJMb2NhbGUgPSBfcHJvcHMuZ3JlZ29yaWFuQ2FsZW5kYXJMb2NhbGU7XG4gICAgdmFyIG9uQ2hhbmdlID0gX3Byb3BzLm9uQ2hhbmdlO1xuXG4gICAgaWYgKHN0cikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFsdWUgPSBjb3B5VGltZShmb3JtYXR0ZXIucGFyc2Uoc3RyLCB7XG4gICAgICAgICAgbG9jYWxlOiBncmVnb3JpYW5DYWxlbmRhckxvY2FsZSxcbiAgICAgICAgICBvYmV5Q291bnQ6IHRydWVcbiAgICAgICAgfSksIHRoaXMucHJvcHMuc2VsZWN0ZWRWYWx1ZSk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBpbnZhbGlkOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgJiYgKCFkaXNhYmxlZERhdGUgfHwgIWRpc2FibGVkRGF0ZSh2YWx1ZSkpKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbFZhbHVlID0gdGhpcy5wcm9wcy5zZWxlY3RlZFZhbHVlO1xuICAgICAgICBpZiAob3JpZ2luYWxWYWx1ZSAmJiB2YWx1ZSkge1xuICAgICAgICAgIGlmIChvcmlnaW5hbFZhbHVlLmdldFRpbWUoKSAhPT0gdmFsdWUuZ2V0VGltZSgpKSB7XG4gICAgICAgICAgICBvbkNoYW5nZSh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG9yaWdpbmFsVmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgb25DaGFuZ2UodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBpbnZhbGlkOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uQ2hhbmdlKG51bGwpO1xuICAgIH1cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGludmFsaWQ6IGZhbHNlXG4gICAgfSk7XG4gIH0sXG4gIG9uQ2xlYXI6IGZ1bmN0aW9uIG9uQ2xlYXIoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBzdHI6ICcnXG4gICAgfSk7XG4gICAgdGhpcy5wcm9wcy5vbkNsZWFyKG51bGwpO1xuICB9LFxuICBnZXRSb290RE9NTm9kZTogZnVuY3Rpb24gZ2V0Um9vdERPTU5vZGUoKSB7XG4gICAgcmV0dXJuIF9yZWFjdERvbTJbXCJkZWZhdWx0XCJdLmZpbmRET01Ob2RlKHRoaXMpO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBfc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHZhciBpbnZhbGlkID0gX3N0YXRlLmludmFsaWQ7XG4gICAgdmFyIHN0ciA9IF9zdGF0ZS5zdHI7XG4gICAgdmFyIHNlbGVjdGVkVmFsdWUgPSBwcm9wcy5zZWxlY3RlZFZhbHVlO1xuICAgIHZhciBsb2NhbGUgPSBwcm9wcy5sb2NhbGU7XG4gICAgdmFyIHByZWZpeENscyA9IHByb3BzLnByZWZpeENscztcbiAgICB2YXIgcGxhY2Vob2xkZXIgPSBwcm9wcy5wbGFjZWhvbGRlcjtcbiAgICB2YXIgb25DaGFuZ2UgPSBwcm9wcy5vbkNoYW5nZTtcbiAgICB2YXIgdGltZVBpY2tlciA9IHByb3BzLnRpbWVQaWNrZXI7XG4gICAgdmFyIGRpc2FibGVkVGltZSA9IHByb3BzLmRpc2FibGVkVGltZTtcbiAgICB2YXIgZ3JlZ29yaWFuQ2FsZW5kYXJMb2NhbGUgPSBwcm9wcy5ncmVnb3JpYW5DYWxlbmRhckxvY2FsZTtcblxuICAgIHZhciBpbnZhbGlkQ2xhc3MgPSBpbnZhbGlkID8gcHJlZml4Q2xzICsgJy1pbnB1dC1pbnZhbGlkJyA6ICcnO1xuICAgIHZhciBkaXNhYmxlZFRpbWVDb25maWcgPSBkaXNhYmxlZFRpbWUgJiYgdGltZVBpY2tlciA/ICgwLCBfaW5kZXguZ2V0VGltZUNvbmZpZykoc2VsZWN0ZWRWYWx1ZSwgZGlzYWJsZWRUaW1lKSA6IG51bGw7XG4gICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnZGl2JyxcbiAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWlucHV0LXdyYXAnIH0sXG4gICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctdGltZS1waWNrZXItd3JhcCcgfSxcbiAgICAgICAgdGltZVBpY2tlciA/IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNsb25lRWxlbWVudCh0aW1lUGlja2VyLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgc2hvd0NsZWFyOiBmYWxzZSxcbiAgICAgICAgICBhbGxvd0VtcHR5OiBmYWxzZSxcbiAgICAgICAgICBnZXRQb3B1cENvbnRhaW5lcjogdGhpcy5nZXRSb290RE9NTm9kZSxcbiAgICAgICAgICBncmVnb3JpYW5DYWxlbmRhckxvY2FsZTogZ3JlZ29yaWFuQ2FsZW5kYXJMb2NhbGUsXG4gICAgICAgICAgdmFsdWU6IHNlbGVjdGVkVmFsdWUsXG4gICAgICAgICAgb25DaGFuZ2U6IG9uQ2hhbmdlXG4gICAgICAgIH0sIGRpc2FibGVkVGltZUNvbmZpZykpIDogbnVsbFxuICAgICAgKSxcbiAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdkaXYnLFxuICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1kYXRlLWlucHV0LXdyYXAnIH0sXG4gICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jywge1xuICAgICAgICAgIGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1pbnB1dCAgJyArIGludmFsaWRDbGFzcyxcbiAgICAgICAgICB2YWx1ZTogc3RyLFxuICAgICAgICAgIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlcixcbiAgICAgICAgICBvbkNoYW5nZTogdGhpcy5vbklucHV0Q2hhbmdlXG4gICAgICAgIH0pXG4gICAgICApLFxuICAgICAgcHJvcHMuc2hvd0NsZWFyID8gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudCgnYScsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWNsZWFyLWJ0bicsXG4gICAgICAgIHJvbGU6ICdidXR0b24nLFxuICAgICAgICB0aXRsZTogbG9jYWxlLmNsZWFyLFxuICAgICAgICBvbkNsaWNrOiB0aGlzLm9uQ2xlYXJcbiAgICAgIH0pIDogbnVsbFxuICAgICk7XG4gIH1cbn0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IERhdGVJbnB1dDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9saWIvZGF0ZS9EYXRlSW5wdXQuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yZWFjdERvbSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgX3JlYWN0RG9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0RG9tKTtcblxudmFyIF9yY1V0aWwgPSByZXF1aXJlKCdyYy11dGlsJyk7XG5cbnZhciBfcGxhY2VtZW50cyA9IHJlcXVpcmUoJy4vcGlja2VyL3BsYWNlbWVudHMnKTtcblxudmFyIF9wbGFjZW1lbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BsYWNlbWVudHMpO1xuXG52YXIgX3JjVHJpZ2dlciA9IHJlcXVpcmUoJ3JjLXRyaWdnZXInKTtcblxudmFyIF9yY1RyaWdnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmNUcmlnZ2VyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiByZWZGbihmaWVsZCwgY29tcG9uZW50KSB7XG4gIHRoaXNbZmllbGRdID0gY29tcG9uZW50O1xufVxuXG52YXIgUGlja2VyID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1BpY2tlcicsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgYW5pbWF0aW9uOiBfcmVhY3QuUHJvcFR5cGVzLm9uZU9mVHlwZShbX3JlYWN0LlByb3BUeXBlcy5mdW5jLCBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZ10pLFxuICAgIGRpc2FibGVkOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgdHJhbnNpdGlvbk5hbWU6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9uQ2hhbmdlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25PcGVuOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25DbG9zZTogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIGNoaWxkcmVuOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgZ2V0Q2FsZW5kYXJDb250YWluZXI6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBjYWxlbmRhcjogX3JlYWN0LlByb3BUeXBlcy5lbGVtZW50LFxuICAgIHN0eWxlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBvcGVuOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgZGVmYXVsdE9wZW46IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBwcmVmaXhDbHM6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHBsYWNlbWVudDogX3JlYWN0LlByb3BUeXBlcy5hbnksXG4gICAgdmFsdWU6IF9yZWFjdC5Qcm9wVHlwZXMub25lT2ZUeXBlKFtfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCwgX3JlYWN0LlByb3BUeXBlcy5hcnJheV0pLFxuICAgIGRlZmF1bHRWYWx1ZTogX3JlYWN0LlByb3BUeXBlcy5vbmVPZlR5cGUoW19yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LCBfcmVhY3QuUHJvcFR5cGVzLmFycmF5XSksXG4gICAgYWxpZ246IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0XG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiBnZXREZWZhdWx0UHJvcHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByZWZpeENsczogJ3JjLWNhbGVuZGFyLXBpY2tlcicsXG4gICAgICBzdHlsZToge30sXG4gICAgICBhbGlnbjoge30sXG4gICAgICBwbGFjZW1lbnQ6ICdib3R0b21MZWZ0JyxcbiAgICAgIGRlZmF1bHRPcGVuOiBmYWxzZSxcbiAgICAgIG9uQ2hhbmdlOiBub29wLFxuICAgICAgb25PcGVuOiBub29wLFxuICAgICAgb25DbG9zZTogbm9vcFxuICAgIH07XG4gIH0sXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIG9wZW4gPSB1bmRlZmluZWQ7XG4gICAgaWYgKCdvcGVuJyBpbiBwcm9wcykge1xuICAgICAgb3BlbiA9IHByb3BzLm9wZW47XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wZW4gPSBwcm9wcy5kZWZhdWx0T3BlbjtcbiAgICB9XG4gICAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWUgfHwgcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIHRoaXMuc2F2ZUNhbGVuZGFyUmVmID0gcmVmRm4uYmluZCh0aGlzLCAnY2FsZW5kYXJJbnN0YW5jZScpO1xuICAgIHJldHVybiB7XG4gICAgICBvcGVuOiBvcGVuLFxuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfTtcbiAgfSxcbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICB2YXIgdmFsdWUgPSBuZXh0UHJvcHMudmFsdWU7XG4gICAgdmFyIG9wZW4gPSBuZXh0UHJvcHMub3BlbjtcblxuICAgIGlmICgndmFsdWUnIGluIG5leHRQcm9wcykge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChvcGVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBvcGVuOiBvcGVuXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIG9uQ2FsZW5kYXJLZXlEb3duOiBmdW5jdGlvbiBvbkNhbGVuZGFyS2V5RG93bihldmVudCkge1xuICAgIGlmIChldmVudC5rZXlDb2RlID09PSBfcmNVdGlsLktleUNvZGUuRVNDKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIHRoaXMuY2xvc2UodGhpcy5mb2N1cyk7XG4gICAgfVxuICB9LFxuICBvbkNhbGVuZGFyU2VsZWN0OiBmdW5jdGlvbiBvbkNhbGVuZGFyU2VsZWN0KHZhbHVlKSB7XG4gICAgdmFyIGNhdXNlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIGlmICghKCd2YWx1ZScgaW4gcHJvcHMpKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFwcm9wcy5jYWxlbmRhci5wcm9wcy50aW1lUGlja2VyICYmIGNhdXNlLnNvdXJjZSAhPT0gJ2RhdGVJbnB1dCcpIHtcbiAgICAgIHRoaXMuY2xvc2UodGhpcy5mb2N1cyk7XG4gICAgfVxuICAgIHByb3BzLm9uQ2hhbmdlKHZhbHVlKTtcbiAgfSxcbiAgb25DYWxlbmRhck9rOiBmdW5jdGlvbiBvbkNhbGVuZGFyT2soKSB7XG4gICAgdGhpcy5jbG9zZSh0aGlzLmZvY3VzKTtcbiAgfSxcbiAgb25DYWxlbmRhckNsZWFyOiBmdW5jdGlvbiBvbkNhbGVuZGFyQ2xlYXIoKSB7XG4gICAgdGhpcy5jbG9zZSh0aGlzLmZvY3VzKTtcbiAgfSxcbiAgb25WaXNpYmxlQ2hhbmdlOiBmdW5jdGlvbiBvblZpc2libGVDaGFuZ2Uob3Blbikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLnNldE9wZW4ob3BlbiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgX3JlYWN0RG9tMltcImRlZmF1bHRcIl0uZmluZERPTU5vZGUoX3RoaXMuY2FsZW5kYXJJbnN0YW5jZSkuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgZ2V0Q2FsZW5kYXJFbGVtZW50OiBmdW5jdGlvbiBnZXRDYWxlbmRhckVsZW1lbnQoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHZhciBjYWxlbmRhclByb3AgPSBwcm9wcy5jYWxlbmRhcjtcbiAgICB2YXIgdmFsdWUgPSBzdGF0ZS52YWx1ZTtcblxuICAgIHZhciBkZWZhdWx0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgLy8gUmFuZ2VDYWxlbmRhclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgZGVmYXVsdFZhbHVlID0gdmFsdWVbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmF1bHRWYWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICB2YXIgZXh0cmFQcm9wcyA9IHtcbiAgICAgIHJlZjogdGhpcy5zYXZlQ2FsZW5kYXJSZWYsXG4gICAgICBkZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZSB8fCBjYWxlbmRhclByb3AucHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgZGVmYXVsdFNlbGVjdGVkVmFsdWU6IHZhbHVlLFxuICAgICAgb25LZXlEb3duOiB0aGlzLm9uQ2FsZW5kYXJLZXlEb3duLFxuICAgICAgb25PazogKDAsIF9yY1V0aWwuY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKShjYWxlbmRhclByb3AucHJvcHMub25PaywgdGhpcy5vbkNhbGVuZGFyT2spLFxuICAgICAgb25TZWxlY3Q6ICgwLCBfcmNVdGlsLmNyZWF0ZUNoYWluZWRGdW5jdGlvbikoY2FsZW5kYXJQcm9wLnByb3BzLm9uU2VsZWN0LCB0aGlzLm9uQ2FsZW5kYXJTZWxlY3QpLFxuICAgICAgb25DbGVhcjogKDAsIF9yY1V0aWwuY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKShjYWxlbmRhclByb3AucHJvcHMub25DbGVhciwgdGhpcy5vbkNhbGVuZGFyQ2xlYXIpXG4gICAgfTtcblxuICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jbG9uZUVsZW1lbnQoY2FsZW5kYXJQcm9wLCBleHRyYVByb3BzKTtcbiAgfSxcbiAgc2V0T3BlbjogZnVuY3Rpb24gc2V0T3BlbihvcGVuLCBjYWxsYmFjaykge1xuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBvbk9wZW4gPSBfcHJvcHMub25PcGVuO1xuICAgIHZhciBvbkNsb3NlID0gX3Byb3BzLm9uQ2xvc2U7XG5cbiAgICBpZiAodGhpcy5zdGF0ZS5vcGVuICE9PSBvcGVuKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgb3Blbjogb3BlblxuICAgICAgfSwgY2FsbGJhY2spO1xuICAgICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICBvcGVuOiBvcGVuXG4gICAgICB9O1xuICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgb25PcGVuKGV2ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uQ2xvc2UoZXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgb3BlbjogZnVuY3Rpb24gb3BlbihjYWxsYmFjaykge1xuICAgIHRoaXMuc2V0T3Blbih0cnVlLCBjYWxsYmFjayk7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiBjbG9zZShjYWxsYmFjaykge1xuICAgIHRoaXMuc2V0T3BlbihmYWxzZSwgY2FsbGJhY2spO1xuICB9LFxuICBmb2N1czogZnVuY3Rpb24gZm9jdXMoKSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLm9wZW4pIHtcbiAgICAgIF9yZWFjdERvbTJbXCJkZWZhdWx0XCJdLmZpbmRET01Ob2RlKHRoaXMpLmZvY3VzKCk7XG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBwcmVmaXhDbHMgPSBwcm9wcy5wcmVmaXhDbHM7XG4gICAgdmFyIHBsYWNlbWVudCA9IHByb3BzLnBsYWNlbWVudDtcbiAgICB2YXIgc3R5bGUgPSBwcm9wcy5zdHlsZTtcbiAgICB2YXIgZ2V0Q2FsZW5kYXJDb250YWluZXIgPSBwcm9wcy5nZXRDYWxlbmRhckNvbnRhaW5lcjtcbiAgICB2YXIgYWxpZ24gPSBwcm9wcy5hbGlnbjtcbiAgICB2YXIgYW5pbWF0aW9uID0gcHJvcHMuYW5pbWF0aW9uO1xuICAgIHZhciBkaXNhYmxlZCA9IHByb3BzLmRpc2FibGVkO1xuICAgIHZhciB0cmFuc2l0aW9uTmFtZSA9IHByb3BzLnRyYW5zaXRpb25OYW1lO1xuICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuXG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgIF9yY1RyaWdnZXIyW1wiZGVmYXVsdFwiXSxcbiAgICAgIHtcbiAgICAgICAgcG9wdXA6IHRoaXMuZ2V0Q2FsZW5kYXJFbGVtZW50KCksXG4gICAgICAgIHBvcHVwQWxpZ246IGFsaWduLFxuICAgICAgICBidWlsdGluUGxhY2VtZW50czogX3BsYWNlbWVudHMyW1wiZGVmYXVsdFwiXSxcbiAgICAgICAgcG9wdXBQbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgICAgYWN0aW9uOiBkaXNhYmxlZCA/IFtdIDogWydjbGljayddLFxuICAgICAgICBkZXN0cm95UG9wdXBPbkhpZGU6IHRydWUsXG4gICAgICAgIGdldFBvcHVwQ29udGFpbmVyOiBnZXRDYWxlbmRhckNvbnRhaW5lcixcbiAgICAgICAgcG9wdXBTdHlsZTogc3R5bGUsXG4gICAgICAgIHBvcHVwQW5pbWF0aW9uOiBhbmltYXRpb24sXG4gICAgICAgIHBvcHVwVHJhbnNpdGlvbk5hbWU6IHRyYW5zaXRpb25OYW1lLFxuICAgICAgICBwb3B1cFZpc2libGU6IHN0YXRlLm9wZW4sXG4gICAgICAgIG9uUG9wdXBWaXNpYmxlQ2hhbmdlOiB0aGlzLm9uVmlzaWJsZUNoYW5nZSxcbiAgICAgICAgcHJlZml4Q2xzOiBwcmVmaXhDbHNcbiAgICAgIH0sXG4gICAgICBjaGlsZHJlbihzdGF0ZSwgcHJvcHMpXG4gICAgKTtcbiAgfVxufSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUGlja2VyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9QaWNrZXIuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgYXV0b0FkanVzdE92ZXJmbG93ID0ge1xuICBhZGp1c3RYOiAxLFxuICBhZGp1c3RZOiAxXG59O1xuXG52YXIgdGFyZ2V0T2Zmc2V0ID0gWzAsIDBdO1xuXG52YXIgcGxhY2VtZW50cyA9IHtcbiAgYm90dG9tTGVmdDoge1xuICAgIHBvaW50czogWyd0bCcsICd0bCddLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3csXG4gICAgb2Zmc2V0OiBbMCwgLTNdLFxuICAgIHRhcmdldE9mZnNldDogdGFyZ2V0T2Zmc2V0XG4gIH0sXG4gIGJvdHRvbVJpZ2h0OiB7XG4gICAgcG9pbnRzOiBbJ3RyJywgJ3RyJ10sXG4gICAgb3ZlcmZsb3c6IGF1dG9BZGp1c3RPdmVyZmxvdyxcbiAgICBvZmZzZXQ6IFswLCAtM10sXG4gICAgdGFyZ2V0T2Zmc2V0OiB0YXJnZXRPZmZzZXRcbiAgfSxcbiAgdG9wUmlnaHQ6IHtcbiAgICBwb2ludHM6IFsnYnInLCAnYnInXSxcbiAgICBvdmVyZmxvdzogYXV0b0FkanVzdE92ZXJmbG93LFxuICAgIG9mZnNldDogWzAsIDNdLFxuICAgIHRhcmdldE9mZnNldDogdGFyZ2V0T2Zmc2V0XG4gIH0sXG4gIHRvcExlZnQ6IHtcbiAgICBwb2ludHM6IFsnYmwnLCAnYmwnXSxcbiAgICBvdmVyZmxvdzogYXV0b0FkanVzdE92ZXJmbG93LFxuICAgIG9mZnNldDogWzAsIDNdLFxuICAgIHRhcmdldE9mZnNldDogdGFyZ2V0T2Zmc2V0XG4gIH1cbn07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gcGxhY2VtZW50cztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9saWIvcGlja2VyL3BsYWNlbWVudHMuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIFJFX05VTSA9IC9bXFwtK10/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bXFwtK10/XFxkK3wpLy5zb3VyY2U7XG5cbnZhciBnZXRDb21wdXRlZFN0eWxlWCA9IHVuZGVmaW5lZDtcblxuZnVuY3Rpb24gY3NzKGVsLCBuYW1lLCB2KSB7XG4gIHZhciB2YWx1ZSA9IHY7XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKHZhciBpIGluIG5hbWUpIHtcbiAgICAgIGlmIChuYW1lLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgIGNzcyhlbCwgaSwgbmFtZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZSArICdweCc7XG4gICAgfVxuICAgIGVsLnN0eWxlW25hbWVdID0gdmFsdWU7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZVgoZWwsIG5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRDbGllbnRQb3NpdGlvbihlbGVtKSB7XG4gIHZhciBib3ggPSB1bmRlZmluZWQ7XG4gIHZhciB4ID0gdW5kZWZpbmVkO1xuICB2YXIgeSA9IHVuZGVmaW5lZDtcbiAgdmFyIGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcbiAgdmFyIGJvZHkgPSBkb2MuYm9keTtcbiAgdmFyIGRvY0VsZW0gPSBkb2MgJiYgZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgLy8g5qC55o2uIEdCUyDmnIDmlrDmlbDmja7vvIxBLUdyYWRlIEJyb3dzZXJzIOmDveW3suaUr+aMgSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qg5pa55rOV77yM5LiN55So5YaN6ICD6JmR5Lyg57uf55qE5a6e546w5pa55byPXG4gIGJveCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgLy8g5rOo77yaalF1ZXJ5IOi/mOiAg+iZkeWHj+WOuyBkb2NFbGVtLmNsaWVudExlZnQvY2xpZW50VG9wXG4gIC8vIOS9hua1i+ivleWPkeeOsO+8jOi/meagt+WPjeiAjOS8muWvvOiHtOW9kyBodG1sIOWSjCBib2R5IOaciei+uei3nS/ovrnmoYbmoLflvI/ml7bvvIzojrflj5bnmoTlgLzkuI3mraPnoa5cbiAgLy8g5q2k5aSW77yMaWU2IOS8muW/veeVpSBodG1sIOeahCBtYXJnaW4g5YC877yM5bm46L+Q5Zyw5piv5rKh5pyJ6LCB5Lya5Y676K6+572uIGh0bWwg55qEIG1hcmdpblxuXG4gIHggPSBib3gubGVmdDtcbiAgeSA9IGJveC50b3A7XG5cbiAgLy8gSW4gSUUsIG1vc3Qgb2YgdGhlIHRpbWUsIDIgZXh0cmEgcGl4ZWxzIGFyZSBhZGRlZCB0byB0aGUgdG9wIGFuZCBsZWZ0XG4gIC8vIGR1ZSB0byB0aGUgaW1wbGljaXQgMi1waXhlbCBpbnNldCBib3JkZXIuICBJbiBJRTYvNyBxdWlya3MgbW9kZSBhbmRcbiAgLy8gSUU2IHN0YW5kYXJkcyBtb2RlLCB0aGlzIGJvcmRlciBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIHRoZVxuICAvLyBkb2N1bWVudCBlbGVtZW50J3MgYm9yZGVyIHRvIHplcm8gLS0gdGh1cywgd2UgY2Fubm90IHJlbHkgb24gdGhlXG4gIC8vIG9mZnNldCBhbHdheXMgYmVpbmcgMiBwaXhlbHMuXG5cbiAgLy8gSW4gcXVpcmtzIG1vZGUsIHRoZSBvZmZzZXQgY2FuIGJlIGRldGVybWluZWQgYnkgcXVlcnlpbmcgdGhlIGJvZHknc1xuICAvLyBjbGllbnRMZWZ0L2NsaWVudFRvcCwgYnV0IGluIHN0YW5kYXJkcyBtb2RlLCBpdCBpcyBmb3VuZCBieSBxdWVyeWluZ1xuICAvLyB0aGUgZG9jdW1lbnQgZWxlbWVudCdzIGNsaWVudExlZnQvY2xpZW50VG9wLiAgU2luY2Ugd2UgYWxyZWFkeSBjYWxsZWRcbiAgLy8gZ2V0Q2xpZW50Qm91bmRpbmdSZWN0IHdlIGhhdmUgYWxyZWFkeSBmb3JjZWQgYSByZWZsb3csIHNvIGl0IGlzIG5vdFxuICAvLyB0b28gZXhwZW5zaXZlIGp1c3QgdG8gcXVlcnkgdGhlbSBhbGwuXG5cbiAgLy8gaWUg5LiL5bqU6K+l5YeP5Y6756qX5Y+j55qE6L655qGG5ZCn77yM5q+V56uf6buY6K6kIGFic29sdXRlIOmDveaYr+ebuOWvueeql+WPo+WumuS9jeeahFxuICAvLyDnqpflj6PovrnmoYbmoIflh4bmmK/orr4gZG9jdW1lbnRFbGVtZW50ICxxdWlya3Mg5pe26K6+572uIGJvZHlcbiAgLy8g5pyA5aW956aB5q2i5ZyoIGJvZHkg5ZKMIGh0bWwg5LiK6L655qGGIO+8jOS9hiBpZSA8IDkgaHRtbCDpu5jorqTmnIkgMnB4IO+8jOWHj+WOu1xuICAvLyDkvYbmmK/pnZ4gaWUg5LiN5Y+v6IO96K6+572u56qX5Y+j6L655qGG77yMYm9keSBodG1sIOS5n+S4jeaYr+eql+WPoyAsaWUg5Y+v5Lul6YCa6L+HIGh0bWwsYm9keSDorr7nva5cbiAgLy8g5qCH5YeGIGllIOS4iyBkb2NFbGVtLmNsaWVudFRvcCDlsLHmmK8gYm9yZGVyLXRvcFxuICAvLyBpZTcgaHRtbCDljbPnqpflj6PovrnmoYbmlLnlj5jkuI3kuobjgILmsLjov5zkuLogMlxuICAvLyDkvYbmoIflh4YgZmlyZWZveC9jaHJvbWUvaWU5IOS4iyBkb2NFbGVtLmNsaWVudFRvcCDmmK/nqpflj6PovrnmoYbvvIzljbPkvb/orr7kuoYgYm9yZGVyLXRvcCDkuZ/kuLogMFxuXG4gIHggLT0gZG9jRWxlbS5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCB8fCAwO1xuICB5IC09IGRvY0VsZW0uY2xpZW50VG9wIHx8IGJvZHkuY2xpZW50VG9wIHx8IDA7XG5cbiAgcmV0dXJuIHsgbGVmdDogeCwgdG9wOiB5IH07XG59XG5cbmZ1bmN0aW9uIGdldFNjcm9sbCh3LCB0b3ApIHtcbiAgdmFyIHJldCA9IHdbJ3BhZ2UnICsgKHRvcCA/ICdZJyA6ICdYJykgKyAnT2Zmc2V0J107XG4gIHZhciBtZXRob2QgPSAnc2Nyb2xsJyArICh0b3AgPyAnVG9wJyA6ICdMZWZ0Jyk7XG4gIGlmICh0eXBlb2YgcmV0ICE9PSAnbnVtYmVyJykge1xuICAgIHZhciBkID0gdy5kb2N1bWVudDtcbiAgICAvLyBpZTYsNyw4IHN0YW5kYXJkIG1vZGVcbiAgICByZXQgPSBkLmRvY3VtZW50RWxlbWVudFttZXRob2RdO1xuICAgIGlmICh0eXBlb2YgcmV0ICE9PSAnbnVtYmVyJykge1xuICAgICAgLy8gcXVpcmtzIG1vZGVcbiAgICAgIHJldCA9IGQuYm9keVttZXRob2RdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxMZWZ0KHcpIHtcbiAgcmV0dXJuIGdldFNjcm9sbCh3KTtcbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsVG9wKHcpIHtcbiAgcmV0dXJuIGdldFNjcm9sbCh3LCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2V0T2Zmc2V0KGVsKSB7XG4gIHZhciBwb3MgPSBnZXRDbGllbnRQb3NpdGlvbihlbCk7XG4gIHZhciBkb2MgPSBlbC5vd25lckRvY3VtZW50O1xuICB2YXIgdyA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICBwb3MubGVmdCArPSBnZXRTY3JvbGxMZWZ0KHcpO1xuICBwb3MudG9wICs9IGdldFNjcm9sbFRvcCh3KTtcbiAgcmV0dXJuIHBvcztcbn1cbmZ1bmN0aW9uIF9nZXRDb21wdXRlZFN0eWxlKGVsZW0sIG5hbWUsIGNzKSB7XG4gIHZhciBjb21wdXRlZFN0eWxlID0gY3M7XG4gIHZhciB2YWwgPSAnJztcbiAgdmFyIGQgPSBlbGVtLm93bmVyRG9jdW1lbnQ7XG4gIGNvbXB1dGVkU3R5bGUgPSBjb21wdXRlZFN0eWxlIHx8IGQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtLCBudWxsKTtcblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20va2lzc3l0ZWFtL2tpc3N5L2lzc3Vlcy82MVxuICBpZiAoY29tcHV0ZWRTdHlsZSkge1xuICAgIHZhbCA9IGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKSB8fCBjb21wdXRlZFN0eWxlW25hbWVdO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxudmFyIF9SRV9OVU1fTk9fUFggPSBuZXcgUmVnRXhwKCdeKCcgKyBSRV9OVU0gKyAnKSg/IXB4KVthLXolXSskJywgJ2knKTtcbnZhciBSRV9QT1MgPSAvXih0b3B8cmlnaHR8Ym90dG9tfGxlZnQpJC87XG52YXIgQ1VSUkVOVF9TVFlMRSA9ICdjdXJyZW50U3R5bGUnO1xudmFyIFJVTlRJTUVfU1RZTEUgPSAncnVudGltZVN0eWxlJztcbnZhciBMRUZUID0gJ2xlZnQnO1xudmFyIFBYID0gJ3B4JztcblxuZnVuY3Rpb24gX2dldENvbXB1dGVkU3R5bGVJRShlbGVtLCBuYW1lKSB7XG4gIC8vIGN1cnJlbnRTdHlsZSBtYXliZSBudWxsXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNTIzMS5hc3B4XG4gIHZhciByZXQgPSBlbGVtW0NVUlJFTlRfU1RZTEVdICYmIGVsZW1bQ1VSUkVOVF9TVFlMRV1bbmFtZV07XG5cbiAgLy8g5b2TIHdpZHRoL2hlaWdodCDorr7nva7kuLrnmb7liIbmr5Tml7bvvIzpgJrov4cgcGl4ZWxMZWZ0IOaWueW8j+i9rOaNoueahCB3aWR0aC9oZWlnaHQg5YC8XG4gIC8vIOS4gOW8gOWni+WwseWkhOeQhuS6hiEgQ1VTVE9NX1NUWUxFLmhlaWdodCxDVVNUT01fU1RZTEUud2lkdGggLGNzc0hvb2sg6Kej5YazQDIwMTEtMDgtMTlcbiAgLy8g5ZyoIGllIOS4i+S4jeWvue+8jOmcgOimgeebtOaOpeeUqCBvZmZzZXQg5pa55byPXG4gIC8vIGJvcmRlcldpZHRoIOetieWAvOS5n+aciemXrumimO+8jOS9huiAg+iZkeWIsCBib3JkZXJXaWR0aCDorr7kuLrnmb7liIbmr5TnmoTmpoLnjoflvojlsI/vvIzov5nph4zlsLHkuI3ogIPomZHkuoZcblxuICAvLyBGcm9tIHRoZSBhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXG4gIC8vIGh0dHA6Ly9lcmlrLmVhZS5uZXQvYXJjaGl2ZXMvMjAwNy8wNy8yNy8xOC41NC4xNS8jY29tbWVudC0xMDIyOTFcbiAgLy8gSWYgd2UncmUgbm90IGRlYWxpbmcgd2l0aCBhIHJlZ3VsYXIgcGl4ZWwgbnVtYmVyXG4gIC8vIGJ1dCBhIG51bWJlciB0aGF0IGhhcyBhIHdlaXJkIGVuZGluZywgd2UgbmVlZCB0byBjb252ZXJ0IGl0IHRvIHBpeGVsc1xuICAvLyBleGNsdWRlIGxlZnQgcmlnaHQgZm9yIHJlbGF0aXZpdHlcbiAgaWYgKF9SRV9OVU1fTk9fUFgudGVzdChyZXQpICYmICFSRV9QT1MudGVzdChuYW1lKSkge1xuICAgIC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcbiAgICB2YXIgc3R5bGUgPSBlbGVtLnN0eWxlO1xuICAgIHZhciBsZWZ0ID0gc3R5bGVbTEVGVF07XG4gICAgdmFyIHJzTGVmdCA9IGVsZW1bUlVOVElNRV9TVFlMRV1bTEVGVF07XG5cbiAgICAvLyBwcmV2ZW50IGZsYXNoaW5nIG9mIGNvbnRlbnRcbiAgICBlbGVtW1JVTlRJTUVfU1RZTEVdW0xFRlRdID0gZWxlbVtDVVJSRU5UX1NUWUxFXVtMRUZUXTtcblxuICAgIC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcbiAgICBzdHlsZVtMRUZUXSA9IG5hbWUgPT09ICdmb250U2l6ZScgPyAnMWVtJyA6IHJldCB8fCAwO1xuICAgIHJldCA9IHN0eWxlLnBpeGVsTGVmdCArIFBYO1xuXG4gICAgLy8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuICAgIHN0eWxlW0xFRlRdID0gbGVmdDtcblxuICAgIGVsZW1bUlVOVElNRV9TVFlMRV1bTEVGVF0gPSByc0xlZnQ7XG4gIH1cbiAgcmV0dXJuIHJldCA9PT0gJycgPyAnYXV0bycgOiByZXQ7XG59XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBnZXRDb21wdXRlZFN0eWxlWCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlID8gX2dldENvbXB1dGVkU3R5bGUgOiBfZ2V0Q29tcHV0ZWRTdHlsZUlFO1xufVxuXG5mdW5jdGlvbiBnZXRPZmZzZXREaXJlY3Rpb24oZGlyLCBvcHRpb24pIHtcbiAgaWYgKGRpciA9PT0gJ2xlZnQnKSB7XG4gICAgcmV0dXJuIG9wdGlvbi51c2VDc3NSaWdodCA/ICdyaWdodCcgOiBkaXI7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbi51c2VDc3NCb3R0b20gPyAnYm90dG9tJyA6IGRpcjtcbn1cblxuZnVuY3Rpb24gb3Bwb3NpdGVPZmZzZXREaXJlY3Rpb24oZGlyKSB7XG4gIGlmIChkaXIgPT09ICdsZWZ0Jykge1xuICAgIHJldHVybiAncmlnaHQnO1xuICB9IGVsc2UgaWYgKGRpciA9PT0gJ3JpZ2h0Jykge1xuICAgIHJldHVybiAnbGVmdCc7XG4gIH0gZWxzZSBpZiAoZGlyID09PSAndG9wJykge1xuICAgIHJldHVybiAnYm90dG9tJztcbiAgfSBlbHNlIGlmIChkaXIgPT09ICdib3R0b20nKSB7XG4gICAgcmV0dXJuICd0b3AnO1xuICB9XG59XG5cbi8vIOiuvue9riBlbGVtIOebuOWvuSBlbGVtLm93bmVyRG9jdW1lbnQg55qE5Z2Q5qCHXG5mdW5jdGlvbiBzZXRPZmZzZXQoZWxlbSwgb2Zmc2V0LCBvcHRpb24pIHtcbiAgLy8gc2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxuICBpZiAoY3NzKGVsZW0sICdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuICAgIGVsZW0uc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICB9XG4gIHZhciBwcmVzZXRIID0gLTk5OTtcbiAgdmFyIHByZXNldFYgPSAtOTk5O1xuICB2YXIgaG9yaXpvbnRhbFByb3BlcnR5ID0gZ2V0T2Zmc2V0RGlyZWN0aW9uKCdsZWZ0Jywgb3B0aW9uKTtcbiAgdmFyIHZlcnRpY2FsUHJvcGVydHkgPSBnZXRPZmZzZXREaXJlY3Rpb24oJ3RvcCcsIG9wdGlvbik7XG4gIHZhciBvcHBvc2l0ZUhvcml6b250YWxQcm9wZXJ0eSA9IG9wcG9zaXRlT2Zmc2V0RGlyZWN0aW9uKGhvcml6b250YWxQcm9wZXJ0eSk7XG4gIHZhciBvcHBvc2l0ZVZlcnRpY2FsUHJvcGVydHkgPSBvcHBvc2l0ZU9mZnNldERpcmVjdGlvbih2ZXJ0aWNhbFByb3BlcnR5KTtcblxuICBpZiAoaG9yaXpvbnRhbFByb3BlcnR5ICE9PSAnbGVmdCcpIHtcbiAgICBwcmVzZXRIID0gOTk5O1xuICB9XG5cbiAgaWYgKHZlcnRpY2FsUHJvcGVydHkgIT09ICd0b3AnKSB7XG4gICAgcHJlc2V0ViA9IDk5OTtcbiAgfVxuXG4gIGlmICgnbGVmdCcgaW4gb2Zmc2V0KSB7XG4gICAgZWxlbS5zdHlsZVtvcHBvc2l0ZUhvcml6b250YWxQcm9wZXJ0eV0gPSAnJztcbiAgICBlbGVtLnN0eWxlW2hvcml6b250YWxQcm9wZXJ0eV0gPSBwcmVzZXRIICsgJ3B4JztcbiAgfVxuICBpZiAoJ3RvcCcgaW4gb2Zmc2V0KSB7XG4gICAgZWxlbS5zdHlsZVtvcHBvc2l0ZVZlcnRpY2FsUHJvcGVydHldID0gJyc7XG4gICAgZWxlbS5zdHlsZVt2ZXJ0aWNhbFByb3BlcnR5XSA9IHByZXNldFYgKyAncHgnO1xuICB9XG4gIHZhciBvbGQgPSBnZXRPZmZzZXQoZWxlbSk7XG4gIHZhciByZXQgPSB7fTtcbiAgdmFyIGtleSA9IHVuZGVmaW5lZDtcbiAgZm9yIChrZXkgaW4gb2Zmc2V0KSB7XG4gICAgaWYgKG9mZnNldC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICB2YXIgZGlyID0gZ2V0T2Zmc2V0RGlyZWN0aW9uKGtleSwgb3B0aW9uKTtcbiAgICAgIHZhciBwcmVzZXQgPSBrZXkgPT09ICdsZWZ0JyA/IHByZXNldEggOiBwcmVzZXRWO1xuICAgICAgaWYgKGRpciA9PT0ga2V5KSB7XG4gICAgICAgIHJldFtkaXJdID0gcHJlc2V0ICsgb2Zmc2V0W2tleV0gLSBvbGRba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldFtkaXJdID0gcHJlc2V0ICsgb2xkW2tleV0gLSBvZmZzZXRba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY3NzKGVsZW0sIHJldCk7XG59XG5cbmZ1bmN0aW9uIGVhY2goYXJyLCBmbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGZuKGFycltpXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNCb3JkZXJCb3hGbihlbGVtKSB7XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlWChlbGVtLCAnYm94U2l6aW5nJykgPT09ICdib3JkZXItYm94Jztcbn1cblxudmFyIEJPWF9NT0RFTFMgPSBbJ21hcmdpbicsICdib3JkZXInLCAncGFkZGluZyddO1xudmFyIENPTlRFTlRfSU5ERVggPSAtMTtcbnZhciBQQURESU5HX0lOREVYID0gMjtcbnZhciBCT1JERVJfSU5ERVggPSAxO1xudmFyIE1BUkdJTl9JTkRFWCA9IDA7XG5cbmZ1bmN0aW9uIHN3YXAoZWxlbSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIG9sZCA9IHt9O1xuICB2YXIgc3R5bGUgPSBlbGVtLnN0eWxlO1xuICB2YXIgbmFtZSA9IHVuZGVmaW5lZDtcblxuICAvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcbiAgZm9yIChuYW1lIGluIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgb2xkW25hbWVdID0gc3R5bGVbbmFtZV07XG4gICAgICBzdHlsZVtuYW1lXSA9IG9wdGlvbnNbbmFtZV07XG4gICAgfVxuICB9XG5cbiAgY2FsbGJhY2suY2FsbChlbGVtKTtcblxuICAvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcbiAgZm9yIChuYW1lIGluIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgc3R5bGVbbmFtZV0gPSBvbGRbbmFtZV07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFBCTVdpZHRoKGVsZW0sIHByb3BzLCB3aGljaCkge1xuICB2YXIgdmFsdWUgPSAwO1xuICB2YXIgcHJvcCA9IHVuZGVmaW5lZDtcbiAgdmFyIGogPSB1bmRlZmluZWQ7XG4gIHZhciBpID0gdW5kZWZpbmVkO1xuICBmb3IgKGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKyspIHtcbiAgICBwcm9wID0gcHJvcHNbal07XG4gICAgaWYgKHByb3ApIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB3aGljaC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY3NzUHJvcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHByb3AgPT09ICdib3JkZXInKSB7XG4gICAgICAgICAgY3NzUHJvcCA9IHByb3AgKyB3aGljaFtpXSArICdXaWR0aCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3NzUHJvcCA9IHByb3AgKyB3aGljaFtpXTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSArPSBwYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGVYKGVsZW0sIGNzc1Byb3ApKSB8fCAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQSBjcnVkZSB3YXkgb2YgZGV0ZXJtaW5pbmcgaWYgYW4gb2JqZWN0IGlzIGEgd2luZG93XG4gKiBAbWVtYmVyIHV0aWxcbiAqL1xuZnVuY3Rpb24gaXNXaW5kb3cob2JqKSB7XG4gIC8vIG11c3QgdXNlID09IGZvciBpZThcbiAgLyogZXNsaW50IGVxZXFlcTowICovXG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgb2JqICE9PSB1bmRlZmluZWQgJiYgb2JqID09IG9iai53aW5kb3c7XG59XG5cbnZhciBkb21VdGlscyA9IHt9O1xuXG5lYWNoKFsnV2lkdGgnLCAnSGVpZ2h0J10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRvbVV0aWxzWydkb2MnICsgbmFtZV0gPSBmdW5jdGlvbiAocmVmV2luKSB7XG4gICAgdmFyIGQgPSByZWZXaW4uZG9jdW1lbnQ7XG4gICAgcmV0dXJuIE1hdGgubWF4KFxuICAgIC8vIGZpcmVmb3ggY2hyb21lIGRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQ8IGJvZHkuc2Nyb2xsSGVpZ2h0XG4gICAgLy8gaWUgc3RhbmRhcmQgbW9kZSA6IGRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQ+IGJvZHkuc2Nyb2xsSGVpZ2h0XG4gICAgZC5kb2N1bWVudEVsZW1lbnRbJ3Njcm9sbCcgKyBuYW1lXSxcbiAgICAvLyBxdWlya3MgOiBkb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0IOacgOWkp+etieS6juWPr+inhueql+WPo+WkmuS4gOeCue+8n1xuICAgIGQuYm9keVsnc2Nyb2xsJyArIG5hbWVdLCBkb21VdGlsc1sndmlld3BvcnQnICsgbmFtZV0oZCkpO1xuICB9O1xuXG4gIGRvbVV0aWxzWyd2aWV3cG9ydCcgKyBuYW1lXSA9IGZ1bmN0aW9uICh3aW4pIHtcbiAgICAvLyBwYyBicm93c2VyIGluY2x1ZGVzIHNjcm9sbGJhciBpbiB3aW5kb3cuaW5uZXJXaWR0aFxuICAgIHZhciBwcm9wID0gJ2NsaWVudCcgKyBuYW1lO1xuICAgIHZhciBkb2MgPSB3aW4uZG9jdW1lbnQ7XG4gICAgdmFyIGJvZHkgPSBkb2MuYm9keTtcbiAgICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICB2YXIgZG9jdW1lbnRFbGVtZW50UHJvcCA9IGRvY3VtZW50RWxlbWVudFtwcm9wXTtcbiAgICAvLyDmoIflh4bmqKHlvI/lj5YgZG9jdW1lbnRFbGVtZW50XG4gICAgLy8gYmFja2NvbXBhdCDlj5YgYm9keVxuICAgIHJldHVybiBkb2MuY29tcGF0TW9kZSA9PT0gJ0NTUzFDb21wYXQnICYmIGRvY3VtZW50RWxlbWVudFByb3AgfHwgYm9keSAmJiBib2R5W3Byb3BdIHx8IGRvY3VtZW50RWxlbWVudFByb3A7XG4gIH07XG59KTtcblxuLypcbiDlvpfliLDlhYPntKDnmoTlpKflsI/kv6Hmga9cbiBAcGFyYW0gZWxlbVxuIEBwYXJhbSBuYW1lXG4gQHBhcmFtIHtTdHJpbmd9IFtleHRyYV0gICdwYWRkaW5nJyA6IChjc3Mgd2lkdGgpICsgcGFkZGluZ1xuICdib3JkZXInIDogKGNzcyB3aWR0aCkgKyBwYWRkaW5nICsgYm9yZGVyXG4gJ21hcmdpbicgOiAoY3NzIHdpZHRoKSArIHBhZGRpbmcgKyBib3JkZXIgKyBtYXJnaW5cbiAqL1xuZnVuY3Rpb24gZ2V0V0goZWxlbSwgbmFtZSwgZXgpIHtcbiAgdmFyIGV4dHJhID0gZXg7XG4gIGlmIChpc1dpbmRvdyhlbGVtKSkge1xuICAgIHJldHVybiBuYW1lID09PSAnd2lkdGgnID8gZG9tVXRpbHMudmlld3BvcnRXaWR0aChlbGVtKSA6IGRvbVV0aWxzLnZpZXdwb3J0SGVpZ2h0KGVsZW0pO1xuICB9IGVsc2UgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDkpIHtcbiAgICByZXR1cm4gbmFtZSA9PT0gJ3dpZHRoJyA/IGRvbVV0aWxzLmRvY1dpZHRoKGVsZW0pIDogZG9tVXRpbHMuZG9jSGVpZ2h0KGVsZW0pO1xuICB9XG4gIHZhciB3aGljaCA9IG5hbWUgPT09ICd3aWR0aCcgPyBbJ0xlZnQnLCAnUmlnaHQnXSA6IFsnVG9wJywgJ0JvdHRvbSddO1xuICB2YXIgYm9yZGVyQm94VmFsdWUgPSBuYW1lID09PSAnd2lkdGgnID8gZWxlbS5vZmZzZXRXaWR0aCA6IGVsZW0ub2Zmc2V0SGVpZ2h0O1xuICB2YXIgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGVYKGVsZW0pO1xuICB2YXIgaXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveEZuKGVsZW0sIGNvbXB1dGVkU3R5bGUpO1xuICB2YXIgY3NzQm94VmFsdWUgPSAwO1xuICBpZiAoYm9yZGVyQm94VmFsdWUgPT09IG51bGwgfHwgYm9yZGVyQm94VmFsdWUgPT09IHVuZGVmaW5lZCB8fCBib3JkZXJCb3hWYWx1ZSA8PSAwKSB7XG4gICAgYm9yZGVyQm94VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgLy8gRmFsbCBiYWNrIHRvIGNvbXB1dGVkIHRoZW4gdW4gY29tcHV0ZWQgY3NzIGlmIG5lY2Vzc2FyeVxuICAgIGNzc0JveFZhbHVlID0gZ2V0Q29tcHV0ZWRTdHlsZVgoZWxlbSwgbmFtZSk7XG4gICAgaWYgKGNzc0JveFZhbHVlID09PSBudWxsIHx8IGNzc0JveFZhbHVlID09PSB1bmRlZmluZWQgfHwgTnVtYmVyKGNzc0JveFZhbHVlKSA8IDApIHtcbiAgICAgIGNzc0JveFZhbHVlID0gZWxlbS5zdHlsZVtuYW1lXSB8fCAwO1xuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgJycsIGF1dG8sIGFuZCBwcmVwYXJlIGZvciBleHRyYVxuICAgIGNzc0JveFZhbHVlID0gcGFyc2VGbG9hdChjc3NCb3hWYWx1ZSkgfHwgMDtcbiAgfVxuICBpZiAoZXh0cmEgPT09IHVuZGVmaW5lZCkge1xuICAgIGV4dHJhID0gaXNCb3JkZXJCb3ggPyBCT1JERVJfSU5ERVggOiBDT05URU5UX0lOREVYO1xuICB9XG4gIHZhciBib3JkZXJCb3hWYWx1ZU9ySXNCb3JkZXJCb3ggPSBib3JkZXJCb3hWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IGlzQm9yZGVyQm94O1xuICB2YXIgdmFsID0gYm9yZGVyQm94VmFsdWUgfHwgY3NzQm94VmFsdWU7XG4gIGlmIChleHRyYSA9PT0gQ09OVEVOVF9JTkRFWCkge1xuICAgIGlmIChib3JkZXJCb3hWYWx1ZU9ySXNCb3JkZXJCb3gpIHtcbiAgICAgIHJldHVybiB2YWwgLSBnZXRQQk1XaWR0aChlbGVtLCBbJ2JvcmRlcicsICdwYWRkaW5nJ10sIHdoaWNoLCBjb21wdXRlZFN0eWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNzc0JveFZhbHVlO1xuICB9IGVsc2UgaWYgKGJvcmRlckJveFZhbHVlT3JJc0JvcmRlckJveCkge1xuICAgIGlmIChleHRyYSA9PT0gQk9SREVSX0lOREVYKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gdmFsICsgKGV4dHJhID09PSBQQURESU5HX0lOREVYID8gLWdldFBCTVdpZHRoKGVsZW0sIFsnYm9yZGVyJ10sIHdoaWNoLCBjb21wdXRlZFN0eWxlKSA6IGdldFBCTVdpZHRoKGVsZW0sIFsnbWFyZ2luJ10sIHdoaWNoLCBjb21wdXRlZFN0eWxlKSk7XG4gIH1cbiAgcmV0dXJuIGNzc0JveFZhbHVlICsgZ2V0UEJNV2lkdGgoZWxlbSwgQk9YX01PREVMUy5zbGljZShleHRyYSksIHdoaWNoLCBjb21wdXRlZFN0eWxlKTtcbn1cblxudmFyIGNzc1Nob3cgPSB7IHBvc2l0aW9uOiAnYWJzb2x1dGUnLCB2aXNpYmlsaXR5OiAnaGlkZGVuJywgZGlzcGxheTogJ2Jsb2NrJyB9O1xuXG4vLyBmaXggIzExOSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9raXNzeXRlYW0va2lzc3kvaXNzdWVzLzExOVxuZnVuY3Rpb24gZ2V0V0hJZ25vcmVEaXNwbGF5KCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICB2YXIgdmFsID0gdW5kZWZpbmVkO1xuICB2YXIgZWxlbSA9IGFyZ3NbMF07XG4gIC8vIGluIGNhc2UgZWxlbSBpcyB3aW5kb3dcbiAgLy8gZWxlbS5vZmZzZXRXaWR0aCA9PT0gdW5kZWZpbmVkXG4gIGlmIChlbGVtLm9mZnNldFdpZHRoICE9PSAwKSB7XG4gICAgdmFsID0gZ2V0V0guYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICBzd2FwKGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhbCA9IGdldFdILmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn1cblxuZWFjaChbJ3dpZHRoJywgJ2hlaWdodCddLCBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgZmlyc3QgPSBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKTtcbiAgZG9tVXRpbHNbJ291dGVyJyArIGZpcnN0XSA9IGZ1bmN0aW9uIChlbCwgaW5jbHVkZU1hcmdpbikge1xuICAgIHJldHVybiBlbCAmJiBnZXRXSElnbm9yZURpc3BsYXkoZWwsIG5hbWUsIGluY2x1ZGVNYXJnaW4gPyBNQVJHSU5fSU5ERVggOiBCT1JERVJfSU5ERVgpO1xuICB9O1xuICB2YXIgd2hpY2ggPSBuYW1lID09PSAnd2lkdGgnID8gWydMZWZ0JywgJ1JpZ2h0J10gOiBbJ1RvcCcsICdCb3R0b20nXTtcblxuICBkb21VdGlsc1tuYW1lXSA9IGZ1bmN0aW9uIChlbGVtLCB2KSB7XG4gICAgdmFyIHZhbCA9IHY7XG4gICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZWxlbSkge1xuICAgICAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGVYKGVsZW0pO1xuICAgICAgICB2YXIgaXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveEZuKGVsZW0pO1xuICAgICAgICBpZiAoaXNCb3JkZXJCb3gpIHtcbiAgICAgICAgICB2YWwgKz0gZ2V0UEJNV2lkdGgoZWxlbSwgWydwYWRkaW5nJywgJ2JvcmRlciddLCB3aGljaCwgY29tcHV0ZWRTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNzcyhlbGVtLCBuYW1lLCB2YWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW0gJiYgZ2V0V0hJZ25vcmVEaXNwbGF5KGVsZW0sIG5hbWUsIENPTlRFTlRfSU5ERVgpO1xuICB9O1xufSk7XG5cbmZ1bmN0aW9uIG1peCh0bywgZnJvbSkge1xuICBmb3IgKHZhciBpIGluIGZyb20pIHtcbiAgICBpZiAoZnJvbS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgdG9baV0gPSBmcm9tW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG87XG59XG5cbnZhciB1dGlscyA9IHtcbiAgZ2V0V2luZG93OiBmdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICAgIGlmIChub2RlICYmIG5vZGUuZG9jdW1lbnQgJiYgbm9kZS5zZXRUaW1lb3V0KSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgdmFyIGRvYyA9IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlO1xuICAgIHJldHVybiBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgfSxcbiAgb2Zmc2V0OiBmdW5jdGlvbiBvZmZzZXQoZWwsIHZhbHVlLCBvcHRpb24pIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgc2V0T2Zmc2V0KGVsLCB2YWx1ZSwgb3B0aW9uIHx8IHt9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdldE9mZnNldChlbCk7XG4gICAgfVxuICB9LFxuICBpc1dpbmRvdzogaXNXaW5kb3csXG4gIGVhY2g6IGVhY2gsXG4gIGNzczogY3NzLFxuICBjbG9uZTogZnVuY3Rpb24gY2xvbmUob2JqKSB7XG4gICAgdmFyIGkgPSB1bmRlZmluZWQ7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgcmV0W2ldID0gb2JqW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgb3ZlcmZsb3cgPSBvYmoub3ZlcmZsb3c7XG4gICAgaWYgKG92ZXJmbG93KSB7XG4gICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICByZXQub3ZlcmZsb3dbaV0gPSBvYmoub3ZlcmZsb3dbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcbiAgbWl4OiBtaXgsXG4gIGdldFdpbmRvd1Njcm9sbExlZnQ6IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbExlZnQodykge1xuICAgIHJldHVybiBnZXRTY3JvbGxMZWZ0KHcpO1xuICB9LFxuICBnZXRXaW5kb3dTY3JvbGxUb3A6IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbFRvcCh3KSB7XG4gICAgcmV0dXJuIGdldFNjcm9sbFRvcCh3KTtcbiAgfSxcbiAgbWVyZ2U6IGZ1bmN0aW9uIG1lcmdlKCkge1xuICAgIHZhciByZXQgPSB7fTtcblxuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB1dGlscy5taXgocmV0LCBhcmdzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcbiAgdmlld3BvcnRXaWR0aDogMCxcbiAgdmlld3BvcnRIZWlnaHQ6IDBcbn07XG5cbm1peCh1dGlscywgZG9tVXRpbHMpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSB1dGlscztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9+L3JjLXRyaWdnZXIvfi9yYy1hbGlnbi9+L2RvbS1hbGlnbi9saWIvdXRpbHMuanNcbiAqKi8iLCIvKipcbiAqIOiOt+WPliBub2RlIOS4iueahCBhbGlnbiDlr7npvZDngrkg55u45a+55LqO6aG16Z2i55qE5Z2Q5qCHXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmZ1bmN0aW9uIGdldEFsaWduT2Zmc2V0KHJlZ2lvbiwgYWxpZ24pIHtcbiAgdmFyIFYgPSBhbGlnbi5jaGFyQXQoMCk7XG4gIHZhciBIID0gYWxpZ24uY2hhckF0KDEpO1xuICB2YXIgdyA9IHJlZ2lvbi53aWR0aDtcbiAgdmFyIGggPSByZWdpb24uaGVpZ2h0O1xuICB2YXIgeCA9IHVuZGVmaW5lZDtcbiAgdmFyIHkgPSB1bmRlZmluZWQ7XG5cbiAgeCA9IHJlZ2lvbi5sZWZ0O1xuICB5ID0gcmVnaW9uLnRvcDtcblxuICBpZiAoViA9PT0gJ2MnKSB7XG4gICAgeSArPSBoIC8gMjtcbiAgfSBlbHNlIGlmIChWID09PSAnYicpIHtcbiAgICB5ICs9IGg7XG4gIH1cblxuICBpZiAoSCA9PT0gJ2MnKSB7XG4gICAgeCArPSB3IC8gMjtcbiAgfSBlbHNlIGlmIChIID09PSAncicpIHtcbiAgICB4ICs9IHc7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxlZnQ6IHgsXG4gICAgdG9wOiB5XG4gIH07XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGdldEFsaWduT2Zmc2V0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL34vcmMtdHJpZ2dlci9+L3JjLWFsaWduL34vZG9tLWFsaWduL2xpYi9nZXRBbGlnbk9mZnNldC5qc1xuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBpc1dpbmRvdztcblxuZnVuY3Rpb24gaXNXaW5kb3cob2JqKSB7XG4gIC8qIGVzbGludCBuby1lcS1udWxsOiAwICovXG4gIC8qIGVzbGludCBlcWVxZXE6IDAgKi9cbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PSBvYmoud2luZG93O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9+L3JjLXRyaWdnZXIvfi9yYy1hbGlnbi9saWIvaXNXaW5kb3cuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy50b0FycmF5Q2hpbGRyZW4gPSB0b0FycmF5Q2hpbGRyZW47XG5leHBvcnRzLmZpbmRDaGlsZEluQ2hpbGRyZW5CeUtleSA9IGZpbmRDaGlsZEluQ2hpbGRyZW5CeUtleTtcbmV4cG9ydHMuZmluZFNob3duQ2hpbGRJbkNoaWxkcmVuQnlLZXkgPSBmaW5kU2hvd25DaGlsZEluQ2hpbGRyZW5CeUtleTtcbmV4cG9ydHMuZmluZEhpZGRlbkNoaWxkSW5DaGlsZHJlbkJ5S2V5ID0gZmluZEhpZGRlbkNoaWxkSW5DaGlsZHJlbkJ5S2V5O1xuZXhwb3J0cy5pc1NhbWVDaGlsZHJlbiA9IGlzU2FtZUNoaWxkcmVuO1xuZXhwb3J0cy5tZXJnZUNoaWxkcmVuID0gbWVyZ2VDaGlsZHJlbjtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbmZ1bmN0aW9uIHRvQXJyYXlDaGlsZHJlbihjaGlsZHJlbikge1xuICB2YXIgcmV0ID0gW107XG4gIF9yZWFjdDJbJ2RlZmF1bHQnXS5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXQucHVzaChjaGlsZCk7XG4gIH0pO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBmaW5kQ2hpbGRJbkNoaWxkcmVuQnlLZXkoY2hpbGRyZW4sIGtleSkge1xuICB2YXIgcmV0ID0gbnVsbDtcbiAgaWYgKGNoaWxkcmVuKSB7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIHJldCA9IGNoaWxkO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGZpbmRTaG93bkNoaWxkSW5DaGlsZHJlbkJ5S2V5KGNoaWxkcmVuLCBrZXksIHNob3dQcm9wKSB7XG4gIHZhciByZXQgPSBudWxsO1xuICBpZiAoY2hpbGRyZW4pIHtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5ICYmIGNoaWxkLnByb3BzW3Nob3dQcm9wXSkge1xuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0d28gY2hpbGQgd2l0aCBzYW1lIGtleSBmb3IgPHJjLWFuaW1hdGU+IGNoaWxkcmVuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0ID0gY2hpbGQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZmluZEhpZGRlbkNoaWxkSW5DaGlsZHJlbkJ5S2V5KGNoaWxkcmVuLCBrZXksIHNob3dQcm9wKSB7XG4gIHZhciBmb3VuZCA9IDA7XG4gIGlmIChjaGlsZHJlbikge1xuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm91bmQgPSBjaGlsZC5rZXkgPT09IGtleSAmJiAhY2hpbGQucHJvcHNbc2hvd1Byb3BdO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBmb3VuZDtcbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGRyZW4oYzEsIGMyLCBzaG93UHJvcCkge1xuICB2YXIgc2FtZSA9IGMxLmxlbmd0aCA9PT0gYzIubGVuZ3RoO1xuICBpZiAoc2FtZSkge1xuICAgIGMxLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkLCBpbmRleCkge1xuICAgICAgdmFyIGNoaWxkMiA9IGMyW2luZGV4XTtcbiAgICAgIGlmIChjaGlsZC5rZXkgIT09IGNoaWxkMi5rZXkpIHtcbiAgICAgICAgc2FtZSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChzaG93UHJvcCAmJiBjaGlsZC5wcm9wc1tzaG93UHJvcF0gIT09IGNoaWxkMi5wcm9wc1tzaG93UHJvcF0pIHtcbiAgICAgICAgc2FtZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBzYW1lO1xufVxuXG5mdW5jdGlvbiBtZXJnZUNoaWxkcmVuKHByZXYsIG5leHQpIHtcbiAgdmFyIHJldCA9IFtdO1xuXG4gIC8vIEZvciBlYWNoIGtleSBvZiBgbmV4dGAsIHRoZSBsaXN0IG9mIGtleXMgdG8gaW5zZXJ0IGJlZm9yZSB0aGF0IGtleSBpblxuICAvLyB0aGUgY29tYmluZWQgbGlzdFxuICB2YXIgbmV4dENoaWxkcmVuUGVuZGluZyA9IHt9O1xuICB2YXIgcGVuZGluZ0NoaWxkcmVuID0gW107XG4gIHByZXYuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoZmluZENoaWxkSW5DaGlsZHJlbkJ5S2V5KG5leHQsIGNoaWxkLmtleSkpIHtcbiAgICAgIGlmIChwZW5kaW5nQ2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIG5leHRDaGlsZHJlblBlbmRpbmdbY2hpbGQua2V5XSA9IHBlbmRpbmdDaGlsZHJlbjtcbiAgICAgICAgcGVuZGluZ0NoaWxkcmVuID0gW107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlbmRpbmdDaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH0pO1xuXG4gIG5leHQuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAobmV4dENoaWxkcmVuUGVuZGluZy5oYXNPd25Qcm9wZXJ0eShjaGlsZC5rZXkpKSB7XG4gICAgICByZXQgPSByZXQuY29uY2F0KG5leHRDaGlsZHJlblBlbmRpbmdbY2hpbGQua2V5XSk7XG4gICAgfVxuICAgIHJldC5wdXNoKGNoaWxkKTtcbiAgfSk7XG5cbiAgcmV0ID0gcmV0LmNvbmNhdChwZW5kaW5nQ2hpbGRyZW4pO1xuXG4gIHJldHVybiByZXQ7XG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL34vcmMtdHJpZ2dlci9+L3JjLWFuaW1hdGUvbGliL0NoaWxkcmVuVXRpbHMuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgRVZFTlRfTkFNRV9NQVAgPSB7XG4gIHRyYW5zaXRpb25lbmQ6IHtcbiAgICB0cmFuc2l0aW9uOiAndHJhbnNpdGlvbmVuZCcsXG4gICAgV2Via2l0VHJhbnNpdGlvbjogJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxuICAgIE1velRyYW5zaXRpb246ICdtb3pUcmFuc2l0aW9uRW5kJyxcbiAgICBPVHJhbnNpdGlvbjogJ29UcmFuc2l0aW9uRW5kJyxcbiAgICBtc1RyYW5zaXRpb246ICdNU1RyYW5zaXRpb25FbmQnXG4gIH0sXG5cbiAgYW5pbWF0aW9uZW5kOiB7XG4gICAgYW5pbWF0aW9uOiAnYW5pbWF0aW9uZW5kJyxcbiAgICBXZWJraXRBbmltYXRpb246ICd3ZWJraXRBbmltYXRpb25FbmQnLFxuICAgIE1vekFuaW1hdGlvbjogJ21vekFuaW1hdGlvbkVuZCcsXG4gICAgT0FuaW1hdGlvbjogJ29BbmltYXRpb25FbmQnLFxuICAgIG1zQW5pbWF0aW9uOiAnTVNBbmltYXRpb25FbmQnXG4gIH1cbn07XG5cbnZhciBlbmRFdmVudHMgPSBbXTtcblxuZnVuY3Rpb24gZGV0ZWN0RXZlbnRzKCkge1xuICB2YXIgdGVzdEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHZhciBzdHlsZSA9IHRlc3RFbC5zdHlsZTtcblxuICBpZiAoISgnQW5pbWF0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgRVZFTlRfTkFNRV9NQVAuYW5pbWF0aW9uZW5kLmFuaW1hdGlvbjtcbiAgfVxuXG4gIGlmICghKCdUcmFuc2l0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgRVZFTlRfTkFNRV9NQVAudHJhbnNpdGlvbmVuZC50cmFuc2l0aW9uO1xuICB9XG5cbiAgZm9yICh2YXIgYmFzZUV2ZW50TmFtZSBpbiBFVkVOVF9OQU1FX01BUCkge1xuICAgIGlmIChFVkVOVF9OQU1FX01BUC5oYXNPd25Qcm9wZXJ0eShiYXNlRXZlbnROYW1lKSkge1xuICAgICAgdmFyIGJhc2VFdmVudHMgPSBFVkVOVF9OQU1FX01BUFtiYXNlRXZlbnROYW1lXTtcbiAgICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBiYXNlRXZlbnRzKSB7XG4gICAgICAgIGlmIChzdHlsZU5hbWUgaW4gc3R5bGUpIHtcbiAgICAgICAgICBlbmRFdmVudHMucHVzaChiYXNlRXZlbnRzW3N0eWxlTmFtZV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gIGRldGVjdEV2ZW50cygpO1xufVxuXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50TmFtZSwgZXZlbnRMaXN0ZW5lcikge1xuICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudExpc3RlbmVyLCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnROYW1lLCBldmVudExpc3RlbmVyKSB7XG4gIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50TGlzdGVuZXIsIGZhbHNlKTtcbn1cblxudmFyIFRyYW5zaXRpb25FdmVudHMgPSB7XG4gIGFkZEVuZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIGFkZEVuZEV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnRMaXN0ZW5lcikge1xuICAgIGlmIChlbmRFdmVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB3aW5kb3cuc2V0VGltZW91dChldmVudExpc3RlbmVyLCAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZW5kRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGVuZEV2ZW50KSB7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKG5vZGUsIGVuZEV2ZW50LCBldmVudExpc3RlbmVyKTtcbiAgICB9KTtcbiAgfSxcblxuXG4gIGVuZEV2ZW50czogZW5kRXZlbnRzLFxuXG4gIHJlbW92ZUVuZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIHJlbW92ZUVuZEV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnRMaXN0ZW5lcikge1xuICAgIGlmIChlbmRFdmVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVuZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbmRFdmVudCkge1xuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihub2RlLCBlbmRFdmVudCwgZXZlbnRMaXN0ZW5lcik7XG4gICAgfSk7XG4gIH1cbn07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gVHJhbnNpdGlvbkV2ZW50cztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9+L3JjLXRyaWdnZXIvfi9yYy1hbmltYXRlL34vY3NzLWFuaW1hdGlvbi9saWIvRXZlbnQuanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFyciwgb2JqKXtcbiAgaWYgKGFyci5pbmRleE9mKSByZXR1cm4gYXJyLmluZGV4T2Yob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYXJyW2ldID09PSBvYmopIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL34vcmMtdHJpZ2dlci9+L3JjLWFuaW1hdGUvfi9jc3MtYW5pbWF0aW9uL34vY29tcG9uZW50LWNsYXNzZXMvfi9jb21wb25lbnQtaW5kZXhvZi9pbmRleC5qc1xuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIHV0aWwgPSB7XG4gIGlzQXBwZWFyU3VwcG9ydGVkOiBmdW5jdGlvbiBpc0FwcGVhclN1cHBvcnRlZChwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy50cmFuc2l0aW9uTmFtZSAmJiBwcm9wcy50cmFuc2l0aW9uQXBwZWFyIHx8IHByb3BzLmFuaW1hdGlvbi5hcHBlYXI7XG4gIH0sXG4gIGlzRW50ZXJTdXBwb3J0ZWQ6IGZ1bmN0aW9uIGlzRW50ZXJTdXBwb3J0ZWQocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMudHJhbnNpdGlvbk5hbWUgJiYgcHJvcHMudHJhbnNpdGlvbkVudGVyIHx8IHByb3BzLmFuaW1hdGlvbi5lbnRlcjtcbiAgfSxcbiAgaXNMZWF2ZVN1cHBvcnRlZDogZnVuY3Rpb24gaXNMZWF2ZVN1cHBvcnRlZChwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy50cmFuc2l0aW9uTmFtZSAmJiBwcm9wcy50cmFuc2l0aW9uTGVhdmUgfHwgcHJvcHMuYW5pbWF0aW9uLmxlYXZlO1xuICB9LFxuXG4gIGFsbG93QXBwZWFyQ2FsbGJhY2s6IGZ1bmN0aW9uIGFsbG93QXBwZWFyQ2FsbGJhY2socHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMudHJhbnNpdGlvbkFwcGVhciB8fCBwcm9wcy5hbmltYXRpb24uYXBwZWFyO1xuICB9LFxuICBhbGxvd0VudGVyQ2FsbGJhY2s6IGZ1bmN0aW9uIGFsbG93RW50ZXJDYWxsYmFjayhwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy50cmFuc2l0aW9uRW50ZXIgfHwgcHJvcHMuYW5pbWF0aW9uLmVudGVyO1xuICB9LFxuICBhbGxvd0xlYXZlQ2FsbGJhY2s6IGZ1bmN0aW9uIGFsbG93TGVhdmVDYWxsYmFjayhwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy50cmFuc2l0aW9uTGVhdmUgfHwgcHJvcHMuYW5pbWF0aW9uLmxlYXZlO1xuICB9XG59O1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB1dGlsO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvfi9yYy10cmlnZ2VyL34vcmMtYW5pbWF0ZS9saWIvdXRpbC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxudmFyIExhenlSZW5kZXJCb3ggPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnTGF6eVJlbmRlckJveCcsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgY2hpbGRyZW46IF9yZWFjdC5Qcm9wVHlwZXMuYW55LFxuICAgIGNsYXNzTmFtZTogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgdmlzaWJsZTogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGhpZGRlbkNsYXNzTmFtZTogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmdcbiAgfSxcbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiBmdW5jdGlvbiBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzKSB7XG4gICAgcmV0dXJuIG5leHRQcm9wcy5oaWRkZW5DbGFzc05hbWUgfHwgbmV4dFByb3BzLnZpc2libGU7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLnByb3BzLmhpZGRlbkNsYXNzTmFtZSkge1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMucHJvcHMuY2xhc3NOYW1lO1xuICAgICAgaWYgKCF0aGlzLnByb3BzLnZpc2libGUpIHtcbiAgICAgICAgY2xhc3NOYW1lICs9ICcgJyArIHRoaXMucHJvcHMuaGlkZGVuQ2xhc3NOYW1lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoJ2RpdicsIF9leHRlbmRzKHt9LCB0aGlzLnByb3BzLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lIH0pKTtcbiAgICB9XG4gICAgaWYgKF9yZWFjdDJbXCJkZWZhdWx0XCJdLkNoaWxkcmVuLmNvdW50KHRoaXMucHJvcHMuY2hpbGRyZW4pID4gMSkge1xuICAgICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoJ2RpdicsIHRoaXMucHJvcHMpO1xuICAgIH1cbiAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uQ2hpbGRyZW4ub25seSh0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgfVxufSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gTGF6eVJlbmRlckJveDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9+L3JjLXRyaWdnZXIvbGliL0xhenlSZW5kZXJCb3guanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHMuZ2V0QWxpZ25Gcm9tUGxhY2VtZW50ID0gZ2V0QWxpZ25Gcm9tUGxhY2VtZW50O1xuZXhwb3J0cy5nZXRQb3B1cENsYXNzTmFtZUZyb21BbGlnbiA9IGdldFBvcHVwQ2xhc3NOYW1lRnJvbUFsaWduO1xuZnVuY3Rpb24gaXNQb2ludHNFcShhMSwgYTIpIHtcbiAgcmV0dXJuIGExWzBdID09PSBhMlswXSAmJiBhMVsxXSA9PT0gYTJbMV07XG59XG5cbmZ1bmN0aW9uIGdldEFsaWduRnJvbVBsYWNlbWVudChidWlsdGluUGxhY2VtZW50cywgcGxhY2VtZW50U3RyLCBhbGlnbikge1xuICB2YXIgYmFzZUFsaWduID0gYnVpbHRpblBsYWNlbWVudHNbcGxhY2VtZW50U3RyXSB8fCB7fTtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBiYXNlQWxpZ24sIGFsaWduKTtcbn1cblxuZnVuY3Rpb24gZ2V0UG9wdXBDbGFzc05hbWVGcm9tQWxpZ24oYnVpbHRpblBsYWNlbWVudHMsIHByZWZpeENscywgYWxpZ24pIHtcbiAgdmFyIHBvaW50cyA9IGFsaWduLnBvaW50cztcbiAgZm9yICh2YXIgcGxhY2VtZW50IGluIGJ1aWx0aW5QbGFjZW1lbnRzKSB7XG4gICAgaWYgKGJ1aWx0aW5QbGFjZW1lbnRzLmhhc093blByb3BlcnR5KHBsYWNlbWVudCkpIHtcbiAgICAgIGlmIChpc1BvaW50c0VxKGJ1aWx0aW5QbGFjZW1lbnRzW3BsYWNlbWVudF0ucG9pbnRzLCBwb2ludHMpKSB7XG4gICAgICAgIHJldHVybiBwcmVmaXhDbHMgKyAnLXBsYWNlbWVudC0nICsgcGxhY2VtZW50O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL34vcmMtdHJpZ2dlci9saWIvdXRpbHMuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9Nb250aFBhbmVsID0gcmVxdWlyZSgnLi9tb250aC9Nb250aFBhbmVsJyk7XG5cbnZhciBfTW9udGhQYW5lbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Nb250aFBhbmVsKTtcblxudmFyIF9DYWxlbmRhck1peGluID0gcmVxdWlyZSgnLi9taXhpbi9DYWxlbmRhck1peGluJyk7XG5cbnZhciBfQ2FsZW5kYXJNaXhpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DYWxlbmRhck1peGluKTtcblxudmFyIF9Db21tb25NaXhpbiA9IHJlcXVpcmUoJy4vbWl4aW4vQ29tbW9uTWl4aW4nKTtcblxudmFyIF9Db21tb25NaXhpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Db21tb25NaXhpbik7XG5cbnZhciBfcmNVdGlsID0gcmVxdWlyZSgncmMtdXRpbCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxudmFyIE1vbnRoQ2FsZW5kYXIgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnTW9udGhDYWxlbmRhcicsXG5cbiAgbWl4aW5zOiBbX0NvbW1vbk1peGluMltcImRlZmF1bHRcIl0sIF9DYWxlbmRhck1peGluMltcImRlZmF1bHRcIl1dLFxuXG4gIG9uS2V5RG93bjogZnVuY3Rpb24gb25LZXlEb3duKGV2ZW50KSB7XG4gICAgdmFyIGtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xuICAgIHZhciBjdHJsS2V5ID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5O1xuICAgIHZhciBzdGF0ZVZhbHVlID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICB2YXIgdmFsdWUgPSBzdGF0ZVZhbHVlO1xuICAgIHN3aXRjaCAoa2V5Q29kZSkge1xuICAgICAgY2FzZSBfcmNVdGlsLktleUNvZGUuRE9XTjpcbiAgICAgICAgdmFsdWUgPSBzdGF0ZVZhbHVlLmNsb25lKCk7XG4gICAgICAgIHZhbHVlLmFkZE1vbnRoKDMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX3JjVXRpbC5LZXlDb2RlLlVQOlxuICAgICAgICB2YWx1ZSA9IHN0YXRlVmFsdWUuY2xvbmUoKTtcbiAgICAgICAgdmFsdWUuYWRkTW9udGgoLTMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX3JjVXRpbC5LZXlDb2RlLkxFRlQ6XG4gICAgICAgIHZhbHVlID0gc3RhdGVWYWx1ZS5jbG9uZSgpO1xuICAgICAgICBpZiAoY3RybEtleSkge1xuICAgICAgICAgIHZhbHVlLmFkZFllYXIoLTEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlLmFkZE1vbnRoKC0xKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX3JjVXRpbC5LZXlDb2RlLlJJR0hUOlxuICAgICAgICB2YWx1ZSA9IHN0YXRlVmFsdWUuY2xvbmUoKTtcbiAgICAgICAgaWYgKGN0cmxLZXkpIHtcbiAgICAgICAgICB2YWx1ZS5hZGRZZWFyKDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlLmFkZE1vbnRoKDEpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfcmNVdGlsLktleUNvZGUuRU5URVI6XG4gICAgICAgIHRoaXMub25TZWxlY3Qoc3RhdGVWYWx1ZSk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHZhbHVlICE9PSBzdGF0ZVZhbHVlKSB7XG4gICAgICB0aGlzLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGNoaWxkcmVuID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfTW9udGhQYW5lbDJbXCJkZWZhdWx0XCJdLCB7XG4gICAgICBsb2NhbGU6IHByb3BzLmxvY2FsZSxcbiAgICAgIGRpc2FibGVkRGF0ZTogcHJvcHMuZGlzYWJsZWREYXRlLFxuICAgICAgc3R5bGU6IHsgcG9zaXRpb246ICdyZWxhdGl2ZScgfSxcbiAgICAgIHZhbHVlOiB0aGlzLnN0YXRlLnZhbHVlLFxuICAgICAgcm9vdFByZWZpeENsczogcHJvcHMucHJlZml4Q2xzLFxuICAgICAgb25DaGFuZ2U6IHRoaXMuc2V0VmFsdWUsXG4gICAgICBvblNlbGVjdDogdGhpcy5vblNlbGVjdFxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLnJlbmRlclJvb3Qoe1xuICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgfSk7XG4gIH1cbn0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IE1vbnRoQ2FsZW5kYXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL01vbnRoQ2FsZW5kYXIuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfWWVhclBhbmVsID0gcmVxdWlyZSgncmMtY2FsZW5kYXIvbGliL3llYXIvWWVhclBhbmVsJyk7XG5cbnZhciBfWWVhclBhbmVsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1llYXJQYW5lbCk7XG5cbnZhciBfQ2FsZW5kYXJNaXhpbiA9IHJlcXVpcmUoJ3JjLWNhbGVuZGFyL2xpYi9taXhpbi9DYWxlbmRhck1peGluJyk7XG5cbnZhciBfQ2FsZW5kYXJNaXhpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DYWxlbmRhck1peGluKTtcblxudmFyIF9Db21tb25NaXhpbiA9IHJlcXVpcmUoJ3JjLWNhbGVuZGFyL2xpYi9taXhpbi9Db21tb25NaXhpbicpO1xuXG52YXIgX0NvbW1vbk1peGluMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NvbW1vbk1peGluKTtcblxudmFyIF9yY1V0aWwgPSByZXF1aXJlKCdyYy11dGlsJyk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yZWFjdERvbSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgX3JlYWN0RG9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0RG9tKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbnZhciBZZWFyQ2FsZW5kYXIgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVDbGFzcyh7XG4gICAgZGlzcGxheU5hbWU6ICdZZWFyQ2FsZW5kYXInLFxuXG4gICAgbWl4aW5zOiBbX0NhbGVuZGFyTWl4aW4yW1wiZGVmYXVsdFwiXSwgX0NvbW1vbk1peGluMltcImRlZmF1bHRcIl1dLFxuXG4gICAgb25LZXlEb3duOiBmdW5jdGlvbiBvbktleURvd24oZSkge1xuICAgICAgICB2YXIga2V5Q29kZSA9IGUua2V5Q29kZTtcbiAgICAgICAgdmFyIGN0cmxLZXkgPSBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5O1xuICAgICAgICB2YXIgc3RhdGVWYWx1ZSA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgICAgIHZhciB2YWx1ZSA9IHN0YXRlVmFsdWU7XG4gICAgICAgIHN3aXRjaCAoa2V5Q29kZSkge1xuICAgICAgICAgICAgY2FzZSBfcmNVdGlsLktleUNvZGUuRE9XTjpcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHN0YXRlVmFsdWUuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICB2YWx1ZS5hZGRNb250aCgzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgX3JjVXRpbC5LZXlDb2RlLlVQOlxuICAgICAgICAgICAgICAgIHZhbHVlID0gc3RhdGVWYWx1ZS5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIHZhbHVlLmFkZE1vbnRoKC0zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgX3JjVXRpbC5LZXlDb2RlLkxFRlQ6XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBzdGF0ZVZhbHVlLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgaWYgKGN0cmxLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuYWRkWWVhcigtMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuYWRkTW9udGgoLTEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgX3JjVXRpbC5LZXlDb2RlLlJJR0hUOlxuICAgICAgICAgICAgICAgIHZhbHVlID0gc3RhdGVWYWx1ZS5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIGlmIChjdHJsS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmFkZFllYXIoMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuYWRkTW9udGgoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBfcmNVdGlsLktleUNvZGUuRU5URVI6XG4gICAgICAgICAgICAgICAgdGhpcy5vblNlbGVjdChzdGF0ZVZhbHVlKTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICE9PSBzdGF0ZVZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfWWVhclBhbmVsMltcImRlZmF1bHRcIl0sIHsgbG9jYWxlOiBwcm9wcy5sb2NhbGUsXG4gICAgICAgICAgICBkaXNhYmxlZERhdGU6IHByb3BzLmRpc2FibGVkRGF0ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnN0YXRlLnZhbHVlLFxuICAgICAgICAgICAgcm9vdFByZWZpeENsczogcHJvcHMucHJlZml4Q2xzLFxuICAgICAgICAgICAgb25DaGFuZ2U6IHRoaXMuc2V0VmFsdWUsXG4gICAgICAgICAgICBvblNlbGVjdDogdGhpcy5vblNlbGVjdCB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyUm9vdCh7XG4gICAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgICAgICBjbGFzc05hbWU6IHByb3BzLnByZWZpeENscyArICcteWVhci1jYWxlbmRhci1jb250YWluZXInXG5cbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gWWVhckNhbGVuZGFyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9idWlsZC9ZZWFyQ2FsZW5kYXIuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfVGltZVBpY2tlciA9IHJlcXVpcmUoJy4vVGltZVBpY2tlcicpO1xuXG52YXIgX1RpbWVQaWNrZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVGltZVBpY2tlcik7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IF9UaW1lUGlja2VyMlsnZGVmYXVsdCddO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmMtdGltZS1waWNrZXIvbGliL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gODhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JjVHJpZ2dlciA9IHJlcXVpcmUoJ3JjLXRyaWdnZXInKTtcblxudmFyIF9yY1RyaWdnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmNUcmlnZ2VyKTtcblxudmFyIF9tb2R1bGVQYW5lbCA9IHJlcXVpcmUoJy4vbW9kdWxlL1BhbmVsJyk7XG5cbnZhciBfbW9kdWxlUGFuZWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbW9kdWxlUGFuZWwpO1xuXG52YXIgX3V0aWxQbGFjZW1lbnRzID0gcmVxdWlyZSgnLi91dGlsL3BsYWNlbWVudHMnKTtcblxudmFyIF91dGlsUGxhY2VtZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlsUGxhY2VtZW50cyk7XG5cbnZhciBfbWl4aW5Db21tb25NaXhpbiA9IHJlcXVpcmUoJy4vbWl4aW4vQ29tbW9uTWl4aW4nKTtcblxudmFyIF9taXhpbkNvbW1vbk1peGluMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21peGluQ29tbW9uTWl4aW4pO1xuXG52YXIgX3V0aWxJbmRleCA9IHJlcXVpcmUoJy4vdXRpbC9pbmRleCcpO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gcmVmRm4oZmllbGQsIGNvbXBvbmVudCkge1xuICB0aGlzW2ZpZWxkXSA9IGNvbXBvbmVudDtcbn1cblxudmFyIFBpY2tlciA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUGlja2VyJyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBwcmVmaXhDbHM6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGxvY2FsZTogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgdmFsdWU6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIGRpc2FibGVkOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgYWxsb3dFbXB0eTogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGRlZmF1bHRWYWx1ZTogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgb3BlbjogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGRlZmF1bHRPcGVuOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgYWxpZ246IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIHBsYWNlbWVudDogX3JlYWN0LlByb3BUeXBlcy5hbnksXG4gICAgdHJhbnNpdGlvbk5hbWU6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGdldFBvcHVwQ29udGFpbmVyOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgcGxhY2Vob2xkZXI6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGZvcm1hdHRlcjogX3JlYWN0LlByb3BUeXBlcy5hbnksXG4gICAgc2hvd0hvdXI6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBzdHlsZTogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgY2xhc3NOYW1lOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBzaG93U2Vjb25kOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgZGlzYWJsZWRIb3VyczogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIGRpc2FibGVkTWludXRlczogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIGRpc2FibGVkU2Vjb25kczogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIGhpZGVEaXNhYmxlZE9wdGlvbnM6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBvbkNoYW5nZTogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uT3BlbjogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uQ2xvc2U6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuY1xuICB9LFxuXG4gIG1peGluczogW19taXhpbkNvbW1vbk1peGluMlsnZGVmYXVsdCddXSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGVmYXVsdE9wZW46IGZhbHNlLFxuICAgICAgc3R5bGU6IHt9LFxuICAgICAgY2xhc3NOYW1lOiAnJyxcbiAgICAgIGFsaWduOiB7fSxcbiAgICAgIGFsbG93RW1wdHk6IHRydWUsXG4gICAgICBzaG93SG91cjogdHJ1ZSxcbiAgICAgIHNob3dTZWNvbmQ6IHRydWUsXG4gICAgICBkaXNhYmxlZEhvdXJzOiBub29wLFxuICAgICAgZGlzYWJsZWRNaW51dGVzOiBub29wLFxuICAgICAgZGlzYWJsZWRTZWNvbmRzOiBub29wLFxuICAgICAgaGlkZURpc2FibGVkT3B0aW9uczogZmFsc2UsXG4gICAgICBwbGFjZW1lbnQ6ICdib3R0b21MZWZ0JyxcbiAgICAgIG9uQ2hhbmdlOiBub29wLFxuICAgICAgb25PcGVuOiBub29wLFxuICAgICAgb25DbG9zZTogbm9vcFxuICAgIH07XG4gIH0sXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgdGhpcy5zYXZlUGFuZWxSZWYgPSByZWZGbi5iaW5kKHRoaXMsICdwYW5lbEluc3RhbmNlJyk7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGRlZmF1bHRPcGVuID0gX3Byb3BzLmRlZmF1bHRPcGVuO1xuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBfcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIHZhciBfcHJvcHMkb3BlbiA9IF9wcm9wcy5vcGVuO1xuICAgIHZhciBvcGVuID0gX3Byb3BzJG9wZW4gPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRPcGVuIDogX3Byb3BzJG9wZW47XG4gICAgdmFyIF9wcm9wcyR2YWx1ZSA9IF9wcm9wcy52YWx1ZTtcbiAgICB2YXIgdmFsdWUgPSBfcHJvcHMkdmFsdWUgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IF9wcm9wcyR2YWx1ZTtcblxuICAgIHJldHVybiB7XG4gICAgICBvcGVuOiBvcGVuLFxuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfTtcbiAgfSxcblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIHZhciB2YWx1ZSA9IG5leHRQcm9wcy52YWx1ZTtcbiAgICB2YXIgb3BlbiA9IG5leHRQcm9wcy5vcGVuO1xuXG4gICAgaWYgKCd2YWx1ZScgaW4gbmV4dFByb3BzKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG9wZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IG9wZW46IG9wZW4gfSk7XG4gICAgfVxuICB9LFxuXG4gIG9uUGFuZWxDaGFuZ2U6IGZ1bmN0aW9uIG9uUGFuZWxDaGFuZ2UodmFsdWUpIHtcbiAgICB0aGlzLnNldFZhbHVlKHZhbHVlKTtcbiAgfSxcblxuICBvblBhbmVsQ2xlYXI6IGZ1bmN0aW9uIG9uUGFuZWxDbGVhcigpIHtcbiAgICB0aGlzLnNldFZhbHVlKG51bGwpO1xuICAgIHRoaXMuc2V0T3BlbihmYWxzZSk7XG4gIH0sXG5cbiAgb25WaXNpYmxlQ2hhbmdlOiBmdW5jdGlvbiBvblZpc2libGVDaGFuZ2Uob3Blbikge1xuICAgIHRoaXMuc2V0T3BlbihvcGVuKTtcbiAgfSxcblxuICBvbkVzYzogZnVuY3Rpb24gb25Fc2MoKSB7XG4gICAgdGhpcy5zZXRPcGVuKGZhbHNlKTtcbiAgICB0aGlzLnJlZnMucGlja2VyLmZvY3VzKCk7XG4gIH0sXG5cbiAgb25LZXlEb3duOiBmdW5jdGlvbiBvbktleURvd24oZSkge1xuICAgIGlmIChlLmtleUNvZGUgPT09IDQwKSB7XG4gICAgICB0aGlzLnNldE9wZW4odHJ1ZSk7XG4gICAgfVxuICB9LFxuXG4gIHNldFZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICghKCd2YWx1ZScgaW4gdGhpcy5wcm9wcykpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHZhbHVlKTtcbiAgfSxcblxuICBnZXRGb3JtYXR0ZXI6IGZ1bmN0aW9uIGdldEZvcm1hdHRlcigpIHtcbiAgICB2YXIgZm9ybWF0dGVyID0gdGhpcy5wcm9wcy5mb3JtYXR0ZXI7XG4gICAgdmFyIGxvY2FsZSA9IHRoaXMucHJvcHMubG9jYWxlO1xuICAgIGlmIChmb3JtYXR0ZXIpIHtcbiAgICAgIGlmIChmb3JtYXR0ZXIgPT09IHRoaXMubGFzdEZvcm1hdHRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWxGb3JtYXR0ZXI7XG4gICAgICB9XG4gICAgICB0aGlzLm5vcm1hbEZvcm1hdHRlciA9ICgwLCBfdXRpbEluZGV4LmdldEZvcm1hdHRlcikoZm9ybWF0dGVyLCBsb2NhbGUpO1xuICAgICAgdGhpcy5sYXN0Rm9ybWF0dGVyID0gZm9ybWF0dGVyO1xuICAgICAgcmV0dXJuIHRoaXMubm9ybWFsRm9ybWF0dGVyO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucHJvcHMuc2hvd1NlY29uZCkge1xuICAgICAgaWYgKCF0aGlzLm5vdFNob3dTZWNvbmRGb3JtYXR0ZXIpIHtcbiAgICAgICAgdGhpcy5ub3RTaG93U2Vjb25kRm9ybWF0dGVyID0gKDAsIF91dGlsSW5kZXguZ2V0Rm9ybWF0dGVyKSgnSEg6bW0nLCBsb2NhbGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubm90U2hvd1NlY29uZEZvcm1hdHRlcjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnByb3BzLnNob3dIb3VyKSB7XG4gICAgICBpZiAoIXRoaXMubm90U2hvd0hvdXJGb3JtYXR0ZXIpIHtcbiAgICAgICAgdGhpcy5ub3RTaG93SG91ckZvcm1hdHRlciA9ICgwLCBfdXRpbEluZGV4LmdldEZvcm1hdHRlcikoJ21tOnNzJywgbG9jYWxlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm5vdFNob3dIb3VyRm9ybWF0dGVyO1xuICAgIH1cbiAgICBpZiAoIXRoaXMubm9ybWFsRm9ybWF0dGVyKSB7XG4gICAgICB0aGlzLm5vcm1hbEZvcm1hdHRlciA9ICgwLCBfdXRpbEluZGV4LmdldEZvcm1hdHRlcikoJ0hIOm1tOnNzJywgbG9jYWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubm9ybWFsRm9ybWF0dGVyO1xuICB9LFxuXG4gIGdldFBhbmVsRWxlbWVudDogZnVuY3Rpb24gZ2V0UGFuZWxFbGVtZW50KCkge1xuICAgIHZhciBfcHJvcHMyID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcHJlZml4Q2xzID0gX3Byb3BzMi5wcmVmaXhDbHM7XG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IF9wcm9wczIuZGVmYXVsdFZhbHVlO1xuICAgIHZhciBsb2NhbGUgPSBfcHJvcHMyLmxvY2FsZTtcbiAgICB2YXIgcGxhY2Vob2xkZXIgPSBfcHJvcHMyLnBsYWNlaG9sZGVyO1xuICAgIHZhciBkaXNhYmxlZEhvdXJzID0gX3Byb3BzMi5kaXNhYmxlZEhvdXJzO1xuICAgIHZhciBkaXNhYmxlZE1pbnV0ZXMgPSBfcHJvcHMyLmRpc2FibGVkTWludXRlcztcbiAgICB2YXIgZGlzYWJsZWRTZWNvbmRzID0gX3Byb3BzMi5kaXNhYmxlZFNlY29uZHM7XG4gICAgdmFyIGhpZGVEaXNhYmxlZE9wdGlvbnMgPSBfcHJvcHMyLmhpZGVEaXNhYmxlZE9wdGlvbnM7XG4gICAgdmFyIGFsbG93RW1wdHkgPSBfcHJvcHMyLmFsbG93RW1wdHk7XG4gICAgdmFyIHNob3dIb3VyID0gX3Byb3BzMi5zaG93SG91cjtcbiAgICB2YXIgc2hvd1NlY29uZCA9IF9wcm9wczIuc2hvd1NlY29uZDtcblxuICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChfbW9kdWxlUGFuZWwyWydkZWZhdWx0J10sIHtcbiAgICAgIHByZWZpeENsczogcHJlZml4Q2xzICsgJy1wYW5lbCcsXG4gICAgICByZWY6IHRoaXMuc2F2ZVBhbmVsUmVmLFxuICAgICAgdmFsdWU6IHRoaXMuc3RhdGUudmFsdWUsXG4gICAgICBvbkNoYW5nZTogdGhpcy5vblBhbmVsQ2hhbmdlLFxuICAgICAgZ3JlZ29yaWFuQ2FsZW5kYXJMb2NhbGU6IGxvY2FsZS5jYWxlbmRhcixcbiAgICAgIG9uQ2xlYXI6IHRoaXMub25QYW5lbENsZWFyLFxuICAgICAgZGVmYXVsdFZhbHVlOiBkZWZhdWx0VmFsdWUsXG4gICAgICBzaG93SG91cjogc2hvd0hvdXIsXG4gICAgICBvbkVzYzogdGhpcy5vbkVzYyxcbiAgICAgIHNob3dTZWNvbmQ6IHNob3dTZWNvbmQsXG4gICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgIGFsbG93RW1wdHk6IGFsbG93RW1wdHksXG4gICAgICBmb3JtYXR0ZXI6IHRoaXMuZ2V0Rm9ybWF0dGVyKCksXG4gICAgICBwbGFjZWhvbGRlcjogcGxhY2Vob2xkZXIsXG4gICAgICBkaXNhYmxlZEhvdXJzOiBkaXNhYmxlZEhvdXJzLFxuICAgICAgZGlzYWJsZWRNaW51dGVzOiBkaXNhYmxlZE1pbnV0ZXMsXG4gICAgICBkaXNhYmxlZFNlY29uZHM6IGRpc2FibGVkU2Vjb25kcyxcbiAgICAgIGhpZGVEaXNhYmxlZE9wdGlvbnM6IGhpZGVEaXNhYmxlZE9wdGlvbnNcbiAgICB9KTtcbiAgfSxcblxuICBzZXRPcGVuOiBmdW5jdGlvbiBzZXRPcGVuKG9wZW4sIGNhbGxiYWNrKSB7XG4gICAgdmFyIF9wcm9wczMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBvbk9wZW4gPSBfcHJvcHMzLm9uT3BlbjtcbiAgICB2YXIgb25DbG9zZSA9IF9wcm9wczMub25DbG9zZTtcblxuICAgIGlmICh0aGlzLnN0YXRlLm9wZW4gIT09IG9wZW4pIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBvcGVuOiBvcGVuXG4gICAgICB9LCBjYWxsYmFjayk7XG4gICAgICB2YXIgX2V2ZW50ID0ge1xuICAgICAgICBvcGVuOiBvcGVuXG4gICAgICB9O1xuICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgb25PcGVuKF9ldmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbkNsb3NlKF9ldmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfcHJvcHM0ID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcHJlZml4Q2xzID0gX3Byb3BzNC5wcmVmaXhDbHM7XG4gICAgdmFyIHBsYWNlaG9sZGVyID0gX3Byb3BzNC5wbGFjZWhvbGRlcjtcbiAgICB2YXIgcGxhY2VtZW50ID0gX3Byb3BzNC5wbGFjZW1lbnQ7XG4gICAgdmFyIGFsaWduID0gX3Byb3BzNC5hbGlnbjtcbiAgICB2YXIgZGlzYWJsZWQgPSBfcHJvcHM0LmRpc2FibGVkO1xuICAgIHZhciB0cmFuc2l0aW9uTmFtZSA9IF9wcm9wczQudHJhbnNpdGlvbk5hbWU7XG4gICAgdmFyIHN0eWxlID0gX3Byb3BzNC5zdHlsZTtcbiAgICB2YXIgY2xhc3NOYW1lID0gX3Byb3BzNC5jbGFzc05hbWU7XG4gICAgdmFyIHNob3dIb3VyID0gX3Byb3BzNC5zaG93SG91cjtcbiAgICB2YXIgc2hvd1NlY29uZCA9IF9wcm9wczQuc2hvd1NlY29uZDtcbiAgICB2YXIgZ2V0UG9wdXBDb250YWluZXIgPSBfcHJvcHM0LmdldFBvcHVwQ29udGFpbmVyO1xuICAgIHZhciBfc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHZhciBvcGVuID0gX3N0YXRlLm9wZW47XG4gICAgdmFyIHZhbHVlID0gX3N0YXRlLnZhbHVlO1xuXG4gICAgdmFyIHBvcHVwQ2xhc3NOYW1lID0gdW5kZWZpbmVkO1xuICAgIGlmICghc2hvd0hvdXIgfHwgIXNob3dTZWNvbmQpIHtcbiAgICAgIHBvcHVwQ2xhc3NOYW1lID0gcHJlZml4Q2xzICsgJy1wYW5lbC1uYXJyb3cnO1xuICAgIH1cbiAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBfcmNUcmlnZ2VyMlsnZGVmYXVsdCddLFxuICAgICAge1xuICAgICAgICBwcmVmaXhDbHM6IHByZWZpeENscyArICctcGFuZWwnLFxuICAgICAgICBwb3B1cENsYXNzTmFtZTogcG9wdXBDbGFzc05hbWUsXG4gICAgICAgIHBvcHVwOiB0aGlzLmdldFBhbmVsRWxlbWVudCgpLFxuICAgICAgICBwb3B1cEFsaWduOiBhbGlnbixcbiAgICAgICAgYnVpbHRpblBsYWNlbWVudHM6IF91dGlsUGxhY2VtZW50czJbJ2RlZmF1bHQnXSxcbiAgICAgICAgcG9wdXBQbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgICAgYWN0aW9uOiBkaXNhYmxlZCA/IFtdIDogWydjbGljayddLFxuICAgICAgICBkZXN0cm95UG9wdXBPbkhpZGU6IHRydWUsXG4gICAgICAgIGdldFBvcHVwQ29udGFpbmVyOiBnZXRQb3B1cENvbnRhaW5lcixcbiAgICAgICAgcG9wdXBUcmFuc2l0aW9uTmFtZTogdHJhbnNpdGlvbk5hbWUsXG4gICAgICAgIHBvcHVwVmlzaWJsZTogb3BlbixcbiAgICAgICAgb25Qb3B1cFZpc2libGVDaGFuZ2U6IHRoaXMub25WaXNpYmxlQ2hhbmdlXG4gICAgICB9LFxuICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdzcGFuJyxcbiAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICcgJyArIGNsYXNzTmFtZSwgc3R5bGU6IHN0eWxlIH0sXG4gICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KCdpbnB1dCcsIHtcbiAgICAgICAgICBjbGFzc05hbWU6IHByZWZpeENscyArICctaW5wdXQnLFxuICAgICAgICAgIHJlZjogJ3BpY2tlcicsIHR5cGU6ICd0ZXh0JywgcGxhY2Vob2xkZXI6IHBsYWNlaG9sZGVyLFxuICAgICAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgICAgIG9uS2V5RG93bjogdGhpcy5vbktleURvd24sXG4gICAgICAgICAgZGlzYWJsZWQ6IGRpc2FibGVkLCB2YWx1ZTogdmFsdWUgJiYgdGhpcy5nZXRGb3JtYXR0ZXIoKS5mb3JtYXQodmFsdWUpIHx8ICcnXG4gICAgICAgIH0pLFxuICAgICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudCgnc3BhbicsIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWljb24nIH0pXG4gICAgICApXG4gICAgKTtcbiAgfVxufSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFBpY2tlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JjLXRpbWUtcGlja2VyL2xpYi9UaW1lUGlja2VyLmpzXG4gKiogbW9kdWxlIGlkID0gODlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yZWFjdERvbSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgX3JlYWN0RG9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0RG9tKTtcblxudmFyIF9yY1V0aWwgPSByZXF1aXJlKCdyYy11dGlsJyk7XG5cbnZhciBfUG9wdXAgPSByZXF1aXJlKCcuL1BvcHVwJyk7XG5cbnZhciBfUG9wdXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUG9wdXApO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIHJldHVybkVtcHR5U3RyaW5nKCkge1xuICByZXR1cm4gJyc7XG59XG5cbnZhciBBTExfSEFORExFUlMgPSBbJ29uQ2xpY2snLCAnb25Nb3VzZURvd24nLCAnb25Ub3VjaFN0YXJ0JywgJ29uTW91c2VFbnRlcicsICdvbk1vdXNlTGVhdmUnLCAnb25Gb2N1cycsICdvbkJsdXInXTtcblxudmFyIFRyaWdnZXIgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnVHJpZ2dlcicsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgYWN0aW9uOiBfcmVhY3QuUHJvcFR5cGVzLmFueSxcbiAgICBzaG93QWN0aW9uOiBfcmVhY3QuUHJvcFR5cGVzLmFueSxcbiAgICBoaWRlQWN0aW9uOiBfcmVhY3QuUHJvcFR5cGVzLmFueSxcbiAgICBnZXRQb3B1cENsYXNzTmFtZUZyb21BbGlnbjogX3JlYWN0LlByb3BUeXBlcy5hbnksXG4gICAgb25Qb3B1cFZpc2libGVDaGFuZ2U6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBhZnRlclBvcHVwVmlzaWJsZUNoYW5nZTogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIHBvcHVwOiBfcmVhY3QuUHJvcFR5cGVzLm5vZGUuaXNSZXF1aXJlZCxcbiAgICBwb3B1cFN0eWxlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBwcmVmaXhDbHM6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHBvcHVwQ2xhc3NOYW1lOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBwb3B1cFBsYWNlbWVudDogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgYnVpbHRpblBsYWNlbWVudHM6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIHBvcHVwVHJhbnNpdGlvbk5hbWU6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHBvcHVwQW5pbWF0aW9uOiBfcmVhY3QuUHJvcFR5cGVzLmFueSxcbiAgICBtb3VzZUVudGVyRGVsYXk6IF9yZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgIG1vdXNlTGVhdmVEZWxheTogX3JlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgekluZGV4OiBfcmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICBmb2N1c0RlbGF5OiBfcmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICBibHVyRGVsYXk6IF9yZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgIGdldFBvcHVwQ29udGFpbmVyOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgZGVzdHJveVBvcHVwT25IaWRlOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgbWFzazogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIG9uUG9wdXBBbGlnbjogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIHBvcHVwQWxpZ246IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIHBvcHVwVmlzaWJsZTogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIG1hc2tUcmFuc2l0aW9uTmFtZTogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgbWFza0FuaW1hdGlvbjogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmdcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHJlZml4Q2xzOiAncmMtdHJpZ2dlci1wb3B1cCcsXG4gICAgICBnZXRQb3B1cENsYXNzTmFtZUZyb21BbGlnbjogcmV0dXJuRW1wdHlTdHJpbmcsXG4gICAgICBvblBvcHVwVmlzaWJsZUNoYW5nZTogbm9vcCxcbiAgICAgIGFmdGVyUG9wdXBWaXNpYmxlQ2hhbmdlOiBub29wLFxuICAgICAgb25Qb3B1cEFsaWduOiBub29wLFxuICAgICAgcG9wdXBDbGFzc05hbWU6ICcnLFxuICAgICAgbW91c2VFbnRlckRlbGF5OiAwLFxuICAgICAgbW91c2VMZWF2ZURlbGF5OiAwLjEsXG4gICAgICBmb2N1c0RlbGF5OiAwLFxuICAgICAgYmx1ckRlbGF5OiAwLjE1LFxuICAgICAgcG9wdXBTdHlsZToge30sXG4gICAgICBkZXN0cm95UG9wdXBPbkhpZGU6IGZhbHNlLFxuICAgICAgcG9wdXBBbGlnbjoge30sXG4gICAgICBkZWZhdWx0UG9wdXBWaXNpYmxlOiBmYWxzZSxcbiAgICAgIG1hc2s6IGZhbHNlLFxuICAgICAgYWN0aW9uOiBbXSxcbiAgICAgIHNob3dBY3Rpb246IFtdLFxuICAgICAgaGlkZUFjdGlvbjogW11cbiAgICB9O1xuICB9LFxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBwb3B1cFZpc2libGUgPSB2b2lkIDA7XG4gICAgaWYgKCdwb3B1cFZpc2libGUnIGluIHByb3BzKSB7XG4gICAgICBwb3B1cFZpc2libGUgPSAhIXByb3BzLnBvcHVwVmlzaWJsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9wdXBWaXNpYmxlID0gISFwcm9wcy5kZWZhdWx0UG9wdXBWaXNpYmxlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcG9wdXBWaXNpYmxlOiBwb3B1cFZpc2libGVcbiAgICB9O1xuICB9LFxuICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5jb21wb25lbnREaWRVcGRhdGUoe30sIHtcbiAgICAgIHBvcHVwVmlzaWJsZTogdGhpcy5zdGF0ZS5wb3B1cFZpc2libGVcbiAgICB9KTtcbiAgfSxcbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICBpZiAoJ3BvcHVwVmlzaWJsZScgaW4gbmV4dFByb3BzKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgcG9wdXBWaXNpYmxlOiAhIW5leHRQcm9wcy5wb3B1cFZpc2libGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgY29tcG9uZW50RGlkVXBkYXRlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGlmICh0aGlzLnBvcHVwUmVuZGVyZWQpIHtcbiAgICAgIHZhciBfcmV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VsZiA9IF90aGlzO1xuICAgICAgICBfcmVhY3REb20yW1wiZGVmYXVsdFwiXS51bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihfdGhpcywgX3RoaXMuZ2V0UG9wdXBFbGVtZW50KCksIF90aGlzLmdldFBvcHVwQ29udGFpbmVyKCksIGZ1bmN0aW9uIHJlbmRlclBvcHVwKCkge1xuICAgICAgICAgIC8qIGVzbGludCByZWFjdC9uby1pcy1tb3VudGVkOjAgKi9cbiAgICAgICAgICBpZiAodGhpcy5pc01vdW50ZWQoKSkge1xuICAgICAgICAgICAgc2VsZi5wb3B1cERvbU5vZGUgPSB0aGlzLmdldFBvcHVwRG9tTm9kZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLnBvcHVwRG9tTm9kZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmV2U3RhdGUucG9wdXBWaXNpYmxlICE9PSBzdGF0ZS5wb3B1cFZpc2libGUpIHtcbiAgICAgICAgICAgIHByb3BzLmFmdGVyUG9wdXBWaXNpYmxlQ2hhbmdlKHN0YXRlLnBvcHVwVmlzaWJsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByb3BzLmFjdGlvbi5pbmRleE9mKCdjbGljaycpICE9PSAtMSkge1xuICAgICAgICAgIGlmIChzdGF0ZS5wb3B1cFZpc2libGUpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuY2xpY2tPdXRzaWRlSGFuZGxlcikge1xuICAgICAgICAgICAgICBfdGhpcy5jbGlja091dHNpZGVIYW5kbGVyID0gX3JjVXRpbC5Eb20uYWRkRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgJ21vdXNlZG93bicsIF90aGlzLm9uRG9jdW1lbnRDbGljayk7XG4gICAgICAgICAgICAgIF90aGlzLnRvdWNoT3V0c2lkZUhhbmRsZXIgPSBfcmNVdGlsLkRvbS5hZGRFdmVudExpc3RlbmVyKGRvY3VtZW50LCAndG91Y2hzdGFydCcsIF90aGlzLm9uRG9jdW1lbnRDbGljayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB2OiB2b2lkIDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChfdGhpcy5jbGlja091dHNpZGVIYW5kbGVyKSB7XG4gICAgICAgICAgX3RoaXMuY2xpY2tPdXRzaWRlSGFuZGxlci5yZW1vdmUoKTtcbiAgICAgICAgICBfdGhpcy50b3VjaE91dHNpZGVIYW5kbGVyLnJlbW92ZSgpO1xuICAgICAgICAgIF90aGlzLmNsaWNrT3V0c2lkZUhhbmRsZXIgPSBudWxsO1xuICAgICAgICAgIF90aGlzLnRvdWNoT3V0c2lkZUhhbmRsZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9KCk7XG5cbiAgICAgIGlmICgodHlwZW9mIF9yZXQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKF9yZXQpKSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQudjtcbiAgICB9XG4gIH0sXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB2YXIgcG9wdXBDb250YWluZXIgPSB0aGlzLnBvcHVwQ29udGFpbmVyO1xuICAgIGlmIChwb3B1cENvbnRhaW5lcikge1xuICAgICAgX3JlYWN0RG9tMltcImRlZmF1bHRcIl0udW5tb3VudENvbXBvbmVudEF0Tm9kZShwb3B1cENvbnRhaW5lcik7XG4gICAgICBwb3B1cENvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHBvcHVwQ29udGFpbmVyKTtcbiAgICAgIHRoaXMucG9wdXBDb250YWluZXIgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmNsZWFyRGVsYXlUaW1lcigpO1xuICAgIGlmICh0aGlzLmNsaWNrT3V0c2lkZUhhbmRsZXIpIHtcbiAgICAgIHRoaXMuY2xpY2tPdXRzaWRlSGFuZGxlci5yZW1vdmUoKTtcbiAgICAgIHRoaXMudG91Y2hPdXRzaWRlSGFuZGxlci5yZW1vdmUoKTtcbiAgICAgIHRoaXMuY2xpY2tPdXRzaWRlSGFuZGxlciA9IG51bGw7XG4gICAgICB0aGlzLnRvdWNoT3V0c2lkZUhhbmRsZXIgPSBudWxsO1xuICAgIH1cbiAgfSxcbiAgb25Nb3VzZUVudGVyOiBmdW5jdGlvbiBvbk1vdXNlRW50ZXIoKSB7XG4gICAgdGhpcy5kZWxheVNldFBvcHVwVmlzaWJsZSh0cnVlLCB0aGlzLnByb3BzLm1vdXNlRW50ZXJEZWxheSk7XG4gIH0sXG4gIG9uTW91c2VMZWF2ZTogZnVuY3Rpb24gb25Nb3VzZUxlYXZlKCkge1xuICAgIHRoaXMuZGVsYXlTZXRQb3B1cFZpc2libGUoZmFsc2UsIHRoaXMucHJvcHMubW91c2VMZWF2ZURlbGF5KTtcbiAgfSxcbiAgb25Gb2N1czogZnVuY3Rpb24gb25Gb2N1cygpIHtcbiAgICB0aGlzLmZvY3VzVGltZSA9IERhdGUubm93KCk7XG4gICAgdGhpcy5kZWxheVNldFBvcHVwVmlzaWJsZSh0cnVlLCB0aGlzLnByb3BzLmZvY3VzRGVsYXkpO1xuICB9LFxuICBvbk1vdXNlRG93bjogZnVuY3Rpb24gb25Nb3VzZURvd24oKSB7XG4gICAgdGhpcy5wcmVDbGlja1RpbWUgPSBEYXRlLm5vdygpO1xuICB9LFxuICBvblRvdWNoU3RhcnQ6IGZ1bmN0aW9uIG9uVG91Y2hTdGFydCgpIHtcbiAgICB0aGlzLnByZVRvdWNoVGltZSA9IERhdGUubm93KCk7XG4gIH0sXG4gIG9uQmx1cjogZnVuY3Rpb24gb25CbHVyKCkge1xuICAgIHRoaXMuZGVsYXlTZXRQb3B1cFZpc2libGUoZmFsc2UsIHRoaXMucHJvcHMuYmx1ckRlbGF5KTtcbiAgfSxcbiAgb25DbGljazogZnVuY3Rpb24gb25DbGljayhldmVudCkge1xuICAgIC8vIGZvY3VzIHdpbGwgdHJpZ2dlciBjbGlja1xuICAgIGlmICh0aGlzLmZvY3VzVGltZSkge1xuICAgICAgdmFyIHByZVRpbWUgPSB2b2lkIDA7XG4gICAgICBpZiAodGhpcy5wcmVDbGlja1RpbWUgJiYgdGhpcy5wcmVUb3VjaFRpbWUpIHtcbiAgICAgICAgcHJlVGltZSA9IE1hdGgubWluKHRoaXMucHJlQ2xpY2tUaW1lLCB0aGlzLnByZVRvdWNoVGltZSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucHJlQ2xpY2tUaW1lKSB7XG4gICAgICAgIHByZVRpbWUgPSB0aGlzLnByZUNsaWNrVGltZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmVUb3VjaFRpbWUpIHtcbiAgICAgICAgcHJlVGltZSA9IHRoaXMucHJlVG91Y2hUaW1lO1xuICAgICAgfVxuICAgICAgaWYgKE1hdGguYWJzKHByZVRpbWUgLSB0aGlzLmZvY3VzVGltZSkgPCAyMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmZvY3VzVGltZSA9IDA7XG4gICAgfVxuICAgIHRoaXMucHJlQ2xpY2tUaW1lID0gMDtcbiAgICB0aGlzLnByZVRvdWNoVGltZSA9IDA7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB2YXIgbmV4dFZpc2libGUgPSAhdGhpcy5zdGF0ZS5wb3B1cFZpc2libGU7XG4gICAgaWYgKHRoaXMuaXNDbGlja1RvSGlkZSgpICYmICFuZXh0VmlzaWJsZSB8fCBuZXh0VmlzaWJsZSAmJiB0aGlzLmlzQ2xpY2tUb1Nob3coKSkge1xuICAgICAgdGhpcy5zZXRQb3B1cFZpc2libGUoIXRoaXMuc3RhdGUucG9wdXBWaXNpYmxlKTtcbiAgICB9XG4gIH0sXG4gIG9uRG9jdW1lbnRDbGljazogZnVuY3Rpb24gb25Eb2N1bWVudENsaWNrKGV2ZW50KSB7XG4gICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICB2YXIgcm9vdCA9ICgwLCBfcmVhY3REb20uZmluZERPTU5vZGUpKHRoaXMpO1xuICAgIHZhciBwb3B1cE5vZGUgPSB0aGlzLmdldFBvcHVwRG9tTm9kZSgpO1xuICAgIGlmICghX3JjVXRpbC5Eb20uY29udGFpbnMocm9vdCwgdGFyZ2V0KSAmJiAhX3JjVXRpbC5Eb20uY29udGFpbnMocG9wdXBOb2RlLCB0YXJnZXQpKSB7XG4gICAgICB0aGlzLnNldFBvcHVwVmlzaWJsZShmYWxzZSk7XG4gICAgfVxuICB9LFxuICBnZXRQb3B1cERvbU5vZGU6IGZ1bmN0aW9uIGdldFBvcHVwRG9tTm9kZSgpIHtcbiAgICAvLyBmb3IgdGVzdFxuICAgIHJldHVybiB0aGlzLnBvcHVwRG9tTm9kZTtcbiAgfSxcbiAgZ2V0Um9vdERvbU5vZGU6IGZ1bmN0aW9uIGdldFJvb3REb21Ob2RlKCkge1xuICAgIHJldHVybiBfcmVhY3REb20yW1wiZGVmYXVsdFwiXS5maW5kRE9NTm9kZSh0aGlzKTtcbiAgfSxcbiAgZ2V0UG9wdXBDb250YWluZXI6IGZ1bmN0aW9uIGdldFBvcHVwQ29udGFpbmVyKCkge1xuICAgIGlmICghdGhpcy5wb3B1cENvbnRhaW5lcikge1xuICAgICAgdGhpcy5wb3B1cENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdmFyIG1vdW50Tm9kZSA9IHRoaXMucHJvcHMuZ2V0UG9wdXBDb250YWluZXIgPyB0aGlzLnByb3BzLmdldFBvcHVwQ29udGFpbmVyKCgwLCBfcmVhY3REb20uZmluZERPTU5vZGUpKHRoaXMpKSA6IGRvY3VtZW50LmJvZHk7XG4gICAgICBtb3VudE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5wb3B1cENvbnRhaW5lcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBvcHVwQ29udGFpbmVyO1xuICB9LFxuICBnZXRQb3B1cENsYXNzTmFtZUZyb21BbGlnbjogZnVuY3Rpb24gZ2V0UG9wdXBDbGFzc05hbWVGcm9tQWxpZ24oYWxpZ24pIHtcbiAgICB2YXIgY2xhc3NOYW1lID0gW107XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcG9wdXBQbGFjZW1lbnQgPSBwcm9wcy5wb3B1cFBsYWNlbWVudDtcbiAgICB2YXIgYnVpbHRpblBsYWNlbWVudHMgPSBwcm9wcy5idWlsdGluUGxhY2VtZW50cztcbiAgICB2YXIgcHJlZml4Q2xzID0gcHJvcHMucHJlZml4Q2xzO1xuXG4gICAgaWYgKHBvcHVwUGxhY2VtZW50ICYmIGJ1aWx0aW5QbGFjZW1lbnRzKSB7XG4gICAgICBjbGFzc05hbWUucHVzaCgoMCwgX3V0aWxzLmdldFBvcHVwQ2xhc3NOYW1lRnJvbUFsaWduKShidWlsdGluUGxhY2VtZW50cywgcHJlZml4Q2xzLCBhbGlnbikpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZ2V0UG9wdXBDbGFzc05hbWVGcm9tQWxpZ24pIHtcbiAgICAgIGNsYXNzTmFtZS5wdXNoKHByb3BzLmdldFBvcHVwQ2xhc3NOYW1lRnJvbUFsaWduKGFsaWduKSk7XG4gICAgfVxuICAgIHJldHVybiBjbGFzc05hbWUuam9pbignICcpO1xuICB9LFxuICBnZXRQb3B1cEFsaWduOiBmdW5jdGlvbiBnZXRQb3B1cEFsaWduKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHBvcHVwUGxhY2VtZW50ID0gcHJvcHMucG9wdXBQbGFjZW1lbnQ7XG4gICAgdmFyIHBvcHVwQWxpZ24gPSBwcm9wcy5wb3B1cEFsaWduO1xuICAgIHZhciBidWlsdGluUGxhY2VtZW50cyA9IHByb3BzLmJ1aWx0aW5QbGFjZW1lbnRzO1xuXG4gICAgaWYgKHBvcHVwUGxhY2VtZW50ICYmIGJ1aWx0aW5QbGFjZW1lbnRzKSB7XG4gICAgICByZXR1cm4gKDAsIF91dGlscy5nZXRBbGlnbkZyb21QbGFjZW1lbnQpKGJ1aWx0aW5QbGFjZW1lbnRzLCBwb3B1cFBsYWNlbWVudCwgcG9wdXBBbGlnbik7XG4gICAgfVxuICAgIHJldHVybiBwb3B1cEFsaWduO1xuICB9LFxuICBnZXRQb3B1cEVsZW1lbnQ6IGZ1bmN0aW9uIGdldFBvcHVwRWxlbWVudCgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdmFyIG1vdXNlUHJvcHMgPSB7fTtcbiAgICBpZiAocHJvcHMuYWN0aW9uLmluZGV4T2YoJ2hvdmVyJykgIT09IC0xKSB7XG4gICAgICBtb3VzZVByb3BzLm9uTW91c2VFbnRlciA9IHRoaXMub25Nb3VzZUVudGVyO1xuICAgICAgbW91c2VQcm9wcy5vbk1vdXNlTGVhdmUgPSB0aGlzLm9uTW91c2VMZWF2ZTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBfUG9wdXAyW1wiZGVmYXVsdFwiXSxcbiAgICAgIF9leHRlbmRzKHtcbiAgICAgICAgcHJlZml4Q2xzOiBwcm9wcy5wcmVmaXhDbHMsXG4gICAgICAgIGRlc3Ryb3lQb3B1cE9uSGlkZTogcHJvcHMuZGVzdHJveVBvcHVwT25IaWRlLFxuICAgICAgICB2aXNpYmxlOiBzdGF0ZS5wb3B1cFZpc2libGUsXG4gICAgICAgIGNsYXNzTmFtZTogcHJvcHMucG9wdXBDbGFzc05hbWUsXG4gICAgICAgIGFjdGlvbjogcHJvcHMuYWN0aW9uLFxuICAgICAgICBhbGlnbjogdGhpcy5nZXRQb3B1cEFsaWduKCksXG4gICAgICAgIG9uQWxpZ246IHByb3BzLm9uUG9wdXBBbGlnbixcbiAgICAgICAgYW5pbWF0aW9uOiBwcm9wcy5wb3B1cEFuaW1hdGlvbixcbiAgICAgICAgZ2V0Q2xhc3NOYW1lRnJvbUFsaWduOiB0aGlzLmdldFBvcHVwQ2xhc3NOYW1lRnJvbUFsaWduXG4gICAgICB9LCBtb3VzZVByb3BzLCB7XG4gICAgICAgIGdldFJvb3REb21Ob2RlOiB0aGlzLmdldFJvb3REb21Ob2RlLFxuICAgICAgICBzdHlsZTogcHJvcHMucG9wdXBTdHlsZSxcbiAgICAgICAgbWFzazogcHJvcHMubWFzayxcbiAgICAgICAgekluZGV4OiBwcm9wcy56SW5kZXgsXG4gICAgICAgIHRyYW5zaXRpb25OYW1lOiBwcm9wcy5wb3B1cFRyYW5zaXRpb25OYW1lLFxuICAgICAgICBtYXNrQW5pbWF0aW9uOiBwcm9wcy5tYXNrQW5pbWF0aW9uLFxuICAgICAgICBtYXNrVHJhbnNpdGlvbk5hbWU6IHByb3BzLm1hc2tUcmFuc2l0aW9uTmFtZVxuICAgICAgfSksXG4gICAgICBwcm9wcy5wb3B1cFxuICAgICk7XG4gIH0sXG4gIHNldFBvcHVwVmlzaWJsZTogZnVuY3Rpb24gc2V0UG9wdXBWaXNpYmxlKHBvcHVwVmlzaWJsZSkge1xuICAgIHRoaXMuY2xlYXJEZWxheVRpbWVyKCk7XG4gICAgaWYgKHRoaXMuc3RhdGUucG9wdXBWaXNpYmxlICE9PSBwb3B1cFZpc2libGUpIHtcbiAgICAgIGlmICghKCdwb3B1cFZpc2libGUnIGluIHRoaXMucHJvcHMpKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIHBvcHVwVmlzaWJsZTogcG9wdXBWaXNpYmxlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5wcm9wcy5vblBvcHVwVmlzaWJsZUNoYW5nZShwb3B1cFZpc2libGUpO1xuICAgIH1cbiAgfSxcbiAgZGVsYXlTZXRQb3B1cFZpc2libGU6IGZ1bmN0aW9uIGRlbGF5U2V0UG9wdXBWaXNpYmxlKHZpc2libGUsIGRlbGF5Uykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIGRlbGF5ID0gZGVsYXlTICogMTAwMDtcbiAgICB0aGlzLmNsZWFyRGVsYXlUaW1lcigpO1xuICAgIGlmIChkZWxheSkge1xuICAgICAgdGhpcy5kZWxheVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5zZXRQb3B1cFZpc2libGUodmlzaWJsZSk7XG4gICAgICAgIF90aGlzMi5jbGVhckRlbGF5VGltZXIoKTtcbiAgICAgIH0sIGRlbGF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRQb3B1cFZpc2libGUodmlzaWJsZSk7XG4gICAgfVxuICB9LFxuICBjbGVhckRlbGF5VGltZXI6IGZ1bmN0aW9uIGNsZWFyRGVsYXlUaW1lcigpIHtcbiAgICBpZiAodGhpcy5kZWxheVRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWxheVRpbWVyKTtcbiAgICAgIHRoaXMuZGVsYXlUaW1lciA9IG51bGw7XG4gICAgfVxuICB9LFxuICBpc0NsaWNrVG9TaG93OiBmdW5jdGlvbiBpc0NsaWNrVG9TaG93KCkge1xuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBhY3Rpb24gPSBfcHJvcHMuYWN0aW9uO1xuICAgIHZhciBzaG93QWN0aW9uID0gX3Byb3BzLnNob3dBY3Rpb247XG5cbiAgICByZXR1cm4gYWN0aW9uLmluZGV4T2YoJ2NsaWNrJykgIT09IC0xIHx8IHNob3dBY3Rpb24uaW5kZXhPZignY2xpY2snKSAhPT0gLTE7XG4gIH0sXG4gIGlzQ2xpY2tUb0hpZGU6IGZ1bmN0aW9uIGlzQ2xpY2tUb0hpZGUoKSB7XG4gICAgdmFyIF9wcm9wczIgPSB0aGlzLnByb3BzO1xuICAgIHZhciBhY3Rpb24gPSBfcHJvcHMyLmFjdGlvbjtcbiAgICB2YXIgaGlkZUFjdGlvbiA9IF9wcm9wczIuaGlkZUFjdGlvbjtcblxuICAgIHJldHVybiBhY3Rpb24uaW5kZXhPZignY2xpY2snKSAhPT0gLTEgfHwgaGlkZUFjdGlvbi5pbmRleE9mKCdjbGljaycpICE9PSAtMTtcbiAgfSxcbiAgaXNNb3VzZUVudGVyVG9TaG93OiBmdW5jdGlvbiBpc01vdXNlRW50ZXJUb1Nob3coKSB7XG4gICAgdmFyIF9wcm9wczMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBhY3Rpb24gPSBfcHJvcHMzLmFjdGlvbjtcbiAgICB2YXIgc2hvd0FjdGlvbiA9IF9wcm9wczMuc2hvd0FjdGlvbjtcblxuICAgIHJldHVybiBhY3Rpb24uaW5kZXhPZignaG92ZXInKSAhPT0gLTEgfHwgc2hvd0FjdGlvbi5pbmRleE9mKCdtb3VzZUVudGVyJykgIT09IC0xO1xuICB9LFxuICBpc01vdXNlTGVhdmVUb0hpZGU6IGZ1bmN0aW9uIGlzTW91c2VMZWF2ZVRvSGlkZSgpIHtcbiAgICB2YXIgX3Byb3BzNCA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGFjdGlvbiA9IF9wcm9wczQuYWN0aW9uO1xuICAgIHZhciBoaWRlQWN0aW9uID0gX3Byb3BzNC5oaWRlQWN0aW9uO1xuXG4gICAgcmV0dXJuIGFjdGlvbi5pbmRleE9mKCdob3ZlcicpICE9PSAtMSB8fCBoaWRlQWN0aW9uLmluZGV4T2YoJ21vdXNlTGVhdmUnKSAhPT0gLTE7XG4gIH0sXG4gIGlzRm9jdXNUb1Nob3c6IGZ1bmN0aW9uIGlzRm9jdXNUb1Nob3coKSB7XG4gICAgdmFyIF9wcm9wczUgPSB0aGlzLnByb3BzO1xuICAgIHZhciBhY3Rpb24gPSBfcHJvcHM1LmFjdGlvbjtcbiAgICB2YXIgc2hvd0FjdGlvbiA9IF9wcm9wczUuc2hvd0FjdGlvbjtcblxuICAgIHJldHVybiBhY3Rpb24uaW5kZXhPZignZm9jdXMnKSAhPT0gLTEgfHwgc2hvd0FjdGlvbi5pbmRleE9mKCdmb2N1cycpICE9PSAtMTtcbiAgfSxcbiAgaXNCbHVyVG9IaWRlOiBmdW5jdGlvbiBpc0JsdXJUb0hpZGUoKSB7XG4gICAgdmFyIF9wcm9wczYgPSB0aGlzLnByb3BzO1xuICAgIHZhciBhY3Rpb24gPSBfcHJvcHM2LmFjdGlvbjtcbiAgICB2YXIgaGlkZUFjdGlvbiA9IF9wcm9wczYuaGlkZUFjdGlvbjtcblxuICAgIHJldHVybiBhY3Rpb24uaW5kZXhPZignZm9jdXMnKSAhPT0gLTEgfHwgaGlkZUFjdGlvbi5pbmRleE9mKCdibHVyJykgIT09IC0xO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB0aGlzLnBvcHVwUmVuZGVyZWQgPSB0aGlzLnBvcHVwUmVuZGVyZWQgfHwgdGhpcy5zdGF0ZS5wb3B1cFZpc2libGU7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgY2hpbGQgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKTtcbiAgICB2YXIgY2hpbGRQcm9wcyA9IGNoaWxkLnByb3BzIHx8IHt9O1xuICAgIHZhciBuZXdDaGlsZFByb3BzID0ge307XG5cbiAgICBpZiAodGhpcy5pc0NsaWNrVG9IaWRlKCkgfHwgdGhpcy5pc0NsaWNrVG9TaG93KCkpIHtcbiAgICAgIG5ld0NoaWxkUHJvcHMub25DbGljayA9ICgwLCBfcmNVdGlsLmNyZWF0ZUNoYWluZWRGdW5jdGlvbikodGhpcy5vbkNsaWNrLCBjaGlsZFByb3BzLm9uQ2xpY2spO1xuICAgICAgbmV3Q2hpbGRQcm9wcy5vbk1vdXNlRG93biA9ICgwLCBfcmNVdGlsLmNyZWF0ZUNoYWluZWRGdW5jdGlvbikodGhpcy5vbk1vdXNlRG93biwgY2hpbGRQcm9wcy5vbk1vdXNlRG93bik7XG4gICAgICBuZXdDaGlsZFByb3BzLm9uVG91Y2hTdGFydCA9ICgwLCBfcmNVdGlsLmNyZWF0ZUNoYWluZWRGdW5jdGlvbikodGhpcy5vblRvdWNoU3RhcnQsIGNoaWxkUHJvcHMub25Ub3VjaFN0YXJ0KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNNb3VzZUVudGVyVG9TaG93KCkpIHtcbiAgICAgIG5ld0NoaWxkUHJvcHMub25Nb3VzZUVudGVyID0gKDAsIF9yY1V0aWwuY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKSh0aGlzLm9uTW91c2VFbnRlciwgY2hpbGRQcm9wcy5vbk1vdXNlRW50ZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc01vdXNlTGVhdmVUb0hpZGUoKSkge1xuICAgICAgbmV3Q2hpbGRQcm9wcy5vbk1vdXNlTGVhdmUgPSAoMCwgX3JjVXRpbC5jcmVhdGVDaGFpbmVkRnVuY3Rpb24pKHRoaXMub25Nb3VzZUxlYXZlLCBjaGlsZFByb3BzLm9uTW91c2VMZWF2ZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzRm9jdXNUb1Nob3coKSkge1xuICAgICAgbmV3Q2hpbGRQcm9wcy5vbkZvY3VzID0gKDAsIF9yY1V0aWwuY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKSh0aGlzLm9uRm9jdXMsIGNoaWxkUHJvcHMub25Gb2N1cyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzQmx1clRvSGlkZSgpKSB7XG4gICAgICBuZXdDaGlsZFByb3BzLm9uQmx1ciA9ICgwLCBfcmNVdGlsLmNyZWF0ZUNoYWluZWRGdW5jdGlvbikodGhpcy5vbkJsdXIsIGNoaWxkUHJvcHMub25CbHVyKTtcbiAgICB9XG5cbiAgICBBTExfSEFORExFUlMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgdmFyIG5ld0ZuID0gdm9pZCAwO1xuICAgICAgaWYgKHByb3BzW2hhbmRsZXJdICYmIG5ld0NoaWxkUHJvcHNbaGFuZGxlcl0pIHtcbiAgICAgICAgbmV3Rm4gPSAoMCwgX3JjVXRpbC5jcmVhdGVDaGFpbmVkRnVuY3Rpb24pKHByb3BzW2hhbmRsZXJdLCBuZXdDaGlsZFByb3BzW2hhbmRsZXJdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0ZuID0gcHJvcHNbaGFuZGxlcl0gfHwgbmV3Q2hpbGRQcm9wc1toYW5kbGVyXTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdGbikge1xuICAgICAgICBuZXdDaGlsZFByb3BzW2hhbmRsZXJdID0gbmV3Rm47XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KGNoaWxkLCBuZXdDaGlsZFByb3BzKTtcbiAgfVxufSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gVHJpZ2dlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JjLXRpbWUtcGlja2VyL34vcmMtdHJpZ2dlci9saWIvVHJpZ2dlci5qc1xuICoqIG1vZHVsZSBpZCA9IDkxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7XG5cbi8qKlxuICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbiAqIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyBcImRlcHJlY2F0ZWRcIiB2ZXJzaW9uIG9mIGBmbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVwcmVjYXRlIChmbiwgbXNnKSB7XG4gIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGBsb2NhbFN0b3JhZ2VgIGZvciBib29sZWFuIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb25maWcgKG5hbWUpIHtcbiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXNcbiAgdHJ5IHtcbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yYy10aW1lLXBpY2tlci9+L3JjLXRyaWdnZXIvfi9yYy11dGlsL34vdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDk1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmZXRjaEtleXMgPSByZXF1aXJlKCdsb2Rhc2gua2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCLCBjb21wYXJlLCBjb21wYXJlQ29udGV4dCkge1xuXG4gICAgdmFyIHJldCA9IGNvbXBhcmUgPyBjb21wYXJlLmNhbGwoY29tcGFyZUNvbnRleHQsIG9iakEsIG9iakIpIDogdm9pZCAwO1xuXG4gICAgaWYgKHJldCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiAhIXJldDtcbiAgICB9XG5cbiAgICBpZiAob2JqQSA9PT0gb2JqQikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9iakEgIT09ICdvYmplY3QnIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09ICdvYmplY3QnIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBrZXlzQSA9IGZldGNoS2V5cyhvYmpBKTtcbiAgICB2YXIga2V5c0IgPSBmZXRjaEtleXMob2JqQik7XG5cbiAgICB2YXIgbGVuID0ga2V5c0EubGVuZ3RoO1xuICAgIGlmIChsZW4gIT09IGtleXNCLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29tcGFyZUNvbnRleHQgPSBjb21wYXJlQ29udGV4dCB8fCBudWxsO1xuXG4gICAgLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cbiAgICB2YXIgYkhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5iaW5kKG9iakIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNBW2ldO1xuICAgICAgICBpZiAoIWJIYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlQSA9IG9iakFba2V5XTtcbiAgICAgICAgdmFyIHZhbHVlQiA9IG9iakJba2V5XTtcblxuICAgICAgICB2YXIgX3JldCA9IGNvbXBhcmUgPyBjb21wYXJlLmNhbGwoY29tcGFyZUNvbnRleHQsIHZhbHVlQSwgdmFsdWVCLCBrZXkpIDogdm9pZCAwO1xuICAgICAgICBpZiAoX3JldCA9PT0gZmFsc2UgfHwgX3JldCA9PT0gdm9pZCAwICYmIHZhbHVlQSAhPT0gdmFsdWVCKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmMtdGltZS1waWNrZXIvfi9yYy10cmlnZ2VyL34vcmMtdXRpbC9+L3NoYWxsb3dlcXVhbC9tb2R1bGVzL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gOTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogbG9kYXNoIDMuMS4yIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG52YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnbG9kYXNoLl9nZXRuYXRpdmUnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJ2xvZGFzaC5pc2FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCdsb2Rhc2guaXNhcnJheScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXlxcZCskLztcblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IGdldE5hdGl2ZShPYmplY3QsICdrZXlzJyk7XG5cbi8qKlxuICogVXNlZCBhcyB0aGUgW21heGltdW0gbGVuZ3RoXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIubWF4X3NhZmVfaW50ZWdlcilcbiAqIG9mIGFuIGFycmF5LWxpa2UgdmFsdWUuXG4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IHZhbHVlIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gYXZvaWQgYSBbSklUIGJ1Z10oaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE0Mjc5MilcbiAqIHRoYXQgYWZmZWN0cyBTYWZhcmkgb24gYXQgbGVhc3QgaU9TIDguMS04LjMgQVJNNjQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBcImxlbmd0aFwiIHZhbHVlLlxuICovXG52YXIgZ2V0TGVuZ3RoID0gYmFzZVByb3BlcnR5KCdsZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgoZ2V0TGVuZ3RoKHZhbHVlKSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhbHVlID0gKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgPyArdmFsdWUgOiAtMTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiBvZiBgT2JqZWN0LmtleXNgIHdoaWNoIGNyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlXG4gKiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gc2hpbUtleXMob2JqZWN0KSB7XG4gIHZhciBwcm9wcyA9IGtleXNJbihvYmplY3QpLFxuICAgICAgcHJvcHNMZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBwcm9wc0xlbmd0aCAmJiBvYmplY3QubGVuZ3RoO1xuXG4gIHZhciBhbGxvd0luZGV4ZXMgPSAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgcHJvcHNMZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgIGlmICgoYWxsb3dJbmRleGVzICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpKSB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgW2xhbmd1YWdlIHR5cGVdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDgpIG9mIGBPYmplY3RgLlxuICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdCgxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIC8vIEF2b2lkIGEgVjggSklUIGJ1ZyBpbiBDaHJvbWUgMTktMjAuXG4gIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xudmFyIGtleXMgPSAhbmF0aXZlS2V5cyA/IHNoaW1LZXlzIDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIHZhciBDdG9yID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3QuY29uc3RydWN0b3I7XG4gIGlmICgodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSA9PT0gb2JqZWN0KSB8fFxuICAgICAgKHR5cGVvZiBvYmplY3QgIT0gJ2Z1bmN0aW9uJyAmJiBpc0FycmF5TGlrZShvYmplY3QpKSkge1xuICAgIHJldHVybiBzaGltS2V5cyhvYmplY3QpO1xuICB9XG4gIHJldHVybiBpc09iamVjdChvYmplY3QpID8gbmF0aXZlS2V5cyhvYmplY3QpIDogW107XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICB9XG4gIHZhciBsZW5ndGggPSBvYmplY3QubGVuZ3RoO1xuICBsZW5ndGggPSAobGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpICYmIGxlbmd0aCkgfHwgMDtcblxuICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgIGluZGV4ID0gLTEsXG4gICAgICBpc1Byb3RvID0gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSA9PT0gb2JqZWN0LFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgIHNraXBJbmRleGVzID0gbGVuZ3RoID4gMDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSAoaW5kZXggKyAnJyk7XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKHNraXBJbmRleGVzICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpKSAmJlxuICAgICAgICAhKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXM7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yYy10aW1lLXBpY2tlci9+L3JjLXRyaWdnZXIvfi9yYy11dGlsL34vc2hhbGxvd2VxdWFsL34vbG9kYXNoLmtleXMvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogbG9kYXNoIDMuOS4xIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkgPiA1KS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZm5Ub1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqVG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZuVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZSgvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICByZXR1cm4gaXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIG9sZGVyIHZlcnNpb25zIG9mIENocm9tZSBhbmQgU2FmYXJpIHdoaWNoIHJldHVybiAnZnVuY3Rpb24nIGZvciByZWdleGVzXG4gIC8vIGFuZCBTYWZhcmkgOCBlcXVpdmFsZW50cyB3aGljaCByZXR1cm4gJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9ycy5cbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBmdW5jVGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBbbGFuZ3VhZ2UgdHlwZV0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4OCkgb2YgYE9iamVjdGAuXG4gKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTmF0aXZlKEFycmF5LnByb3RvdHlwZS5wdXNoKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTmF0aXZlKF8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgcmV0dXJuIHJlSXNOYXRpdmUudGVzdChmblRvU3RyaW5nLmNhbGwodmFsdWUpKTtcbiAgfVxuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiByZUlzSG9zdEN0b3IudGVzdCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TmF0aXZlO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmMtdGltZS1waWNrZXIvfi9yYy10cmlnZ2VyL34vcmMtdXRpbC9+L3NoYWxsb3dlcXVhbC9+L2xvZGFzaC5rZXlzL34vbG9kYXNoLl9nZXRuYXRpdmUvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogbG9kYXNoIDMuMC44IChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE2IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTYgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IHZhbHVlIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gYXZvaWQgYSBbSklUIGJ1Z10oaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE0Mjc5MilcbiAqIHRoYXQgYWZmZWN0cyBTYWZhcmkgb24gYXQgbGVhc3QgaU9TIDguMS04LjMgQVJNNjQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBcImxlbmd0aFwiIHZhbHVlLlxuICovXG52YXIgZ2V0TGVuZ3RoID0gYmFzZVByb3BlcnR5KCdsZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIC8vIFNhZmFyaSA4LjEgaW5jb3JyZWN0bHkgbWFrZXMgYGFyZ3VtZW50cy5jYWxsZWVgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIHJldHVybiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgKCFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgfHwgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJnc1RhZyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aChnZXRMZW5ndGgodmFsdWUpKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOCB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBhbmQgd2VhayBtYXAgY29uc3RydWN0b3JzLFxuICAvLyBhbmQgUGhhbnRvbUpTIDEuOSB3aGljaCByZXR1cm5zICdmdW5jdGlvbicgZm9yIGBOb2RlTGlzdGAgaW5zdGFuY2VzLlxuICB2YXIgdGFnID0gaXNPYmplY3QodmFsdWUpID8gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyBsb29zZWx5IGJhc2VkIG9uIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIFtsYW5ndWFnZSB0eXBlXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBvZiBgT2JqZWN0YC5cbiAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JjLXRpbWUtcGlja2VyL34vcmMtdHJpZ2dlci9+L3JjLXV0aWwvfi9zaGFsbG93ZXF1YWwvfi9sb2Rhc2gua2V5cy9+L2xvZGFzaC5pc2FyZ3VtZW50cy9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBsb2Rhc2ggMy4wLjQgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkgPiA1KS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZm5Ub1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqVG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZuVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZSgvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNBcnJheSA9IGdldE5hdGl2ZShBcnJheSwgJ2lzQXJyYXknKTtcblxuLyoqXG4gKiBVc2VkIGFzIHRoZSBbbWF4aW11bSBsZW5ndGhdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5tYXhfc2FmZV9pbnRlZ2VyKVxuICogb2YgYW4gYXJyYXktbGlrZSB2YWx1ZS5cbiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgcmV0dXJuIGlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgYmFzZWQgb24gW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcnJheVRhZztcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIG9sZGVyIHZlcnNpb25zIG9mIENocm9tZSBhbmQgU2FmYXJpIHdoaWNoIHJldHVybiAnZnVuY3Rpb24nIGZvciByZWdleGVzXG4gIC8vIGFuZCBTYWZhcmkgOCBlcXVpdmFsZW50cyB3aGljaCByZXR1cm4gJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9ycy5cbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBmdW5jVGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBbbGFuZ3VhZ2UgdHlwZV0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4OCkgb2YgYE9iamVjdGAuXG4gKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTmF0aXZlKEFycmF5LnByb3RvdHlwZS5wdXNoKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTmF0aXZlKF8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgcmV0dXJuIHJlSXNOYXRpdmUudGVzdChmblRvU3RyaW5nLmNhbGwodmFsdWUpKTtcbiAgfVxuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiByZUlzSG9zdEN0b3IudGVzdCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JjLXRpbWUtcGlja2VyL34vcmMtdHJpZ2dlci9+L3JjLXV0aWwvfi9zaGFsbG93ZXF1YWwvfi9sb2Rhc2gua2V5cy9+L2xvZGFzaC5pc2FycmF5L2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1snZGVmYXVsdCddID0gYWRkRXZlbnRMaXN0ZW5lcldyYXA7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9hZGREb21FdmVudExpc3RlbmVyID0gcmVxdWlyZSgnYWRkLWRvbS1ldmVudC1saXN0ZW5lcicpO1xuXG52YXIgX2FkZERvbUV2ZW50TGlzdGVuZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYWRkRG9tRXZlbnRMaXN0ZW5lcik7XG5cbnZhciBfcmVhY3REb20gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIF9yZWFjdERvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdERvbSk7XG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXJXcmFwKHRhcmdldCwgZXZlbnRUeXBlLCBjYikge1xuICAvKiBlc2xpbnQgY2FtZWxjYXNlOiAyICovXG4gIHZhciBjYWxsYmFjayA9IF9yZWFjdERvbTJbJ2RlZmF1bHQnXS51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyA/IGZ1bmN0aW9uIHJ1bihlKSB7XG4gICAgX3JlYWN0RG9tMlsnZGVmYXVsdCddLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzKGNiLCBlKTtcbiAgfSA6IGNiO1xuICByZXR1cm4gKDAsIF9hZGREb21FdmVudExpc3RlbmVyMlsnZGVmYXVsdCddKSh0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yYy10aW1lLXBpY2tlci9+L3JjLXRyaWdnZXIvfi9yYy11dGlsL2xpYi9Eb20vYWRkRXZlbnRMaXN0ZW5lci5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGFkZEV2ZW50TGlzdGVuZXI7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9FdmVudE9iamVjdCA9IHJlcXVpcmUoJy4vRXZlbnRPYmplY3QnKTtcblxudmFyIF9FdmVudE9iamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9FdmVudE9iamVjdCk7XG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIodGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIHdyYXBDYWxsYmFjayhlKSB7XG4gICAgdmFyIG5lID0gbmV3IF9FdmVudE9iamVjdDJbJ2RlZmF1bHQnXShlKTtcbiAgICBjYWxsYmFjay5jYWxsKHRhcmdldCwgbmUpO1xuICB9XG5cbiAgaWYgKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCB3cmFwQ2FsbGJhY2ssIGZhbHNlKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgd3JhcENhbGxiYWNrLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIGlmICh0YXJnZXQuYXR0YWNoRXZlbnQpIHtcbiAgICB0YXJnZXQuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50VHlwZSwgd3JhcENhbGxiYWNrKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgIHRhcmdldC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCB3cmFwQ2FsbGJhY2spO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmMtdGltZS1waWNrZXIvfi9yYy10cmlnZ2VyL34vcmMtdXRpbC9+L2FkZC1kb20tZXZlbnQtbGlzdGVuZXIvbGliL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEBpZ25vcmVcbiAqIGV2ZW50IG9iamVjdCBmb3IgZG9tXG4gKiBAYXV0aG9yIHlpbWluZ2hlQGdtYWlsLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9FdmVudEJhc2VPYmplY3QgPSByZXF1aXJlKCcuL0V2ZW50QmFzZU9iamVjdCcpO1xuXG52YXIgX0V2ZW50QmFzZU9iamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9FdmVudEJhc2VPYmplY3QpO1xuXG52YXIgX29iamVjdEFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIF9vYmplY3RBc3NpZ24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb2JqZWN0QXNzaWduKTtcblxudmFyIFRSVUUgPSB0cnVlO1xudmFyIEZBTFNFID0gZmFsc2U7XG52YXIgY29tbW9uUHJvcHMgPSBbJ2FsdEtleScsICdidWJibGVzJywgJ2NhbmNlbGFibGUnLCAnY3RybEtleScsICdjdXJyZW50VGFyZ2V0JywgJ2V2ZW50UGhhc2UnLCAnbWV0YUtleScsICdzaGlmdEtleScsICd0YXJnZXQnLCAndGltZVN0YW1wJywgJ3ZpZXcnLCAndHlwZSddO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZCh3KSB7XG4gIHJldHVybiB3ID09PSBudWxsIHx8IHcgPT09IHVuZGVmaW5lZDtcbn1cblxudmFyIGV2ZW50Tm9ybWFsaXplcnMgPSBbe1xuICByZWc6IC9ea2V5LyxcbiAgcHJvcHM6IFsnY2hhcicsICdjaGFyQ29kZScsICdrZXknLCAna2V5Q29kZScsICd3aGljaCddLFxuICBmaXg6IGZ1bmN0aW9uIGZpeChldmVudCwgbmF0aXZlRXZlbnQpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoZXZlbnQud2hpY2gpKSB7XG4gICAgICBldmVudC53aGljaCA9ICFpc051bGxPclVuZGVmaW5lZChuYXRpdmVFdmVudC5jaGFyQ29kZSkgPyBuYXRpdmVFdmVudC5jaGFyQ29kZSA6IG5hdGl2ZUV2ZW50LmtleUNvZGU7XG4gICAgfVxuXG4gICAgLy8gYWRkIG1ldGFLZXkgdG8gbm9uLU1hYyBicm93c2VycyAodXNlIGN0cmwgZm9yIFBDICdzIGFuZCBNZXRhIGZvciBNYWNzKVxuICAgIGlmIChldmVudC5tZXRhS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGV2ZW50Lm1ldGFLZXkgPSBldmVudC5jdHJsS2V5O1xuICAgIH1cbiAgfVxufSwge1xuICByZWc6IC9edG91Y2gvLFxuICBwcm9wczogWyd0b3VjaGVzJywgJ2NoYW5nZWRUb3VjaGVzJywgJ3RhcmdldFRvdWNoZXMnXVxufSwge1xuICByZWc6IC9eaGFzaGNoYW5nZSQvLFxuICBwcm9wczogWyduZXdVUkwnLCAnb2xkVVJMJ11cbn0sIHtcbiAgcmVnOiAvXmdlc3R1cmVjaGFuZ2UkL2ksXG4gIHByb3BzOiBbJ3JvdGF0aW9uJywgJ3NjYWxlJ11cbn0sIHtcbiAgcmVnOiAvXihtb3VzZXdoZWVsfERPTU1vdXNlU2Nyb2xsKSQvLFxuICBwcm9wczogW10sXG4gIGZpeDogZnVuY3Rpb24gZml4KGV2ZW50LCBuYXRpdmVFdmVudCkge1xuICAgIHZhciBkZWx0YVggPSB1bmRlZmluZWQ7XG4gICAgdmFyIGRlbHRhWSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgZGVsdGEgPSB1bmRlZmluZWQ7XG4gICAgdmFyIHdoZWVsRGVsdGEgPSBuYXRpdmVFdmVudC53aGVlbERlbHRhO1xuICAgIHZhciBheGlzID0gbmF0aXZlRXZlbnQuYXhpcztcbiAgICB2YXIgd2hlZWxEZWx0YVkgPSBuYXRpdmVFdmVudC53aGVlbERlbHRhWTtcbiAgICB2YXIgd2hlZWxEZWx0YVggPSBuYXRpdmVFdmVudC53aGVlbERlbHRhWDtcbiAgICB2YXIgZGV0YWlsID0gbmF0aXZlRXZlbnQuZGV0YWlsO1xuXG4gICAgLy8gaWUvd2Via2l0XG4gICAgaWYgKHdoZWVsRGVsdGEpIHtcbiAgICAgIGRlbHRhID0gd2hlZWxEZWx0YSAvIDEyMDtcbiAgICB9XG5cbiAgICAvLyBnZWNrb1xuICAgIGlmIChkZXRhaWwpIHtcbiAgICAgIC8vIHByZXNzIGNvbnRyb2wgZS5kZXRhaWwgPT0gMSBlbHNlIGUuZGV0YWlsID09IDNcbiAgICAgIGRlbHRhID0gMCAtIChkZXRhaWwgJSAzID09PSAwID8gZGV0YWlsIC8gMyA6IGRldGFpbCk7XG4gICAgfVxuXG4gICAgLy8gR2Vja29cbiAgICBpZiAoYXhpcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoYXhpcyA9PT0gZXZlbnQuSE9SSVpPTlRBTF9BWElTKSB7XG4gICAgICAgIGRlbHRhWSA9IDA7XG4gICAgICAgIGRlbHRhWCA9IDAgLSBkZWx0YTtcbiAgICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gZXZlbnQuVkVSVElDQUxfQVhJUykge1xuICAgICAgICBkZWx0YVggPSAwO1xuICAgICAgICBkZWx0YVkgPSBkZWx0YTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXZWJraXRcbiAgICBpZiAod2hlZWxEZWx0YVkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVsdGFZID0gd2hlZWxEZWx0YVkgLyAxMjA7XG4gICAgfVxuICAgIGlmICh3aGVlbERlbHRhWCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZWx0YVggPSAtMSAqIHdoZWVsRGVsdGFYIC8gMTIwO1xuICAgIH1cblxuICAgIC8vIOm7mOiupCBkZWx0YVkgKGllKVxuICAgIGlmICghZGVsdGFYICYmICFkZWx0YVkpIHtcbiAgICAgIGRlbHRhWSA9IGRlbHRhO1xuICAgIH1cblxuICAgIGlmIChkZWx0YVggIT09IHVuZGVmaW5lZCkge1xuICAgICAgLyoqXG4gICAgICAgKiBkZWx0YVggb2YgbW91c2V3aGVlbCBldmVudFxuICAgICAgICogQHByb3BlcnR5IGRlbHRhWFxuICAgICAgICogQG1lbWJlciBFdmVudC5Eb21FdmVudC5PYmplY3RcbiAgICAgICAqL1xuICAgICAgZXZlbnQuZGVsdGFYID0gZGVsdGFYO1xuICAgIH1cblxuICAgIGlmIChkZWx0YVkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLyoqXG4gICAgICAgKiBkZWx0YVkgb2YgbW91c2V3aGVlbCBldmVudFxuICAgICAgICogQHByb3BlcnR5IGRlbHRhWVxuICAgICAgICogQG1lbWJlciBFdmVudC5Eb21FdmVudC5PYmplY3RcbiAgICAgICAqL1xuICAgICAgZXZlbnQuZGVsdGFZID0gZGVsdGFZO1xuICAgIH1cblxuICAgIGlmIChkZWx0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvKipcbiAgICAgICAqIGRlbHRhIG9mIG1vdXNld2hlZWwgZXZlbnRcbiAgICAgICAqIEBwcm9wZXJ0eSBkZWx0YVxuICAgICAgICogQG1lbWJlciBFdmVudC5Eb21FdmVudC5PYmplY3RcbiAgICAgICAqL1xuICAgICAgZXZlbnQuZGVsdGEgPSBkZWx0YTtcbiAgICB9XG4gIH1cbn0sIHtcbiAgcmVnOiAvXm1vdXNlfGNvbnRleHRtZW51fGNsaWNrfG1zcG9pbnRlcnwoXkRPTU1vdXNlU2Nyb2xsJCkvaSxcbiAgcHJvcHM6IFsnYnV0dG9ucycsICdjbGllbnRYJywgJ2NsaWVudFknLCAnYnV0dG9uJywgJ29mZnNldFgnLCAncmVsYXRlZFRhcmdldCcsICd3aGljaCcsICdmcm9tRWxlbWVudCcsICd0b0VsZW1lbnQnLCAnb2Zmc2V0WScsICdwYWdlWCcsICdwYWdlWScsICdzY3JlZW5YJywgJ3NjcmVlblknXSxcbiAgZml4OiBmdW5jdGlvbiBmaXgoZXZlbnQsIG5hdGl2ZUV2ZW50KSB7XG4gICAgdmFyIGV2ZW50RG9jID0gdW5kZWZpbmVkO1xuICAgIHZhciBkb2MgPSB1bmRlZmluZWQ7XG4gICAgdmFyIGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICB2YXIgYnV0dG9uID0gbmF0aXZlRXZlbnQuYnV0dG9uO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHBhZ2VYL1kgaWYgbWlzc2luZyBhbmQgY2xpZW50WC9ZIGF2YWlsYWJsZVxuICAgIGlmICh0YXJnZXQgJiYgaXNOdWxsT3JVbmRlZmluZWQoZXZlbnQucGFnZVgpICYmICFpc051bGxPclVuZGVmaW5lZChuYXRpdmVFdmVudC5jbGllbnRYKSkge1xuICAgICAgZXZlbnREb2MgPSB0YXJnZXQub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcbiAgICAgIGRvYyA9IGV2ZW50RG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgIGJvZHkgPSBldmVudERvYy5ib2R5O1xuICAgICAgZXZlbnQucGFnZVggPSBuYXRpdmVFdmVudC5jbGllbnRYICsgKGRvYyAmJiBkb2Muc2Nyb2xsTGVmdCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsTGVmdCB8fCAwKSAtIChkb2MgJiYgZG9jLmNsaWVudExlZnQgfHwgYm9keSAmJiBib2R5LmNsaWVudExlZnQgfHwgMCk7XG4gICAgICBldmVudC5wYWdlWSA9IG5hdGl2ZUV2ZW50LmNsaWVudFkgKyAoZG9jICYmIGRvYy5zY3JvbGxUb3AgfHwgYm9keSAmJiBib2R5LnNjcm9sbFRvcCB8fCAwKSAtIChkb2MgJiYgZG9jLmNsaWVudFRvcCB8fCBib2R5ICYmIGJvZHkuY2xpZW50VG9wIHx8IDApO1xuICAgIH1cblxuICAgIC8vIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxuICAgIC8vIGRvIG5vdCB1c2UgYnV0dG9uXG4gICAgaWYgKCFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGJ1dHRvbiAmIDEpIHtcbiAgICAgICAgZXZlbnQud2hpY2ggPSAxO1xuICAgICAgfSBlbHNlIGlmIChidXR0b24gJiAyKSB7XG4gICAgICAgIGV2ZW50LndoaWNoID0gMztcbiAgICAgIH0gZWxzZSBpZiAoYnV0dG9uICYgNCkge1xuICAgICAgICBldmVudC53aGljaCA9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBldmVudC53aGljaCA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRkIHJlbGF0ZWRUYXJnZXQsIGlmIG5lY2Vzc2FyeVxuICAgIGlmICghZXZlbnQucmVsYXRlZFRhcmdldCAmJiBldmVudC5mcm9tRWxlbWVudCkge1xuICAgICAgZXZlbnQucmVsYXRlZFRhcmdldCA9IGV2ZW50LmZyb21FbGVtZW50ID09PSB0YXJnZXQgPyBldmVudC50b0VsZW1lbnQgOiBldmVudC5mcm9tRWxlbWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbn1dO1xuXG5mdW5jdGlvbiByZXRUcnVlKCkge1xuICByZXR1cm4gVFJVRTtcbn1cblxuZnVuY3Rpb24gcmV0RmFsc2UoKSB7XG4gIHJldHVybiBGQUxTRTtcbn1cblxuZnVuY3Rpb24gRG9tRXZlbnRPYmplY3QobmF0aXZlRXZlbnQpIHtcbiAgdmFyIHR5cGUgPSBuYXRpdmVFdmVudC50eXBlO1xuXG4gIHZhciBpc05hdGl2ZSA9IHR5cGVvZiBuYXRpdmVFdmVudC5zdG9wUHJvcGFnYXRpb24gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG5hdGl2ZUV2ZW50LmNhbmNlbEJ1YmJsZSA9PT0gJ2Jvb2xlYW4nO1xuXG4gIF9FdmVudEJhc2VPYmplY3QyWydkZWZhdWx0J10uY2FsbCh0aGlzKTtcblxuICB0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG5cbiAgLy8gaW4gY2FzZSBkb20gZXZlbnQgaGFzIGJlZW4gbWFyayBhcyBkZWZhdWx0IHByZXZlbnRlZCBieSBsb3dlciBkb20gbm9kZVxuICB2YXIgaXNEZWZhdWx0UHJldmVudGVkID0gcmV0RmFsc2U7XG4gIGlmICgnZGVmYXVsdFByZXZlbnRlZCcgaW4gbmF0aXZlRXZlbnQpIHtcbiAgICBpc0RlZmF1bHRQcmV2ZW50ZWQgPSBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkID8gcmV0VHJ1ZSA6IHJldEZhbHNlO1xuICB9IGVsc2UgaWYgKCdnZXRQcmV2ZW50RGVmYXVsdCcgaW4gbmF0aXZlRXZlbnQpIHtcbiAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTExNTFcbiAgICBpc0RlZmF1bHRQcmV2ZW50ZWQgPSBuYXRpdmVFdmVudC5nZXRQcmV2ZW50RGVmYXVsdCgpID8gcmV0VHJ1ZSA6IHJldEZhbHNlO1xuICB9IGVsc2UgaWYgKCdyZXR1cm5WYWx1ZScgaW4gbmF0aXZlRXZlbnQpIHtcbiAgICBpc0RlZmF1bHRQcmV2ZW50ZWQgPSBuYXRpdmVFdmVudC5yZXR1cm5WYWx1ZSA9PT0gRkFMU0UgPyByZXRUcnVlIDogcmV0RmFsc2U7XG4gIH1cblxuICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGlzRGVmYXVsdFByZXZlbnRlZDtcblxuICB2YXIgZml4Rm5zID0gW107XG4gIHZhciBmaXhGbiA9IHVuZGVmaW5lZDtcbiAgdmFyIGwgPSB1bmRlZmluZWQ7XG4gIHZhciBwcm9wID0gdW5kZWZpbmVkO1xuICB2YXIgcHJvcHMgPSBjb21tb25Qcm9wcy5jb25jYXQoKTtcblxuICBldmVudE5vcm1hbGl6ZXJzLmZvckVhY2goZnVuY3Rpb24gKG5vcm1hbGl6ZXIpIHtcbiAgICBpZiAodHlwZS5tYXRjaChub3JtYWxpemVyLnJlZykpIHtcbiAgICAgIHByb3BzID0gcHJvcHMuY29uY2F0KG5vcm1hbGl6ZXIucHJvcHMpO1xuICAgICAgaWYgKG5vcm1hbGl6ZXIuZml4KSB7XG4gICAgICAgIGZpeEZucy5wdXNoKG5vcm1hbGl6ZXIuZml4KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGwgPSBwcm9wcy5sZW5ndGg7XG5cbiAgLy8gY2xvbmUgcHJvcGVydGllcyBvZiB0aGUgb3JpZ2luYWwgZXZlbnQgb2JqZWN0XG4gIHdoaWxlIChsKSB7XG4gICAgcHJvcCA9IHByb3BzWy0tbF07XG4gICAgdGhpc1twcm9wXSA9IG5hdGl2ZUV2ZW50W3Byb3BdO1xuICB9XG5cbiAgLy8gZml4IHRhcmdldCBwcm9wZXJ0eSwgaWYgbmVjZXNzYXJ5XG4gIGlmICghdGhpcy50YXJnZXQgJiYgaXNOYXRpdmUpIHtcbiAgICB0aGlzLnRhcmdldCA9IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQgfHwgZG9jdW1lbnQ7IC8vIHNyY0VsZW1lbnQgbWlnaHQgbm90IGJlIGRlZmluZWQgZWl0aGVyXG4gIH1cblxuICAvLyBjaGVjayBpZiB0YXJnZXQgaXMgYSB0ZXh0IG5vZGUgKHNhZmFyaSlcbiAgaWYgKHRoaXMudGFyZ2V0ICYmIHRoaXMudGFyZ2V0Lm5vZGVUeXBlID09PSAzKSB7XG4gICAgdGhpcy50YXJnZXQgPSB0aGlzLnRhcmdldC5wYXJlbnROb2RlO1xuICB9XG5cbiAgbCA9IGZpeEZucy5sZW5ndGg7XG5cbiAgd2hpbGUgKGwpIHtcbiAgICBmaXhGbiA9IGZpeEZuc1stLWxdO1xuICAgIGZpeEZuKHRoaXMsIG5hdGl2ZUV2ZW50KTtcbiAgfVxuXG4gIHRoaXMudGltZVN0YW1wID0gbmF0aXZlRXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG59XG5cbnZhciBFdmVudEJhc2VPYmplY3RQcm90byA9IF9FdmVudEJhc2VPYmplY3QyWydkZWZhdWx0J10ucHJvdG90eXBlO1xuXG4oMCwgX29iamVjdEFzc2lnbjJbJ2RlZmF1bHQnXSkoRG9tRXZlbnRPYmplY3QucHJvdG90eXBlLCBFdmVudEJhc2VPYmplY3RQcm90bywge1xuICBjb25zdHJ1Y3RvcjogRG9tRXZlbnRPYmplY3QsXG5cbiAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KCkge1xuICAgIHZhciBlID0gdGhpcy5uYXRpdmVFdmVudDtcblxuICAgIC8vIGlmIHByZXZlbnREZWZhdWx0IGV4aXN0cyBydW4gaXQgb24gdGhlIG9yaWdpbmFsIGV2ZW50XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb3RoZXJ3aXNlIHNldCB0aGUgcmV0dXJuVmFsdWUgcHJvcGVydHkgb2YgdGhlIG9yaWdpbmFsIGV2ZW50IHRvIEZBTFNFIChJRSlcbiAgICAgIGUucmV0dXJuVmFsdWUgPSBGQUxTRTtcbiAgICB9XG5cbiAgICBFdmVudEJhc2VPYmplY3RQcm90by5wcmV2ZW50RGVmYXVsdC5jYWxsKHRoaXMpO1xuICB9LFxuXG4gIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgIHZhciBlID0gdGhpcy5uYXRpdmVFdmVudDtcblxuICAgIC8vIGlmIHN0b3BQcm9wYWdhdGlvbiBleGlzdHMgcnVuIGl0IG9uIHRoZSBvcmlnaW5hbCBldmVudFxuICAgIGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb3RoZXJ3aXNlIHNldCB0aGUgY2FuY2VsQnViYmxlIHByb3BlcnR5IG9mIHRoZSBvcmlnaW5hbCBldmVudCB0byBUUlVFIChJRSlcbiAgICAgIGUuY2FuY2VsQnViYmxlID0gVFJVRTtcbiAgICB9XG5cbiAgICBFdmVudEJhc2VPYmplY3RQcm90by5zdG9wUHJvcGFnYXRpb24uY2FsbCh0aGlzKTtcbiAgfVxufSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IERvbUV2ZW50T2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmMtdGltZS1waWNrZXIvfi9yYy10cmlnZ2VyL34vcmMtdXRpbC9+L2FkZC1kb20tZXZlbnQtbGlzdGVuZXIvbGliL0V2ZW50T2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmMtdGltZS1waWNrZXIvfi9yYy10cmlnZ2VyL34vcmMtdXRpbC9+L2FkZC1kb20tZXZlbnQtbGlzdGVuZXIvfi9vYmplY3QtYXNzaWduL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yZWFjdERvbSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgX3JlYWN0RG9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0RG9tKTtcblxudmFyIF9yY0FsaWduID0gcmVxdWlyZSgncmMtYWxpZ24nKTtcblxudmFyIF9yY0FsaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JjQWxpZ24pO1xuXG52YXIgX3JjQW5pbWF0ZSA9IHJlcXVpcmUoJ3JjLWFuaW1hdGUnKTtcblxudmFyIF9yY0FuaW1hdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmNBbmltYXRlKTtcblxudmFyIF9Qb3B1cElubmVyID0gcmVxdWlyZSgnLi9Qb3B1cElubmVyJyk7XG5cbnZhciBfUG9wdXBJbm5lcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Qb3B1cElubmVyKTtcblxudmFyIF9MYXp5UmVuZGVyQm94ID0gcmVxdWlyZSgnLi9MYXp5UmVuZGVyQm94Jyk7XG5cbnZhciBfTGF6eVJlbmRlckJveDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9MYXp5UmVuZGVyQm94KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbnZhciBQb3B1cCA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdQb3B1cCcsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgdmlzaWJsZTogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIHN0eWxlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBnZXRDbGFzc05hbWVGcm9tQWxpZ246IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkFsaWduOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgZ2V0Um9vdERvbU5vZGU6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbk1vdXNlRW50ZXI6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBhbGlnbjogX3JlYWN0LlByb3BUeXBlcy5hbnksXG4gICAgZGVzdHJveVBvcHVwT25IaWRlOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgY2xhc3NOYW1lOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBwcmVmaXhDbHM6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9uTW91c2VMZWF2ZTogX3JlYWN0LlByb3BUeXBlcy5mdW5jXG4gIH0sXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMucm9vdE5vZGUgPSB0aGlzLmdldFBvcHVwRG9tTm9kZSgpO1xuICB9LFxuICBvbkFsaWduOiBmdW5jdGlvbiBvbkFsaWduKHBvcHVwRG9tTm9kZSwgYWxpZ24pIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBhbGlnbkNsYXNzTmFtZSA9IHByb3BzLmdldENsYXNzTmFtZUZyb21BbGlnbihwcm9wcy5hbGlnbik7XG4gICAgdmFyIGN1cnJlbnRBbGlnbkNsYXNzTmFtZSA9IHByb3BzLmdldENsYXNzTmFtZUZyb21BbGlnbihhbGlnbik7XG4gICAgaWYgKGFsaWduQ2xhc3NOYW1lICE9PSBjdXJyZW50QWxpZ25DbGFzc05hbWUpIHtcbiAgICAgIHRoaXMuY3VycmVudEFsaWduQ2xhc3NOYW1lID0gY3VycmVudEFsaWduQ2xhc3NOYW1lO1xuICAgICAgcG9wdXBEb21Ob2RlLmNsYXNzTmFtZSA9IHRoaXMuZ2V0Q2xhc3NOYW1lKGN1cnJlbnRBbGlnbkNsYXNzTmFtZSk7XG4gICAgfVxuICAgIHByb3BzLm9uQWxpZ24ocG9wdXBEb21Ob2RlLCBhbGlnbik7XG4gIH0sXG4gIGdldFBvcHVwRG9tTm9kZTogZnVuY3Rpb24gZ2V0UG9wdXBEb21Ob2RlKCkge1xuICAgIHJldHVybiBfcmVhY3REb20yW1wiZGVmYXVsdFwiXS5maW5kRE9NTm9kZSh0aGlzLnJlZnMucG9wdXApO1xuICB9LFxuICBnZXRUYXJnZXQ6IGZ1bmN0aW9uIGdldFRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5nZXRSb290RG9tTm9kZSgpO1xuICB9LFxuICBnZXRNYXNrVHJhbnNpdGlvbk5hbWU6IGZ1bmN0aW9uIGdldE1hc2tUcmFuc2l0aW9uTmFtZSgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciB0cmFuc2l0aW9uTmFtZSA9IHByb3BzLm1hc2tUcmFuc2l0aW9uTmFtZTtcbiAgICB2YXIgYW5pbWF0aW9uID0gcHJvcHMubWFza0FuaW1hdGlvbjtcbiAgICBpZiAoIXRyYW5zaXRpb25OYW1lICYmIGFuaW1hdGlvbikge1xuICAgICAgdHJhbnNpdGlvbk5hbWUgPSBwcm9wcy5wcmVmaXhDbHMgKyAnLScgKyBhbmltYXRpb247XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2l0aW9uTmFtZTtcbiAgfSxcbiAgZ2V0VHJhbnNpdGlvbk5hbWU6IGZ1bmN0aW9uIGdldFRyYW5zaXRpb25OYW1lKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHRyYW5zaXRpb25OYW1lID0gcHJvcHMudHJhbnNpdGlvbk5hbWU7XG4gICAgaWYgKCF0cmFuc2l0aW9uTmFtZSAmJiBwcm9wcy5hbmltYXRpb24pIHtcbiAgICAgIHRyYW5zaXRpb25OYW1lID0gcHJvcHMucHJlZml4Q2xzICsgJy0nICsgcHJvcHMuYW5pbWF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNpdGlvbk5hbWU7XG4gIH0sXG4gIGdldENsYXNzTmFtZTogZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKGN1cnJlbnRBbGlnbkNsYXNzTmFtZSkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLnByZWZpeENscyArICcgJyArIHRoaXMucHJvcHMuY2xhc3NOYW1lICsgJyAnICsgY3VycmVudEFsaWduQ2xhc3NOYW1lO1xuICB9LFxuICBnZXRQb3B1cEVsZW1lbnQ6IGZ1bmN0aW9uIGdldFBvcHVwRWxlbWVudCgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBhbGlnbiA9IHByb3BzLmFsaWduO1xuICAgIHZhciBzdHlsZSA9IHByb3BzLnN0eWxlO1xuICAgIHZhciB2aXNpYmxlID0gcHJvcHMudmlzaWJsZTtcbiAgICB2YXIgcHJlZml4Q2xzID0gcHJvcHMucHJlZml4Q2xzO1xuICAgIHZhciBkZXN0cm95UG9wdXBPbkhpZGUgPSBwcm9wcy5kZXN0cm95UG9wdXBPbkhpZGU7XG5cbiAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy5nZXRDbGFzc05hbWUodGhpcy5jdXJyZW50QWxpZ25DbGFzc05hbWUgfHwgcHJvcHMuZ2V0Q2xhc3NOYW1lRnJvbUFsaWduKGFsaWduKSk7XG4gICAgdmFyIGhpZGRlbkNsYXNzTmFtZSA9IHByZWZpeENscyArICctaGlkZGVuJztcbiAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgIHRoaXMuY3VycmVudEFsaWduQ2xhc3NOYW1lID0gbnVsbDtcbiAgICB9XG4gICAgdmFyIG5ld1N0eWxlID0gX2V4dGVuZHMoe30sIHN0eWxlLCB0aGlzLmdldFpJbmRleFN0eWxlKCkpO1xuICAgIHZhciBwb3B1cElubmVyUHJvcHMgPSB7XG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgIHByZWZpeENsczogcHJlZml4Q2xzLFxuICAgICAgcmVmOiAncG9wdXAnLFxuICAgICAgb25Nb3VzZUVudGVyOiBwcm9wcy5vbk1vdXNlRW50ZXIsXG4gICAgICBvbk1vdXNlTGVhdmU6IHByb3BzLm9uTW91c2VMZWF2ZSxcbiAgICAgIHN0eWxlOiBuZXdTdHlsZVxuICAgIH07XG4gICAgaWYgKGRlc3Ryb3lQb3B1cE9uSGlkZSkge1xuICAgICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIF9yY0FuaW1hdGUyW1wiZGVmYXVsdFwiXSxcbiAgICAgICAge1xuICAgICAgICAgIGNvbXBvbmVudDogJycsXG4gICAgICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgICAgIHRyYW5zaXRpb25BcHBlYXI6IHRydWUsXG4gICAgICAgICAgdHJhbnNpdGlvbk5hbWU6IHRoaXMuZ2V0VHJhbnNpdGlvbk5hbWUoKVxuICAgICAgICB9LFxuICAgICAgICB2aXNpYmxlID8gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICBfcmNBbGlnbjJbXCJkZWZhdWx0XCJdLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRhcmdldDogdGhpcy5nZXRUYXJnZXQsXG4gICAgICAgICAgICBrZXk6ICdwb3B1cCcsXG4gICAgICAgICAgICBtb25pdG9yV2luZG93UmVzaXplOiB0cnVlLFxuICAgICAgICAgICAgYWxpZ246IGFsaWduLFxuICAgICAgICAgICAgb25BbGlnbjogdGhpcy5vbkFsaWduXG4gICAgICAgICAgfSxcbiAgICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgX1BvcHVwSW5uZXIyW1wiZGVmYXVsdFwiXSxcbiAgICAgICAgICAgIF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSwgcG9wdXBJbm5lclByb3BzKSxcbiAgICAgICAgICAgIHByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgKVxuICAgICAgICApIDogbnVsbFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBfcmNBbmltYXRlMltcImRlZmF1bHRcIl0sXG4gICAgICB7XG4gICAgICAgIGNvbXBvbmVudDogJycsXG4gICAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgdHJhbnNpdGlvbkFwcGVhcjogdHJ1ZSxcbiAgICAgICAgdHJhbnNpdGlvbk5hbWU6IHRoaXMuZ2V0VHJhbnNpdGlvbk5hbWUoKSxcbiAgICAgICAgc2hvd1Byb3A6ICd4VmlzaWJsZSdcbiAgICAgIH0sXG4gICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICBfcmNBbGlnbjJbXCJkZWZhdWx0XCJdLFxuICAgICAgICB7XG4gICAgICAgICAgdGFyZ2V0OiB0aGlzLmdldFRhcmdldCxcbiAgICAgICAgICBrZXk6ICdwb3B1cCcsXG4gICAgICAgICAgbW9uaXRvcldpbmRvd1Jlc2l6ZTogdHJ1ZSxcbiAgICAgICAgICB4VmlzaWJsZTogdmlzaWJsZSxcbiAgICAgICAgICBjaGlsZHJlblByb3BzOiB7IHZpc2libGU6ICd4VmlzaWJsZScgfSxcbiAgICAgICAgICBkaXNhYmxlZDogIXZpc2libGUsXG4gICAgICAgICAgYWxpZ246IGFsaWduLFxuICAgICAgICAgIG9uQWxpZ246IHRoaXMub25BbGlnblxuICAgICAgICB9LFxuICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIF9Qb3B1cElubmVyMltcImRlZmF1bHRcIl0sXG4gICAgICAgICAgX2V4dGVuZHMoe1xuICAgICAgICAgICAgaGlkZGVuQ2xhc3NOYW1lOiBoaWRkZW5DbGFzc05hbWVcbiAgICAgICAgICB9LCBwb3B1cElubmVyUHJvcHMpLFxuICAgICAgICAgIHByb3BzLmNoaWxkcmVuXG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICB9LFxuICBnZXRaSW5kZXhTdHlsZTogZnVuY3Rpb24gZ2V0WkluZGV4U3R5bGUoKSB7XG4gICAgdmFyIHN0eWxlID0ge307XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICBpZiAocHJvcHMuekluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0eWxlLnpJbmRleCA9IHByb3BzLnpJbmRleDtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9LFxuICBnZXRNYXNrRWxlbWVudDogZnVuY3Rpb24gZ2V0TWFza0VsZW1lbnQoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgbWFza0VsZW1lbnQgPSB2b2lkIDA7XG4gICAgaWYgKHByb3BzLm1hc2spIHtcbiAgICAgIHZhciBtYXNrVHJhbnNpdGlvbiA9IHRoaXMuZ2V0TWFza1RyYW5zaXRpb25OYW1lKCk7XG4gICAgICBtYXNrRWxlbWVudCA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xhenlSZW5kZXJCb3gyW1wiZGVmYXVsdFwiXSwge1xuICAgICAgICBzdHlsZTogdGhpcy5nZXRaSW5kZXhTdHlsZSgpLFxuICAgICAgICBrZXk6ICdtYXNrJyxcbiAgICAgICAgY2xhc3NOYW1lOiBwcm9wcy5wcmVmaXhDbHMgKyAnLW1hc2snLFxuICAgICAgICBoaWRkZW5DbGFzc05hbWU6IHByb3BzLnByZWZpeENscyArICctbWFzay1oaWRkZW4nLFxuICAgICAgICB2aXNpYmxlOiBwcm9wcy52aXNpYmxlXG4gICAgICB9KTtcbiAgICAgIGlmIChtYXNrVHJhbnNpdGlvbikge1xuICAgICAgICBtYXNrRWxlbWVudCA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgX3JjQW5pbWF0ZTJbXCJkZWZhdWx0XCJdLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGtleTogJ21hc2snLFxuICAgICAgICAgICAgc2hvd1Byb3A6ICd2aXNpYmxlJyxcbiAgICAgICAgICAgIHRyYW5zaXRpb25BcHBlYXI6IHRydWUsXG4gICAgICAgICAgICBjb21wb25lbnQ6ICcnLFxuICAgICAgICAgICAgdHJhbnNpdGlvbk5hbWU6IG1hc2tUcmFuc2l0aW9uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtYXNrRWxlbWVudFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFza0VsZW1lbnQ7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgJ2RpdicsXG4gICAgICBudWxsLFxuICAgICAgdGhpcy5nZXRNYXNrRWxlbWVudCgpLFxuICAgICAgdGhpcy5nZXRQb3B1cEVsZW1lbnQoKVxuICAgICk7XG4gIH1cbn0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFBvcHVwO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmMtdGltZS1waWNrZXIvfi9yYy10cmlnZ2VyL2xpYi9Qb3B1cC5qc1xuICoqIG1vZHVsZSBpZCA9IDExM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gZXhwb3J0IHRoaXMgcGFja2FnZSdzIGFwaVxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX0FsaWduID0gcmVxdWlyZSgnLi9BbGlnbicpO1xuXG52YXIgX0FsaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0FsaWduKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gX0FsaWduMlsnZGVmYXVsdCddO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmMtdGltZS1waWNrZXIvfi9yYy10cmlnZ2VyL34vcmMtYWxpZ24vbGliL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yZWFjdERvbSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgX3JlYWN0RG9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0RG9tKTtcblxudmFyIF9kb21BbGlnbiA9IHJlcXVpcmUoJ2RvbS1hbGlnbicpO1xuXG52YXIgX2RvbUFsaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RvbUFsaWduKTtcblxudmFyIF9yY1V0aWwgPSByZXF1aXJlKCdyYy11dGlsJyk7XG5cbnZhciBfaXNXaW5kb3cgPSByZXF1aXJlKCcuL2lzV2luZG93Jyk7XG5cbnZhciBfaXNXaW5kb3cyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNXaW5kb3cpO1xuXG5mdW5jdGlvbiBidWZmZXIoZm4sIG1zKSB7XG4gIHZhciB0aW1lciA9IHVuZGVmaW5lZDtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJ1ZmZlckZuKCkge1xuICAgIGlmICh0aW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICB9XG4gICAgdGltZXIgPSBzZXRUaW1lb3V0KGZuLCBtcyk7XG4gIH07XG59XG5cbnZhciBBbGlnbiA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnQWxpZ24nLFxuXG4gIHByb3BUeXBlczoge1xuICAgIGNoaWxkcmVuUHJvcHM6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIGFsaWduOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICAgIHRhcmdldDogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uQWxpZ246IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBtb25pdG9yQnVmZmVyVGltZTogX3JlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgbW9uaXRvcldpbmRvd1Jlc2l6ZTogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGRpc2FibGVkOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgY2hpbGRyZW46IF9yZWFjdC5Qcm9wVHlwZXMuYW55XG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiBnZXREZWZhdWx0UHJvcHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhcmdldDogZnVuY3Rpb24gdGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgICAgfSxcbiAgICAgIG9uQWxpZ246IGZ1bmN0aW9uIG9uQWxpZ24oKSB7fSxcbiAgICAgIG1vbml0b3JCdWZmZXJUaW1lOiA1MCxcbiAgICAgIG1vbml0b3JXaW5kb3dSZXNpemU6IGZhbHNlLFxuICAgICAgZGlzYWJsZWQ6IGZhbHNlXG4gICAgfTtcbiAgfSxcblxuICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAvLyBpZiBwYXJlbnQgcmVmIG5vdCBhdHRhY2hlZCAuLi4uIHVzZSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZFxuICAgIGlmICghcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBfcmVhY3REb20yWydkZWZhdWx0J10uZmluZERPTU5vZGUodGhpcyk7XG4gICAgICBwcm9wcy5vbkFsaWduKHNvdXJjZSwgKDAsIF9kb21BbGlnbjJbJ2RlZmF1bHQnXSkoc291cmNlLCBwcm9wcy50YXJnZXQoKSwgcHJvcHMuYWxpZ24pKTtcbiAgICAgIGlmIChwcm9wcy5tb25pdG9yV2luZG93UmVzaXplKSB7XG4gICAgICAgIHRoaXMuc3RhcnRNb25pdG9yV2luZG93UmVzaXplKCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgIHZhciByZUFsaWduID0gZmFsc2U7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgY3VycmVudFRhcmdldCA9IHVuZGVmaW5lZDtcblxuICAgIGlmICghcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIGlmIChwcmV2UHJvcHMuZGlzYWJsZWQgfHwgcHJldlByb3BzLmFsaWduICE9PSBwcm9wcy5hbGlnbikge1xuICAgICAgICByZUFsaWduID0gdHJ1ZTtcbiAgICAgICAgY3VycmVudFRhcmdldCA9IHByb3BzLnRhcmdldCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGxhc3RUYXJnZXQgPSBwcmV2UHJvcHMudGFyZ2V0KCk7XG4gICAgICAgIGN1cnJlbnRUYXJnZXQgPSBwcm9wcy50YXJnZXQoKTtcbiAgICAgICAgaWYgKCgwLCBfaXNXaW5kb3cyWydkZWZhdWx0J10pKGxhc3RUYXJnZXQpICYmICgwLCBfaXNXaW5kb3cyWydkZWZhdWx0J10pKGN1cnJlbnRUYXJnZXQpKSB7XG4gICAgICAgICAgcmVBbGlnbiA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3RUYXJnZXQgIT09IGN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgICByZUFsaWduID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZUFsaWduKSB7XG4gICAgICB2YXIgc291cmNlID0gX3JlYWN0RG9tMlsnZGVmYXVsdCddLmZpbmRET01Ob2RlKHRoaXMpO1xuICAgICAgcHJvcHMub25BbGlnbihzb3VyY2UsICgwLCBfZG9tQWxpZ24yWydkZWZhdWx0J10pKHNvdXJjZSwgY3VycmVudFRhcmdldCwgcHJvcHMuYWxpZ24pKTtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMubW9uaXRvcldpbmRvd1Jlc2l6ZSAmJiAhcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuc3RhcnRNb25pdG9yV2luZG93UmVzaXplKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RvcE1vbml0b3JXaW5kb3dSZXNpemUoKTtcbiAgICB9XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuc3RvcE1vbml0b3JXaW5kb3dSZXNpemUoKTtcbiAgfSxcblxuICBvbldpbmRvd1Jlc2l6ZTogZnVuY3Rpb24gb25XaW5kb3dSZXNpemUoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICBpZiAoIXByb3BzLmRpc2FibGVkKSB7XG4gICAgICB2YXIgc291cmNlID0gX3JlYWN0RG9tMlsnZGVmYXVsdCddLmZpbmRET01Ob2RlKHRoaXMpO1xuICAgICAgcHJvcHMub25BbGlnbihzb3VyY2UsICgwLCBfZG9tQWxpZ24yWydkZWZhdWx0J10pKHNvdXJjZSwgcHJvcHMudGFyZ2V0KCksIHByb3BzLmFsaWduKSk7XG4gICAgfVxuICB9LFxuXG4gIHN0YXJ0TW9uaXRvcldpbmRvd1Jlc2l6ZTogZnVuY3Rpb24gc3RhcnRNb25pdG9yV2luZG93UmVzaXplKCkge1xuICAgIGlmICghdGhpcy5yZXNpemVIYW5kbGVyKSB7XG4gICAgICB0aGlzLnJlc2l6ZUhhbmRsZXIgPSBfcmNVdGlsLkRvbS5hZGRFdmVudExpc3RlbmVyKHdpbmRvdywgJ3Jlc2l6ZScsIGJ1ZmZlcih0aGlzLm9uV2luZG93UmVzaXplLCB0aGlzLnByb3BzLm1vbml0b3JCdWZmZXJUaW1lKSk7XG4gICAgfVxuICB9LFxuXG4gIHN0b3BNb25pdG9yV2luZG93UmVzaXplOiBmdW5jdGlvbiBzdG9wTW9uaXRvcldpbmRvd1Jlc2l6ZSgpIHtcbiAgICBpZiAodGhpcy5yZXNpemVIYW5kbGVyKSB7XG4gICAgICB0aGlzLnJlc2l6ZUhhbmRsZXIucmVtb3ZlKCk7XG4gICAgICB0aGlzLnJlc2l6ZUhhbmRsZXIgPSBudWxsO1xuICAgIH1cbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgY2hpbGRyZW5Qcm9wcyA9IF9wcm9wcy5jaGlsZHJlblByb3BzO1xuICAgIHZhciBjaGlsZHJlbiA9IF9wcm9wcy5jaGlsZHJlbjtcblxuICAgIHZhciBjaGlsZCA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKTtcbiAgICBpZiAoY2hpbGRyZW5Qcm9wcykge1xuICAgICAgdmFyIG5ld1Byb3BzID0ge307XG4gICAgICBmb3IgKHZhciBwcm9wIGluIGNoaWxkcmVuUHJvcHMpIHtcbiAgICAgICAgaWYgKGNoaWxkcmVuUHJvcHMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICBuZXdQcm9wc1twcm9wXSA9IHRoaXMucHJvcHNbY2hpbGRyZW5Qcm9wc1twcm9wXV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY2xvbmVFbGVtZW50KGNoaWxkLCBuZXdQcm9wcyk7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZDtcbiAgfVxufSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEFsaWduO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmMtdGltZS1waWNrZXIvfi9yYy10cmlnZ2VyL34vcmMtYWxpZ24vbGliL0FsaWduLmpzXG4gKiogbW9kdWxlIGlkID0gMTE1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIGFsaWduIGRvbSBub2RlIGZsZXhpYmx5XG4gKiBAYXV0aG9yIHlpbWluZ2hlQGdtYWlsLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIF91dGlsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlscyk7XG5cbnZhciBfZ2V0T2Zmc2V0UGFyZW50ID0gcmVxdWlyZSgnLi9nZXRPZmZzZXRQYXJlbnQnKTtcblxudmFyIF9nZXRPZmZzZXRQYXJlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0T2Zmc2V0UGFyZW50KTtcblxudmFyIF9nZXRWaXNpYmxlUmVjdEZvckVsZW1lbnQgPSByZXF1aXJlKCcuL2dldFZpc2libGVSZWN0Rm9yRWxlbWVudCcpO1xuXG52YXIgX2dldFZpc2libGVSZWN0Rm9yRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRWaXNpYmxlUmVjdEZvckVsZW1lbnQpO1xuXG52YXIgX2FkanVzdEZvclZpZXdwb3J0ID0gcmVxdWlyZSgnLi9hZGp1c3RGb3JWaWV3cG9ydCcpO1xuXG52YXIgX2FkanVzdEZvclZpZXdwb3J0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FkanVzdEZvclZpZXdwb3J0KTtcblxudmFyIF9nZXRSZWdpb24gPSByZXF1aXJlKCcuL2dldFJlZ2lvbicpO1xuXG52YXIgX2dldFJlZ2lvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRSZWdpb24pO1xuXG52YXIgX2dldEVsRnV0dXJlUG9zID0gcmVxdWlyZSgnLi9nZXRFbEZ1dHVyZVBvcycpO1xuXG52YXIgX2dldEVsRnV0dXJlUG9zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEVsRnV0dXJlUG9zKTtcblxuLy8gaHR0cDovL3lpbWluZ2hlLml0ZXllLmNvbS9ibG9nLzExMjQ3MjBcblxuZnVuY3Rpb24gaXNGYWlsWChlbEZ1dHVyZVBvcywgZWxSZWdpb24sIHZpc2libGVSZWN0KSB7XG4gIHJldHVybiBlbEZ1dHVyZVBvcy5sZWZ0IDwgdmlzaWJsZVJlY3QubGVmdCB8fCBlbEZ1dHVyZVBvcy5sZWZ0ICsgZWxSZWdpb24ud2lkdGggPiB2aXNpYmxlUmVjdC5yaWdodDtcbn1cblxuZnVuY3Rpb24gaXNGYWlsWShlbEZ1dHVyZVBvcywgZWxSZWdpb24sIHZpc2libGVSZWN0KSB7XG4gIHJldHVybiBlbEZ1dHVyZVBvcy50b3AgPCB2aXNpYmxlUmVjdC50b3AgfHwgZWxGdXR1cmVQb3MudG9wICsgZWxSZWdpb24uaGVpZ2h0ID4gdmlzaWJsZVJlY3QuYm90dG9tO1xufVxuXG5mdW5jdGlvbiBpc0NvbXBsZXRlRmFpbFgoZWxGdXR1cmVQb3MsIGVsUmVnaW9uLCB2aXNpYmxlUmVjdCkge1xuICByZXR1cm4gZWxGdXR1cmVQb3MubGVmdCA+IHZpc2libGVSZWN0LnJpZ2h0IHx8IGVsRnV0dXJlUG9zLmxlZnQgKyBlbFJlZ2lvbi53aWR0aCA8IHZpc2libGVSZWN0LmxlZnQ7XG59XG5cbmZ1bmN0aW9uIGlzQ29tcGxldGVGYWlsWShlbEZ1dHVyZVBvcywgZWxSZWdpb24sIHZpc2libGVSZWN0KSB7XG4gIHJldHVybiBlbEZ1dHVyZVBvcy50b3AgPiB2aXNpYmxlUmVjdC5ib3R0b20gfHwgZWxGdXR1cmVQb3MudG9wICsgZWxSZWdpb24uaGVpZ2h0IDwgdmlzaWJsZVJlY3QudG9wO1xufVxuXG5mdW5jdGlvbiBmbGlwKHBvaW50cywgcmVnLCBtYXApIHtcbiAgdmFyIHJldCA9IFtdO1xuICBfdXRpbHMyWydkZWZhdWx0J10uZWFjaChwb2ludHMsIGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0LnB1c2gocC5yZXBsYWNlKHJlZywgZnVuY3Rpb24gKG0pIHtcbiAgICAgIHJldHVybiBtYXBbbV07XG4gICAgfSkpO1xuICB9KTtcbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZmxpcE9mZnNldChvZmZzZXQsIGluZGV4KSB7XG4gIG9mZnNldFtpbmRleF0gPSAtb2Zmc2V0W2luZGV4XTtcbiAgcmV0dXJuIG9mZnNldDtcbn1cblxuZnVuY3Rpb24gY29udmVydE9mZnNldChzdHIsIG9mZnNldExlbikge1xuICB2YXIgbiA9IHVuZGVmaW5lZDtcbiAgaWYgKC8lJC8udGVzdChzdHIpKSB7XG4gICAgbiA9IHBhcnNlSW50KHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDEpLCAxMCkgLyAxMDAgKiBvZmZzZXRMZW47XG4gIH0gZWxzZSB7XG4gICAgbiA9IHBhcnNlSW50KHN0ciwgMTApO1xuICB9XG4gIHJldHVybiBuIHx8IDA7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU9mZnNldChvZmZzZXQsIGVsKSB7XG4gIG9mZnNldFswXSA9IGNvbnZlcnRPZmZzZXQob2Zmc2V0WzBdLCBlbC53aWR0aCk7XG4gIG9mZnNldFsxXSA9IGNvbnZlcnRPZmZzZXQob2Zmc2V0WzFdLCBlbC5oZWlnaHQpO1xufVxuXG5mdW5jdGlvbiBkb21BbGlnbihlbCwgcmVmTm9kZSwgYWxpZ24pIHtcbiAgdmFyIHBvaW50cyA9IGFsaWduLnBvaW50cztcbiAgdmFyIG9mZnNldCA9IGFsaWduLm9mZnNldCB8fCBbMCwgMF07XG4gIHZhciB0YXJnZXRPZmZzZXQgPSBhbGlnbi50YXJnZXRPZmZzZXQgfHwgWzAsIDBdO1xuICB2YXIgb3ZlcmZsb3cgPSBhbGlnbi5vdmVyZmxvdztcbiAgdmFyIHRhcmdldCA9IGFsaWduLnRhcmdldCB8fCByZWZOb2RlO1xuICB2YXIgc291cmNlID0gYWxpZ24uc291cmNlIHx8IGVsO1xuICBvZmZzZXQgPSBbXS5jb25jYXQob2Zmc2V0KTtcbiAgdGFyZ2V0T2Zmc2V0ID0gW10uY29uY2F0KHRhcmdldE9mZnNldCk7XG4gIG92ZXJmbG93ID0gb3ZlcmZsb3cgfHwge307XG4gIHZhciBuZXdPdmVyZmxvd0NmZyA9IHt9O1xuXG4gIHZhciBmYWlsID0gMDtcbiAgLy8g5b2T5YmN6IqC54K55Y+v5Lul6KKr5pS+572u55qE5pi+56S65Yy65Z+fXG4gIHZhciB2aXNpYmxlUmVjdCA9ICgwLCBfZ2V0VmlzaWJsZVJlY3RGb3JFbGVtZW50MlsnZGVmYXVsdCddKShzb3VyY2UpO1xuICAvLyDlvZPliY3oioLngrnmiYDljaDnmoTljLrln58sIGxlZnQvdG9wL3dpZHRoL2hlaWdodFxuICB2YXIgZWxSZWdpb24gPSAoMCwgX2dldFJlZ2lvbjJbJ2RlZmF1bHQnXSkoc291cmNlKTtcbiAgLy8g5Y+C54Wn6IqC54K55omA5Y2g55qE5Yy65Z+fLCBsZWZ0L3RvcC93aWR0aC9oZWlnaHRcbiAgdmFyIHJlZk5vZGVSZWdpb24gPSAoMCwgX2dldFJlZ2lvbjJbJ2RlZmF1bHQnXSkodGFyZ2V0KTtcbiAgLy8g5bCGIG9mZnNldCDovazmjaLmiJDmlbDlgLzvvIzmlK/mjIHnmb7liIbmr5RcbiAgbm9ybWFsaXplT2Zmc2V0KG9mZnNldCwgZWxSZWdpb24pO1xuICBub3JtYWxpemVPZmZzZXQodGFyZ2V0T2Zmc2V0LCByZWZOb2RlUmVnaW9uKTtcbiAgLy8g5b2T5YmN6IqC54K55bCG6KaB6KKr5pS+572u55qE5L2N572uXG4gIHZhciBlbEZ1dHVyZVBvcyA9ICgwLCBfZ2V0RWxGdXR1cmVQb3MyWydkZWZhdWx0J10pKGVsUmVnaW9uLCByZWZOb2RlUmVnaW9uLCBwb2ludHMsIG9mZnNldCwgdGFyZ2V0T2Zmc2V0KTtcbiAgLy8g5b2T5YmN6IqC54K55bCG6KaB5omA5aSE55qE5Yy65Z+fXG4gIHZhciBuZXdFbFJlZ2lvbiA9IF91dGlsczJbJ2RlZmF1bHQnXS5tZXJnZShlbFJlZ2lvbiwgZWxGdXR1cmVQb3MpO1xuXG4gIC8vIOWmguaenOWPr+inhuWMuuWfn+S4jeiDveWujOWFqOaUvue9ruW9k+WJjeiKgueCueaXtuWFgeiuuOiwg+aVtFxuICBpZiAodmlzaWJsZVJlY3QgJiYgKG92ZXJmbG93LmFkanVzdFggfHwgb3ZlcmZsb3cuYWRqdXN0WSkpIHtcbiAgICBpZiAob3ZlcmZsb3cuYWRqdXN0WCkge1xuICAgICAgLy8g5aaC5p6c5qiq5ZCR5LiN6IO95pS+5LiLXG4gICAgICBpZiAoaXNGYWlsWChlbEZ1dHVyZVBvcywgZWxSZWdpb24sIHZpc2libGVSZWN0KSkge1xuICAgICAgICAvLyDlr7npvZDkvY3nva7lj43kuItcbiAgICAgICAgdmFyIG5ld1BvaW50cyA9IGZsaXAocG9pbnRzLCAvW2xyXS9pZywge1xuICAgICAgICAgIGw6ICdyJyxcbiAgICAgICAgICByOiAnbCdcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIOWBj+enu+mHj+S5n+WPjeS4i1xuICAgICAgICB2YXIgbmV3T2Zmc2V0ID0gZmxpcE9mZnNldChvZmZzZXQsIDApO1xuICAgICAgICB2YXIgbmV3VGFyZ2V0T2Zmc2V0ID0gZmxpcE9mZnNldCh0YXJnZXRPZmZzZXQsIDApO1xuICAgICAgICB2YXIgbmV3RWxGdXR1cmVQb3MgPSAoMCwgX2dldEVsRnV0dXJlUG9zMlsnZGVmYXVsdCddKShlbFJlZ2lvbiwgcmVmTm9kZVJlZ2lvbiwgbmV3UG9pbnRzLCBuZXdPZmZzZXQsIG5ld1RhcmdldE9mZnNldCk7XG4gICAgICAgIGlmICghaXNDb21wbGV0ZUZhaWxYKG5ld0VsRnV0dXJlUG9zLCBlbFJlZ2lvbiwgdmlzaWJsZVJlY3QpKSB7XG4gICAgICAgICAgZmFpbCA9IDE7XG4gICAgICAgICAgcG9pbnRzID0gbmV3UG9pbnRzO1xuICAgICAgICAgIG9mZnNldCA9IG5ld09mZnNldDtcbiAgICAgICAgICB0YXJnZXRPZmZzZXQgPSBuZXdUYXJnZXRPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3ZlcmZsb3cuYWRqdXN0WSkge1xuICAgICAgLy8g5aaC5p6c57q15ZCR5LiN6IO95pS+5LiLXG4gICAgICBpZiAoaXNGYWlsWShlbEZ1dHVyZVBvcywgZWxSZWdpb24sIHZpc2libGVSZWN0KSkge1xuICAgICAgICAvLyDlr7npvZDkvY3nva7lj43kuItcbiAgICAgICAgdmFyIG5ld1BvaW50cyA9IGZsaXAocG9pbnRzLCAvW3RiXS9pZywge1xuICAgICAgICAgIHQ6ICdiJyxcbiAgICAgICAgICBiOiAndCdcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIOWBj+enu+mHj+S5n+WPjeS4i1xuICAgICAgICB2YXIgbmV3T2Zmc2V0ID0gZmxpcE9mZnNldChvZmZzZXQsIDEpO1xuICAgICAgICB2YXIgbmV3VGFyZ2V0T2Zmc2V0ID0gZmxpcE9mZnNldCh0YXJnZXRPZmZzZXQsIDEpO1xuICAgICAgICB2YXIgbmV3RWxGdXR1cmVQb3MgPSAoMCwgX2dldEVsRnV0dXJlUG9zMlsnZGVmYXVsdCddKShlbFJlZ2lvbiwgcmVmTm9kZVJlZ2lvbiwgbmV3UG9pbnRzLCBuZXdPZmZzZXQsIG5ld1RhcmdldE9mZnNldCk7XG4gICAgICAgIGlmICghaXNDb21wbGV0ZUZhaWxZKG5ld0VsRnV0dXJlUG9zLCBlbFJlZ2lvbiwgdmlzaWJsZVJlY3QpKSB7XG4gICAgICAgICAgZmFpbCA9IDE7XG4gICAgICAgICAgcG9pbnRzID0gbmV3UG9pbnRzO1xuICAgICAgICAgIG9mZnNldCA9IG5ld09mZnNldDtcbiAgICAgICAgICB0YXJnZXRPZmZzZXQgPSBuZXdUYXJnZXRPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDlpoLmnpzlpLHotKXvvIzph43mlrDorqHnrpflvZPliY3oioLngrnlsIbopoHooqvmlL7nva7nmoTkvY3nva5cbiAgICBpZiAoZmFpbCkge1xuICAgICAgZWxGdXR1cmVQb3MgPSAoMCwgX2dldEVsRnV0dXJlUG9zMlsnZGVmYXVsdCddKShlbFJlZ2lvbiwgcmVmTm9kZVJlZ2lvbiwgcG9pbnRzLCBvZmZzZXQsIHRhcmdldE9mZnNldCk7XG4gICAgICBfdXRpbHMyWydkZWZhdWx0J10ubWl4KG5ld0VsUmVnaW9uLCBlbEZ1dHVyZVBvcyk7XG4gICAgfVxuXG4gICAgLy8g5qOA5p+l5Y+N5LiL5ZCO55qE5L2N572u5piv5ZCm5Y+v5Lul5pS+5LiL5LqGXG4gICAgLy8g5aaC5p6c5LuN54S25pS+5LiN5LiL5Y+q5pyJ5oyH5a6a5LqG5Y+v5Lul6LCD5pW05b2T5YmN5pa55ZCR5omN6LCD5pW0XG4gICAgbmV3T3ZlcmZsb3dDZmcuYWRqdXN0WCA9IG92ZXJmbG93LmFkanVzdFggJiYgaXNGYWlsWChlbEZ1dHVyZVBvcywgZWxSZWdpb24sIHZpc2libGVSZWN0KTtcblxuICAgIG5ld092ZXJmbG93Q2ZnLmFkanVzdFkgPSBvdmVyZmxvdy5hZGp1c3RZICYmIGlzRmFpbFkoZWxGdXR1cmVQb3MsIGVsUmVnaW9uLCB2aXNpYmxlUmVjdCk7XG5cbiAgICAvLyDnoa7lrp7opoHosIPmlbTvvIznlJroh7Plj6/og73kvJrosIPmlbTpq5jluqblrr3luqZcbiAgICBpZiAobmV3T3ZlcmZsb3dDZmcuYWRqdXN0WCB8fCBuZXdPdmVyZmxvd0NmZy5hZGp1c3RZKSB7XG4gICAgICBuZXdFbFJlZ2lvbiA9ICgwLCBfYWRqdXN0Rm9yVmlld3BvcnQyWydkZWZhdWx0J10pKGVsRnV0dXJlUG9zLCBlbFJlZ2lvbiwgdmlzaWJsZVJlY3QsIG5ld092ZXJmbG93Q2ZnKTtcbiAgICB9XG4gIH1cblxuICAvLyBuZWVkIGp1ZGdlIHRvIGluIGNhc2Ugc2V0IGZpeGVkIHdpdGggaW4gY3NzIG9uIGhlaWdodCBhdXRvIGVsZW1lbnRcbiAgaWYgKG5ld0VsUmVnaW9uLndpZHRoICE9PSBlbFJlZ2lvbi53aWR0aCkge1xuICAgIF91dGlsczJbJ2RlZmF1bHQnXS5jc3Moc291cmNlLCAnd2lkdGgnLCBzb3VyY2Uud2lkdGgoKSArIG5ld0VsUmVnaW9uLndpZHRoIC0gZWxSZWdpb24ud2lkdGgpO1xuICB9XG5cbiAgaWYgKG5ld0VsUmVnaW9uLmhlaWdodCAhPT0gZWxSZWdpb24uaGVpZ2h0KSB7XG4gICAgX3V0aWxzMlsnZGVmYXVsdCddLmNzcyhzb3VyY2UsICdoZWlnaHQnLCBzb3VyY2UuaGVpZ2h0KCkgKyBuZXdFbFJlZ2lvbi5oZWlnaHQgLSBlbFJlZ2lvbi5oZWlnaHQpO1xuICB9XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2tpc3N5dGVhbS9raXNzeS9pc3N1ZXMvMTkwXG4gIC8vIGh0dHA6Ly9sb2NhbGhvc3Q6ODg4OC9raXNzeS9zcmMvb3ZlcmxheS9kZW1vL290aGVyL3JlbGF0aXZlX2FsaWduL2FsaWduLmh0bWxcbiAgLy8g55u45a+55LqO5bGP5bmV5L2N572u5rKh5Y+Y77yM6ICMIGxlZnQvdG9wIOWPmOS6hlxuICAvLyDkvovlpoIgPGRpdiAncmVsYXRpdmUnPjxlbCBhYnNvbHV0ZT48L2Rpdj5cbiAgX3V0aWxzMlsnZGVmYXVsdCddLm9mZnNldChzb3VyY2UsIHtcbiAgICBsZWZ0OiBuZXdFbFJlZ2lvbi5sZWZ0LFxuICAgIHRvcDogbmV3RWxSZWdpb24udG9wXG4gIH0sIHtcbiAgICB1c2VDc3NSaWdodDogYWxpZ24udXNlQ3NzUmlnaHQsXG4gICAgdXNlQ3NzQm90dG9tOiBhbGlnbi51c2VDc3NCb3R0b21cbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBwb2ludHM6IHBvaW50cyxcbiAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICB0YXJnZXRPZmZzZXQ6IHRhcmdldE9mZnNldCxcbiAgICBvdmVyZmxvdzogbmV3T3ZlcmZsb3dDZmdcbiAgfTtcbn1cblxuZG9tQWxpZ24uX19nZXRPZmZzZXRQYXJlbnQgPSBfZ2V0T2Zmc2V0UGFyZW50MlsnZGVmYXVsdCddO1xuXG5kb21BbGlnbi5fX2dldFZpc2libGVSZWN0Rm9yRWxlbWVudCA9IF9nZXRWaXNpYmxlUmVjdEZvckVsZW1lbnQyWydkZWZhdWx0J107XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGRvbUFsaWduO1xuXG4vKipcbiAqICAyMDEyLTA0LTI2IHlpbWluZ2hlQGdtYWlsLmNvbVxuICogICAtIOS8mOWMluaZuuiDveWvuem9kOeul+azlVxuICogICAtIOaFjueUqCByZXNpemVYWFxuICpcbiAqICAyMDExLTA3LTEzIHlpbWluZ2hlQGdtYWlsLmNvbSBub3RlOlxuICogICAtIOWinuWKoOaZuuiDveWvuem9kO+8jOS7peWPiuWkp+Wwj+iwg+aVtOmAiemhuVxuICoqL1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmMtdGltZS1waWNrZXIvfi9yYy10cmlnZ2VyL34vcmMtYWxpZ24vfi9kb20tYWxpZ24vbGliL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIFJFX05VTSA9IC9bXFwtK10/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bXFwtK10/XFxkK3wpLy5zb3VyY2U7XG5cbnZhciBnZXRDb21wdXRlZFN0eWxlWCA9IHVuZGVmaW5lZDtcblxuZnVuY3Rpb24gY3NzKGVsLCBuYW1lLCB2KSB7XG4gIHZhciB2YWx1ZSA9IHY7XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKHZhciBpIGluIG5hbWUpIHtcbiAgICAgIGlmIChuYW1lLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgIGNzcyhlbCwgaSwgbmFtZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZSArICdweCc7XG4gICAgfVxuICAgIGVsLnN0eWxlW25hbWVdID0gdmFsdWU7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZVgoZWwsIG5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRDbGllbnRQb3NpdGlvbihlbGVtKSB7XG4gIHZhciBib3ggPSB1bmRlZmluZWQ7XG4gIHZhciB4ID0gdW5kZWZpbmVkO1xuICB2YXIgeSA9IHVuZGVmaW5lZDtcbiAgdmFyIGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcbiAgdmFyIGJvZHkgPSBkb2MuYm9keTtcbiAgdmFyIGRvY0VsZW0gPSBkb2MgJiYgZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgLy8g5qC55o2uIEdCUyDmnIDmlrDmlbDmja7vvIxBLUdyYWRlIEJyb3dzZXJzIOmDveW3suaUr+aMgSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qg5pa55rOV77yM5LiN55So5YaN6ICD6JmR5Lyg57uf55qE5a6e546w5pa55byPXG4gIGJveCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgLy8g5rOo77yaalF1ZXJ5IOi/mOiAg+iZkeWHj+WOuyBkb2NFbGVtLmNsaWVudExlZnQvY2xpZW50VG9wXG4gIC8vIOS9hua1i+ivleWPkeeOsO+8jOi/meagt+WPjeiAjOS8muWvvOiHtOW9kyBodG1sIOWSjCBib2R5IOaciei+uei3nS/ovrnmoYbmoLflvI/ml7bvvIzojrflj5bnmoTlgLzkuI3mraPnoa5cbiAgLy8g5q2k5aSW77yMaWU2IOS8muW/veeVpSBodG1sIOeahCBtYXJnaW4g5YC877yM5bm46L+Q5Zyw5piv5rKh5pyJ6LCB5Lya5Y676K6+572uIGh0bWwg55qEIG1hcmdpblxuXG4gIHggPSBib3gubGVmdDtcbiAgeSA9IGJveC50b3A7XG5cbiAgLy8gSW4gSUUsIG1vc3Qgb2YgdGhlIHRpbWUsIDIgZXh0cmEgcGl4ZWxzIGFyZSBhZGRlZCB0byB0aGUgdG9wIGFuZCBsZWZ0XG4gIC8vIGR1ZSB0byB0aGUgaW1wbGljaXQgMi1waXhlbCBpbnNldCBib3JkZXIuICBJbiBJRTYvNyBxdWlya3MgbW9kZSBhbmRcbiAgLy8gSUU2IHN0YW5kYXJkcyBtb2RlLCB0aGlzIGJvcmRlciBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIHRoZVxuICAvLyBkb2N1bWVudCBlbGVtZW50J3MgYm9yZGVyIHRvIHplcm8gLS0gdGh1cywgd2UgY2Fubm90IHJlbHkgb24gdGhlXG4gIC8vIG9mZnNldCBhbHdheXMgYmVpbmcgMiBwaXhlbHMuXG5cbiAgLy8gSW4gcXVpcmtzIG1vZGUsIHRoZSBvZmZzZXQgY2FuIGJlIGRldGVybWluZWQgYnkgcXVlcnlpbmcgdGhlIGJvZHknc1xuICAvLyBjbGllbnRMZWZ0L2NsaWVudFRvcCwgYnV0IGluIHN0YW5kYXJkcyBtb2RlLCBpdCBpcyBmb3VuZCBieSBxdWVyeWluZ1xuICAvLyB0aGUgZG9jdW1lbnQgZWxlbWVudCdzIGNsaWVudExlZnQvY2xpZW50VG9wLiAgU2luY2Ugd2UgYWxyZWFkeSBjYWxsZWRcbiAgLy8gZ2V0Q2xpZW50Qm91bmRpbmdSZWN0IHdlIGhhdmUgYWxyZWFkeSBmb3JjZWQgYSByZWZsb3csIHNvIGl0IGlzIG5vdFxuICAvLyB0b28gZXhwZW5zaXZlIGp1c3QgdG8gcXVlcnkgdGhlbSBhbGwuXG5cbiAgLy8gaWUg5LiL5bqU6K+l5YeP5Y6756qX5Y+j55qE6L655qGG5ZCn77yM5q+V56uf6buY6K6kIGFic29sdXRlIOmDveaYr+ebuOWvueeql+WPo+WumuS9jeeahFxuICAvLyDnqpflj6PovrnmoYbmoIflh4bmmK/orr4gZG9jdW1lbnRFbGVtZW50ICxxdWlya3Mg5pe26K6+572uIGJvZHlcbiAgLy8g5pyA5aW956aB5q2i5ZyoIGJvZHkg5ZKMIGh0bWwg5LiK6L655qGGIO+8jOS9hiBpZSA8IDkgaHRtbCDpu5jorqTmnIkgMnB4IO+8jOWHj+WOu1xuICAvLyDkvYbmmK/pnZ4gaWUg5LiN5Y+v6IO96K6+572u56qX5Y+j6L655qGG77yMYm9keSBodG1sIOS5n+S4jeaYr+eql+WPoyAsaWUg5Y+v5Lul6YCa6L+HIGh0bWwsYm9keSDorr7nva5cbiAgLy8g5qCH5YeGIGllIOS4iyBkb2NFbGVtLmNsaWVudFRvcCDlsLHmmK8gYm9yZGVyLXRvcFxuICAvLyBpZTcgaHRtbCDljbPnqpflj6PovrnmoYbmlLnlj5jkuI3kuobjgILmsLjov5zkuLogMlxuICAvLyDkvYbmoIflh4YgZmlyZWZveC9jaHJvbWUvaWU5IOS4iyBkb2NFbGVtLmNsaWVudFRvcCDmmK/nqpflj6PovrnmoYbvvIzljbPkvb/orr7kuoYgYm9yZGVyLXRvcCDkuZ/kuLogMFxuXG4gIHggLT0gZG9jRWxlbS5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCB8fCAwO1xuICB5IC09IGRvY0VsZW0uY2xpZW50VG9wIHx8IGJvZHkuY2xpZW50VG9wIHx8IDA7XG5cbiAgcmV0dXJuIHsgbGVmdDogeCwgdG9wOiB5IH07XG59XG5cbmZ1bmN0aW9uIGdldFNjcm9sbCh3LCB0b3ApIHtcbiAgdmFyIHJldCA9IHdbJ3BhZ2UnICsgKHRvcCA/ICdZJyA6ICdYJykgKyAnT2Zmc2V0J107XG4gIHZhciBtZXRob2QgPSAnc2Nyb2xsJyArICh0b3AgPyAnVG9wJyA6ICdMZWZ0Jyk7XG4gIGlmICh0eXBlb2YgcmV0ICE9PSAnbnVtYmVyJykge1xuICAgIHZhciBkID0gdy5kb2N1bWVudDtcbiAgICAvLyBpZTYsNyw4IHN0YW5kYXJkIG1vZGVcbiAgICByZXQgPSBkLmRvY3VtZW50RWxlbWVudFttZXRob2RdO1xuICAgIGlmICh0eXBlb2YgcmV0ICE9PSAnbnVtYmVyJykge1xuICAgICAgLy8gcXVpcmtzIG1vZGVcbiAgICAgIHJldCA9IGQuYm9keVttZXRob2RdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxMZWZ0KHcpIHtcbiAgcmV0dXJuIGdldFNjcm9sbCh3KTtcbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsVG9wKHcpIHtcbiAgcmV0dXJuIGdldFNjcm9sbCh3LCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2V0T2Zmc2V0KGVsKSB7XG4gIHZhciBwb3MgPSBnZXRDbGllbnRQb3NpdGlvbihlbCk7XG4gIHZhciBkb2MgPSBlbC5vd25lckRvY3VtZW50O1xuICB2YXIgdyA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICBwb3MubGVmdCArPSBnZXRTY3JvbGxMZWZ0KHcpO1xuICBwb3MudG9wICs9IGdldFNjcm9sbFRvcCh3KTtcbiAgcmV0dXJuIHBvcztcbn1cbmZ1bmN0aW9uIF9nZXRDb21wdXRlZFN0eWxlKGVsZW0sIG5hbWUsIGNzKSB7XG4gIHZhciBjb21wdXRlZFN0eWxlID0gY3M7XG4gIHZhciB2YWwgPSAnJztcbiAgdmFyIGQgPSBlbGVtLm93bmVyRG9jdW1lbnQ7XG4gIGNvbXB1dGVkU3R5bGUgPSBjb21wdXRlZFN0eWxlIHx8IGQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtLCBudWxsKTtcblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20va2lzc3l0ZWFtL2tpc3N5L2lzc3Vlcy82MVxuICBpZiAoY29tcHV0ZWRTdHlsZSkge1xuICAgIHZhbCA9IGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKSB8fCBjb21wdXRlZFN0eWxlW25hbWVdO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxudmFyIF9SRV9OVU1fTk9fUFggPSBuZXcgUmVnRXhwKCdeKCcgKyBSRV9OVU0gKyAnKSg/IXB4KVthLXolXSskJywgJ2knKTtcbnZhciBSRV9QT1MgPSAvXih0b3B8cmlnaHR8Ym90dG9tfGxlZnQpJC87XG52YXIgQ1VSUkVOVF9TVFlMRSA9ICdjdXJyZW50U3R5bGUnO1xudmFyIFJVTlRJTUVfU1RZTEUgPSAncnVudGltZVN0eWxlJztcbnZhciBMRUZUID0gJ2xlZnQnO1xudmFyIFBYID0gJ3B4JztcblxuZnVuY3Rpb24gX2dldENvbXB1dGVkU3R5bGVJRShlbGVtLCBuYW1lKSB7XG4gIC8vIGN1cnJlbnRTdHlsZSBtYXliZSBudWxsXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNTIzMS5hc3B4XG4gIHZhciByZXQgPSBlbGVtW0NVUlJFTlRfU1RZTEVdICYmIGVsZW1bQ1VSUkVOVF9TVFlMRV1bbmFtZV07XG5cbiAgLy8g5b2TIHdpZHRoL2hlaWdodCDorr7nva7kuLrnmb7liIbmr5Tml7bvvIzpgJrov4cgcGl4ZWxMZWZ0IOaWueW8j+i9rOaNoueahCB3aWR0aC9oZWlnaHQg5YC8XG4gIC8vIOS4gOW8gOWni+WwseWkhOeQhuS6hiEgQ1VTVE9NX1NUWUxFLmhlaWdodCxDVVNUT01fU1RZTEUud2lkdGggLGNzc0hvb2sg6Kej5YazQDIwMTEtMDgtMTlcbiAgLy8g5ZyoIGllIOS4i+S4jeWvue+8jOmcgOimgeebtOaOpeeUqCBvZmZzZXQg5pa55byPXG4gIC8vIGJvcmRlcldpZHRoIOetieWAvOS5n+aciemXrumimO+8jOS9huiAg+iZkeWIsCBib3JkZXJXaWR0aCDorr7kuLrnmb7liIbmr5TnmoTmpoLnjoflvojlsI/vvIzov5nph4zlsLHkuI3ogIPomZHkuoZcblxuICAvLyBGcm9tIHRoZSBhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXG4gIC8vIGh0dHA6Ly9lcmlrLmVhZS5uZXQvYXJjaGl2ZXMvMjAwNy8wNy8yNy8xOC41NC4xNS8jY29tbWVudC0xMDIyOTFcbiAgLy8gSWYgd2UncmUgbm90IGRlYWxpbmcgd2l0aCBhIHJlZ3VsYXIgcGl4ZWwgbnVtYmVyXG4gIC8vIGJ1dCBhIG51bWJlciB0aGF0IGhhcyBhIHdlaXJkIGVuZGluZywgd2UgbmVlZCB0byBjb252ZXJ0IGl0IHRvIHBpeGVsc1xuICAvLyBleGNsdWRlIGxlZnQgcmlnaHQgZm9yIHJlbGF0aXZpdHlcbiAgaWYgKF9SRV9OVU1fTk9fUFgudGVzdChyZXQpICYmICFSRV9QT1MudGVzdChuYW1lKSkge1xuICAgIC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcbiAgICB2YXIgc3R5bGUgPSBlbGVtLnN0eWxlO1xuICAgIHZhciBsZWZ0ID0gc3R5bGVbTEVGVF07XG4gICAgdmFyIHJzTGVmdCA9IGVsZW1bUlVOVElNRV9TVFlMRV1bTEVGVF07XG5cbiAgICAvLyBwcmV2ZW50IGZsYXNoaW5nIG9mIGNvbnRlbnRcbiAgICBlbGVtW1JVTlRJTUVfU1RZTEVdW0xFRlRdID0gZWxlbVtDVVJSRU5UX1NUWUxFXVtMRUZUXTtcblxuICAgIC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcbiAgICBzdHlsZVtMRUZUXSA9IG5hbWUgPT09ICdmb250U2l6ZScgPyAnMWVtJyA6IHJldCB8fCAwO1xuICAgIHJldCA9IHN0eWxlLnBpeGVsTGVmdCArIFBYO1xuXG4gICAgLy8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuICAgIHN0eWxlW0xFRlRdID0gbGVmdDtcblxuICAgIGVsZW1bUlVOVElNRV9TVFlMRV1bTEVGVF0gPSByc0xlZnQ7XG4gIH1cbiAgcmV0dXJuIHJldCA9PT0gJycgPyAnYXV0bycgOiByZXQ7XG59XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBnZXRDb21wdXRlZFN0eWxlWCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlID8gX2dldENvbXB1dGVkU3R5bGUgOiBfZ2V0Q29tcHV0ZWRTdHlsZUlFO1xufVxuXG5mdW5jdGlvbiBnZXRPZmZzZXREaXJlY3Rpb24oZGlyLCBvcHRpb24pIHtcbiAgaWYgKGRpciA9PT0gJ2xlZnQnKSB7XG4gICAgcmV0dXJuIG9wdGlvbi51c2VDc3NSaWdodCA/ICdyaWdodCcgOiBkaXI7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbi51c2VDc3NCb3R0b20gPyAnYm90dG9tJyA6IGRpcjtcbn1cblxuZnVuY3Rpb24gb3Bwb3NpdGVPZmZzZXREaXJlY3Rpb24oZGlyKSB7XG4gIGlmIChkaXIgPT09ICdsZWZ0Jykge1xuICAgIHJldHVybiAncmlnaHQnO1xuICB9IGVsc2UgaWYgKGRpciA9PT0gJ3JpZ2h0Jykge1xuICAgIHJldHVybiAnbGVmdCc7XG4gIH0gZWxzZSBpZiAoZGlyID09PSAndG9wJykge1xuICAgIHJldHVybiAnYm90dG9tJztcbiAgfSBlbHNlIGlmIChkaXIgPT09ICdib3R0b20nKSB7XG4gICAgcmV0dXJuICd0b3AnO1xuICB9XG59XG5cbi8vIOiuvue9riBlbGVtIOebuOWvuSBlbGVtLm93bmVyRG9jdW1lbnQg55qE5Z2Q5qCHXG5mdW5jdGlvbiBzZXRPZmZzZXQoZWxlbSwgb2Zmc2V0LCBvcHRpb24pIHtcbiAgLy8gc2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxuICBpZiAoY3NzKGVsZW0sICdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuICAgIGVsZW0uc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICB9XG4gIHZhciBwcmVzZXRIID0gLTk5OTtcbiAgdmFyIHByZXNldFYgPSAtOTk5O1xuICB2YXIgaG9yaXpvbnRhbFByb3BlcnR5ID0gZ2V0T2Zmc2V0RGlyZWN0aW9uKCdsZWZ0Jywgb3B0aW9uKTtcbiAgdmFyIHZlcnRpY2FsUHJvcGVydHkgPSBnZXRPZmZzZXREaXJlY3Rpb24oJ3RvcCcsIG9wdGlvbik7XG4gIHZhciBvcHBvc2l0ZUhvcml6b250YWxQcm9wZXJ0eSA9IG9wcG9zaXRlT2Zmc2V0RGlyZWN0aW9uKGhvcml6b250YWxQcm9wZXJ0eSk7XG4gIHZhciBvcHBvc2l0ZVZlcnRpY2FsUHJvcGVydHkgPSBvcHBvc2l0ZU9mZnNldERpcmVjdGlvbih2ZXJ0aWNhbFByb3BlcnR5KTtcblxuICBpZiAoaG9yaXpvbnRhbFByb3BlcnR5ICE9PSAnbGVmdCcpIHtcbiAgICBwcmVzZXRIID0gOTk5O1xuICB9XG5cbiAgaWYgKHZlcnRpY2FsUHJvcGVydHkgIT09ICd0b3AnKSB7XG4gICAgcHJlc2V0ViA9IDk5OTtcbiAgfVxuXG4gIGlmICgnbGVmdCcgaW4gb2Zmc2V0KSB7XG4gICAgZWxlbS5zdHlsZVtvcHBvc2l0ZUhvcml6b250YWxQcm9wZXJ0eV0gPSAnJztcbiAgICBlbGVtLnN0eWxlW2hvcml6b250YWxQcm9wZXJ0eV0gPSBwcmVzZXRIICsgJ3B4JztcbiAgfVxuICBpZiAoJ3RvcCcgaW4gb2Zmc2V0KSB7XG4gICAgZWxlbS5zdHlsZVtvcHBvc2l0ZVZlcnRpY2FsUHJvcGVydHldID0gJyc7XG4gICAgZWxlbS5zdHlsZVt2ZXJ0aWNhbFByb3BlcnR5XSA9IHByZXNldFYgKyAncHgnO1xuICB9XG4gIHZhciBvbGQgPSBnZXRPZmZzZXQoZWxlbSk7XG4gIHZhciByZXQgPSB7fTtcbiAgdmFyIGtleSA9IHVuZGVmaW5lZDtcbiAgZm9yIChrZXkgaW4gb2Zmc2V0KSB7XG4gICAgaWYgKG9mZnNldC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICB2YXIgZGlyID0gZ2V0T2Zmc2V0RGlyZWN0aW9uKGtleSwgb3B0aW9uKTtcbiAgICAgIHZhciBwcmVzZXQgPSBrZXkgPT09ICdsZWZ0JyA/IHByZXNldEggOiBwcmVzZXRWO1xuICAgICAgaWYgKGRpciA9PT0ga2V5KSB7XG4gICAgICAgIHJldFtkaXJdID0gcHJlc2V0ICsgb2Zmc2V0W2tleV0gLSBvbGRba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldFtkaXJdID0gcHJlc2V0ICsgb2xkW2tleV0gLSBvZmZzZXRba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY3NzKGVsZW0sIHJldCk7XG59XG5cbmZ1bmN0aW9uIGVhY2goYXJyLCBmbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGZuKGFycltpXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNCb3JkZXJCb3hGbihlbGVtKSB7XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlWChlbGVtLCAnYm94U2l6aW5nJykgPT09ICdib3JkZXItYm94Jztcbn1cblxudmFyIEJPWF9NT0RFTFMgPSBbJ21hcmdpbicsICdib3JkZXInLCAncGFkZGluZyddO1xudmFyIENPTlRFTlRfSU5ERVggPSAtMTtcbnZhciBQQURESU5HX0lOREVYID0gMjtcbnZhciBCT1JERVJfSU5ERVggPSAxO1xudmFyIE1BUkdJTl9JTkRFWCA9IDA7XG5cbmZ1bmN0aW9uIHN3YXAoZWxlbSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIG9sZCA9IHt9O1xuICB2YXIgc3R5bGUgPSBlbGVtLnN0eWxlO1xuICB2YXIgbmFtZSA9IHVuZGVmaW5lZDtcblxuICAvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcbiAgZm9yIChuYW1lIGluIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgb2xkW25hbWVdID0gc3R5bGVbbmFtZV07XG4gICAgICBzdHlsZVtuYW1lXSA9IG9wdGlvbnNbbmFtZV07XG4gICAgfVxuICB9XG5cbiAgY2FsbGJhY2suY2FsbChlbGVtKTtcblxuICAvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcbiAgZm9yIChuYW1lIGluIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgc3R5bGVbbmFtZV0gPSBvbGRbbmFtZV07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFBCTVdpZHRoKGVsZW0sIHByb3BzLCB3aGljaCkge1xuICB2YXIgdmFsdWUgPSAwO1xuICB2YXIgcHJvcCA9IHVuZGVmaW5lZDtcbiAgdmFyIGogPSB1bmRlZmluZWQ7XG4gIHZhciBpID0gdW5kZWZpbmVkO1xuICBmb3IgKGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKyspIHtcbiAgICBwcm9wID0gcHJvcHNbal07XG4gICAgaWYgKHByb3ApIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB3aGljaC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY3NzUHJvcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHByb3AgPT09ICdib3JkZXInKSB7XG4gICAgICAgICAgY3NzUHJvcCA9IHByb3AgKyB3aGljaFtpXSArICdXaWR0aCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3NzUHJvcCA9IHByb3AgKyB3aGljaFtpXTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSArPSBwYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGVYKGVsZW0sIGNzc1Byb3ApKSB8fCAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQSBjcnVkZSB3YXkgb2YgZGV0ZXJtaW5pbmcgaWYgYW4gb2JqZWN0IGlzIGEgd2luZG93XG4gKiBAbWVtYmVyIHV0aWxcbiAqL1xuZnVuY3Rpb24gaXNXaW5kb3cob2JqKSB7XG4gIC8vIG11c3QgdXNlID09IGZvciBpZThcbiAgLyogZXNsaW50IGVxZXFlcTowICovXG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgb2JqICE9PSB1bmRlZmluZWQgJiYgb2JqID09IG9iai53aW5kb3c7XG59XG5cbnZhciBkb21VdGlscyA9IHt9O1xuXG5lYWNoKFsnV2lkdGgnLCAnSGVpZ2h0J10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRvbVV0aWxzWydkb2MnICsgbmFtZV0gPSBmdW5jdGlvbiAocmVmV2luKSB7XG4gICAgdmFyIGQgPSByZWZXaW4uZG9jdW1lbnQ7XG4gICAgcmV0dXJuIE1hdGgubWF4KFxuICAgIC8vIGZpcmVmb3ggY2hyb21lIGRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQ8IGJvZHkuc2Nyb2xsSGVpZ2h0XG4gICAgLy8gaWUgc3RhbmRhcmQgbW9kZSA6IGRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQ+IGJvZHkuc2Nyb2xsSGVpZ2h0XG4gICAgZC5kb2N1bWVudEVsZW1lbnRbJ3Njcm9sbCcgKyBuYW1lXSxcbiAgICAvLyBxdWlya3MgOiBkb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0IOacgOWkp+etieS6juWPr+inhueql+WPo+WkmuS4gOeCue+8n1xuICAgIGQuYm9keVsnc2Nyb2xsJyArIG5hbWVdLCBkb21VdGlsc1sndmlld3BvcnQnICsgbmFtZV0oZCkpO1xuICB9O1xuXG4gIGRvbVV0aWxzWyd2aWV3cG9ydCcgKyBuYW1lXSA9IGZ1bmN0aW9uICh3aW4pIHtcbiAgICAvLyBwYyBicm93c2VyIGluY2x1ZGVzIHNjcm9sbGJhciBpbiB3aW5kb3cuaW5uZXJXaWR0aFxuICAgIHZhciBwcm9wID0gJ2NsaWVudCcgKyBuYW1lO1xuICAgIHZhciBkb2MgPSB3aW4uZG9jdW1lbnQ7XG4gICAgdmFyIGJvZHkgPSBkb2MuYm9keTtcbiAgICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICB2YXIgZG9jdW1lbnRFbGVtZW50UHJvcCA9IGRvY3VtZW50RWxlbWVudFtwcm9wXTtcbiAgICAvLyDmoIflh4bmqKHlvI/lj5YgZG9jdW1lbnRFbGVtZW50XG4gICAgLy8gYmFja2NvbXBhdCDlj5YgYm9keVxuICAgIHJldHVybiBkb2MuY29tcGF0TW9kZSA9PT0gJ0NTUzFDb21wYXQnICYmIGRvY3VtZW50RWxlbWVudFByb3AgfHwgYm9keSAmJiBib2R5W3Byb3BdIHx8IGRvY3VtZW50RWxlbWVudFByb3A7XG4gIH07XG59KTtcblxuLypcbiDlvpfliLDlhYPntKDnmoTlpKflsI/kv6Hmga9cbiBAcGFyYW0gZWxlbVxuIEBwYXJhbSBuYW1lXG4gQHBhcmFtIHtTdHJpbmd9IFtleHRyYV0gICdwYWRkaW5nJyA6IChjc3Mgd2lkdGgpICsgcGFkZGluZ1xuICdib3JkZXInIDogKGNzcyB3aWR0aCkgKyBwYWRkaW5nICsgYm9yZGVyXG4gJ21hcmdpbicgOiAoY3NzIHdpZHRoKSArIHBhZGRpbmcgKyBib3JkZXIgKyBtYXJnaW5cbiAqL1xuZnVuY3Rpb24gZ2V0V0goZWxlbSwgbmFtZSwgZXgpIHtcbiAgdmFyIGV4dHJhID0gZXg7XG4gIGlmIChpc1dpbmRvdyhlbGVtKSkge1xuICAgIHJldHVybiBuYW1lID09PSAnd2lkdGgnID8gZG9tVXRpbHMudmlld3BvcnRXaWR0aChlbGVtKSA6IGRvbVV0aWxzLnZpZXdwb3J0SGVpZ2h0KGVsZW0pO1xuICB9IGVsc2UgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDkpIHtcbiAgICByZXR1cm4gbmFtZSA9PT0gJ3dpZHRoJyA/IGRvbVV0aWxzLmRvY1dpZHRoKGVsZW0pIDogZG9tVXRpbHMuZG9jSGVpZ2h0KGVsZW0pO1xuICB9XG4gIHZhciB3aGljaCA9IG5hbWUgPT09ICd3aWR0aCcgPyBbJ0xlZnQnLCAnUmlnaHQnXSA6IFsnVG9wJywgJ0JvdHRvbSddO1xuICB2YXIgYm9yZGVyQm94VmFsdWUgPSBuYW1lID09PSAnd2lkdGgnID8gZWxlbS5vZmZzZXRXaWR0aCA6IGVsZW0ub2Zmc2V0SGVpZ2h0O1xuICB2YXIgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGVYKGVsZW0pO1xuICB2YXIgaXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveEZuKGVsZW0sIGNvbXB1dGVkU3R5bGUpO1xuICB2YXIgY3NzQm94VmFsdWUgPSAwO1xuICBpZiAoYm9yZGVyQm94VmFsdWUgPT09IG51bGwgfHwgYm9yZGVyQm94VmFsdWUgPT09IHVuZGVmaW5lZCB8fCBib3JkZXJCb3hWYWx1ZSA8PSAwKSB7XG4gICAgYm9yZGVyQm94VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgLy8gRmFsbCBiYWNrIHRvIGNvbXB1dGVkIHRoZW4gdW4gY29tcHV0ZWQgY3NzIGlmIG5lY2Vzc2FyeVxuICAgIGNzc0JveFZhbHVlID0gZ2V0Q29tcHV0ZWRTdHlsZVgoZWxlbSwgbmFtZSk7XG4gICAgaWYgKGNzc0JveFZhbHVlID09PSBudWxsIHx8IGNzc0JveFZhbHVlID09PSB1bmRlZmluZWQgfHwgTnVtYmVyKGNzc0JveFZhbHVlKSA8IDApIHtcbiAgICAgIGNzc0JveFZhbHVlID0gZWxlbS5zdHlsZVtuYW1lXSB8fCAwO1xuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgJycsIGF1dG8sIGFuZCBwcmVwYXJlIGZvciBleHRyYVxuICAgIGNzc0JveFZhbHVlID0gcGFyc2VGbG9hdChjc3NCb3hWYWx1ZSkgfHwgMDtcbiAgfVxuICBpZiAoZXh0cmEgPT09IHVuZGVmaW5lZCkge1xuICAgIGV4dHJhID0gaXNCb3JkZXJCb3ggPyBCT1JERVJfSU5ERVggOiBDT05URU5UX0lOREVYO1xuICB9XG4gIHZhciBib3JkZXJCb3hWYWx1ZU9ySXNCb3JkZXJCb3ggPSBib3JkZXJCb3hWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IGlzQm9yZGVyQm94O1xuICB2YXIgdmFsID0gYm9yZGVyQm94VmFsdWUgfHwgY3NzQm94VmFsdWU7XG4gIGlmIChleHRyYSA9PT0gQ09OVEVOVF9JTkRFWCkge1xuICAgIGlmIChib3JkZXJCb3hWYWx1ZU9ySXNCb3JkZXJCb3gpIHtcbiAgICAgIHJldHVybiB2YWwgLSBnZXRQQk1XaWR0aChlbGVtLCBbJ2JvcmRlcicsICdwYWRkaW5nJ10sIHdoaWNoLCBjb21wdXRlZFN0eWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNzc0JveFZhbHVlO1xuICB9IGVsc2UgaWYgKGJvcmRlckJveFZhbHVlT3JJc0JvcmRlckJveCkge1xuICAgIGlmIChleHRyYSA9PT0gQk9SREVSX0lOREVYKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gdmFsICsgKGV4dHJhID09PSBQQURESU5HX0lOREVYID8gLWdldFBCTVdpZHRoKGVsZW0sIFsnYm9yZGVyJ10sIHdoaWNoLCBjb21wdXRlZFN0eWxlKSA6IGdldFBCTVdpZHRoKGVsZW0sIFsnbWFyZ2luJ10sIHdoaWNoLCBjb21wdXRlZFN0eWxlKSk7XG4gIH1cbiAgcmV0dXJuIGNzc0JveFZhbHVlICsgZ2V0UEJNV2lkdGgoZWxlbSwgQk9YX01PREVMUy5zbGljZShleHRyYSksIHdoaWNoLCBjb21wdXRlZFN0eWxlKTtcbn1cblxudmFyIGNzc1Nob3cgPSB7IHBvc2l0aW9uOiAnYWJzb2x1dGUnLCB2aXNpYmlsaXR5OiAnaGlkZGVuJywgZGlzcGxheTogJ2Jsb2NrJyB9O1xuXG4vLyBmaXggIzExOSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9raXNzeXRlYW0va2lzc3kvaXNzdWVzLzExOVxuZnVuY3Rpb24gZ2V0V0hJZ25vcmVEaXNwbGF5KCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICB2YXIgdmFsID0gdW5kZWZpbmVkO1xuICB2YXIgZWxlbSA9IGFyZ3NbMF07XG4gIC8vIGluIGNhc2UgZWxlbSBpcyB3aW5kb3dcbiAgLy8gZWxlbS5vZmZzZXRXaWR0aCA9PT0gdW5kZWZpbmVkXG4gIGlmIChlbGVtLm9mZnNldFdpZHRoICE9PSAwKSB7XG4gICAgdmFsID0gZ2V0V0guYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICBzd2FwKGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhbCA9IGdldFdILmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn1cblxuZWFjaChbJ3dpZHRoJywgJ2hlaWdodCddLCBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgZmlyc3QgPSBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKTtcbiAgZG9tVXRpbHNbJ291dGVyJyArIGZpcnN0XSA9IGZ1bmN0aW9uIChlbCwgaW5jbHVkZU1hcmdpbikge1xuICAgIHJldHVybiBlbCAmJiBnZXRXSElnbm9yZURpc3BsYXkoZWwsIG5hbWUsIGluY2x1ZGVNYXJnaW4gPyBNQVJHSU5fSU5ERVggOiBCT1JERVJfSU5ERVgpO1xuICB9O1xuICB2YXIgd2hpY2ggPSBuYW1lID09PSAnd2lkdGgnID8gWydMZWZ0JywgJ1JpZ2h0J10gOiBbJ1RvcCcsICdCb3R0b20nXTtcblxuICBkb21VdGlsc1tuYW1lXSA9IGZ1bmN0aW9uIChlbGVtLCB2KSB7XG4gICAgdmFyIHZhbCA9IHY7XG4gICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZWxlbSkge1xuICAgICAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGVYKGVsZW0pO1xuICAgICAgICB2YXIgaXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveEZuKGVsZW0pO1xuICAgICAgICBpZiAoaXNCb3JkZXJCb3gpIHtcbiAgICAgICAgICB2YWwgKz0gZ2V0UEJNV2lkdGgoZWxlbSwgWydwYWRkaW5nJywgJ2JvcmRlciddLCB3aGljaCwgY29tcHV0ZWRTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNzcyhlbGVtLCBuYW1lLCB2YWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW0gJiYgZ2V0V0hJZ25vcmVEaXNwbGF5KGVsZW0sIG5hbWUsIENPTlRFTlRfSU5ERVgpO1xuICB9O1xufSk7XG5cbmZ1bmN0aW9uIG1peCh0bywgZnJvbSkge1xuICBmb3IgKHZhciBpIGluIGZyb20pIHtcbiAgICBpZiAoZnJvbS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgdG9baV0gPSBmcm9tW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG87XG59XG5cbnZhciB1dGlscyA9IHtcbiAgZ2V0V2luZG93OiBmdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICAgIGlmIChub2RlICYmIG5vZGUuZG9jdW1lbnQgJiYgbm9kZS5zZXRUaW1lb3V0KSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgdmFyIGRvYyA9IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlO1xuICAgIHJldHVybiBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgfSxcbiAgb2Zmc2V0OiBmdW5jdGlvbiBvZmZzZXQoZWwsIHZhbHVlLCBvcHRpb24pIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgc2V0T2Zmc2V0KGVsLCB2YWx1ZSwgb3B0aW9uIHx8IHt9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdldE9mZnNldChlbCk7XG4gICAgfVxuICB9LFxuICBpc1dpbmRvdzogaXNXaW5kb3csXG4gIGVhY2g6IGVhY2gsXG4gIGNzczogY3NzLFxuICBjbG9uZTogZnVuY3Rpb24gY2xvbmUob2JqKSB7XG4gICAgdmFyIGkgPSB1bmRlZmluZWQ7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgcmV0W2ldID0gb2JqW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgb3ZlcmZsb3cgPSBvYmoub3ZlcmZsb3c7XG4gICAgaWYgKG92ZXJmbG93KSB7XG4gICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICByZXQub3ZlcmZsb3dbaV0gPSBvYmoub3ZlcmZsb3dbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcbiAgbWl4OiBtaXgsXG4gIGdldFdpbmRvd1Njcm9sbExlZnQ6IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbExlZnQodykge1xuICAgIHJldHVybiBnZXRTY3JvbGxMZWZ0KHcpO1xuICB9LFxuICBnZXRXaW5kb3dTY3JvbGxUb3A6IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbFRvcCh3KSB7XG4gICAgcmV0dXJuIGdldFNjcm9sbFRvcCh3KTtcbiAgfSxcbiAgbWVyZ2U6IGZ1bmN0aW9uIG1lcmdlKCkge1xuICAgIHZhciByZXQgPSB7fTtcblxuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB1dGlscy5taXgocmV0LCBhcmdzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcbiAgdmlld3BvcnRXaWR0aDogMCxcbiAgdmlld3BvcnRIZWlnaHQ6IDBcbn07XG5cbm1peCh1dGlscywgZG9tVXRpbHMpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSB1dGlscztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JjLXRpbWUtcGlja2VyL34vcmMtdHJpZ2dlci9+L3JjLWFsaWduL34vZG9tLWFsaWduL2xpYi91dGlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDExN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXIgX3V0aWxzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWxzKTtcblxuLyoqXG4gKiDlvpfliLDkvJrlr7zoh7TlhYPntKDmmL7npLrkuI3lhajnmoTnpZblhYjlhYPntKBcbiAqL1xuXG5mdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICAvLyBpZSDov5nkuKrkuZ/kuI3mmK/lrozlhajlj6/ooYxcbiAgLypcbiAgIDxkaXYgc3R5bGU9XCJ3aWR0aDogNTBweDtoZWlnaHQ6IDEwMHB4O292ZXJmbG93OiBoaWRkZW5cIj5cbiAgIDxkaXYgc3R5bGU9XCJ3aWR0aDogNTBweDtoZWlnaHQ6IDEwMHB4O3Bvc2l0aW9uOiByZWxhdGl2ZTtcIiBpZD1cImQ2XCI+XG4gICDlhYPntKAgNiDpq5ggMTAwcHgg5a69IDUwcHg8YnIvPlxuICAgPC9kaXY+XG4gICA8L2Rpdj5cbiAgICovXG4gIC8vIGVsZW1lbnQub2Zmc2V0UGFyZW50IGRvZXMgdGhlIHJpZ2h0IHRoaW5nIGluIGllNyBhbmQgYmVsb3cuIFJldHVybiBwYXJlbnQgd2l0aCBsYXlvdXQhXG4gIC8vICBJbiBvdGhlciBicm93c2VycyBpdCBvbmx5IGluY2x1ZGVzIGVsZW1lbnRzIHdpdGggcG9zaXRpb24gYWJzb2x1dGUsIHJlbGF0aXZlIG9yXG4gIC8vIGZpeGVkLCBub3QgZWxlbWVudHMgd2l0aCBvdmVyZmxvdyBzZXQgdG8gYXV0byBvciBzY3JvbGwuXG4gIC8vICAgICAgICBpZiAoVUEuaWUgJiYgaWVNb2RlIDwgOCkge1xuICAvLyAgICAgICAgICAgIHJldHVybiBlbGVtZW50Lm9mZnNldFBhcmVudDtcbiAgLy8gICAgICAgIH1cbiAgLy8g57uf5LiA55qEIG9mZnNldFBhcmVudCDmlrnms5VcbiAgdmFyIGRvYyA9IGVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgdmFyIGJvZHkgPSBkb2MuYm9keTtcbiAgdmFyIHBhcmVudCA9IHVuZGVmaW5lZDtcbiAgdmFyIHBvc2l0aW9uU3R5bGUgPSBfdXRpbHMyWydkZWZhdWx0J10uY3NzKGVsZW1lbnQsICdwb3NpdGlvbicpO1xuICB2YXIgc2tpcFN0YXRpYyA9IHBvc2l0aW9uU3R5bGUgPT09ICdmaXhlZCcgfHwgcG9zaXRpb25TdHlsZSA9PT0gJ2Fic29sdXRlJztcblxuICBpZiAoIXNraXBTdGF0aWMpIHtcbiAgICByZXR1cm4gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaHRtbCcgPyBudWxsIDogZWxlbWVudC5wYXJlbnROb2RlO1xuICB9XG5cbiAgZm9yIChwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7IHBhcmVudCAmJiBwYXJlbnQgIT09IGJvZHk7IHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlKSB7XG4gICAgcG9zaXRpb25TdHlsZSA9IF91dGlsczJbJ2RlZmF1bHQnXS5jc3MocGFyZW50LCAncG9zaXRpb24nKTtcbiAgICBpZiAocG9zaXRpb25TdHlsZSAhPT0gJ3N0YXRpYycpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBnZXRPZmZzZXRQYXJlbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yYy10aW1lLXBpY2tlci9+L3JjLXRyaWdnZXIvfi9yYy1hbGlnbi9+L2RvbS1hbGlnbi9saWIvZ2V0T2Zmc2V0UGFyZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMTE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciBfdXRpbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbHMpO1xuXG52YXIgX2dldE9mZnNldFBhcmVudCA9IHJlcXVpcmUoJy4vZ2V0T2Zmc2V0UGFyZW50Jyk7XG5cbnZhciBfZ2V0T2Zmc2V0UGFyZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldE9mZnNldFBhcmVudCk7XG5cbi8qKlxuICog6I635b6X5YWD57Sg55qE5pi+56S66YOo5YiG55qE5Yy65Z+fXG4gKi9cbmZ1bmN0aW9uIGdldFZpc2libGVSZWN0Rm9yRWxlbWVudChlbGVtZW50KSB7XG4gIHZhciB2aXNpYmxlUmVjdCA9IHtcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiBJbmZpbml0eSxcbiAgICB0b3A6IDAsXG4gICAgYm90dG9tOiBJbmZpbml0eVxuICB9O1xuICB2YXIgZWwgPSAoMCwgX2dldE9mZnNldFBhcmVudDJbJ2RlZmF1bHQnXSkoZWxlbWVudCk7XG4gIHZhciBzY3JvbGxYID0gdW5kZWZpbmVkO1xuICB2YXIgc2Nyb2xsWSA9IHVuZGVmaW5lZDtcbiAgdmFyIHdpblNpemUgPSB1bmRlZmluZWQ7XG4gIHZhciBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIHZhciB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgdmFyIGJvZHkgPSBkb2MuYm9keTtcbiAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgLy8gRGV0ZXJtaW5lIHRoZSBzaXplIG9mIHRoZSB2aXNpYmxlIHJlY3QgYnkgY2xpbWJpbmcgdGhlIGRvbSBhY2NvdW50aW5nIGZvclxuICAvLyBhbGwgc2Nyb2xsYWJsZSBjb250YWluZXJzLlxuICB3aGlsZSAoZWwpIHtcbiAgICAvLyBjbGllbnRXaWR0aCBpcyB6ZXJvIGZvciBpbmxpbmUgYmxvY2sgZWxlbWVudHMgaW4gaWUuXG4gICAgaWYgKChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ01TSUUnKSA9PT0gLTEgfHwgZWwuY2xpZW50V2lkdGggIT09IDApICYmXG4gICAgLy8gYm9keSBtYXkgaGF2ZSBvdmVyZmxvdyBzZXQgb24gaXQsIHlldCB3ZSBzdGlsbCBnZXQgdGhlIGVudGlyZVxuICAgIC8vIHZpZXdwb3J0LiBJbiBzb21lIGJyb3dzZXJzLCBlbC5vZmZzZXRQYXJlbnQgbWF5IGJlXG4gICAgLy8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBzbyBjaGVjayBmb3IgdGhhdCB0b28uXG4gICAgZWwgIT09IGJvZHkgJiYgZWwgIT09IGRvY3VtZW50RWxlbWVudCAmJiBfdXRpbHMyWydkZWZhdWx0J10uY3NzKGVsLCAnb3ZlcmZsb3cnKSAhPT0gJ3Zpc2libGUnKSB7XG4gICAgICB2YXIgcG9zID0gX3V0aWxzMlsnZGVmYXVsdCddLm9mZnNldChlbCk7XG4gICAgICAvLyBhZGQgYm9yZGVyXG4gICAgICBwb3MubGVmdCArPSBlbC5jbGllbnRMZWZ0O1xuICAgICAgcG9zLnRvcCArPSBlbC5jbGllbnRUb3A7XG4gICAgICB2aXNpYmxlUmVjdC50b3AgPSBNYXRoLm1heCh2aXNpYmxlUmVjdC50b3AsIHBvcy50b3ApO1xuICAgICAgdmlzaWJsZVJlY3QucmlnaHQgPSBNYXRoLm1pbih2aXNpYmxlUmVjdC5yaWdodCxcbiAgICAgIC8vIGNvbnNpZGVyIGFyZWEgd2l0aG91dCBzY3JvbGxCYXJcbiAgICAgIHBvcy5sZWZ0ICsgZWwuY2xpZW50V2lkdGgpO1xuICAgICAgdmlzaWJsZVJlY3QuYm90dG9tID0gTWF0aC5taW4odmlzaWJsZVJlY3QuYm90dG9tLCBwb3MudG9wICsgZWwuY2xpZW50SGVpZ2h0KTtcbiAgICAgIHZpc2libGVSZWN0LmxlZnQgPSBNYXRoLm1heCh2aXNpYmxlUmVjdC5sZWZ0LCBwb3MubGVmdCk7XG4gICAgfSBlbHNlIGlmIChlbCA9PT0gYm9keSB8fCBlbCA9PT0gZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZWwgPSAoMCwgX2dldE9mZnNldFBhcmVudDJbJ2RlZmF1bHQnXSkoZWwpO1xuICB9XG5cbiAgLy8gQ2xpcCBieSB3aW5kb3cncyB2aWV3cG9ydC5cbiAgc2Nyb2xsWCA9IF91dGlsczJbJ2RlZmF1bHQnXS5nZXRXaW5kb3dTY3JvbGxMZWZ0KHdpbik7XG4gIHNjcm9sbFkgPSBfdXRpbHMyWydkZWZhdWx0J10uZ2V0V2luZG93U2Nyb2xsVG9wKHdpbik7XG4gIHZpc2libGVSZWN0LmxlZnQgPSBNYXRoLm1heCh2aXNpYmxlUmVjdC5sZWZ0LCBzY3JvbGxYKTtcbiAgdmlzaWJsZVJlY3QudG9wID0gTWF0aC5tYXgodmlzaWJsZVJlY3QudG9wLCBzY3JvbGxZKTtcbiAgd2luU2l6ZSA9IHtcbiAgICB3aWR0aDogX3V0aWxzMlsnZGVmYXVsdCddLnZpZXdwb3J0V2lkdGgod2luKSxcbiAgICBoZWlnaHQ6IF91dGlsczJbJ2RlZmF1bHQnXS52aWV3cG9ydEhlaWdodCh3aW4pXG4gIH07XG4gIHZpc2libGVSZWN0LnJpZ2h0ID0gTWF0aC5taW4odmlzaWJsZVJlY3QucmlnaHQsIHNjcm9sbFggKyB3aW5TaXplLndpZHRoKTtcbiAgdmlzaWJsZVJlY3QuYm90dG9tID0gTWF0aC5taW4odmlzaWJsZVJlY3QuYm90dG9tLCBzY3JvbGxZICsgd2luU2l6ZS5oZWlnaHQpO1xuICByZXR1cm4gdmlzaWJsZVJlY3QudG9wID49IDAgJiYgdmlzaWJsZVJlY3QubGVmdCA+PSAwICYmIHZpc2libGVSZWN0LmJvdHRvbSA+IHZpc2libGVSZWN0LnRvcCAmJiB2aXNpYmxlUmVjdC5yaWdodCA+IHZpc2libGVSZWN0LmxlZnQgPyB2aXNpYmxlUmVjdCA6IG51bGw7XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGdldFZpc2libGVSZWN0Rm9yRWxlbWVudDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JjLXRpbWUtcGlja2VyL34vcmMtdHJpZ2dlci9+L3JjLWFsaWduL34vZG9tLWFsaWduL2xpYi9nZXRWaXNpYmxlUmVjdEZvckVsZW1lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIF91dGlsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlscyk7XG5cbmZ1bmN0aW9uIGFkanVzdEZvclZpZXdwb3J0KGVsRnV0dXJlUG9zLCBlbFJlZ2lvbiwgdmlzaWJsZVJlY3QsIG92ZXJmbG93KSB7XG4gIHZhciBwb3MgPSBfdXRpbHMyWydkZWZhdWx0J10uY2xvbmUoZWxGdXR1cmVQb3MpO1xuICB2YXIgc2l6ZSA9IHtcbiAgICB3aWR0aDogZWxSZWdpb24ud2lkdGgsXG4gICAgaGVpZ2h0OiBlbFJlZ2lvbi5oZWlnaHRcbiAgfTtcblxuICBpZiAob3ZlcmZsb3cuYWRqdXN0WCAmJiBwb3MubGVmdCA8IHZpc2libGVSZWN0LmxlZnQpIHtcbiAgICBwb3MubGVmdCA9IHZpc2libGVSZWN0LmxlZnQ7XG4gIH1cblxuICAvLyBMZWZ0IGVkZ2UgaW5zaWRlIGFuZCByaWdodCBlZGdlIG91dHNpZGUgdmlld3BvcnQsIHRyeSB0byByZXNpemUgaXQuXG4gIGlmIChvdmVyZmxvdy5yZXNpemVXaWR0aCAmJiBwb3MubGVmdCA+PSB2aXNpYmxlUmVjdC5sZWZ0ICYmIHBvcy5sZWZ0ICsgc2l6ZS53aWR0aCA+IHZpc2libGVSZWN0LnJpZ2h0KSB7XG4gICAgc2l6ZS53aWR0aCAtPSBwb3MubGVmdCArIHNpemUud2lkdGggLSB2aXNpYmxlUmVjdC5yaWdodDtcbiAgfVxuXG4gIC8vIFJpZ2h0IGVkZ2Ugb3V0c2lkZSB2aWV3cG9ydCwgdHJ5IHRvIG1vdmUgaXQuXG4gIGlmIChvdmVyZmxvdy5hZGp1c3RYICYmIHBvcy5sZWZ0ICsgc2l6ZS53aWR0aCA+IHZpc2libGVSZWN0LnJpZ2h0KSB7XG4gICAgLy8g5L+d6K+B5bem6L6555WM5ZKM5Y+v6KeG5Yy65Z+f5bem6L6555WM5a+56b2QXG4gICAgcG9zLmxlZnQgPSBNYXRoLm1heCh2aXNpYmxlUmVjdC5yaWdodCAtIHNpemUud2lkdGgsIHZpc2libGVSZWN0LmxlZnQpO1xuICB9XG5cbiAgLy8gVG9wIGVkZ2Ugb3V0c2lkZSB2aWV3cG9ydCwgdHJ5IHRvIG1vdmUgaXQuXG4gIGlmIChvdmVyZmxvdy5hZGp1c3RZICYmIHBvcy50b3AgPCB2aXNpYmxlUmVjdC50b3ApIHtcbiAgICBwb3MudG9wID0gdmlzaWJsZVJlY3QudG9wO1xuICB9XG5cbiAgLy8gVG9wIGVkZ2UgaW5zaWRlIGFuZCBib3R0b20gZWRnZSBvdXRzaWRlIHZpZXdwb3J0LCB0cnkgdG8gcmVzaXplIGl0LlxuICBpZiAob3ZlcmZsb3cucmVzaXplSGVpZ2h0ICYmIHBvcy50b3AgPj0gdmlzaWJsZVJlY3QudG9wICYmIHBvcy50b3AgKyBzaXplLmhlaWdodCA+IHZpc2libGVSZWN0LmJvdHRvbSkge1xuICAgIHNpemUuaGVpZ2h0IC09IHBvcy50b3AgKyBzaXplLmhlaWdodCAtIHZpc2libGVSZWN0LmJvdHRvbTtcbiAgfVxuXG4gIC8vIEJvdHRvbSBlZGdlIG91dHNpZGUgdmlld3BvcnQsIHRyeSB0byBtb3ZlIGl0LlxuICBpZiAob3ZlcmZsb3cuYWRqdXN0WSAmJiBwb3MudG9wICsgc2l6ZS5oZWlnaHQgPiB2aXNpYmxlUmVjdC5ib3R0b20pIHtcbiAgICAvLyDkv53or4HkuIrovrnnlYzlkozlj6/op4bljLrln5/kuIrovrnnlYzlr7npvZBcbiAgICBwb3MudG9wID0gTWF0aC5tYXgodmlzaWJsZVJlY3QuYm90dG9tIC0gc2l6ZS5oZWlnaHQsIHZpc2libGVSZWN0LnRvcCk7XG4gIH1cblxuICByZXR1cm4gX3V0aWxzMlsnZGVmYXVsdCddLm1peChwb3MsIHNpemUpO1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBhZGp1c3RGb3JWaWV3cG9ydDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JjLXRpbWUtcGlja2VyL34vcmMtdHJpZ2dlci9+L3JjLWFsaWduL34vZG9tLWFsaWduL2xpYi9hZGp1c3RGb3JWaWV3cG9ydC5qc1xuICoqIG1vZHVsZSBpZCA9IDEyMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXIgX3V0aWxzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWxzKTtcblxuZnVuY3Rpb24gZ2V0UmVnaW9uKG5vZGUpIHtcbiAgdmFyIG9mZnNldCA9IHVuZGVmaW5lZDtcbiAgdmFyIHcgPSB1bmRlZmluZWQ7XG4gIHZhciBoID0gdW5kZWZpbmVkO1xuICBpZiAoIV91dGlsczJbJ2RlZmF1bHQnXS5pc1dpbmRvdyhub2RlKSAmJiBub2RlLm5vZGVUeXBlICE9PSA5KSB7XG4gICAgb2Zmc2V0ID0gX3V0aWxzMlsnZGVmYXVsdCddLm9mZnNldChub2RlKTtcbiAgICB3ID0gX3V0aWxzMlsnZGVmYXVsdCddLm91dGVyV2lkdGgobm9kZSk7XG4gICAgaCA9IF91dGlsczJbJ2RlZmF1bHQnXS5vdXRlckhlaWdodChub2RlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgd2luID0gX3V0aWxzMlsnZGVmYXVsdCddLmdldFdpbmRvdyhub2RlKTtcbiAgICBvZmZzZXQgPSB7XG4gICAgICBsZWZ0OiBfdXRpbHMyWydkZWZhdWx0J10uZ2V0V2luZG93U2Nyb2xsTGVmdCh3aW4pLFxuICAgICAgdG9wOiBfdXRpbHMyWydkZWZhdWx0J10uZ2V0V2luZG93U2Nyb2xsVG9wKHdpbilcbiAgICB9O1xuICAgIHcgPSBfdXRpbHMyWydkZWZhdWx0J10udmlld3BvcnRXaWR0aCh3aW4pO1xuICAgIGggPSBfdXRpbHMyWydkZWZhdWx0J10udmlld3BvcnRIZWlnaHQod2luKTtcbiAgfVxuICBvZmZzZXQud2lkdGggPSB3O1xuICBvZmZzZXQuaGVpZ2h0ID0gaDtcbiAgcmV0dXJuIG9mZnNldDtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gZ2V0UmVnaW9uO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmMtdGltZS1waWNrZXIvfi9yYy10cmlnZ2VyL34vcmMtYWxpZ24vfi9kb20tYWxpZ24vbGliL2dldFJlZ2lvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDEyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX2dldEFsaWduT2Zmc2V0ID0gcmVxdWlyZSgnLi9nZXRBbGlnbk9mZnNldCcpO1xuXG52YXIgX2dldEFsaWduT2Zmc2V0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEFsaWduT2Zmc2V0KTtcblxuZnVuY3Rpb24gZ2V0RWxGdXR1cmVQb3MoZWxSZWdpb24sIHJlZk5vZGVSZWdpb24sIHBvaW50cywgb2Zmc2V0LCB0YXJnZXRPZmZzZXQpIHtcbiAgdmFyIHh5ID0gdW5kZWZpbmVkO1xuICB2YXIgZGlmZiA9IHVuZGVmaW5lZDtcbiAgdmFyIHAxID0gdW5kZWZpbmVkO1xuICB2YXIgcDIgPSB1bmRlZmluZWQ7XG5cbiAgeHkgPSB7XG4gICAgbGVmdDogZWxSZWdpb24ubGVmdCxcbiAgICB0b3A6IGVsUmVnaW9uLnRvcFxuICB9O1xuXG4gIHAxID0gKDAsIF9nZXRBbGlnbk9mZnNldDJbJ2RlZmF1bHQnXSkocmVmTm9kZVJlZ2lvbiwgcG9pbnRzWzFdKTtcbiAgcDIgPSAoMCwgX2dldEFsaWduT2Zmc2V0MlsnZGVmYXVsdCddKShlbFJlZ2lvbiwgcG9pbnRzWzBdKTtcblxuICBkaWZmID0gW3AyLmxlZnQgLSBwMS5sZWZ0LCBwMi50b3AgLSBwMS50b3BdO1xuXG4gIHJldHVybiB7XG4gICAgbGVmdDogeHkubGVmdCAtIGRpZmZbMF0gKyBvZmZzZXRbMF0gLSB0YXJnZXRPZmZzZXRbMF0sXG4gICAgdG9wOiB4eS50b3AgLSBkaWZmWzFdICsgb2Zmc2V0WzFdIC0gdGFyZ2V0T2Zmc2V0WzFdXG4gIH07XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGdldEVsRnV0dXJlUG9zO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmMtdGltZS1waWNrZXIvfi9yYy10cmlnZ2VyL34vcmMtYWxpZ24vfi9kb20tYWxpZ24vbGliL2dldEVsRnV0dXJlUG9zLmpzXG4gKiogbW9kdWxlIGlkID0gMTIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9DaGlsZHJlblV0aWxzID0gcmVxdWlyZSgnLi9DaGlsZHJlblV0aWxzJyk7XG5cbnZhciBfQW5pbWF0ZUNoaWxkID0gcmVxdWlyZSgnLi9BbmltYXRlQ2hpbGQnKTtcblxudmFyIF9BbmltYXRlQ2hpbGQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQW5pbWF0ZUNoaWxkKTtcblxudmFyIF91dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbnZhciBfdXRpbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlsKTtcblxudmFyIGRlZmF1bHRLZXkgPSAncmNfYW5pbWF0ZV8nICsgRGF0ZS5ub3coKTtcblxuZnVuY3Rpb24gZ2V0Q2hpbGRyZW5Gcm9tUHJvcHMocHJvcHMpIHtcbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gIGlmIChfcmVhY3QyWydkZWZhdWx0J10uaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKSB7XG4gICAgaWYgKCFjaGlsZHJlbi5rZXkpIHtcbiAgICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY2xvbmVFbGVtZW50KGNoaWxkcmVuLCB7XG4gICAgICAgIGtleTogZGVmYXVsdEtleVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBBbmltYXRlID0gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdBbmltYXRlJyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBjb21wb25lbnQ6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYW55LFxuICAgIGFuaW1hdGlvbjogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5vYmplY3QsXG4gICAgdHJhbnNpdGlvbk5hbWU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHRyYW5zaXRpb25FbnRlcjogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLFxuICAgIHRyYW5zaXRpb25BcHBlYXI6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCxcbiAgICBleGNsdXNpdmU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCxcbiAgICB0cmFuc2l0aW9uTGVhdmU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCxcbiAgICBvbkVuZDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLFxuICAgIG9uRW50ZXI6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkxlYXZlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25BcHBlYXI6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYyxcbiAgICBzaG93UHJvcDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmdcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYW5pbWF0aW9uOiB7fSxcbiAgICAgIGNvbXBvbmVudDogJ3NwYW4nLFxuICAgICAgdHJhbnNpdGlvbkVudGVyOiB0cnVlLFxuICAgICAgdHJhbnNpdGlvbkxlYXZlOiB0cnVlLFxuICAgICAgdHJhbnNpdGlvbkFwcGVhcjogZmFsc2UsXG4gICAgICBvbkVuZDogbm9vcCxcbiAgICAgIG9uRW50ZXI6IG5vb3AsXG4gICAgICBvbkxlYXZlOiBub29wLFxuICAgICAgb25BcHBlYXI6IG5vb3BcbiAgICB9O1xuICB9LFxuXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgIHRoaXMuY3VycmVudGx5QW5pbWF0aW5nS2V5cyA9IHt9O1xuICAgIHRoaXMua2V5c1RvRW50ZXIgPSBbXTtcbiAgICB0aGlzLmtleXNUb0xlYXZlID0gW107XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoaWxkcmVuOiAoMCwgX0NoaWxkcmVuVXRpbHMudG9BcnJheUNoaWxkcmVuKShnZXRDaGlsZHJlbkZyb21Qcm9wcyh0aGlzLnByb3BzKSlcbiAgICB9O1xuICB9LFxuXG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHNob3dQcm9wID0gdGhpcy5wcm9wcy5zaG93UHJvcDtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnN0YXRlLmNoaWxkcmVuO1xuICAgIGlmIChzaG93UHJvcCkge1xuICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiAhIWNoaWxkLnByb3BzW3Nob3dQcm9wXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgX3RoaXMucGVyZm9ybUFwcGVhcihjaGlsZC5rZXkpO1xuICAgIH0pO1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB0aGlzLm5leHRQcm9wcyA9IG5leHRQcm9wcztcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gKDAsIF9DaGlsZHJlblV0aWxzLnRvQXJyYXlDaGlsZHJlbikoZ2V0Q2hpbGRyZW5Gcm9tUHJvcHMobmV4dFByb3BzKSk7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAvLyBleGNsdXNpdmUgbmVlZHMgaW1tZWRpYXRlIHJlc3BvbnNlXG4gICAgaWYgKHByb3BzLmV4Y2x1c2l2ZSkge1xuICAgICAgT2JqZWN0LmtleXModGhpcy5jdXJyZW50bHlBbmltYXRpbmdLZXlzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX3RoaXMyLnN0b3Aoa2V5KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgc2hvd1Byb3AgPSBwcm9wcy5zaG93UHJvcDtcbiAgICB2YXIgY3VycmVudGx5QW5pbWF0aW5nS2V5cyA9IHRoaXMuY3VycmVudGx5QW5pbWF0aW5nS2V5cztcbiAgICAvLyBsYXN0IHByb3BzIGNoaWxkcmVuIGlmIGV4Y2x1c2l2ZVxuICAgIHZhciBjdXJyZW50Q2hpbGRyZW4gPSBwcm9wcy5leGNsdXNpdmUgPyAoMCwgX0NoaWxkcmVuVXRpbHMudG9BcnJheUNoaWxkcmVuKShnZXRDaGlsZHJlbkZyb21Qcm9wcyhwcm9wcykpIDogdGhpcy5zdGF0ZS5jaGlsZHJlbjtcbiAgICAvLyBpbiBjYXNlIGRlc3Ryb3kgaW4gc2hvd1Byb3AgbW9kZVxuICAgIHZhciBuZXdDaGlsZHJlbiA9IFtdO1xuICAgIGlmIChzaG93UHJvcCkge1xuICAgICAgY3VycmVudENoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGN1cnJlbnRDaGlsZCkge1xuICAgICAgICB2YXIgbmV4dENoaWxkID0gKDAsIF9DaGlsZHJlblV0aWxzLmZpbmRDaGlsZEluQ2hpbGRyZW5CeUtleSkobmV4dENoaWxkcmVuLCBjdXJyZW50Q2hpbGQua2V5KTtcbiAgICAgICAgdmFyIG5ld0NoaWxkID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoKCFuZXh0Q2hpbGQgfHwgIW5leHRDaGlsZC5wcm9wc1tzaG93UHJvcF0pICYmIGN1cnJlbnRDaGlsZC5wcm9wc1tzaG93UHJvcF0pIHtcbiAgICAgICAgICBuZXdDaGlsZCA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jbG9uZUVsZW1lbnQobmV4dENoaWxkIHx8IGN1cnJlbnRDaGlsZCwgX2RlZmluZVByb3BlcnR5KHt9LCBzaG93UHJvcCwgdHJ1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0NoaWxkID0gbmV4dENoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdDaGlsZCkge1xuICAgICAgICAgIG5ld0NoaWxkcmVuLnB1c2gobmV3Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG5leHRDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChuZXh0Q2hpbGQpIHtcbiAgICAgICAgaWYgKCEoMCwgX0NoaWxkcmVuVXRpbHMuZmluZENoaWxkSW5DaGlsZHJlbkJ5S2V5KShjdXJyZW50Q2hpbGRyZW4sIG5leHRDaGlsZC5rZXkpKSB7XG4gICAgICAgICAgbmV3Q2hpbGRyZW4ucHVzaChuZXh0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3Q2hpbGRyZW4gPSAoMCwgX0NoaWxkcmVuVXRpbHMubWVyZ2VDaGlsZHJlbikoY3VycmVudENoaWxkcmVuLCBuZXh0Q2hpbGRyZW4pO1xuICAgIH1cblxuICAgIC8vIG5lZWQgcmVuZGVyIHRvIGF2b2lkIHVwZGF0ZVxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgY2hpbGRyZW46IG5ld0NoaWxkcmVuXG4gICAgfSk7XG5cbiAgICBuZXh0Q2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHZhciBrZXkgPSBjaGlsZC5rZXk7XG4gICAgICBpZiAoY3VycmVudGx5QW5pbWF0aW5nS2V5c1trZXldKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBoYXNQcmV2ID0gKDAsIF9DaGlsZHJlblV0aWxzLmZpbmRDaGlsZEluQ2hpbGRyZW5CeUtleSkoY3VycmVudENoaWxkcmVuLCBrZXkpO1xuICAgICAgaWYgKHNob3dQcm9wKSB7XG4gICAgICAgIHZhciBzaG93SW5OZXh0ID0gY2hpbGQucHJvcHNbc2hvd1Byb3BdO1xuICAgICAgICBpZiAoaGFzUHJldikge1xuICAgICAgICAgIHZhciBzaG93SW5Ob3cgPSAoMCwgX0NoaWxkcmVuVXRpbHMuZmluZFNob3duQ2hpbGRJbkNoaWxkcmVuQnlLZXkpKGN1cnJlbnRDaGlsZHJlbiwga2V5LCBzaG93UHJvcCk7XG4gICAgICAgICAgaWYgKCFzaG93SW5Ob3cgJiYgc2hvd0luTmV4dCkge1xuICAgICAgICAgICAgX3RoaXMyLmtleXNUb0VudGVyLnB1c2goa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2hvd0luTmV4dCkge1xuICAgICAgICAgIF90aGlzMi5rZXlzVG9FbnRlci5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWhhc1ByZXYpIHtcbiAgICAgICAgX3RoaXMyLmtleXNUb0VudGVyLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGN1cnJlbnRDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgdmFyIGtleSA9IGNoaWxkLmtleTtcbiAgICAgIGlmIChjdXJyZW50bHlBbmltYXRpbmdLZXlzW2tleV0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGhhc05leHQgPSAoMCwgX0NoaWxkcmVuVXRpbHMuZmluZENoaWxkSW5DaGlsZHJlbkJ5S2V5KShuZXh0Q2hpbGRyZW4sIGtleSk7XG4gICAgICBpZiAoc2hvd1Byb3ApIHtcbiAgICAgICAgdmFyIHNob3dJbk5vdyA9IGNoaWxkLnByb3BzW3Nob3dQcm9wXTtcbiAgICAgICAgaWYgKGhhc05leHQpIHtcbiAgICAgICAgICB2YXIgc2hvd0luTmV4dCA9ICgwLCBfQ2hpbGRyZW5VdGlscy5maW5kU2hvd25DaGlsZEluQ2hpbGRyZW5CeUtleSkobmV4dENoaWxkcmVuLCBrZXksIHNob3dQcm9wKTtcbiAgICAgICAgICBpZiAoIXNob3dJbk5leHQgJiYgc2hvd0luTm93KSB7XG4gICAgICAgICAgICBfdGhpczIua2V5c1RvTGVhdmUucHVzaChrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzaG93SW5Ob3cpIHtcbiAgICAgICAgICBfdGhpczIua2V5c1RvTGVhdmUucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFoYXNOZXh0KSB7XG4gICAgICAgIF90aGlzMi5rZXlzVG9MZWF2ZS5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkVXBkYXRlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgaWYgKHRoaXMuaXNNb3VudGVkKCkpIHtcbiAgICAgIHZhciBrZXlzVG9FbnRlciA9IHRoaXMua2V5c1RvRW50ZXI7XG4gICAgICB0aGlzLmtleXNUb0VudGVyID0gW107XG4gICAgICBrZXlzVG9FbnRlci5mb3JFYWNoKHRoaXMucGVyZm9ybUVudGVyKTtcbiAgICAgIHZhciBrZXlzVG9MZWF2ZSA9IHRoaXMua2V5c1RvTGVhdmU7XG4gICAgICB0aGlzLmtleXNUb0xlYXZlID0gW107XG4gICAgICBrZXlzVG9MZWF2ZS5mb3JFYWNoKHRoaXMucGVyZm9ybUxlYXZlKTtcbiAgICB9XG4gIH0sXG5cbiAgcGVyZm9ybUVudGVyOiBmdW5jdGlvbiBwZXJmb3JtRW50ZXIoa2V5KSB7XG4gICAgLy8gbWF5IGFscmVhZHkgcmVtb3ZlIGJ5IGV4Y2x1c2l2ZVxuICAgIGlmICh0aGlzLnJlZnNba2V5XSkge1xuICAgICAgdGhpcy5jdXJyZW50bHlBbmltYXRpbmdLZXlzW2tleV0gPSB0cnVlO1xuICAgICAgdGhpcy5yZWZzW2tleV0uY29tcG9uZW50V2lsbEVudGVyKHRoaXMuaGFuZGxlRG9uZUFkZGluZy5iaW5kKHRoaXMsIGtleSwgJ2VudGVyJykpO1xuICAgIH1cbiAgfSxcblxuICBwZXJmb3JtQXBwZWFyOiBmdW5jdGlvbiBwZXJmb3JtQXBwZWFyKGtleSkge1xuICAgIGlmICh0aGlzLnJlZnNba2V5XSkge1xuICAgICAgdGhpcy5jdXJyZW50bHlBbmltYXRpbmdLZXlzW2tleV0gPSB0cnVlO1xuICAgICAgdGhpcy5yZWZzW2tleV0uY29tcG9uZW50V2lsbEFwcGVhcih0aGlzLmhhbmRsZURvbmVBZGRpbmcuYmluZCh0aGlzLCBrZXksICdhcHBlYXInKSk7XG4gICAgfVxuICB9LFxuXG4gIGhhbmRsZURvbmVBZGRpbmc6IGZ1bmN0aW9uIGhhbmRsZURvbmVBZGRpbmcoa2V5LCB0eXBlKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICBkZWxldGUgdGhpcy5jdXJyZW50bHlBbmltYXRpbmdLZXlzW2tleV07XG4gICAgLy8gaWYgdXBkYXRlIG9uIGV4Y2x1c2l2ZSBtb2RlLCBza2lwIGNoZWNrXG4gICAgaWYgKHByb3BzLmV4Y2x1c2l2ZSAmJiBwcm9wcyAhPT0gdGhpcy5uZXh0UHJvcHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGN1cnJlbnRDaGlsZHJlbiA9ICgwLCBfQ2hpbGRyZW5VdGlscy50b0FycmF5Q2hpbGRyZW4pKGdldENoaWxkcmVuRnJvbVByb3BzKHByb3BzKSk7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWRDaGlsZEJ5S2V5KGN1cnJlbnRDaGlsZHJlbiwga2V5KSkge1xuICAgICAgLy8gZXhjbHVzaXZlIHdpbGwgbm90IG5lZWQgdGhpc1xuICAgICAgdGhpcy5wZXJmb3JtTGVhdmUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgPT09ICdhcHBlYXInKSB7XG4gICAgICAgIGlmIChfdXRpbDJbJ2RlZmF1bHQnXS5hbGxvd0FwcGVhckNhbGxiYWNrKHByb3BzKSkge1xuICAgICAgICAgIHByb3BzLm9uQXBwZWFyKGtleSk7XG4gICAgICAgICAgcHJvcHMub25FbmQoa2V5LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKF91dGlsMlsnZGVmYXVsdCddLmFsbG93RW50ZXJDYWxsYmFjayhwcm9wcykpIHtcbiAgICAgICAgICBwcm9wcy5vbkVudGVyKGtleSk7XG4gICAgICAgICAgcHJvcHMub25FbmQoa2V5LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBwZXJmb3JtTGVhdmU6IGZ1bmN0aW9uIHBlcmZvcm1MZWF2ZShrZXkpIHtcbiAgICAvLyBtYXkgYWxyZWFkeSByZW1vdmUgYnkgZXhjbHVzaXZlXG4gICAgaWYgKHRoaXMucmVmc1trZXldKSB7XG4gICAgICB0aGlzLmN1cnJlbnRseUFuaW1hdGluZ0tleXNba2V5XSA9IHRydWU7XG4gICAgICB0aGlzLnJlZnNba2V5XS5jb21wb25lbnRXaWxsTGVhdmUodGhpcy5oYW5kbGVEb25lTGVhdmluZy5iaW5kKHRoaXMsIGtleSkpO1xuICAgIH1cbiAgfSxcblxuICBoYW5kbGVEb25lTGVhdmluZzogZnVuY3Rpb24gaGFuZGxlRG9uZUxlYXZpbmcoa2V5KSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICBkZWxldGUgdGhpcy5jdXJyZW50bHlBbmltYXRpbmdLZXlzW2tleV07XG4gICAgLy8gaWYgdXBkYXRlIG9uIGV4Y2x1c2l2ZSBtb2RlLCBza2lwIGNoZWNrXG4gICAgaWYgKHByb3BzLmV4Y2x1c2l2ZSAmJiBwcm9wcyAhPT0gdGhpcy5uZXh0UHJvcHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGN1cnJlbnRDaGlsZHJlbiA9ICgwLCBfQ2hpbGRyZW5VdGlscy50b0FycmF5Q2hpbGRyZW4pKGdldENoaWxkcmVuRnJvbVByb3BzKHByb3BzKSk7XG4gICAgLy8gaW4gY2FzZSBzdGF0ZSBjaGFuZ2UgaXMgdG9vIGZhc3RcbiAgICBpZiAodGhpcy5pc1ZhbGlkQ2hpbGRCeUtleShjdXJyZW50Q2hpbGRyZW4sIGtleSkpIHtcbiAgICAgIHRoaXMucGVyZm9ybUVudGVyKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChfdXRpbDJbJ2RlZmF1bHQnXS5hbGxvd0xlYXZlQ2FsbGJhY2socHJvcHMpKSB7XG4gICAgICAgIHByb3BzLm9uTGVhdmUoa2V5KTtcbiAgICAgICAgcHJvcHMub25FbmQoa2V5LCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc01vdW50ZWQoKSAmJiAhKDAsIF9DaGlsZHJlblV0aWxzLmlzU2FtZUNoaWxkcmVuKSh0aGlzLnN0YXRlLmNoaWxkcmVuLCBjdXJyZW50Q2hpbGRyZW4sIHByb3BzLnNob3dQcm9wKSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBjaGlsZHJlbjogY3VycmVudENoaWxkcmVuXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBpc1ZhbGlkQ2hpbGRCeUtleTogZnVuY3Rpb24gaXNWYWxpZENoaWxkQnlLZXkoY3VycmVudENoaWxkcmVuLCBrZXkpIHtcbiAgICB2YXIgc2hvd1Byb3AgPSB0aGlzLnByb3BzLnNob3dQcm9wO1xuICAgIGlmIChzaG93UHJvcCkge1xuICAgICAgcmV0dXJuICgwLCBfQ2hpbGRyZW5VdGlscy5maW5kU2hvd25DaGlsZEluQ2hpbGRyZW5CeUtleSkoY3VycmVudENoaWxkcmVuLCBrZXksIHNob3dQcm9wKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBfQ2hpbGRyZW5VdGlscy5maW5kQ2hpbGRJbkNoaWxkcmVuQnlLZXkpKGN1cnJlbnRDaGlsZHJlbiwga2V5KTtcbiAgfSxcblxuICBzdG9wOiBmdW5jdGlvbiBzdG9wKGtleSkge1xuICAgIGRlbGV0ZSB0aGlzLmN1cnJlbnRseUFuaW1hdGluZ0tleXNba2V5XTtcbiAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5yZWZzW2tleV07XG4gICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgY29tcG9uZW50LnN0b3AoKTtcbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB0aGlzLm5leHRQcm9wcyA9IHByb3BzO1xuICAgIHZhciBzdGF0ZUNoaWxkcmVuID0gdGhpcy5zdGF0ZS5jaGlsZHJlbjtcbiAgICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuICAgIGlmIChzdGF0ZUNoaWxkcmVuKSB7XG4gICAgICBjaGlsZHJlbiA9IHN0YXRlQ2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGlsZC5rZXkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3Qgc2V0IGtleSBmb3IgPHJjLWFuaW1hdGU+IGNoaWxkcmVuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIF9BbmltYXRlQ2hpbGQyWydkZWZhdWx0J10sXG4gICAgICAgICAge1xuICAgICAgICAgICAga2V5OiBjaGlsZC5rZXksXG4gICAgICAgICAgICByZWY6IGNoaWxkLmtleSxcbiAgICAgICAgICAgIGFuaW1hdGlvbjogcHJvcHMuYW5pbWF0aW9uLFxuICAgICAgICAgICAgdHJhbnNpdGlvbk5hbWU6IHByb3BzLnRyYW5zaXRpb25OYW1lLFxuICAgICAgICAgICAgdHJhbnNpdGlvbkVudGVyOiBwcm9wcy50cmFuc2l0aW9uRW50ZXIsXG4gICAgICAgICAgICB0cmFuc2l0aW9uQXBwZWFyOiBwcm9wcy50cmFuc2l0aW9uQXBwZWFyLFxuICAgICAgICAgICAgdHJhbnNpdGlvbkxlYXZlOiBwcm9wcy50cmFuc2l0aW9uTGVhdmUgfSxcbiAgICAgICAgICBjaGlsZFxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBDb21wb25lbnQgPSBwcm9wcy5jb21wb25lbnQ7XG4gICAgaWYgKENvbXBvbmVudCkge1xuICAgICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIHRoaXMucHJvcHMsXG4gICAgICAgIGNoaWxkcmVuXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW5bMF0gfHwgbnVsbDtcbiAgfVxufSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEFuaW1hdGU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yYy10aW1lLXBpY2tlci9+L3JjLXRyaWdnZXIvfi9yYy1hbmltYXRlL2xpYi9BbmltYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMTI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy50b0FycmF5Q2hpbGRyZW4gPSB0b0FycmF5Q2hpbGRyZW47XG5leHBvcnRzLmZpbmRDaGlsZEluQ2hpbGRyZW5CeUtleSA9IGZpbmRDaGlsZEluQ2hpbGRyZW5CeUtleTtcbmV4cG9ydHMuZmluZFNob3duQ2hpbGRJbkNoaWxkcmVuQnlLZXkgPSBmaW5kU2hvd25DaGlsZEluQ2hpbGRyZW5CeUtleTtcbmV4cG9ydHMuZmluZEhpZGRlbkNoaWxkSW5DaGlsZHJlbkJ5S2V5ID0gZmluZEhpZGRlbkNoaWxkSW5DaGlsZHJlbkJ5S2V5O1xuZXhwb3J0cy5pc1NhbWVDaGlsZHJlbiA9IGlzU2FtZUNoaWxkcmVuO1xuZXhwb3J0cy5tZXJnZUNoaWxkcmVuID0gbWVyZ2VDaGlsZHJlbjtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbmZ1bmN0aW9uIHRvQXJyYXlDaGlsZHJlbihjaGlsZHJlbikge1xuICB2YXIgcmV0ID0gW107XG4gIF9yZWFjdDJbJ2RlZmF1bHQnXS5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXQucHVzaChjaGlsZCk7XG4gIH0pO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBmaW5kQ2hpbGRJbkNoaWxkcmVuQnlLZXkoY2hpbGRyZW4sIGtleSkge1xuICB2YXIgcmV0ID0gbnVsbDtcbiAgaWYgKGNoaWxkcmVuKSB7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIHJldCA9IGNoaWxkO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGZpbmRTaG93bkNoaWxkSW5DaGlsZHJlbkJ5S2V5KGNoaWxkcmVuLCBrZXksIHNob3dQcm9wKSB7XG4gIHZhciByZXQgPSBudWxsO1xuICBpZiAoY2hpbGRyZW4pIHtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5ICYmIGNoaWxkLnByb3BzW3Nob3dQcm9wXSkge1xuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0d28gY2hpbGQgd2l0aCBzYW1lIGtleSBmb3IgPHJjLWFuaW1hdGU+IGNoaWxkcmVuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0ID0gY2hpbGQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZmluZEhpZGRlbkNoaWxkSW5DaGlsZHJlbkJ5S2V5KGNoaWxkcmVuLCBrZXksIHNob3dQcm9wKSB7XG4gIHZhciBmb3VuZCA9IDA7XG4gIGlmIChjaGlsZHJlbikge1xuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm91bmQgPSBjaGlsZC5rZXkgPT09IGtleSAmJiAhY2hpbGQucHJvcHNbc2hvd1Byb3BdO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBmb3VuZDtcbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGRyZW4oYzEsIGMyLCBzaG93UHJvcCkge1xuICB2YXIgc2FtZSA9IGMxLmxlbmd0aCA9PT0gYzIubGVuZ3RoO1xuICBpZiAoc2FtZSkge1xuICAgIGMxLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkLCBpbmRleCkge1xuICAgICAgdmFyIGNoaWxkMiA9IGMyW2luZGV4XTtcbiAgICAgIGlmIChjaGlsZC5rZXkgIT09IGNoaWxkMi5rZXkpIHtcbiAgICAgICAgc2FtZSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChzaG93UHJvcCAmJiBjaGlsZC5wcm9wc1tzaG93UHJvcF0gIT09IGNoaWxkMi5wcm9wc1tzaG93UHJvcF0pIHtcbiAgICAgICAgc2FtZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBzYW1lO1xufVxuXG5mdW5jdGlvbiBtZXJnZUNoaWxkcmVuKHByZXYsIG5leHQpIHtcbiAgdmFyIHJldCA9IFtdO1xuXG4gIC8vIEZvciBlYWNoIGtleSBvZiBgbmV4dGAsIHRoZSBsaXN0IG9mIGtleXMgdG8gaW5zZXJ0IGJlZm9yZSB0aGF0IGtleSBpblxuICAvLyB0aGUgY29tYmluZWQgbGlzdFxuICB2YXIgbmV4dENoaWxkcmVuUGVuZGluZyA9IHt9O1xuICB2YXIgcGVuZGluZ0NoaWxkcmVuID0gW107XG4gIHByZXYuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoZmluZENoaWxkSW5DaGlsZHJlbkJ5S2V5KG5leHQsIGNoaWxkLmtleSkpIHtcbiAgICAgIGlmIChwZW5kaW5nQ2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIG5leHRDaGlsZHJlblBlbmRpbmdbY2hpbGQua2V5XSA9IHBlbmRpbmdDaGlsZHJlbjtcbiAgICAgICAgcGVuZGluZ0NoaWxkcmVuID0gW107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlbmRpbmdDaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH0pO1xuXG4gIG5leHQuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAobmV4dENoaWxkcmVuUGVuZGluZy5oYXNPd25Qcm9wZXJ0eShjaGlsZC5rZXkpKSB7XG4gICAgICByZXQgPSByZXQuY29uY2F0KG5leHRDaGlsZHJlblBlbmRpbmdbY2hpbGQua2V5XSk7XG4gICAgfVxuICAgIHJldC5wdXNoKGNoaWxkKTtcbiAgfSk7XG5cbiAgcmV0ID0gcmV0LmNvbmNhdChwZW5kaW5nQ2hpbGRyZW4pO1xuXG4gIHJldHVybiByZXQ7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmMtdGltZS1waWNrZXIvfi9yYy10cmlnZ2VyL34vcmMtYW5pbWF0ZS9saWIvQ2hpbGRyZW5VdGlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDEyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcmVhY3REb20gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIF9yZWFjdERvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdERvbSk7XG5cbnZhciBfY3NzQW5pbWF0aW9uID0gcmVxdWlyZSgnY3NzLWFuaW1hdGlvbicpO1xuXG52YXIgX2Nzc0FuaW1hdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jc3NBbmltYXRpb24pO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIF91dGlsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWwpO1xuXG52YXIgdHJhbnNpdGlvbk1hcCA9IHtcbiAgZW50ZXI6ICd0cmFuc2l0aW9uRW50ZXInLFxuICBhcHBlYXI6ICd0cmFuc2l0aW9uQXBwZWFyJyxcbiAgbGVhdmU6ICd0cmFuc2l0aW9uTGVhdmUnXG59O1xuXG52YXIgQW5pbWF0ZUNoaWxkID0gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdBbmltYXRlQ2hpbGQnLFxuXG4gIHByb3BUeXBlczoge1xuICAgIGNoaWxkcmVuOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmFueVxuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLnN0b3AoKTtcbiAgfSxcblxuICBjb21wb25lbnRXaWxsRW50ZXI6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxFbnRlcihkb25lKSB7XG4gICAgaWYgKF91dGlsMlsnZGVmYXVsdCddLmlzRW50ZXJTdXBwb3J0ZWQodGhpcy5wcm9wcykpIHtcbiAgICAgIHRoaXMudHJhbnNpdGlvbignZW50ZXInLCBkb25lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9uZSgpO1xuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRXaWxsQXBwZWFyOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsQXBwZWFyKGRvbmUpIHtcbiAgICBpZiAoX3V0aWwyWydkZWZhdWx0J10uaXNBcHBlYXJTdXBwb3J0ZWQodGhpcy5wcm9wcykpIHtcbiAgICAgIHRoaXMudHJhbnNpdGlvbignYXBwZWFyJywgZG9uZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvbmUoKTtcbiAgICB9XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbExlYXZlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTGVhdmUoZG9uZSkge1xuICAgIGlmIChfdXRpbDJbJ2RlZmF1bHQnXS5pc0xlYXZlU3VwcG9ydGVkKHRoaXMucHJvcHMpKSB7XG4gICAgICB0aGlzLnRyYW5zaXRpb24oJ2xlYXZlJywgZG9uZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvbmUoKTtcbiAgICB9XG4gIH0sXG5cbiAgdHJhbnNpdGlvbjogZnVuY3Rpb24gdHJhbnNpdGlvbihhbmltYXRpb25UeXBlLCBmaW5pc2hDYWxsYmFjaykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgbm9kZSA9IF9yZWFjdERvbTJbJ2RlZmF1bHQnXS5maW5kRE9NTm9kZSh0aGlzKTtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciB0cmFuc2l0aW9uTmFtZSA9IHByb3BzLnRyYW5zaXRpb25OYW1lO1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIHZhciBlbmQgPSBmdW5jdGlvbiBlbmQoKSB7XG4gICAgICBfdGhpcy5zdG9wcGVyID0gbnVsbDtcbiAgICAgIGZpbmlzaENhbGxiYWNrKCk7XG4gICAgfTtcbiAgICBpZiAoKF9jc3NBbmltYXRpb24uaXNDc3NBbmltYXRpb25TdXBwb3J0ZWQgfHwgIXByb3BzLmFuaW1hdGlvblthbmltYXRpb25UeXBlXSkgJiYgdHJhbnNpdGlvbk5hbWUgJiYgcHJvcHNbdHJhbnNpdGlvbk1hcFthbmltYXRpb25UeXBlXV0pIHtcbiAgICAgIHRoaXMuc3RvcHBlciA9ICgwLCBfY3NzQW5pbWF0aW9uMlsnZGVmYXVsdCddKShub2RlLCB0cmFuc2l0aW9uTmFtZSArICctJyArIGFuaW1hdGlvblR5cGUsIGVuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RvcHBlciA9IHByb3BzLmFuaW1hdGlvblthbmltYXRpb25UeXBlXShub2RlLCBlbmQpO1xuICAgIH1cbiAgfSxcblxuICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgIHZhciBzdG9wcGVyID0gdGhpcy5zdG9wcGVyO1xuICAgIGlmIChzdG9wcGVyKSB7XG4gICAgICB0aGlzLnN0b3BwZXIgPSBudWxsO1xuICAgICAgc3RvcHBlci5zdG9wKCk7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICB9XG59KTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gQW5pbWF0ZUNoaWxkO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmMtdGltZS1waWNrZXIvfi9yYy10cmlnZ2VyL34vcmMtYW5pbWF0ZS9saWIvQW5pbWF0ZUNoaWxkLmpzXG4gKiogbW9kdWxlIGlkID0gMTI4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfRXZlbnQgPSByZXF1aXJlKCcuL0V2ZW50Jyk7XG5cbnZhciBfRXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRXZlbnQpO1xuXG52YXIgX2NvbXBvbmVudENsYXNzZXMgPSByZXF1aXJlKCdjb21wb25lbnQtY2xhc3NlcycpO1xuXG52YXIgX2NvbXBvbmVudENsYXNzZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9uZW50Q2xhc3Nlcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG52YXIgaXNDc3NBbmltYXRpb25TdXBwb3J0ZWQgPSBfRXZlbnQyW1wiZGVmYXVsdFwiXS5lbmRFdmVudHMubGVuZ3RoICE9PSAwO1xuXG5cbnZhciBjYXBpdGFsUHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnTycsXG4vLyBtcyBpcyBzcGVjaWFsIC4uLi4gIVxuJ21zJ107XG52YXIgcHJlZml4ZXMgPSBbJy13ZWJraXQtJywgJy1tb3otJywgJy1vLScsICdtcy0nLCAnJ107XG5cbmZ1bmN0aW9uIGdldER1cmF0aW9uKG5vZGUsIG5hbWUpIHtcbiAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cbiAgdmFyIHJldCA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmV0ID0gc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcmVmaXhlc1tpXSArIG5hbWUpO1xuICAgIGlmIChyZXQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBmaXhCcm93c2VyQnlUaW1lb3V0KG5vZGUpIHtcbiAgaWYgKGlzQ3NzQW5pbWF0aW9uU3VwcG9ydGVkKSB7XG4gICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IHBhcnNlRmxvYXQoZ2V0RHVyYXRpb24obm9kZSwgJ3RyYW5zaXRpb24tZHVyYXRpb24nKSkgfHwgMDtcbiAgICB2YXIgYW5pbWF0aW9uRHVyYXRpb24gPSBwYXJzZUZsb2F0KGdldER1cmF0aW9uKG5vZGUsICdhbmltYXRpb24tZHVyYXRpb24nKSkgfHwgMDtcbiAgICB2YXIgdGltZSA9IE1hdGgubWF4KHRyYW5zaXRpb25EdXJhdGlvbiwgYW5pbWF0aW9uRHVyYXRpb24pO1xuICAgIC8vIHNvbWV0aW1lcywgYnJvd3NlciBidWdcbiAgICBub2RlLnJjRW5kQW5pbVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIG5vZGUucmNFbmRBbmltVGltZW91dCA9IG51bGw7XG4gICAgICBpZiAobm9kZS5yY0VuZExpc3RlbmVyKSB7XG4gICAgICAgIG5vZGUucmNFbmRMaXN0ZW5lcigpO1xuICAgICAgfVxuICAgIH0sIHRpbWUgKiAxMDAwICsgMjAwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhckJyb3dzZXJCdWdUaW1lb3V0KG5vZGUpIHtcbiAgaWYgKG5vZGUucmNFbmRBbmltVGltZW91dCkge1xuICAgIGNsZWFyVGltZW91dChub2RlLnJjRW5kQW5pbVRpbWVvdXQpO1xuICAgIG5vZGUucmNFbmRBbmltVGltZW91dCA9IG51bGw7XG4gIH1cbn1cblxudmFyIGNzc0FuaW1hdGlvbiA9IGZ1bmN0aW9uIGNzc0FuaW1hdGlvbihub2RlLCB0cmFuc2l0aW9uTmFtZSwgZW5kQ2FsbGJhY2spIHtcbiAgdmFyIGNsYXNzTmFtZSA9IHRyYW5zaXRpb25OYW1lO1xuICB2YXIgYWN0aXZlQ2xhc3NOYW1lID0gY2xhc3NOYW1lICsgJy1hY3RpdmUnO1xuICB2YXIgZW5kID0gZW5kQ2FsbGJhY2s7XG4gIHZhciBzdGFydCA9IHZvaWQgMDtcbiAgdmFyIGFjdGl2ZSA9IHZvaWQgMDtcbiAgdmFyIG5vZGVDbGFzc2VzID0gKDAsIF9jb21wb25lbnRDbGFzc2VzMltcImRlZmF1bHRcIl0pKG5vZGUpO1xuXG4gIGlmIChlbmRDYWxsYmFjayAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZW5kQ2FsbGJhY2spID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIGVuZCA9IGVuZENhbGxiYWNrLmVuZDtcbiAgICBzdGFydCA9IGVuZENhbGxiYWNrLnN0YXJ0O1xuICAgIGFjdGl2ZSA9IGVuZENhbGxiYWNrLmFjdGl2ZTtcbiAgfVxuXG4gIGlmIChub2RlLnJjRW5kTGlzdGVuZXIpIHtcbiAgICBub2RlLnJjRW5kTGlzdGVuZXIoKTtcbiAgfVxuXG4gIG5vZGUucmNFbmRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUgJiYgZS50YXJnZXQgIT09IG5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5yY0FuaW1UaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQobm9kZS5yY0FuaW1UaW1lb3V0KTtcbiAgICAgIG5vZGUucmNBbmltVGltZW91dCA9IG51bGw7XG4gICAgfVxuXG4gICAgY2xlYXJCcm93c2VyQnVnVGltZW91dChub2RlKTtcblxuICAgIG5vZGVDbGFzc2VzLnJlbW92ZShjbGFzc05hbWUpO1xuICAgIG5vZGVDbGFzc2VzLnJlbW92ZShhY3RpdmVDbGFzc05hbWUpO1xuXG4gICAgX0V2ZW50MltcImRlZmF1bHRcIl0ucmVtb3ZlRW5kRXZlbnRMaXN0ZW5lcihub2RlLCBub2RlLnJjRW5kTGlzdGVuZXIpO1xuICAgIG5vZGUucmNFbmRMaXN0ZW5lciA9IG51bGw7XG5cbiAgICAvLyBVc3VhbGx5IHRoaXMgb3B0aW9uYWwgZW5kIGlzIHVzZWQgZm9yIGluZm9ybWluZyBhbiBvd25lciBvZlxuICAgIC8vIGEgbGVhdmUgYW5pbWF0aW9uIGFuZCB0ZWxsaW5nIGl0IHRvIHJlbW92ZSB0aGUgY2hpbGQuXG4gICAgaWYgKGVuZCkge1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9O1xuXG4gIF9FdmVudDJbXCJkZWZhdWx0XCJdLmFkZEVuZEV2ZW50TGlzdGVuZXIobm9kZSwgbm9kZS5yY0VuZExpc3RlbmVyKTtcblxuICBub2RlQ2xhc3Nlcy5hZGQoY2xhc3NOYW1lKTtcblxuICBpZiAoc3RhcnQpIHtcbiAgICBzdGFydCgpO1xuICB9XG5cbiAgbm9kZS5yY0FuaW1UaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgbm9kZS5yY0FuaW1UaW1lb3V0ID0gbnVsbDtcbiAgICBub2RlQ2xhc3Nlcy5hZGQoYWN0aXZlQ2xhc3NOYW1lKTtcbiAgICBpZiAoYWN0aXZlKSB7XG4gICAgICBhY3RpdmUoKTtcbiAgICB9XG4gICAgZml4QnJvd3NlckJ5VGltZW91dChub2RlKTtcbiAgfSwgMCk7XG5cbiAgcmV0dXJuIHtcbiAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgaWYgKG5vZGUucmNFbmRMaXN0ZW5lcikge1xuICAgICAgICBub2RlLnJjRW5kTGlzdGVuZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuXG5jc3NBbmltYXRpb24uc3R5bGUgPSBmdW5jdGlvbiAobm9kZSwgc3R5bGUsIGNhbGxiYWNrKSB7XG4gIGlmIChub2RlLnJjRW5kTGlzdGVuZXIpIHtcbiAgICBub2RlLnJjRW5kTGlzdGVuZXIoKTtcbiAgfVxuXG4gIG5vZGUucmNFbmRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUgJiYgZS50YXJnZXQgIT09IG5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5yY0FuaW1UaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQobm9kZS5yY0FuaW1UaW1lb3V0KTtcbiAgICAgIG5vZGUucmNBbmltVGltZW91dCA9IG51bGw7XG4gICAgfVxuXG4gICAgY2xlYXJCcm93c2VyQnVnVGltZW91dChub2RlKTtcblxuICAgIF9FdmVudDJbXCJkZWZhdWx0XCJdLnJlbW92ZUVuZEV2ZW50TGlzdGVuZXIobm9kZSwgbm9kZS5yY0VuZExpc3RlbmVyKTtcbiAgICBub2RlLnJjRW5kTGlzdGVuZXIgPSBudWxsO1xuXG4gICAgLy8gVXN1YWxseSB0aGlzIG9wdGlvbmFsIGNhbGxiYWNrIGlzIHVzZWQgZm9yIGluZm9ybWluZyBhbiBvd25lciBvZlxuICAgIC8vIGEgbGVhdmUgYW5pbWF0aW9uIGFuZCB0ZWxsaW5nIGl0IHRvIHJlbW92ZSB0aGUgY2hpbGQuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfTtcblxuICBfRXZlbnQyW1wiZGVmYXVsdFwiXS5hZGRFbmRFdmVudExpc3RlbmVyKG5vZGUsIG5vZGUucmNFbmRMaXN0ZW5lcik7XG5cbiAgbm9kZS5yY0FuaW1UaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyBpbiBzdHlsZSkge1xuICAgICAgaWYgKHN0eWxlLmhhc093blByb3BlcnR5KHMpKSB7XG4gICAgICAgIG5vZGUuc3R5bGVbc10gPSBzdHlsZVtzXTtcbiAgICAgIH1cbiAgICB9XG4gICAgbm9kZS5yY0FuaW1UaW1lb3V0ID0gbnVsbDtcbiAgICBmaXhCcm93c2VyQnlUaW1lb3V0KG5vZGUpO1xuICB9LCAwKTtcbn07XG5cbmNzc0FuaW1hdGlvbi5zZXRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKG5vZGUsIHAsIHZhbHVlKSB7XG4gIHZhciBwcm9wZXJ0eSA9IHA7XG4gIHZhciB2ID0gdmFsdWU7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdiA9IHByb3BlcnR5O1xuICAgIHByb3BlcnR5ID0gJyc7XG4gIH1cbiAgcHJvcGVydHkgPSBwcm9wZXJ0eSB8fCAnJztcbiAgY2FwaXRhbFByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgIG5vZGUuc3R5bGVbcHJlZml4ICsgJ1RyYW5zaXRpb24nICsgcHJvcGVydHldID0gdjtcbiAgfSk7XG59O1xuXG5jc3NBbmltYXRpb24uaXNDc3NBbmltYXRpb25TdXBwb3J0ZWQgPSBpc0Nzc0FuaW1hdGlvblN1cHBvcnRlZDtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBjc3NBbmltYXRpb247XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yYy10aW1lLXBpY2tlci9+L3JjLXRyaWdnZXIvfi9yYy1hbmltYXRlL34vY3NzLWFuaW1hdGlvbi9saWIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBFVkVOVF9OQU1FX01BUCA9IHtcbiAgdHJhbnNpdGlvbmVuZDoge1xuICAgIHRyYW5zaXRpb246ICd0cmFuc2l0aW9uZW5kJyxcbiAgICBXZWJraXRUcmFuc2l0aW9uOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICAgTW96VHJhbnNpdGlvbjogJ21velRyYW5zaXRpb25FbmQnLFxuICAgIE9UcmFuc2l0aW9uOiAnb1RyYW5zaXRpb25FbmQnLFxuICAgIG1zVHJhbnNpdGlvbjogJ01TVHJhbnNpdGlvbkVuZCdcbiAgfSxcblxuICBhbmltYXRpb25lbmQ6IHtcbiAgICBhbmltYXRpb246ICdhbmltYXRpb25lbmQnLFxuICAgIFdlYmtpdEFuaW1hdGlvbjogJ3dlYmtpdEFuaW1hdGlvbkVuZCcsXG4gICAgTW96QW5pbWF0aW9uOiAnbW96QW5pbWF0aW9uRW5kJyxcbiAgICBPQW5pbWF0aW9uOiAnb0FuaW1hdGlvbkVuZCcsXG4gICAgbXNBbmltYXRpb246ICdNU0FuaW1hdGlvbkVuZCdcbiAgfVxufTtcblxudmFyIGVuZEV2ZW50cyA9IFtdO1xuXG5mdW5jdGlvbiBkZXRlY3RFdmVudHMoKSB7XG4gIHZhciB0ZXN0RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdmFyIHN0eWxlID0gdGVzdEVsLnN0eWxlO1xuXG4gIGlmICghKCdBbmltYXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuICAgIGRlbGV0ZSBFVkVOVF9OQU1FX01BUC5hbmltYXRpb25lbmQuYW5pbWF0aW9uO1xuICB9XG5cbiAgaWYgKCEoJ1RyYW5zaXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuICAgIGRlbGV0ZSBFVkVOVF9OQU1FX01BUC50cmFuc2l0aW9uZW5kLnRyYW5zaXRpb247XG4gIH1cblxuICBmb3IgKHZhciBiYXNlRXZlbnROYW1lIGluIEVWRU5UX05BTUVfTUFQKSB7XG4gICAgaWYgKEVWRU5UX05BTUVfTUFQLmhhc093blByb3BlcnR5KGJhc2VFdmVudE5hbWUpKSB7XG4gICAgICB2YXIgYmFzZUV2ZW50cyA9IEVWRU5UX05BTUVfTUFQW2Jhc2VFdmVudE5hbWVdO1xuICAgICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIGJhc2VFdmVudHMpIHtcbiAgICAgICAgaWYgKHN0eWxlTmFtZSBpbiBzdHlsZSkge1xuICAgICAgICAgIGVuZEV2ZW50cy5wdXNoKGJhc2VFdmVudHNbc3R5bGVOYW1lXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgZGV0ZWN0RXZlbnRzKCk7XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnROYW1lLCBldmVudExpc3RlbmVyKSB7XG4gIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50TGlzdGVuZXIsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudE5hbWUsIGV2ZW50TGlzdGVuZXIpIHtcbiAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnRMaXN0ZW5lciwgZmFsc2UpO1xufVxuXG52YXIgVHJhbnNpdGlvbkV2ZW50cyA9IHtcbiAgYWRkRW5kRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gYWRkRW5kRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudExpc3RlbmVyKSB7XG4gICAgaWYgKGVuZEV2ZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGV2ZW50TGlzdGVuZXIsIDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbmRFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZW5kRXZlbnQpIHtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIobm9kZSwgZW5kRXZlbnQsIGV2ZW50TGlzdGVuZXIpO1xuICAgIH0pO1xuICB9LFxuXG5cbiAgZW5kRXZlbnRzOiBlbmRFdmVudHMsXG5cbiAgcmVtb3ZlRW5kRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gcmVtb3ZlRW5kRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudExpc3RlbmVyKSB7XG4gICAgaWYgKGVuZEV2ZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZW5kRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGVuZEV2ZW50KSB7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKG5vZGUsIGVuZEV2ZW50LCBldmVudExpc3RlbmVyKTtcbiAgICB9KTtcbiAgfVxufTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBUcmFuc2l0aW9uRXZlbnRzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmMtdGltZS1waWNrZXIvfi9yYy10cmlnZ2VyL34vcmMtYW5pbWF0ZS9+L2Nzcy1hbmltYXRpb24vbGliL0V2ZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMTMwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudHJ5IHtcbiAgdmFyIGluZGV4ID0gcmVxdWlyZSgnaW5kZXhvZicpO1xufSBjYXRjaCAoZXJyKSB7XG4gIHZhciBpbmRleCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmRleG9mJyk7XG59XG5cbi8qKlxuICogV2hpdGVzcGFjZSByZWdleHAuXG4gKi9cblxudmFyIHJlID0gL1xccysvO1xuXG4vKipcbiAqIHRvU3RyaW5nIHJlZmVyZW5jZS5cbiAqL1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIFdyYXAgYGVsYCBpbiBhIGBDbGFzc0xpc3RgLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEByZXR1cm4ge0NsYXNzTGlzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlbCl7XG4gIHJldHVybiBuZXcgQ2xhc3NMaXN0KGVsKTtcbn07XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBDbGFzc0xpc3QgZm9yIGBlbGAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gQ2xhc3NMaXN0KGVsKSB7XG4gIGlmICghZWwgfHwgIWVsLm5vZGVUeXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBIERPTSBlbGVtZW50IHJlZmVyZW5jZSBpcyByZXF1aXJlZCcpO1xuICB9XG4gIHRoaXMuZWwgPSBlbDtcbiAgdGhpcy5saXN0ID0gZWwuY2xhc3NMaXN0O1xufVxuXG4vKipcbiAqIEFkZCBjbGFzcyBgbmFtZWAgaWYgbm90IGFscmVhZHkgcHJlc2VudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Q2xhc3NMaXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5DbGFzc0xpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKG5hbWUpe1xuICAvLyBjbGFzc0xpc3RcbiAgaWYgKHRoaXMubGlzdCkge1xuICAgIHRoaXMubGlzdC5hZGQobmFtZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBmYWxsYmFja1xuICB2YXIgYXJyID0gdGhpcy5hcnJheSgpO1xuICB2YXIgaSA9IGluZGV4KGFyciwgbmFtZSk7XG4gIGlmICghfmkpIGFyci5wdXNoKG5hbWUpO1xuICB0aGlzLmVsLmNsYXNzTmFtZSA9IGFyci5qb2luKCcgJyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgY2xhc3MgYG5hbWVgIHdoZW4gcHJlc2VudCwgb3JcbiAqIHBhc3MgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gcmVtb3ZlXG4gKiBhbnkgd2hpY2ggbWF0Y2guXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBuYW1lXG4gKiBAcmV0dXJuIHtDbGFzc0xpc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNsYXNzTGlzdC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24obmFtZSl7XG4gIGlmICgnW29iamVjdCBSZWdFeHBdJyA9PSB0b1N0cmluZy5jYWxsKG5hbWUpKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlTWF0Y2hpbmcobmFtZSk7XG4gIH1cblxuICAvLyBjbGFzc0xpc3RcbiAgaWYgKHRoaXMubGlzdCkge1xuICAgIHRoaXMubGlzdC5yZW1vdmUobmFtZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBmYWxsYmFja1xuICB2YXIgYXJyID0gdGhpcy5hcnJheSgpO1xuICB2YXIgaSA9IGluZGV4KGFyciwgbmFtZSk7XG4gIGlmICh+aSkgYXJyLnNwbGljZShpLCAxKTtcbiAgdGhpcy5lbC5jbGFzc05hbWUgPSBhcnIuam9pbignICcpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBjbGFzc2VzIG1hdGNoaW5nIGByZWAuXG4gKlxuICogQHBhcmFtIHtSZWdFeHB9IHJlXG4gKiBAcmV0dXJuIHtDbGFzc0xpc3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5DbGFzc0xpc3QucHJvdG90eXBlLnJlbW92ZU1hdGNoaW5nID0gZnVuY3Rpb24ocmUpe1xuICB2YXIgYXJyID0gdGhpcy5hcnJheSgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChyZS50ZXN0KGFycltpXSkpIHtcbiAgICAgIHRoaXMucmVtb3ZlKGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUb2dnbGUgY2xhc3MgYG5hbWVgLCBjYW4gZm9yY2Ugc3RhdGUgdmlhIGBmb3JjZWAuXG4gKlxuICogRm9yIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBjbGFzc0xpc3QsIGJ1dCBkbyBub3Qgc3VwcG9ydCBgZm9yY2VgIHlldCxcbiAqIHRoZSBtaXN0YWtlIHdpbGwgYmUgZGV0ZWN0ZWQgYW5kIGNvcnJlY3RlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtCb29sZWFufSBmb3JjZVxuICogQHJldHVybiB7Q2xhc3NMaXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5DbGFzc0xpc3QucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uKG5hbWUsIGZvcmNlKXtcbiAgLy8gY2xhc3NMaXN0XG4gIGlmICh0aGlzLmxpc3QpIHtcbiAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGZvcmNlKSB7XG4gICAgICBpZiAoZm9yY2UgIT09IHRoaXMubGlzdC50b2dnbGUobmFtZSwgZm9yY2UpKSB7XG4gICAgICAgIHRoaXMubGlzdC50b2dnbGUobmFtZSk7IC8vIHRvZ2dsZSBhZ2FpbiB0byBjb3JyZWN0XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGlzdC50b2dnbGUobmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZmFsbGJhY2tcbiAgaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBmb3JjZSkge1xuICAgIGlmICghZm9yY2UpIHtcbiAgICAgIHRoaXMucmVtb3ZlKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZChuYW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMuaGFzKG5hbWUpKSB7XG4gICAgICB0aGlzLnJlbW92ZShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGQobmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBvZiBjbGFzc2VzLlxuICpcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5DbGFzc0xpc3QucHJvdG90eXBlLmFycmF5ID0gZnVuY3Rpb24oKXtcbiAgdmFyIGNsYXNzTmFtZSA9IHRoaXMuZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnO1xuICB2YXIgc3RyID0gY2xhc3NOYW1lLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcbiAgdmFyIGFyciA9IHN0ci5zcGxpdChyZSk7XG4gIGlmICgnJyA9PT0gYXJyWzBdKSBhcnIuc2hpZnQoKTtcbiAgcmV0dXJuIGFycjtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgY2xhc3MgYG5hbWVgIGlzIHByZXNlbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0NsYXNzTGlzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ2xhc3NMaXN0LnByb3RvdHlwZS5oYXMgPVxuQ2xhc3NMaXN0LnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKG5hbWUpe1xuICByZXR1cm4gdGhpcy5saXN0XG4gICAgPyB0aGlzLmxpc3QuY29udGFpbnMobmFtZSlcbiAgICA6ICEhIH5pbmRleCh0aGlzLmFycmF5KCksIG5hbWUpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JjLXRpbWUtcGlja2VyL34vcmMtdHJpZ2dlci9+L3JjLWFuaW1hdGUvfi9jc3MtYW5pbWF0aW9uL34vY29tcG9uZW50LWNsYXNzZXMvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyLCBvYmope1xuICBpZiAoYXJyLmluZGV4T2YpIHJldHVybiBhcnIuaW5kZXhPZihvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgIGlmIChhcnJbaV0gPT09IG9iaikgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yYy10aW1lLXBpY2tlci9+L3JjLXRyaWdnZXIvfi9yYy1hbmltYXRlL34vY3NzLWFuaW1hdGlvbi9+L2NvbXBvbmVudC1jbGFzc2VzL34vY29tcG9uZW50LWluZGV4b2YvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX0xhenlSZW5kZXJCb3ggPSByZXF1aXJlKCcuL0xhenlSZW5kZXJCb3gnKTtcblxudmFyIF9MYXp5UmVuZGVyQm94MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0xhenlSZW5kZXJCb3gpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxudmFyIFBvcHVwSW5uZXIgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUG9wdXBJbm5lcicsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgaGlkZGVuQ2xhc3NOYW1lOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBjbGFzc05hbWU6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHByZWZpeENsczogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgb25Nb3VzZUVudGVyOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Nb3VzZUxlYXZlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgY2hpbGRyZW46IF9yZWFjdC5Qcm9wVHlwZXMuYW55XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZTtcbiAgICBpZiAoIXByb3BzLnZpc2libGUpIHtcbiAgICAgIGNsYXNzTmFtZSArPSAnICcgKyBwcm9wcy5oaWRkZW5DbGFzc05hbWU7XG4gICAgfVxuICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgJ2RpdicsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgICBvbk1vdXNlRW50ZXI6IHByb3BzLm9uTW91c2VFbnRlcixcbiAgICAgICAgb25Nb3VzZUxlYXZlOiBwcm9wcy5vbk1vdXNlTGVhdmUsXG4gICAgICAgIHN0eWxlOiBwcm9wcy5zdHlsZVxuICAgICAgfSxcbiAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIF9MYXp5UmVuZGVyQm94MltcImRlZmF1bHRcIl0sXG4gICAgICAgIHsgY2xhc3NOYW1lOiBwcm9wcy5wcmVmaXhDbHMgKyAnLWNvbnRlbnQnLCB2aXNpYmxlOiBwcm9wcy52aXNpYmxlIH0sXG4gICAgICAgIHByb3BzLmNoaWxkcmVuXG4gICAgICApXG4gICAgKTtcbiAgfVxufSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUG9wdXBJbm5lcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JjLXRpbWUtcGlja2VyL34vcmMtdHJpZ2dlci9saWIvUG9wdXBJbm5lci5qc1xuICoqIG1vZHVsZSBpZCA9IDEzNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG52YXIgTGF6eVJlbmRlckJveCA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdMYXp5UmVuZGVyQm94JyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBjaGlsZHJlbjogX3JlYWN0LlByb3BUeXBlcy5hbnksXG4gICAgY2xhc3NOYW1lOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICB2aXNpYmxlOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgaGlkZGVuQ2xhc3NOYW1lOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZ1xuICB9LFxuICBzaG91bGRDb21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMpIHtcbiAgICByZXR1cm4gbmV4dFByb3BzLmhpZGRlbkNsYXNzTmFtZSB8fCBuZXh0UHJvcHMudmlzaWJsZTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMucHJvcHMuaGlkZGVuQ2xhc3NOYW1lKSB7XG4gICAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy5wcm9wcy5jbGFzc05hbWU7XG4gICAgICBpZiAoIXRoaXMucHJvcHMudmlzaWJsZSkge1xuICAgICAgICBjbGFzc05hbWUgKz0gJyAnICsgdGhpcy5wcm9wcy5oaWRkZW5DbGFzc05hbWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudCgnZGl2JywgX2V4dGVuZHMoe30sIHRoaXMucHJvcHMsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWUgfSkpO1xuICAgIH1cbiAgICBpZiAoX3JlYWN0MltcImRlZmF1bHRcIl0uQ2hpbGRyZW4uY291bnQodGhpcy5wcm9wcy5jaGlsZHJlbikgPiAxKSB7XG4gICAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudCgnZGl2JywgdGhpcy5wcm9wcyk7XG4gICAgfVxuICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5DaGlsZHJlbi5vbmx5KHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICB9XG59KTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBMYXp5UmVuZGVyQm94O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmMtdGltZS1waWNrZXIvfi9yYy10cmlnZ2VyL2xpYi9MYXp5UmVuZGVyQm94LmpzXG4gKiogbW9kdWxlIGlkID0gMTM1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHMuZ2V0QWxpZ25Gcm9tUGxhY2VtZW50ID0gZ2V0QWxpZ25Gcm9tUGxhY2VtZW50O1xuZXhwb3J0cy5nZXRQb3B1cENsYXNzTmFtZUZyb21BbGlnbiA9IGdldFBvcHVwQ2xhc3NOYW1lRnJvbUFsaWduO1xuZnVuY3Rpb24gaXNQb2ludHNFcShhMSwgYTIpIHtcbiAgcmV0dXJuIGExWzBdID09PSBhMlswXSAmJiBhMVsxXSA9PT0gYTJbMV07XG59XG5cbmZ1bmN0aW9uIGdldEFsaWduRnJvbVBsYWNlbWVudChidWlsdGluUGxhY2VtZW50cywgcGxhY2VtZW50U3RyLCBhbGlnbikge1xuICB2YXIgYmFzZUFsaWduID0gYnVpbHRpblBsYWNlbWVudHNbcGxhY2VtZW50U3RyXSB8fCB7fTtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBiYXNlQWxpZ24sIGFsaWduKTtcbn1cblxuZnVuY3Rpb24gZ2V0UG9wdXBDbGFzc05hbWVGcm9tQWxpZ24oYnVpbHRpblBsYWNlbWVudHMsIHByZWZpeENscywgYWxpZ24pIHtcbiAgdmFyIHBvaW50cyA9IGFsaWduLnBvaW50cztcbiAgZm9yICh2YXIgcGxhY2VtZW50IGluIGJ1aWx0aW5QbGFjZW1lbnRzKSB7XG4gICAgaWYgKGJ1aWx0aW5QbGFjZW1lbnRzLmhhc093blByb3BlcnR5KHBsYWNlbWVudCkpIHtcbiAgICAgIGlmIChpc1BvaW50c0VxKGJ1aWx0aW5QbGFjZW1lbnRzW3BsYWNlbWVudF0ucG9pbnRzLCBwb2ludHMpKSB7XG4gICAgICAgIHJldHVybiBwcmVmaXhDbHMgKyAnLXBsYWNlbWVudC0nICsgcGxhY2VtZW50O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmMtdGltZS1waWNrZXIvfi9yYy10cmlnZ2VyL2xpYi91dGlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDEzNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfbWl4aW5Db21tb25NaXhpbiA9IHJlcXVpcmUoJy4uL21peGluL0NvbW1vbk1peGluJyk7XG5cbnZhciBfbWl4aW5Db21tb25NaXhpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9taXhpbkNvbW1vbk1peGluKTtcblxudmFyIF9IZWFkZXIgPSByZXF1aXJlKCcuL0hlYWRlcicpO1xuXG52YXIgX0hlYWRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9IZWFkZXIpO1xuXG52YXIgX0NvbWJvYm94ID0gcmVxdWlyZSgnLi9Db21ib2JveCcpO1xuXG52YXIgX0NvbWJvYm94MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NvbWJvYm94KTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGdlbmVyYXRlT3B0aW9ucyhsZW5ndGgsIGRpc2FibGVkT3B0aW9ucywgaGlkZURpc2FibGVkT3B0aW9ucykge1xuICB2YXIgYXJyID0gW107XG4gIGZvciAodmFyIHZhbHVlID0gMDsgdmFsdWUgPCBsZW5ndGg7IHZhbHVlKyspIHtcbiAgICBpZiAoIWRpc2FibGVkT3B0aW9ucyB8fCBkaXNhYmxlZE9wdGlvbnMuaW5kZXhPZih2YWx1ZSkgPCAwIHx8ICFoaWRlRGlzYWJsZWRPcHRpb25zKSB7XG4gICAgICBhcnIucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbnZhciBQYW5lbCA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUGFuZWwnLFxuXG4gIHByb3BUeXBlczoge1xuICAgIHByZWZpeENsczogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgdmFsdWU6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIGxvY2FsZTogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgcGxhY2Vob2xkZXI6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGdyZWdvcmlhbkNhbGVuZGFyTG9jYWxlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBmb3JtYXR0ZXI6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIGRpc2FibGVkSG91cnM6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBkaXNhYmxlZE1pbnV0ZXM6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBkaXNhYmxlZFNlY29uZHM6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBoaWRlRGlzYWJsZWRPcHRpb25zOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgb25DaGFuZ2U6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkVzYzogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIGFsbG93RW1wdHk6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBzaG93SG91cjogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIHNob3dTZWNvbmQ6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBvbkNsZWFyOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmNcbiAgfSxcblxuICBtaXhpbnM6IFtfbWl4aW5Db21tb25NaXhpbjJbJ2RlZmF1bHQnXV0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiBnZXREZWZhdWx0UHJvcHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uQ2hhbmdlOiBub29wLFxuICAgICAgb25DbGVhcjogbm9vcFxuICAgIH07XG4gIH0sXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiB0aGlzLnByb3BzLnZhbHVlLFxuICAgICAgc2VsZWN0aW9uUmFuZ2U6IFtdXG4gICAgfTtcbiAgfSxcblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIHZhciB2YWx1ZSA9IG5leHRQcm9wcy52YWx1ZTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UobmV3VmFsdWUpIHtcbiAgICB0aGlzLnNldFN0YXRlKHsgdmFsdWU6IG5ld1ZhbHVlIH0pO1xuICAgIHRoaXMucHJvcHMub25DaGFuZ2UobmV3VmFsdWUpO1xuICB9LFxuXG4gIG9uQ2xlYXI6IGZ1bmN0aW9uIG9uQ2xlYXIoKSB7XG4gICAgdGhpcy5wcm9wcy5vbkNsZWFyKCk7XG4gIH0sXG5cbiAgb25DdXJyZW50U2VsZWN0UGFuZWxDaGFuZ2U6IGZ1bmN0aW9uIG9uQ3VycmVudFNlbGVjdFBhbmVsQ2hhbmdlKGN1cnJlbnRTZWxlY3RQYW5lbCkge1xuICAgIHRoaXMuc2V0U3RhdGUoeyBjdXJyZW50U2VsZWN0UGFuZWw6IGN1cnJlbnRTZWxlY3RQYW5lbCB9KTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgbG9jYWxlID0gX3Byb3BzLmxvY2FsZTtcbiAgICB2YXIgcHJlZml4Q2xzID0gX3Byb3BzLnByZWZpeENscztcbiAgICB2YXIgcGxhY2Vob2xkZXIgPSBfcHJvcHMucGxhY2Vob2xkZXI7XG4gICAgdmFyIGRpc2FibGVkSG91cnMgPSBfcHJvcHMuZGlzYWJsZWRIb3VycztcbiAgICB2YXIgZGlzYWJsZWRNaW51dGVzID0gX3Byb3BzLmRpc2FibGVkTWludXRlcztcbiAgICB2YXIgZGlzYWJsZWRTZWNvbmRzID0gX3Byb3BzLmRpc2FibGVkU2Vjb25kcztcbiAgICB2YXIgaGlkZURpc2FibGVkT3B0aW9ucyA9IF9wcm9wcy5oaWRlRGlzYWJsZWRPcHRpb25zO1xuICAgIHZhciBhbGxvd0VtcHR5ID0gX3Byb3BzLmFsbG93RW1wdHk7XG4gICAgdmFyIHNob3dIb3VyID0gX3Byb3BzLnNob3dIb3VyO1xuICAgIHZhciBzaG93U2Vjb25kID0gX3Byb3BzLnNob3dTZWNvbmQ7XG4gICAgdmFyIGZvcm1hdHRlciA9IF9wcm9wcy5mb3JtYXR0ZXI7XG4gICAgdmFyIGdyZWdvcmlhbkNhbGVuZGFyTG9jYWxlID0gX3Byb3BzLmdyZWdvcmlhbkNhbGVuZGFyTG9jYWxlO1xuXG4gICAgdmFyIHZhbHVlID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICB2YXIgZGlzYWJsZWRIb3VyT3B0aW9ucyA9IGRpc2FibGVkSG91cnMoKTtcbiAgICB2YXIgZGlzYWJsZWRNaW51dGVPcHRpb25zID0gZGlzYWJsZWRNaW51dGVzKHZhbHVlID8gdmFsdWUuZ2V0SG91ck9mRGF5KCkgOiBudWxsKTtcbiAgICB2YXIgZGlzYWJsZWRTZWNvbmRPcHRpb25zID0gZGlzYWJsZWRTZWNvbmRzKHZhbHVlID8gdmFsdWUuZ2V0SG91ck9mRGF5KCkgOiBudWxsLCB2YWx1ZSA/IHZhbHVlLmdldE1pbnV0ZXMoKSA6IG51bGwpO1xuICAgIHZhciBob3VyT3B0aW9ucyA9IGdlbmVyYXRlT3B0aW9ucygyNCwgZGlzYWJsZWRIb3VyT3B0aW9ucywgaGlkZURpc2FibGVkT3B0aW9ucyk7XG4gICAgdmFyIG1pbnV0ZU9wdGlvbnMgPSBnZW5lcmF0ZU9wdGlvbnMoNjAsIGRpc2FibGVkTWludXRlT3B0aW9ucywgaGlkZURpc2FibGVkT3B0aW9ucyk7XG4gICAgdmFyIHNlY29uZE9wdGlvbnMgPSBnZW5lcmF0ZU9wdGlvbnMoNjAsIGRpc2FibGVkU2Vjb25kT3B0aW9ucywgaGlkZURpc2FibGVkT3B0aW9ucyk7XG5cbiAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnZGl2JyxcbiAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWlubmVyJyB9LFxuICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoX0hlYWRlcjJbJ2RlZmF1bHQnXSwge1xuICAgICAgICBwcmVmaXhDbHM6IHByZWZpeENscyxcbiAgICAgICAgZ3JlZ29yaWFuQ2FsZW5kYXJMb2NhbGU6IGdyZWdvcmlhbkNhbGVuZGFyTG9jYWxlLFxuICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBjdXJyZW50U2VsZWN0UGFuZWw6IHRoaXMuc3RhdGUuY3VycmVudFNlbGVjdFBhbmVsLFxuICAgICAgICBvbkVzYzogdGhpcy5wcm9wcy5vbkVzYyxcbiAgICAgICAgZm9ybWF0dGVyOiBmb3JtYXR0ZXIsXG4gICAgICAgIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlcixcbiAgICAgICAgaG91ck9wdGlvbnM6IGhvdXJPcHRpb25zLFxuICAgICAgICBtaW51dGVPcHRpb25zOiBtaW51dGVPcHRpb25zLFxuICAgICAgICBzZWNvbmRPcHRpb25zOiBzZWNvbmRPcHRpb25zLFxuICAgICAgICBkaXNhYmxlZEhvdXJzOiBkaXNhYmxlZEhvdXJzLFxuICAgICAgICBkaXNhYmxlZE1pbnV0ZXM6IGRpc2FibGVkTWludXRlcyxcbiAgICAgICAgZGlzYWJsZWRTZWNvbmRzOiBkaXNhYmxlZFNlY29uZHMsXG4gICAgICAgIG9uQ2hhbmdlOiB0aGlzLm9uQ2hhbmdlLFxuICAgICAgICBvbkNsZWFyOiB0aGlzLm9uQ2xlYXIsXG4gICAgICAgIGFsbG93RW1wdHk6IGFsbG93RW1wdHlcbiAgICAgIH0pLFxuICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoX0NvbWJvYm94MlsnZGVmYXVsdCddLCB7XG4gICAgICAgIHByZWZpeENsczogcHJlZml4Q2xzLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGdyZWdvcmlhbkNhbGVuZGFyTG9jYWxlOiBncmVnb3JpYW5DYWxlbmRhckxvY2FsZSxcbiAgICAgICAgZm9ybWF0dGVyOiBmb3JtYXR0ZXIsXG4gICAgICAgIG9uQ2hhbmdlOiB0aGlzLm9uQ2hhbmdlLFxuICAgICAgICBzaG93SG91cjogc2hvd0hvdXIsXG4gICAgICAgIHNob3dTZWNvbmQ6IHNob3dTZWNvbmQsXG4gICAgICAgIGhvdXJPcHRpb25zOiBob3VyT3B0aW9ucyxcbiAgICAgICAgbWludXRlT3B0aW9uczogbWludXRlT3B0aW9ucyxcbiAgICAgICAgc2Vjb25kT3B0aW9uczogc2Vjb25kT3B0aW9ucyxcbiAgICAgICAgZGlzYWJsZWRIb3VyczogZGlzYWJsZWRIb3VycyxcbiAgICAgICAgZGlzYWJsZWRNaW51dGVzOiBkaXNhYmxlZE1pbnV0ZXMsXG4gICAgICAgIGRpc2FibGVkU2Vjb25kczogZGlzYWJsZWRTZWNvbmRzLFxuICAgICAgICBvbkN1cnJlbnRTZWxlY3RQYW5lbENoYW5nZTogdGhpcy5vbkN1cnJlbnRTZWxlY3RQYW5lbENoYW5nZVxuICAgICAgfSlcbiAgICApO1xuICB9XG59KTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gUGFuZWw7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yYy10aW1lLXBpY2tlci9saWIvbW9kdWxlL1BhbmVsLmpzXG4gKiogbW9kdWxlIGlkID0gMTM3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX2xvY2FsZUVuX1VTID0gcmVxdWlyZSgnLi4vbG9jYWxlL2VuX1VTJyk7XG5cbnZhciBfbG9jYWxlRW5fVVMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbG9jYWxlRW5fVVMpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSB7XG4gIHByb3BUeXBlczoge1xuICAgIHByZWZpeENsczogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgbG9jYWxlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdFxuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwcmVmaXhDbHM6ICdyYy10aW1lLXBpY2tlcicsXG4gICAgICBsb2NhbGU6IF9sb2NhbGVFbl9VUzJbJ2RlZmF1bHQnXVxuICAgIH07XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yYy10aW1lLXBpY2tlci9saWIvbWl4aW4vQ29tbW9uTWl4aW4uanNcbiAqKiBtb2R1bGUgaWQgPSAxMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9ncmVnb3JpYW5DYWxlbmRhckZvcm1hdExpYkxvY2FsZUVuX1VTID0gcmVxdWlyZSgnZ3JlZ29yaWFuLWNhbGVuZGFyLWZvcm1hdC9saWIvbG9jYWxlL2VuX1VTJyk7XG5cbnZhciBfZ3JlZ29yaWFuQ2FsZW5kYXJGb3JtYXRMaWJMb2NhbGVFbl9VUzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ncmVnb3JpYW5DYWxlbmRhckZvcm1hdExpYkxvY2FsZUVuX1VTKTtcblxudmFyIF9ncmVnb3JpYW5DYWxlbmRhckxpYkxvY2FsZUVuX1VTID0gcmVxdWlyZSgnZ3JlZ29yaWFuLWNhbGVuZGFyL2xpYi9sb2NhbGUvZW5fVVMnKTtcblxudmFyIF9ncmVnb3JpYW5DYWxlbmRhckxpYkxvY2FsZUVuX1VTMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dyZWdvcmlhbkNhbGVuZGFyTGliTG9jYWxlRW5fVVMpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSB7XG4gIGNsZWFyOiAnQ2xlYXInLFxuICBmb3JtYXQ6IF9ncmVnb3JpYW5DYWxlbmRhckZvcm1hdExpYkxvY2FsZUVuX1VTMlsnZGVmYXVsdCddLFxuICBjYWxlbmRhcjogX2dyZWdvcmlhbkNhbGVuZGFyTGliTG9jYWxlRW5fVVMyWydkZWZhdWx0J11cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yYy10aW1lLXBpY2tlci9saWIvbG9jYWxlL2VuX1VTLmpzXG4gKiogbW9kdWxlIGlkID0gMTM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF91dGlsU2VsZWN0aW9uID0gcmVxdWlyZSgnLi4vdXRpbC9zZWxlY3Rpb24nKTtcblxudmFyIF91dGlsU2VsZWN0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWxTZWxlY3Rpb24pO1xuXG52YXIgSGVhZGVyID0gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdIZWFkZXInLFxuXG4gIHByb3BUeXBlczoge1xuICAgIGZvcm1hdHRlcjogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgcHJlZml4Q2xzOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBncmVnb3JpYW5DYWxlbmRhckxvY2FsZTogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgbG9jYWxlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBkaXNhYmxlZERhdGU6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBwbGFjZWhvbGRlcjogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgdmFsdWU6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIGhvdXJPcHRpb25zOiBfcmVhY3QuUHJvcFR5cGVzLmFycmF5LFxuICAgIG1pbnV0ZU9wdGlvbnM6IF9yZWFjdC5Qcm9wVHlwZXMuYXJyYXksXG4gICAgc2Vjb25kT3B0aW9uczogX3JlYWN0LlByb3BUeXBlcy5hcnJheSxcbiAgICBkaXNhYmxlZEhvdXJzOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgZGlzYWJsZWRNaW51dGVzOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgZGlzYWJsZWRTZWNvbmRzOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25DaGFuZ2U6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNsZWFyOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Fc2M6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBhbGxvd0VtcHR5OiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgY3VycmVudFNlbGVjdFBhbmVsOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZ1xuICB9LFxuXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMucHJvcHMudmFsdWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0cjogdmFsdWUgJiYgdGhpcy5wcm9wcy5mb3JtYXR0ZXIuZm9ybWF0KHZhbHVlKSB8fCAnJyxcbiAgICAgIGludmFsaWQ6IGZhbHNlXG4gICAgfTtcbiAgfSxcblxuICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQodGhpcy5zZWxlY3RSYW5nZSwgMCk7XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICB2YXIgdmFsdWUgPSBuZXh0UHJvcHMudmFsdWU7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBzdHI6IHZhbHVlICYmIG5leHRQcm9wcy5mb3JtYXR0ZXIuZm9ybWF0KHZhbHVlKSB8fCAnJyxcbiAgICAgIGludmFsaWQ6IGZhbHNlXG4gICAgfSk7XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkVXBkYXRlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQodGhpcy5zZWxlY3RSYW5nZSwgMCk7XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgfSxcblxuICBvbklucHV0Q2hhbmdlOiBmdW5jdGlvbiBvbklucHV0Q2hhbmdlKGV2ZW50KSB7XG4gICAgdmFyIHN0ciA9IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHN0cjogc3RyXG4gICAgfSk7XG4gICAgdmFyIHZhbHVlID0gbnVsbDtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgZm9ybWF0dGVyID0gX3Byb3BzLmZvcm1hdHRlcjtcbiAgICB2YXIgZ3JlZ29yaWFuQ2FsZW5kYXJMb2NhbGUgPSBfcHJvcHMuZ3JlZ29yaWFuQ2FsZW5kYXJMb2NhbGU7XG4gICAgdmFyIGhvdXJPcHRpb25zID0gX3Byb3BzLmhvdXJPcHRpb25zO1xuICAgIHZhciBtaW51dGVPcHRpb25zID0gX3Byb3BzLm1pbnV0ZU9wdGlvbnM7XG4gICAgdmFyIHNlY29uZE9wdGlvbnMgPSBfcHJvcHMuc2Vjb25kT3B0aW9ucztcbiAgICB2YXIgZGlzYWJsZWRIb3VycyA9IF9wcm9wcy5kaXNhYmxlZEhvdXJzO1xuICAgIHZhciBkaXNhYmxlZE1pbnV0ZXMgPSBfcHJvcHMuZGlzYWJsZWRNaW51dGVzO1xuICAgIHZhciBkaXNhYmxlZFNlY29uZHMgPSBfcHJvcHMuZGlzYWJsZWRTZWNvbmRzO1xuICAgIHZhciBvbkNoYW5nZSA9IF9wcm9wcy5vbkNoYW5nZTtcbiAgICB2YXIgYWxsb3dFbXB0eSA9IF9wcm9wcy5hbGxvd0VtcHR5O1xuXG4gICAgaWYgKHN0cikge1xuICAgICAgdmFyIG9yaWdpbmFsVmFsdWUgPSB0aGlzLnByb3BzLnZhbHVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFsdWUgPSBmb3JtYXR0ZXIucGFyc2Uoc3RyLCB7XG4gICAgICAgICAgbG9jYWxlOiBncmVnb3JpYW5DYWxlbmRhckxvY2FsZSxcbiAgICAgICAgICBvYmV5Q291bnQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBpbnZhbGlkOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAvLyBpZiB0aW1lIHZhbHVlIG5vdCBhbGxvd2VkLCByZXNwb25zZSB3YXJuaW5nLlxuICAgICAgICBpZiAoaG91ck9wdGlvbnMuaW5kZXhPZih2YWx1ZS5nZXRIb3VyT2ZEYXkoKSkgPCAwIHx8IG1pbnV0ZU9wdGlvbnMuaW5kZXhPZih2YWx1ZS5nZXRNaW51dGVzKCkpIDwgMCB8fCBzZWNvbmRPcHRpb25zLmluZGV4T2YodmFsdWUuZ2V0U2Vjb25kcygpKSA8IDApIHtcbiAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGludmFsaWQ6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aW1lIHZhbHVlIGlzIGRpc2FibGVkLCByZXNwb25zZSB3YXJuaW5nLlxuICAgICAgICB2YXIgZGlzYWJsZWRIb3VyT3B0aW9ucyA9IGRpc2FibGVkSG91cnMoKTtcbiAgICAgICAgdmFyIGRpc2FibGVkTWludXRlT3B0aW9ucyA9IGRpc2FibGVkTWludXRlcyh2YWx1ZS5nZXRIb3VyT2ZEYXkoKSk7XG4gICAgICAgIHZhciBkaXNhYmxlZFNlY29uZE9wdGlvbnMgPSBkaXNhYmxlZFNlY29uZHModmFsdWUuZ2V0SG91ck9mRGF5KCksIHZhbHVlLmdldE1pbnV0ZXMoKSk7XG4gICAgICAgIGlmIChkaXNhYmxlZEhvdXJPcHRpb25zICYmIGRpc2FibGVkSG91ck9wdGlvbnMuaW5kZXhPZih2YWx1ZS5nZXRIb3VyT2ZEYXkoKSkgPj0gMCB8fCBkaXNhYmxlZE1pbnV0ZU9wdGlvbnMgJiYgZGlzYWJsZWRNaW51dGVPcHRpb25zLmluZGV4T2YodmFsdWUuZ2V0TWludXRlcygpKSA+PSAwIHx8IGRpc2FibGVkU2Vjb25kT3B0aW9ucyAmJiBkaXNhYmxlZFNlY29uZE9wdGlvbnMuaW5kZXhPZih2YWx1ZS5nZXRTZWNvbmRzKCkpID49IDApIHtcbiAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGludmFsaWQ6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3JpZ2luYWxWYWx1ZSAmJiB2YWx1ZSkge1xuICAgICAgICAgIGlmIChvcmlnaW5hbFZhbHVlLmdldEhvdXJPZkRheSgpICE9PSB2YWx1ZS5nZXRIb3VyT2ZEYXkoKSB8fCBvcmlnaW5hbFZhbHVlLmdldE1pbnV0ZXMoKSAhPT0gdmFsdWUuZ2V0TWludXRlcygpIHx8IG9yaWdpbmFsVmFsdWUuZ2V0U2Vjb25kcygpICE9PSB2YWx1ZS5nZXRTZWNvbmRzKCkpIHtcbiAgICAgICAgICAgIC8vIGtlZXAgb3RoZXIgZmllbGRzIGZvciByYy1jYWxlbmRhclxuICAgICAgICAgICAgdmFyIGNoYW5nZWRWYWx1ZSA9IG9yaWdpbmFsVmFsdWUuY2xvbmUoKTtcbiAgICAgICAgICAgIGNoYW5nZWRWYWx1ZS5zZXRIb3VyT2ZEYXkodmFsdWUuZ2V0SG91ck9mRGF5KCkpO1xuICAgICAgICAgICAgY2hhbmdlZFZhbHVlLnNldE1pbnV0ZXModmFsdWUuZ2V0TWludXRlcygpKTtcbiAgICAgICAgICAgIGNoYW5nZWRWYWx1ZS5zZXRTZWNvbmRzKHZhbHVlLmdldFNlY29uZHMoKSk7XG4gICAgICAgICAgICBvbkNoYW5nZShjaGFuZ2VkVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvcmlnaW5hbFZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgIG9uQ2hhbmdlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgaW52YWxpZDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYWxsb3dFbXB0eSkge1xuICAgICAgb25DaGFuZ2UobnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpbnZhbGlkOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGludmFsaWQ6IGZhbHNlXG4gICAgfSk7XG4gIH0sXG5cbiAgb25LZXlEb3duOiBmdW5jdGlvbiBvbktleURvd24oZSkge1xuICAgIGlmIChlLmtleUNvZGUgPT09IDI3KSB7XG4gICAgICB0aGlzLnByb3BzLm9uRXNjKCk7XG4gICAgfVxuICB9LFxuXG4gIG9uQ2xlYXI6IGZ1bmN0aW9uIG9uQ2xlYXIoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IHN0cjogJycgfSk7XG4gICAgdGhpcy5wcm9wcy5vbkNsZWFyKCk7XG4gIH0sXG5cbiAgZ2V0Q2xlYXJCdXR0b246IGZ1bmN0aW9uIGdldENsZWFyQnV0dG9uKCkge1xuICAgIHZhciBfcHJvcHMyID0gdGhpcy5wcm9wcztcbiAgICB2YXIgbG9jYWxlID0gX3Byb3BzMi5sb2NhbGU7XG4gICAgdmFyIHByZWZpeENscyA9IF9wcm9wczIucHJlZml4Q2xzO1xuICAgIHZhciBhbGxvd0VtcHR5ID0gX3Byb3BzMi5hbGxvd0VtcHR5O1xuXG4gICAgaWYgKCFhbGxvd0VtcHR5KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KCdhJywgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctY2xlYXItYnRuJywgcm9sZTogJ2J1dHRvbicsIHRpdGxlOiBsb2NhbGUuY2xlYXIsIG9uTW91c2VEb3duOiB0aGlzLm9uQ2xlYXIgfSk7XG4gIH0sXG5cbiAgZ2V0SW5wdXQ6IGZ1bmN0aW9uIGdldElucHV0KCkge1xuICAgIHZhciBfcHJvcHMzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcHJlZml4Q2xzID0gX3Byb3BzMy5wcmVmaXhDbHM7XG4gICAgdmFyIHBsYWNlaG9sZGVyID0gX3Byb3BzMy5wbGFjZWhvbGRlcjtcbiAgICB2YXIgX3N0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgaW52YWxpZCA9IF9zdGF0ZS5pbnZhbGlkO1xuICAgIHZhciBzdHIgPSBfc3RhdGUuc3RyO1xuXG4gICAgdmFyIGludmFsaWRDbGFzcyA9IGludmFsaWQgPyBwcmVmaXhDbHMgKyAnLWlucHV0LWludmFsaWQnIDogJyc7XG4gICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KCdpbnB1dCcsIHtcbiAgICAgIGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1pbnB1dCAgJyArIGludmFsaWRDbGFzcyxcbiAgICAgIHJlZjogJ2lucHV0JyxcbiAgICAgIG9uS2V5RG93bjogdGhpcy5vbktleURvd24sXG4gICAgICB2YWx1ZTogc3RyLFxuICAgICAgcGxhY2Vob2xkZXI6IHBsYWNlaG9sZGVyLCBvbkNoYW5nZTogdGhpcy5vbklucHV0Q2hhbmdlXG4gICAgfSk7XG4gIH0sXG5cbiAgc2VsZWN0UmFuZ2U6IGZ1bmN0aW9uIHNlbGVjdFJhbmdlKCkge1xuICAgIHRoaXMucmVmcy5pbnB1dC5mb2N1cygpO1xuICAgIGlmICh0aGlzLnByb3BzLmN1cnJlbnRTZWxlY3RQYW5lbCAmJiB0aGlzLnJlZnMuaW5wdXQudmFsdWUpIHtcbiAgICAgIHZhciBzZWxlY3Rpb25SYW5nZVN0YXJ0ID0gMDtcbiAgICAgIHZhciBzZWxlY3Rpb25SYW5nZUVuZCA9IDA7XG4gICAgICBpZiAodGhpcy5wcm9wcy5jdXJyZW50U2VsZWN0UGFuZWwgPT09ICdob3VyJykge1xuICAgICAgICBzZWxlY3Rpb25SYW5nZVN0YXJ0ID0gMDtcbiAgICAgICAgc2VsZWN0aW9uUmFuZ2VFbmQgPSB0aGlzLnJlZnMuaW5wdXQudmFsdWUuaW5kZXhPZignOicpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnByb3BzLmN1cnJlbnRTZWxlY3RQYW5lbCA9PT0gJ21pbnV0ZScpIHtcbiAgICAgICAgc2VsZWN0aW9uUmFuZ2VTdGFydCA9IHRoaXMucmVmcy5pbnB1dC52YWx1ZS5pbmRleE9mKCc6JykgKyAxO1xuICAgICAgICBzZWxlY3Rpb25SYW5nZUVuZCA9IHRoaXMucmVmcy5pbnB1dC52YWx1ZS5sYXN0SW5kZXhPZignOicpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnByb3BzLmN1cnJlbnRTZWxlY3RQYW5lbCA9PT0gJ3NlY29uZCcpIHtcbiAgICAgICAgc2VsZWN0aW9uUmFuZ2VTdGFydCA9IHRoaXMucmVmcy5pbnB1dC52YWx1ZS5sYXN0SW5kZXhPZignOicpICsgMTtcbiAgICAgICAgc2VsZWN0aW9uUmFuZ2VFbmQgPSB0aGlzLnJlZnMuaW5wdXQudmFsdWUubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdGlvblJhbmdlRW5kIC0gc2VsZWN0aW9uUmFuZ2VTdGFydCA9PT0gMikge1xuICAgICAgICAoMCwgX3V0aWxTZWxlY3Rpb24yWydkZWZhdWx0J10pKHRoaXMucmVmcy5pbnB1dCwgc2VsZWN0aW9uUmFuZ2VTdGFydCwgc2VsZWN0aW9uUmFuZ2VFbmQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgcHJlZml4Q2xzID0gdGhpcy5wcm9wcy5wcmVmaXhDbHM7XG5cbiAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnZGl2JyxcbiAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWlucHV0LXdyYXAnIH0sXG4gICAgICB0aGlzLmdldElucHV0KCksXG4gICAgICB0aGlzLmdldENsZWFyQnV0dG9uKClcbiAgICApO1xuICB9XG59KTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gSGVhZGVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmMtdGltZS1waWNrZXIvbGliL21vZHVsZS9IZWFkZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzWydkZWZhdWx0J10gPSBjcmVhdGVTZWxlY3Rpb247XG5cbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdGlvbihmaWVsZCwgc3RhcnQsIGVuZCkge1xuICBpZiAoZmllbGQuY3JlYXRlVGV4dFJhbmdlKSB7XG4gICAgdmFyIHNlbFJhbmdlID0gZmllbGQuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgc2VsUmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG4gICAgc2VsUmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBzdGFydCk7XG4gICAgc2VsUmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgZW5kKTtcbiAgICBzZWxSYW5nZS5zZWxlY3QoKTtcbiAgICBmaWVsZC5mb2N1cygpO1xuICB9IGVsc2UgaWYgKGZpZWxkLnNldFNlbGVjdGlvblJhbmdlKSB7XG4gICAgZmllbGQuZm9jdXMoKTtcbiAgICBmaWVsZC5zZXRTZWxlY3Rpb25SYW5nZShzdGFydCwgZW5kKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZmllbGQuc2VsZWN0aW9uU3RhcnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZmllbGQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICBmaWVsZC5zZWxlY3Rpb25FbmQgPSBlbmQ7XG4gICAgZmllbGQuZm9jdXMoKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yYy10aW1lLXBpY2tlci9saWIvdXRpbC9zZWxlY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxNDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX1NlbGVjdCA9IHJlcXVpcmUoJy4vU2VsZWN0Jyk7XG5cbnZhciBfU2VsZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NlbGVjdCk7XG5cbnZhciBfZ3JlZ29yaWFuQ2FsZW5kYXIgPSByZXF1aXJlKCdncmVnb3JpYW4tY2FsZW5kYXInKTtcblxudmFyIF9ncmVnb3JpYW5DYWxlbmRhcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ncmVnb3JpYW5DYWxlbmRhcik7XG5cbnZhciBmb3JtYXRPcHRpb24gPSBmdW5jdGlvbiBmb3JtYXRPcHRpb24ob3B0aW9uLCBkaXNhYmxlZE9wdGlvbnMpIHtcbiAgdmFyIHZhbHVlID0gJycgKyBvcHRpb247XG4gIGlmIChvcHRpb24gPCAxMCkge1xuICAgIHZhbHVlID0gJzAnICsgb3B0aW9uO1xuICB9XG5cbiAgdmFyIGRpc2FibGVkID0gZmFsc2U7XG4gIGlmIChkaXNhYmxlZE9wdGlvbnMgJiYgZGlzYWJsZWRPcHRpb25zLmluZGV4T2Yob3B0aW9uKSA+PSAwKSB7XG4gICAgZGlzYWJsZWQgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgZGlzYWJsZWQ6IGRpc2FibGVkXG4gIH07XG59O1xuXG52YXIgQ29tYm9ib3ggPSBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ0NvbWJvYm94JyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBmb3JtYXR0ZXI6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIHByZWZpeENsczogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgdmFsdWU6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIG9uQ2hhbmdlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgc2hvd0hvdXI6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBncmVnb3JpYW5DYWxlbmRhckxvY2FsZTogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgc2hvd1NlY29uZDogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGhvdXJPcHRpb25zOiBfcmVhY3QuUHJvcFR5cGVzLmFycmF5LFxuICAgIG1pbnV0ZU9wdGlvbnM6IF9yZWFjdC5Qcm9wVHlwZXMuYXJyYXksXG4gICAgc2Vjb25kT3B0aW9uczogX3JlYWN0LlByb3BUeXBlcy5hcnJheSxcbiAgICBkaXNhYmxlZEhvdXJzOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgZGlzYWJsZWRNaW51dGVzOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgZGlzYWJsZWRTZWNvbmRzOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25DdXJyZW50U2VsZWN0UGFuZWxDaGFuZ2U6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuY1xuICB9LFxuXG4gIG9uSXRlbUNoYW5nZTogZnVuY3Rpb24gb25JdGVtQ2hhbmdlKHR5cGUsIGl0ZW1WYWx1ZSkge1xuICAgIHZhciBvbkNoYW5nZSA9IHRoaXMucHJvcHMub25DaGFuZ2U7XG5cbiAgICB2YXIgdmFsdWUgPSB0aGlzLnByb3BzLnZhbHVlO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5jbG9uZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IHRoaXMuZ2V0Tm93KCkuY2xvbmUoKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdob3VyJykge1xuICAgICAgdmFsdWUuc2V0SG91ck9mRGF5KGl0ZW1WYWx1ZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnbWludXRlJykge1xuICAgICAgdmFsdWUuc2V0TWludXRlcyhpdGVtVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZS5zZXRTZWNvbmRzKGl0ZW1WYWx1ZSk7XG4gICAgfVxuICAgIG9uQ2hhbmdlKHZhbHVlKTtcbiAgfSxcblxuICBvbkVudGVyU2VsZWN0UGFuZWw6IGZ1bmN0aW9uIG9uRW50ZXJTZWxlY3RQYW5lbChyYW5nZSkge1xuICAgIHRoaXMucHJvcHMub25DdXJyZW50U2VsZWN0UGFuZWxDaGFuZ2UocmFuZ2UpO1xuICB9LFxuXG4gIGdldEhvdXJTZWxlY3Q6IGZ1bmN0aW9uIGdldEhvdXJTZWxlY3QoaG91cikge1xuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBwcmVmaXhDbHMgPSBfcHJvcHMucHJlZml4Q2xzO1xuICAgIHZhciBob3VyT3B0aW9ucyA9IF9wcm9wcy5ob3VyT3B0aW9ucztcbiAgICB2YXIgZGlzYWJsZWRIb3VycyA9IF9wcm9wcy5kaXNhYmxlZEhvdXJzO1xuICAgIHZhciBzaG93SG91ciA9IF9wcm9wcy5zaG93SG91cjtcblxuICAgIGlmICghc2hvd0hvdXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgZGlzYWJsZWRPcHRpb25zID0gZGlzYWJsZWRIb3VycygpO1xuXG4gICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KF9TZWxlY3QyWydkZWZhdWx0J10sIHtcbiAgICAgIHByZWZpeENsczogcHJlZml4Q2xzLFxuICAgICAgb3B0aW9uczogaG91ck9wdGlvbnMubWFwKGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdE9wdGlvbihvcHRpb24sIGRpc2FibGVkT3B0aW9ucyk7XG4gICAgICB9KSxcbiAgICAgIHNlbGVjdGVkSW5kZXg6IGhvdXJPcHRpb25zLmluZGV4T2YoaG91ciksXG4gICAgICB0eXBlOiAnaG91cicsXG4gICAgICBvblNlbGVjdDogdGhpcy5vbkl0ZW1DaGFuZ2UsXG4gICAgICBvbk1vdXNlRW50ZXI6IHRoaXMub25FbnRlclNlbGVjdFBhbmVsLmJpbmQodGhpcywgJ2hvdXInKVxuICAgIH0pO1xuICB9LFxuXG4gIGdldE1pbnV0ZVNlbGVjdDogZnVuY3Rpb24gZ2V0TWludXRlU2VsZWN0KG1pbnV0ZSkge1xuICAgIHZhciBfcHJvcHMyID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcHJlZml4Q2xzID0gX3Byb3BzMi5wcmVmaXhDbHM7XG4gICAgdmFyIG1pbnV0ZU9wdGlvbnMgPSBfcHJvcHMyLm1pbnV0ZU9wdGlvbnM7XG4gICAgdmFyIGRpc2FibGVkTWludXRlcyA9IF9wcm9wczIuZGlzYWJsZWRNaW51dGVzO1xuXG4gICAgdmFyIHZhbHVlID0gdGhpcy5wcm9wcy52YWx1ZSB8fCB0aGlzLmdldE5vdygpO1xuICAgIHZhciBkaXNhYmxlZE9wdGlvbnMgPSBkaXNhYmxlZE1pbnV0ZXModmFsdWUuZ2V0SG91ck9mRGF5KCkpO1xuXG4gICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KF9TZWxlY3QyWydkZWZhdWx0J10sIHtcbiAgICAgIHByZWZpeENsczogcHJlZml4Q2xzLFxuICAgICAgb3B0aW9uczogbWludXRlT3B0aW9ucy5tYXAoZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICByZXR1cm4gZm9ybWF0T3B0aW9uKG9wdGlvbiwgZGlzYWJsZWRPcHRpb25zKTtcbiAgICAgIH0pLFxuICAgICAgc2VsZWN0ZWRJbmRleDogbWludXRlT3B0aW9ucy5pbmRleE9mKG1pbnV0ZSksXG4gICAgICB0eXBlOiAnbWludXRlJyxcbiAgICAgIG9uU2VsZWN0OiB0aGlzLm9uSXRlbUNoYW5nZSxcbiAgICAgIG9uTW91c2VFbnRlcjogdGhpcy5vbkVudGVyU2VsZWN0UGFuZWwuYmluZCh0aGlzLCAnbWludXRlJylcbiAgICB9KTtcbiAgfSxcblxuICBnZXRTZWNvbmRTZWxlY3Q6IGZ1bmN0aW9uIGdldFNlY29uZFNlbGVjdChzZWNvbmQpIHtcbiAgICB2YXIgX3Byb3BzMyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHByZWZpeENscyA9IF9wcm9wczMucHJlZml4Q2xzO1xuICAgIHZhciBzZWNvbmRPcHRpb25zID0gX3Byb3BzMy5zZWNvbmRPcHRpb25zO1xuICAgIHZhciBkaXNhYmxlZFNlY29uZHMgPSBfcHJvcHMzLmRpc2FibGVkU2Vjb25kcztcbiAgICB2YXIgc2hvd1NlY29uZCA9IF9wcm9wczMuc2hvd1NlY29uZDtcblxuICAgIGlmICghc2hvd1NlY29uZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IHRoaXMucHJvcHMudmFsdWUgfHwgdGhpcy5nZXROb3coKTtcbiAgICB2YXIgZGlzYWJsZWRPcHRpb25zID0gZGlzYWJsZWRTZWNvbmRzKHZhbHVlLmdldEhvdXJPZkRheSgpLCB2YWx1ZS5nZXRNaW51dGVzKCkpO1xuXG4gICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KF9TZWxlY3QyWydkZWZhdWx0J10sIHtcbiAgICAgIHByZWZpeENsczogcHJlZml4Q2xzLFxuICAgICAgb3B0aW9uczogc2Vjb25kT3B0aW9ucy5tYXAoZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICByZXR1cm4gZm9ybWF0T3B0aW9uKG9wdGlvbiwgZGlzYWJsZWRPcHRpb25zKTtcbiAgICAgIH0pLFxuICAgICAgc2VsZWN0ZWRJbmRleDogc2Vjb25kT3B0aW9ucy5pbmRleE9mKHNlY29uZCksXG4gICAgICB0eXBlOiAnc2Vjb25kJyxcbiAgICAgIG9uU2VsZWN0OiB0aGlzLm9uSXRlbUNoYW5nZSxcbiAgICAgIG9uTW91c2VFbnRlcjogdGhpcy5vbkVudGVyU2VsZWN0UGFuZWwuYmluZCh0aGlzLCAnc2Vjb25kJylcbiAgICB9KTtcbiAgfSxcblxuICBnZXROb3c6IGZ1bmN0aW9uIGdldE5vdygpIHtcbiAgICBpZiAodGhpcy5zaG93Tm93KSB7XG4gICAgICByZXR1cm4gdGhpcy5zaG93Tm93O1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBuZXcgX2dyZWdvcmlhbkNhbGVuZGFyMlsnZGVmYXVsdCddKHRoaXMucHJvcHMuZ3JlZ29yaWFuQ2FsZW5kYXJMb2NhbGUpO1xuICAgIHZhbHVlLnNldFRpbWUoRGF0ZS5ub3coKSk7XG4gICAgdGhpcy5zaG93Tm93ID0gdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBwcmVmaXhDbHMgPSB0aGlzLnByb3BzLnByZWZpeENscztcblxuICAgIHZhciB2YWx1ZSA9IHRoaXMucHJvcHMudmFsdWUgfHwgdGhpcy5nZXROb3coKTtcbiAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnZGl2JyxcbiAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWNvbWJvYm94JyB9LFxuICAgICAgdGhpcy5nZXRIb3VyU2VsZWN0KHZhbHVlLmdldEhvdXJPZkRheSgpKSxcbiAgICAgIHRoaXMuZ2V0TWludXRlU2VsZWN0KHZhbHVlLmdldE1pbnV0ZXMoKSksXG4gICAgICB0aGlzLmdldFNlY29uZFNlbGVjdCh2YWx1ZS5nZXRTZWNvbmRzKCkpXG4gICAgKTtcbiAgfVxufSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IENvbWJvYm94O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmMtdGltZS1waWNrZXIvbGliL21vZHVsZS9Db21ib2JveC5qc1xuICoqIG1vZHVsZSBpZCA9IDE0NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcmVhY3REb20gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIF9yZWFjdERvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdERvbSk7XG5cbnZhciBfY2xhc3NuYW1lczIgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG5cbnZhciBfY2xhc3NuYW1lczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc25hbWVzMik7XG5cbnZhciBzY3JvbGxUbyA9IGZ1bmN0aW9uIHNjcm9sbFRvKGVsZW1lbnQsIHRvLCBkdXJhdGlvbikge1xuICB2YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBmdW5jdGlvbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWVUaW1lb3V0KCkge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGFyZ3VtZW50c1swXSwgMTApO1xuICB9O1xuICAvLyBqdW1wIHRvIHRhcmdldCBpZiBkdXJhdGlvbiB6ZXJvXG4gIGlmIChkdXJhdGlvbiA8PSAwKSB7XG4gICAgZWxlbWVudC5zY3JvbGxUb3AgPSB0bztcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGRpZmZlcmVuY2UgPSB0byAtIGVsZW1lbnQuc2Nyb2xsVG9wO1xuICB2YXIgcGVyVGljayA9IGRpZmZlcmVuY2UgLyBkdXJhdGlvbiAqIDEwO1xuXG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgZWxlbWVudC5zY3JvbGxUb3AgPSBlbGVtZW50LnNjcm9sbFRvcCArIHBlclRpY2s7XG4gICAgaWYgKGVsZW1lbnQuc2Nyb2xsVG9wID09PSB0bykgcmV0dXJuO1xuICAgIHNjcm9sbFRvKGVsZW1lbnQsIHRvLCBkdXJhdGlvbiAtIDEwKTtcbiAgfSk7XG59O1xuXG52YXIgU2VsZWN0ID0gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdTZWxlY3QnLFxuXG4gIHByb3BUeXBlczoge1xuICAgIHByZWZpeENsczogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgb3B0aW9uczogX3JlYWN0LlByb3BUeXBlcy5hcnJheSxcbiAgICBncmVnb3JpYW5DYWxlbmRhckxvY2FsZTogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgc2VsZWN0ZWRJbmRleDogX3JlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgdHlwZTogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgb25TZWxlY3Q6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbk1vdXNlRW50ZXI6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuY1xuICB9LFxuXG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAvLyBqdW1wIHRvIHNlbGVjdGVkIG9wdGlvblxuICAgIHRoaXMuc2Nyb2xsVG9TZWxlY3RlZCgwKTtcbiAgfSxcblxuICBjb21wb25lbnREaWRVcGRhdGU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAvLyBzbW9vdGggc2Nyb2xsIHRvIHNlbGVjdGVkIG9wdGlvblxuICAgIGlmIChwcmV2UHJvcHMuc2VsZWN0ZWRJbmRleCAhPT0gdGhpcy5wcm9wcy5zZWxlY3RlZEluZGV4KSB7XG4gICAgICB0aGlzLnNjcm9sbFRvU2VsZWN0ZWQoMTIwKTtcbiAgICB9XG4gIH0sXG5cbiAgb25TZWxlY3Q6IGZ1bmN0aW9uIG9uU2VsZWN0KHZhbHVlKSB7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIG9uU2VsZWN0ID0gX3Byb3BzLm9uU2VsZWN0O1xuICAgIHZhciB0eXBlID0gX3Byb3BzLnR5cGU7XG5cbiAgICBvblNlbGVjdCh0eXBlLCB2YWx1ZSk7XG4gIH0sXG5cbiAgZ2V0T3B0aW9uczogZnVuY3Rpb24gZ2V0T3B0aW9ucygpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIF9wcm9wczIgPSB0aGlzLnByb3BzO1xuICAgIHZhciBvcHRpb25zID0gX3Byb3BzMi5vcHRpb25zO1xuICAgIHZhciBzZWxlY3RlZEluZGV4ID0gX3Byb3BzMi5zZWxlY3RlZEluZGV4O1xuICAgIHZhciBwcmVmaXhDbHMgPSBfcHJvcHMyLnByZWZpeENscztcblxuICAgIHJldHVybiBvcHRpb25zLm1hcChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgIHZhciBfY2xhc3NuYW1lcztcblxuICAgICAgdmFyIGNscyA9ICgwLCBfY2xhc3NuYW1lczNbJ2RlZmF1bHQnXSkoKF9jbGFzc25hbWVzID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lcywgcHJlZml4Q2xzICsgJy1zZWxlY3Qtb3B0aW9uLXNlbGVjdGVkJywgc2VsZWN0ZWRJbmRleCA9PT0gaW5kZXgpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMsIHByZWZpeENscyArICctc2VsZWN0LW9wdGlvbi1kaXNhYmxlZCcsIGl0ZW0uZGlzYWJsZWQpLCBfY2xhc3NuYW1lcykpO1xuICAgICAgdmFyIG9uY2xpY2sgPSBudWxsO1xuICAgICAgaWYgKCFpdGVtLmRpc2FibGVkKSB7XG4gICAgICAgIG9uY2xpY2sgPSBfdGhpcy5vblNlbGVjdC5iaW5kKF90aGlzLCAraXRlbS52YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdsaScsXG4gICAgICAgIHsgY2xhc3NOYW1lOiBjbHMsIGtleTogaW5kZXgsIG9uQ2xpY2s6IG9uY2xpY2ssIGRpc2FibGVkOiBpdGVtLmRpc2FibGVkIH0sXG4gICAgICAgIGl0ZW0udmFsdWVcbiAgICAgICk7XG4gICAgfSk7XG4gIH0sXG5cbiAgc2Nyb2xsVG9TZWxlY3RlZDogZnVuY3Rpb24gc2Nyb2xsVG9TZWxlY3RlZChkdXJhdGlvbikge1xuICAgIC8vIG1vdmUgdG8gc2VsZWN0ZWQgaXRlbVxuICAgIHZhciBzZWxlY3QgPSBfcmVhY3REb20yWydkZWZhdWx0J10uZmluZERPTU5vZGUodGhpcyk7XG4gICAgdmFyIGxpc3QgPSBfcmVhY3REb20yWydkZWZhdWx0J10uZmluZERPTU5vZGUodGhpcy5yZWZzLmxpc3QpO1xuICAgIHZhciBpbmRleCA9IHRoaXMucHJvcHMuc2VsZWN0ZWRJbmRleDtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICBpbmRleCA9IDA7XG4gICAgfVxuICAgIHZhciB0b3BPcHRpb24gPSBsaXN0LmNoaWxkcmVuW2luZGV4XTtcbiAgICB2YXIgdG8gPSB0b3BPcHRpb24ub2Zmc2V0VG9wO1xuICAgIHNjcm9sbFRvKHNlbGVjdCwgdG8sIGR1cmF0aW9uKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5vcHRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHByZWZpeENscyA9IHRoaXMucHJvcHMucHJlZml4Q2xzO1xuXG4gICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgJ2RpdicsXG4gICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1zZWxlY3QnLFxuICAgICAgICBvbk1vdXNlRW50ZXI6IHRoaXMucHJvcHMub25Nb3VzZUVudGVyIH0sXG4gICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ3VsJyxcbiAgICAgICAgeyByZWY6ICdsaXN0JyB9LFxuICAgICAgICB0aGlzLmdldE9wdGlvbnMoKVxuICAgICAgKVxuICAgICk7XG4gIH1cbn0pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBTZWxlY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yYy10aW1lLXBpY2tlci9saWIvbW9kdWxlL1NlbGVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDE0NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBhdXRvQWRqdXN0T3ZlcmZsb3cgPSB7XG4gIGFkanVzdFg6IDEsXG4gIGFkanVzdFk6IDFcbn07XG5cbnZhciB0YXJnZXRPZmZzZXQgPSBbMCwgMF07XG5cbnZhciBwbGFjZW1lbnRzID0ge1xuICBib3R0b21MZWZ0OiB7XG4gICAgcG9pbnRzOiBbJ3RsJywgJ3RsJ10sXG4gICAgb3ZlcmZsb3c6IGF1dG9BZGp1c3RPdmVyZmxvdyxcbiAgICBvZmZzZXQ6IFswLCAtM10sXG4gICAgdGFyZ2V0T2Zmc2V0OiB0YXJnZXRPZmZzZXRcbiAgfSxcbiAgYm90dG9tUmlnaHQ6IHtcbiAgICBwb2ludHM6IFsndHInLCAndHInXSxcbiAgICBvdmVyZmxvdzogYXV0b0FkanVzdE92ZXJmbG93LFxuICAgIG9mZnNldDogWzAsIC0zXSxcbiAgICB0YXJnZXRPZmZzZXQ6IHRhcmdldE9mZnNldFxuICB9LFxuICB0b3BSaWdodDoge1xuICAgIHBvaW50czogWydicicsICdiciddLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3csXG4gICAgb2Zmc2V0OiBbMCwgM10sXG4gICAgdGFyZ2V0T2Zmc2V0OiB0YXJnZXRPZmZzZXRcbiAgfSxcbiAgdG9wTGVmdDoge1xuICAgIHBvaW50czogWydibCcsICdibCddLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3csXG4gICAgb2Zmc2V0OiBbMCwgM10sXG4gICAgdGFyZ2V0T2Zmc2V0OiB0YXJnZXRPZmZzZXRcbiAgfVxufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gcGxhY2VtZW50cztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JjLXRpbWUtcGlja2VyL2xpYi91dGlsL3BsYWNlbWVudHMuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldEZvcm1hdHRlciA9IGdldEZvcm1hdHRlcjtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX2dyZWdvcmlhbkNhbGVuZGFyRm9ybWF0ID0gcmVxdWlyZSgnZ3JlZ29yaWFuLWNhbGVuZGFyLWZvcm1hdCcpO1xuXG52YXIgX2dyZWdvcmlhbkNhbGVuZGFyRm9ybWF0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dyZWdvcmlhbkNhbGVuZGFyRm9ybWF0KTtcblxuZnVuY3Rpb24gZ2V0Rm9ybWF0dGVyKGZvcm1hdCwgbG9jYWxlKSB7XG4gIGlmICh0eXBlb2YgZm9ybWF0ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBuZXcgX2dyZWdvcmlhbkNhbGVuZGFyRm9ybWF0MlsnZGVmYXVsdCddKGZvcm1hdCwgbG9jYWxlLmZvcm1hdCk7XG4gIH1cbiAgcmV0dXJuIGZvcm1hdDtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yYy10aW1lLXBpY2tlci9saWIvdXRpbC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE1MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHdhcm5pbmcgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYXJncykge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuID4gMiA/IGxlbiAtIDIgOiAwKTtcbiAgICBmb3IgKHZhciBrZXkgPSAyOyBrZXkgPCBsZW47IGtleSsrKSB7XG4gICAgICBhcmdzW2tleSAtIDJdID0gYXJndW1lbnRzW2tleV07XG4gICAgfVxuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArXG4gICAgICAgICdtZXNzYWdlIGFyZ3VtZW50J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0Lmxlbmd0aCA8IDEwIHx8ICgvXltzXFxXXSokLykudGVzdChmb3JtYXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdUaGUgd2FybmluZyBmb3JtYXQgc2hvdWxkIGJlIGFibGUgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyAnICtcbiAgICAgICAgJ3dhcm5pbmcuIFBsZWFzZSwgdXNlIGEgbW9yZSBkZXNjcmlwdGl2ZSBmb3JtYXQgdGhhbjogJyArIGZvcm1hdFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgK1xuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGNhdGNoKHgpIHt9XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yYy10aW1lLXBpY2tlci9+L2dyZWdvcmlhbi1jYWxlbmRhci1mb3JtYXQvfi93YXJuaW5nL2Jyb3dzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZvcm1hdHRlciA9IHJlcXVpcmUoJ3V4Y29yZS1mb3JtYXR0ZXInKTtcbnZhciBUb29sdGlwID0gcmVxdWlyZSgndXhjb3JlLXRvb2x0aXAnKTtcbnZhciBjbGFzc25hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xudmFyIGkxOG4gPSByZXF1aXJlKCcuL2xvY2FsZScpO1xuXG4vKipcbiAqIGNvZGUgc2hvdWxkIGJlIGFuIG9iamVjdCBsaWtlIHRoaXMgeyd4eHh4LXh4LXh4JzogJ3dvcmsvbGVhdmUvc2NoZWR1bGUnfVxuICovXG52YXIgZ2VuZXJhdGVDb250ZW50UmVuZGVyID0gZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50UmVuZGVyKGNvZGUpIHtcbiAgICB2YXIgbG9jYWxlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gJ3poLWNuJyA6IGFyZ3VtZW50c1sxXTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBjb250ZW50UmVuZGVyKGNvZGUsIGxvY2FsZSwgY3VycmVudCwgdmFsdWUpIHtcbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS95aW1pbmdoZS9ncmVnb3JpYW4tY2FsZW5kYXIgdG8gZ2V0IGRldGFpbHMgYWJvdXQgYGN1cnJlbnRgIEFQSVxuICAgICAgICB2YXIgdGltZSA9IGN1cnJlbnQuZ2V0VGltZSgpO1xuICAgICAgICB2YXIgZGF0ZSA9IEZvcm1hdHRlci5kYXRlKHRpbWUsICdZWVlZLU1NLUREJyk7XG4gICAgICAgIHZhciB0eXBlID0gY29kZVtkYXRlXTtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0eXBlID0gW3R5cGVdO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0eXBlID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRpcE1hcCA9IGkxOG5bbG9jYWxlXTtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBbXTtcbiAgICAgICAgdmFyIGlzV29yayA9IHR5cGUuaW5kZXhPZignd29yaycpICE9PSAtMTtcbiAgICAgICAgdmFyIGlzTGVhdmUgPSB0eXBlLmluZGV4T2YoJ2xlYXZlJykgIT09IC0xO1xuICAgICAgICB2YXIgaXNTY2hlZHVsZSA9IHR5cGUuaW5kZXhPZignc2NoZWR1bGUnKSAhPT0gLTE7XG4gICAgICAgIGNvbnRlbnQucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgeyBrZXk6ICdkYXRlJywgY2xhc3NOYW1lOiBjbGFzc25hbWVzKHtcbiAgICAgICAgICAgICAgICAgICAgJ2t1bWEtY2FsZW5kYXItZGF0ZS1jb250ZW50JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgJ3dvcmsnOiBpc1dvcmssXG4gICAgICAgICAgICAgICAgICAgICdsZWF2ZSc6IGlzTGVhdmUsXG4gICAgICAgICAgICAgICAgICAgICdzY2hlZHVsZSc6IGlzU2NoZWR1bGVcbiAgICAgICAgICAgICAgICB9KSB9LFxuICAgICAgICAgICAgY3VycmVudC5nZXREYXlPZk1vbnRoKClcbiAgICAgICAgKSk7XG4gICAgICAgIGlmIChpc1NjaGVkdWxlKSB7XG4gICAgICAgICAgICBjb250ZW50LnB1c2goUmVhY3QuY3JlYXRlRWxlbWVudCgnc3BhbicsIHsga2V5OiAnYm90dG9tLWxpbmUnLCBjbGFzc05hbWU6ICdrdW1hLWNhbGVuZGFyLWRhdGUtZGVjb3JhdGlvbicgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzV29yayB8fCBpc0xlYXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICBUb29sdGlwLFxuICAgICAgICAgICAgICAgIHsgcGxhY2VtZW50OiAncmlnaHQnLCB0cmlnZ2VyOiBbXCJob3ZlclwiXSwgb3ZlcmxheTogdGlwTWFwW2lzV29yayA/ICd3b3JrJyA6ICdsZWF2ZSddIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAna3VtYS1jYWxlbmRhci1kYXRlLWNvbnRlbnQtYm94JyB9LFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG9ubHkgb25lIGNoaWxkIGNhbiBiZSBwYXNzZWQuXG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2t1bWEtY2FsZW5kYXItZGF0ZS1jb250ZW50LWJveCcgfSxcbiAgICAgICAgICAgICAgICBjb250ZW50XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfS5iaW5kKG51bGwsIGNvZGUsIGxvY2FsZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBnZW5lcmF0ZUNvbnRlbnRSZW5kZXI6IGdlbmVyYXRlQ29udGVudFJlbmRlclxufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL2J1aWxkL3V0aWwuanNcbiAqKi8iLCIvKipcbiAqIEZvcm1hdHRlciBDb21wb25lbnQgZm9yIHV4Y29yZVxuICogQGF1dGhvciBndWFuZ2hvbmcud3NqXG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgVXhjb3JlIFRlYW0sIEFsaW53LlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vRm9ybWF0dGVyJyk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtYXR0ZXIvc3JjL2luZGV4LmpzXG4gKiovIiwiLyoqXG4gKiBGb3JtYXR0ZXIgQ29tcG9uZW50IGZvciB1eGNvcmVcbiAqIEBhdXRob3IgZXRlcm5hbHNreVxuICpcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIFV4Y29yZSBUZWFtLCBBbGludy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxudmFyIEZvcm1hdHRlciA9IHt9O1xuXG5Gb3JtYXR0ZXIuZGF0ZSA9IGZ1bmN0aW9uKHN0ciwgcGF0dGVybikge1xuICAgIHZhciBkYXRlID0gbmV3IERhdGUoc3RyKTtcbiAgICBwYXR0ZXJuID0gcGF0dGVybiB8fCAnWVlZWS1NTS1ERCc7XG4gICAgdmFyIG8gPSB7XG4gICAgICAgIFwiTStcIjogZGF0ZS5nZXRNb250aCgpICsgMSwgLy/mnIjku70gXG4gICAgICAgIFwiRCtcIjogZGF0ZS5nZXREYXRlKCksIC8v5pelIFxuICAgICAgICBcImQrXCI6IGRhdGUuZ2V0RGF0ZSgpLCAvL+aXpSBcbiAgICAgICAgXCJIK1wiOiBkYXRlLmdldEhvdXJzKCksIC8v5bCP5pe2IFxuICAgICAgICBcImgrXCI6IGRhdGUuZ2V0SG91cnMoKSwgLy/lsI/ml7YgXG4gICAgICAgIFwibStcIjogZGF0ZS5nZXRNaW51dGVzKCksIC8v5YiGIFxuICAgICAgICBcInMrXCI6IGRhdGUuZ2V0U2Vjb25kcygpLCAvL+enkiBcbiAgICAgICAgXCJRK1wiOiBNYXRoLmZsb29yKChkYXRlLmdldE1vbnRoKCkgKyAzKSAvIDMpLCAvL+Wto+W6piBcbiAgICAgICAgXCJxK1wiOiBNYXRoLmZsb29yKChkYXRlLmdldE1vbnRoKCkgKyAzKSAvIDMpLCAvL+Wto+W6piBcbiAgICAgICAgXCJTXCI6IGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkgLy/mr6vnp5IgXG4gICAgfTtcbiAgICBpZiAoLyh5KykvaS50ZXN0KHBhdHRlcm4pKSB7XG4gICAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuLnJlcGxhY2UoUmVnRXhwLiQxLCAoZGF0ZS5nZXRGdWxsWWVhcigpICsgXCJcIikuc3Vic3RyKDQgLSBSZWdFeHAuJDEubGVuZ3RoKSk7XG4gICAgfVxuICAgIGZvciAodmFyIGsgaW4gbykge1xuICAgICAgICBpZiAobmV3IFJlZ0V4cChcIihcIiArIGsgKyBcIilcIikudGVzdChwYXR0ZXJuKSkgcGF0dGVybiA9IHBhdHRlcm4ucmVwbGFjZShSZWdFeHAuJDEsIChSZWdFeHAuJDEubGVuZ3RoID09IDEpID8gKG9ba10pIDogKChcIjAwXCIgKyBvW2tdKS5zdWJzdHIoKFwiXCIgKyBvW2tdKS5sZW5ndGgpKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXR0ZXJuO1xufVxuXG5Gb3JtYXR0ZXIubW9uZXkgPSBmdW5jdGlvbihzdHIsIGRlbGltaXRlciwgZml4ZWROdW0pIHtcbiAgICBkZWxpbWl0ZXIgPSBkZWxpbWl0ZXIgfHwgXCIgXCI7XG4gICAgaWYgKGZpeGVkTnVtKSB7XG4gICAgICAgIHN0ciA9IHBhcnNlRmxvYXQoc3RyKS50b0ZpeGVkKGZpeGVkTnVtKS50b1N0cmluZygpXG4gICAgfVxuICAgIGlmIChzdHIuaW5kZXhPZihcIi5cIikgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFxcZCkoPz0oPzpcXGR7M30pKyhcXC4pKS9nLCBmdW5jdGlvbihtYXRjaCwgJDEpIHtcbiAgICAgICAgICAgIHJldHVybiAkMSArIGRlbGltaXRlcjtcbiAgICAgICAgfSkucmVwbGFjZSgvKFxcZHszfSkoPyFbJHxcXC58XFwofFxcc10pL2csIGZ1bmN0aW9uKG1hdGNoLCAkMSkge1xuICAgICAgICAgICAgcmV0dXJuICQxO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFxcZCkoPz0oPzpcXGR7M30pKyQpL2csIGZ1bmN0aW9uKG1hdGNoLCAkMSkge1xuICAgICAgICAgICAgcmV0dXJuICQxICsgZGVsaW1pdGVyO1xuICAgICAgICB9KVxuICAgIH1cbn1cblxuRm9ybWF0dGVyLmNubW9iaWxlID0gZnVuY3Rpb24oc3RyLCBkZWxpbWl0ZXIpIHtcbiAgICBkZWxpbWl0ZXIgPSBkZWxpbWl0ZXIgfHwgXCIgXCI7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eKFxcKz8wPzg2KSg/ISQpLywgXCIkMVwiICsgZGVsaW1pdGVyKS5yZXBsYWNlKC8oXFxkezR9KSg/ISQpL2csIFwiJDFcIiArIGRlbGltaXRlcik7XG59XG5cbkZvcm1hdHRlci5jYXJkID0gZnVuY3Rpb24oc3RyLCBkZWxpbWl0ZXIpIHtcbiAgICBkZWxpbWl0ZXIgPSBkZWxpbWl0ZXIgfHwgXCIgXCI7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oXFxkezR9KSg/ISQpL2csIFwiJDFcIiArIGRlbGltaXRlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRm9ybWF0dGVyO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtZm9ybWF0dGVyL3NyYy9Gb3JtYXR0ZXIuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVG9vbHRpcCBDb21wb25lbnQgZm9yIHV4Y29yZVxuICogQGF1dGhvciBcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBVeGNvcmUgVGVhbSwgQWxpbncuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9Ub29sdGlwJyk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS10b29sdGlwL2J1aWxkL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JjVG9vbHRpcCA9IHJlcXVpcmUoJ3JjLXRvb2x0aXAnKTtcblxudmFyIF9yY1Rvb2x0aXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmNUb29sdGlwKTtcblxudmFyIF9vYmplY3RBc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBfb2JqZWN0QXNzaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29iamVjdEFzc2lnbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBUb29sdGlwID0gZnVuY3Rpb24gKF9SY1Rvb2x0aXApIHtcblx0X2luaGVyaXRzKFRvb2x0aXAsIF9SY1Rvb2x0aXApO1xuXG5cdGZ1bmN0aW9uIFRvb2x0aXAocHJvcHMpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgVG9vbHRpcCk7XG5cblx0XHRyZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JjVG9vbHRpcC5jYWxsKHRoaXMsIHByb3BzKSk7XG5cdH1cblxuXHRyZXR1cm4gVG9vbHRpcDtcbn0oX3JjVG9vbHRpcDJbXCJkZWZhdWx0XCJdKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBUb29sdGlwO1xuXG5Ub29sdGlwLmRpc3BsYXlOYW1lID0gJ3V4Y29yZS10b29sdGlwJztcblRvb2x0aXAucHJvcFR5cGVzID0gX3JjVG9vbHRpcDJbXCJkZWZhdWx0XCJdLnByb3BUeXBlcztcblxuVG9vbHRpcC5kZWZhdWx0UHJvcHMgPSAoMCwgX29iamVjdEFzc2lnbjJbXCJkZWZhdWx0XCJdKShfcmNUb29sdGlwMltcImRlZmF1bHRcIl0uZGVmYXVsdFByb3BzLCB7XG5cdHByZWZpeENsczogJ2t1bWEtdG9vbHRpcCcsXG5cdG92ZXJsYXlDbGFzc05hbWU6ICd1eGNvcmUnXG59KTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtdG9vbHRpcC9idWlsZC9Ub29sdGlwLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBhdXRvQWRqdXN0T3ZlcmZsb3cgPSB7XG4gIGFkanVzdFg6IDEsXG4gIGFkanVzdFk6IDFcbn07XG5cbnZhciB0YXJnZXRPZmZzZXQgPSBbMCwgMF07XG5cbnZhciBwbGFjZW1lbnRzID0ge1xuICBsZWZ0OiB7XG4gICAgcG9pbnRzOiBbJ2NyJywgJ2NsJ10sXG4gICAgb3ZlcmZsb3c6IGF1dG9BZGp1c3RPdmVyZmxvdyxcbiAgICBvZmZzZXQ6IFstNCwgMF0sXG4gICAgdGFyZ2V0T2Zmc2V0OiB0YXJnZXRPZmZzZXRcbiAgfSxcbiAgcmlnaHQ6IHtcbiAgICBwb2ludHM6IFsnY2wnLCAnY3InXSxcbiAgICBvdmVyZmxvdzogYXV0b0FkanVzdE92ZXJmbG93LFxuICAgIG9mZnNldDogWzQsIDBdLFxuICAgIHRhcmdldE9mZnNldDogdGFyZ2V0T2Zmc2V0XG4gIH0sXG4gIHRvcDoge1xuICAgIHBvaW50czogWydiYycsICd0YyddLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3csXG4gICAgb2Zmc2V0OiBbMCwgLTRdLFxuICAgIHRhcmdldE9mZnNldDogdGFyZ2V0T2Zmc2V0XG4gIH0sXG4gIGJvdHRvbToge1xuICAgIHBvaW50czogWyd0YycsICdiYyddLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3csXG4gICAgb2Zmc2V0OiBbMCwgNF0sXG4gICAgdGFyZ2V0T2Zmc2V0OiB0YXJnZXRPZmZzZXRcbiAgfSxcbiAgdG9wTGVmdDoge1xuICAgIHBvaW50czogWydibCcsICd0bCddLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3csXG4gICAgb2Zmc2V0OiBbMCwgLTRdLFxuICAgIHRhcmdldE9mZnNldDogdGFyZ2V0T2Zmc2V0XG4gIH0sXG4gIGxlZnRUb3A6IHtcbiAgICBwb2ludHM6IFsndHInLCAndGwnXSxcbiAgICBvdmVyZmxvdzogYXV0b0FkanVzdE92ZXJmbG93LFxuICAgIG9mZnNldDogWy0zLCAwXSxcbiAgICB0YXJnZXRPZmZzZXQ6IHRhcmdldE9mZnNldFxuICB9LFxuICB0b3BSaWdodDoge1xuICAgIHBvaW50czogWydicicsICd0ciddLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3csXG4gICAgb2Zmc2V0OiBbMCwgLTRdLFxuICAgIHRhcmdldE9mZnNldDogdGFyZ2V0T2Zmc2V0XG4gIH0sXG4gIHJpZ2h0VG9wOiB7XG4gICAgcG9pbnRzOiBbJ3RsJywgJ3RyJ10sXG4gICAgb3ZlcmZsb3c6IGF1dG9BZGp1c3RPdmVyZmxvdyxcbiAgICBvZmZzZXQ6IFs0LCAwXSxcbiAgICB0YXJnZXRPZmZzZXQ6IHRhcmdldE9mZnNldFxuICB9LFxuICBib3R0b21SaWdodDoge1xuICAgIHBvaW50czogWyd0cicsICdiciddLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3csXG4gICAgb2Zmc2V0OiBbMCwgNF0sXG4gICAgdGFyZ2V0T2Zmc2V0OiB0YXJnZXRPZmZzZXRcbiAgfSxcbiAgcmlnaHRCb3R0b206IHtcbiAgICBwb2ludHM6IFsnYmwnLCAnYnInXSxcbiAgICBvdmVyZmxvdzogYXV0b0FkanVzdE92ZXJmbG93LFxuICAgIG9mZnNldDogWzQsIDBdLFxuICAgIHRhcmdldE9mZnNldDogdGFyZ2V0T2Zmc2V0XG4gIH0sXG4gIGJvdHRvbUxlZnQ6IHtcbiAgICBwb2ludHM6IFsndGwnLCAnYmwnXSxcbiAgICBvdmVyZmxvdzogYXV0b0FkanVzdE92ZXJmbG93LFxuICAgIG9mZnNldDogWzAsIDRdLFxuICAgIHRhcmdldE9mZnNldDogdGFyZ2V0T2Zmc2V0XG4gIH0sXG4gIGxlZnRCb3R0b206IHtcbiAgICBwb2ludHM6IFsnYnInLCAnYmwnXSxcbiAgICBvdmVyZmxvdzogYXV0b0FkanVzdE92ZXJmbG93LFxuICAgIG9mZnNldDogWy00LCAwXSxcbiAgICB0YXJnZXRPZmZzZXQ6IHRhcmdldE9mZnNldFxuICB9XG59O1xuXG5leHBvcnRzLnBsYWNlbWVudHMgPSBwbGFjZW1lbnRzO1xuZXhwb3J0c1snZGVmYXVsdCddID0gcGxhY2VtZW50cztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLXRvb2x0aXAvfi9yYy10b29sdGlwL2xpYi9wbGFjZW1lbnRzLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbG9jYWxlID0ge1xuICAgICd6aC1jbic6IHtcbiAgICAgICAgJ3dvcmsnOiAn5LiK54+tJyxcbiAgICAgICAgJ2xlYXZlJzogJ+S8keWBhydcbiAgICB9LFxuICAgICdlbi11cyc6IHtcbiAgICAgICAgJ3dvcmsnOiAnd29yaycsXG4gICAgICAgICdsZWF2ZSc6ICdsZWF2ZSdcbiAgICB9XG59O1xuXG5sb2NhbGVbJ2VuJ10gPSBsb2NhbGVbJ2VuLXVzJ107XG5cbm1vZHVsZS5leHBvcnRzID0gbG9jYWxlO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvYnVpbGQvbG9jYWxlLmpzXG4gKiovIiwiLypcbiAqIHpoLWNuIGxvY2FsZVxuICogQGlnbm9yZVxuICogQGF1dGhvciB5aW1pbmdoZUBnbWFpbC5jb21cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBpbiBtaW51dGVzXG4gIHRpbWV6b25lT2Zmc2V0OiA4ICogNjAsXG4gIGZpcnN0RGF5T2ZXZWVrOiAxLFxuICBtaW5pbWFsRGF5c0luRmlyc3RXZWVrOiAxXG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9ncmVnb3JpYW4tY2FsZW5kYXIvbGliL2xvY2FsZS96aF9DTi5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF96aF9DTiA9IHJlcXVpcmUoJ2dyZWdvcmlhbi1jYWxlbmRhci1mb3JtYXQvbGliL2xvY2FsZS96aF9DTicpO1xuXG52YXIgX3poX0NOMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3poX0NOKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0ge1xuICB0b2RheTogJ+S7iuWkqScsXG4gIG5vdzogJ+atpOWIuycsXG4gIG9rOiAn56Gu5a6aJyxcbiAgY2xlYXI6ICfmuIXpmaQnLFxuICBtb250aDogJ+aciCcsXG4gIHllYXI6ICflubQnLFxuICBwcmV2aW91c01vbnRoOiAn5LiK5Liq5pyIICjnv7vpobXkuIrplK4pJyxcbiAgbmV4dE1vbnRoOiAn5LiL5Liq5pyIICjnv7vpobXkuIvplK4pJyxcbiAgbW9udGhTZWxlY3Q6ICfpgInmi6nmnIjku70nLFxuICB5ZWFyU2VsZWN0OiAn6YCJ5oup5bm05Lu9JyxcbiAgZGVjYWRlU2VsZWN0OiAn6YCJ5oup5bm05LujJyxcbiAgeWVhckZvcm1hdDogJ3l5eXlcXCflubRcXCcnLFxuICBtb250aEZvcm1hdDogJ01cXCfmnIhcXCcnLFxuICBkYXRlRm9ybWF0OiAneXl5eVxcJ+W5tFxcJ01cXCfmnIhcXCdkXFwn5pelXFwnJyxcbiAgcHJldmlvdXNZZWFyOiAn5LiK5LiA5bm0IChDb250cm9s6ZSu5Yqg5bem5pa55ZCR6ZSuKScsXG4gIG5leHRZZWFyOiAn5LiL5LiA5bm0IChDb250cm9s6ZSu5Yqg5Y+z5pa55ZCR6ZSuKScsXG4gIHByZXZpb3VzRGVjYWRlOiAn5LiK5LiA5bm05LujJyxcbiAgbmV4dERlY2FkZTogJ+S4i+S4gOW5tOS7oycsXG4gIHByZXZpb3VzQ2VudHVyeTogJ+S4iuS4gOS4lue6qicsXG4gIG5leHRDZW50dXJ5OiAn5LiL5LiA5LiW57qqJyxcbiAgZm9ybWF0OiBfemhfQ04yW1wiZGVmYXVsdFwiXVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9saWIvbG9jYWxlL3poX0NOLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZXJhczogWyflhazlhYPliY0nLCAn5YWs5YWDJ10sXG4gIG1vbnRoczogWyfkuIDmnIgnLCAn5LqM5pyIJywgJ+S4ieaciCcsICflm5vmnIgnLCAn5LqU5pyIJywgJ+WFreaciCcsICfkuIPmnIgnLCAn5YWr5pyIJywgJ+S5neaciCcsICfljYHmnIgnLCAn5Y2B5LiA5pyIJywgJ+WNgeS6jOaciCddLFxuICBzaG9ydE1vbnRoczogWyfkuIDmnIgnLCAn5LqM5pyIJywgJ+S4ieaciCcsICflm5vmnIgnLCAn5LqU5pyIJywgJ+WFreaciCcsICfkuIPmnIgnLCAn5YWr5pyIJywgJ+S5neaciCcsICfljYHmnIgnLCAn5Y2B5LiA5pyIJywgJ+WNgeS6jOaciCddLFxuICB3ZWVrZGF5czogWyfmmJ/mnJ/lpKknLCAn5pif5pyf5LiAJywgJ+aYn+acn+S6jCcsICfmmJ/mnJ/kuIknLCAn5pif5pyf5ZubJywgJ+aYn+acn+S6lCcsICfmmJ/mnJ/lha0nXSxcbiAgc2hvcnRXZWVrZGF5czogWyflkajml6UnLCAn5ZGo5LiAJywgJ+WRqOS6jCcsICflkajkuIknLCAn5ZGo5ZubJywgJ+WRqOS6lCcsICflkajlha0nXSxcbiAgdmVyeVNob3J0V2Vla2RheXM6IFsn5pelJywgJ+S4gCcsICfkuownLCAn5LiJJywgJ+WbmycsICfkupQnLCAn5YWtJ10sXG4gIGFtcG1zOiBbJ+S4iuWNiCcsICfkuIvljYgnXSxcbiAgZGF0ZVBhdHRlcm5zOiBbJ3l5eXlcXCflubRcXCdNXFwn5pyIXFwnZFxcJ+aXpVxcJyBFRUVFJywgJ3l5eXlcXCflubRcXCdNXFwn5pyIXFwnZFxcJ+aXpVxcJycsICd5eXl5LU0tZCcsICd5eS1NLWQnXSxcbiAgdGltZVBhdHRlcm5zOiBbJ2FoaFxcJ+aXtlxcJ21tXFwn5YiGXFwnc3NcXCfnp5JcXCcgXFwnR01UXFwnWicsICdhaGhcXCfml7ZcXCdtbVxcJ+WIhlxcJ3NzXFwn56eSXFwnJywgJ0g6bW06c3MnLCAnYWg6bW0nXSxcbiAgZGF0ZVRpbWVQYXR0ZXJuOiAne2RhdGV9IHt0aW1lfSdcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L2dyZWdvcmlhbi1jYWxlbmRhci1mb3JtYXQvbGliL2xvY2FsZS96aF9DTi5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9ncmVnb3JpYW5DYWxlbmRhckZvcm1hdExpYkxvY2FsZVpoX0NOID0gcmVxdWlyZSgnZ3JlZ29yaWFuLWNhbGVuZGFyLWZvcm1hdC9saWIvbG9jYWxlL3poX0NOJyk7XG5cbnZhciBfZ3JlZ29yaWFuQ2FsZW5kYXJGb3JtYXRMaWJMb2NhbGVaaF9DTjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ncmVnb3JpYW5DYWxlbmRhckZvcm1hdExpYkxvY2FsZVpoX0NOKTtcblxudmFyIF9ncmVnb3JpYW5DYWxlbmRhckxpYkxvY2FsZVpoX0NOID0gcmVxdWlyZSgnZ3JlZ29yaWFuLWNhbGVuZGFyL2xpYi9sb2NhbGUvemhfQ04nKTtcblxudmFyIF9ncmVnb3JpYW5DYWxlbmRhckxpYkxvY2FsZVpoX0NOMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dyZWdvcmlhbkNhbGVuZGFyTGliTG9jYWxlWmhfQ04pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSB7XG4gIGNsZWFyOiAn5riF6ZmkJyxcbiAgZm9ybWF0OiBfZ3JlZ29yaWFuQ2FsZW5kYXJGb3JtYXRMaWJMb2NhbGVaaF9DTjJbJ2RlZmF1bHQnXSxcbiAgY2FsZW5kYXI6IF9ncmVnb3JpYW5DYWxlbmRhckxpYkxvY2FsZVpoX0NOMlsnZGVmYXVsdCddXG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmMtdGltZS1waWNrZXIvbGliL2xvY2FsZS96aF9DTi5qc1xuICoqIG1vZHVsZSBpZCA9IDIxMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENoZWNrYm94R3JvdXAgQ29tcG9uZW50IGZvciB1eGNvcmVcbiAqIEBhdXRob3IgZXRlcm5hbHNreVxuICpcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIFV4Y29yZSBUZWFtLCBBbGludy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL0NoZWNrYm94R3JvdXAnKTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWNoZWNrYm94LWdyb3VwL2J1aWxkL2luZGV4LmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBDaGVja2JveEdyb3VwIENvbXBvbmVudCBmb3IgdXhjb3JlXG4gKiBAYXV0aG9yIGV0ZXJuYWxza3lcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBVeGNvcmUgVGVhbSwgQWxpbncuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbnZhciBJdGVtID0gcmVxdWlyZShcIi4vQ2hlY2tib3hJdGVtXCIpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoXCJvYmplY3QtYXNzaWduXCIpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgQ2hlY2tib3hHcm91cCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzKENoZWNrYm94R3JvdXAsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gQ2hlY2tib3hHcm91cChwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2hlY2tib3hHcm91cCk7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuICAgIH1cblxuICAgIENoZWNrYm94R3JvdXAucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgbWUuc2VsZWN0ZWQgPSBtZS5fY29weShtZS5wcm9wcy52YWx1ZSkgfHwgW107XG4gICAgfTtcblxuICAgIENoZWNrYm94R3JvdXAucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgbWUuc2VsZWN0ZWQgPSBtZS5fY29weShtZS5wcm9wcy52YWx1ZSkgfHwgW107XG4gICAgfTtcblxuICAgIENoZWNrYm94R3JvdXAucHJvdG90eXBlLl9jb3B5ID0gZnVuY3Rpb24gX2NvcHkoYSkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShhKSk7XG4gICAgfTtcblxuICAgIENoZWNrYm94R3JvdXAucHJvdG90eXBlLl9wcm9jZXNzQ2hpbGQgPSBmdW5jdGlvbiBfcHJvY2Vzc0NoaWxkKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgbGVuZ3RoID0gUmVhY3QuQ2hpbGRyZW4uY291bnQobWUucHJvcHMuY2hpbGRyZW4pO1xuICAgICAgICBpZiAoIWxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBSZWFjdC5DaGlsZHJlbi5tYXAobWUucHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghIWNoaWxkLnR5cGUgJiYgY2hpbGQudHlwZS5kaXNwbGF5TmFtZSA9PSBcIkNoZWNrYm94SXRlbVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgICAgICAgICAgICAgICBqc3hkaXNhYmxlZDogbWUucHJvcHMuZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBtZS5faGFuZGxlQ2hhbmdlLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBjaGVja2VkOiBtZS5wcm9wcy52YWx1ZS5pbmRleE9mKGNoaWxkLnByb3BzLnZhbHVlKSAhPSAtMVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH07XG5cbiAgICBDaGVja2JveEdyb3VwLnByb3RvdHlwZS5faGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gX2hhbmRsZUNoYW5nZShjaGVja2VkLCB2YWx1ZSkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBpZiAoY2hlY2tlZCkge1xuICAgICAgICAgICAgLy8gbWUuc2VsZWN0ZWQgPSBtZS5zZWxlY3RlZC5jb25jYXQoW3ZhbHVlXSk7XG4gICAgICAgICAgICBtZS5zZWxlY3RlZC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLnNlbGVjdGVkID0gbWUuc2VsZWN0ZWQuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0gIT0gdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBtZS5wcm9wcy5vbkNoYW5nZShKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1lLnNlbGVjdGVkKSkpO1xuICAgIH07XG5cbiAgICBDaGVja2JveEdyb3VwLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBtZS5wcm9wcy5jbGFzc05hbWUgfSxcbiAgICAgICAgICAgIG1lLl9wcm9jZXNzQ2hpbGQoKVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ2hlY2tib3hHcm91cDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuQ2hlY2tib3hHcm91cC5JdGVtID0gSXRlbTtcblxuQ2hlY2tib3hHcm91cC5kZWZhdWx0UHJvcHMgPSB7XG4gICAgdmFsdWU6IFtdLFxuICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZSgpIHt9LFxuICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICBjbGFzc05hbWU6ICdrdW1hLWNoZWNrYm94LWdyb3VwJ1xufTtcblxuLy8gaHR0cDovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3JldXNhYmxlLWNvbXBvbmVudHMuaHRtbFxuQ2hlY2tib3hHcm91cC5wcm9wVHlwZXMgPSB7XG4gICAgdmFsdWU6IFJlYWN0LlByb3BUeXBlcy5hcnJheSxcbiAgICBvbkNoYW5nZTogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgZGlzYWJsZWQ6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGNsYXNzTmFtZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZ1xufTtcblxuQ2hlY2tib3hHcm91cC5kaXNwbGF5TmFtZSA9IFwiQ2hlY2tib3hHcm91cFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoZWNrYm94R3JvdXA7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1jaGVja2JveC1ncm91cC9idWlsZC9DaGVja2JveEdyb3VwLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIENoZWNrYm94SXRlbSA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzKENoZWNrYm94SXRlbSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBDaGVja2JveEl0ZW0ocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENoZWNrYm94SXRlbSk7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuICAgIH1cblxuICAgIENoZWNrYm94SXRlbS5wcm90b3R5cGUuX2hhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIF9oYW5kbGVDaGFuZ2UoZSkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBtZS5wcm9wcy5vbkNoYW5nZShlLmN1cnJlbnRUYXJnZXQuY2hlY2tlZCwgbWUucHJvcHMudmFsdWUpO1xuICAgIH07XG5cbiAgICBDaGVja2JveEl0ZW0ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIGRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIGlmICgnZGlzYWJsZWQnIGluIG1lLnByb3BzKSB7XG4gICAgICAgICAgICBkaXNhYmxlZCA9IG1lLnByb3BzLmRpc2FibGVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlzYWJsZWQgPSBtZS5wcm9wcy5qc3hkaXNhYmxlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdsYWJlbCcsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnaW5wdXQnLCB7IHR5cGU6ICdjaGVja2JveCcsIGRpc2FibGVkOiBkaXNhYmxlZCwgcmVmOiAnY2hlY2tib3gnLCBjaGVja2VkOiBtZS5wcm9wcy5jaGVja2VkLCBjbGFzc05hbWU6IG1lLnByb3BzLmNsYXNzTmFtZSwgb25DaGFuZ2U6IG1lLl9oYW5kbGVDaGFuZ2UuYmluZChtZSkgfSksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdzJywgbnVsbCksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdzcGFuJywgeyBkYW5nZXJvdXNseVNldElubmVySFRNTDogeyBfX2h0bWw6IG1lLnByb3BzLnRleHQgfSB9KVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ2hlY2tib3hJdGVtO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5DaGVja2JveEl0ZW0uZGVmYXVsdFByb3BzID0ge1xuICAgIHZhbHVlOiBcIlwiLFxuICAgIGNsYXNzTmFtZTogXCJrdW1hLWNoZWNrYm94XCIsXG4gICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKCkge31cbn07XG5cbkNoZWNrYm94SXRlbS5wcm9wVHlwZXMgPSB7XG4gICAgdmFsdWU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgZGlzYWJsZWQ6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGNsYXNzTmFtZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBvbkNoYW5nZTogUmVhY3QuUHJvcFR5cGVzLmZ1bmNcbn07XG5cbkNoZWNrYm94SXRlbS5kaXNwbGF5TmFtZSA9IFwiQ2hlY2tib3hJdGVtXCI7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2hlY2tib3hJdGVtO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtY2hlY2tib3gtZ3JvdXAvYnVpbGQvQ2hlY2tib3hJdGVtLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvbGxhcHNlIENvbXBvbmVudCBmb3IgdXhjb3JlXG4gKiBAYXV0aG9yIHZpY2VudC5iaWFuXG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgVXhjb3JlIFRlYW0sIEFsaW53LlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vQ29sbGFwc2UnKTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWNvbGxhcHNlL2J1aWxkL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcmVhY3REb20gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIF9yZWFjdERvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdERvbSk7XG5cbnZhciBfUGFuZWwgPSByZXF1aXJlKCcuL1BhbmVsJyk7XG5cbnZhciBfUGFuZWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUGFuZWwpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxudmFyIENvbGxhcHNlID0gKDAsIF9yZWFjdC5jcmVhdGVDbGFzcykoe1xuICBzdGF0aWNzOiB7XG4gICAgUGFuZWw6IF9QYW5lbDJbXCJkZWZhdWx0XCJdXG4gIH0sXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgcHJlZml4Q2xzOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBhY3RpdmVLZXk6IF9yZWFjdC5Qcm9wVHlwZXMub25lT2ZUeXBlKFtfcmVhY3QuUHJvcFR5cGVzLnN0cmluZywgX3JlYWN0LlByb3BUeXBlcy5hcnJheU9mKF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nKV0pLFxuICAgIGRlZmF1bHRBY3RpdmVLZXk6IF9yZWFjdC5Qcm9wVHlwZXMub25lT2ZUeXBlKFtfcmVhY3QuUHJvcFR5cGVzLnN0cmluZywgX3JlYWN0LlByb3BUeXBlcy5hcnJheU9mKF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nKV0pLFxuICAgIG9uQ2hhbmdlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgYWNjb3JkaW9uOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2xcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHJlZml4Q2xzOiAna3VtYS1jb2xsYXBzZScsXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoKSB7fSxcbiAgICAgIGFjY29yZGlvbjogZmFsc2VcbiAgICB9O1xuICB9LFxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgYWN0aXZlS2V5ID0gX3Byb3BzLmFjdGl2ZUtleTtcbiAgICB2YXIgYWNjb3JkaW9uID0gX3Byb3BzLmFjY29yZGlvbjtcbiAgICB2YXIgZGVmYXVsdEFjdGl2ZUtleSA9IHRoaXMucHJvcHMuZGVmYXVsdEFjdGl2ZUtleTtcbiAgICAvLyBJZiBpcyBub3QgYWNjb3JkaW9uIG1vZGUsIHRoZW4sIGRlZmF1bHRBY3RpdmVLZXkgc2hvdWxkIGJlIGFuIGFycmF5XG5cbiAgICBpZiAoIWFjY29yZGlvbikge1xuICAgICAgZGVmYXVsdEFjdGl2ZUtleSA9IGRlZmF1bHRBY3RpdmVLZXkgfHwgW107XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFjdGl2ZUtleTogYWN0aXZlS2V5IHx8IGRlZmF1bHRBY3RpdmVLZXlcbiAgICB9O1xuICB9LFxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIGlmICgnYWN0aXZlS2V5JyBpbiBuZXh0UHJvcHMpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBhY3RpdmVLZXk6IG5leHRQcm9wcy5hY3RpdmVLZXlcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgaGFuZGxlQ2xpY2tJdGVtOiBmdW5jdGlvbiBoYW5kbGVDbGlja0l0ZW0oa2V5KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYWN0aXZlS2V5ID0gX3RoaXMuX2dldEFjdGl2aXR5S2V5KCk7XG4gICAgICBpZiAoX3RoaXMucHJvcHMuYWNjb3JkaW9uKSB7XG4gICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBhY3RpdmVLZXk6IGtleSA9PT0gYWN0aXZlS2V5ID8gbnVsbCA6IGtleVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpbmRleCA9IGFjdGl2ZUtleS5pbmRleE9mKGtleSk7XG4gICAgICAgIHZhciBpc0FjdGl2ZSA9IGluZGV4ID4gLTE7XG4gICAgICAgIGlmIChpc0FjdGl2ZSkge1xuICAgICAgICAgIC8vIHJlbW92ZSBhY3RpdmUgc3RhdGVcbiAgICAgICAgICBhY3RpdmVLZXkuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhY3RpdmVLZXkucHVzaChrZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBhY3RpdmVLZXk6IGFjdGl2ZUtleSB9KTtcbiAgICAgIH1cbiAgICAgIF90aGlzLnByb3BzLm9uQ2hhbmdlKGtleSk7XG4gICAgfTtcbiAgfSxcbiAgX2dldEFjdGl2aXR5S2V5OiBmdW5jdGlvbiBfZ2V0QWN0aXZpdHlLZXkoKSB7XG4gICAgdmFyIGFjdGl2ZUtleSA9IHRoaXMuc3RhdGUuYWN0aXZlS2V5O1xuICAgIHZhciBhY2NvcmRpb24gPSB0aGlzLnByb3BzLmFjY29yZGlvbjtcblxuICAgIGlmIChhY2NvcmRpb24gJiYgQXJyYXkuaXNBcnJheShhY3RpdmVLZXkpKSB7XG4gICAgICBhY3RpdmVLZXkgPSBhY3RpdmVLZXlbMF07XG4gICAgfVxuXG4gICAgaWYgKCFhY2NvcmRpb24gJiYgIUFycmF5LmlzQXJyYXkoYWN0aXZlS2V5KSkge1xuICAgICAgYWN0aXZlS2V5ID0gYWN0aXZlS2V5ID8gW2FjdGl2ZUtleV0gOiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIGFjdGl2ZUtleTtcbiAgfSxcbiAgZ2V0SXRlbXM6IGZ1bmN0aW9uIGdldEl0ZW1zKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIGFjdGl2ZUtleSA9IHRoaXMuX2dldEFjdGl2aXR5S2V5KCk7XG4gICAgdmFyIF9wcm9wczIgPSB0aGlzLnByb3BzO1xuICAgIHZhciBwcmVmaXhDbHMgPSBfcHJvcHMyLnByZWZpeENscztcbiAgICB2YXIgYWNjb3JkaW9uID0gX3Byb3BzMi5hY2NvcmRpb247XG5cblxuICAgIHJldHVybiBfcmVhY3QuQ2hpbGRyZW4ubWFwKHRoaXMucHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCwgaW5kZXgpIHtcbiAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGtleSBwcm92aWRlLCB1c2UgdGhlIHBhbmVsIG9yZGVyIGFzIGRlZmF1bHQga2V5XG4gICAgICB2YXIga2V5ID0gY2hpbGQua2V5IHx8IGluZGV4O1xuICAgICAgdmFyIGhlYWRlciA9IGNoaWxkLnByb3BzLmhlYWRlcjtcbiAgICAgIHZhciBpc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgaWYgKGFjY29yZGlvbikge1xuICAgICAgICBpc0FjdGl2ZSA9IGFjdGl2ZUtleSA9PT0ga2V5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNBY3RpdmUgPSBhY3RpdmVLZXkuaW5kZXhPZihrZXkpID4gLTE7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIGhlYWRlcjogaGVhZGVyLFxuICAgICAgICBpc0FjdGl2ZTogaXNBY3RpdmUsXG4gICAgICAgIHByZWZpeENsczogcHJlZml4Q2xzLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGQucHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIG9uSXRlbUNsaWNrOiBfdGhpczIuaGFuZGxlQ2xpY2tJdGVtKGtleSkuYmluZChfdGhpczIpXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfUGFuZWwyW1wiZGVmYXVsdFwiXSwgcHJvcHMpO1xuICAgIH0pO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgcHJlZml4Q2xzID0gdGhpcy5wcm9wcy5wcmVmaXhDbHM7XG4gICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnZGl2JyxcbiAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgfSxcbiAgICAgIHRoaXMuZ2V0SXRlbXMoKVxuICAgICk7XG4gIH1cbn0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IENvbGxhcHNlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1jb2xsYXBzZS9idWlsZC9Db2xsYXBzZS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JlYWN0RG9tID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBfcmVhY3REb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3REb20pO1xuXG52YXIgX2NsYXNzbmFtZXMyID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xuXG52YXIgX2NsYXNzbmFtZXMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NuYW1lczIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxudmFyIENvbGxhcHNlUGFuZWwgPSAoMCwgX3JlYWN0LmNyZWF0ZUNsYXNzKSh7XG4gIHByb3BUeXBlczoge1xuICAgIHByZWZpeENsczogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgaGVhZGVyOiBfcmVhY3QuUHJvcFR5cGVzLm9uZU9mVHlwZShbX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsIF9yZWFjdC5Qcm9wVHlwZXMubnVtYmVyLCBfcmVhY3QuUHJvcFR5cGVzLm5vZGVdKSxcbiAgICBpc0FjdGl2ZTogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIG9uSXRlbUNsaWNrOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmNcbiAgfSxcblxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgICByZXR1cm4geyBpc0FjdGl2ZTogdGhpcy5wcm9wcy5pc0FjdGl2ZSB9O1xuICB9LFxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNBY3RpdmU6IGZhbHNlLFxuICAgICAgb25JdGVtQ2xpY2s6IGZ1bmN0aW9uIG9uSXRlbUNsaWNrKCkge31cbiAgICB9O1xuICB9LFxuICBoYW5kbGVJdGVtQ2xpY2s6IGZ1bmN0aW9uIGhhbmRsZUl0ZW1DbGljaygpIHtcbiAgICB0aGlzLnByb3BzLm9uSXRlbUNsaWNrKCk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfY2xhc3NuYW1lcztcblxuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBwcmVmaXhDbHMgPSBfcHJvcHMucHJlZml4Q2xzO1xuICAgIHZhciBoZWFkZXIgPSBfcHJvcHMuaGVhZGVyO1xuICAgIHZhciBjaGlsZHJlbiA9IF9wcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgaXNBY3RpdmUgPSBfcHJvcHMuaXNBY3RpdmU7XG5cbiAgICB2YXIgaGVhZGVyQ2xzID0gcHJlZml4Q2xzICsgJy1oZWFkZXInO1xuICAgIHZhciBjb250ZW50Q2xzID0gKDAsIF9jbGFzc25hbWVzM1tcImRlZmF1bHRcIl0pKChfY2xhc3NuYW1lcyA9IHt9LCBfY2xhc3NuYW1lc1twcmVmaXhDbHMgKyAnLWNvbnRlbnQnXSA9IHRydWUsIF9jbGFzc25hbWVzW3ByZWZpeENscyArICctY29udGVudC1hY3RpdmUnXSA9IGlzQWN0aXZlLCBfY2xhc3NuYW1lcykpO1xuXG4gICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnZGl2JyxcbiAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWl0ZW0nIH0sXG4gICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgeyBjbGFzc05hbWU6IGhlYWRlckNscywgb25DbGljazogdGhpcy5oYW5kbGVJdGVtQ2xpY2ssXG4gICAgICAgICAgcm9sZTogJ3RhYicsICdhcmlhLWV4cGFuZGVkJzogaXNBY3RpdmUgfSxcbiAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudCgnaScsIHsgY2xhc3NOYW1lOiAnYXJyb3cnIH0pLFxuICAgICAgICBoZWFkZXJcbiAgICAgICksXG4gICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgeyBjbGFzc05hbWU6IGNvbnRlbnRDbHMsXG4gICAgICAgICAgJ2RhdGEtYWN0aXZlJzogaXNBY3RpdmUsXG4gICAgICAgICAgcm9sZTogJ3RhYnBhbmVsJyB9LFxuICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICdkaXYnLFxuICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWNvbnRlbnQtYm94JyB9LFxuICAgICAgICAgIGNoaWxkcmVuXG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICB9XG59KTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBDb2xsYXBzZVBhbmVsO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1jb2xsYXBzZS9idWlsZC9QYW5lbC5qc1xuICoqLyIsIi8qKlxuICogQ29uc3QgQ29tcG9uZW50IGZvciB1eGNvcmVcbiAqIEBhdXRob3IgemhvdXF1YW4ueWV6cVxuICpcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIFV4Y29yZSBUZWFtLCBBbGludy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL0NvbnN0Jyk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1jb25zdC9zcmMvaW5kZXguanNcbiAqKi8iLCIvKipcbiAqIENvbnN0IENvbXBvbmVudCBmb3IgdXhjb3JlXG4gKiBAYXV0aG9yIHpob3VxdWFuLnllenFcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBVeGNvcmUgVGVhbSwgQWxpbncuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbnZhciBDb25zdD0ge1xuICBNT0RFOiB7XG4gICAgVklFVzogJ3ZpZXcnLFxuICAgIEVESVQ6ICdlZGl0J1xuICB9LFxuICBFTlYgOiB7XG4gICAgREVCVUc6ICdkZWJ1ZycsXG4gICAgTElWRTogJ2xpdmUnXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb25zdDtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtY29uc3Qvc3JjL0NvbnN0LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENydW1iIENvbXBvbmVudCBmb3IgdXhjb3JlXG4gKiBAYXV0aG9yIHBlaWppZS5kcGpcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBVeGNvcmUgVGVhbSwgQWxpbncuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9DcnVtYicpO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtY3J1bWIvYnVpbGQvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBDcnVtYiBDb21wb25lbnQgZm9yIHV4Y29yZVxuICogQGF1dGhvciBwZWlqaWUuZHBqXG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgVXhjb3JlIFRlYW0sIEFsaW53LlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG52YXIgQ3J1bWJJdGVtID0gcmVxdWlyZSgnLi9DcnVtYkl0ZW0nKTtcbnZhciBjbGFzc25hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgQ3J1bWIgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoQ3J1bWIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIENydW1iKHByb3BzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENydW1iKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ3J1bWIpLmNhbGwodGhpcywgcHJvcHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDcnVtYiwgW3tcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX2NsYXNzbmFtZXM7XG5cbiAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG5cbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgeyBjbGFzc05hbWU6IGNsYXNzbmFtZXMoKF9jbGFzc25hbWVzID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lcywgcHJvcHMucHJlZml4Q2xzLCB0cnVlKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc25hbWVzLCBwcm9wcy5jbGFzc05hbWUsICEhcHJvcHMuY2xhc3NOYW1lKSwgX2NsYXNzbmFtZXMpKSB9LFxuICAgICAgICBSZWFjdC5DaGlsZHJlbi5tYXAodGhpcy5wcm9wcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgIENydW1iSXRlbSxcbiAgICAgICAgICAgIGl0ZW0ucHJvcHMsXG4gICAgICAgICAgICBpdGVtLnByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENydW1iO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5DcnVtYi5kZWZhdWx0UHJvcHMgPSB7XG4gIHByZWZpeENsczogJ2t1bWEtdXhjcnVtYnMnXG59O1xuXG4vLyBodHRwOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvcmV1c2FibGUtY29tcG9uZW50cy5odG1sXG5DcnVtYi5wcm9wVHlwZXMgPSB7XG4gIHByZWZpeENsczogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgY2xhc3NOYW1lOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nXG59O1xuXG5DcnVtYi5JdGVtID0gQ3J1bWJJdGVtO1xuXG5DcnVtYi5kaXNwbGF5TmFtZSA9ICdDcnVtYic7XG5cbm1vZHVsZS5leHBvcnRzID0gQ3J1bWI7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1jcnVtYi9idWlsZC9DcnVtYi5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIENydW1iSXRlbSBDb21wb25lbnQgZm9yIHV4Y29yZVxuICogQGF1dGhvciBwZWlqaWUuZHBqXG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgVXhjb3JlIFRlYW0sIEFsaW53LlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG52YXIgY2xhc3NuYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIENydW1iSXRlbSA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhDcnVtYkl0ZW0sIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIENydW1iSXRlbShwcm9wcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDcnVtYkl0ZW0pO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihDcnVtYkl0ZW0pLmNhbGwodGhpcywgcHJvcHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDcnVtYkl0ZW0sIFt7XG4gICAga2V5OiAncmVuZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcblxuICAgICAgcmV0dXJuICFwcm9wcy5ocmVmID8gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ3NwYW4nLFxuICAgICAgICB7IGNsYXNzTmFtZTogY2xhc3NuYW1lcyhfZGVmaW5lUHJvcGVydHkoe30sIHByb3BzLmNsYXNzTmFtZSwgISFwcm9wcy5jbGFzc05hbWUpKSB9LFxuICAgICAgICBwcm9wcy5jaGlsZHJlblxuICAgICAgKSA6IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdhJyxcbiAgICAgICAgeyBocmVmOiBwcm9wcy5ocmVmLCBjbGFzc05hbWU6IHByb3BzLmNsYXNzTmFtZSB9LFxuICAgICAgICBwcm9wcy5jaGlsZHJlblxuICAgICAgKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ3J1bWJJdGVtO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5DcnVtYkl0ZW0uZGVmYXVsdFByb3BzID0ge307XG5cbi8vIGh0dHA6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy9yZXVzYWJsZS1jb21wb25lbnRzLmh0bWxcbkNydW1iSXRlbS5wcm9wVHlwZXMgPSB7XG4gIGhyZWY6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gIGNsYXNzTmFtZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZ1xufTtcblxuQ3J1bWJJdGVtLmRpc3BsYXlOYW1lID0gJ0NydW1iSXRlbSc7XG5cbm1vZHVsZS5leHBvcnRzID0gQ3J1bWJJdGVtO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtY3J1bWIvYnVpbGQvQ3J1bWJJdGVtLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERpYWxvZyBDb21wb25lbnQgZm9yIHV4Y29yZVxuICogQGF1dGhvciBcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBVeGNvcmUgVGVhbSwgQWxpbncuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9EaWFsb2cnKTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWRpYWxvZy9idWlsZC9pbmRleC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9yY0RpYWxvZyA9IHJlcXVpcmUoJ3JjLWRpYWxvZycpO1xuXG52YXIgX3JjRGlhbG9nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JjRGlhbG9nKTtcblxudmFyIF9jb25maXJtID0gcmVxdWlyZSgnLi9jb25maXJtJyk7XG5cbnZhciBfY29uZmlybTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb25maXJtKTtcblxudmFyIF91eGNvcmVCdXR0b24gPSByZXF1aXJlKCd1eGNvcmUtYnV0dG9uJyk7XG5cbnZhciBfdXhjb3JlQnV0dG9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V4Y29yZUJ1dHRvbik7XG5cbnZhciBfaTE4biA9IHJlcXVpcmUoJy4vaTE4bicpO1xuXG52YXIgX2kxOG4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaTE4bik7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH0gLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAYXV0aG9yOiB2aW5jZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZGF0ZTogMTUvNS8xOVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBEaWFsb2cgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhEaWFsb2csIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gRGlhbG9nKHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEaWFsb2cpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgY29uZmlybUxvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgdmlzaWJsZTogX3RoaXMucHJvcHMudmlzaWJsZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgRGlhbG9nLnByb3RvdHlwZS5oYW5kbGVDYW5jZWwgPSBmdW5jdGlvbiBoYW5kbGVDYW5jZWwoKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25DYW5jZWwoKTtcbiAgICB9O1xuXG4gICAgRGlhbG9nLnByb3RvdHlwZS5oYW5kbGVPayA9IGZ1bmN0aW9uIGhhbmRsZU9rKCkge1xuICAgICAgICB0aGlzLnByb3BzLm9uT2soKTtcbiAgICB9O1xuXG4gICAgRGlhbG9nLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBsb2NhbGUgPSBfaTE4bjJbXCJkZWZhdWx0XCJdW3Byb3BzLmxvY2FsZV07XG4gICAgICAgIHZhciBkZWZhdWx0Rm9vdGVyID0gW19yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBfdXhjb3JlQnV0dG9uMltcImRlZmF1bHRcIl0sXG4gICAgICAgICAgICB7IGtleTogJ2NvbmZpcm0nLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdwcmltYXJ5JyxcbiAgICAgICAgICAgICAgICBzaXplOiAnbWVkaXVtJyxcbiAgICAgICAgICAgICAgICBsb2FkaW5nOiBwcm9wcy5jb25maXJtTG9hZGluZyxcbiAgICAgICAgICAgICAgICBvbkNsaWNrOiB0aGlzLmhhbmRsZU9rLmJpbmQodGhpcykgfSxcbiAgICAgICAgICAgIGxvY2FsZVsnb2snXVxuICAgICAgICApLCBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgX3V4Y29yZUJ1dHRvbjJbXCJkZWZhdWx0XCJdLFxuICAgICAgICAgICAgeyBrZXk6ICdjYW5jZWwnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdzZWNvbmRhcnknLFxuICAgICAgICAgICAgICAgIHNpemU6ICdtZWRpdW0nLFxuICAgICAgICAgICAgICAgIG9uQ2xpY2s6IHRoaXMuaGFuZGxlQ2FuY2VsLmJpbmQodGhpcykgfSxcbiAgICAgICAgICAgIGxvY2FsZVsnY2FuY2VsJ11cbiAgICAgICAgKV07XG4gICAgICAgIHZhciBmb290ZXIgPSBwcm9wcy5mb290ZXIgfHwgZGVmYXVsdEZvb3RlcjtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IHZvaWQgMDtcbiAgICAgICAgaWYgKCFwcm9wcy50aXRsZSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lICsgJyAnICsgcHJvcHMucHJlZml4Q2xzICsgJy1ub2hlYWRlcic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2cocHJvcHMudGl0bGUsIGNsYXNzTmFtZSk7XG4gICAgICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9yY0RpYWxvZzJbXCJkZWZhdWx0XCJdLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgICBvbkNsb3NlOiB0aGlzLmhhbmRsZUNhbmNlbC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZm9vdGVyOiBmb290ZXJcbiAgICAgICAgfSwgcHJvcHMsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgICAgICAgdmlzaWJsZTogcHJvcHMudmlzaWJsZSB9KSk7XG4gICAgfTtcblxuICAgIHJldHVybiBEaWFsb2c7XG59KF9yZWFjdDJbXCJkZWZhdWx0XCJdLkNvbXBvbmVudCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gRGlhbG9nO1xuXG5cbkRpYWxvZy5kZWZhdWx0UHJvcHMgPSB7XG4gICAgcHJlZml4Q2xzOiAna3VtYS1kbGcnLFxuICAgIGNsYXNzTmFtZTogJycsXG4gICAgb25Pazogbm9vcCxcbiAgICBsb2NhbGU6ICd6aC1jbicsXG4gICAgb25DYW5jZWw6IG5vb3AsXG4gICAgd2lkdGg6IDUyMCxcbiAgICB0cmFuc2l0aW9uTmFtZTogJycsXG4gICAgbWFza0FuaW1hdGlvbjogZmFsc2UsXG4gICAgY29uZmlybUxvYWRpbmc6IGZhbHNlLFxuICAgIHZpc2libGU6IGZhbHNlLFxuICAgIGNsb3NhYmxlOiB0cnVlLFxuICAgIG1hc2tDbG9zYWJsZTogZmFsc2UsXG4gICAgdGl0bGU6ICcnXG59O1xuXG5EaWFsb2cuaW5mbyA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIHByb3BzLmljb25DbGFzc05hbWUgPSAna3VtYS1pY29uLWluZm9ybWF0aW9uJztcbiAgICBwcm9wcy5va0NhbmNlbCA9IGZhbHNlO1xuICAgIHJldHVybiAoMCwgX2NvbmZpcm0yW1wiZGVmYXVsdFwiXSkocHJvcHMpO1xufTtcblxuRGlhbG9nLnN1Y2Nlc3MgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICBwcm9wcy5pY29uQ2xhc3NOYW1lID0gJ2t1bWEtaWNvbi1zdWNjZXNzJztcbiAgICBwcm9wcy5va0NhbmNlbCA9IGZhbHNlO1xuICAgIHJldHVybiAoMCwgX2NvbmZpcm0yW1wiZGVmYXVsdFwiXSkocHJvcHMpO1xufTtcblxuRGlhbG9nLmVycm9yID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgcHJvcHMuaWNvbkNsYXNzTmFtZSA9ICdrdW1hLWljb24tZXJyb3InO1xuICAgIHByb3BzLm9rQ2FuY2VsID0gZmFsc2U7XG4gICAgcmV0dXJuICgwLCBfY29uZmlybTJbXCJkZWZhdWx0XCJdKShwcm9wcyk7XG59O1xuXG5EaWFsb2cuY29uZmlybSA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIHByb3BzLm9rQ2FuY2VsID0gdHJ1ZTtcbiAgICByZXR1cm4gKDAsIF9jb25maXJtMltcImRlZmF1bHRcIl0pKHByb3BzKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWRpYWxvZy9idWlsZC9EaWFsb2cuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9EaWFsb2dXcmFwJyk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1kaWFsb2cvfi9yYy1kaWFsb2cvbGliL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcmVhY3REb20gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIF9yZWFjdERvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdERvbSk7XG5cbnZhciBfRGlhbG9nID0gcmVxdWlyZSgnLi9EaWFsb2cnKTtcblxudmFyIF9EaWFsb2cyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRGlhbG9nKTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGNvcHkob2JqLCBmaWVsZHMpIHtcbiAgdmFyIHJldCA9IHt9O1xuICBmaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgIGlmIChvYmpbZl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0W2ZdID0gb2JqW2ZdO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXQ7XG59XG5cbnZhciBEaWFsb2dXcmFwID0gKGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhEaWFsb2dXcmFwLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBEaWFsb2dXcmFwKHByb3BzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEaWFsb2dXcmFwKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKERpYWxvZ1dyYXAucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuY2FsbCh0aGlzLCBwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHZpc2libGU6IHByb3BzLnZpc2libGVcbiAgICB9O1xuICAgIFsnb25DbG9zZScsICdjbGVhbkRpYWxvZ0NvbnRhaW5lciddLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICAgIF90aGlzW21dID0gX3RoaXNbbV0uYmluZChfdGhpcyk7XG4gICAgfSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRGlhbG9nV3JhcCwgW3tcbiAgICBrZXk6ICdjb21wb25lbnREaWRNb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgdGhpcy5jb21wb25lbnREaWRVcGRhdGUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhwcm9wcykge1xuICAgICAgaWYgKCd2aXNpYmxlJyBpbiBwcm9wcykge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICB2aXNpYmxlOiBwcm9wcy52aXNpYmxlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Nob3VsZENvbXBvbmVudFVwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSkge1xuICAgICAgcmV0dXJuICEhKHRoaXMuc3RhdGUudmlzaWJsZSB8fCBuZXh0U3RhdGUudmlzaWJsZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcG9uZW50RGlkVXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgaWYgKHRoaXMuZGlhbG9nUmVuZGVyZWQpIHtcbiAgICAgICAgdGhpcy5kaWFsb2dJbnN0YW5jZSA9IF9yZWFjdERvbTJbJ2RlZmF1bHQnXS51bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcih0aGlzLCB0aGlzLmdldERpYWxvZ0VsZW1lbnQoKSwgdGhpcy5nZXREaWFsb2dDb250YWluZXIoKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcG9uZW50V2lsbFVubW91bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIGlmICh0aGlzLmRpYWxvZ0NvbnRhaW5lcikge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS52aXNpYmxlKSB7XG4gICAgICAgICAgX3JlYWN0RG9tMlsnZGVmYXVsdCddLnVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHRoaXMsIHRoaXMuZ2V0RGlhbG9nRWxlbWVudCh7XG4gICAgICAgICAgICBvbkFmdGVyQ2xvc2U6IHRoaXMuY2xlYW5EaWFsb2dDb250YWluZXIsXG4gICAgICAgICAgICBvbkNsb3NlOiBub29wLFxuICAgICAgICAgICAgdmlzaWJsZTogZmFsc2VcbiAgICAgICAgICB9KSwgdGhpcy5kaWFsb2dDb250YWluZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY2xlYW5EaWFsb2dDb250YWluZXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uQ2xvc2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNsb3NlKGUpIHtcbiAgICAgIHRoaXMucHJvcHMub25DbG9zZShlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXREaWFsb2dDb250YWluZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREaWFsb2dDb250YWluZXIoKSB7XG4gICAgICBpZiAoIXRoaXMuZGlhbG9nQ29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuZGlhbG9nQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuZGlhbG9nQ29udGFpbmVyLmNsYXNzTmFtZSA9IHRoaXMucHJvcHMucHJlZml4Q2xzICsgJy1jb250YWluZXInO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuZGlhbG9nQ29udGFpbmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmRpYWxvZ0NvbnRhaW5lcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXREaWFsb2dFbGVtZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGlhbG9nRWxlbWVudChleHRyYSkge1xuICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciBkaWFsb2dQcm9wcyA9IGNvcHkocHJvcHMsIFsnY2xhc3NOYW1lJywgJ2Nsb3NhYmxlJywgJ21hc2tDbG9zYWJsZScsICdhbGlnbicsICd0aXRsZScsICdmb290ZXInLCAnbWFzaycsICdhbmltYXRpb24nLCAndHJhbnNpdGlvbk5hbWUnLCAnbWFza0FuaW1hdGlvbicsICdtYXNrVHJhbnNpdGlvbk5hbWUnLCAnbW91c2VQb3NpdGlvbicsICdwcmVmaXhDbHMnLCAnc3R5bGUnLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ3pJbmRleCcsICdib2R5U3R5bGUnXSk7XG4gICAgICBkaWFsb2dQcm9wcyA9IF9leHRlbmRzKHt9LCBkaWFsb2dQcm9wcywge1xuICAgICAgICBvbkNsb3NlOiB0aGlzLm9uQ2xvc2UsXG4gICAgICAgIHZpc2libGU6IHRoaXMuc3RhdGUudmlzaWJsZVxuICAgICAgfSwgZXh0cmEpO1xuICAgICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICBfRGlhbG9nMlsnZGVmYXVsdCddLFxuICAgICAgICBfZXh0ZW5kcyh7fSwgZGlhbG9nUHJvcHMsIHsga2V5OiAnZGlhbG9nJyB9KSxcbiAgICAgICAgcHJvcHMuY2hpbGRyZW5cbiAgICAgICk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0RWxlbWVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVsZW1lbnQocGFydCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGlhbG9nSW5zdGFuY2UuZ2V0RWxlbWVudChwYXJ0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjbGVhbkRpYWxvZ0NvbnRhaW5lcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFuRGlhbG9nQ29udGFpbmVyKCkge1xuICAgICAgX3JlYWN0RG9tMlsnZGVmYXVsdCddLnVubW91bnRDb21wb25lbnRBdE5vZGUodGhpcy5nZXREaWFsb2dDb250YWluZXIoKSk7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMuZGlhbG9nQ29udGFpbmVyKTtcbiAgICAgIHRoaXMuZGlhbG9nQ29udGFpbmVyID0gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB0aGlzLmRpYWxvZ1JlbmRlcmVkID0gdGhpcy5kaWFsb2dSZW5kZXJlZCB8fCB0aGlzLnN0YXRlLnZpc2libGU7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRGlhbG9nV3JhcDtcbn0pKF9yZWFjdDJbJ2RlZmF1bHQnXS5Db21wb25lbnQpO1xuXG5EaWFsb2dXcmFwLmRlZmF1bHRQcm9wcyA9IHtcbiAgY2xhc3NOYW1lOiAnJyxcbiAgYWxpZ246IHtcbiAgICBwb2ludHM6IFsndGMnLCAndGMnXSxcbiAgICBvZmZzZXQ6IFswLCAxMDBdXG4gIH0sXG4gIG1hc2s6IHRydWUsXG4gIGNsb3NhYmxlOiB0cnVlLFxuICBtYXNrQ2xvc2FibGU6IHRydWUsXG4gIHByZWZpeENsczogJ3JjLWRpYWxvZycsXG4gIG9uQ2xvc2U6IG5vb3Bcbn07XG5cbkRpYWxvZ1dyYXAucHJvcFR5cGVzID0ge1xuICBjbGFzc05hbWU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nLFxuICBhbGlnbjogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zaGFwZSh7XG4gICAgYWxpZ246IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYXJyYXksXG4gICAgb2Zmc2V0OiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmFycmF5T2YoX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5udW1iZXIpXG4gIH0pLFxuICBtYXNrOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmJvb2wsXG4gIGNsb3NhYmxlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmJvb2wsXG4gIG1hc2tDbG9zYWJsZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLFxuICBwcmVmaXhDbHM6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nLFxuICB2aXNpYmxlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmJvb2wsXG4gIG9uQ2xvc2U6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuY1xufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gRGlhbG9nV3JhcDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtZGlhbG9nL34vcmMtZGlhbG9nL2xpYi9EaWFsb2dXcmFwLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcmVhY3REb20gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIF9yZWFjdERvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdERvbSk7XG5cbnZhciBfcmNBbGlnbiA9IHJlcXVpcmUoJ3JjLWFsaWduJyk7XG5cbnZhciBfcmNBbGlnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yY0FsaWduKTtcblxudmFyIF9yY1V0aWxMaWJLZXlDb2RlID0gcmVxdWlyZSgncmMtdXRpbC9saWIvS2V5Q29kZScpO1xuXG52YXIgX3JjVXRpbExpYktleUNvZGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmNVdGlsTGliS2V5Q29kZSk7XG5cbnZhciBfcmNBbmltYXRlID0gcmVxdWlyZSgncmMtYW5pbWF0ZScpO1xuXG52YXIgX3JjQW5pbWF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yY0FuaW1hdGUpO1xuXG52YXIgX0RPTVdyYXAgPSByZXF1aXJlKCcuL0RPTVdyYXAnKTtcblxudmFyIF9ET01XcmFwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RPTVdyYXApO1xuXG52YXIgX2NsYXNzbmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG5cbnZhciBfY2xhc3NuYW1lczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc25hbWVzKTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGdldFNjcm9sbCh3LCB0b3ApIHtcbiAgdmFyIHJldCA9IHdbJ3BhZ2UnICsgKHRvcCA/ICdZJyA6ICdYJykgKyAnT2Zmc2V0J107XG4gIHZhciBtZXRob2QgPSAnc2Nyb2xsJyArICh0b3AgPyAnVG9wJyA6ICdMZWZ0Jyk7XG4gIGlmICh0eXBlb2YgcmV0ICE9PSAnbnVtYmVyJykge1xuICAgIHZhciBkID0gdy5kb2N1bWVudDtcbiAgICByZXQgPSBkLmRvY3VtZW50RWxlbWVudFttZXRob2RdO1xuICAgIGlmICh0eXBlb2YgcmV0ICE9PSAnbnVtYmVyJykge1xuICAgICAgcmV0ID0gZC5ib2R5W21ldGhvZF07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHNldFRyYW5zZm9ybU9yaWdpbihub2RlLCB2YWx1ZSkge1xuICB2YXIgc3R5bGUgPSBub2RlLnN0eWxlO1xuICBbJ1dlYmtpdCcsICdNb3onLCAnTXMnLCAnbXMnXS5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICBzdHlsZVtwcmVmaXggKyAnVHJhbnNmb3JtT3JpZ2luJ10gPSB2YWx1ZTtcbiAgfSk7XG4gIHN0eWxlWyd0cmFuc2Zvcm1PcmlnaW4nXSA9IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBvZmZzZXQoZWwpIHtcbiAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHBvcyA9IHtcbiAgICBsZWZ0OiByZWN0LmxlZnQsXG4gICAgdG9wOiByZWN0LnRvcFxuICB9O1xuICB2YXIgZG9jID0gZWwub3duZXJEb2N1bWVudDtcbiAgdmFyIHcgPSBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgcG9zLmxlZnQgKz0gZ2V0U2Nyb2xsKHcpO1xuICBwb3MudG9wICs9IGdldFNjcm9sbCh3LCAxKTtcbiAgcmV0dXJuIHBvcztcbn1cblxudmFyIERpYWxvZyA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnRGlhbG9nJyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBvbkFmdGVyQ2xvc2U6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNsb3NlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgY2xvc2FibGU6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBtYXNrQ2xvc2FibGU6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICB2aXNpYmxlOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgbW91c2VQb3NpdGlvbjogX3JlYWN0LlByb3BUeXBlcy5vYmplY3RcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb25BZnRlckNsb3NlOiBub29wLFxuICAgICAgb25DbG9zZTogbm9vcFxuICAgIH07XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuY29tcG9uZW50RGlkVXBkYXRlKHt9KTtcbiAgfSxcblxuICBjb21wb25lbnREaWRVcGRhdGU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIGlmIChwcm9wcy52aXNpYmxlKSB7XG4gICAgICAvLyBmaXJzdCBzaG93XG4gICAgICBpZiAoIXByZXZQcm9wcy52aXNpYmxlKSB7XG4gICAgICAgIHRoaXMubGFzdE91dFNpZGVGb2N1c05vZGUgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICBfcmVhY3REb20yWydkZWZhdWx0J10uZmluZERPTU5vZGUodGhpcy5yZWZzLmRpYWxvZykuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByZXZQcm9wcy52aXNpYmxlKSB7XG4gICAgICBpZiAocHJvcHMubWFzayAmJiB0aGlzLmxhc3RPdXRTaWRlRm9jdXNOb2RlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5sYXN0T3V0U2lkZUZvY3VzTm9kZS5mb2N1cygpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhpcy5sYXN0T3V0U2lkZUZvY3VzTm9kZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0T3V0U2lkZUZvY3VzTm9kZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIG9uQW5pbWF0ZUxlYXZlOiBmdW5jdGlvbiBvbkFuaW1hdGVMZWF2ZSgpIHtcbiAgICB0aGlzLnByb3BzLm9uQWZ0ZXJDbG9zZSgpO1xuICB9LFxuXG4gIG9uTWFza0NsaWNrOiBmdW5jdGlvbiBvbk1hc2tDbGljayhlKSB7XG4gICAgaWYgKHRoaXMucHJvcHMuY2xvc2FibGUgJiYgdGhpcy5wcm9wcy5tYXNrQ2xvc2FibGUpIHtcbiAgICAgIHRoaXMuY2xvc2UoZSk7XG4gICAgfVxuICAgIF9yZWFjdERvbTJbJ2RlZmF1bHQnXS5maW5kRE9NTm9kZSh0aGlzLnJlZnMuZGlhbG9nKS5mb2N1cygpO1xuICB9LFxuXG4gIG9uS2V5RG93bjogZnVuY3Rpb24gb25LZXlEb3duKGUpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIGlmIChwcm9wcy5jbG9zYWJsZSkge1xuICAgICAgaWYgKGUua2V5Q29kZSA9PT0gX3JjVXRpbExpYktleUNvZGUyWydkZWZhdWx0J10uRVNDKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGtlZXAgZm9jdXMgaW5zaWRlIGRpYWxvZ1xuICAgIGlmIChwcm9wcy52aXNpYmxlKSB7XG4gICAgICBpZiAoZS5rZXlDb2RlID09PSBfcmNVdGlsTGliS2V5Q29kZTJbJ2RlZmF1bHQnXS5UQUIpIHtcbiAgICAgICAgdmFyIGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICB2YXIgZGlhbG9nUm9vdCA9IF9yZWFjdERvbTJbJ2RlZmF1bHQnXS5maW5kRE9NTm9kZSh0aGlzLnJlZnMuZGlhbG9nKTtcbiAgICAgICAgdmFyIHNlbnRpbmVsID0gdGhpcy5yZWZzLnNlbnRpbmVsO1xuICAgICAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgICAgIGlmIChhY3RpdmVFbGVtZW50ID09PSBkaWFsb2dSb290KSB7XG4gICAgICAgICAgICBzZW50aW5lbC5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChhY3RpdmVFbGVtZW50ID09PSB0aGlzLnJlZnMuc2VudGluZWwpIHtcbiAgICAgICAgICBkaWFsb2dSb290LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgb25BbGlnbjogZnVuY3Rpb24gb25BbGlnbihkaWFsb2dOb2RlKSB7XG4gICAgdmFyIG1vdXNlUG9zaXRpb24gPSB0aGlzLnByb3BzLm1vdXNlUG9zaXRpb247XG4gICAgaWYgKHRoaXMucHJvcHMudmlzaWJsZSkge1xuICAgICAgaWYgKG1vdXNlUG9zaXRpb24pIHtcbiAgICAgICAgdmFyIGVsT2Zmc2V0ID0gb2Zmc2V0KGRpYWxvZ05vZGUpO1xuICAgICAgICBzZXRUcmFuc2Zvcm1PcmlnaW4oZGlhbG9nTm9kZSwgbW91c2VQb3NpdGlvbi54IC0gZWxPZmZzZXQubGVmdCArICdweCAnICsgKG1vdXNlUG9zaXRpb24ueSAtIGVsT2Zmc2V0LnRvcCkgKyAncHgnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRyYW5zZm9ybU9yaWdpbihkaWFsb2dOb2RlLCAnJyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGdldERpYWxvZ0VsZW1lbnQ6IGZ1bmN0aW9uIGdldERpYWxvZ0VsZW1lbnQoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgY2xvc2FibGUgPSBwcm9wcy5jbG9zYWJsZTtcbiAgICB2YXIgcHJlZml4Q2xzID0gcHJvcHMucHJlZml4Q2xzO1xuICAgIHZhciBkZXN0ID0ge307XG4gICAgaWYgKHByb3BzLndpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlc3Qud2lkdGggPSBwcm9wcy53aWR0aDtcbiAgICB9XG4gICAgaWYgKHByb3BzLmhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZXN0LmhlaWdodCA9IHByb3BzLmhlaWdodDtcbiAgICB9XG4gICAgaWYgKHByb3BzLnpJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZXN0LnpJbmRleCA9IHByb3BzLnpJbmRleDtcbiAgICB9XG5cbiAgICB2YXIgZm9vdGVyID0gdW5kZWZpbmVkO1xuICAgIGlmIChwcm9wcy5mb290ZXIpIHtcbiAgICAgIGZvb3RlciA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctZm9vdGVyJywgcmVmOiAnZm9vdGVyJyB9LFxuICAgICAgICBwcm9wcy5mb290ZXJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGhlYWRlciA9IHVuZGVmaW5lZDtcbiAgICBpZiAocHJvcHMudGl0bGUpIHtcbiAgICAgIGhlYWRlciA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctaGVhZGVyJywgcmVmOiAnaGVhZGVyJyB9LFxuICAgICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy10aXRsZScgfSxcbiAgICAgICAgICBwcm9wcy50aXRsZVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBjbG9zZXIgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGNsb3NhYmxlKSB7XG4gICAgICBjbG9zZXIgPSBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2EnLFxuICAgICAgICB7IHRhYkluZGV4OiAnMCcsIG9uQ2xpY2s6IHRoaXMuY2xvc2UsIGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1jbG9zZScgfSxcbiAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nLCB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1jbG9zZS14JyB9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGUgPSBfZXh0ZW5kcyh7fSwgcHJvcHMuc3R5bGUsIGRlc3QpO1xuICAgIHZhciBkaWFsb2dQcm9wcyA9IHtcbiAgICAgIGNsYXNzTmFtZTogW3Byb3BzLnByZWZpeENscywgcHJvcHMuY2xhc3NOYW1lXS5qb2luKCcgJyksXG4gICAgICB0YWJJbmRleDogJzAnLFxuICAgICAgcm9sZTogJ2RpYWxvZycsXG4gICAgICByZWY6ICdkaWFsb2cnLFxuICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgb25LZXlEb3duOiB0aGlzLm9uS2V5RG93blxuICAgIH07XG4gICAgdmFyIHRyYW5zaXRpb25OYW1lID0gdGhpcy5nZXRUcmFuc2l0aW9uTmFtZSgpO1xuICAgIHZhciBkaWFsb2dFbGVtZW50ID0gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBfRE9NV3JhcDJbJ2RlZmF1bHQnXSxcbiAgICAgIF9leHRlbmRzKHt9LCBkaWFsb2dQcm9wcywge1xuICAgICAgICBoaWRkZW5DbGFzc05hbWU6IHByZWZpeENscyArICctaGlkZGVuJyB9KSxcbiAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctY29udGVudCcgfSxcbiAgICAgICAgY2xvc2VyLFxuICAgICAgICBoZWFkZXIsXG4gICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICdkaXYnLFxuICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWJvZHknLCBzdHlsZTogcHJvcHMuYm9keVN0eWxlLCByZWY6ICdib2R5JyB9LFxuICAgICAgICAgIHByb3BzLmNoaWxkcmVuXG4gICAgICAgICksXG4gICAgICAgIGZvb3RlclxuICAgICAgKSxcbiAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgeyB0YWJJbmRleDogJzAnLCByZWY6ICdzZW50aW5lbCcsIHN0eWxlOiB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAsIG92ZXJmbG93OiAnaGlkZGVuJyB9IH0sXG4gICAgICAgICdzZW50aW5lbCdcbiAgICAgIClcbiAgICApO1xuICAgIC8vIGFkZCBrZXkgZm9yIGFsaWduIHRvIGtlZXAgYW5pbWF0ZSBjaGlsZHJlbiBzdGFibGVcbiAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBfcmNBbmltYXRlMlsnZGVmYXVsdCddLFxuICAgICAgeyBrZXk6ICdkaWFsb2cnLFxuICAgICAgICBzaG93UHJvcDogJ2RpYWxvZ1Zpc2libGUnLFxuICAgICAgICBvbkxlYXZlOiB0aGlzLm9uQW5pbWF0ZUxlYXZlLFxuICAgICAgICB0cmFuc2l0aW9uTmFtZTogdHJhbnNpdGlvbk5hbWUsXG4gICAgICAgIGNvbXBvbmVudDogJycsXG4gICAgICAgIHRyYW5zaXRpb25BcHBlYXI6IHRydWUgfSxcbiAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICBfcmNBbGlnbjJbJ2RlZmF1bHQnXSxcbiAgICAgICAgeyBhbGlnbjogcHJvcHMuYWxpZ24sXG4gICAgICAgICAga2V5OiAnZGlhbG9nJyxcbiAgICAgICAgICBvbkFsaWduOiB0aGlzLm9uQWxpZ24sXG4gICAgICAgICAgZGlhbG9nVmlzaWJsZTogcHJvcHMudmlzaWJsZSxcbiAgICAgICAgICBjaGlsZHJlblByb3BzOiB7XG4gICAgICAgICAgICB2aXNpYmxlOiAnZGlhbG9nVmlzaWJsZSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1vbml0b3JCdWZmZXJUaW1lOiA4MCxcbiAgICAgICAgICBtb25pdG9yV2luZG93UmVzaXplOiB0cnVlLFxuICAgICAgICAgIGRpc2FibGVkOiAhcHJvcHMudmlzaWJsZSB9LFxuICAgICAgICBkaWFsb2dFbGVtZW50XG4gICAgICApXG4gICAgKTtcbiAgfSxcblxuICBnZXRNYXNrRWxlbWVudDogZnVuY3Rpb24gZ2V0TWFza0VsZW1lbnQoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgbWFza1Byb3BzID0ge1xuICAgICAgb25DbGljazogdGhpcy5vbk1hc2tDbGlja1xuICAgIH07XG5cbiAgICBpZiAocHJvcHMuekluZGV4KSB7XG4gICAgICBtYXNrUHJvcHMuc3R5bGUgPSB7IHpJbmRleDogcHJvcHMuekluZGV4IH07XG4gICAgfVxuICAgIHZhciBtYXNrRWxlbWVudCA9IHVuZGVmaW5lZDtcbiAgICBpZiAocHJvcHMubWFzaykge1xuICAgICAgdmFyIG1hc2tUcmFuc2l0aW9uID0gdGhpcy5nZXRNYXNrVHJhbnNpdGlvbk5hbWUoKTtcbiAgICAgIG1hc2tFbGVtZW50ID0gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoX0RPTVdyYXAyWydkZWZhdWx0J10sIF9leHRlbmRzKHt9LCBtYXNrUHJvcHMsIHsga2V5OiAnbWFzaycsXG4gICAgICAgIGNsYXNzTmFtZTogcHJvcHMucHJlZml4Q2xzICsgJy1tYXNrJyxcbiAgICAgICAgdmlzaWJsZTogcHJvcHMudmlzaWJsZSxcbiAgICAgICAgaGlkZGVuQ2xhc3NOYW1lOiBwcm9wcy5wcmVmaXhDbHMgKyAnLW1hc2staGlkZGVuJyB9KSk7XG4gICAgICBpZiAobWFza1RyYW5zaXRpb24pIHtcbiAgICAgICAgbWFza0VsZW1lbnQgPSBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICBfcmNBbmltYXRlMlsnZGVmYXVsdCddLFxuICAgICAgICAgIHsga2V5OiAnbWFzaycsIHNob3dQcm9wOiAndmlzaWJsZScsXG4gICAgICAgICAgICB0cmFuc2l0aW9uQXBwZWFyOiB0cnVlLCBjb21wb25lbnQ6ICcnLFxuICAgICAgICAgICAgdHJhbnNpdGlvbk5hbWU6IG1hc2tUcmFuc2l0aW9uIH0sXG4gICAgICAgICAgbWFza0VsZW1lbnRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hc2tFbGVtZW50O1xuICB9LFxuXG4gIGdldE1hc2tUcmFuc2l0aW9uTmFtZTogZnVuY3Rpb24gZ2V0TWFza1RyYW5zaXRpb25OYW1lKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHRyYW5zaXRpb25OYW1lID0gcHJvcHMubWFza1RyYW5zaXRpb25OYW1lO1xuICAgIHZhciBhbmltYXRpb24gPSBwcm9wcy5tYXNrQW5pbWF0aW9uO1xuICAgIGlmICghdHJhbnNpdGlvbk5hbWUgJiYgYW5pbWF0aW9uKSB7XG4gICAgICB0cmFuc2l0aW9uTmFtZSA9IHByb3BzLnByZWZpeENscyArICctJyArIGFuaW1hdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zaXRpb25OYW1lO1xuICB9LFxuXG4gIGdldFRyYW5zaXRpb25OYW1lOiBmdW5jdGlvbiBnZXRUcmFuc2l0aW9uTmFtZSgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciB0cmFuc2l0aW9uTmFtZSA9IHByb3BzLnRyYW5zaXRpb25OYW1lO1xuICAgIHZhciBhbmltYXRpb24gPSBwcm9wcy5hbmltYXRpb247XG4gICAgaWYgKCF0cmFuc2l0aW9uTmFtZSAmJiBhbmltYXRpb24pIHtcbiAgICAgIHRyYW5zaXRpb25OYW1lID0gcHJvcHMucHJlZml4Q2xzICsgJy0nICsgYW5pbWF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNpdGlvbk5hbWU7XG4gIH0sXG5cbiAgZ2V0RWxlbWVudDogZnVuY3Rpb24gZ2V0RWxlbWVudChwYXJ0KSB7XG4gICAgcmV0dXJuIHRoaXMucmVmc1twYXJ0XTtcbiAgfSxcblxuICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoZSkge1xuICAgIHRoaXMucHJvcHMub25DbG9zZShlKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBwcmVmaXhDbHMgPSBwcm9wcy5wcmVmaXhDbHM7XG4gICAgdmFyIGNsYXNzTmFtZSA9IF9kZWZpbmVQcm9wZXJ0eSh7fSwgcHJlZml4Q2xzICsgJy13cmFwJywgMSk7XG5cbiAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnZGl2JyxcbiAgICAgIHsgY2xhc3NOYW1lOiAoMCwgX2NsYXNzbmFtZXMyWydkZWZhdWx0J10pKGNsYXNzTmFtZSksIHJlZjogJ3Jvb3QnIH0sXG4gICAgICBbdGhpcy5nZXRNYXNrRWxlbWVudCgpLCB0aGlzLmdldERpYWxvZ0VsZW1lbnQoKV1cbiAgICApO1xuICB9XG59KTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gRGlhbG9nO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1kaWFsb2cvfi9yYy1kaWFsb2cvbGliL0RpYWxvZy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgRE9NV3JhcCA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnRE9NV3JhcCcsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgdGFnOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLnN0cmluZ1xuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0YWc6ICdkaXYnXG4gICAgfTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgcHJvcHMgPSBfZXh0ZW5kcyh7fSwgdGhpcy5wcm9wcyk7XG4gICAgaWYgKCFwcm9wcy52aXNpYmxlKSB7XG4gICAgICBwcm9wcy5jbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUgfHwgJyc7XG4gICAgICBwcm9wcy5jbGFzc05hbWUgKz0gJyAnICsgcHJvcHMuaGlkZGVuQ2xhc3NOYW1lO1xuICAgIH1cbiAgICB2YXIgVGFnID0gcHJvcHMudGFnO1xuICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChUYWcsIHByb3BzKTtcbiAgfVxufSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IERPTVdyYXA7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWRpYWxvZy9+L3JjLWRpYWxvZy9saWIvRE9NV3JhcC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuXG4gICAgdmFyIGQgPSB2b2lkIDA7XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICBwcm9wcy5pY29uQ2xhc3NOYW1lID0gcHJvcHMuaWNvbkNsYXNzTmFtZSB8fCAna3VtYS1pY29uLWNhdXRpb24nO1xuICAgIHZhciB3aWR0aCA9IHByb3BzLndpZHRoIHx8IDMwMDtcblxuICAgIHByb3BzLmxvY2FsZSA9IHByb3BzLmxvY2FsZSB8fCAnemgtY24nO1xuICAgIHZhciBsb2NhbGUgPSBfaTE4bjJbXCJkZWZhdWx0XCJdW3Byb3BzLmxvY2FsZV07XG5cbiAgICAvLyDpu5jorqTkuLogdHJ1Ze+8jOS/neaMgeWQkeS4i+WFvOWuuVxuICAgIGlmICghKCdva0NhbmNlbCcgaW4gcHJvcHMpKSB7XG4gICAgICAgIHByb3BzLm9rQ2FuY2VsID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgZC5zZXRTdGF0ZSh7XG4gICAgICAgICAgICB2aXNpYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgX3JlYWN0RG9tMltcImRlZmF1bHRcIl0udW5tb3VudENvbXBvbmVudEF0Tm9kZShkaXYpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRpdik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25DYW5jZWwoKSB7XG4gICAgICAgIHZhciBjYW5jZWxGbiA9IHByb3BzLm9uQ2FuY2VsO1xuICAgICAgICBpZiAoY2FuY2VsRm4pIHtcbiAgICAgICAgICAgIHZhciByZXQgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoY2FuY2VsRm4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gY2FuY2VsRm4oY2xvc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXQgPSBjYW5jZWxGbigpO1xuICAgICAgICAgICAgICAgIGlmICghcmV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJldCAmJiByZXQudGhlbikge1xuICAgICAgICAgICAgICAgIHJldC50aGVuKGNsb3NlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbk9rKCkge1xuICAgICAgICB2YXIgb2tGbiA9IHByb3BzLm9uT2s7XG4gICAgICAgIGlmIChva0ZuKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKG9rRm4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gb2tGbihjbG9zZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldCA9IG9rRm4oKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJldCkge1xuICAgICAgICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXQgJiYgcmV0LnRoZW4pIHtcbiAgICAgICAgICAgICAgICByZXQudGhlbihjbG9zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGJvZHkgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgeyBjbGFzc05hbWU6ICdrdW1hLWNvbmZpcm0tYm9keScgfSxcbiAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudCgnaScsIHsgY2xhc3NOYW1lOiAna3VtYS1pY29uICcgKyBwcm9wcy5pY29uQ2xhc3NOYW1lIH0pLFxuICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdrdW1hLWNvbmZpcm0tdGl0bGUnIH0sXG4gICAgICAgICAgICBwcm9wcy50aXRsZVxuICAgICAgICApLFxuICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2t1bWEtY29uZmlybS1jb250ZW50JyB9LFxuICAgICAgICAgICAgcHJvcHMuY29udGVudFxuICAgICAgICApXG4gICAgKTtcbiAgICB2YXIgZm9vdGVyID0gdm9pZCAwO1xuXG4gICAgaWYgKHByb3BzLm9rQ2FuY2VsKSB7XG4gICAgICAgIGZvb3RlciA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAna3VtYS1jb25maXJtLWFjdGlvbicgfSxcbiAgICAgICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgX3V4Y29yZUJ1dHRvbjJbXCJkZWZhdWx0XCJdLFxuICAgICAgICAgICAgICAgIHsgc2l6ZTogcHJvcHMuYnV0dG9uU2l6ZSB8fCBcInNtYWxsXCIsIG9uQ2xpY2s6IG9uT2sgfSxcbiAgICAgICAgICAgICAgICBsb2NhbGVbJ29rJ11cbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgIF91eGNvcmVCdXR0b24yW1wiZGVmYXVsdFwiXSxcbiAgICAgICAgICAgICAgICB7IHR5cGU6ICdzZWNvbmRhcnknLCBzaXplOiBwcm9wcy5idXR0b25TaXplIHx8IFwic21hbGxcIiwgb25DbGljazogb25DYW5jZWwgfSxcbiAgICAgICAgICAgICAgICBsb2NhbGVbJ2NhbmNlbCddXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9vdGVyID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdrdW1hLWNvbmZpcm0tYWN0aW9uJyB9LFxuICAgICAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICBfdXhjb3JlQnV0dG9uMltcImRlZmF1bHRcIl0sXG4gICAgICAgICAgICAgICAgeyBzaXplOiBwcm9wcy5idXR0b25TaXplIHx8IFwic21hbGxcIiwgb25DbGljazogb25PayB9LFxuICAgICAgICAgICAgICAgIGxvY2FsZVsnaXNlZSddXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgX3JlYWN0RG9tMltcImRlZmF1bHRcIl0ucmVuZGVyKF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIF9EaWFsb2cyW1wiZGVmYXVsdFwiXSxcbiAgICAgICAge1xuICAgICAgICAgICAgcHJlZml4Q2xzOiAna3VtYS1kbGcnLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAna3VtYS1kbGctY29uZmlybScsXG4gICAgICAgICAgICBvbkNhbmNlbDogb25DYW5jZWwsXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgY2xvc2FibGU6IHRydWUsXG4gICAgICAgICAgICB0aXRsZTogJycsXG4gICAgICAgICAgICBmb290ZXI6ICcnLFxuICAgICAgICAgICAgdHJhbnNpdGlvbk5hbWU6IHByb3BzLnRyYW5zaXRpb25OYW1lIHx8IFwidGhyZWVGYWxsVlwiLFxuICAgICAgICAgICAgbWFza1RyYW5zaXRpb25OYW1lOiBwcm9wcy50cmFuc2l0aW9uTmFtZSB8fCBcImZhZGVcIiwgd2lkdGg6IHdpZHRoIH0sXG4gICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgJyAnLFxuICAgICAgICAgICAgZm9vdGVyXG4gICAgICAgIClcbiAgICApLCBkaXYsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZCA9IHRoaXM7XG4gICAgfSk7XG59O1xuXG52YXIgX3V4Y29yZUJ1dHRvbiA9IHJlcXVpcmUoJ3V4Y29yZS1idXR0b24nKTtcblxudmFyIF91eGNvcmVCdXR0b24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXhjb3JlQnV0dG9uKTtcblxudmFyIF9EaWFsb2cgPSByZXF1aXJlKCcuL0RpYWxvZycpO1xuXG52YXIgX0RpYWxvZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EaWFsb2cpO1xuXG52YXIgX2kxOG4gPSByZXF1aXJlKCcuL2kxOG4nKTtcblxudmFyIF9pMThuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2kxOG4pO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcmVhY3REb20gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIF9yZWFjdERvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdERvbSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWRpYWxvZy9idWlsZC9jb25maXJtLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAnemgtY24nOiB7XG4gICAgICAgICdvayc6ICfnoa7lrponLFxuICAgICAgICAnY2FuY2VsJzogJ+WPlua2iCcsXG4gICAgICAgICdpc2VlJzogJ+efpemBk+S6hidcbiAgICB9LFxuICAgICdlbi11cyc6IHtcbiAgICAgICAgJ29rJzogJ29rJyxcbiAgICAgICAgJ2NhbmNlbCc6ICdjYW5jZWwnLFxuICAgICAgICAnaXNlZSc6ICdvaydcbiAgICB9XG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtZGlhbG9nL2J1aWxkL2kxOG4uanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRHJvcGRvd24gQ29tcG9uZW50IGZvciB1eGNvcmVcbiAqIEBhdXRob3IgXG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgVXhjb3JlIFRlYW0sIEFsaW53LlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vRHJvcGRvd24nKTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWRyb3Bkb3duL2J1aWxkL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JjRHJvcGRvd24gPSByZXF1aXJlKCdyYy1kcm9wZG93bicpO1xuXG52YXIgX3JjRHJvcGRvd24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmNEcm9wZG93bik7XG5cbnZhciBfb2JqZWN0QXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgX29iamVjdEFzc2lnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vYmplY3RBc3NpZ24pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgRHJvcGRvd24gPSBmdW5jdGlvbiAoX1JjRHJvcGRvd24pIHtcblx0X2luaGVyaXRzKERyb3Bkb3duLCBfUmNEcm9wZG93bik7XG5cblx0ZnVuY3Rpb24gRHJvcGRvd24ocHJvcHMpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHJvcGRvd24pO1xuXG5cdFx0cmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SY0Ryb3Bkb3duLmNhbGwodGhpcywgcHJvcHMpKTtcblx0fVxuXG5cdHJldHVybiBEcm9wZG93bjtcbn0oX3JjRHJvcGRvd24yW1wiZGVmYXVsdFwiXSk7XG5cbkRyb3Bkb3duLmRpc3BsYXlOYW1lID0gJ3V4Y29yZS1kcm9wZG93bic7XG5Ecm9wZG93bi5wcm9wVHlwZXMgPSBfcmNEcm9wZG93bjJbXCJkZWZhdWx0XCJdLnByb3BUeXBlcztcbkRyb3Bkb3duLmRlZmF1bHRQcm9wcyA9ICgwLCBfb2JqZWN0QXNzaWduMltcImRlZmF1bHRcIl0pKF9yY0Ryb3Bkb3duMltcImRlZmF1bHRcIl0uZGVmYXVsdFByb3BzLCB7XG5cdHByZWZpeENsczogJ2t1bWEtZHJvcGRvd24nLFxuXHRvdmVybGF5Q2xhc3NOYW1lOiAndXhjb3JlJ1xufSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gRHJvcGRvd247XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWRyb3Bkb3duL2J1aWxkL0Ryb3Bkb3duLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX0Ryb3Bkb3duID0gcmVxdWlyZSgnLi9Ecm9wZG93bicpO1xuXG52YXIgX0Ryb3Bkb3duMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Ryb3Bkb3duKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX0Ryb3Bkb3duMltcImRlZmF1bHRcIl07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWRyb3Bkb3duL34vcmMtZHJvcGRvd24vbGliL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcmVhY3REb20gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIF9yZWFjdERvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdERvbSk7XG5cbnZhciBfcmNUcmlnZ2VyID0gcmVxdWlyZSgncmMtdHJpZ2dlcicpO1xuXG52YXIgX3JjVHJpZ2dlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yY1RyaWdnZXIpO1xuXG52YXIgX3BsYWNlbWVudHMgPSByZXF1aXJlKCcuL3BsYWNlbWVudHMnKTtcblxudmFyIF9wbGFjZW1lbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BsYWNlbWVudHMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG4vKlxuXG4gdmFyIE1lbnVJdGVtID0gTWVudS5JdGVtO1xuXG4gdmFyIG1lbnUgPSA8TWVudT48TWVudUl0ZW0+MTwvTWVudUl0ZW0+PC9NZW51PjtcblxuIDxEcm9wRG93biB0cmlnZ2VyPVwiY2xpY2tcIiBhbmltYXRpb25OYW1lPVwiXCIgb3ZlcmxheT17PD59IG9uU2VsZWN0PXt9PlxuIDxidXR0b24+b3BlbjwvYnV0dG9uPlxuIDwvRHJvcERvd24+XG4gKi9cblxudmFyIERyb3Bkb3duID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ0Ryb3Bkb3duJyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBtaW5PdmVybGF5V2lkdGhNYXRjaFRyaWdnZXI6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBvblZpc2libGVDaGFuZ2U6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBwcmVmaXhDbHM6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGNoaWxkcmVuOiBfcmVhY3QuUHJvcFR5cGVzLmFueSxcbiAgICB0cmFuc2l0aW9uTmFtZTogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgb3ZlcmxheUNsYXNzTmFtZTogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgYW5pbWF0aW9uOiBfcmVhY3QuUHJvcFR5cGVzLmFueSxcbiAgICBhbGlnbjogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgb3ZlcmxheVN0eWxlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBwbGFjZW1lbnQ6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHRyaWdnZXI6IF9yZWFjdC5Qcm9wVHlwZXMuYXJyYXksXG4gICAgc2hvd0FjdGlvbjogX3JlYWN0LlByb3BUeXBlcy5hcnJheSxcbiAgICBoaWRlQWN0aW9uOiBfcmVhY3QuUHJvcFR5cGVzLmFycmF5LFxuICAgIGdldFBvcHVwQ29udGFpbmVyOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmNcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWluT3ZlcmxheVdpZHRoTWF0Y2hUcmlnZ2VyOiB0cnVlLFxuICAgICAgcHJlZml4Q2xzOiAncmMtZHJvcGRvd24nLFxuICAgICAgdHJpZ2dlcjogWydob3ZlciddLFxuICAgICAgc2hvd0FjdGlvbjogW10sXG4gICAgICBoaWRlQWN0aW9uOiBbXSxcbiAgICAgIG92ZXJsYXlDbGFzc05hbWU6ICcnLFxuICAgICAgb3ZlcmxheVN0eWxlOiB7fSxcbiAgICAgIGRlZmF1bHRWaXNpYmxlOiBmYWxzZSxcbiAgICAgIG9uVmlzaWJsZUNoYW5nZTogZnVuY3Rpb24gb25WaXNpYmxlQ2hhbmdlKCkge30sXG5cbiAgICAgIHBsYWNlbWVudDogJ2JvdHRvbUxlZnQnXG4gICAgfTtcbiAgfSxcbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICBpZiAoJ3Zpc2libGUnIGluIHByb3BzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2aXNpYmxlOiBwcm9wcy52aXNpYmxlXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdmlzaWJsZTogcHJvcHMuZGVmYXVsdFZpc2libGVcbiAgICB9O1xuICB9LFxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHByb3BzKSB7XG4gICAgaWYgKCd2aXNpYmxlJyBpbiBwcm9wcykge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHZpc2libGU6IHByb3BzLnZpc2libGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgb25DbGljazogZnVuY3Rpb24gb25DbGljayhlKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgb3ZlcmxheVByb3BzID0gcHJvcHMub3ZlcmxheS5wcm9wcztcbiAgICBpZiAoISgndmlzaWJsZScgaW4gcHJvcHMpKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgdmlzaWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAob3ZlcmxheVByb3BzLm9uQ2xpY2spIHtcbiAgICAgIG92ZXJsYXlQcm9wcy5vbkNsaWNrKGUpO1xuICAgIH1cbiAgfSxcbiAgb25WaXNpYmxlQ2hhbmdlOiBmdW5jdGlvbiBvblZpc2libGVDaGFuZ2Uodikge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgaWYgKCEoJ3Zpc2libGUnIGluIHByb3BzKSkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHZpc2libGU6IHZcbiAgICAgIH0pO1xuICAgIH1cbiAgICBwcm9wcy5vblZpc2libGVDaGFuZ2Uodik7XG4gIH0sXG4gIGdldE1lbnVFbGVtZW50OiBmdW5jdGlvbiBnZXRNZW51RWxlbWVudCgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jbG9uZUVsZW1lbnQocHJvcHMub3ZlcmxheSwge1xuICAgICAgcHJlZml4Q2xzOiBwcm9wcy5wcmVmaXhDbHMgKyAnLW1lbnUnLFxuICAgICAgb25DbGljazogdGhpcy5vbkNsaWNrXG4gICAgfSk7XG4gIH0sXG4gIGdldFBvcHVwRG9tTm9kZTogZnVuY3Rpb24gZ2V0UG9wdXBEb21Ob2RlKCkge1xuICAgIHJldHVybiB0aGlzLnJlZnMudHJpZ2dlci5nZXRQb3B1cERvbU5vZGUoKTtcbiAgfSxcbiAgYWZ0ZXJWaXNpYmxlQ2hhbmdlOiBmdW5jdGlvbiBhZnRlclZpc2libGVDaGFuZ2UodmlzaWJsZSkge1xuICAgIGlmICh2aXNpYmxlICYmIHRoaXMucHJvcHMubWluT3ZlcmxheVdpZHRoTWF0Y2hUcmlnZ2VyKSB7XG4gICAgICB2YXIgb3ZlcmxheU5vZGUgPSB0aGlzLmdldFBvcHVwRG9tTm9kZSgpO1xuICAgICAgdmFyIHJvb3ROb2RlID0gX3JlYWN0RG9tMltcImRlZmF1bHRcIl0uZmluZERPTU5vZGUodGhpcyk7XG4gICAgICBpZiAocm9vdE5vZGUub2Zmc2V0V2lkdGggPiBvdmVybGF5Tm9kZS5vZmZzZXRXaWR0aCkge1xuICAgICAgICBvdmVybGF5Tm9kZS5zdHlsZS53aWR0aCA9IHJvb3ROb2RlLm9mZnNldFdpZHRoICsgJ3B4JztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfZXh0ZW5kczI7XG5cbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcHJlZml4Q2xzID0gX3Byb3BzLnByZWZpeENscztcbiAgICB2YXIgY2hpbGRyZW4gPSBfcHJvcHMuY2hpbGRyZW47XG4gICAgdmFyIHRyYW5zaXRpb25OYW1lID0gX3Byb3BzLnRyYW5zaXRpb25OYW1lO1xuICAgIHZhciBhbmltYXRpb24gPSBfcHJvcHMuYW5pbWF0aW9uO1xuICAgIHZhciBhbGlnbiA9IF9wcm9wcy5hbGlnbjtcbiAgICB2YXIgcGxhY2VtZW50ID0gX3Byb3BzLnBsYWNlbWVudDtcbiAgICB2YXIgZ2V0UG9wdXBDb250YWluZXIgPSBfcHJvcHMuZ2V0UG9wdXBDb250YWluZXI7XG4gICAgdmFyIHNob3dBY3Rpb24gPSBfcHJvcHMuc2hvd0FjdGlvbjtcbiAgICB2YXIgaGlkZUFjdGlvbiA9IF9wcm9wcy5oaWRlQWN0aW9uO1xuICAgIHZhciBvdmVybGF5Q2xhc3NOYW1lID0gX3Byb3BzLm92ZXJsYXlDbGFzc05hbWU7XG4gICAgdmFyIG92ZXJsYXlTdHlsZSA9IF9wcm9wcy5vdmVybGF5U3R5bGU7XG4gICAgdmFyIHRyaWdnZXIgPSBfcHJvcHMudHJpZ2dlcjtcblxuICAgIHZhciBvdGhlclByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wcywgWydwcmVmaXhDbHMnLCAnY2hpbGRyZW4nLCAndHJhbnNpdGlvbk5hbWUnLCAnYW5pbWF0aW9uJywgJ2FsaWduJywgJ3BsYWNlbWVudCcsICdnZXRQb3B1cENvbnRhaW5lcicsICdzaG93QWN0aW9uJywgJ2hpZGVBY3Rpb24nLCAnb3ZlcmxheUNsYXNzTmFtZScsICdvdmVybGF5U3R5bGUnLCAndHJpZ2dlciddKTtcblxuICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgX3JjVHJpZ2dlcjJbXCJkZWZhdWx0XCJdLFxuICAgICAgX2V4dGVuZHMoe30sIG90aGVyUHJvcHMsIChfZXh0ZW5kczIgPSB7XG4gICAgICAgIHByZWZpeENsczogcHJlZml4Q2xzLFxuICAgICAgICByZWY6ICd0cmlnZ2VyJyxcbiAgICAgICAgcG9wdXBDbGFzc05hbWU6IG92ZXJsYXlDbGFzc05hbWUsXG4gICAgICAgIHBvcHVwU3R5bGU6IG92ZXJsYXlTdHlsZSxcbiAgICAgICAgYnVpbHRpblBsYWNlbWVudHM6IF9wbGFjZW1lbnRzMltcImRlZmF1bHRcIl0sXG4gICAgICAgIGFjdGlvbjogdHJpZ2dlcixcbiAgICAgICAgc2hvd0FjdGlvbjogc2hvd0FjdGlvblxuICAgICAgfSwgX2RlZmluZVByb3BlcnR5KF9leHRlbmRzMiwgJ3Nob3dBY3Rpb24nLCBzaG93QWN0aW9uKSwgX2RlZmluZVByb3BlcnR5KF9leHRlbmRzMiwgJ2hpZGVBY3Rpb24nLCBoaWRlQWN0aW9uKSwgX2RlZmluZVByb3BlcnR5KF9leHRlbmRzMiwgJ3BvcHVwUGxhY2VtZW50JywgcGxhY2VtZW50KSwgX2RlZmluZVByb3BlcnR5KF9leHRlbmRzMiwgJ3BvcHVwQWxpZ24nLCBhbGlnbiksIF9kZWZpbmVQcm9wZXJ0eShfZXh0ZW5kczIsICdwb3B1cFRyYW5zaXRpb25OYW1lJywgdHJhbnNpdGlvbk5hbWUpLCBfZGVmaW5lUHJvcGVydHkoX2V4dGVuZHMyLCAncG9wdXBBbmltYXRpb24nLCBhbmltYXRpb24pLCBfZGVmaW5lUHJvcGVydHkoX2V4dGVuZHMyLCAncG9wdXBWaXNpYmxlJywgdGhpcy5zdGF0ZS52aXNpYmxlKSwgX2RlZmluZVByb3BlcnR5KF9leHRlbmRzMiwgJ2FmdGVyUG9wdXBWaXNpYmxlQ2hhbmdlJywgdGhpcy5hZnRlclZpc2libGVDaGFuZ2UpLCBfZGVmaW5lUHJvcGVydHkoX2V4dGVuZHMyLCAncG9wdXAnLCB0aGlzLmdldE1lbnVFbGVtZW50KCkpLCBfZGVmaW5lUHJvcGVydHkoX2V4dGVuZHMyLCAnb25Qb3B1cFZpc2libGVDaGFuZ2UnLCB0aGlzLm9uVmlzaWJsZUNoYW5nZSksIF9kZWZpbmVQcm9wZXJ0eShfZXh0ZW5kczIsICdnZXRQb3B1cENvbnRhaW5lcicsIGdldFBvcHVwQ29udGFpbmVyKSwgX2V4dGVuZHMyKSksXG4gICAgICBjaGlsZHJlblxuICAgICk7XG4gIH1cbn0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IERyb3Bkb3duO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1kcm9wZG93bi9+L3JjLWRyb3Bkb3duL2xpYi9Ecm9wZG93bi5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBhdXRvQWRqdXN0T3ZlcmZsb3cgPSB7XG4gIGFkanVzdFg6IDEsXG4gIGFkanVzdFk6IDFcbn07XG5cbnZhciB0YXJnZXRPZmZzZXQgPSBbMCwgMF07XG5cbnZhciBwbGFjZW1lbnRzID0gZXhwb3J0cy5wbGFjZW1lbnRzID0ge1xuICB0b3BMZWZ0OiB7XG4gICAgcG9pbnRzOiBbJ2JsJywgJ3RsJ10sXG4gICAgb3ZlcmZsb3c6IGF1dG9BZGp1c3RPdmVyZmxvdyxcbiAgICBvZmZzZXQ6IFswLCAtNF0sXG4gICAgdGFyZ2V0T2Zmc2V0OiB0YXJnZXRPZmZzZXRcbiAgfSxcbiAgYm90dG9tTGVmdDoge1xuICAgIHBvaW50czogWyd0bCcsICdibCddLFxuICAgIG92ZXJmbG93OiBhdXRvQWRqdXN0T3ZlcmZsb3csXG4gICAgb2Zmc2V0OiBbMCwgNF0sXG4gICAgdGFyZ2V0T2Zmc2V0OiB0YXJnZXRPZmZzZXRcbiAgfVxufTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBwbGFjZW1lbnRzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtZHJvcGRvd24vfi9yYy1kcm9wZG93bi9saWIvcGxhY2VtZW50cy5qc1xuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIEZvcm0gQ29tcG9uZW50IGZvciB1eGNvcmVcbiAqIEBhdXRob3IgZXRlcm5hbHNreVxuICpcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIFV4Y29yZSBUZWFtLCBBbGludy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbnZhciBGb3JtID0gcmVxdWlyZSgnLi9Gb3JtJyk7XG5cbi8vIOS7pSBGb3JtIOaPkuS7tueahOW9ouW8j+e7meWHulxuRm9ybS5UZXh0QXJlYUZvcm1GaWVsZCA9IHJlcXVpcmUoXCIuL0Zvcm1GaWVsZC9UZXh0QXJlYUZvcm1GaWVsZFwiKTtcbkZvcm0uSW5wdXRGb3JtRmllbGQgPSByZXF1aXJlKFwiLi9Gb3JtRmllbGQvSW5wdXRGb3JtRmllbGRcIik7XG5Gb3JtLlJhZGlvR3JvdXBGb3JtRmllbGQgPSByZXF1aXJlKFwiLi9Gb3JtRmllbGQvUmFkaW9Hcm91cEZvcm1GaWVsZFwiKTtcbkZvcm0uU2VsZWN0Rm9ybUZpZWxkID0gcmVxdWlyZShcIi4vRm9ybUZpZWxkL1NlbGVjdEZvcm1GaWVsZFwiKTtcbkZvcm0uTnVtYmVySW5wdXRGb3JtRmllbGQgPSByZXF1aXJlKCcuL0Zvcm1GaWVsZC9OdW1iZXJJbnB1dEZvcm1GaWVsZCcpO1xuRm9ybS5EYXRlRm9ybUZpZWxkID0gcmVxdWlyZSgnLi9Gb3JtRmllbGQvRGF0ZUZvcm1GaWVsZCcpO1xuRm9ybS5DaGVja2JveEdyb3VwRm9ybUZpZWxkID0gcmVxdWlyZShcIi4vRm9ybUZpZWxkL0NoZWNrYm94R3JvdXBGb3JtRmllbGRcIik7XG5Gb3JtLkNhc2NhZGVTZWxlY3RGb3JtRmllbGQgPSByZXF1aXJlKFwiLi9Gb3JtRmllbGQvQ2FzY2FkZVNlbGVjdEZvcm1GaWVsZFwiKTtcbkZvcm0uT3RoZXJGb3JtRmllbGQgPSByZXF1aXJlKFwiLi9Gb3JtRmllbGQvT3RoZXJGb3JtRmllbGRcIik7XG5Gb3JtLkJ1dHRvbkdyb3VwRm9ybUZpZWxkID0gcmVxdWlyZShcIi4vRm9ybUZpZWxkL0J1dHRvbkdyb3VwRm9ybUZpZWxkXCIpO1xuRm9ybS5FZGl0b3JGb3JtRmllbGQgPSByZXF1aXJlKFwiLi9Gb3JtRmllbGQvRWRpdG9yRm9ybUZpZWxkXCIpO1xuRm9ybS5TZWFyY2hGb3JtRmllbGQgPSByZXF1aXJlKFwiLi9Gb3JtRmllbGQvU2VhcmNoRm9ybUZpZWxkXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZvcm07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL2J1aWxkL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIEZvcm0gQ29tcG9uZW50IGZvciB1eGNvcmVcbiAqIEBhdXRob3IgZXRlcm5hbHNreVxuICpcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIFV4Y29yZSBUZWFtLCBBbGludy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xudmFyIEZvcm1Sb3cgPSByZXF1aXJlKFwiLi9Gb3JtUm93XCIpO1xudmFyIEZvcm1Sb3dUaXRsZSA9IHJlcXVpcmUoXCIuL0Zvcm1Sb3dUaXRsZVwiKTtcbnZhciBGb3JtRmllbGQgPSByZXF1aXJlKFwiLi9Gb3JtRmllbGQvRm9ybUZpZWxkXCIpO1xuXG52YXIgQ29uc3RhbnRzID0gcmVxdWlyZShcInV4Y29yZS1jb25zdFwiKTtcbnZhciBWYWxpZGF0b3JzID0gcmVxdWlyZShcIi4vVmFsaWRhdG9yc1wiKTtcbnZhciBLZXlDb2RlID0gcmVxdWlyZSgnLi9LZXlDb2RlJyk7XG5cbnZhciBjbGFzc25hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcbnZhciBkZWVwY29weSA9IHJlcXVpcmUoJ2RlZXBjb3B5Jyk7XG52YXIgZGVlcEVxdWFsID0gcmVxdWlyZSgnZGVlcC1lcXVhbCcpO1xuXG52YXIgRm9ybSA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzKEZvcm0sIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gRm9ybShwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRm9ybSk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICAgICAgX3RoaXMuZmllbGRzID0ge307XG4gICAgICAgIF90aGlzLmVycm9ycyA9IHt9O1xuICAgICAgICBfdGhpcy5kYXRhID0ge307XG4gICAgICAgIF90aGlzLnN0YXRlID0ge307XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBGb3JtLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgIH07XG5cbiAgICBGb3JtLnByb3RvdHlwZS5fY29weSA9IGZ1bmN0aW9uIF9jb3B5KGEpIHtcbiAgICAgICAgcmV0dXJuIGRlZXBjb3B5KGEpO1xuICAgIH07XG5cbiAgICBGb3JtLnByb3RvdHlwZS5hdHRhY2hGb3JtRmllbGQgPSBmdW5jdGlvbiBhdHRhY2hGb3JtRmllbGQoZmllbGQpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBmaWVsZC5nZXROYW1lKCk7XG4gICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRWFjaCBmaWVsZCBuZWVkcyBhIG5hbWUgdG8gaWRlbnRpZnkgaXRzZWxmXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5maWVsZHNbbmFtZV0gPSBmaWVsZDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBGb3JtLnByb3RvdHlwZS5kZXRhY2hGb3JtRmllbGQgPSBmdW5jdGlvbiBkZXRhY2hGb3JtRmllbGQoZmllbGQpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBmaWVsZC5nZXROYW1lKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmZpZWxkc1tuYW1lXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuZGF0YVtuYW1lXTtcbiAgICB9O1xuXG4gICAgRm9ybS5wcm90b3R5cGUuaGFuZGxlRGF0YUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZURhdGFDaGFuZ2UoZmllbGQsIGZpZWxkRGF0YSwgZnJvbU1vdW50KSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIG1lLmRhdGFbZmllbGQucHJvcHMuanN4bmFtZV0gPSBmaWVsZERhdGEudmFsdWU7XG4gICAgICAgIGlmICghZnJvbU1vdW50KSB7XG4gICAgICAgICAgICBtZS5wcm9wcy5qc3hvbkNoYW5nZShtZS5fY29weShtZS5kYXRhKSwgZmllbGQucHJvcHMuanN4bmFtZSwgZmllbGREYXRhLnBhc3MpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEZvcm0ucHJvdG90eXBlLmdldFZhbHVlcyA9IGZ1bmN0aW9uIGdldFZhbHVlcyhmb3JjZSkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgX2ZsYWcgPSBtZS5kb1ZhbGlkYXRlKGZvcmNlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlczogbWUuX2NvcHkobWUuZGF0YSksXG4gICAgICAgICAgICBwYXNzOiBfZmxhZ1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBGb3JtLnByb3RvdHlwZS5yZXNldFZhbHVlcyA9IGZ1bmN0aW9uIHJlc2V0VmFsdWVzKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG1lLmZpZWxkcyk7XG4gICAgICAgIHZhciBkYXRhID0gbWUucHJvcHMuanN4dmFsdWVzIHx8IG1lLnByb3BzLnBhc3NlZERhdGEgfHwge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbWUuZmllbGRzW2tleXNbaV1dLmhhbmRsZURhdGFDaGFuZ2UoZGF0YVtrZXlzW2ldXSA9PSB1bmRlZmluZWQgPyBudWxsIDogZGF0YVtrZXlzW2ldXSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBzZXQgRm9ybSB2YWx1ZXMgbWFudWFsbHlcbiAgICAgKi9cblxuICAgIEZvcm0ucHJvdG90eXBlLnNldFZhbHVlcyA9IGZ1bmN0aW9uIHNldFZhbHVlcyhkYXRhKSB7XG4gICAgICAgIGlmICgodHlwZW9mIGRhdGEgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGRhdGEpKSAhPSAnb2JqZWN0JykgcmV0dXJuO1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgc2F2ZWREYXRhID0gbWUuZGF0YTtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWRlZXBFcXVhbChkYXRhW2tleXNbaV1dLCBzYXZlZERhdGFba2V5c1tpXV0pKSB7XG4gICAgICAgICAgICAgICAgbWUuZmllbGRzW2tleXNbaV1dLmhhbmRsZURhdGFDaGFuZ2UoZGF0YVtrZXlzW2ldXSA9PSB1bmRlZmluZWQgPyBudWxsIDogZGF0YVtrZXlzW2ldXSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgRm9ybS5wcm90b3R5cGUuZG9WYWxpZGF0ZSA9IGZ1bmN0aW9uIGRvVmFsaWRhdGUoZm9yY2UpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIHBhc3MgPSB0cnVlO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG1lLmZpZWxkcyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZW1QYXNzID0gbWUuZmllbGRzW2tleXNbaV1dLmRvVmFsaWRhdGUoZm9yY2UpO1xuICAgICAgICAgICAgbWUuZXJyb3JzW2tleXNbaV1dID0gIWl0ZW1QYXNzO1xuICAgICAgICAgICAgaWYgKCFpdGVtUGFzcykge1xuICAgICAgICAgICAgICAgIHBhc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFzcztcbiAgICB9O1xuXG4gICAgRm9ybS5wcm90b3R5cGUuaXNEaXJ0eSA9IGZ1bmN0aW9uIGlzRGlydHkoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5kb1ZhbGlkYXRlKCk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgICog57uf5LiA5pWw5o2u5rWB77yM5omA5pyJ55qEIHByb3Bz77yM6YCa6L+HIEZvcm0gLT4gRm9ybVJvdyAtPiBGb3JtRmllbGQg5ZCR5LiL5Lyg6YCS77yM5aaC5p6c5pyJ55qEXG4gICAgICog5a2Q5YWD57Sg5pivIEZvcm1GaWVsZO+8jOWImeiHquWKqOWcqOS7lueahOWklumdouWMheS4gOWxgiBGb3JtUm9344CCXG4gICAgICogQHBhcmFtIHtSZWFjdCBFbGVtZW50cyBBcnJheX0gY2hpbGRyZW4gdGhpcy5wcm9wcy5jaGlsZHJlblxuICAgICAqL1xuXG4gICAgRm9ybS5wcm90b3R5cGUuX3Byb2Nlc3NDaGlsZCA9IGZ1bmN0aW9uIF9wcm9jZXNzQ2hpbGQoY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IFJlYWN0LkNoaWxkcmVuLmNvdW50KGNoaWxkcmVuKTtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgICAgIGlmIChsZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRk9STTogWW91IG11c3QgcGFzcyBjaGlsZHJlbiB0byB0aGUgZm9ybSBjb21wb25lbnRcIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQsIGluZGV4KSB7XG4gICAgICAgICAgICAvLyDlpoLmnpzmmK/oh6rlt7Hmt7vliqDnmoQgRE9NIOebtOaOpeaKm+W8g1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZC50eXBlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAoL0Zvcm1GaWVsZC8udGVzdChjaGlsZC50eXBlLmRpc3BsYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICBGb3JtUm93LFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkXG4gICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoL0Zvcm1Sb3cvLnRlc3QoY2hpbGQudHlwZS5kaXNwbGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfTtcblxuICAgIEZvcm0ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIF9jbGFzc25hbWVzO1xuXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IG1lLl9wcm9jZXNzQ2hpbGQobWUucHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogY2xhc3NuYW1lcygoX2NsYXNzbmFtZXMgPSB7fSwgX2NsYXNzbmFtZXNbbWUucHJvcHMuanN4cHJlZml4Q2xzXSA9IHRydWUsIF9jbGFzc25hbWVzW21lLnByb3BzLmNsYXNzTmFtZV0gPSAhIW1lLnByb3BzLmNsYXNzTmFtZSwgX2NsYXNzbmFtZXNbXCJrdW1hLXV4Zm9ybS1lZGl0LW1vZGVcIl0gPSBtZS5wcm9wcy5qc3htb2RlID09IENvbnN0YW50cy5NT0RFLkVESVQsIF9jbGFzc25hbWVzW1wia3VtYS11eGZvcm0tdmlldy1tb2RlXCJdID0gbWUucHJvcHMuanN4bW9kZSA9PSBDb25zdGFudHMuTU9ERS5WSUVXLCBfY2xhc3NuYW1lcykpIH0sXG4gICAgICAgICAgICAhIWVsZW1lbnRzICYmIGVsZW1lbnRzLm1hcChmdW5jdGlvbiAoY2hpbGQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgICAgICAgICAgICAgICBtb2RlOiBtZS5wcm9wcy5qc3htb2RlLFxuICAgICAgICAgICAgICAgICAgICBpbnN0YW50VmFsaWRhdGU6IG1lLnByb3BzLmluc3RhbnRWYWxpZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZGVlcGNvcHkobWUucHJvcHMuanN4dmFsdWVzIHx8IG1lLnByb3BzLnBhc3NlZERhdGEgfHwge30pLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBhdHRhY2hGb3JtRmllbGQ6IG1lLmF0dGFjaEZvcm1GaWVsZC5iaW5kKG1lKSxcbiAgICAgICAgICAgICAgICAgICAgZGV0YWNoRm9ybUZpZWxkOiBtZS5kZXRhY2hGb3JtRmllbGQuYmluZChtZSksXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZURhdGFDaGFuZ2U6IG1lLmhhbmRsZURhdGFDaGFuZ2UuYmluZChtZSksXG4gICAgICAgICAgICAgICAgICAgIGdldFZhbHVlczogbWUuZ2V0VmFsdWVzLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgICAgICByZXNldFZhbHVlczogbWUucmVzZXRWYWx1ZXMuYmluZChtZSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHJldHVybiBGb3JtO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG4vLyDku6UgRm9ybSDnmoTmj5Lku7bnmoTlvaLlvI/nu5nlh7pcblxuXG5Gb3JtLkZvcm1Sb3cgPSBGb3JtUm93O1xuRm9ybS5Gb3JtUm93VGl0bGUgPSBGb3JtUm93VGl0bGU7XG5Gb3JtLkZvcm1GaWVsZCA9IEZvcm1GaWVsZDtcblxuLy8gRm9ybS5NZW50aW9uRm9ybUZpZWxkID0gTWVudGlvbkZvcm1GaWVsZDtcbkZvcm0uQ29uc3RhbnRzID0gQ29uc3RhbnRzO1xuRm9ybS5WYWxpZGF0b3JzID0gVmFsaWRhdG9ycztcbkZvcm0uS2V5Q29kZSA9IEtleUNvZGU7XG5cbkZvcm0uZGVmYXVsdFByb3BzID0ge1xuICAgIGpzeHByZWZpeENsczogXCJrdW1hLXV4Zm9ybVwiLFxuICAgIGpzeG1vZGU6IENvbnN0YW50cy5NT0RFLkVESVQsXG4gICAgaW5zdGFudFZhbGlkYXRlOiB0cnVlLFxuICAgIGpzeG9uQ2hhbmdlOiBmdW5jdGlvbiBqc3hvbkNoYW5nZSgpIHt9XG59O1xuXG4vLyBodHRwOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvcmV1c2FibGUtY29tcG9uZW50cy5odG1sXG5Gb3JtLnByb3BUeXBlcyA9IHtcbiAgICBqc3hwcmVmaXhDbHM6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAganN4bW9kZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBqc3h2YWx1ZXM6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgaW5zdGFudFZhbGlkYXRlOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBqc3hvbkNoYW5nZTogUmVhY3QuUHJvcFR5cGVzLmZ1bmNcbn07XG5cbkZvcm0uZGlzcGxheU5hbWUgPSBcIkZvcm1cIjtcblxubW9kdWxlLmV4cG9ydHMgPSBGb3JtO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9idWlsZC9Gb3JtLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcbnZhciBjbGFzc25hbWVzID0gcmVxdWlyZShcImNsYXNzbmFtZXNcIik7XG5cbnZhciBGb3JtUm93ID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoRm9ybVJvdywgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBGb3JtUm93KHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGb3JtUm93KTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgICAgICBfdGhpcy50b3RhbEZsZXggPSAwO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgRm9ybVJvdy5wcm90b3R5cGUuX3Byb2Nlc3NDaGlsZCA9IGZ1bmN0aW9uIF9wcm9jZXNzQ2hpbGQoY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgbWUudG90YWxGbGV4ID0gMDtcbiAgICAgICAgdmFyIGxlbmd0aCA9IFJlYWN0LkNoaWxkcmVuLmNvdW50KGNoaWxkcmVuKTtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgICAgIGlmIChsZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRk9STTogWW91IG11c3QgcGFzcyBjaGlsZHJlbiB0byB0aGUgZm9ybSBjb21wb25lbnRcIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkLCBpbmRleCkge1xuICAgICAgICAgICAgLy8g5aaC5p6c5piv6Ieq5bex5re75Yqg55qEIERPTSDnm7TmjqXmipvlvINcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hpbGQudHlwZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKC9Gb3JtRmllbGQvLnRlc3QoY2hpbGQudHlwZS5kaXNwbGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLnByb3BzLmpzeHNob3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnRvdGFsRmxleCArPSBjaGlsZC5wcm9wcy5qc3hmbGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH07XG5cbiAgICBGb3JtUm93LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBfY2xhc3NuYW1lcztcblxuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBtZS5fcHJvY2Vzc0NoaWxkKG1lLnByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBjbGFzc25hbWVzKChfY2xhc3NuYW1lcyA9IHt9LCBfY2xhc3NuYW1lc1ttZS5wcm9wcy5qc3hwcmVmaXhDbHNdID0gdHJ1ZSwgX2NsYXNzbmFtZXNbbWUucHJvcHMuY2xhc3NOYW1lXSA9ICEhbWUucHJvcHMuY2xhc3NOYW1lLCBfY2xhc3NuYW1lcykpIH0sXG4gICAgICAgICAgICAhIWVsZW1lbnRzICYmIGVsZW1lbnRzLm1hcChmdW5jdGlvbiAoY2hpbGQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gbWUucHJvcHMuZGF0YVtjaGlsZC5wcm9wcy5qc3huYW1lXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IG1lLnByb3BzLm1vZGUsXG4gICAgICAgICAgICAgICAgICAgIGpzeGluc3RhbnQ6IG1lLnByb3BzLmluc3RhbnRWYWxpZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IGNoaWxkLnByb3BzLmpzeG5hbWUgfHwgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7IHdpZHRoOiBjaGlsZC5wcm9wcy5qc3hmbGV4IC8gbWUudG90YWxGbGV4ICogMTAwICsgJyUnIH0sXG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaEZvcm1GaWVsZDogbWUucHJvcHMuYXR0YWNoRm9ybUZpZWxkLFxuICAgICAgICAgICAgICAgICAgICBkZXRhY2hGb3JtRmllbGQ6IG1lLnByb3BzLmRldGFjaEZvcm1GaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRGF0YUNoYW5nZTogbWUucHJvcHMuaGFuZGxlRGF0YUNoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0VmFsdWVzOiBtZS5wcm9wcy5nZXRWYWx1ZXMsXG4gICAgICAgICAgICAgICAgICAgIHJlc2V0VmFsdWVzOiBtZS5wcm9wcy5yZXNldFZhbHVlc1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEZvcm1Sb3c7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbkZvcm1Sb3cuZGVmYXVsdFByb3BzID0ge1xuICAgIGpzeHByZWZpeENsczogXCJrdW1hLXV4Zm9ybS1yb3dcIlxufTtcbkZvcm1Sb3cucHJvcFR5cGVzID0ge1xuICAgIGpzeHByZWZpeENsczogUmVhY3QuUHJvcFR5cGVzLnN0cmluZ1xufTtcbkZvcm1Sb3cuZGlzcGxheU5hbWUgPSBcIkZvcm1Sb3dcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBGb3JtUm93O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9idWlsZC9Gb3JtUm93LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogQGF1dGhvcjogemhvdXF1YW4ueWV6cVxuICogQHRpbWU6IDgvNyAyMDE1XG4gKiBGb3JtIFJvdyBUaXRsZVxuICovXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG52YXIgQ29uc3RhbnRzID0gcmVxdWlyZShcInV4Y29yZS1jb25zdFwiKTtcbnZhciBjbGFzc25hbWVzID0gcmVxdWlyZShcImNsYXNzbmFtZXNcIik7XG5cbnZhciBGb3JtUm93VGl0bGUgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhGb3JtUm93VGl0bGUsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gRm9ybVJvd1RpdGxlKHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGb3JtUm93VGl0bGUpO1xuXG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpKTtcbiAgICB9XG5cbiAgICBGb3JtUm93VGl0bGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIF9jbGFzc25hbWVzO1xuXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBsZW5ndGggPSBSZWFjdC5DaGlsZHJlbi5jb3VudChtZS5wcm9wcy5jaGlsZHJlbik7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogY2xhc3NuYW1lcygoX2NsYXNzbmFtZXMgPSB7fSwgX2NsYXNzbmFtZXNbbWUucHJvcHMuanN4cHJlZml4Q2xzXSA9IHRydWUsIF9jbGFzc25hbWVzW21lLnByb3BzLmNsYXNzTmFtZV0gPSAhIW1lLnByb3BzLmNsYXNzTmFtZSwgX2NsYXNzbmFtZXMpKSB9LFxuICAgICAgICAgICAgbWUucHJvcHMuanN4dGl0bGUsXG4gICAgICAgICAgICAhIWxlbmd0aCAmJiBSZWFjdC5DaGlsZHJlbi5tYXAobWUucHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gRm9ybVJvd1RpdGxlO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG47XG5cbkZvcm1Sb3dUaXRsZS5wcm9wVHlwZXMgPSB7XG4gICAganN4cHJlZml4Q2xzOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGpzeHRpdGxlOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nXG59O1xuXG5Gb3JtUm93VGl0bGUuZGVmYXVsdFByb3BzID0ge1xuICAgIGpzeHByZWZpeENsczogXCJrdW1hLXV4Zm9ybS1yb3ctdGl0bGVcIixcbiAgICBqc3h0aXRsZTogXCJcIlxufTtcblxuRm9ybVJvd1RpdGxlLmRpc3BsYXlOYW1lID0gXCJGb3JtUm93VGl0bGVcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBGb3JtUm93VGl0bGU7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL2J1aWxkL0Zvcm1Sb3dUaXRsZS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xudmFyIENvbnN0YW50cyA9IHJlcXVpcmUoXCJ1eGNvcmUtY29uc3RcIik7XG52YXIgY2xhc3NuYW1lcyA9IHJlcXVpcmUoXCJjbGFzc25hbWVzXCIpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoXCJvYmplY3QtYXNzaWduXCIpO1xudmFyIGRlZXBlcXVhbCA9IHJlcXVpcmUoXCJkZWVwLWVxdWFsXCIpO1xuXG52YXIgRm9ybUZpZWxkID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoRm9ybUZpZWxkLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIEZvcm1GaWVsZChwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRm9ybUZpZWxkKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHZhbHVlOiBwcm9wcy52YWx1ZSxcbiAgICAgICAgICAgIGZvcm1hdFZhbHVlOiBfdGhpcy5mb3JtYXRWYWx1ZShwcm9wcy52YWx1ZSksXG4gICAgICAgICAgICBlcnJvcjogZmFsc2UsXG4gICAgICAgICAgICBlcnJNc2c6ICcnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBGb3JtRmllbGQucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIGlmICghbWUucHJvcHMuc3RhbmRhbG9uZSkge1xuICAgICAgICAgICAgbWUucHJvcHMuYXR0YWNoRm9ybUZpZWxkKG1lKTtcbiAgICAgICAgICAgIG1lLnByb3BzLmhhbmRsZURhdGFDaGFuZ2UobWUsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbWUucHJvcHMudmFsdWUsXG4gICAgICAgICAgICAgICAgcGFzczogdHJ1ZVxuICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgRm9ybUZpZWxkLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgaWYgKCFtZS5faXNFcXVhbChuZXh0UHJvcHMudmFsdWUsIG1lLnByb3BzLnZhbHVlKSkge1xuICAgICAgICAgICAgbWUuaGFuZGxlRGF0YUNoYW5nZShuZXh0UHJvcHMudmFsdWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEZvcm1GaWVsZC5wcm90b3R5cGUuX2lzRXF1YWwgPSBmdW5jdGlvbiBfaXNFcXVhbChhLCBiKSB7XG4gICAgICAgIHJldHVybiBkZWVwZXF1YWwoYSwgYik7XG4gICAgfTtcblxuICAgIEZvcm1GaWVsZC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgaWYgKCFtZS5wcm9wcy5zdGFuZGFsb25lKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLmRldGFjaEZvcm1GaWVsZCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBGb3JtRmllbGQucHJvdG90eXBlLmdldE5hbWUgPSBmdW5jdGlvbiBnZXROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5qc3huYW1lO1xuICAgIH07XG5cbiAgICAvKlxuICAgICAqIEZpcmVkIHdoZW4gZmllbGQgdmFsdWUgY2hhbmdlc++8jHVwZGF0ZSBmb3JtJ3Mgc3RhdGUgYW5kIHRoZW4gdHJpZ2dlciByZS1yZW5kZXIuXG4gICAgICogQHBhcmFtIGZyb21SZXNldCB7Ym9vbGVhbn0gaWYgaGFuZGxlRGF0YUNoYW5nZSBpcyBpbnZva2VkIGJ5IGZvcm0ncyByZXNldFZhbHVlcyxcbiAgICAgKiBkb1ZhbGlkYXRlIHNob3VsZCBub3QgYmUgaW52b2tlZC5cbiAgICAgKi9cblxuICAgIEZvcm1GaWVsZC5wcm90b3R5cGUuaGFuZGxlRGF0YUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZURhdGFDaGFuZ2UodmFsdWUsIGZyb21SZXNldCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBtZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBmb3JtYXRWYWx1ZTogbWUuZm9ybWF0VmFsdWUodmFsdWUpLFxuICAgICAgICAgICAgZXJyb3I6ICEhZnJvbVJlc2V0ID8gZmFsc2UgOiBtZS5zdGF0ZS5lcnJvcixcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiB3aHkgc2V0IHN0YXRlIGZyb21SZXNldD8gc29tZSBmaWVsZCBsaWtlIGVkaXRvciBjYW5ub3QgYmUgcmVzZXQgaW4gdGhlIGNvbW1vbiB3YXlcbiAgICAgICAgICAgICAqIHNvIHNldCB0aGlzIHN0YXRlIHRvIHRlbGwgdGhlIGZpZWxkIHRoYXQgeW91IG5lZWQgdG8gcmVzZXQgYnkgeW91cnNlbGYuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZyb21SZXNldDogISFmcm9tUmVzZXRcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhc3MgPSB0cnVlO1xuICAgICAgICAgICAgLy8gdmFsaWRhdGVPbkJsdXIgb25seSBzdXBwb3J0IElucHV0Rm9ybUZpZWxkICYgVGV4dEFyYWVGb3JtRmllbGQgbm93XG4gICAgICAgICAgICBpZiAoIWZyb21SZXNldCAmJiAhbWUucHJvcHMuc3RhbmRhbG9uZSAmJiAhbWUucHJvcHMudmFsaWRhdGVPbkJsdXIpIHtcbiAgICAgICAgICAgICAgICBwYXNzID0gbWUuZG9WYWxpZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgISFtZS5wcm9wcy5oYW5kbGVEYXRhQ2hhbmdlICYmIG1lLnByb3BzLmhhbmRsZURhdGFDaGFuZ2UobWUsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgcGFzczogcGFzc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBpZiB2YWxpZGF0ZSBwYXNzLCByZXR1cm4gdHJ1ZSwgb3IsIHJldHVybiBmYWxzZVxuICAgICAqIGlmIG5vIHJ1bGUsIGl0IG1lYW5zIHZhbGlkYXRlIHBhc3MuXG4gICAgICovXG5cbiAgICBGb3JtRmllbGQucHJvdG90eXBlLmRvVmFsaWRhdGUgPSBmdW5jdGlvbiBkb1ZhbGlkYXRlKGZvcmNlKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBpbnN0YW50ID0gdHJ1ZTtcbiAgICAgICAgaWYgKCdpbnN0YW50VmFsaWRhdGUnIGluIG1lLnByb3BzKSB7XG4gICAgICAgICAgICBpbnN0YW50ID0gbWUucHJvcHMuaW5zdGFudFZhbGlkYXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5zdGFudCA9IG1lLnByb3BzLmpzeGluc3RhbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYGZvcmNlYCBoYXMgdGhlIHRvcCBwcmlvcml0eSwgYHVuZGVmaW5lZGAgaXMgbm90IGVxdWFsIHRvIGBmYWxzZWBcbiAgICAgICAgLy8gYGluc3RhbnRgIGhhcyB0aGUgc2Nlb25kIHByaW9yaXR5IGhlcmVcbiAgICAgICAgLy8gZXRlcm5hbHNreUAyMDE2LjAzLjE1XG4gICAgICAgIGlmIChmb3JjZSA9PT0gdHJ1ZSB8fCBmb3JjZSAhPT0gZmFsc2UgJiYgaW5zdGFudCkge1xuICAgICAgICAgICAgaWYgKG1lLnByb3BzLmpzeHJ1bGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gbWUuaXNEaXJ0eSgpO1xuICAgICAgICAgICAgICAgIG1lLnNldFN0YXRlKHsgZXJyb3I6IGVycm9yLmlzRGlydHksIGVyck1zZzogZXJyb3IuZXJyTXNnIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAhZXJyb3IuaXNEaXJ0eTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgICAqIHJ1bGUgY2FuIGJlIGFuIG9iamVjdCwgY29udGFpbmluZyBlcnJNc2cgJiB2YWxpZGF0b3IsXG4gICAgICogYW5kIHJ1bGUgY2FuIGFsc28gYmUgYW4gYXJyYXkgY29udGFpbmluZyBzdWNoIG9iamVjdHMuXG4gICAgICogdGhpcyBmdW5jIHdpbGwgY2hlY2sgdGhlbSBvbmUgYnkgb25lLCBhbmQgcmV0dXJuIGZhbHNlXG4gICAgICogdW5sZXNzIGFsbCBydWxlcyBwYXNzXG4gICAgICovXG5cbiAgICBGb3JtRmllbGQucHJvdG90eXBlLmlzRGlydHkgPSBmdW5jdGlvbiBpc0RpcnR5KCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgcnVsZXMgPSBtZS5wcm9wcy5qc3hydWxlcztcbiAgICAgICAgdmFyIGlzRGlydHkgPSBmYWxzZTtcbiAgICAgICAgdmFyIGVyck1zZyA9IFwiXCI7XG4gICAgICAgIGlmICgodHlwZW9mIHJ1bGVzID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihydWxlcykpID09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkocnVsZXMpKSB7XG4gICAgICAgICAgICBpc0RpcnR5ID0gIXJ1bGVzLnZhbGlkYXRvcihtZS5zdGF0ZS52YWx1ZSk7XG4gICAgICAgICAgICBlcnJNc2cgPSBydWxlcy5lcnJNc2c7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShydWxlcykpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpc0RpcnR5ID0gIXJ1bGVzW2ldLnZhbGlkYXRvcihtZS5zdGF0ZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyTXNnID0gcnVsZXNbaV0uZXJyTXNnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzRGlydHk6IGlzRGlydHksXG4gICAgICAgICAgICBlcnJNc2c6IGVyck1zZ1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBGb3JtRmllbGQucHJvdG90eXBlLnJlbmRlclRpcHMgPSBmdW5jdGlvbiByZW5kZXJUaXBzKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgbW9kZSA9IG1lLnByb3BzLmpzeG1vZGUgfHwgbWUucHJvcHMubW9kZTtcbiAgICAgICAgaWYgKG1vZGUgIT0gQ29uc3RhbnRzLk1PREUuRURJVCkgcmV0dXJuO1xuICAgICAgICBpZiAobWUucHJvcHMuc3RhbmRhbG9uZSAmJiBtZS5wcm9wcy5tZXNzYWdlICYmIG1lLnByb3BzLm1lc3NhZ2UudHlwZSA9PSBcInRpcFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAnbGknLFxuICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAna3VtYS11eGZvcm0tdGlwcycgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdpJywgeyBjbGFzc05hbWU6ICdrdW1hLWljb24ga3VtYS1pY29uLWluZm9ybWF0aW9uJyB9KSxcbiAgICAgICAgICAgICAgICBtZS5wcm9wcy5tZXNzYWdlLm1lc3NhZ2VcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhdGhpcy5wcm9wcy5qc3h0aXBzICYmICFtZS5zdGF0ZS5lcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ2xpJyxcbiAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2t1bWEtdXhmb3JtLXRpcHMnIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnaScsIHsgY2xhc3NOYW1lOiAna3VtYS1pY29uIGt1bWEtaWNvbi1pbmZvcm1hdGlvbicgfSksXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5qc3h0aXBzXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogWW91IHNob3VsZCByZXdyaXRlIHRoaXMgbWV0aG9k77yMd2hlbiB5b3UgbmVlZCB0byBmb3JtYXQgdGhlIHZhbHVlIGFzIHlvdSBjb25jZXJuLlxuICAgICAqL1xuXG4gICAgRm9ybUZpZWxkLnByb3RvdHlwZS5mb3JtYXRWYWx1ZSA9IGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBZb3Ugc2hvdWxkIHJld3JpdGUgdGhpcyBtZXRob2QsIHdoZW4geW91IGFyZSBkZXZlbG9waW5nIGEgbmV3IHR5cGUgb2YgZm9ybSBmaWVsZC5cbiAgICAgKi9cblxuICAgIEZvcm1GaWVsZC5wcm90b3R5cGUucmVuZGVyRmllbGQgPSBmdW5jdGlvbiByZW5kZXJGaWVsZCgpIHt9O1xuXG4gICAgRm9ybUZpZWxkLnByb3RvdHlwZS5yZW5kZXJFcnJvck1zZyA9IGZ1bmN0aW9uIHJlbmRlckVycm9yTXNnKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgbW9kZSA9IG1lLnByb3BzLmpzeG1vZGUgfHwgbWUucHJvcHMubW9kZTtcbiAgICAgICAgaWYgKG1vZGUgIT0gQ29uc3RhbnRzLk1PREUuRURJVCkgcmV0dXJuO1xuICAgICAgICBpZiAobWUucHJvcHMuc3RhbmRhbG9uZSAmJiBtZS5wcm9wcy5tZXNzYWdlICYmIG1lLnByb3BzLm1lc3NhZ2UudHlwZSA9PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICdsaScsXG4gICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdrdW1hLXV4Zm9ybS1lcnJvcm1zZycgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdpJywgeyBjbGFzc05hbWU6ICdrdW1hLWljb24ga3VtYS1pY29uLWVycm9yJyB9KSxcbiAgICAgICAgICAgICAgICBtZS5wcm9wcy5tZXNzYWdlLm1lc3NhZ2VcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhbWUuc3RhdGUuZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICdsaScsXG4gICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdrdW1hLXV4Zm9ybS1lcnJvcm1zZycgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdpJywgeyBjbGFzc05hbWU6ICdrdW1hLWljb24ga3VtYS1pY29uLWVycm9yJyB9KSxcbiAgICAgICAgICAgICAgICBtZS5zdGF0ZS5lcnJNc2dcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgRm9ybUZpZWxkLnByb3RvdHlwZS5yZW5kZXJMYWJlbCA9IGZ1bmN0aW9uIHJlbmRlckxhYmVsKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgbW9kZSA9IG1lLnByb3BzLmpzeG1vZGUgfHwgbWUucHJvcHMubW9kZTtcbiAgICAgICAgdmFyIGFsaWduID0gbWUucHJvcHMudmVydGljYWxBbGlnbiB8fCBtZS5wcm9wcy5qc3hWZXJ0aWNhbEFsaWduOyAvLyBqc3hWZXJ0aWNhbEFsaWduIGlzIGFuIGludGVybmFsIHZhcmlibGUuXG4gICAgICAgIGlmIChtZS5wcm9wcy5qc3hzaG93TGFiZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICdsYWJlbCcsXG4gICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6IGNsYXNzbmFtZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJrdW1hLWxhYmVsXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInZlcnRpY2FsLWFsaWduXCI6IGFsaWduXG4gICAgICAgICAgICAgICAgICAgIH0pIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ3JlcXVpcmVkJyB9LFxuICAgICAgICAgICAgICAgICAgICBtZS5wcm9wcy5yZXF1aXJlZCAmJiBtb2RlID09IENvbnN0YW50cy5NT0RFLkVESVQgPyBcIiogXCIgOiBcIlwiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdzcGFuJywgeyBjbGFzc05hbWU6ICdsYWJlbC1jb250ZW50JywgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHsgX19odG1sOiBtZS5wcm9wcy5qc3hsYWJlbCB9IH0pXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEZvcm1GaWVsZC5wcm90b3R5cGUuYWRkU3BlY2lmaWNDbGFzcyA9IGZ1bmN0aW9uIGFkZFNwZWNpZmljQ2xhc3MoY2xhc3NuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmpzeHByZWZpeENscztcbiAgICB9O1xuXG4gICAgRm9ybUZpZWxkLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBfY2xhc3NuYW1lcztcblxuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgc3BlY2lmaWNDbHMgPSBtZS5hZGRTcGVjaWZpY0NsYXNzKCk7XG4gICAgICAgIHZhciBtb2RlID0gbWUucHJvcHMuanN4bW9kZSB8fCBtZS5wcm9wcy5tb2RlO1xuXG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogY2xhc3NuYW1lcygoX2NsYXNzbmFtZXMgPSB7fSwgX2NsYXNzbmFtZXNbc3BlY2lmaWNDbHNdID0gdHJ1ZSwgX2NsYXNzbmFtZXNbbWUucHJvcHMuY2xhc3NOYW1lXSA9ICEhbWUucHJvcHMuY2xhc3NOYW1lLCBfY2xhc3NuYW1lcykpLCBzdHlsZTogYXNzaWduKHt9LCBtZS5wcm9wcy5zdHlsZSwge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBtZS5wcm9wcy5qc3hzaG93ID8gXCJ0YWJsZVwiIDogXCJub25lXCJcbiAgICAgICAgICAgICAgICB9KSB9LFxuICAgICAgICAgICAgbWUucmVuZGVyTGFiZWwoKSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ3VsJyxcbiAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogY2xhc3NuYW1lcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImt1bWEtdXhmb3JtLWZpZWxkLWNvbnRlbnRcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidmlldy1tb2RlXCI6IG1vZGUgPT0gQ29uc3RhbnRzLk1PREUuVklFVyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZWRpdC1tb2RlXCI6IG1vZGUgPT0gQ29uc3RhbnRzLk1PREUuRURJVCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaGFzLWVycm9yXCI6ICEhbWUuc3RhdGUuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgfSkgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAnbGknLFxuICAgICAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2t1bWEtdXhmb3JtLWZpZWxkLWNvcmUnIH0sXG4gICAgICAgICAgICAgICAgICAgIG1lLnJlbmRlckZpZWxkKClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIG1lLnJlbmRlclRpcHMoKSxcbiAgICAgICAgICAgICAgICBtZS5yZW5kZXJFcnJvck1zZygpXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHJldHVybiBGb3JtRmllbGQ7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbjtcblxuRm9ybUZpZWxkLnByb3BUeXBlcyA9IHtcbiAgICBpbnN0YW50VmFsaWRhdGU6IFJlYWN0LlByb3BUeXBlcy5ib29sLCAvLyDmmK/lkKbnq4vljbPmoKHpqoxcbiAgICBqc3hzaG93OiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBqc3htb2RlOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGpzeHNob3dMYWJlbDogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAganN4cHJlZml4Q2xzOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGpzeGZsZXg6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAganN4bmFtZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGpzeHBsYWNlaG9sZGVyOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGpzeGxhYmVsOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGpzeHRpcHM6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAganN4cnVsZXM6IFJlYWN0LlByb3BUeXBlcy5vbmVPZlR5cGUoW1JlYWN0LlByb3BUeXBlcy5vYmplY3QsIFJlYWN0LlByb3BUeXBlcy5hcnJheV0pLFxuICAgIHN0YW5kYWxvbmU6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIHJlcXVpcmVkOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbFxufTtcblxuRm9ybUZpZWxkLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBqc3hzaG93OiB0cnVlLCAvLyDmmK/lkKbmmL7npLror6XlnZdcbiAgICBqc3hzaG93TGFiZWw6IHRydWUsIC8vIOaYr+WQpuWxleekuiBsYWJlbFxuICAgIGpzeHByZWZpeENsczogXCJrdW1hLXV4Zm9ybS1maWVsZFwiLCAvLyDpu5jorqTnsbvlkI1cbiAgICBqc3hmbGV4OiAxLCAvLyDljaAgRm9ybSDnmoTmr5TkvovvvIznsbvkvLzkuo4gY3NzMyDkuK3nmoQgZmxleC1ib3hcbiAgICBqc3huYW1lOiBcIlwiLCAvLyDooajljZXlrZfmrrVcbiAgICBqc3hwbGFjZWhvbGRlcjogXCJcIiwgLy8g5Zyo5pyq6YCJ5YC85LmL5YmN55qE5Y2g5L2N56ymXG4gICAganN4bGFiZWw6IFwiXCIsIC8vIOW3puS+p+ihqOWNleWfn+agh+mimFxuICAgIGpzeHRpcHM6IFwiXCIsIC8vIOaPkOmGklxuICAgIHN0YW5kYWxvbmU6IGZhbHNlLCAvLyDmmK/lkKblpITkuo7ni6znq4vkvb/nlKjmqKHlvI9cbiAgICBtb2RlOiBDb25zdGFudHMuTU9ERS5FRElULFxuICAgIHJlcXVpcmVkOiBmYWxzZVxufTtcblxuRm9ybUZpZWxkLmRpc3BsYXlOYW1lID0gXCJGb3JtRmllbGRcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBGb3JtRmllbGQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL2J1aWxkL0Zvcm1GaWVsZC9Gb3JtRmllbGQuanNcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbidcbiAgPyBPYmplY3Qua2V5cyA6IHNoaW07XG5cbmV4cG9ydHMuc2hpbSA9IHNoaW07XG5mdW5jdGlvbiBzaGltIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gIHJldHVybiBrZXlzO1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vZGVlcC1lcXVhbC9saWIva2V5cy5qc1xuICoqLyIsInZhciBzdXBwb3J0c0FyZ3VtZW50c0NsYXNzID0gKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnRzKVxufSkoKSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNBcmd1bWVudHNDbGFzcyA/IHN1cHBvcnRlZCA6IHVuc3VwcG9ydGVkO1xuXG5leHBvcnRzLnN1cHBvcnRlZCA9IHN1cHBvcnRlZDtcbmZ1bmN0aW9uIHN1cHBvcnRlZChvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcblxuZXhwb3J0cy51bnN1cHBvcnRlZCA9IHVuc3VwcG9ydGVkO1xuZnVuY3Rpb24gdW5zdXBwb3J0ZWQob2JqZWN0KXtcbiAgcmV0dXJuIG9iamVjdCAmJlxuICAgIHR5cGVvZiBvYmplY3QgPT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2Ygb2JqZWN0Lmxlbmd0aCA9PSAnbnVtYmVyJyAmJlxuICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdjYWxsZWUnKSAmJlxuICAgICFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCAnY2FsbGVlJykgfHxcbiAgICBmYWxzZTtcbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vfi9kZWVwLWVxdWFsL2xpYi9pc19hcmd1bWVudHMuanNcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDcmVhdGVkIGJ5IHh5IG9uIDE1LzQvMTYuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidXhjb3JlLXZhbGlkYXRvclwiKTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vYnVpbGQvVmFsaWRhdG9ycy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBWYWxpZGF0b3IgQ29tcG9uZW50IGZvciB1eGNvcmVcbiAqIEBhdXRob3IgZXRlcm5hbHNreVxuICpcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIFV4Y29yZSBUZWFtLCBBbGludy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL1ZhbGlkYXRvcicpO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtdmFsaWRhdG9yL2J1aWxkL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuLyoqXG4gKiBDcmVhdGVkIGJ5IHh5IG9uIDE1LzQvMTYuXG4gKi9cblxudmFyIFZhbGlkYXRvciA9IHt9O1xuXG52YXIgUEFUVEVSTiA9IHtcbiAgICBFTUFJTDogL14oW2EtejAtOV9cXC4tXSspQChbXFxkYS16XFwuLV0rKVxcLihbYS16XFwuXXsyLDZ9KSQvLFxuICAgIFVSTDogL14oaHR0cHM/OlxcL1xcLyk/KFtcXGRhLXpcXC4tXSspXFwuKFthLXpcXC5dezIsNn0pKFtcXC9cXHcgXFwuLV0qKSpcXC8/JC8sXG4gICAgSEVYOiAvXiM/KFthLWYwLTldezZ9fFthLWYwLTldezN9KSQvaSxcbiAgICBOVU06IC9eKCgtP1xcZCtcXC5cXGQrKXwoLT9cXGQrKXwoLT9cXC5cXGQrKSkkLyxcbiAgICBJRENBUkQ6IC8oXlxcZHsxNX0kKXwoXlxcZHsxN30oWzAtOV18WCkkKS9pLFxuICAgIENOTU9CSUxFOiAvXigwfDg2fDE3OTUxKT8oMTNbMC05XXwxNVswMTIzNTY3ODldfDE3WzA2NzhdfDE4WzAtOV18MTRbNTddKVswLTldezh9JC9cbn07XG5cblZhbGlkYXRvci5pc05vdEVtcHR5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gZW1wdHkgbWVhbnMgZW1wdHkgc3RyaW5nLCBlbXB0eSBhcnJheSwgZW1wdHkgb2JqZWN0ICYgbnVsbCAmIHVuZGVmaW5lZFxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoICE9PSAwO1xuICAgIH0gZWxzZSBpZiAoKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsdWUpKSA9PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCAhPT0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAhIWk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gISF2YWx1ZTtcbiAgICB9XG59O1xuXG5WYWxpZGF0b3IuaXNOdW0gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gUEFUVEVSTi5OVU0udGVzdCh2YWx1ZSk7XG59O1xuXG5WYWxpZGF0b3IuaXNJbnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gVmFsaWRhdG9yLmlzTnVtKHZhbHVlKSAmJiBwYXJzZUludCh2YWx1ZSkgPT0gdmFsdWU7XG59O1xuXG5WYWxpZGF0b3IuaXNEZWNpbWFsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIFZhbGlkYXRvci5pc051bSh2YWx1ZSkgJiYgIVZhbGlkYXRvci5pc0ludCh2YWx1ZSk7XG59O1xuXG5WYWxpZGF0b3IuaXNBcnJheSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn07XG5cblZhbGlkYXRvci5pc1JlZ0V4cCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuICEhbmV3IFJlZ0V4cCh2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcblxuVmFsaWRhdG9yLmlzT2JqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbHVlKSkgPT09ICdvYmplY3QnICYmICFWYWxpZGF0b3IuaXNBcnJheSh2YWx1ZSk7XG59O1xuXG5WYWxpZGF0b3IuaXNGdW5jID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cblZhbGlkYXRvci5pc0VtYWlsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgUEFUVEVSTi5FTUFJTC50ZXN0KHZhbHVlKTtcbn07XG5cblZhbGlkYXRvci5pc1VybCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIFBBVFRFUk4uVVJMLnRlc3QodmFsdWUpO1xufTtcblxuVmFsaWRhdG9yLmlzSGV4ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgUEFUVEVSTi5IRVgudGVzdCh2YWx1ZSk7XG59O1xuXG5WYWxpZGF0b3IuaXNJZENhcmQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBQQVRURVJOLklEQ0FSRC50ZXN0KHZhbHVlKTtcbn07XG5cblZhbGlkYXRvci5pc0NOTW9iaWxlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgUEFUVEVSTi5DTk1PQklMRS50ZXN0KHZhbHVlKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IFZhbGlkYXRvcjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLXZhbGlkYXRvci9idWlsZC9WYWxpZGF0b3IuanNcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qXG4gICAqIEVudGVyXG4gICAqL1xuICBFbnRlcjogMTNcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL2J1aWxkL0tleUNvZGUuanNcbiAqKi8iLCIvKiFcbiAqIEBsaWNlbnNlIGRlZXBjb3B5LmpzIENvcHlyaWdodChjKSAyMDEzIHNhc2ErMVxuICogaHR0cHM6Ly9naXRodWIuY29tL3Nhc2FwbHVzMS9kZWVwY29weS5qc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG5cblxuLyoqXG4gKiBleHBvcnQgdG8gQU1EL0NvbW1vbkpTL2dsb2JhbC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZ2xvYmFsIGdsb2JhbCBvYmplY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmYWN0b3J5IGZhY3RvcnkgbWV0aG9kLlxuICovXG4oZnVuY3Rpb24oZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhIWRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZmFjdG9yeSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSB7XG4gICAgZ2xvYmFsLmRlZXBjb3B5ID0gZmFjdG9yeSgpO1xuICB9XG59KHRoaXMsIGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGlzTm9kZSwgdXRpbCwgaXNCdWZmZXIsIGdldEtleXMsIGdldFN5bWJvbHMsIGluZGV4T2ZBcnJheTtcblxuICAvLyBpcyBub2RlLmpzL2lvLmpzP1xuICBpc05vZGUgPSAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJyk7XG5cbiAgLy8gZmFsbGJhY2sgdXRpbCBtb2R1bGUgZm9yIGJyb3dzZXIuXG4gIHV0aWwgPSAoaXNOb2RlKSA/IHJlcXVpcmUoJ3V0aWwnKSA6IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RhdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IERhdGVdJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNSZWdFeHAodmFsdWUpIHtcbiAgICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNBcnJheTogKHR5cGVvZiBBcnJheS5pc0FycmF5ID09PSAnZnVuY3Rpb24nKSA/XG4gICAgICAgICAgZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmopO1xuICAgICAgICAgIH0gOiBpc0FycmF5LFxuICAgICAgaXNEYXRlOiBpc0RhdGUsXG4gICAgICBpc1JlZ0V4cDogaXNSZWdFeHAsXG4gICAgICBpc1N5bWJvbDogKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpID9cbiAgICAgICAgICBpc1N5bWJvbCA6XG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBhbHdheXMgcmV0dXJuIGZhbHNlIHdoZW4gU3ltYm9sIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgIH07XG4gIH0oKSk7XG5cbiAgLy8gZmFsbGJhY2sgQnVmZmVyLmlzQnVmZmVyXG4gIGlzQnVmZmVyID0gKGlzTm9kZSkgP1xuICAgICAgZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKTtcbiAgICAgIH0gOlxuICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGlmIGJyb3dzZXIsIGFsd2F5cyByZXR1cm4gZmFsc2VcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcblxuICAvLyBmYWxsYmFjayBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzLlxuICBnZXRLZXlzID0gKHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJykgP1xuICAgICAgZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgfSA6XG4gICAgICBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgdmFyIGtleXMgPSBbXSxcbiAgICAgICAgICAgIGtleTtcblxuICAgICAgICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb2JqIGlzIG5vdCBhbiBPYmplY3QnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgICB9O1xuXG4gIC8vIGdldCBzeW1ib2xzIGluIG9iamVjdC5cbiAgZ2V0U3ltYm9scyA9ICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSA/XG4gICAgICBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKTtcbiAgICAgIH0gOlxuICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGFsd2F5cyByZXR1cm4gZW1wdHkgYXJyYXkgd2hlbiBTeW1ib2wgaXMgbm90IHN1cHBvcnRlZC5cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfTtcblxuICAvLyBmYWxsYmFjayBBcnJheSNpbmRleE9mIGZvciBvbGQgYnJvd3NlcnMuXG4gIGluZGV4T2ZBcnJheSA9ICh0eXBlb2YgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpID9cbiAgICAgIGZ1bmN0aW9uKGFycmF5LCBzZWFyY2hFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBhcnJheS5pbmRleE9mKHNlYXJjaEVsZW1lbnQpO1xuICAgICAgfSA6XG4gICAgICBmdW5jdGlvbihhcnJheSwgc2VhcmNoRWxlbWVudCkge1xuICAgICAgICB2YXIgaSwgbGVuO1xuXG4gICAgICAgIGlmICghdXRpbC5pc0FycmF5KGFycmF5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FycmF5IGlzIG5vdCBhbiBBcnJheScpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICBpZiAoYXJyYXlbaV0gPT09IHNlYXJjaEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH07XG5cbiAgLyoqXG4gICAqIHJlY3Vyc2l2ZSBkZWVwIGNvcHkgZm9yIHZhbHVlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIGNvcHkgdGFyZ2V0LlxuICAgKiBAcGFyYW0geyp9IGNsb25lXG4gICAqIEBwYXJhbSB7QXJyYXl9IHZpc2l0ZWRcbiAgICogQHBhcmFtIHtBcnJheX0gcmVmZXJlbmNlXG4gICAqIEByZXR1cm4geyp9IGNvcGllZCB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGNvcHlWYWx1ZV8odmFsdWUsIGNsb25lLCB2aXNpdGVkLCByZWZlcmVuY2UpIHtcbiAgICB2YXIgc3RyLCBwb3MsIGJ1Ziwga2V5cywgaSwgbGVuLCBrZXksIHZhbCwgaWR4LCBvYmosIHJlZjtcblxuICAgIC8vIG51bWJlciwgc3RyaW5nLCBib29sZWFuLCBudWxsLCB1bmRlZmluZWQsIGZ1bmN0aW9uIGFuZCBzeW1ib2wuXG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvLyBEYXRlLlxuICAgIGlmICh1dGlsLmlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIC8vIEZpcmVmb3ggbmVlZCB0byBjb252ZXJ0IHRvIE51bWJlclxuICAgICAgLy9cbiAgICAgIC8vIEZpcmVmb3g6XG4gICAgICAvLyAgIHZhciBkYXRlID0gbmV3IERhdGU7XG4gICAgICAvLyAgICtkYXRlOyAgICAgICAgICAgIC8vIDE0MjA5MDkzNjU5NjdcbiAgICAgIC8vICAgK25ldyBEYXRlKGRhdGUpOyAgLy8gMTQyMDkwOTM2NTAwMFxuICAgICAgLy8gICArbmV3IERhdGUoK2RhdGUpOyAvLyAxNDIwOTA5MzY1OTY3XG4gICAgICAvLyBDaHJvbWU6XG4gICAgICAvLyAgIHZhciBkYXRlID0gbmV3IERhdGU7XG4gICAgICAvLyAgICtkYXRlOyAgICAgICAgICAgIC8vIDE0MjA5MDk3NTc5MTNcbiAgICAgIC8vICAgK25ldyBEYXRlKGRhdGUpOyAgLy8gMTQyMDkwOTc1NzkxM1xuICAgICAgLy8gICArbmV3IERhdGUoK2RhdGUpOyAvLyAxNDIwOTA5NzU3OTEzXG4gICAgICByZXR1cm4gbmV3IERhdGUoK3ZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBSZWdFeHAuXG4gICAgaWYgKHV0aWwuaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICAvLyBDaHJvbWUsIFNhZmFyaTpcbiAgICAgIC8vICAgKG5ldyBSZWdFeHApLnNvdXJjZSA9PiBcIig/OilcIlxuICAgICAgLy8gRmlyZWZveDpcbiAgICAgIC8vICAgKG5ldyBSZWdFeHApLnNvdXJjZSA9PiBcIlwiXG4gICAgICAvLyBDaHJvbWUsIFNhZmFyaSwgRmlyZWZveFxuICAgICAgLy8gICBTdHJpbmcobmV3IFJlZ0V4cCkgPT4gXCIvKD86KS9cIlxuICAgICAgc3RyID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgIHBvcyA9IHN0ci5sYXN0SW5kZXhPZignLycpO1xuXG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cChzdHIuc2xpY2UoMSwgcG9zKSwgc3RyLnNsaWNlKHBvcyArIDEpKTtcbiAgICB9XG5cbiAgICAvLyBCdWZmZXIsIG5vZGUuanMgb25seS5cbiAgICBpZiAoaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICBidWYgPSBuZXcgQnVmZmVyKHZhbHVlLmxlbmd0aCk7XG4gICAgICB2YWx1ZS5jb3B5KGJ1Zik7XG5cbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuXG4gICAgLy8gT2JqZWN0IG9yIEFycmF5LlxuICAgIGtleXMgPSBnZXRLZXlzKHZhbHVlKS5jb25jYXQoZ2V0U3ltYm9scyh2YWx1ZSkpO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIHZhbCA9IHZhbHVlW2tleV07XG5cbiAgICAgIGlmICh2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWR4ID0gaW5kZXhPZkFycmF5KHZpc2l0ZWQsIHZhbCk7XG5cbiAgICAgICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgICAgICAvLyBub3QgY2lyY3VsYXIgcmVmZXJlbmNlXG4gICAgICAgICAgb2JqID0gKHV0aWwuaXNBcnJheSh2YWwpKSA/IFtdIDoge307XG5cbiAgICAgICAgICB2aXNpdGVkLnB1c2godmFsKTtcbiAgICAgICAgICByZWZlcmVuY2UucHVzaChvYmopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNpcmN1bGFyIHJlZmVyZW5jZVxuICAgICAgICAgIHJlZiA9IHJlZmVyZW5jZVtpZHhdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNsb25lW2tleV0gPSByZWYgfHwgY29weVZhbHVlXyh2YWwsIG9iaiwgdmlzaXRlZCwgcmVmZXJlbmNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cblxuICAvKipcbiAgICogZGVlcCBjb3B5IGZvciB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBjb3B5IHRhcmdldC5cbiAgICovXG4gIGZ1bmN0aW9uIGRlZXBjb3B5KHZhbHVlKSB7XG4gICAgdmFyIGNsb25lID0gKHV0aWwuaXNBcnJheSh2YWx1ZSkpID8gW10gOiB7fSxcbiAgICAgICAgdmlzaXRlZCA9IFt2YWx1ZV0sXG4gICAgICAgIHJlZmVyZW5jZSA9IFtjbG9uZV07XG5cbiAgICByZXR1cm4gY29weVZhbHVlXyh2YWx1ZSwgY2xvbmUsIHZpc2l0ZWQsIHJlZmVyZW5jZSk7XG4gIH1cblxuICByZXR1cm4gZGVlcGNvcHk7XG59KSk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vfi9kZWVwY29weS9kZWVwY29weS5qc1xuICoqLyIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxudmFyIHJvb3RQYXJlbnQgPSB7fVxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIFNhZmFyaSA1LTcgbGFja3Mgc3VwcG9ydCBmb3IgY2hhbmdpbmcgdGhlIGBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yYCBwcm9wZXJ0eVxuICogICAgIG9uIG9iamVjdHMuXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICBmdW5jdGlvbiBCYXIgKCkge31cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuZm9vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfVxuICAgIGFyci5jb25zdHJ1Y3RvciA9IEJhclxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIGFyci5jb25zdHJ1Y3RvciA9PT0gQmFyICYmIC8vIGNvbnN0cnVjdG9yIGNhbiBiZSBzZXRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuLyoqXG4gKiBDbGFzczogQnVmZmVyXG4gKiA9PT09PT09PT09PT09XG4gKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBhcmUgYXVnbWVudGVkXG4gKiB3aXRoIGZ1bmN0aW9uIHByb3BlcnRpZXMgZm9yIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBBUEkgZnVuY3Rpb25zLiBXZSB1c2VcbiAqIGBVaW50OEFycmF5YCBzbyB0aGF0IHNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0IHJldHVybnNcbiAqIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIEJ5IGF1Z21lbnRpbmcgdGhlIGluc3RhbmNlcywgd2UgY2FuIGF2b2lkIG1vZGlmeWluZyB0aGUgYFVpbnQ4QXJyYXlgXG4gKiBwcm90b3R5cGUuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgLy8gQXZvaWQgZ29pbmcgdGhyb3VnaCBhbiBBcmd1bWVudHNBZGFwdG9yVHJhbXBvbGluZSBpbiB0aGUgY29tbW9uIGNhc2UuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGFyZ3VtZW50c1sxXSlcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcpXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpcy5sZW5ndGggPSAwXG4gICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWRcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gZnJvbU51bWJlcih0aGlzLCBhcmcpXG4gIH1cblxuICAvLyBTbGlnaHRseSBsZXNzIGNvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGlzLCBhcmcsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogJ3V0ZjgnKVxuICB9XG5cbiAgLy8gVW51c3VhbC5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhpcywgYXJnKVxufVxuXG5mdW5jdGlvbiBmcm9tTnVtYmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChsZW5ndGgpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIC8vIEFzc3VtcHRpb246IGJ5dGVMZW5ndGgoKSByZXR1cm4gdmFsdWUgaXMgYWx3YXlzIDwga01heExlbmd0aC5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG5cbiAgdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmplY3QpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmplY3QpKSByZXR1cm4gZnJvbUJ1ZmZlcih0aGF0LCBvYmplY3QpXG5cbiAgaWYgKGlzQXJyYXkob2JqZWN0KSkgcmV0dXJuIGZyb21BcnJheSh0aGF0LCBvYmplY3QpXG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbXVzdCBzdGFydCB3aXRoIG51bWJlciwgYnVmZmVyLCBhcnJheSBvciBzdHJpbmcnKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAob2JqZWN0LmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gZnJvbVR5cGVkQXJyYXkodGhhdCwgb2JqZWN0KVxuICAgIH1cbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgb2JqZWN0KVxuICAgIH1cbiAgfVxuXG4gIGlmIChvYmplY3QubGVuZ3RoKSByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmplY3QpXG5cbiAgcmV0dXJuIGZyb21Kc29uT2JqZWN0KHRoYXQsIG9iamVjdClcbn1cblxuZnVuY3Rpb24gZnJvbUJ1ZmZlciAodGhhdCwgYnVmZmVyKSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGJ1ZmZlci5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICBidWZmZXIuY29weSh0aGF0LCAwLCAwLCBsZW5ndGgpXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8vIER1cGxpY2F0ZSBvZiBmcm9tQXJyYXkoKSB0byBrZWVwIGZyb21BcnJheSgpIG1vbm9tb3JwaGljLlxuZnVuY3Rpb24gZnJvbVR5cGVkQXJyYXkgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIC8vIFRydW5jYXRpbmcgdGhlIGVsZW1lbnRzIGlzIHByb2JhYmx5IG5vdCB3aGF0IHBlb3BsZSBleHBlY3QgZnJvbSB0eXBlZFxuICAvLyBhcnJheXMgd2l0aCBCWVRFU19QRVJfRUxFTUVOVCA+IDEgYnV0IGl0J3MgY29tcGF0aWJsZSB3aXRoIHRoZSBiZWhhdmlvclxuICAvLyBvZiB0aGUgb2xkIEJ1ZmZlciBjb25zdHJ1Y3Rvci5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXkpIHtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgYXJyYXkuYnl0ZUxlbmd0aFxuICAgIHRoYXQgPSBCdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkoYXJyYXkpKVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbVR5cGVkQXJyYXkodGhhdCwgbmV3IFVpbnQ4QXJyYXkoYXJyYXkpKVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vLyBEZXNlcmlhbGl6ZSB7IHR5cGU6ICdCdWZmZXInLCBkYXRhOiBbMSwyLDMsLi4uXSB9IGludG8gYSBCdWZmZXIgb2JqZWN0LlxuLy8gUmV0dXJucyBhIHplcm8tbGVuZ3RoIGJ1ZmZlciBmb3IgaW5wdXRzIHRoYXQgZG9uJ3QgY29uZm9ybSB0byB0aGUgc3BlYy5cbmZ1bmN0aW9uIGZyb21Kc29uT2JqZWN0ICh0aGF0LCBvYmplY3QpIHtcbiAgdmFyIGFycmF5XG4gIHZhciBsZW5ndGggPSAwXG5cbiAgaWYgKG9iamVjdC50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iamVjdC5kYXRhKSkge1xuICAgIGFycmF5ID0gb2JqZWN0LmRhdGFcbiAgICBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIH1cbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbn0gZWxzZSB7XG4gIC8vIHByZS1zZXQgZm9yIHZhbHVlcyB0aGF0IG1heSBleGlzdCBpbiB0aGUgZnV0dXJlXG4gIEJ1ZmZlci5wcm90b3R5cGUubGVuZ3RoID0gdW5kZWZpbmVkXG4gIEJ1ZmZlci5wcm90b3R5cGUucGFyZW50ID0gdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGFsbG9jYXRlICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShsZW5ndGgpKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICAgIHRoYXQuX2lzQnVmZmVyID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGZyb21Qb29sID0gbGVuZ3RoICE9PSAwICYmIGxlbmd0aCA8PSBCdWZmZXIucG9vbFNpemUgPj4+IDFcbiAgaWYgKGZyb21Qb29sKSB0aGF0LnBhcmVudCA9IHJvb3RQYXJlbnRcblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKHN1YmplY3QsIGVuY29kaW5nKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTbG93QnVmZmVyKSkgcmV0dXJuIG5ldyBTbG93QnVmZmVyKHN1YmplY3QsIGVuY29kaW5nKVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHN1YmplY3QsIGVuY29kaW5nKVxuICBkZWxldGUgYnVmLnBhcmVudFxuICByZXR1cm4gYnVmXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICB2YXIgaSA9IDBcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIGJyZWFrXG5cbiAgICArK2lcbiAgfVxuXG4gIGlmIChpICE9PSBsZW4pIHtcbiAgICB4ID0gYVtpXVxuICAgIHkgPSBiW2ldXG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xpc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzLicpXG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIGl0ZW0uY29weShidWYsIHBvcylcbiAgICBwb3MgKz0gaXRlbS5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSBzdHJpbmcgPSAnJyArIHN0cmluZ1xuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgLy8gRGVwcmVjYXRlZFxuICAgICAgY2FzZSAncmF3JzpcbiAgICAgIGNhc2UgJ3Jhd3MnOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIHN0YXJ0ID0gc3RhcnQgfCAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA9PT0gSW5maW5pdHkgPyB0aGlzLmxlbmd0aCA6IGVuZCB8IDBcblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoZW5kIDw9IHN0YXJ0KSByZXR1cm4gJydcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBiaW5hcnlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIDBcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCkge1xuICBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIGJ5dGVPZmZzZXQgPj49IDBcblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAtMVxuICBpZiAoYnl0ZU9mZnNldCA+PSB0aGlzLmxlbmd0aCkgcmV0dXJuIC0xXG5cbiAgLy8gTmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBNYXRoLm1heCh0aGlzLmxlbmd0aCArIGJ5dGVPZmZzZXQsIDApXG5cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHJldHVybiAtMSAvLyBzcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZyBhbHdheXMgZmFpbHNcbiAgICByZXR1cm4gU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICB9XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIHJldHVybiBhcnJheUluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICB9XG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZih0aGlzLCBbIHZhbCBdLCBieXRlT2Zmc2V0KVxuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCkge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKHZhciBpID0gMDsgYnl0ZU9mZnNldCArIGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhcnJbYnl0ZU9mZnNldCArIGldID09PSB2YWxbZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXhdKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsLmxlbmd0aCkgcmV0dXJuIGJ5dGVPZmZzZXQgKyBmb3VuZEluZGV4XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG4vLyBgZ2V0YCBpcyBkZXByZWNhdGVkXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAob2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuZ2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy5yZWFkVUludDgob2Zmc2V0KVxufVxuXG4vLyBgc2V0YCBpcyBkZXByZWNhdGVkXG5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAodiwgb2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuc2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy53cml0ZVVJbnQ4KHYsIG9mZnNldClcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiaW5hcnlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgb2Zmc2V0ID0gbGVuZ3RoIHwgMFxuICAgIGxlbmd0aCA9IHN3YXBcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdhdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYmluYXJ5V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBiaW5hcnlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gQnVmZmVyLl9hdWdtZW50KHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCkpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgaSsrKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICBpZiAobmV3QnVmLmxlbmd0aCkgbmV3QnVmLnBhcmVudCA9IHRoaXMucGFyZW50IHx8IHRoaXNcblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J1ZmZlciBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndmFsdWUgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCksIDApXG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCksIDApXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSB2YWx1ZSA8IDAgPyAxIDogMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IHZhbHVlIDwgMCA/IDEgOiAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuX3NldCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksIHRhcmdldFN0YXJ0KVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBmaWxsKHZhbHVlLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIGlmICghdmFsdWUpIHZhbHVlID0gMFxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQpIGVuZCA9IHRoaXMubGVuZ3RoXG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5kIDwgc3RhcnQnKVxuXG4gIC8vIEZpbGwgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3N0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2VuZCBvdXQgb2YgYm91bmRzJylcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSB2YWx1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSB1dGY4VG9CeXRlcyh2YWx1ZS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYEFycmF5QnVmZmVyYCB3aXRoIHRoZSAqY29waWVkKiBtZW1vcnkgb2YgdGhlIGJ1ZmZlciBpbnN0YW5jZS5cbiAqIEFkZGVkIGluIE5vZGUgMC4xMi4gT25seSBhdmFpbGFibGUgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEFycmF5QnVmZmVyLlxuICovXG5CdWZmZXIucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiB0b0FycmF5QnVmZmVyICgpIHtcbiAgaWYgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgICAgcmV0dXJuIChuZXcgQnVmZmVyKHRoaXMpKS5idWZmZXJcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBidWZbaV0gPSB0aGlzW2ldXG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmLmJ1ZmZlclxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCdWZmZXIudG9BcnJheUJ1ZmZlciBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpXG4gIH1cbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgQlAgPSBCdWZmZXIucHJvdG90eXBlXG5cbi8qKlxuICogQXVnbWVudCBhIFVpbnQ4QXJyYXkgKmluc3RhbmNlKiAobm90IHRoZSBVaW50OEFycmF5IGNsYXNzISkgd2l0aCBCdWZmZXIgbWV0aG9kc1xuICovXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiBfYXVnbWVudCAoYXJyKSB7XG4gIGFyci5jb25zdHJ1Y3RvciA9IEJ1ZmZlclxuICBhcnIuX2lzQnVmZmVyID0gdHJ1ZVxuXG4gIC8vIHNhdmUgcmVmZXJlbmNlIHRvIG9yaWdpbmFsIFVpbnQ4QXJyYXkgc2V0IG1ldGhvZCBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgYXJyLl9zZXQgPSBhcnIuc2V0XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBhcnIuZ2V0ID0gQlAuZ2V0XG4gIGFyci5zZXQgPSBCUC5zZXRcblxuICBhcnIud3JpdGUgPSBCUC53cml0ZVxuICBhcnIudG9TdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9Mb2NhbGVTdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9KU09OID0gQlAudG9KU09OXG4gIGFyci5lcXVhbHMgPSBCUC5lcXVhbHNcbiAgYXJyLmNvbXBhcmUgPSBCUC5jb21wYXJlXG4gIGFyci5pbmRleE9mID0gQlAuaW5kZXhPZlxuICBhcnIuY29weSA9IEJQLmNvcHlcbiAgYXJyLnNsaWNlID0gQlAuc2xpY2VcbiAgYXJyLnJlYWRVSW50TEUgPSBCUC5yZWFkVUludExFXG4gIGFyci5yZWFkVUludEJFID0gQlAucmVhZFVJbnRCRVxuICBhcnIucmVhZFVJbnQ4ID0gQlAucmVhZFVJbnQ4XG4gIGFyci5yZWFkVUludDE2TEUgPSBCUC5yZWFkVUludDE2TEVcbiAgYXJyLnJlYWRVSW50MTZCRSA9IEJQLnJlYWRVSW50MTZCRVxuICBhcnIucmVhZFVJbnQzMkxFID0gQlAucmVhZFVJbnQzMkxFXG4gIGFyci5yZWFkVUludDMyQkUgPSBCUC5yZWFkVUludDMyQkVcbiAgYXJyLnJlYWRJbnRMRSA9IEJQLnJlYWRJbnRMRVxuICBhcnIucmVhZEludEJFID0gQlAucmVhZEludEJFXG4gIGFyci5yZWFkSW50OCA9IEJQLnJlYWRJbnQ4XG4gIGFyci5yZWFkSW50MTZMRSA9IEJQLnJlYWRJbnQxNkxFXG4gIGFyci5yZWFkSW50MTZCRSA9IEJQLnJlYWRJbnQxNkJFXG4gIGFyci5yZWFkSW50MzJMRSA9IEJQLnJlYWRJbnQzMkxFXG4gIGFyci5yZWFkSW50MzJCRSA9IEJQLnJlYWRJbnQzMkJFXG4gIGFyci5yZWFkRmxvYXRMRSA9IEJQLnJlYWRGbG9hdExFXG4gIGFyci5yZWFkRmxvYXRCRSA9IEJQLnJlYWRGbG9hdEJFXG4gIGFyci5yZWFkRG91YmxlTEUgPSBCUC5yZWFkRG91YmxlTEVcbiAgYXJyLnJlYWREb3VibGVCRSA9IEJQLnJlYWREb3VibGVCRVxuICBhcnIud3JpdGVVSW50OCA9IEJQLndyaXRlVUludDhcbiAgYXJyLndyaXRlVUludExFID0gQlAud3JpdGVVSW50TEVcbiAgYXJyLndyaXRlVUludEJFID0gQlAud3JpdGVVSW50QkVcbiAgYXJyLndyaXRlVUludDE2TEUgPSBCUC53cml0ZVVJbnQxNkxFXG4gIGFyci53cml0ZVVJbnQxNkJFID0gQlAud3JpdGVVSW50MTZCRVxuICBhcnIud3JpdGVVSW50MzJMRSA9IEJQLndyaXRlVUludDMyTEVcbiAgYXJyLndyaXRlVUludDMyQkUgPSBCUC53cml0ZVVJbnQzMkJFXG4gIGFyci53cml0ZUludExFID0gQlAud3JpdGVJbnRMRVxuICBhcnIud3JpdGVJbnRCRSA9IEJQLndyaXRlSW50QkVcbiAgYXJyLndyaXRlSW50OCA9IEJQLndyaXRlSW50OFxuICBhcnIud3JpdGVJbnQxNkxFID0gQlAud3JpdGVJbnQxNkxFXG4gIGFyci53cml0ZUludDE2QkUgPSBCUC53cml0ZUludDE2QkVcbiAgYXJyLndyaXRlSW50MzJMRSA9IEJQLndyaXRlSW50MzJMRVxuICBhcnIud3JpdGVJbnQzMkJFID0gQlAud3JpdGVJbnQzMkJFXG4gIGFyci53cml0ZUZsb2F0TEUgPSBCUC53cml0ZUZsb2F0TEVcbiAgYXJyLndyaXRlRmxvYXRCRSA9IEJQLndyaXRlRmxvYXRCRVxuICBhcnIud3JpdGVEb3VibGVMRSA9IEJQLndyaXRlRG91YmxlTEVcbiAgYXJyLndyaXRlRG91YmxlQkUgPSBCUC53cml0ZURvdWJsZUJFXG4gIGFyci5maWxsID0gQlAuZmlsbFxuICBhcnIuaW5zcGVjdCA9IEJQLmluc3BlY3RcbiAgYXJyLnRvQXJyYXlCdWZmZXIgPSBCUC50b0FycmF5QnVmZmVyXG5cbiAgcmV0dXJuIGFyclxufVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spL34vbm9kZS1saWJzLWJyb3dzZXIvfi9idWZmZXIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAzNDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cbjsoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG4gIHZhciBBcnIgPSAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgID8gVWludDhBcnJheVxuICAgIDogQXJyYXlcblxuXHR2YXIgUExVUyAgID0gJysnLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIICA9ICcvJy5jaGFyQ29kZUF0KDApXG5cdHZhciBOVU1CRVIgPSAnMCcuY2hhckNvZGVBdCgwKVxuXHR2YXIgTE9XRVIgID0gJ2EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFVQUEVSICA9ICdBJy5jaGFyQ29kZUF0KDApXG5cdHZhciBQTFVTX1VSTF9TQUZFID0gJy0nLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIX1VSTF9TQUZFID0gJ18nLmNoYXJDb2RlQXQoMClcblxuXHRmdW5jdGlvbiBkZWNvZGUgKGVsdCkge1xuXHRcdHZhciBjb2RlID0gZWx0LmNoYXJDb2RlQXQoMClcblx0XHRpZiAoY29kZSA9PT0gUExVUyB8fFxuXHRcdCAgICBjb2RlID09PSBQTFVTX1VSTF9TQUZFKVxuXHRcdFx0cmV0dXJuIDYyIC8vICcrJ1xuXHRcdGlmIChjb2RlID09PSBTTEFTSCB8fFxuXHRcdCAgICBjb2RlID09PSBTTEFTSF9VUkxfU0FGRSlcblx0XHRcdHJldHVybiA2MyAvLyAnLydcblx0XHRpZiAoY29kZSA8IE5VTUJFUilcblx0XHRcdHJldHVybiAtMSAvL25vIG1hdGNoXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIgKyAxMClcblx0XHRcdHJldHVybiBjb2RlIC0gTlVNQkVSICsgMjYgKyAyNlxuXHRcdGlmIChjb2RlIDwgVVBQRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gVVBQRVJcblx0XHRpZiAoY29kZSA8IExPV0VSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIExPV0VSICsgMjZcblx0fVxuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5IChiNjQpIHtcblx0XHR2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuXG5cdFx0aWYgKGI2NC5sZW5ndGggJSA0ID4gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Jylcblx0XHR9XG5cblx0XHQvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuXHRcdC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcblx0XHQvLyByZXByZXNlbnQgb25lIGJ5dGVcblx0XHQvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcblx0XHQvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG5cdFx0dmFyIGxlbiA9IGI2NC5sZW5ndGhcblx0XHRwbGFjZUhvbGRlcnMgPSAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMikgPyAyIDogJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDEpID8gMSA6IDBcblxuXHRcdC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuXHRcdGFyciA9IG5ldyBBcnIoYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoXG5cblx0XHR2YXIgTCA9IDBcblxuXHRcdGZ1bmN0aW9uIHB1c2ggKHYpIHtcblx0XHRcdGFycltMKytdID0gdlxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTgpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgMTIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPDwgNikgfCBkZWNvZGUoYjY0LmNoYXJBdChpICsgMykpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDAwMCkgPj4gMTYpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDApID4+IDgpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0aWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpID4+IDQpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTApIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgNCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA+PiAyKVxuXHRcdFx0cHVzaCgodG1wID4+IDgpICYgMHhGRilcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJyXG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0ICh1aW50OCkge1xuXHRcdHZhciBpLFxuXHRcdFx0ZXh0cmFCeXRlcyA9IHVpbnQ4Lmxlbmd0aCAlIDMsIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG5cdFx0XHRvdXRwdXQgPSBcIlwiLFxuXHRcdFx0dGVtcCwgbGVuZ3RoXG5cblx0XHRmdW5jdGlvbiBlbmNvZGUgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cC5jaGFyQXQobnVtKVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG5cdFx0XHRyZXR1cm4gZW5jb2RlKG51bSA+PiAxOCAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiAxMiAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiA2ICYgMHgzRikgKyBlbmNvZGUobnVtICYgMHgzRilcblx0XHR9XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuXHRcdFx0b3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCh0ZW1wKVxuXHRcdH1cblxuXHRcdC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcblx0XHRzd2l0Y2ggKGV4dHJhQnl0ZXMpIHtcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0dGVtcCA9IHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAyKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9PSdcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0dGVtcCA9ICh1aW50OFt1aW50OC5sZW5ndGggLSAyXSA8PCA4KSArICh1aW50OFt1aW50OC5sZW5ndGggLSAxXSlcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDEwKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wID4+IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCAyKSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPSdcblx0XHRcdFx0YnJlYWtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0XG5cdH1cblxuXHRleHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXlcblx0ZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gdWludDhUb0Jhc2U2NFxufSh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgPyAodGhpcy5iYXNlNjRqcyA9IHt9KSA6IGV4cG9ydHMpKVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjaykvfi9ub2RlLWxpYnMtYnJvd3Nlci9+L2J1ZmZlci9+L2Jhc2U2NC1qcy9saWIvYjY0LmpzXG4gKiogbW9kdWxlIGlkID0gMzQzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spL34vbm9kZS1saWJzLWJyb3dzZXIvfi9idWZmZXIvfi9pZWVlNzU0L2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMzQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spL34vbm9kZS1saWJzLWJyb3dzZXIvfi9idWZmZXIvfi9pc2FycmF5L2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMzQ1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS9+L25vZGUtbGlicy1icm93c2VyL34vdXRpbC91dGlsLmpzXG4gKiogbW9kdWxlIGlkID0gMzQ2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjaykvfi9ub2RlLWxpYnMtYnJvd3Nlci9+L3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAzNDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjaykvfi9ub2RlLWxpYnMtYnJvd3Nlci9+L3V0aWwvfi9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMzQ4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBDcmVhdGVkIGJ5IHh5IG9uIDE1LzQvMTMuXG4gKi9cbnZhciBGb3JtRmllbGQgPSByZXF1aXJlKCcuL0Zvcm1GaWVsZCcpO1xudmFyIENvbnN0YW50cyA9IHJlcXVpcmUoXCJ1eGNvcmUtY29uc3RcIik7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgVGV4dEFyZWFGb3JtRmllbGQgPSBmdW5jdGlvbiAoX0Zvcm1GaWVsZCkge1xuICAgIF9pbmhlcml0cyhUZXh0QXJlYUZvcm1GaWVsZCwgX0Zvcm1GaWVsZCk7XG5cbiAgICBmdW5jdGlvbiBUZXh0QXJlYUZvcm1GaWVsZChwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dEFyZWFGb3JtRmllbGQpO1xuXG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfRm9ybUZpZWxkLmNhbGwodGhpcywgcHJvcHMpKTtcbiAgICB9XG5cbiAgICBUZXh0QXJlYUZvcm1GaWVsZC5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKGUpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIGF1dG9UcmltID0gbWUucHJvcHMuYXV0b1RyaW07XG5cbiAgICAgICAgdmFyIHZhbHVlID0gZS5jdXJyZW50VGFyZ2V0LnZhbHVlO1xuICAgICAgICBpZiAoYXV0b1RyaW0pIHtcbiAgICAgICAgICAgIHZhbHVlID0gbWUudHJpbSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbWUuaGFuZGxlRGF0YUNoYW5nZSh2YWx1ZSk7XG4gICAgfTtcblxuICAgIFRleHRBcmVhRm9ybUZpZWxkLnByb3RvdHlwZS50cmltID0gZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oXlxccyt8XFxzKyQpL2csIFwiXCIpO1xuICAgIH07XG5cbiAgICBUZXh0QXJlYUZvcm1GaWVsZC5wcm90b3R5cGUuYWRkU3BlY2lmaWNDbGFzcyA9IGZ1bmN0aW9uIGFkZFNwZWNpZmljQ2xhc3MoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIGlmIChtZS5wcm9wcy5qc3hwcmVmaXhDbHMgPT0gXCJrdW1hLXV4Zm9ybS1maWVsZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbWUucHJvcHMuanN4cHJlZml4Q2xzICsgXCIga3VtYS10ZXh0YXJlYS11eGZvcm0tZmllbGRcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtZS5wcm9wcy5qc3hwcmVmaXhDbHM7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgVGV4dEFyZWFGb3JtRmllbGQucHJvdG90eXBlLmhhbmRsZUZvY3VzID0gZnVuY3Rpb24gaGFuZGxlRm9jdXMoZSkge1xuICAgICAgICB0aGlzLnByb3BzLm9uRm9jdXMoZSk7XG4gICAgfTtcblxuICAgIFRleHRBcmVhRm9ybUZpZWxkLnByb3RvdHlwZS5oYW5kbGVCbHVyID0gZnVuY3Rpb24gaGFuZGxlQmx1cihlKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBwYXNzID0gdHJ1ZTtcbiAgICAgICAgaWYgKG1lLnByb3BzLnZhbGlkYXRlT25CbHVyKSB7XG4gICAgICAgICAgICBwYXNzID0gbWUuZG9WYWxpZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIG1lLnByb3BzLm9uQmx1cihlLCBwYXNzKTtcbiAgICB9O1xuXG4gICAgVGV4dEFyZWFGb3JtRmllbGQucHJvdG90eXBlLmhhbmRsZUtleURvd24gPSBmdW5jdGlvbiBoYW5kbGVLZXlEb3duKGUpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgbWUucHJvcHMub25LZXlEb3duKGUpO1xuICAgIH07XG5cbiAgICBUZXh0QXJlYUZvcm1GaWVsZC5wcm90b3R5cGUucmVuZGVyRmllbGQgPSBmdW5jdGlvbiByZW5kZXJGaWVsZCgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIG1vZGUgPSBtZS5wcm9wcy5qc3htb2RlIHx8IG1lLnByb3BzLm1vZGU7XG4gICAgICAgIGlmIChtb2RlID09IENvbnN0YW50cy5NT0RFLkVESVQpIHtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScsIHtcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogbWUucHJvcHMuanN4ZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IG1lLnByb3BzLmpzeHBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2t1bWEtdGV4dGFyZWEnLFxuICAgICAgICAgICAgICAgIHJlZjogJ3Jvb3QnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBtZS5zdGF0ZS52YWx1ZSB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBtZS5oYW5kbGVDaGFuZ2UuYmluZChtZSksXG4gICAgICAgICAgICAgICAgb25Gb2N1czogbWUuaGFuZGxlRm9jdXMuYmluZChtZSksXG4gICAgICAgICAgICAgICAgb25CbHVyOiBtZS5oYW5kbGVCbHVyLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgIG9uS2V5RG93bjogbWUuaGFuZGxlS2V5RG93bi5iaW5kKG1lKSB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChtb2RlID09IENvbnN0YW50cy5NT0RFLlZJRVcpIHtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIG1lLnN0YXRlLnZhbHVlXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBUZXh0QXJlYUZvcm1GaWVsZDtcbn0oRm9ybUZpZWxkKTtcblxuVGV4dEFyZWFGb3JtRmllbGQuZGlzcGxheU5hbWUgPSBcIlRleHRBcmVhRm9ybUZpZWxkXCI7XG5UZXh0QXJlYUZvcm1GaWVsZC5wcm9wVHlwZXMgPSBhc3NpZ24oe30sIEZvcm1GaWVsZC5wcm9wVHlwZXMsIHtcbiAgICBvbkJsdXI6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uRm9jdXM6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uS2V5RG93bjogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgdmFsaWRhdGVPbkJsdXI6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGF1dG9UcmltOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbFxufSk7XG5UZXh0QXJlYUZvcm1GaWVsZC5kZWZhdWx0UHJvcHMgPSBhc3NpZ24oe30sIEZvcm1GaWVsZC5kZWZhdWx0UHJvcHMsIHtcbiAgICBvbkJsdXI6IGZ1bmN0aW9uIG9uQmx1cigpIHt9LFxuICAgIG9uRm9jdXM6IGZ1bmN0aW9uIG9uRm9jdXMoKSB7fSxcbiAgICBvbktleURvd246IGZ1bmN0aW9uIG9uS2V5RG93bigpIHt9LFxuICAgIHZhbGlkYXRlT25CbHVyOiBmYWxzZVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IFRleHRBcmVhRm9ybUZpZWxkO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9idWlsZC9Gb3JtRmllbGQvVGV4dEFyZWFGb3JtRmllbGQuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xudmFyIEZvcm1GaWVsZCA9IHJlcXVpcmUoJy4vRm9ybUZpZWxkJyk7XG52YXIgQ29uc3RhbnRzID0gcmVxdWlyZShcInV4Y29yZS1jb25zdFwiKTtcbnZhciBjbGFzc25hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIEZvcm1Db3VudCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzKEZvcm1Db3VudCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBGb3JtQ291bnQocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvcm1Db3VudCk7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuICAgIH1cblxuICAgIEZvcm1Db3VudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdrdW1hLXV4Zm9ybS1jb3VudCcgfSxcbiAgICAgICAgICAgIG1lLnByb3BzLmxlbmd0aCArIFwiL1wiICsgbWUucHJvcHMudG90YWxcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEZvcm1Db3VudDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuRm9ybUNvdW50LmRlZmF1bHRQcm9wcyA9IHt9O1xuRm9ybUNvdW50LnByb3BUeXBlcyA9IHtcbiAgICBsZW5ndGg6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgdG90YWw6IFJlYWN0LlByb3BUeXBlcy5udW1iZXJcbn07XG5cbkZvcm1Db3VudC5kaXNwbGF5TmFtZSA9IFwiRm9ybUNvdW50XCI7XG5cbnZhciBMZWZ0QWRkb24gPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudDIpIHtcbiAgICBfaW5oZXJpdHMoTGVmdEFkZG9uLCBfUmVhY3QkQ29tcG9uZW50Mik7XG5cbiAgICBmdW5jdGlvbiBMZWZ0QWRkb24ocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExlZnRBZGRvbik7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQyLmNhbGwodGhpcywgcHJvcHMpKTtcbiAgICB9XG5cbiAgICBMZWZ0QWRkb24ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBjbGFzc25hbWVzKHtcbiAgICAgICAgICAgICAgICAgICAgXCJrdW1hLXV4Zm9ybS1sZWZ0LWljb25cIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgXCJrdW1hLXV4Zm9ybS1sZWZ0LWljb24tZm9jdXNcIjogISFtZS5wcm9wcy5mb2N1c1xuICAgICAgICAgICAgICAgIH0pIH0sXG4gICAgICAgICAgICBtZS5wcm9wcy5jaGlsZHJlblxuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gTGVmdEFkZG9uO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5MZWZ0QWRkb24uZGVmYXVsdFByb3BzID0ge307XG5MZWZ0QWRkb24ucHJvcFR5cGVzID0ge307XG5MZWZ0QWRkb24uZGlzcGxheU5hbWUgPSBcIkxlZnRBZGRvblwiO1xuXG52YXIgUmlnaHRBZGRvbiA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50Mykge1xuICAgIF9pbmhlcml0cyhSaWdodEFkZG9uLCBfUmVhY3QkQ29tcG9uZW50Myk7XG5cbiAgICBmdW5jdGlvbiBSaWdodEFkZG9uKHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSaWdodEFkZG9uKTtcblxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudDMuY2FsbCh0aGlzLCBwcm9wcykpO1xuICAgIH1cblxuICAgIFJpZ2h0QWRkb24ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAna3VtYS11eGZvcm0tcmlnaHQtaWNvbiAnIH0sXG4gICAgICAgICAgICBtZS5wcm9wcy5jaGlsZHJlblxuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gUmlnaHRBZGRvbjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuUmlnaHRBZGRvbi5kZWZhdWx0UHJvcHMgPSB7fTtcblJpZ2h0QWRkb24ucHJvcFR5cGVzID0ge307XG5SaWdodEFkZG9uLmRpc3BsYXlOYW1lID0gXCJSaWdodEFkZG9uXCI7XG5cbi8qKlxuICogZXh0ZW5kIEZvcm1GaWVsZCwgcmV3cml0ZSByZW5kZXJGaWVsZCBtZXRob2RcbiAqL1xuXG52YXIgSW5wdXRGb3JtRmllbGQgPSBmdW5jdGlvbiAoX0Zvcm1GaWVsZCkge1xuICAgIF9pbmhlcml0cyhJbnB1dEZvcm1GaWVsZCwgX0Zvcm1GaWVsZCk7XG5cbiAgICBmdW5jdGlvbiBJbnB1dEZvcm1GaWVsZChwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5wdXRGb3JtRmllbGQpO1xuXG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfRm9ybUZpZWxkLmNhbGwodGhpcywgcHJvcHMpKTtcbiAgICB9XG5cbiAgICBJbnB1dEZvcm1GaWVsZC5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMucmVmcy5yb290KS52YWx1ZSgpO1xuICAgIH07XG5cbiAgICBJbnB1dEZvcm1GaWVsZC5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKGUpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIGF1dG9UcmltID0gbWUucHJvcHMuYXV0b1RyaW07XG5cbiAgICAgICAgdmFyIHZhbHVlID0gZS5jdXJyZW50VGFyZ2V0LnZhbHVlO1xuICAgICAgICBpZiAoYXV0b1RyaW0pIHtcbiAgICAgICAgICAgIHZhbHVlID0gbWUudHJpbSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbWUuaGFuZGxlRGF0YUNoYW5nZShtZS5kZUZvcm1hdFZhbHVlKHZhbHVlKSk7XG4gICAgfTtcblxuICAgIElucHV0Rm9ybUZpZWxkLnByb3RvdHlwZS50cmltID0gZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oXlxccyt8XFxzKyQpL2csIFwiXCIpO1xuICAgIH07XG5cbiAgICBJbnB1dEZvcm1GaWVsZC5wcm90b3R5cGUuaGFuZGxlRm9jdXMgPSBmdW5jdGlvbiBoYW5kbGVGb2N1cyhlKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZm9jdXM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHJvcHMub25Gb2N1cyhlKTtcbiAgICB9O1xuXG4gICAgSW5wdXRGb3JtRmllbGQucHJvdG90eXBlLmhhbmRsZUJsdXIgPSBmdW5jdGlvbiBoYW5kbGVCbHVyKGUpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgbWUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZm9jdXM6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcGFzcyA9IHRydWU7XG4gICAgICAgIGlmIChtZS5wcm9wcy52YWxpZGF0ZU9uQmx1cikge1xuICAgICAgICAgICAgcGFzcyA9IG1lLmRvVmFsaWRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBtZS5wcm9wcy5vbkJsdXIoZSwgcGFzcyk7XG4gICAgfTtcblxuICAgIElucHV0Rm9ybUZpZWxkLnByb3RvdHlwZS5oYW5kbGVLZXlEb3duID0gZnVuY3Rpb24gaGFuZGxlS2V5RG93bihlKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIG1lLnByb3BzLm9uS2V5RG93bihlKTtcbiAgICB9O1xuXG4gICAgSW5wdXRGb3JtRmllbGQucHJvdG90eXBlLmRlRm9ybWF0VmFsdWUgPSBmdW5jdGlvbiBkZUZvcm1hdFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgSW5wdXRGb3JtRmllbGQucHJvdG90eXBlLmFkZFNwZWNpZmljQ2xhc3MgPSBmdW5jdGlvbiBhZGRTcGVjaWZpY0NsYXNzKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBpZiAobWUucHJvcHMuanN4cHJlZml4Q2xzID09IFwia3VtYS11eGZvcm0tZmllbGRcIikge1xuICAgICAgICAgICAgcmV0dXJuIG1lLnByb3BzLmpzeHByZWZpeENscyArIFwiIGt1bWEtaW5wdXQtdXhmb3JtLWZpZWxkXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbWUucHJvcHMuanN4cHJlZml4Q2xzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIElucHV0Rm9ybUZpZWxkLnByb3RvdHlwZS5nZXRDb3VudCA9IGZ1bmN0aW9uIGdldENvdW50KCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBtZS5wcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB2b2lkIDA7XG4gICAgICAgIFJlYWN0LkNoaWxkcmVuLm1hcChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgJiYgdHlwZW9mIGNoaWxkLnR5cGUgPT0gJ2Z1bmN0aW9uJyAmJiBjaGlsZC50eXBlLmRpc3BsYXlOYW1lID09ICdGb3JtQ291bnQnKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGNoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCEhZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHRvdGFsID0gZWxlbWVudC5wcm9wcy50b3RhbDtcbiAgICAgICAgICAgIHZhciBDb3VudCA9IFJlYWN0LmNsb25lRWxlbWVudChlbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoOiAhIW1lLnN0YXRlLnZhbHVlID8gbWUuc3RhdGUudmFsdWUubGVuZ3RoIDogMCxcbiAgICAgICAgICAgICAgICBrZXk6IFwiY291bnRcIlxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogQ291bnQsXG4gICAgICAgICAgICAgICAgdG90YWw6IHRvdGFsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIElucHV0Rm9ybUZpZWxkLnByb3RvdHlwZS5yZW5kZXJMZWZ0QWRkb24gPSBmdW5jdGlvbiByZW5kZXJMZWZ0QWRkb24oKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IG1lLnByb3BzLmNoaWxkcmVuO1xuICAgICAgICB2YXIgZWxlbWVudCA9IHZvaWQgMDtcbiAgICAgICAgUmVhY3QuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZCAmJiB0eXBlb2YgY2hpbGQudHlwZSA9PSAnZnVuY3Rpb24nICYmIGNoaWxkLnR5cGUuZGlzcGxheU5hbWUgPT0gJ0xlZnRBZGRvbicpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gY2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoISFlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgICBmb2N1czogISFtZS5zdGF0ZS5mb2N1cyxcbiAgICAgICAgICAgICAgICBrZXk6IFwibGVmdFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBJbnB1dEZvcm1GaWVsZC5wcm90b3R5cGUucmVuZGVyUmlnaHRBZGRvbiA9IGZ1bmN0aW9uIHJlbmRlclJpZ2h0QWRkb24oKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IG1lLnByb3BzLmNoaWxkcmVuO1xuICAgICAgICB2YXIgZWxlbWVudCA9IHZvaWQgMDtcbiAgICAgICAgUmVhY3QuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZCAmJiB0eXBlb2YgY2hpbGQudHlwZSA9PSAnZnVuY3Rpb24nICYmIGNoaWxkLnR5cGUuZGlzcGxheU5hbWUgPT0gJ1JpZ2h0QWRkb24nKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGNoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoISFlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgICBrZXk6IFwicmlnaHRcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgSW5wdXRGb3JtRmllbGQucHJvdG90eXBlLnJlbmRlckZpZWxkID0gZnVuY3Rpb24gcmVuZGVyRmllbGQoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgICAgdmFyIG1vZGUgPSBtZS5wcm9wcy5qc3htb2RlIHx8IG1lLnByb3BzLm1vZGU7XG4gICAgICAgIHZhciBjb3VudCA9IG1lLmdldENvdW50KCk7XG4gICAgICAgIHZhciBsZWZ0QWRkb24gPSBtZS5yZW5kZXJMZWZ0QWRkb24oKTtcbiAgICAgICAgdmFyIHJpZ2h0QWRkb24gPSBtZS5yZW5kZXJSaWdodEFkZG9uKCk7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IG1lLnByb3BzLmNoaWxkcmVuO1xuICAgICAgICBpZiAobW9kZSA9PSBDb25zdGFudHMuTU9ERS5FRElUKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXJPcHRpb25zID0ge307XG4gICAgICAgICAgICAvLyBpZiAoISFjb3VudCkge1xuICAgICAgICAgICAgLy8gICAgIG90aGVyT3B0aW9ucy5tYXhMZW5ndGggPSBjb3VudC50b3RhbCArIFwiXCI7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICBpZiAoISFsZWZ0QWRkb24pIHtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChsZWZ0QWRkb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJyLnB1c2goUmVhY3QuY3JlYXRlRWxlbWVudCgnaW5wdXQnLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzKHtcbiAgICAgICAgICAgICAgICAgICAgXCJrdW1hLWlucHV0XCI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICdrdW1hLXV4Zm9ybS1pbnB1dC1oYXMtcmlnaHQnOiAhIWNvdW50IHx8ICEhcmlnaHRBZGRvbixcbiAgICAgICAgICAgICAgICAgICAgXCJrdW1hLXV4Zm9ybS1pbnB1dC1oYXMtbGVmdFwiOiAhIWxlZnRBZGRvblxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHJlZjogJ3Jvb3QnLFxuICAgICAgICAgICAgICAgIGtleTogbWUucHJvcHMuaW5wdXRUeXBlLFxuICAgICAgICAgICAgICAgIHR5cGU6IG1lLnByb3BzLmlucHV0VHlwZSxcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogbWUucHJvcHMuanN4cGxhY2Vob2xkZXIsXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ6IG1lLnByb3BzLmpzeGRpc2FibGVkID09IFwiZGlzYWJsZWRcIiB8fCBtZS5wcm9wcy5qc3hkaXNhYmxlZCA9PSB0cnVlID8gXCJkaXNhYmxlZFwiIDogXCJcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBtZS5wcm9wcy5rZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IG1lLnN0YXRlLmZvcm1hdFZhbHVlLFxuICAgICAgICAgICAgICAgIG9uRm9jdXM6IG1lLmhhbmRsZUZvY3VzLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgIG9uQmx1cjogbWUuaGFuZGxlQmx1ci5iaW5kKG1lKSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogbWUuaGFuZGxlQ2hhbmdlLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgIG9uS2V5RG93bjogbWUuaGFuZGxlS2V5RG93bi5iaW5kKG1lKVxuICAgICAgICAgICAgfSwgb3RoZXJPcHRpb25zKSkpO1xuXG4gICAgICAgICAgICBpZiAoISFyaWdodEFkZG9uKSB7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2gocmlnaHRBZGRvbik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCEhY291bnQpIHtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChjb3VudC5lbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtb2RlID09IENvbnN0YW50cy5NT0RFLlZJRVcpIHtcbiAgICAgICAgICAgIGFyci5wdXNoKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgICAgIHsga2V5OiAndGV4dCcgfSxcbiAgICAgICAgICAgICAgICBtZS5zdGF0ZS5mb3JtYXRWYWx1ZVxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIElucHV0Rm9ybUZpZWxkO1xufShGb3JtRmllbGQpO1xuXG5JbnB1dEZvcm1GaWVsZC5Db3VudCA9IEZvcm1Db3VudDtcbklucHV0Rm9ybUZpZWxkLkxlZnRBZGRvbiA9IExlZnRBZGRvbjtcbklucHV0Rm9ybUZpZWxkLlJpZ2h0QWRkb24gPSBSaWdodEFkZG9uO1xuSW5wdXRGb3JtRmllbGQucHJvcFR5cGVzID0gYXNzaWduKHt9LCBGb3JtRmllbGQucHJvcFR5cGVzLCB7XG4gICAgb25CbHVyOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkZvY3VzOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbktleURvd246IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIHZhbGlkYXRlT25CbHVyOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBhdXRvVHJpbTogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgaW5wdXRUeXBlOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nXG59KTtcbklucHV0Rm9ybUZpZWxkLmRlZmF1bHRQcm9wcyA9IGFzc2lnbih7fSwgRm9ybUZpZWxkLmRlZmF1bHRQcm9wcywge1xuICAgIG9uQmx1cjogZnVuY3Rpb24gb25CbHVyKCkge30sXG4gICAgb25Gb2N1czogZnVuY3Rpb24gb25Gb2N1cygpIHt9LFxuICAgIG9uS2V5RG93bjogZnVuY3Rpb24gb25LZXlEb3duKCkge30sXG4gICAgdmFsaWRhdGVPbkJsdXI6IGZhbHNlLFxuICAgIGlucHV0VHlwZTogJ3RleHQnXG59KTtcbklucHV0Rm9ybUZpZWxkLmRpc3BsYXlOYW1lID0gXCJJbnB1dEZvcm1GaWVsZFwiO1xubW9kdWxlLmV4cG9ydHMgPSBJbnB1dEZvcm1GaWVsZDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vYnVpbGQvRm9ybUZpZWxkL0lucHV0Rm9ybUZpZWxkLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogQ3JlYXRlZCBieSB4eSBvbiAxNS80LzEzLlxuICovXG52YXIgRm9ybUZpZWxkID0gcmVxdWlyZSgnLi9Gb3JtRmllbGQnKTtcbnZhciBDb25zdGFudHMgPSByZXF1aXJlKFwidXhjb3JlLWNvbnN0XCIpO1xudmFyIFJhZGlvR3JvdXAgPSByZXF1aXJlKCd1eGNvcmUtcmFkaW9ncm91cCcpO1xudmFyIEl0ZW0gPSBSYWRpb0dyb3VwLkl0ZW07XG5cbnZhciBSYWRpb0dyb3VwRm9ybUZpZWxkID0gZnVuY3Rpb24gKF9Gb3JtRmllbGQpIHtcbiAgICBfaW5oZXJpdHMoUmFkaW9Hcm91cEZvcm1GaWVsZCwgX0Zvcm1GaWVsZCk7XG5cbiAgICBmdW5jdGlvbiBSYWRpb0dyb3VwRm9ybUZpZWxkKHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSYWRpb0dyb3VwRm9ybUZpZWxkKTtcblxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0Zvcm1GaWVsZC5jYWxsKHRoaXMsIHByb3BzKSk7XG4gICAgfVxuXG4gICAgUmFkaW9Hcm91cEZvcm1GaWVsZC5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKHZhbHVlKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIG1lLmhhbmRsZURhdGFDaGFuZ2UodmFsdWUpO1xuICAgIH07XG5cbiAgICBSYWRpb0dyb3VwRm9ybUZpZWxkLnByb3RvdHlwZS5hZGRTcGVjaWZpY0NsYXNzID0gZnVuY3Rpb24gYWRkU3BlY2lmaWNDbGFzcygpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgaWYgKG1lLnByb3BzLmpzeHByZWZpeENscyA9PSBcImt1bWEtdXhmb3JtLWZpZWxkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBtZS5wcm9wcy5qc3hwcmVmaXhDbHMgKyBcIiBrdW1hLXJhZGlvLWdyb3VwLXV4Zm9ybS1maWVsZFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1lLnByb3BzLmpzeHByZWZpeENscztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBSYWRpb0dyb3VwRm9ybUZpZWxkLnByb3RvdHlwZS5yZW5kZXJGaWVsZCA9IGZ1bmN0aW9uIHJlbmRlckZpZWxkKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgYXJyID0gW107XG4gICAgICAgIHZhciBtb2RlID0gbWUucHJvcHMuanN4bW9kZSB8fCBtZS5wcm9wcy5tb2RlO1xuICAgICAgICBpZiAobW9kZSA9PSBDb25zdGFudHMuTU9ERS5FRElUKSB7XG4gICAgICAgICAgICBhcnIucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgIFJhZGlvR3JvdXAsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZWY6ICdlbCcsXG4gICAgICAgICAgICAgICAgICAgIGtleTogJ3JhZGlvZ3JvdXAnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWUuc3RhdGUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBtZS5oYW5kbGVDaGFuZ2UuYmluZChtZSkgfSxcbiAgICAgICAgICAgICAgICBtZS5wcm9wcy5jaGlsZHJlblxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IG1lLnByb3BzLmNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoY2hpbGQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLnByb3BzLnZhbHVlID09IG1lLnN0YXRlLnZhbHVlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgICAgICAgICAgeyBrZXk6ICdyYWRpb2dyb3VwJyB9LFxuICAgICAgICAgICAgICAgICAgICB0ZXh0WzBdLnByb3BzLnRleHRcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH07XG5cbiAgICByZXR1cm4gUmFkaW9Hcm91cEZvcm1GaWVsZDtcbn0oRm9ybUZpZWxkKTtcblxuUmFkaW9Hcm91cEZvcm1GaWVsZC5kaXNwbGF5TmFtZSA9IFwiUmFkaW9Hcm91cEZvcm1GaWVsZFwiO1xuUmFkaW9Hcm91cEZvcm1GaWVsZC5wcm9wVHlwZXMgPSBGb3JtRmllbGQucHJvcFR5cGVzO1xuUmFkaW9Hcm91cEZvcm1GaWVsZC5kZWZhdWx0UHJvcHMgPSBGb3JtRmllbGQuZGVmYXVsdFByb3BzO1xuUmFkaW9Hcm91cEZvcm1GaWVsZC5JdGVtID0gSXRlbTtcbm1vZHVsZS5leHBvcnRzID0gUmFkaW9Hcm91cEZvcm1GaWVsZDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vYnVpbGQvRm9ybUZpZWxkL1JhZGlvR3JvdXBGb3JtRmllbGQuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUmFkaW9ncm91cCBDb21wb25lbnQgZm9yIHV4Y29yZVxuICogQGF1dGhvciBcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBVeGNvcmUgVGVhbSwgQWxpbncuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9SYWRpb2dyb3VwJyk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1yYWRpb2dyb3VwL2J1aWxkL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuKiB0aGFua3MgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGVuZ2xvdS9yZWFjdC1yYWRpby1ncm91cFxuKiBAYXV0aG9yOiB6aG91cXVhbi55ZXpxXG4qIEB0aW1lICA6IDUvMjUgMjAxNVxuKi9cblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xudmFyIEl0ZW0gPSByZXF1aXJlKCcuL1JhZGlvZ3JvdXBJdGVtJyk7XG52YXIgY2xhc3NuYW1lcyA9IHJlcXVpcmUoXCJjbGFzc25hbWVzXCIpO1xuXG52YXIgUmFkaW9ncm91cCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzKFJhZGlvZ3JvdXAsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gUmFkaW9ncm91cChwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmFkaW9ncm91cCk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHByb3BzLmRlZmF1bHRWYWx1ZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgUmFkaW9ncm91cC5wcm90b3R5cGUuX2hhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIF9oYW5kbGVDaGFuZ2UodmFsdWUpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgbWUucHJvcHMub25DaGFuZ2UodmFsdWUpO1xuICAgIH07XG5cbiAgICBSYWRpb2dyb3VwLnByb3RvdHlwZS5fcHJvY2Vzc0NoaWxkID0gZnVuY3Rpb24gX3Byb2Nlc3NDaGlsZCgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIGxlbmd0aCA9IFJlYWN0LkNoaWxkcmVuLmNvdW50KG1lLnByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgaWYgKCFsZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gUmVhY3QuQ2hpbGRyZW4ubWFwKG1lLnByb3BzLmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoISFjaGlsZC50eXBlICYmIGNoaWxkLnR5cGUuZGlzcGxheU5hbWUgPT0gXCJSYWRpb2dyb3VwSXRlbVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTogbWUuX2hhbmRsZUNoYW5nZS5iaW5kKG1lKSxcbiAgICAgICAgICAgICAgICAgICAga2V5OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tlZDogbWUucHJvcHMudmFsdWUgPT0gY2hpbGQucHJvcHMudmFsdWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9O1xuXG4gICAgUmFkaW9ncm91cC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICB2YXIgX2NsYXNzbmFtZXM7XG5cbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBjbGFzc25hbWVzKChfY2xhc3NuYW1lcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgXCJrdW1hLXJhZGlvLWdyb3VwXCI6IHRydWVcbiAgICAgICAgICAgICAgICB9LCBfY2xhc3NuYW1lc1ttZS5wcm9wcy5jbGFzc05hbWVdID0gISFtZS5wcm9wcy5jbGFzc05hbWUsIF9jbGFzc25hbWVzKSkgfSxcbiAgICAgICAgICAgIG1lLl9wcm9jZXNzQ2hpbGQoKVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gUmFkaW9ncm91cDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuUmFkaW9ncm91cC5kaXNwbGF5TmFtZSA9IFwiUmFkaW9ncm91cFwiO1xuUmFkaW9ncm91cC5wcm9wVHlwZXMgPSB7XG4gICAgdmFsdWU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgb25DaGFuZ2U6IFJlYWN0LlByb3BUeXBlcy5mdW5jXG59O1xuUmFkaW9ncm91cC5kZWZhdWx0UHJvcHMgPSB7XG4gICAgdmFsdWU6IFwiXCIsXG4gICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKCkge31cbn07XG5cblJhZGlvZ3JvdXAuSXRlbSA9IEl0ZW07XG5cbm1vZHVsZS5leHBvcnRzID0gUmFkaW9ncm91cDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLXJhZGlvZ3JvdXAvYnVpbGQvUmFkaW9ncm91cC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBSYWRpb2dyb3VwSXRlbSA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzKFJhZGlvZ3JvdXBJdGVtLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIFJhZGlvZ3JvdXBJdGVtKHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSYWRpb2dyb3VwSXRlbSk7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuICAgIH1cblxuICAgIFJhZGlvZ3JvdXBJdGVtLnByb3RvdHlwZS5faGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gX2hhbmRsZUNoYW5nZShlKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIG1lLnByb3BzLm9uQ2hhbmdlKG1lLnByb3BzLnZhbHVlKTtcbiAgICB9O1xuXG4gICAgUmFkaW9ncm91cEl0ZW0ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnbGFiZWwnLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JywgeyB0eXBlOiAncmFkaW8nLCBkaXNhYmxlZDogbWUucHJvcHMuZGlzYWJsZWQsIHJlZjogJ3JhZGlvJywgY2xhc3NOYW1lOiBtZS5wcm9wcy5jbGFzc05hbWUsIGNoZWNrZWQ6IG1lLnByb3BzLmNoZWNrZWQsIG9uQ2hhbmdlOiBtZS5faGFuZGxlQ2hhbmdlLmJpbmQobWUpIH0pLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgncycsIG51bGwpLFxuICAgICAgICAgICAgbWUucHJvcHMudGV4dFxuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gUmFkaW9ncm91cEl0ZW07XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblJhZGlvZ3JvdXBJdGVtLmRpc3BsYXlOYW1lID0gXCJSYWRpb2dyb3VwSXRlbVwiO1xuUmFkaW9ncm91cEl0ZW0ucHJvcFR5cGVzID0ge1xuICAgIHRleHQ6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgdmFsdWU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgY2xhc3NOYW1lOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGRpc2FibGVkOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBvbkNoYW5nZTogUmVhY3QuUHJvcFR5cGVzLmZ1bmNcbn07XG5SYWRpb2dyb3VwSXRlbS5kZWZhdWx0UHJvcHMgPSB7XG4gICAgdGV4dDogXCJcIixcbiAgICB2YWx1ZTogXCJcIixcbiAgICBjbGFzc05hbWU6IFwia3VtYS1jaGVja2JveFwiLFxuICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoKSB7fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYWRpb2dyb3VwSXRlbTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLXJhZGlvZ3JvdXAvYnVpbGQvUmFkaW9ncm91cEl0ZW0uanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBDcmVhdGVkIGJ5IHh5IG9uIDE1LzQvMTMuXG4gKi9cbnZhciBGb3JtRmllbGQgPSByZXF1aXJlKCcuL0Zvcm1GaWVsZCcpO1xudmFyIENvbnN0YW50cyA9IHJlcXVpcmUoXCJ1eGNvcmUtY29uc3RcIik7XG52YXIgU2VsZWN0ID0gcmVxdWlyZSgndXhjb3JlLXNlbGVjdDInKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG52YXIgT3B0aW9uID0gU2VsZWN0Lk9wdGlvbjtcblxudmFyIHNlbGVjdE9wdGlvbnMgPSBbJ29uU2VsZWN0JywgJ29uRGVzZWxlY3QnLCAnZ2V0UG9wdXBDb250YWluZXInLCAnbXVsdGlwbGUnLCAnZmlsdGVyT3B0aW9uJywgJ2FsbG93Q2xlYXInLCAnY29tYm9ib3gnLCAnc2VhcmNoUGxhY2Vob2xkZXInLCAndGFncycsICdkaXNhYmxlZCcsICdzaG93U2VhcmNoJywgJ3BsYWNlaG9sZGVyJywgJ29wdGlvbkxhYmVsUHJvcCcsICdtYXhUYWdUZXh0TGVuZ3RoJywgJ2Ryb3Bkb3duTWF0Y2hTZWxlY3RXaWR0aCcsICdkcm9wZG93bkNsYXNzTmFtZScsICdub3RGb3VuZENvbnRlbnQnXTtcblxudmFyIFNlbGVjdEZvcm1GaWVsZCA9IGZ1bmN0aW9uIChfRm9ybUZpZWxkKSB7XG4gICAgX2luaGVyaXRzKFNlbGVjdEZvcm1GaWVsZCwgX0Zvcm1GaWVsZCk7XG5cbiAgICBmdW5jdGlvbiBTZWxlY3RGb3JtRmllbGQocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNlbGVjdEZvcm1GaWVsZCk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0Zvcm1GaWVsZC5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICAgICAgdmFyIG1lID0gX3RoaXM7XG4gICAgICAgIGFzc2lnbihtZS5zdGF0ZSwge1xuICAgICAgICAgICAgZGF0YTogcHJvcHMuanN4ZGF0YVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIFNlbGVjdEZvcm1GaWVsZC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIGlmICghbWUuX2lzRXF1YWwobmV4dFByb3BzLnZhbHVlLCBtZS5wcm9wcy52YWx1ZSkpIHtcbiAgICAgICAgICAgIG1lLmhhbmRsZURhdGFDaGFuZ2UobmV4dFByb3BzLnZhbHVlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1lLl9pc0VxdWFsKG5leHRQcm9wcy5qc3hkYXRhLCBtZS5wcm9wcy5qc3hkYXRhKSkge1xuICAgICAgICAgICAgbWUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGRhdGE6IG5leHRQcm9wcy5qc3hkYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTZWxlY3RGb3JtRmllbGQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgaWYgKG1lLnByb3BzLmpzeGZldGNoVXJsKSB7XG4gICAgICAgICAgICBtZS5mZXRjaERhdGEoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTZWxlY3RGb3JtRmllbGQucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIGlmICghbWUucHJvcHMuc3RhbmRhbG9uZSkge1xuICAgICAgICAgICAgbWUucHJvcHMuYXR0YWNoRm9ybUZpZWxkKG1lKTtcbiAgICAgICAgICAgIG1lLnByb3BzLmhhbmRsZURhdGFDaGFuZ2UobWUsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbWUucHJvcHMudmFsdWUsXG4gICAgICAgICAgICAgICAgcGFzczogdHJ1ZVxuICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbWUuaGFzRGVwcmVjYXRlZFByb3BzKCk7XG4gICAgfTtcblxuICAgIFNlbGVjdEZvcm1GaWVsZC5wcm90b3R5cGUuaGFuZGxlRGF0YUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZURhdGFDaGFuZ2UodmFsdWUsIGZyb21SZXNldCwgbGFiZWwpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgbWUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgbGFiZWw6IGxhYmVsIHx8IFtdLFxuICAgICAgICAgICAgZm9ybWF0VmFsdWU6IG1lLmZvcm1hdFZhbHVlKHZhbHVlKSxcbiAgICAgICAgICAgIGVycm9yOiAhIWZyb21SZXNldCA/IGZhbHNlIDogbWUuc3RhdGUuZXJyb3IsXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogd2h5IHNldCBzdGF0ZSBmcm9tUmVzZXQ/IHNvbWUgZmllbGQgbGlrZSBlZGl0b3IgY2Fubm90IGJlIHJlc2V0IGluIHRoZSBjb21tb24gd2F5XG4gICAgICAgICAgICAgKiBzbyBzZXQgdGhpcyBzdGF0ZSB0byB0ZWxsIHRoZSBmaWVsZCB0aGF0IHlvdSBuZWVkIHRvIHJlc2V0IGJ5IHlvdXJzZWxmLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmcm9tUmVzZXQ6IGZyb21SZXNldFxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGFzcyA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIWZyb21SZXNldCkge1xuICAgICAgICAgICAgICAgIHBhc3MgPSBtZS5kb1ZhbGlkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZS5wcm9wcy5oYW5kbGVEYXRhQ2hhbmdlKG1lLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHBhc3M6IHBhc3NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgU2VsZWN0Rm9ybUZpZWxkLnByb3RvdHlwZS5mZXRjaERhdGEgPSBmdW5jdGlvbiBmZXRjaERhdGEodmFsdWUpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIGFqYXhPcHRpb25zID0ge1xuICAgICAgICAgICAgdXJsOiBtZS5wcm9wcy5qc3hmZXRjaFVybCxcbiAgICAgICAgICAgIGRhdGFUeXBlOiBtZS5wcm9wcy5kYXRhVHlwZSxcbiAgICAgICAgICAgIGRhdGE6IG1lLnByb3BzLmJlZm9yZUZldGNoKHsgcTogdmFsdWUgfSksXG4gICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiBzdWNjZXNzKGRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmV0Y2hEYXRhID0gbWUucHJvcHMuYWZ0ZXJGZXRjaChkYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAoISFtZS5wcm9wcy5qc3hkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGZldGNoRGF0YSA9IGFzc2lnbih7fSwgZmV0Y2hEYXRhLCBtZS5wcm9wcy5qc3hkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBmZXRjaERhdGFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmYWlsOiBmdW5jdGlvbiBmYWlsKCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRmV0Y2ggRGF0YSBmYWlsZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICgvXFwuanNvbnAvLnRlc3QobWUucHJvcHMuanN4ZmV0Y2hVcmwpKSB7XG4gICAgICAgICAgICBhamF4T3B0aW9ucy5kYXRhVHlwZSA9IFwianNvbnBcIjtcbiAgICAgICAgfVxuICAgICAgICAkLmFqYXgoYWpheE9wdGlvbnMpO1xuICAgIH07XG5cbiAgICBTZWxlY3RGb3JtRmllbGQucHJvdG90eXBlLmhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZSh2YWx1ZSwgbGFiZWwpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgbWUuaGFuZGxlRGF0YUNoYW5nZSh2YWx1ZSwgZmFsc2UsIGxhYmVsKTtcbiAgICB9O1xuXG4gICAgU2VsZWN0Rm9ybUZpZWxkLnByb3RvdHlwZS5oYW5kbGVTZWFyY2ggPSBmdW5jdGlvbiBoYW5kbGVTZWFyY2godmFsdWUpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgaWYgKG1lLnByb3BzLmpzeGZldGNoVXJsKSB7XG4gICAgICAgICAgICBtZS5mZXRjaERhdGEodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUucHJvcHMub25TZWFyY2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFNlbGVjdEZvcm1GaWVsZC5wcm90b3R5cGUuX3Byb2Nlc3NEYXRhID0gZnVuY3Rpb24gX3Byb2Nlc3NEYXRhKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgdmFsdWVzID0gT2JqZWN0LmtleXMobWUuc3RhdGUuZGF0YSk7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IG1lLnByb3BzLmNoaWxkcmVuO1xuICAgICAgICBpZiAoIXZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybihcIllvdSBuZWVkIHRvIHBhc3MgZGF0YSB0byBpbml0aWFsaXplIFNlbGVjdC5cIik7XG4gICAgICAgICAgICBpZiAoISFjaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhcnIgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgdmFyIF9tZSRwcm9wcyA9IG1lLnByb3BzO1xuICAgICAgICAgICAgICAgIHZhciBtdWx0aXBsZSA9IF9tZSRwcm9wcy5tdWx0aXBsZTtcbiAgICAgICAgICAgICAgICB2YXIganN4bXVsdGlwbGUgPSBfbWUkcHJvcHMuanN4bXVsdGlwbGU7XG4gICAgICAgICAgICAgICAgdmFyIGNvbWJvYm94ID0gX21lJHByb3BzLmNvbWJvYm94O1xuICAgICAgICAgICAgICAgIHZhciBqc3hjb21ib2JveCA9IF9tZSRwcm9wcy5qc3hjb21ib2JveDtcblxuICAgICAgICAgICAgICAgIGlmIChtdWx0aXBsZSA9PSB0cnVlIHx8IGpzeG11bHRpcGxlID09IHRydWUgfHwgY29tYm9ib3ggPT0gdHJ1ZSB8fCBqc3hjb21ib2JveCA9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBtZS5zdGF0ZS5kYXRhW3ZhbHVlXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgdGl0bGU6IG1lLnN0YXRlLmRhdGFbdmFsdWVdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5zdGF0ZS5kYXRhW3ZhbHVlXVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgT3B0aW9uLFxuICAgICAgICAgICAgICAgICAgICB7IGtleTogdmFsdWUsIHRpdGxlOiBtZS5zdGF0ZS5kYXRhW3ZhbHVlXSB9LFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTZWxlY3RGb3JtRmllbGQucHJvdG90eXBlLmFkZFNwZWNpZmljQ2xhc3MgPSBmdW5jdGlvbiBhZGRTcGVjaWZpY0NsYXNzKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBpZiAobWUucHJvcHMuanN4cHJlZml4Q2xzID09IFwia3VtYS11eGZvcm0tZmllbGRcIikge1xuICAgICAgICAgICAgcmV0dXJuIG1lLnByb3BzLmpzeHByZWZpeENscyArIFwiIGt1bWEtc2VsZWN0LXV4Zm9ybS1maWVsZFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1lLnByb3BzLmpzeHByZWZpeENscztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTZWxlY3RGb3JtRmllbGQucHJvdG90eXBlLmhhc0RlcHJlY2F0ZWRQcm9wcyA9IGZ1bmN0aW9uIGhhc0RlcHJlY2F0ZWRQcm9wcygpIHtcbiAgICAgICAgdmFyIGFyciA9IFsnanN4bXVsdGlwbGUnLCAnanN4YWxsb3dDbGVhcicsICdqc3hjb21ib2JveCcsICdqc3hzZWFyY2hQbGFjZWhvbGRlcicsICdqc3h0YWdzJywgJ2pzeGRpc2FibGVkJywgJ2pzeHNob3dTZWFyY2gnLCAnanN4cGxhY2Vob2xkZXInXTtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhtZS5wcm9wcyk7XG4gICAgICAgIHZhciBoYXNEZXByZWNhdGVkID0ga2V5cy5zb21lKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyci5pbmRleE9mKGl0ZW0pICE9IC0xO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGhhc0RlcHJlY2F0ZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlNlbGVjdEZvcm1GaWVsZDogcHJvcHMgc2FtZSBhcyB1eGNvcmUtc2VsZWN0MiBjYW4gYmUgcGFzc2VkIHdpdGhvdXQgcHJlZml4ICdqc3gnIG5vdyAoZXhjbHVkZSBzdHlsZSkuIHdlIHdpbGwgcmVtb3ZlIHRoZSBzdXBwb3J0IG9mIHRoZSBwcm9wcyBtZW50aW9uZWQgYWJvdmUgd2l0aCBwcmVmaXggJ2pzeCcgYXQgdXhjb3JlLWZvcm1AMS4zLjAgLlwiKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTZWxlY3RGb3JtRmllbGQucHJvdG90eXBlLmdldFZhbHVlUHJvcFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWVQcm9wVmFsdWUoY2hpbGQpIHtcbiAgICAgICAgdmFyIGtleSA9IFwiXCI7XG4gICAgICAgIGlmICgndmFsdWUnIGluIGNoaWxkLnByb3BzKSB7XG4gICAgICAgICAgICBrZXkgPSBjaGlsZC5wcm9wcy52YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtleSA9IGNoaWxkLmtleTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH07XG5cbiAgICBTZWxlY3RGb3JtRmllbGQucHJvdG90eXBlLnJlbmRlckZpZWxkID0gZnVuY3Rpb24gcmVuZGVyRmllbGQoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgICAgdmFyIG1vZGUgPSBtZS5wcm9wcy5qc3htb2RlIHx8IG1lLnByb3BzLm1vZGU7XG5cbiAgICAgICAgaWYgKG1vZGUgPT0gQ29uc3RhbnRzLk1PREUuRURJVCkge1xuICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmVmOiBcImVsXCIsXG4gICAgICAgICAgICAgICAgICAgIGtleTogXCJzZWxlY3RcIixcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uTGFiZWxQcm9wOiBtZS5wcm9wcy5vcHRpb25MYWJlbFByb3AsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBtZS5wcm9wcy5qc3hzdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGU6IG1lLnByb3BzLmpzeG11bHRpcGxlLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd0NsZWFyOiBtZS5wcm9wcy5qc3hhbGxvd0NsZWFyLFxuICAgICAgICAgICAgICAgICAgICBjb21ib2JveDogbWUucHJvcHMuanN4Y29tYm9ib3gsXG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaFBsYWNlaG9sZGVyOiBtZS5wcm9wcy5qc3hzZWFyY2hQbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICAgICAgdGFnczogbWUucHJvcHMuanN4dGFncyxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uRmlsdGVyUHJvcDogbWUucHJvcHMub3B0aW9uRmlsdGVyUHJvcCxcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6ICEhbWUucHJvcHMuanN4ZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlOiBtZS5zdGF0ZS52YWx1ZSB8fCBbXSxcbiAgICAgICAgICAgICAgICAgICAgc2hvd1NlYXJjaDogbWUucHJvcHMuanN4c2hvd1NlYXJjaCxcbiAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IG1lLnByb3BzLmpzeHBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTogbWUuaGFuZGxlQ2hhbmdlLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgICAgICBvblNlYXJjaDogbWUuaGFuZGxlU2VhcmNoLmJpbmQobWUpXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHNlbGVjdE9wdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0gaW4gbWUucHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbaXRlbV0gPSBtZS5wcm9wc1tpdGVtXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG1lLnByb3BzLmpzeGRhdGEpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vcHRpb25GaWx0ZXJQcm9wID0gJ3RpdGxlJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBvbmx5IGpzeGZldGNoVXJsIG1vZGUgbmVlZCBwYXNzIGxhYmVsLCBmb3IgdGhlIG9wdGlvbnMgYWx3YXlzIGNoYW5nZS5cbiAgICAgICAgICAgICAgICAvLyB3aGVuIG1vdW50LCBzdGF0ZS5sYWJlbCBpcyB1bmRlZmluZWQsIHdoaWNoIGNhdXNlIGRlZmFsdXRWYWx1ZSBjYW5ub3QgYmUgdXNlZC5cbiAgICAgICAgICAgICAgICBpZiAoISFtZS5wcm9wcy5qc3hmZXRjaFVybCAmJiAhIW1lLnN0YXRlLmxhYmVsICYmIG1lLnN0YXRlLmxhYmVsLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmxhYmVsID0gbWUuc3RhdGUubGFiZWwgfHwgW107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFtZS5wcm9wcy5jb21ib2JveCB8fCBtZS5zdGF0ZS5mcm9tUmVzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy52YWx1ZSA9IG1lLnN0YXRlLnZhbHVlIHx8IFtdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghIW1lLnByb3BzLmpzeGZldGNoVXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZmlsdGVyT3B0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFyci5wdXNoKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgIFNlbGVjdCxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgbWUuX3Byb2Nlc3NEYXRhKClcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PSBDb25zdGFudHMuTU9ERS5WSUVXKSB7XG4gICAgICAgICAgICB2YXIgc3RyID0gJyc7XG4gICAgICAgICAgICBpZiAobWUuc3RhdGUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gdHlwZW9mIG1lLnN0YXRlLnZhbHVlID09ICdzdHJpbmcnID8gW21lLnN0YXRlLnZhbHVlXSA6IG1lLnN0YXRlLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZS5zdGF0ZS5sYWJlbCAmJiBtZS5zdGF0ZS5sYWJlbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgPSBtZS5zdGF0ZS5sYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGluIGpzeGRhdGEgb3IganN4ZmV0Y2hVcmwgbW9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG1lLnN0YXRlLmRhdGEpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBtZS5zdGF0ZS5kYXRhW3ZhbHVlXSArIFwiIFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBpbiA8T3B0aW9uPiBNb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUucHJvcHMuY2hpbGRyZW4gJiYgbWUucHJvcHMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVQcm9wVmFsdWUgPSBtZS5nZXRWYWx1ZVByb3BWYWx1ZShjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzLmluZGV4T2YodmFsdWVQcm9wVmFsdWUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBjaGlsZC5wcm9wc1ttZS5wcm9wcy5vcHRpb25MYWJlbFByb3BdICsgXCIgXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcnIucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgICAgICB7IGtleTogJ3NlbGVjdCcgfSxcbiAgICAgICAgICAgICAgICBzdHJcbiAgICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfTtcblxuICAgIHJldHVybiBTZWxlY3RGb3JtRmllbGQ7XG59KEZvcm1GaWVsZCk7XG5cblNlbGVjdEZvcm1GaWVsZC5PcHRpb24gPSBPcHRpb247XG5TZWxlY3RGb3JtRmllbGQuZGlzcGxheU5hbWUgPSBcIlNlbGVjdEZvcm1GaWVsZFwiO1xuU2VsZWN0Rm9ybUZpZWxkLnByb3BUeXBlcyA9IGFzc2lnbih7fSwgRm9ybUZpZWxkLnByb3BUeXBlcywge1xuICAgIGpzeHN0eWxlOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIGpzeHBsYWNlaG9sZGVyOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGpzeGNvbWJvYm94OiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBqc3hkYXRhOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIGJlZm9yZUZldGNoOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBhZnRlckZldGNoOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBqc3hzaG93U2VhcmNoOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBqc3h0YWdzOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBqc3htdWx0aXBsZTogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAganN4YWxsb3dDbGVhcjogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAganN4c2VhcmNoUGxhY2Vob2xkZXI6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgb3B0aW9uRmlsdGVyUHJvcDogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBkYXRhVHlwZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZ1xufSk7XG5TZWxlY3RGb3JtRmllbGQuZGVmYXVsdFByb3BzID0gYXNzaWduKHt9LCBGb3JtRmllbGQuZGVmYXVsdFByb3BzLCB7XG4gICAganN4c3R5bGU6IHt9LFxuICAgIGpzeHBsYWNlaG9sZGVyOiBcIuivt+S4i+aLiemAieaLqVwiLFxuICAgIGpzeGNvbWJvYm94OiBmYWxzZSxcbiAgICBqc3hkYXRhOiB7fSxcbiAgICBiZWZvcmVGZXRjaDogZnVuY3Rpb24gYmVmb3JlRmV0Y2gob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBhZnRlckZldGNoOiBmdW5jdGlvbiBhZnRlckZldGNoKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgb25TZWFyY2g6IGZ1bmN0aW9uIG9uU2VhcmNoKCkge30sXG4gICAganN4c2hvd1NlYXJjaDogdHJ1ZSxcbiAgICBqc3hhbGxvd0NsZWFyOiBmYWxzZSxcbiAgICBqc3h0YWdzOiBmYWxzZSxcbiAgICBqc3htdWx0aXBsZTogZmFsc2UsXG4gICAganN4c2VhcmNoUGxhY2Vob2xkZXI6IFwiXCIsXG4gICAgb3B0aW9uRmlsdGVyUHJvcDogXCJjaGlsZHJlblwiLFxuICAgIG9wdGlvbkxhYmVsUHJvcDogXCJjaGlsZHJlblwiLFxuICAgIGRhdGFUeXBlOiAnanNvbidcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbGVjdEZvcm1GaWVsZDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vYnVpbGQvRm9ybUZpZWxkL1NlbGVjdEZvcm1GaWVsZC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTZWxlY3QyIENvbXBvbmVudCBmb3IgdXhjb3JlXG4gKiBAYXV0aG9yIFxuICpcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIFV4Y29yZSBUZWFtLCBBbGludy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL1NlbGVjdDInKTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLXNlbGVjdDIvYnVpbGQvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFJjU2VsZWN0ID0gcmVxdWlyZSgncmMtc2VsZWN0Jyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgU2VsZWN0MiA9IGZ1bmN0aW9uIChfUmNTZWxlY3QpIHtcbiAgICBfaW5oZXJpdHMoU2VsZWN0MiwgX1JjU2VsZWN0KTtcblxuICAgIGZ1bmN0aW9uIFNlbGVjdDIocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNlbGVjdDIpO1xuXG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmNTZWxlY3QuY2FsbCh0aGlzLCBwcm9wcykpO1xuICAgIH1cblxuICAgIHJldHVybiBTZWxlY3QyO1xufShSY1NlbGVjdCk7XG5cblNlbGVjdDIuZGlzcGxheU5hbWUgPSAnU2VsZWN0Mic7XG5TZWxlY3QyLmRlZmF1bHRQcm9wcyA9IGFzc2lnbih7fSwgUmNTZWxlY3QuZGVmYXVsdFByb3BzLCB7XG4gICAgcHJlZml4Q2xzOiBcImt1bWEtc2VsZWN0MlwiLFxuICAgIG9wdGlvbkxhYmVsUHJvcDogXCJjaGlsZHJlblwiLFxuICAgIHRyYW5zaXRpb25OYW1lOiAnc2xpZGVVcCdcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbGVjdDI7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1zZWxlY3QyL2J1aWxkL1NlbGVjdDIuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfU2VsZWN0ID0gcmVxdWlyZSgnLi9TZWxlY3QnKTtcblxudmFyIF9TZWxlY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2VsZWN0KTtcblxudmFyIF9PcHRpb24gPSByZXF1aXJlKCcuL09wdGlvbicpO1xuXG52YXIgX09wdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9PcHRpb24pO1xuXG52YXIgX09wdEdyb3VwID0gcmVxdWlyZSgnLi9PcHRHcm91cCcpO1xuXG52YXIgX09wdEdyb3VwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX09wdEdyb3VwKTtcblxuX1NlbGVjdDJbJ2RlZmF1bHQnXS5PcHRpb24gPSBfT3B0aW9uMlsnZGVmYXVsdCddO1xuX1NlbGVjdDJbJ2RlZmF1bHQnXS5PcHRHcm91cCA9IF9PcHRHcm91cDJbJ2RlZmF1bHQnXTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IF9TZWxlY3QyWydkZWZhdWx0J107XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3QvbGliL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcmVhY3REb20gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIF9yZWFjdERvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdERvbSk7XG5cbnZhciBfcmNVdGlsID0gcmVxdWlyZSgncmMtdXRpbCcpO1xuXG52YXIgX2NsYXNzbmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG5cbnZhciBfY2xhc3NuYW1lczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc25hbWVzKTtcblxudmFyIF9PcHRHcm91cCA9IHJlcXVpcmUoJy4vT3B0R3JvdXAnKTtcblxudmFyIF9PcHRHcm91cDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9PcHRHcm91cCk7XG5cbnZhciBfcmNBbmltYXRlID0gcmVxdWlyZSgncmMtYW5pbWF0ZScpO1xuXG52YXIgX3JjQW5pbWF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yY0FuaW1hdGUpO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIF9TZWxlY3RUcmlnZ2VyID0gcmVxdWlyZSgnLi9TZWxlY3RUcmlnZ2VyJyk7XG5cbnZhciBfU2VsZWN0VHJpZ2dlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TZWxlY3RUcmlnZ2VyKTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGZpbHRlckZuKGlucHV0LCBjaGlsZCkge1xuICByZXR1cm4gU3RyaW5nKCgwLCBfdXRpbC5nZXRQcm9wVmFsdWUpKGNoaWxkLCB0aGlzLnByb3BzLm9wdGlvbkZpbHRlclByb3ApKS5pbmRleE9mKGlucHV0KSA+IC0xO1xufVxuXG5mdW5jdGlvbiBzYXZlUmVmKG5hbWUsIGNvbXBvbmVudCkge1xuICB0aGlzW25hbWVdID0gY29tcG9uZW50O1xufVxuXG52YXIgU2VsZWN0ID0gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdTZWxlY3QnLFxuXG4gIHByb3BUeXBlczoge1xuICAgIGRlZmF1bHRBY3RpdmVGaXJzdE9wdGlvbjogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIG11bHRpcGxlOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgZmlsdGVyT3B0aW9uOiBfcmVhY3QuUHJvcFR5cGVzLmFueSxcbiAgICBzaG93U2VhcmNoOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgZGlzYWJsZWQ6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBzaG93QXJyb3c6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICB0YWdzOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgdHJhbnNpdGlvbk5hbWU6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9wdGlvbkxhYmVsUHJvcDogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgb3B0aW9uRmlsdGVyUHJvcDogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgYW5pbWF0aW9uOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBjaG9pY2VUcmFuc2l0aW9uTmFtZTogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgb25DaGFuZ2U6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvblNlbGVjdDogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uU2VhcmNoOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgc2VhcmNoUGxhY2Vob2xkZXI6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHBsYWNlaG9sZGVyOiBfcmVhY3QuUHJvcFR5cGVzLmFueSxcbiAgICBvbkRlc2VsZWN0OiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgdmFsdWU6IF9yZWFjdC5Qcm9wVHlwZXMub25lT2ZUeXBlKFtfcmVhY3QuUHJvcFR5cGVzLmFycmF5LCBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZ10pLFxuICAgIGRlZmF1bHRWYWx1ZTogX3JlYWN0LlByb3BUeXBlcy5vbmVPZlR5cGUoW19yZWFjdC5Qcm9wVHlwZXMuYXJyYXksIF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nXSksXG4gICAgbGFiZWw6IF9yZWFjdC5Qcm9wVHlwZXMub25lT2ZUeXBlKFtfcmVhY3QuUHJvcFR5cGVzLmFycmF5LCBfcmVhY3QuUHJvcFR5cGVzLmFueV0pLFxuICAgIGRlZmF1bHRMYWJlbDogX3JlYWN0LlByb3BUeXBlcy5vbmVPZlR5cGUoW19yZWFjdC5Qcm9wVHlwZXMuYXJyYXksIF9yZWFjdC5Qcm9wVHlwZXMuYW55XSksXG4gICAgZHJvcGRvd25TdHlsZTogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgbWF4VGFnVGV4dExlbmd0aDogX3JlYWN0LlByb3BUeXBlcy5udW1iZXJcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHJlZml4Q2xzOiAncmMtc2VsZWN0JyxcbiAgICAgIGZpbHRlck9wdGlvbjogZmlsdGVyRm4sXG4gICAgICBkZWZhdWx0QWN0aXZlRmlyc3RPcHRpb246IHRydWUsXG4gICAgICBzaG93U2VhcmNoOiB0cnVlLFxuICAgICAgYWxsb3dDbGVhcjogZmFsc2UsXG4gICAgICBwbGFjZWhvbGRlcjogJycsXG4gICAgICBzZWFyY2hQbGFjZWhvbGRlcjogJycsXG4gICAgICBkZWZhdWx0VmFsdWU6IFtdLFxuICAgICAgb25DaGFuZ2U6IG5vb3AsXG4gICAgICBvblNlbGVjdDogbm9vcCxcbiAgICAgIG9uU2VhcmNoOiBub29wLFxuICAgICAgb25EZXNlbGVjdDogbm9vcCxcbiAgICAgIHNob3dBcnJvdzogdHJ1ZSxcbiAgICAgIGRyb3Bkb3duTWF0Y2hTZWxlY3RXaWR0aDogdHJ1ZSxcbiAgICAgIGRyb3Bkb3duU3R5bGU6IHt9LFxuICAgICAgZHJvcGRvd25NZW51U3R5bGU6IHt9LFxuICAgICAgb3B0aW9uRmlsdGVyUHJvcDogJ3ZhbHVlJyxcbiAgICAgIG9wdGlvbkxhYmVsUHJvcDogJ3ZhbHVlJyxcbiAgICAgIG5vdEZvdW5kQ29udGVudDogJ05vdCBGb3VuZCdcbiAgICB9O1xuICB9LFxuXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHZhbHVlID0gW107XG4gICAgaWYgKCd2YWx1ZScgaW4gcHJvcHMpIHtcbiAgICAgIHZhbHVlID0gKDAsIF91dGlsLnRvQXJyYXkpKHByb3BzLnZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSAoMCwgX3V0aWwudG9BcnJheSkocHJvcHMuZGVmYXVsdFZhbHVlKTtcbiAgICB9XG4gICAgdmFyIGxhYmVsID0gdGhpcy5nZXRMYWJlbEZyb21Qcm9wcyhwcm9wcywgdmFsdWUsIDEpO1xuICAgIHZhciBpbnB1dFZhbHVlID0gJyc7XG4gICAgaWYgKHByb3BzLmNvbWJvYm94KSB7XG4gICAgICBpbnB1dFZhbHVlID0gdmFsdWVbMF0gfHwgJyc7XG4gICAgfVxuICAgIHRoaXMuc2F2ZUlucHV0UmVmID0gc2F2ZVJlZi5iaW5kKHRoaXMsICdpbnB1dEluc3RhbmNlJyk7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBpbnB1dFZhbHVlOiBpbnB1dFZhbHVlLCBsYWJlbDogbGFiZWwgfTtcbiAgfSxcblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIGlmICgndmFsdWUnIGluIG5leHRQcm9wcykge1xuICAgICAgdmFyIHZhbHVlID0gKDAsIF91dGlsLnRvQXJyYXkpKG5leHRQcm9wcy52YWx1ZSk7XG4gICAgICB2YXIgbGFiZWwgPSB0aGlzLmdldExhYmVsRnJvbVByb3BzKG5leHRQcm9wcywgdmFsdWUpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgbGFiZWw6IGxhYmVsXG4gICAgICB9KTtcbiAgICAgIGlmIChuZXh0UHJvcHMuY29tYm9ib3gpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgaW5wdXRWYWx1ZTogdmFsdWVbMF0gfHwgJydcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICBpZiAoc3RhdGUub3BlbiAmJiAoMCwgX3V0aWwuaXNNdWx0aXBsZU9yVGFncykocHJvcHMpKSB7XG4gICAgICB2YXIgaW5wdXROb2RlID0gdGhpcy5nZXRJbnB1dERPTU5vZGUoKTtcbiAgICAgIGlmIChpbnB1dE5vZGUudmFsdWUpIHtcbiAgICAgICAgaW5wdXROb2RlLnN0eWxlLndpZHRoID0gJyc7XG4gICAgICAgIGlucHV0Tm9kZS5zdHlsZS53aWR0aCA9IGlucHV0Tm9kZS5zY3JvbGxXaWR0aCArICdweCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dE5vZGUuc3R5bGUud2lkdGggPSAnJztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLmRyb3Bkb3duQ29udGFpbmVyKSB7XG4gICAgICBfcmVhY3REb20yWydkZWZhdWx0J10udW5tb3VudENvbXBvbmVudEF0Tm9kZSh0aGlzLmRyb3Bkb3duQ29udGFpbmVyKTtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5kcm9wZG93bkNvbnRhaW5lcik7XG4gICAgICB0aGlzLmRyb3Bkb3duQ29udGFpbmVyID0gbnVsbDtcbiAgICB9XG4gIH0sXG5cbiAgb25JbnB1dENoYW5nZTogZnVuY3Rpb24gb25JbnB1dENoYW5nZShldmVudCkge1xuICAgIHZhciB2YWwgPSBldmVudC50YXJnZXQudmFsdWU7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGlucHV0VmFsdWU6IHZhbCxcbiAgICAgIG9wZW46IHRydWVcbiAgICB9KTtcbiAgICBpZiAoKDAsIF91dGlsLmlzQ29tYm9ib3gpKHByb3BzKSkge1xuICAgICAgdGhpcy5maXJlQ2hhbmdlKFt2YWxdLCBbdmFsXSk7XG4gICAgfVxuICAgIHByb3BzLm9uU2VhcmNoKHZhbCk7XG4gIH0sXG5cbiAgb25Ecm9wZG93blZpc2libGVDaGFuZ2U6IGZ1bmN0aW9uIG9uRHJvcGRvd25WaXNpYmxlQ2hhbmdlKG9wZW4pIHtcbiAgICB0aGlzLnNldE9wZW5TdGF0ZShvcGVuKTtcbiAgfSxcblxuICAvLyBjb21ib2JveCBpZ25vcmVcbiAgb25LZXlEb3duOiBmdW5jdGlvbiBvbktleURvd24oZXZlbnQpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIGlmIChwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIga2V5Q29kZSA9IGV2ZW50LmtleUNvZGU7XG4gICAgaWYgKHRoaXMuc3RhdGUub3BlbiAmJiAhdGhpcy5nZXRJbnB1dERPTU5vZGUoKSkge1xuICAgICAgdGhpcy5vbklucHV0S2V5RG93bihldmVudCk7XG4gICAgfSBlbHNlIGlmIChrZXlDb2RlID09PSBfcmNVdGlsLktleUNvZGUuRU5URVIgfHwga2V5Q29kZSA9PT0gX3JjVXRpbC5LZXlDb2RlLkRPV04pIHtcbiAgICAgIHRoaXMuc2V0T3BlblN0YXRlKHRydWUpO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sXG5cbiAgb25JbnB1dEtleURvd246IGZ1bmN0aW9uIG9uSW5wdXRLZXlEb3duKGV2ZW50KSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHZhciBrZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcbiAgICBpZiAoKDAsIF91dGlsLmlzTXVsdGlwbGVPclRhZ3MpKHByb3BzKSAmJiAhZXZlbnQudGFyZ2V0LnZhbHVlICYmIGtleUNvZGUgPT09IF9yY1V0aWwuS2V5Q29kZS5CQUNLU1BBQ0UpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHN0YXRlLnZhbHVlLmNvbmNhdCgpO1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCkge1xuICAgICAgICB2YXIgbGFiZWwgPSBzdGF0ZS5sYWJlbC5jb25jYXQoKTtcbiAgICAgICAgdmFyIHBvcFZhbHVlID0gdmFsdWUucG9wKCk7XG4gICAgICAgIGxhYmVsLnBvcCgpO1xuICAgICAgICBwcm9wcy5vbkRlc2VsZWN0KHBvcFZhbHVlKTtcbiAgICAgICAgdGhpcy5maXJlQ2hhbmdlKHZhbHVlLCBsYWJlbCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGtleUNvZGUgPT09IF9yY1V0aWwuS2V5Q29kZS5ET1dOKSB7XG4gICAgICBpZiAoIXN0YXRlLm9wZW4pIHtcbiAgICAgICAgdGhpcy5vcGVuSWZIYXNDaGlsZHJlbigpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PT0gX3JjVXRpbC5LZXlDb2RlLkVTQykge1xuICAgICAgaWYgKHN0YXRlLm9wZW4pIHtcbiAgICAgICAgdGhpcy5zZXRPcGVuU3RhdGUoZmFsc2UpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUub3Blbikge1xuICAgICAgdmFyIG1lbnUgPSB0aGlzLnJlZnMudHJpZ2dlci5nZXRJbm5lck1lbnUoKTtcbiAgICAgIGlmIChtZW51ICYmIG1lbnUub25LZXlEb3duKGV2ZW50KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgb25NZW51U2VsZWN0OiBmdW5jdGlvbiBvbk1lbnVTZWxlY3QoX3JlZikge1xuICAgIHZhciBpdGVtID0gX3JlZi5pdGVtO1xuXG4gICAgdmFyIHZhbHVlID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICB2YXIgbGFiZWwgPSB0aGlzLnN0YXRlLmxhYmVsO1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHNlbGVjdGVkVmFsdWUgPSAoMCwgX3V0aWwuZ2V0VmFsdWVQcm9wVmFsdWUpKGl0ZW0pO1xuICAgIHZhciBzZWxlY3RlZExhYmVsID0gdGhpcy5nZXRMYWJlbEZyb21PcHRpb24oaXRlbSk7XG4gICAgcHJvcHMub25TZWxlY3Qoc2VsZWN0ZWRWYWx1ZSwgaXRlbSk7XG4gICAgaWYgKCgwLCBfdXRpbC5pc011bHRpcGxlT3JUYWdzKShwcm9wcykpIHtcbiAgICAgIGlmICh2YWx1ZS5pbmRleE9mKHNlbGVjdGVkVmFsdWUpICE9PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHZhbHVlLmNvbmNhdChbc2VsZWN0ZWRWYWx1ZV0pO1xuICAgICAgbGFiZWwgPSBsYWJlbC5jb25jYXQoW3NlbGVjdGVkTGFiZWxdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZhbHVlWzBdID09PSBzZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2V0T3BlblN0YXRlKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSBbc2VsZWN0ZWRWYWx1ZV07XG4gICAgICBsYWJlbCA9IFtzZWxlY3RlZExhYmVsXTtcbiAgICAgIHRoaXMuc2V0T3BlblN0YXRlKGZhbHNlKTtcbiAgICB9XG4gICAgdGhpcy5maXJlQ2hhbmdlKHZhbHVlLCBsYWJlbCk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBpbnB1dFZhbHVlOiAnJ1xuICAgIH0pO1xuICAgIGlmICgoMCwgX3V0aWwuaXNDb21ib2JveCkocHJvcHMpKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaW5wdXRWYWx1ZTogKDAsIF91dGlsLmdldFByb3BWYWx1ZSkoaXRlbSwgcHJvcHMub3B0aW9uTGFiZWxQcm9wKVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIG9uTWVudURlc2VsZWN0OiBmdW5jdGlvbiBvbk1lbnVEZXNlbGVjdChfcmVmMikge1xuICAgIHZhciBpdGVtID0gX3JlZjIuaXRlbTtcbiAgICB2YXIgZG9tRXZlbnQgPSBfcmVmMi5kb21FdmVudDtcblxuICAgIGlmIChkb21FdmVudC50eXBlID09PSAnY2xpY2snKSB7XG4gICAgICB0aGlzLnJlbW92ZVNlbGVjdGVkKCgwLCBfdXRpbC5nZXRWYWx1ZVByb3BWYWx1ZSkoaXRlbSkpO1xuICAgIH1cbiAgICBpZiAoISgwLCBfdXRpbC5pc011bHRpcGxlT3JUYWdzKSh0aGlzLnByb3BzKSkge1xuICAgICAgdGhpcy5zZXRPcGVuU3RhdGUoZmFsc2UpO1xuICAgIH1cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGlucHV0VmFsdWU6ICcnXG4gICAgfSk7XG4gIH0sXG5cbiAgb25QbGFjZWhvbGRlckNsaWNrOiBmdW5jdGlvbiBvblBsYWNlaG9sZGVyQ2xpY2soKSB7XG4gICAgdGhpcy5nZXRJbnB1dERPTU5vZGUoKS5mb2N1cygpO1xuICB9LFxuXG4gIG9uQ2xlYXJTZWxlY3Rpb246IGZ1bmN0aW9uIG9uQ2xlYXJTZWxlY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHByb3BzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGlmIChzdGF0ZS5pbnB1dFZhbHVlIHx8IHN0YXRlLnZhbHVlLmxlbmd0aCkge1xuICAgICAgdGhpcy5maXJlQ2hhbmdlKFtdLCBbXSk7XG4gICAgICB0aGlzLnNldE9wZW5TdGF0ZShmYWxzZSk7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaW5wdXRWYWx1ZTogJydcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICBnZXRMYWJlbEJ5U2luZ2xlVmFsdWU6IGZ1bmN0aW9uIGdldExhYmVsQnlTaW5nbGVWYWx1ZShjaGlsZHJlbiwgdmFsdWUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgbGFiZWwgPSBudWxsO1xuICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC50eXBlID09PSBfT3B0R3JvdXAyWydkZWZhdWx0J10pIHtcbiAgICAgICAgdmFyIG1heWJlID0gX3RoaXMuZ2V0TGFiZWxCeVNpbmdsZVZhbHVlKGNoaWxkLnByb3BzLmNoaWxkcmVuLCB2YWx1ZSk7XG4gICAgICAgIGlmIChtYXliZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGxhYmVsID0gbWF5YmU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKDAsIF91dGlsLmdldFZhbHVlUHJvcFZhbHVlKShjaGlsZCkgPT09IHZhbHVlKSB7XG4gICAgICAgIGxhYmVsID0gX3RoaXMuZ2V0TGFiZWxGcm9tT3B0aW9uKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbGFiZWw7XG4gIH0sXG5cbiAgZ2V0TGFiZWxGcm9tT3B0aW9uOiBmdW5jdGlvbiBnZXRMYWJlbEZyb21PcHRpb24oY2hpbGQpIHtcbiAgICByZXR1cm4gKDAsIF91dGlsLmdldFByb3BWYWx1ZSkoY2hpbGQsIHRoaXMucHJvcHMub3B0aW9uTGFiZWxQcm9wKTtcbiAgfSxcblxuICBnZXRMYWJlbEZyb21Qcm9wczogZnVuY3Rpb24gZ2V0TGFiZWxGcm9tUHJvcHMocHJvcHMsIHZhbHVlLCBpbml0KSB7XG4gICAgdmFyIGxhYmVsID0gW107XG4gICAgaWYgKCdsYWJlbCcgaW4gcHJvcHMpIHtcbiAgICAgIGxhYmVsID0gKDAsIF91dGlsLnRvQXJyYXkpKHByb3BzLmxhYmVsKTtcbiAgICB9IGVsc2UgaWYgKGluaXQgJiYgJ2RlZmF1bHRMYWJlbCcgaW4gcHJvcHMpIHtcbiAgICAgIGxhYmVsID0gKDAsIF91dGlsLnRvQXJyYXkpKHByb3BzLmRlZmF1bHRMYWJlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhYmVsID0gdGhpcy5nZXRMYWJlbEJ5VmFsdWUocHJvcHMuY2hpbGRyZW4sIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGxhYmVsO1xuICB9LFxuXG4gIGdldFZMRm9yT25DaGFuZ2U6IGZ1bmN0aW9uIGdldFZMRm9yT25DaGFuZ2UodmxzKSB7XG4gICAgaWYgKHZscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gKDAsIF91dGlsLmlzTXVsdGlwbGVPclRhZ3MpKHRoaXMucHJvcHMpID8gdmxzIDogdmxzWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdmxzO1xuICB9LFxuXG4gIGdldExhYmVsQnlWYWx1ZTogZnVuY3Rpb24gZ2V0TGFiZWxCeVZhbHVlKGNoaWxkcmVuLCB2YWx1ZXMpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHJldHVybiB2YWx1ZXMubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdmFyIGxhYmVsID0gX3RoaXMyLmdldExhYmVsQnlTaW5nbGVWYWx1ZShjaGlsZHJlbiwgdmFsdWUpO1xuICAgICAgaWYgKGxhYmVsID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsYWJlbDtcbiAgICB9KTtcbiAgfSxcblxuICBnZXREcm9wZG93bkNvbnRhaW5lcjogZnVuY3Rpb24gZ2V0RHJvcGRvd25Db250YWluZXIoKSB7XG4gICAgaWYgKCF0aGlzLmRyb3Bkb3duQ29udGFpbmVyKSB7XG4gICAgICB0aGlzLmRyb3Bkb3duQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuZHJvcGRvd25Db250YWluZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kcm9wZG93bkNvbnRhaW5lcjtcbiAgfSxcblxuICBnZXRTZWFyY2hQbGFjZWhvbGRlckVsZW1lbnQ6IGZ1bmN0aW9uIGdldFNlYXJjaFBsYWNlaG9sZGVyRWxlbWVudChoaWRkZW4pIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIGlmIChwcm9wcy5zZWFyY2hQbGFjZWhvbGRlcikge1xuICAgICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnc3BhbicsXG4gICAgICAgIHtcbiAgICAgICAgICBzdHlsZTogeyBkaXNwbGF5OiBoaWRkZW4gPyAnbm9uZScgOiAnYmxvY2snIH0sXG4gICAgICAgICAgb25DbGljazogdGhpcy5vblBsYWNlaG9sZGVyQ2xpY2ssXG4gICAgICAgICAgY2xhc3NOYW1lOiBwcm9wcy5wcmVmaXhDbHMgKyAnLXNlYXJjaF9fZmllbGRfX3BsYWNlaG9sZGVyJyB9LFxuICAgICAgICBwcm9wcy5zZWFyY2hQbGFjZWhvbGRlclxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgZ2V0SW5wdXRFbGVtZW50OiBmdW5jdGlvbiBnZXRJbnB1dEVsZW1lbnQoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnc3BhbicsXG4gICAgICB7IGNsYXNzTmFtZTogcHJvcHMucHJlZml4Q2xzICsgJy1zZWFyY2hfX2ZpZWxkX193cmFwJyB9LFxuICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoJ2lucHV0JywgeyByZWY6IHRoaXMuc2F2ZUlucHV0UmVmLFxuICAgICAgICBvbkNoYW5nZTogdGhpcy5vbklucHV0Q2hhbmdlLFxuICAgICAgICBvbktleURvd246IHRoaXMub25JbnB1dEtleURvd24sXG4gICAgICAgIHZhbHVlOiB0aGlzLnN0YXRlLmlucHV0VmFsdWUsXG4gICAgICAgIGRpc2FibGVkOiBwcm9wcy5kaXNhYmxlZCxcbiAgICAgICAgY2xhc3NOYW1lOiBwcm9wcy5wcmVmaXhDbHMgKyAnLXNlYXJjaF9fZmllbGQnLFxuICAgICAgICByb2xlOiAndGV4dGJveCcgfSksXG4gICAgICAoMCwgX3V0aWwuaXNNdWx0aXBsZU9yVGFncykocHJvcHMpID8gbnVsbCA6IHRoaXMuZ2V0U2VhcmNoUGxhY2Vob2xkZXJFbGVtZW50KCEhdGhpcy5zdGF0ZS5pbnB1dFZhbHVlKVxuICAgICk7XG4gIH0sXG5cbiAgZ2V0SW5wdXRET01Ob2RlOiBmdW5jdGlvbiBnZXRJbnB1dERPTU5vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRJbnN0YW5jZTtcbiAgfSxcblxuICBnZXRQb3B1cERPTU5vZGU6IGZ1bmN0aW9uIGdldFBvcHVwRE9NTm9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWZzLnRyaWdnZXIuZ2V0UG9wdXBET01Ob2RlKCk7XG4gIH0sXG5cbiAgZ2V0UG9wdXBNZW51Q29tcG9uZW50OiBmdW5jdGlvbiBnZXRQb3B1cE1lbnVDb21wb25lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVmcy50cmlnZ2VyLmdldElubmVyTWVudSgpO1xuICB9LFxuXG4gIHNldE9wZW5TdGF0ZTogZnVuY3Rpb24gc2V0T3BlblN0YXRlKG9wZW4pIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHZhciByZWZzID0gdGhpcy5yZWZzO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgb3Blbjogb3BlblxuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChvcGVuIHx8ICgwLCBfdXRpbC5pc011bHRpcGxlT3JUYWdzT3JDb21ib2JveCkoX3RoaXMzLnByb3BzKSkge1xuICAgICAgICBpZiAoX3RoaXMzLmdldElucHV0RE9NTm9kZSgpKSB7XG4gICAgICAgICAgX3RoaXMzLmdldElucHV0RE9NTm9kZSgpLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVmcy5zZWxlY3Rpb24pIHtcbiAgICAgICAgcmVmcy5zZWxlY3Rpb24uZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICByZW1vdmVTZWxlY3RlZDogZnVuY3Rpb24gcmVtb3ZlU2VsZWN0ZWQoc2VsZWN0ZWRWYWx1ZSkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgaWYgKHByb3BzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBsYWJlbCA9IHRoaXMuc3RhdGUubGFiZWwuY29uY2F0KCk7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5zdGF0ZS52YWx1ZS5pbmRleE9mKHNlbGVjdGVkVmFsdWUpO1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuc3RhdGUudmFsdWUuZmlsdGVyKGZ1bmN0aW9uIChzaW5nbGVWYWx1ZSkge1xuICAgICAgcmV0dXJuIHNpbmdsZVZhbHVlICE9PSBzZWxlY3RlZFZhbHVlO1xuICAgIH0pO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGxhYmVsLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIHZhciBjYW5NdWx0aXBsZSA9ICgwLCBfdXRpbC5pc011bHRpcGxlT3JUYWdzKShwcm9wcyk7XG4gICAgaWYgKGNhbk11bHRpcGxlKSB7XG4gICAgICBwcm9wcy5vbkRlc2VsZWN0KHNlbGVjdGVkVmFsdWUpO1xuICAgIH1cbiAgICB0aGlzLmZpcmVDaGFuZ2UodmFsdWUsIGxhYmVsKTtcbiAgfSxcblxuICBvcGVuSWZIYXNDaGlsZHJlbjogZnVuY3Rpb24gb3BlbklmSGFzQ2hpbGRyZW4oKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICBpZiAoX3JlYWN0MlsnZGVmYXVsdCddLkNoaWxkcmVuLmNvdW50KHByb3BzLmNoaWxkcmVuKSB8fCAoMCwgX3V0aWwuaXNTaW5nbGVNb2RlKShwcm9wcykpIHtcbiAgICAgIHRoaXMuc2V0T3BlblN0YXRlKHRydWUpO1xuICAgIH1cbiAgfSxcblxuICBmaXJlQ2hhbmdlOiBmdW5jdGlvbiBmaXJlQ2hhbmdlKHZhbHVlLCBsYWJlbCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgaWYgKCEoJ3ZhbHVlJyBpbiBwcm9wcykpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICB2YWx1ZTogdmFsdWUsIGxhYmVsOiBsYWJlbFxuICAgICAgfSk7XG4gICAgfVxuICAgIHByb3BzLm9uQ2hhbmdlKHRoaXMuZ2V0VkxGb3JPbkNoYW5nZSh2YWx1ZSksIHRoaXMuZ2V0VkxGb3JPbkNoYW5nZShsYWJlbCkpO1xuICB9LFxuICByZW5kZXJUb3BDb250cm9sTm9kZTogZnVuY3Rpb24gcmVuZGVyVG9wQ29udHJvbE5vZGUoKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICB2YXIgdmFsdWUgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgIHZhciBsYWJlbCA9IHRoaXMuc3RhdGUubGFiZWw7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgY2hvaWNlVHJhbnNpdGlvbk5hbWUgPSBwcm9wcy5jaG9pY2VUcmFuc2l0aW9uTmFtZTtcbiAgICB2YXIgcHJlZml4Q2xzID0gcHJvcHMucHJlZml4Q2xzO1xuICAgIHZhciBtYXhUYWdUZXh0TGVuZ3RoID0gcHJvcHMubWF4VGFnVGV4dExlbmd0aDtcblxuICAgIC8vIHNpbmdsZSBhbmQgbm90IGNvbWJvYm94LCBpbnB1dCBpcyBpbnNpZGUgZHJvcGRvd25cbiAgICBpZiAoKDAsIF91dGlsLmlzU2luZ2xlTW9kZSkocHJvcHMpKSB7XG4gICAgICB2YXIgcGxhY2Vob2xkZXIgPSBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ3NwYW4nLFxuICAgICAgICB7IGtleTogJ3BsYWNlaG9sZGVyJyxcbiAgICAgICAgICBjbGFzc05hbWU6IHByZWZpeENscyArICctc2VsZWN0aW9uX19wbGFjZWhvbGRlcicgfSxcbiAgICAgICAgcHJvcHMucGxhY2Vob2xkZXJcbiAgICAgICk7XG4gICAgICB2YXIgaW5uZXJOb2RlID0gcGxhY2Vob2xkZXI7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5sYWJlbFswXSkge1xuICAgICAgICBpbm5lck5vZGUgPSBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgeyBrZXk6ICd2YWx1ZScgfSxcbiAgICAgICAgICB0aGlzLnN0YXRlLmxhYmVsWzBdXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdzcGFuJyxcbiAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctc2VsZWN0aW9uX19yZW5kZXJlZCcgfSxcbiAgICAgICAgaW5uZXJOb2RlXG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBzZWxlY3RlZFZhbHVlTm9kZXMgPSBbXTtcbiAgICBpZiAoKDAsIF91dGlsLmlzTXVsdGlwbGVPclRhZ3MpKHByb3BzKSkge1xuICAgICAgc2VsZWN0ZWRWYWx1ZU5vZGVzID0gdmFsdWUubWFwKGZ1bmN0aW9uIChzaW5nbGVWYWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBsYWJlbFtpbmRleF07XG4gICAgICAgIHZhciB0aXRsZSA9IGNvbnRlbnQ7XG4gICAgICAgIGlmIChtYXhUYWdUZXh0TGVuZ3RoICYmIHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJyAmJiBjb250ZW50Lmxlbmd0aCA+IG1heFRhZ1RleHRMZW5ndGgpIHtcbiAgICAgICAgICBjb250ZW50ID0gY29udGVudC5zbGljZSgwLCBtYXhUYWdUZXh0TGVuZ3RoKSArICcuLi4nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnbGknLFxuICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLXNlbGVjdGlvbl9fY2hvaWNlJyxcbiAgICAgICAgICAgIGtleTogc2luZ2xlVmFsdWUsXG4gICAgICAgICAgICB0aXRsZTogdGl0bGUgfSxcbiAgICAgICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLXNlbGVjdGlvbl9fY2hvaWNlX19jb250ZW50JyB9LFxuICAgICAgICAgICAgY29udGVudFxuICAgICAgICAgICksXG4gICAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nLCB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1zZWxlY3Rpb25fX2Nob2ljZV9fcmVtb3ZlJyxcbiAgICAgICAgICAgIG9uQ2xpY2s6IF90aGlzNC5yZW1vdmVTZWxlY3RlZC5iaW5kKF90aGlzNCwgc2luZ2xlVmFsdWUpIH0pXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgc2VsZWN0ZWRWYWx1ZU5vZGVzLnB1c2goX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnbGknLFxuICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctc2VhcmNoICcgKyBwcmVmaXhDbHMgKyAnLXNlYXJjaC0taW5saW5lJywga2V5OiAnX19pbnB1dCcgfSxcbiAgICAgIHRoaXMuZ2V0SW5wdXRFbGVtZW50KClcbiAgICApKTtcbiAgICB2YXIgY2xhc3NOYW1lID0gcHJlZml4Q2xzICsgJy1zZWxlY3Rpb25fX3JlbmRlcmVkJztcbiAgICBpZiAoKDAsIF91dGlsLmlzTXVsdGlwbGVPclRhZ3MpKHByb3BzKSAmJiBjaG9pY2VUcmFuc2l0aW9uTmFtZSkge1xuICAgICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICBfcmNBbmltYXRlMlsnZGVmYXVsdCddLFxuICAgICAgICB7IGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgICAgIGNvbXBvbmVudDogJ3VsJyxcbiAgICAgICAgICB0cmFuc2l0aW9uTmFtZTogY2hvaWNlVHJhbnNpdGlvbk5hbWUgfSxcbiAgICAgICAgc2VsZWN0ZWRWYWx1ZU5vZGVzXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAndWwnLFxuICAgICAgeyBjbGFzc05hbWU6IGNsYXNzTmFtZSB9LFxuICAgICAgc2VsZWN0ZWRWYWx1ZU5vZGVzXG4gICAgKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3Jvb3RDbHM7XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBtdWx0aXBsZSA9ICgwLCBfdXRpbC5pc011bHRpcGxlT3JUYWdzKShwcm9wcyk7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lO1xuICAgIHZhciBkaXNhYmxlZCA9IHByb3BzLmRpc2FibGVkO1xuICAgIHZhciBhbGxvd0NsZWFyID0gcHJvcHMuYWxsb3dDbGVhcjtcbiAgICB2YXIgcHJlZml4Q2xzID0gcHJvcHMucHJlZml4Q2xzO1xuXG4gICAgdmFyIGN0cmxOb2RlID0gdGhpcy5yZW5kZXJUb3BDb250cm9sTm9kZSgpO1xuICAgIHZhciBleHRyYVNlbGVjdGlvblByb3BzID0ge307XG4gICAgaWYgKCEoMCwgX3V0aWwuaXNDb21ib2JveCkocHJvcHMpKSB7XG4gICAgICBleHRyYVNlbGVjdGlvblByb3BzID0ge1xuICAgICAgICBvbktleURvd246IHRoaXMub25LZXlEb3duLFxuICAgICAgICB0YWJJbmRleDogMFxuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHJvb3RDbHMgPSAoX3Jvb3RDbHMgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9yb290Q2xzLCBjbGFzc05hbWUsICEhY2xhc3NOYW1lKSwgX2RlZmluZVByb3BlcnR5KF9yb290Q2xzLCBwcmVmaXhDbHMsIDEpLCBfZGVmaW5lUHJvcGVydHkoX3Jvb3RDbHMsIHByZWZpeENscyArICctb3BlbicsIHN0YXRlLm9wZW4pLCBfZGVmaW5lUHJvcGVydHkoX3Jvb3RDbHMsIHByZWZpeENscyArICctY29tYm9ib3gnLCAoMCwgX3V0aWwuaXNDb21ib2JveCkocHJvcHMpKSwgX2RlZmluZVByb3BlcnR5KF9yb290Q2xzLCBwcmVmaXhDbHMgKyAnLWRpc2FibGVkJywgZGlzYWJsZWQpLCBfZGVmaW5lUHJvcGVydHkoX3Jvb3RDbHMsIHByZWZpeENscyArICctZW5hYmxlZCcsICFkaXNhYmxlZCksIF9yb290Q2xzKTtcblxuICAgIHZhciBjbGVhciA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KCdzcGFuJywgeyBrZXk6ICdjbGVhcicsXG4gICAgICBjbGFzc05hbWU6IHByZWZpeENscyArICctc2VsZWN0aW9uX19jbGVhcicsXG4gICAgICBvbkNsaWNrOiB0aGlzLm9uQ2xlYXJTZWxlY3Rpb24gfSk7XG4gICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgX1NlbGVjdFRyaWdnZXIyWydkZWZhdWx0J10sXG4gICAgICBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgICAgb3B0aW9uczogcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIG11bHRpcGxlOiBtdWx0aXBsZSxcbiAgICAgICAgZGlzYWJsZWQ6IGRpc2FibGVkLFxuICAgICAgICB2aXNpYmxlOiBzdGF0ZS5vcGVuLFxuICAgICAgICBpbnB1dFZhbHVlOiBzdGF0ZS5pbnB1dFZhbHVlLFxuICAgICAgICBpbnB1dEVsZW1lbnQ6IHRoaXMuZ2V0SW5wdXRFbGVtZW50KCksXG4gICAgICAgIHZhbHVlOiBzdGF0ZS52YWx1ZSxcbiAgICAgICAgb25Ecm9wZG93blZpc2libGVDaGFuZ2U6IHRoaXMub25Ecm9wZG93blZpc2libGVDaGFuZ2UsXG4gICAgICAgIG9uTWVudVNlbGVjdDogdGhpcy5vbk1lbnVTZWxlY3QsXG4gICAgICAgIG9uTWVudURlc2VsZWN0OiB0aGlzLm9uTWVudURlc2VsZWN0LFxuICAgICAgICByZWY6ICd0cmlnZ2VyJyB9KSxcbiAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnc3BhbicsXG4gICAgICAgIHtcbiAgICAgICAgICBzdHlsZTogcHJvcHMuc3R5bGUsXG4gICAgICAgICAgY2xhc3NOYW1lOiAoMCwgX2NsYXNzbmFtZXMyWydkZWZhdWx0J10pKHJvb3RDbHMpIH0sXG4gICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICBfZXh0ZW5kcyh7IHJlZjogJ3NlbGVjdGlvbicsXG4gICAgICAgICAgICBrZXk6ICdzZWxlY3Rpb24nLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLXNlbGVjdGlvbiAnICsgcHJlZml4Q2xzICsgJy1zZWxlY3Rpb24tLScgKyAobXVsdGlwbGUgPyAnbXVsdGlwbGUnIDogJ3NpbmdsZScpLFxuICAgICAgICAgICAgcm9sZTogJ2NvbWJvYm94JyxcbiAgICAgICAgICAgICdhcmlhLWF1dG9jb21wbGV0ZSc6ICdsaXN0JyxcbiAgICAgICAgICAgICdhcmlhLWhhc3BvcHVwJzogJ3RydWUnLFxuICAgICAgICAgICAgJ2FyaWEtZXhwYW5kZWQnOiBzdGF0ZS5vcGVuXG4gICAgICAgICAgfSwgZXh0cmFTZWxlY3Rpb25Qcm9wcyksXG4gICAgICAgICAgY3RybE5vZGUsXG4gICAgICAgICAgYWxsb3dDbGVhciAmJiAhKDAsIF91dGlsLmlzTXVsdGlwbGVPclRhZ3MpKHByb3BzKSA/IGNsZWFyIDogbnVsbCxcbiAgICAgICAgICBtdWx0aXBsZSB8fCAhcHJvcHMuc2hvd0Fycm93ID8gbnVsbCA6IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgeyBrZXk6ICdhcnJvdycsIGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1hcnJvdycsIHRhYkluZGV4OiAnLTEnLCBzdHlsZTogeyBvdXRsaW5lOiAnbm9uZScgfSB9LFxuICAgICAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoJ2InLCBudWxsKVxuICAgICAgICAgICksXG4gICAgICAgICAgbXVsdGlwbGUgPyB0aGlzLmdldFNlYXJjaFBsYWNlaG9sZGVyRWxlbWVudCghIXRoaXMuc3RhdGUuaW5wdXRWYWx1ZSB8fCB0aGlzLnN0YXRlLnZhbHVlLmxlbmd0aCkgOiBudWxsXG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICB9XG59KTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gU2VsZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1zZWxlY3QyL34vcmMtc2VsZWN0L2xpYi9TZWxlY3QuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIE9wdEdyb3VwID0gKGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhPcHRHcm91cCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gT3B0R3JvdXAoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE9wdEdyb3VwKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKE9wdEdyb3VwLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gT3B0R3JvdXA7XG59KShfcmVhY3QyWydkZWZhdWx0J10uQ29tcG9uZW50KTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gT3B0R3JvdXA7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3QvbGliL09wdEdyb3VwLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0VmFsdWVQcm9wVmFsdWUgPSBnZXRWYWx1ZVByb3BWYWx1ZTtcbmV4cG9ydHMuZ2V0UHJvcFZhbHVlID0gZ2V0UHJvcFZhbHVlO1xuZXhwb3J0cy5pc0NvbWJvYm94ID0gaXNDb21ib2JveDtcbmV4cG9ydHMuaXNNdWx0aXBsZU9yVGFncyA9IGlzTXVsdGlwbGVPclRhZ3M7XG5leHBvcnRzLmlzTXVsdGlwbGVPclRhZ3NPckNvbWJvYm94ID0gaXNNdWx0aXBsZU9yVGFnc09yQ29tYm9ib3g7XG5leHBvcnRzLmlzU2luZ2xlTW9kZSA9IGlzU2luZ2xlTW9kZTtcbmV4cG9ydHMudG9BcnJheSA9IHRvQXJyYXk7XG5leHBvcnRzLmdldFNlbGVjdEtleXMgPSBnZXRTZWxlY3RLZXlzO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfcmNNZW51ID0gcmVxdWlyZSgncmMtbWVudScpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbmZ1bmN0aW9uIGdldFZhbHVlUHJvcFZhbHVlKGNoaWxkKSB7XG4gIHZhciBwcm9wcyA9IGNoaWxkLnByb3BzO1xuICBpZiAoJ3ZhbHVlJyBpbiBwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy52YWx1ZTtcbiAgfVxuICBpZiAoY2hpbGQua2V5KSB7XG4gICAgcmV0dXJuIGNoaWxkLmtleTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ25vIGtleSBvciB2YWx1ZSBmb3IgJyArIGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gZ2V0UHJvcFZhbHVlKGNoaWxkLCBwcm9wKSB7XG4gIGlmIChwcm9wID09PSAndmFsdWUnKSB7XG4gICAgcmV0dXJuIGdldFZhbHVlUHJvcFZhbHVlKGNoaWxkKTtcbiAgfVxuICByZXR1cm4gY2hpbGQucHJvcHNbcHJvcF07XG59XG5cbmZ1bmN0aW9uIGlzQ29tYm9ib3gocHJvcHMpIHtcbiAgcmV0dXJuIHByb3BzLmNvbWJvYm94O1xufVxuXG5mdW5jdGlvbiBpc011bHRpcGxlT3JUYWdzKHByb3BzKSB7XG4gIHJldHVybiBwcm9wcy5tdWx0aXBsZSB8fCBwcm9wcy50YWdzO1xufVxuXG5mdW5jdGlvbiBpc011bHRpcGxlT3JUYWdzT3JDb21ib2JveChwcm9wcykge1xuICByZXR1cm4gaXNNdWx0aXBsZU9yVGFncyhwcm9wcykgfHwgaXNDb21ib2JveChwcm9wcyk7XG59XG5cbmZ1bmN0aW9uIGlzU2luZ2xlTW9kZShwcm9wcykge1xuICByZXR1cm4gIWlzTXVsdGlwbGVPclRhZ3NPckNvbWJvYm94KHByb3BzKTtcbn1cblxuZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICB2YXIgcmV0ID0gdmFsdWU7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0ID0gW107XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0ID0gW3ZhbHVlXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBnZXRTZWxlY3RLZXlzKG1lbnVJdGVtcywgdmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgdmFyIHNlbGVjdGVkS2V5cyA9IFtdO1xuICBfcmVhY3QyWydkZWZhdWx0J10uQ2hpbGRyZW4uZm9yRWFjaChtZW51SXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0udHlwZSA9PT0gX3JjTWVudS5JdGVtR3JvdXApIHtcbiAgICAgIHNlbGVjdGVkS2V5cyA9IHNlbGVjdGVkS2V5cy5jb25jYXQoZ2V0U2VsZWN0S2V5cyhpdGVtLnByb3BzLmNoaWxkcmVuLCB2YWx1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXRlbVZhbHVlID0gZ2V0VmFsdWVQcm9wVmFsdWUoaXRlbSk7XG4gICAgICB2YXIgaXRlbUtleSA9IGl0ZW0ua2V5O1xuICAgICAgaWYgKHZhbHVlLmluZGV4T2YoaXRlbVZhbHVlKSAhPT0gLTEgJiYgaXRlbUtleSkge1xuICAgICAgICBzZWxlY3RlZEtleXMucHVzaChpdGVtS2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc2VsZWN0ZWRLZXlzO1xufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtc2VsZWN0Mi9+L3JjLXNlbGVjdC9saWIvdXRpbC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBSRV9OVU0gPSAvW1xcLStdPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdW1xcLStdP1xcZCt8KS8uc291cmNlO1xuXG5mdW5jdGlvbiBnZXRDbGllbnRQb3NpdGlvbihlbGVtKSB7XG4gIHZhciBib3ggPSB1bmRlZmluZWQ7XG4gIHZhciB4ID0gdW5kZWZpbmVkO1xuICB2YXIgeSA9IHVuZGVmaW5lZDtcbiAgdmFyIGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcbiAgdmFyIGJvZHkgPSBkb2MuYm9keTtcbiAgdmFyIGRvY0VsZW0gPSBkb2MgJiYgZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgLy8g5qC55o2uIEdCUyDmnIDmlrDmlbDmja7vvIxBLUdyYWRlIEJyb3dzZXJzIOmDveW3suaUr+aMgSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qg5pa55rOV77yM5LiN55So5YaN6ICD6JmR5Lyg57uf55qE5a6e546w5pa55byPXG4gIGJveCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgLy8g5rOo77yaalF1ZXJ5IOi/mOiAg+iZkeWHj+WOuyBkb2NFbGVtLmNsaWVudExlZnQvY2xpZW50VG9wXG4gIC8vIOS9hua1i+ivleWPkeeOsO+8jOi/meagt+WPjeiAjOS8muWvvOiHtOW9kyBodG1sIOWSjCBib2R5IOaciei+uei3nS/ovrnmoYbmoLflvI/ml7bvvIzojrflj5bnmoTlgLzkuI3mraPnoa5cbiAgLy8g5q2k5aSW77yMaWU2IOS8muW/veeVpSBodG1sIOeahCBtYXJnaW4g5YC877yM5bm46L+Q5Zyw5piv5rKh5pyJ6LCB5Lya5Y676K6+572uIGh0bWwg55qEIG1hcmdpblxuXG4gIHggPSBib3gubGVmdDtcbiAgeSA9IGJveC50b3A7XG5cbiAgLy8gSW4gSUUsIG1vc3Qgb2YgdGhlIHRpbWUsIDIgZXh0cmEgcGl4ZWxzIGFyZSBhZGRlZCB0byB0aGUgdG9wIGFuZCBsZWZ0XG4gIC8vIGR1ZSB0byB0aGUgaW1wbGljaXQgMi1waXhlbCBpbnNldCBib3JkZXIuICBJbiBJRTYvNyBxdWlya3MgbW9kZSBhbmRcbiAgLy8gSUU2IHN0YW5kYXJkcyBtb2RlLCB0aGlzIGJvcmRlciBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIHRoZVxuICAvLyBkb2N1bWVudCBlbGVtZW50J3MgYm9yZGVyIHRvIHplcm8gLS0gdGh1cywgd2UgY2Fubm90IHJlbHkgb24gdGhlXG4gIC8vIG9mZnNldCBhbHdheXMgYmVpbmcgMiBwaXhlbHMuXG5cbiAgLy8gSW4gcXVpcmtzIG1vZGUsIHRoZSBvZmZzZXQgY2FuIGJlIGRldGVybWluZWQgYnkgcXVlcnlpbmcgdGhlIGJvZHknc1xuICAvLyBjbGllbnRMZWZ0L2NsaWVudFRvcCwgYnV0IGluIHN0YW5kYXJkcyBtb2RlLCBpdCBpcyBmb3VuZCBieSBxdWVyeWluZ1xuICAvLyB0aGUgZG9jdW1lbnQgZWxlbWVudCdzIGNsaWVudExlZnQvY2xpZW50VG9wLiAgU2luY2Ugd2UgYWxyZWFkeSBjYWxsZWRcbiAgLy8gZ2V0Q2xpZW50Qm91bmRpbmdSZWN0IHdlIGhhdmUgYWxyZWFkeSBmb3JjZWQgYSByZWZsb3csIHNvIGl0IGlzIG5vdFxuICAvLyB0b28gZXhwZW5zaXZlIGp1c3QgdG8gcXVlcnkgdGhlbSBhbGwuXG5cbiAgLy8gaWUg5LiL5bqU6K+l5YeP5Y6756qX5Y+j55qE6L655qGG5ZCn77yM5q+V56uf6buY6K6kIGFic29sdXRlIOmDveaYr+ebuOWvueeql+WPo+WumuS9jeeahFxuICAvLyDnqpflj6PovrnmoYbmoIflh4bmmK/orr4gZG9jdW1lbnRFbGVtZW50ICxxdWlya3Mg5pe26K6+572uIGJvZHlcbiAgLy8g5pyA5aW956aB5q2i5ZyoIGJvZHkg5ZKMIGh0bWwg5LiK6L655qGGIO+8jOS9hiBpZSA8IDkgaHRtbCDpu5jorqTmnIkgMnB4IO+8jOWHj+WOu1xuICAvLyDkvYbmmK/pnZ4gaWUg5LiN5Y+v6IO96K6+572u56qX5Y+j6L655qGG77yMYm9keSBodG1sIOS5n+S4jeaYr+eql+WPoyAsaWUg5Y+v5Lul6YCa6L+HIGh0bWwsYm9keSDorr7nva5cbiAgLy8g5qCH5YeGIGllIOS4iyBkb2NFbGVtLmNsaWVudFRvcCDlsLHmmK8gYm9yZGVyLXRvcFxuICAvLyBpZTcgaHRtbCDljbPnqpflj6PovrnmoYbmlLnlj5jkuI3kuobjgILmsLjov5zkuLogMlxuICAvLyDkvYbmoIflh4YgZmlyZWZveC9jaHJvbWUvaWU5IOS4iyBkb2NFbGVtLmNsaWVudFRvcCDmmK/nqpflj6PovrnmoYbvvIzljbPkvb/orr7kuoYgYm9yZGVyLXRvcCDkuZ/kuLogMFxuXG4gIHggLT0gZG9jRWxlbS5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCB8fCAwO1xuICB5IC09IGRvY0VsZW0uY2xpZW50VG9wIHx8IGJvZHkuY2xpZW50VG9wIHx8IDA7XG5cbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiB4LFxuICAgIHRvcDogeVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRTY3JvbGwodywgdG9wKSB7XG4gIHZhciByZXQgPSB3WydwYWdlJyArICh0b3AgPyAnWScgOiAnWCcpICsgJ09mZnNldCddO1xuICB2YXIgbWV0aG9kID0gJ3Njcm9sbCcgKyAodG9wID8gJ1RvcCcgOiAnTGVmdCcpO1xuICBpZiAodHlwZW9mIHJldCAhPT0gJ251bWJlcicpIHtcbiAgICB2YXIgZCA9IHcuZG9jdW1lbnQ7XG4gICAgLy8gaWU2LDcsOCBzdGFuZGFyZCBtb2RlXG4gICAgcmV0ID0gZC5kb2N1bWVudEVsZW1lbnRbbWV0aG9kXTtcbiAgICBpZiAodHlwZW9mIHJldCAhPT0gJ251bWJlcicpIHtcbiAgICAgIC8vIHF1aXJrcyBtb2RlXG4gICAgICByZXQgPSBkLmJvZHlbbWV0aG9kXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsTGVmdCh3KSB7XG4gIHJldHVybiBnZXRTY3JvbGwodyk7XG59XG5cbmZ1bmN0aW9uIGdldFNjcm9sbFRvcCh3KSB7XG4gIHJldHVybiBnZXRTY3JvbGwodywgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdldE9mZnNldChlbCkge1xuICB2YXIgcG9zID0gZ2V0Q2xpZW50UG9zaXRpb24oZWwpO1xuICB2YXIgZG9jID0gZWwub3duZXJEb2N1bWVudDtcbiAgdmFyIHcgPSBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgcG9zLmxlZnQgKz0gZ2V0U2Nyb2xsTGVmdCh3KTtcbiAgcG9zLnRvcCArPSBnZXRTY3JvbGxUb3Aodyk7XG4gIHJldHVybiBwb3M7XG59XG5mdW5jdGlvbiBfZ2V0Q29tcHV0ZWRTdHlsZShlbGVtLCBuYW1lLCBjb21wdXRlZFN0eWxlXykge1xuICB2YXIgdmFsID0gJyc7XG4gIHZhciBkID0gZWxlbS5vd25lckRvY3VtZW50O1xuICB2YXIgY29tcHV0ZWRTdHlsZSA9IGNvbXB1dGVkU3R5bGVfIHx8IGQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtLCBudWxsKTtcblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20va2lzc3l0ZWFtL2tpc3N5L2lzc3Vlcy82MVxuICBpZiAoY29tcHV0ZWRTdHlsZSkge1xuICAgIHZhbCA9IGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKSB8fCBjb21wdXRlZFN0eWxlW25hbWVdO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxudmFyIF9SRV9OVU1fTk9fUFggPSBuZXcgUmVnRXhwKCdeKCcgKyBSRV9OVU0gKyAnKSg/IXB4KVthLXolXSskJywgJ2knKTtcbnZhciBSRV9QT1MgPSAvXih0b3B8cmlnaHR8Ym90dG9tfGxlZnQpJC87XG52YXIgQ1VSUkVOVF9TVFlMRSA9ICdjdXJyZW50U3R5bGUnO1xudmFyIFJVTlRJTUVfU1RZTEUgPSAncnVudGltZVN0eWxlJztcbnZhciBMRUZUID0gJ2xlZnQnO1xudmFyIFBYID0gJ3B4JztcblxuZnVuY3Rpb24gX2dldENvbXB1dGVkU3R5bGVJRShlbGVtLCBuYW1lKSB7XG4gIC8vIGN1cnJlbnRTdHlsZSBtYXliZSBudWxsXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNTIzMS5hc3B4XG4gIHZhciByZXQgPSBlbGVtW0NVUlJFTlRfU1RZTEVdICYmIGVsZW1bQ1VSUkVOVF9TVFlMRV1bbmFtZV07XG5cbiAgLy8g5b2TIHdpZHRoL2hlaWdodCDorr7nva7kuLrnmb7liIbmr5Tml7bvvIzpgJrov4cgcGl4ZWxMZWZ0IOaWueW8j+i9rOaNoueahCB3aWR0aC9oZWlnaHQg5YC8XG4gIC8vIOS4gOW8gOWni+WwseWkhOeQhuS6hiEgQ1VTVE9NX1NUWUxFLmhlaWdodCxDVVNUT01fU1RZTEUud2lkdGggLGNzc0hvb2sg6Kej5YazQDIwMTEtMDgtMTlcbiAgLy8g5ZyoIGllIOS4i+S4jeWvue+8jOmcgOimgeebtOaOpeeUqCBvZmZzZXQg5pa55byPXG4gIC8vIGJvcmRlcldpZHRoIOetieWAvOS5n+aciemXrumimO+8jOS9huiAg+iZkeWIsCBib3JkZXJXaWR0aCDorr7kuLrnmb7liIbmr5TnmoTmpoLnjoflvojlsI/vvIzov5nph4zlsLHkuI3ogIPomZHkuoZcblxuICAvLyBGcm9tIHRoZSBhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXG4gIC8vIGh0dHA6Ly9lcmlrLmVhZS5uZXQvYXJjaGl2ZXMvMjAwNy8wNy8yNy8xOC41NC4xNS8jY29tbWVudC0xMDIyOTFcbiAgLy8gSWYgd2UncmUgbm90IGRlYWxpbmcgd2l0aCBhIHJlZ3VsYXIgcGl4ZWwgbnVtYmVyXG4gIC8vIGJ1dCBhIG51bWJlciB0aGF0IGhhcyBhIHdlaXJkIGVuZGluZywgd2UgbmVlZCB0byBjb252ZXJ0IGl0IHRvIHBpeGVsc1xuICAvLyBleGNsdWRlIGxlZnQgcmlnaHQgZm9yIHJlbGF0aXZpdHlcbiAgaWYgKF9SRV9OVU1fTk9fUFgudGVzdChyZXQpICYmICFSRV9QT1MudGVzdChuYW1lKSkge1xuICAgIC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcbiAgICB2YXIgc3R5bGUgPSBlbGVtLnN0eWxlO1xuICAgIHZhciBsZWZ0ID0gc3R5bGVbTEVGVF07XG4gICAgdmFyIHJzTGVmdCA9IGVsZW1bUlVOVElNRV9TVFlMRV1bTEVGVF07XG5cbiAgICAvLyBwcmV2ZW50IGZsYXNoaW5nIG9mIGNvbnRlbnRcbiAgICBlbGVtW1JVTlRJTUVfU1RZTEVdW0xFRlRdID0gZWxlbVtDVVJSRU5UX1NUWUxFXVtMRUZUXTtcblxuICAgIC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcbiAgICBzdHlsZVtMRUZUXSA9IG5hbWUgPT09ICdmb250U2l6ZScgPyAnMWVtJyA6IHJldCB8fCAwO1xuICAgIHJldCA9IHN0eWxlLnBpeGVsTGVmdCArIFBYO1xuXG4gICAgLy8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuICAgIHN0eWxlW0xFRlRdID0gbGVmdDtcblxuICAgIGVsZW1bUlVOVElNRV9TVFlMRV1bTEVGVF0gPSByc0xlZnQ7XG4gIH1cbiAgcmV0dXJuIHJldCA9PT0gJycgPyAnYXV0bycgOiByZXQ7XG59XG5cbnZhciBnZXRDb21wdXRlZFN0eWxlWCA9IHVuZGVmaW5lZDtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBnZXRDb21wdXRlZFN0eWxlWCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlID8gX2dldENvbXB1dGVkU3R5bGUgOiBfZ2V0Q29tcHV0ZWRTdHlsZUlFO1xufVxuXG5mdW5jdGlvbiBlYWNoKGFyciwgZm4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBmbihhcnJbaV0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQm9yZGVyQm94Rm4oZWxlbSkge1xuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZVgoZWxlbSwgJ2JveFNpemluZycpID09PSAnYm9yZGVyLWJveCc7XG59XG5cbnZhciBCT1hfTU9ERUxTID0gWydtYXJnaW4nLCAnYm9yZGVyJywgJ3BhZGRpbmcnXTtcbnZhciBDT05URU5UX0lOREVYID0gLTE7XG52YXIgUEFERElOR19JTkRFWCA9IDI7XG52YXIgQk9SREVSX0lOREVYID0gMTtcbnZhciBNQVJHSU5fSU5ERVggPSAwO1xuXG5mdW5jdGlvbiBzd2FwKGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciBvbGQgPSB7fTtcbiAgdmFyIHN0eWxlID0gZWxlbS5zdHlsZTtcbiAgdmFyIG5hbWUgPSB1bmRlZmluZWQ7XG5cbiAgLy8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG4gIGZvciAobmFtZSBpbiBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIG9sZFtuYW1lXSA9IHN0eWxlW25hbWVdO1xuICAgICAgc3R5bGVbbmFtZV0gPSBvcHRpb25zW25hbWVdO1xuICAgIH1cbiAgfVxuXG4gIGNhbGxiYWNrLmNhbGwoZWxlbSk7XG5cbiAgLy8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG4gIGZvciAobmFtZSBpbiBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHN0eWxlW25hbWVdID0gb2xkW25hbWVdO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQQk1XaWR0aChlbGVtLCBwcm9wcywgd2hpY2gpIHtcbiAgdmFyIHZhbHVlID0gMDtcbiAgdmFyIHByb3AgPSB1bmRlZmluZWQ7XG4gIHZhciBqID0gdW5kZWZpbmVkO1xuICB2YXIgaSA9IHVuZGVmaW5lZDtcbiAgZm9yIChqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrKSB7XG4gICAgcHJvcCA9IHByb3BzW2pdO1xuICAgIGlmIChwcm9wKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgd2hpY2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNzc1Byb3AgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChwcm9wID09PSAnYm9yZGVyJykge1xuICAgICAgICAgIGNzc1Byb3AgPSBwcm9wICsgd2hpY2hbaV0gKyAnV2lkdGgnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNzc1Byb3AgPSBwcm9wICsgd2hpY2hbaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgKz0gcGFyc2VGbG9hdChnZXRDb21wdXRlZFN0eWxlWChlbGVtLCBjc3NQcm9wKSkgfHwgMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEEgY3J1ZGUgd2F5IG9mIGRldGVybWluaW5nIGlmIGFuIG9iamVjdCBpcyBhIHdpbmRvd1xuICogQG1lbWJlciB1dGlsXG4gKi9cbmZ1bmN0aW9uIGlzV2luZG93KG9iaikge1xuICAvLyBtdXN0IHVzZSA9PSBmb3IgaWU4XG4gIC8qIGVzbGludCBlcWVxZXE6MCAqL1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09IG9iai53aW5kb3c7XG59XG5cbnZhciBkb21VdGlscyA9IHt9O1xuXG5lYWNoKFsnV2lkdGgnLCAnSGVpZ2h0J10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRvbVV0aWxzWydkb2MnICsgbmFtZV0gPSBmdW5jdGlvbiAocmVmV2luKSB7XG4gICAgdmFyIGQgPSByZWZXaW4uZG9jdW1lbnQ7XG4gICAgcmV0dXJuIE1hdGgubWF4KFxuICAgIC8vIGZpcmVmb3ggY2hyb21lIGRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQ8IGJvZHkuc2Nyb2xsSGVpZ2h0XG4gICAgLy8gaWUgc3RhbmRhcmQgbW9kZSA6IGRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQ+IGJvZHkuc2Nyb2xsSGVpZ2h0XG4gICAgZC5kb2N1bWVudEVsZW1lbnRbJ3Njcm9sbCcgKyBuYW1lXSxcbiAgICAvLyBxdWlya3MgOiBkb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0IOacgOWkp+etieS6juWPr+inhueql+WPo+WkmuS4gOeCue+8n1xuICAgIGQuYm9keVsnc2Nyb2xsJyArIG5hbWVdLCBkb21VdGlsc1sndmlld3BvcnQnICsgbmFtZV0oZCkpO1xuICB9O1xuXG4gIGRvbVV0aWxzWyd2aWV3cG9ydCcgKyBuYW1lXSA9IGZ1bmN0aW9uICh3aW4pIHtcbiAgICAvLyBwYyBicm93c2VyIGluY2x1ZGVzIHNjcm9sbGJhciBpbiB3aW5kb3cuaW5uZXJXaWR0aFxuICAgIHZhciBwcm9wID0gJ2NsaWVudCcgKyBuYW1lO1xuICAgIHZhciBkb2MgPSB3aW4uZG9jdW1lbnQ7XG4gICAgdmFyIGJvZHkgPSBkb2MuYm9keTtcbiAgICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICB2YXIgZG9jdW1lbnRFbGVtZW50UHJvcCA9IGRvY3VtZW50RWxlbWVudFtwcm9wXTtcbiAgICAvLyDmoIflh4bmqKHlvI/lj5YgZG9jdW1lbnRFbGVtZW50XG4gICAgLy8gYmFja2NvbXBhdCDlj5YgYm9keVxuICAgIHJldHVybiBkb2MuY29tcGF0TW9kZSA9PT0gJ0NTUzFDb21wYXQnICYmIGRvY3VtZW50RWxlbWVudFByb3AgfHwgYm9keSAmJiBib2R5W3Byb3BdIHx8IGRvY3VtZW50RWxlbWVudFByb3A7XG4gIH07XG59KTtcblxuLypcbiDlvpfliLDlhYPntKDnmoTlpKflsI/kv6Hmga9cbiBAcGFyYW0gZWxlbVxuIEBwYXJhbSBuYW1lXG4gQHBhcmFtIHtTdHJpbmd9IFtleHRyYV0gICdwYWRkaW5nJyA6IChjc3Mgd2lkdGgpICsgcGFkZGluZ1xuICdib3JkZXInIDogKGNzcyB3aWR0aCkgKyBwYWRkaW5nICsgYm9yZGVyXG4gJ21hcmdpbicgOiAoY3NzIHdpZHRoKSArIHBhZGRpbmcgKyBib3JkZXIgKyBtYXJnaW5cbiAqL1xuZnVuY3Rpb24gZ2V0V0goZWxlbSwgbmFtZSwgZXh0cmEpIHtcbiAgaWYgKGlzV2luZG93KGVsZW0pKSB7XG4gICAgcmV0dXJuIG5hbWUgPT09ICd3aWR0aCcgPyBkb21VdGlscy52aWV3cG9ydFdpZHRoKGVsZW0pIDogZG9tVXRpbHMudmlld3BvcnRIZWlnaHQoZWxlbSk7XG4gIH0gZWxzZSBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gOSkge1xuICAgIHJldHVybiBuYW1lID09PSAnd2lkdGgnID8gZG9tVXRpbHMuZG9jV2lkdGgoZWxlbSkgOiBkb21VdGlscy5kb2NIZWlnaHQoZWxlbSk7XG4gIH1cbiAgdmFyIHdoaWNoID0gbmFtZSA9PT0gJ3dpZHRoJyA/IFsnTGVmdCcsICdSaWdodCddIDogWydUb3AnLCAnQm90dG9tJ107XG4gIHZhciBib3JkZXJCb3hWYWx1ZSA9IG5hbWUgPT09ICd3aWR0aCcgPyBlbGVtLm9mZnNldFdpZHRoIDogZWxlbS5vZmZzZXRIZWlnaHQ7XG4gIHZhciBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZVgoZWxlbSk7XG4gIHZhciBpc0JvcmRlckJveCA9IGlzQm9yZGVyQm94Rm4oZWxlbSwgY29tcHV0ZWRTdHlsZSk7XG4gIHZhciBjc3NCb3hWYWx1ZSA9IDA7XG4gIGlmIChib3JkZXJCb3hWYWx1ZSA9PSBudWxsIHx8IGJvcmRlckJveFZhbHVlIDw9IDApIHtcbiAgICBib3JkZXJCb3hWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAvLyBGYWxsIGJhY2sgdG8gY29tcHV0ZWQgdGhlbiB1biBjb21wdXRlZCBjc3MgaWYgbmVjZXNzYXJ5XG4gICAgY3NzQm94VmFsdWUgPSBnZXRDb21wdXRlZFN0eWxlWChlbGVtLCBuYW1lKTtcbiAgICBpZiAoY3NzQm94VmFsdWUgPT0gbnVsbCB8fCBOdW1iZXIoY3NzQm94VmFsdWUpIDwgMCkge1xuICAgICAgY3NzQm94VmFsdWUgPSBlbGVtLnN0eWxlW25hbWVdIHx8IDA7XG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZSAnJywgYXV0bywgYW5kIHByZXBhcmUgZm9yIGV4dHJhXG4gICAgY3NzQm94VmFsdWUgPSBwYXJzZUZsb2F0KGNzc0JveFZhbHVlKSB8fCAwO1xuICB9XG4gIGlmIChleHRyYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXh0cmEgPSBpc0JvcmRlckJveCA/IEJPUkRFUl9JTkRFWCA6IENPTlRFTlRfSU5ERVg7XG4gIH1cbiAgdmFyIGJvcmRlckJveFZhbHVlT3JJc0JvcmRlckJveCA9IGJvcmRlckJveFZhbHVlICE9PSB1bmRlZmluZWQgfHwgaXNCb3JkZXJCb3g7XG4gIHZhciB2YWwgPSBib3JkZXJCb3hWYWx1ZSB8fCBjc3NCb3hWYWx1ZTtcbiAgaWYgKGV4dHJhID09PSBDT05URU5UX0lOREVYKSB7XG4gICAgaWYgKGJvcmRlckJveFZhbHVlT3JJc0JvcmRlckJveCkge1xuICAgICAgcmV0dXJuIHZhbCAtIGdldFBCTVdpZHRoKGVsZW0sIFsnYm9yZGVyJywgJ3BhZGRpbmcnXSwgd2hpY2gsIGNvbXB1dGVkU3R5bGUpO1xuICAgIH1cbiAgICByZXR1cm4gY3NzQm94VmFsdWU7XG4gIH1cbiAgaWYgKGJvcmRlckJveFZhbHVlT3JJc0JvcmRlckJveCkge1xuICAgIHZhciBwYWRkaW5nID0gZXh0cmEgPT09IFBBRERJTkdfSU5ERVggPyAtZ2V0UEJNV2lkdGgoZWxlbSwgWydib3JkZXInXSwgd2hpY2gsIGNvbXB1dGVkU3R5bGUpIDogZ2V0UEJNV2lkdGgoZWxlbSwgWydtYXJnaW4nXSwgd2hpY2gsIGNvbXB1dGVkU3R5bGUpO1xuICAgIHJldHVybiB2YWwgKyAoZXh0cmEgPT09IEJPUkRFUl9JTkRFWCA/IDAgOiBwYWRkaW5nKTtcbiAgfVxuICByZXR1cm4gY3NzQm94VmFsdWUgKyBnZXRQQk1XaWR0aChlbGVtLCBCT1hfTU9ERUxTLnNsaWNlKGV4dHJhKSwgd2hpY2gsIGNvbXB1dGVkU3R5bGUpO1xufVxuXG52YXIgY3NzU2hvdyA9IHtcbiAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gIHZpc2liaWxpdHk6ICdoaWRkZW4nLFxuICBkaXNwbGF5OiAnYmxvY2snXG59O1xuXG4vLyBmaXggIzExOSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9raXNzeXRlYW0va2lzc3kvaXNzdWVzLzExOVxuZnVuY3Rpb24gZ2V0V0hJZ25vcmVEaXNwbGF5KGVsZW0pIHtcbiAgdmFyIHZhbCA9IHVuZGVmaW5lZDtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIC8vIGluIGNhc2UgZWxlbSBpcyB3aW5kb3dcbiAgLy8gZWxlbS5vZmZzZXRXaWR0aCA9PT0gdW5kZWZpbmVkXG4gIGlmIChlbGVtLm9mZnNldFdpZHRoICE9PSAwKSB7XG4gICAgdmFsID0gZ2V0V0guYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICBzd2FwKGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhbCA9IGdldFdILmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gY3NzKGVsLCBuYW1lLCB2KSB7XG4gIHZhciB2YWx1ZSA9IHY7XG4gIGlmICgodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG5hbWUpKSA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKHZhciBpIGluIG5hbWUpIHtcbiAgICAgIGlmIChuYW1lLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgIGNzcyhlbCwgaSwgbmFtZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgdmFsdWUgKz0gJ3B4JztcbiAgICB9XG4gICAgZWwuc3R5bGVbbmFtZV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlWChlbCwgbmFtZSk7XG59XG5cbmVhY2goWyd3aWR0aCcsICdoZWlnaHQnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIGZpcnN0ID0gbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSk7XG4gIGRvbVV0aWxzWydvdXRlcicgKyBmaXJzdF0gPSBmdW5jdGlvbiAoZWwsIGluY2x1ZGVNYXJnaW4pIHtcbiAgICByZXR1cm4gZWwgJiYgZ2V0V0hJZ25vcmVEaXNwbGF5KGVsLCBuYW1lLCBpbmNsdWRlTWFyZ2luID8gTUFSR0lOX0lOREVYIDogQk9SREVSX0lOREVYKTtcbiAgfTtcbiAgdmFyIHdoaWNoID0gbmFtZSA9PT0gJ3dpZHRoJyA/IFsnTGVmdCcsICdSaWdodCddIDogWydUb3AnLCAnQm90dG9tJ107XG5cbiAgZG9tVXRpbHNbbmFtZV0gPSBmdW5jdGlvbiAoZWxlbSwgdmFsKSB7XG4gICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZWxlbSkge1xuICAgICAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGVYKGVsZW0pO1xuICAgICAgICB2YXIgaXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveEZuKGVsZW0pO1xuICAgICAgICBpZiAoaXNCb3JkZXJCb3gpIHtcbiAgICAgICAgICB2YWwgKz0gZ2V0UEJNV2lkdGgoZWxlbSwgWydwYWRkaW5nJywgJ2JvcmRlciddLCB3aGljaCwgY29tcHV0ZWRTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNzcyhlbGVtLCBuYW1lLCB2YWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW0gJiYgZ2V0V0hJZ25vcmVEaXNwbGF5KGVsZW0sIG5hbWUsIENPTlRFTlRfSU5ERVgpO1xuICB9O1xufSk7XG5cbi8vIOiuvue9riBlbGVtIOebuOWvuSBlbGVtLm93bmVyRG9jdW1lbnQg55qE5Z2Q5qCHXG5mdW5jdGlvbiBzZXRPZmZzZXQoZWxlbSwgb2Zmc2V0KSB7XG4gIC8vIHNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cbiAgaWYgKGNzcyhlbGVtLCAncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycpIHtcbiAgICBlbGVtLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgfVxuXG4gIHZhciBvbGQgPSBnZXRPZmZzZXQoZWxlbSk7XG4gIHZhciByZXQgPSB7fTtcbiAgdmFyIGN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gIHZhciBrZXkgPSB1bmRlZmluZWQ7XG5cbiAgZm9yIChrZXkgaW4gb2Zmc2V0KSB7XG4gICAgaWYgKG9mZnNldC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBjdXJyZW50ID0gcGFyc2VGbG9hdChjc3MoZWxlbSwga2V5KSkgfHwgMDtcbiAgICAgIHJldFtrZXldID0gY3VycmVudCArIG9mZnNldFtrZXldIC0gb2xkW2tleV07XG4gICAgfVxuICB9XG4gIGNzcyhlbGVtLCByZXQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9leHRlbmRzKHtcbiAgZ2V0V2luZG93OiBmdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICAgIHZhciBkb2MgPSBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZTtcbiAgICByZXR1cm4gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gIH0sXG4gIG9mZnNldDogZnVuY3Rpb24gb2Zmc2V0KGVsLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBzZXRPZmZzZXQoZWwsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdldE9mZnNldChlbCk7XG4gICAgfVxuICB9LFxuXG4gIGlzV2luZG93OiBpc1dpbmRvdyxcbiAgZWFjaDogZWFjaCxcbiAgY3NzOiBjc3MsXG4gIGNsb25lOiBmdW5jdGlvbiBjbG9uZShvYmopIHtcbiAgICB2YXIgcmV0ID0ge307XG4gICAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgcmV0W2ldID0gb2JqW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgb3ZlcmZsb3cgPSBvYmoub3ZlcmZsb3c7XG4gICAgaWYgKG92ZXJmbG93KSB7XG4gICAgICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgcmV0Lm92ZXJmbG93W2ldID0gb2JqLm92ZXJmbG93W2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH0sXG4gIHNjcm9sbExlZnQ6IGZ1bmN0aW9uIHNjcm9sbExlZnQodywgdikge1xuICAgIGlmIChpc1dpbmRvdyh3KSkge1xuICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZ2V0U2Nyb2xsTGVmdCh3KTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5zY3JvbGxUbyh2LCBnZXRTY3JvbGxUb3AodykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB3LnNjcm9sbExlZnQ7XG4gICAgICB9XG4gICAgICB3LnNjcm9sbExlZnQgPSB2O1xuICAgIH1cbiAgfSxcbiAgc2Nyb2xsVG9wOiBmdW5jdGlvbiBzY3JvbGxUb3Aodywgdikge1xuICAgIGlmIChpc1dpbmRvdyh3KSkge1xuICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZ2V0U2Nyb2xsVG9wKHcpO1xuICAgICAgfVxuICAgICAgd2luZG93LnNjcm9sbFRvKGdldFNjcm9sbExlZnQodyksIHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB3LnNjcm9sbFRvcDtcbiAgICAgIH1cbiAgICAgIHcuc2Nyb2xsVG9wID0gdjtcbiAgICB9XG4gIH0sXG5cbiAgdmlld3BvcnRXaWR0aDogMCxcbiAgdmlld3BvcnRIZWlnaHQ6IDBcbn0sIGRvbVV0aWxzKTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3Qvfi9kb20tc2Nyb2xsLWludG8tdmlldy9saWIvdXRpbC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm5vb3AgPSBub29wO1xuZXhwb3J0cy5nZXRLZXlGcm9tQ2hpbGRyZW5JbmRleCA9IGdldEtleUZyb21DaGlsZHJlbkluZGV4O1xuZXhwb3J0cy5sb29wTWVudUl0ZW0gPSBsb29wTWVudUl0ZW07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgbm93ID0gRGF0ZS5ub3coKTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGdldEtleUZyb21DaGlsZHJlbkluZGV4KGNoaWxkLCBtZW51RXZlbnRLZXksIGluZGV4KSB7XG4gIHZhciBwcmVmaXggPSBtZW51RXZlbnRLZXkgfHwgJyc7XG4gIHJldHVybiBjaGlsZC5rZXkgfHwgcHJlZml4ICsgJ2l0ZW1fJyArIG5vdyArICdfJyArIGluZGV4O1xufVxuXG5mdW5jdGlvbiBsb29wTWVudUl0ZW0oY2hpbGRyZW4sIGNiKSB7XG4gIHZhciBpbmRleCA9IC0xO1xuICBfcmVhY3QyWydkZWZhdWx0J10uQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGMpIHtcbiAgICBpbmRleCsrO1xuICAgIGlmIChjICYmIGMudHlwZS5pc01lbnVJdGVtR3JvdXApIHtcbiAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5DaGlsZHJlbi5mb3JFYWNoKGMucHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjMikge1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICBjYihjMiwgaW5kZXgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNiKGMsIGluZGV4KTtcbiAgICB9XG4gIH0pO1xufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtc2VsZWN0Mi9+L3JjLXNlbGVjdC9+L3JjLW1lbnUvbGliL3V0aWwuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIE1lbnVJdGVtR3JvdXAgPSBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ01lbnVJdGVtR3JvdXAnLFxuXG4gIHByb3BUeXBlczoge1xuICAgIHJlbmRlck1lbnVJdGVtOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgaW5kZXg6IF9yZWFjdC5Qcm9wVHlwZXMubnVtYmVyXG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiBnZXREZWZhdWx0UHJvcHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRpc2FibGVkOiB0cnVlXG4gICAgfTtcbiAgfSxcblxuICByZW5kZXJJbm5lck1lbnVJdGVtOiBmdW5jdGlvbiByZW5kZXJJbm5lck1lbnVJdGVtKGl0ZW0sIHN1YkluZGV4KSB7XG4gICAgdmFyIHJlbmRlck1lbnVJdGVtID0gdGhpcy5wcm9wcy5yZW5kZXJNZW51SXRlbTtcbiAgICByZXR1cm4gcmVuZGVyTWVudUl0ZW0oaXRlbSwgdGhpcy5wcm9wcy5pbmRleCwgc3ViSW5kZXgpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSB8fCAnJztcbiAgICB2YXIgcm9vdFByZWZpeENscyA9IHByb3BzLnJvb3RQcmVmaXhDbHM7XG5cbiAgICBjbGFzc05hbWUgKz0gJyAnICsgcm9vdFByZWZpeENscyArICctaXRlbS1ncm91cCc7XG4gICAgdmFyIHRpdGxlQ2xhc3NOYW1lID0gcm9vdFByZWZpeENscyArICctaXRlbS1ncm91cC10aXRsZSc7XG4gICAgdmFyIGxpc3RDbGFzc05hbWUgPSByb290UHJlZml4Q2xzICsgJy1pdGVtLWdyb3VwLWxpc3QnO1xuICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICdsaScsXG4gICAgICB7IGNsYXNzTmFtZTogY2xhc3NOYW1lIH0sXG4gICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIHsgY2xhc3NOYW1lOiB0aXRsZUNsYXNzTmFtZSB9LFxuICAgICAgICBwcm9wcy50aXRsZVxuICAgICAgKSxcbiAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAndWwnLFxuICAgICAgICB7IGNsYXNzTmFtZTogbGlzdENsYXNzTmFtZSB9LFxuICAgICAgICBfcmVhY3QyWydkZWZhdWx0J10uQ2hpbGRyZW4ubWFwKHByb3BzLmNoaWxkcmVuLCB0aGlzLnJlbmRlcklubmVyTWVudUl0ZW0pXG4gICAgICApXG4gICAgKTtcbiAgfVxufSk7XG5cbk1lbnVJdGVtR3JvdXAuaXNNZW51SXRlbUdyb3VwID0gdHJ1ZTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gTWVudUl0ZW1Hcm91cDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtc2VsZWN0Mi9+L3JjLXNlbGVjdC9+L3JjLW1lbnUvbGliL01lbnVJdGVtR3JvdXAuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIERpdmlkZXIgPSBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ0RpdmlkZXInLFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBkaXNhYmxlZDogdHJ1ZVxuICAgIH07XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lIHx8ICcnO1xuICAgIHZhciByb290UHJlZml4Q2xzID0gcHJvcHMucm9vdFByZWZpeENscztcbiAgICBjbGFzc05hbWUgKz0gJyAnICsgKHJvb3RQcmVmaXhDbHMgKyAnLWl0ZW0tZGl2aWRlcicpO1xuICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudCgnbGknLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWUgfSkpO1xuICB9XG59KTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gRGl2aWRlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtc2VsZWN0Mi9+L3JjLXNlbGVjdC9+L3JjLW1lbnUvbGliL0RpdmlkZXIuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbnZhciBfcmNUcmlnZ2VyID0gcmVxdWlyZSgncmMtdHJpZ2dlcicpO1xuXG52YXIgX3JjVHJpZ2dlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yY1RyaWdnZXIpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfY2xhc3NuYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcblxudmFyIF9jbGFzc25hbWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzbmFtZXMpO1xuXG52YXIgX0Ryb3Bkb3duTWVudSA9IHJlcXVpcmUoJy4vRHJvcGRvd25NZW51Jyk7XG5cbnZhciBfRHJvcGRvd25NZW51MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Ryb3Bkb3duTWVudSk7XG5cbnZhciBfcmVhY3REb20gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIF9yZWFjdERvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdERvbSk7XG5cbnZhciBfT3B0R3JvdXAgPSByZXF1aXJlKCcuL09wdEdyb3VwJyk7XG5cbnZhciBfT3B0R3JvdXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfT3B0R3JvdXApO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIF9yY01lbnUgPSByZXF1aXJlKCdyYy1tZW51Jyk7XG5cbnZhciBCVUlMVF9JTl9QTEFDRU1FTlRTID0ge1xuICBib3R0b21MZWZ0OiB7XG4gICAgcG9pbnRzOiBbJ3RsJywgJ2JsJ10sXG4gICAgb2Zmc2V0OiBbMCwgNF0sXG4gICAgb3ZlcmZsb3c6IHtcbiAgICAgIGFkanVzdFg6IDAsXG4gICAgICBhZGp1c3RZOiAxXG4gICAgfVxuICB9LFxuICB0b3BMZWZ0OiB7XG4gICAgcG9pbnRzOiBbJ2JsJywgJ3RsJ10sXG4gICAgb2Zmc2V0OiBbMCwgLTRdLFxuICAgIG92ZXJmbG93OiB7XG4gICAgICBhZGp1c3RYOiAwLFxuICAgICAgYWRqdXN0WTogMVxuICAgIH1cbiAgfVxufTtcblxudmFyIFNlbGVjdFRyaWdnZXIgPSBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1NlbGVjdFRyaWdnZXInLFxuXG4gIHByb3BUeXBlczoge1xuICAgIGRyb3Bkb3duTWF0Y2hTZWxlY3RXaWR0aDogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIHZpc2libGU6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBmaWx0ZXJPcHRpb246IF9yZWFjdC5Qcm9wVHlwZXMuYW55LFxuICAgIG9wdGlvbnM6IF9yZWFjdC5Qcm9wVHlwZXMuYW55LFxuICAgIHByZWZpeENsczogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgcG9wdXBDbGFzc05hbWU6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGNoaWxkcmVuOiBfcmVhY3QuUHJvcFR5cGVzLmFueVxuICB9LFxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIGlmICh0aGlzLnByb3BzLmRyb3Bkb3duTWF0Y2hTZWxlY3RXaWR0aCAmJiB0aGlzLnByb3BzLnZpc2libGUpIHtcbiAgICAgIHZhciBkcm9wZG93bkRPTU5vZGUgPSB0aGlzLmdldFBvcHVwRE9NTm9kZSgpO1xuICAgICAgaWYgKGRyb3Bkb3duRE9NTm9kZSkge1xuICAgICAgICBkcm9wZG93bkRPTU5vZGUuc3R5bGUud2lkdGggPSBfcmVhY3REb20yWydkZWZhdWx0J10uZmluZERPTU5vZGUodGhpcykub2Zmc2V0V2lkdGggKyAncHgnO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBnZXRJbm5lck1lbnU6IGZ1bmN0aW9uIGdldElubmVyTWVudSgpIHtcbiAgICByZXR1cm4gdGhpcy5wb3B1cE1lbnUgJiYgdGhpcy5wb3B1cE1lbnUucmVmcy5tZW51O1xuICB9LFxuXG4gIGdldFBvcHVwRE9NTm9kZTogZnVuY3Rpb24gZ2V0UG9wdXBET01Ob2RlKCkge1xuICAgIHJldHVybiB0aGlzLnJlZnMudHJpZ2dlci5nZXRQb3B1cERvbU5vZGUoKTtcbiAgfSxcblxuICBnZXREcm9wZG93bkVsZW1lbnQ6IGZ1bmN0aW9uIGdldERyb3Bkb3duRWxlbWVudChuZXdQcm9wcykge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KF9Ecm9wZG93bk1lbnUyWydkZWZhdWx0J10sIF9leHRlbmRzKHtcbiAgICAgIHJlZjogdGhpcy5zYXZlTWVudVxuICAgIH0sIG5ld1Byb3BzLCB7XG4gICAgICBwcmVmaXhDbHM6IHRoaXMuZ2V0RHJvcGRvd25QcmVmaXhDbHMoKSxcbiAgICAgIG9uTWVudVNlbGVjdDogcHJvcHMub25NZW51U2VsZWN0LFxuICAgICAgb25NZW51RGVzZWxlY3Q6IHByb3BzLm9uTWVudURlc2VsZWN0LFxuICAgICAgdmFsdWU6IHByb3BzLnZhbHVlLFxuICAgICAgZGVmYXVsdEFjdGl2ZUZpcnN0T3B0aW9uOiBwcm9wcy5kZWZhdWx0QWN0aXZlRmlyc3RPcHRpb24sXG4gICAgICBkcm9wZG93bk1lbnVTdHlsZTogcHJvcHMuZHJvcGRvd25NZW51U3R5bGVcbiAgICB9KSk7XG4gIH0sXG5cbiAgZ2V0RHJvcGRvd25UcmFuc2l0aW9uTmFtZTogZnVuY3Rpb24gZ2V0RHJvcGRvd25UcmFuc2l0aW9uTmFtZSgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciB0cmFuc2l0aW9uTmFtZSA9IHByb3BzLnRyYW5zaXRpb25OYW1lO1xuICAgIGlmICghdHJhbnNpdGlvbk5hbWUgJiYgcHJvcHMuYW5pbWF0aW9uKSB7XG4gICAgICB0cmFuc2l0aW9uTmFtZSA9IHRoaXMuZ2V0RHJvcGRvd25QcmVmaXhDbHMoKSArICctJyArIHByb3BzLmFuaW1hdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zaXRpb25OYW1lO1xuICB9LFxuXG4gIGdldERyb3Bkb3duUHJlZml4Q2xzOiBmdW5jdGlvbiBnZXREcm9wZG93blByZWZpeENscygpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5wcmVmaXhDbHMgKyAnLWRyb3Bkb3duJztcbiAgfSxcblxuICBmaWx0ZXJPcHRpb246IGZ1bmN0aW9uIGZpbHRlck9wdGlvbihpbnB1dCwgY2hpbGQpIHtcbiAgICBpZiAoIWlucHV0KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGZpbHRlck9wdGlvbiA9IHRoaXMucHJvcHMuZmlsdGVyT3B0aW9uO1xuICAgIGlmICghZmlsdGVyT3B0aW9uKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGNoaWxkLnByb3BzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXJPcHRpb24uY2FsbCh0aGlzLCBpbnB1dCwgY2hpbGQpO1xuICB9LFxuXG4gIHNhdmVNZW51OiBmdW5jdGlvbiBzYXZlTWVudShtZW51KSB7XG4gICAgdGhpcy5wb3B1cE1lbnUgPSBtZW51O1xuICB9LFxuXG4gIHJlbmRlckZpbHRlck9wdGlvbnM6IGZ1bmN0aW9uIHJlbmRlckZpbHRlck9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyRmlsdGVyT3B0aW9uc0Zyb21DaGlsZHJlbih0aGlzLnByb3BzLm9wdGlvbnMsIHRydWUpO1xuICB9LFxuXG4gIHJlbmRlckZpbHRlck9wdGlvbnNGcm9tQ2hpbGRyZW46IGZ1bmN0aW9uIHJlbmRlckZpbHRlck9wdGlvbnNGcm9tQ2hpbGRyZW4oY2hpbGRyZW4sIHNob3dOb3RGb3VuZCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgc2VsID0gW107XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgaW5wdXRWYWx1ZSA9IHByb3BzLmlucHV0VmFsdWU7XG4gICAgdmFyIGNoaWxkcmVuS2V5cyA9IFtdO1xuICAgIHZhciB0YWdzID0gcHJvcHMudGFncztcbiAgICBfcmVhY3QyWydkZWZhdWx0J10uQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQudHlwZSA9PT0gX09wdEdyb3VwMlsnZGVmYXVsdCddKSB7XG4gICAgICAgIHZhciBpbm5lckl0ZW1zID0gX3RoaXMucmVuZGVyRmlsdGVyT3B0aW9uc0Zyb21DaGlsZHJlbihjaGlsZC5wcm9wcy5jaGlsZHJlbiwgZmFsc2UpO1xuICAgICAgICBpZiAoaW5uZXJJdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgbGFiZWwgPSBjaGlsZC5wcm9wcy5sYWJlbDtcbiAgICAgICAgICB2YXIga2V5ID0gY2hpbGQua2V5O1xuICAgICAgICAgIGlmICgha2V5ICYmIHR5cGVvZiBsYWJlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGtleSA9IGxhYmVsO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWxhYmVsICYmIGtleSkge1xuICAgICAgICAgICAgbGFiZWwgPSBrZXk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbC5wdXNoKF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgX3JjTWVudS5JdGVtR3JvdXAsXG4gICAgICAgICAgICB7IGtleToga2V5LCB0aXRsZTogbGFiZWwgfSxcbiAgICAgICAgICAgIGlubmVySXRlbXNcbiAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRWYWx1ZSA9ICgwLCBfdXRpbC5nZXRWYWx1ZVByb3BWYWx1ZSkoY2hpbGQpO1xuICAgICAgaWYgKF90aGlzLmZpbHRlck9wdGlvbihpbnB1dFZhbHVlLCBjaGlsZCkpIHtcbiAgICAgICAgc2VsLnB1c2goX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoX3JjTWVudS5JdGVtLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgdmFsdWU6IGNoaWxkVmFsdWUsXG4gICAgICAgICAga2V5OiBjaGlsZFZhbHVlXG4gICAgICAgIH0sIGNoaWxkLnByb3BzKSkpO1xuICAgICAgfVxuICAgICAgaWYgKHRhZ3MgJiYgIWNoaWxkLnByb3BzLmRpc2FibGVkKSB7XG4gICAgICAgIGNoaWxkcmVuS2V5cy5wdXNoKGNoaWxkVmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0YWdzKSB7XG4gICAgICAvLyB0YWdzIHZhbHVlIG11c3QgYmUgc3RyaW5nXG4gICAgICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgICAgIHZhbHVlID0gdmFsdWUuZmlsdGVyKGZ1bmN0aW9uIChzaW5nbGVWYWx1ZSkge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5LZXlzLmluZGV4T2Yoc2luZ2xlVmFsdWUpID09PSAtMSAmJiAoIWlucHV0VmFsdWUgfHwgc2luZ2xlVmFsdWUuaW5kZXhPZihpbnB1dFZhbHVlKSA+IC0xKTtcbiAgICAgIH0pO1xuICAgICAgc2VsID0gc2VsLmNvbmNhdCh2YWx1ZS5tYXAoZnVuY3Rpb24gKHNpbmdsZVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICBfcmNNZW51Lkl0ZW0sXG4gICAgICAgICAgeyB2YWx1ZTogc2luZ2xlVmFsdWUsIGtleTogc2luZ2xlVmFsdWUgfSxcbiAgICAgICAgICBzaW5nbGVWYWx1ZVxuICAgICAgICApO1xuICAgICAgfSkpO1xuICAgICAgaWYgKGlucHV0VmFsdWUpIHtcbiAgICAgICAgdmFyIG5vdEZpbmRJbnB1dEl0ZW0gPSBzZWwuZXZlcnkoZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICAgIHJldHVybiAoMCwgX3V0aWwuZ2V0VmFsdWVQcm9wVmFsdWUpKG9wdGlvbikgIT09IGlucHV0VmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobm90RmluZElucHV0SXRlbSkge1xuICAgICAgICAgIHNlbC51bnNoaWZ0KF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgX3JjTWVudS5JdGVtLFxuICAgICAgICAgICAgeyB2YWx1ZTogaW5wdXRWYWx1ZSwga2V5OiBpbnB1dFZhbHVlIH0sXG4gICAgICAgICAgICBpbnB1dFZhbHVlXG4gICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFzZWwubGVuZ3RoICYmIHNob3dOb3RGb3VuZCAmJiBwcm9wcy5ub3RGb3VuZENvbnRlbnQpIHtcbiAgICAgIHNlbCA9IFtfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgX3JjTWVudS5JdGVtLFxuICAgICAgICB7IGRpc2FibGVkOiB0cnVlLCB2YWx1ZTogJ05PVF9GT1VORCcsIGtleTogJ05PVF9GT1VORCcgfSxcbiAgICAgICAgcHJvcHMubm90Rm91bmRDb250ZW50XG4gICAgICApXTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbDtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3BvcHVwQ2xhc3NOYW1lO1xuXG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgbXVsdGlwbGUgPSBwcm9wcy5tdWx0aXBsZTtcbiAgICB2YXIgZHJvcGRvd25QcmVmaXhDbHMgPSB0aGlzLmdldERyb3Bkb3duUHJlZml4Q2xzKCk7XG4gICAgdmFyIHBvcHVwQ2xhc3NOYW1lID0gKF9wb3B1cENsYXNzTmFtZSA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX3BvcHVwQ2xhc3NOYW1lLCBwcm9wcy5kcm9wZG93bkNsYXNzTmFtZSwgISFwcm9wcy5kcm9wZG93bkNsYXNzTmFtZSksIF9kZWZpbmVQcm9wZXJ0eShfcG9wdXBDbGFzc05hbWUsIGRyb3Bkb3duUHJlZml4Q2xzICsgJy0tJyArIChtdWx0aXBsZSA/ICdtdWx0aXBsZScgOiAnc2luZ2xlJyksIDEpLCBfcG9wdXBDbGFzc05hbWUpO1xuICAgIHZhciB2aXNpYmxlID0gcHJvcHMudmlzaWJsZTtcbiAgICB2YXIgbWVudUl0ZW1zID0gdW5kZWZpbmVkO1xuICAgIHZhciBzZWFyY2ggPSB1bmRlZmluZWQ7XG4gICAgbWVudUl0ZW1zID0gdGhpcy5yZW5kZXJGaWx0ZXJPcHRpb25zKCk7XG4gICAgc2VhcmNoID0gbXVsdGlwbGUgfHwgcHJvcHMuY29tYm9ib3ggfHwgIXByb3BzLnNob3dTZWFyY2ggPyBudWxsIDogX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnc3BhbicsXG4gICAgICB7IGNsYXNzTmFtZTogZHJvcGRvd25QcmVmaXhDbHMgKyAnLXNlYXJjaCcgfSxcbiAgICAgIHByb3BzLmlucHV0RWxlbWVudFxuICAgICk7XG4gICAgaWYgKCFzZWFyY2ggJiYgIW1lbnVJdGVtcy5sZW5ndGgpIHtcbiAgICAgIHZpc2libGUgPSBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHBvcHVwRWxlbWVudCA9IHRoaXMuZ2V0RHJvcGRvd25FbGVtZW50KHtcbiAgICAgIG1lbnVJdGVtczogbWVudUl0ZW1zLFxuICAgICAgc2VhcmNoOiBzZWFyY2gsXG4gICAgICBtdWx0aXBsZTogbXVsdGlwbGUsXG4gICAgICB2aXNpYmxlOiB2aXNpYmxlXG4gICAgfSk7XG4gICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgX3JjVHJpZ2dlcjJbJ2RlZmF1bHQnXSxcbiAgICAgIHsgYWN0aW9uOiBwcm9wcy5kaXNhYmxlZCA/IFtdIDogWydjbGljayddLFxuICAgICAgICByZWY6ICd0cmlnZ2VyJyxcbiAgICAgICAgZ2V0UG9wdXBDb250YWluZXI6IHByb3BzLmdldFBvcHVwQ29udGFpbmVyLFxuICAgICAgICBwb3B1cFBsYWNlbWVudDogJ2JvdHRvbUxlZnQnLFxuICAgICAgICBidWlsdGluUGxhY2VtZW50czogQlVJTFRfSU5fUExBQ0VNRU5UUyxcbiAgICAgICAgcHJlZml4Q2xzOiBkcm9wZG93blByZWZpeENscyxcbiAgICAgICAgcG9wdXBUcmFuc2l0aW9uTmFtZTogdGhpcy5nZXREcm9wZG93blRyYW5zaXRpb25OYW1lKCksXG4gICAgICAgIG9uUG9wdXBWaXNpYmxlQ2hhbmdlOiBwcm9wcy5vbkRyb3Bkb3duVmlzaWJsZUNoYW5nZSxcbiAgICAgICAgcG9wdXA6IHBvcHVwRWxlbWVudCxcbiAgICAgICAgcG9wdXBWaXNpYmxlOiB2aXNpYmxlLFxuICAgICAgICBwb3B1cENsYXNzTmFtZTogKDAsIF9jbGFzc25hbWVzMlsnZGVmYXVsdCddKShwb3B1cENsYXNzTmFtZSksXG4gICAgICAgIHBvcHVwU3R5bGU6IHByb3BzLmRyb3Bkb3duU3R5bGVcbiAgICAgIH0sXG4gICAgICB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgKTtcbiAgfVxufSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFNlbGVjdFRyaWdnZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3QvbGliL1NlbGVjdFRyaWdnZXIuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yZWFjdERvbSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIF9yY01lbnUgPSByZXF1aXJlKCdyYy1tZW51Jyk7XG5cbnZhciBfcmNNZW51MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JjTWVudSk7XG5cbnZhciBfZG9tU2Nyb2xsSW50b1ZpZXcgPSByZXF1aXJlKCdkb20tc2Nyb2xsLWludG8tdmlldycpO1xuXG52YXIgX2RvbVNjcm9sbEludG9WaWV3MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RvbVNjcm9sbEludG9WaWV3KTtcblxudmFyIERyb3Bkb3duTWVudSA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnRHJvcGRvd25NZW51JyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBwcmVmaXhDbHM6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIG1lbnVJdGVtczogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5hbnksXG4gICAgc2VhcmNoOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmFueVxuICB9LFxuXG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLnNjcm9sbEFjdGl2ZUl0ZW1Ub1ZpZXcoKTtcbiAgfSxcblxuICBzaG91bGRDb21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMpIHtcbiAgICAvLyBmcmVlemUgd2hlbiBoaWRlXG4gICAgcmV0dXJuIG5leHRQcm9wcy52aXNpYmxlO1xuICB9LFxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgaWYgKCFwcmV2UHJvcHMudmlzaWJsZSAmJiBwcm9wcy52aXNpYmxlKSB7XG4gICAgICB0aGlzLnNjcm9sbEFjdGl2ZUl0ZW1Ub1ZpZXcoKTtcbiAgICB9XG4gIH0sXG5cbiAgc2Nyb2xsQWN0aXZlSXRlbVRvVmlldzogZnVuY3Rpb24gc2Nyb2xsQWN0aXZlSXRlbVRvVmlldygpIHtcbiAgICAvLyBzY3JvbGwgaW50byB2aWV3XG4gICAgdmFyIGl0ZW1Db21wb25lbnQgPSAoMCwgX3JlYWN0RG9tLmZpbmRET01Ob2RlKSh0aGlzLmZpcnN0QWN0aXZlSXRlbSk7XG4gICAgaWYgKGl0ZW1Db21wb25lbnQpIHtcbiAgICAgICgwLCBfZG9tU2Nyb2xsSW50b1ZpZXcyWydkZWZhdWx0J10pKGl0ZW1Db21wb25lbnQsICgwLCBfcmVhY3REb20uZmluZERPTU5vZGUpKHRoaXMucmVmcy5tZW51KSwge1xuICAgICAgICBvbmx5U2Nyb2xsSWZOZWVkZWQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICByZW5kZXJNZW51OiBmdW5jdGlvbiByZW5kZXJNZW51KCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBtZW51SXRlbXMgPSBwcm9wcy5tZW51SXRlbXM7XG4gICAgdmFyIGRlZmF1bHRBY3RpdmVGaXJzdE9wdGlvbiA9IHByb3BzLmRlZmF1bHRBY3RpdmVGaXJzdE9wdGlvbjtcbiAgICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgICB2YXIgZHJvcGRvd25NZW51U3R5bGUgPSBwcm9wcy5kcm9wZG93bk1lbnVTdHlsZTtcbiAgICB2YXIgcHJlZml4Q2xzID0gcHJvcHMucHJlZml4Q2xzO1xuICAgIHZhciBtdWx0aXBsZSA9IHByb3BzLm11bHRpcGxlO1xuICAgIHZhciBvbk1lbnVEZXNlbGVjdCA9IHByb3BzLm9uTWVudURlc2VsZWN0O1xuICAgIHZhciBvbk1lbnVTZWxlY3QgPSBwcm9wcy5vbk1lbnVTZWxlY3Q7XG5cbiAgICBpZiAobWVudUl0ZW1zICYmIG1lbnVJdGVtcy5sZW5ndGgpIHtcbiAgICAgIHZhciBfcmV0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1lbnVQcm9wcyA9IHt9O1xuICAgICAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgICAgICBtZW51UHJvcHMub25EZXNlbGVjdCA9IG9uTWVudURlc2VsZWN0O1xuICAgICAgICAgIG1lbnVQcm9wcy5vblNlbGVjdCA9IG9uTWVudVNlbGVjdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZW51UHJvcHMub25DbGljayA9IG9uTWVudVNlbGVjdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VsZWN0ZWRLZXlzID0gKDAsIF91dGlsLmdldFNlbGVjdEtleXMpKG1lbnVJdGVtcywgdmFsdWUpO1xuICAgICAgICB2YXIgYWN0aXZlS2V5UHJvcHMgPSB7fTtcblxuICAgICAgICB2YXIgY2xvbmVkTWVudUl0ZW1zID0gbWVudUl0ZW1zO1xuICAgICAgICBpZiAoc2VsZWN0ZWRLZXlzLmxlbmd0aCkge1xuICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhY3RpdmVLZXlQcm9wcy5hY3RpdmVLZXkgPSBzZWxlY3RlZEtleXNbMF07XG4gICAgICAgICAgICB2YXIgZm91bmRGaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gc2V0IGZpcnN0QWN0aXZlSXRlbSB2aWEgY2xvbmluZyBtZW51c1xuICAgICAgICAgICAgLy8gZm9yIHNjcm9sbCBpbnRvIHZpZXdcbiAgICAgICAgICAgIHZhciBjbG9uZSA9IGZ1bmN0aW9uIGNsb25lKGl0ZW0pIHtcbiAgICAgICAgICAgICAgaWYgKCFmb3VuZEZpcnN0ICYmIHNlbGVjdGVkS2V5cy5pbmRleE9mKGl0ZW0ua2V5KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBmb3VuZEZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9yZWFjdC5jbG9uZUVsZW1lbnQpKGl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgIHJlZjogZnVuY3Rpb24gcmVmKF9yZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZmlyc3RBY3RpdmVJdGVtID0gX3JlZjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNsb25lZE1lbnVJdGVtcyA9IG1lbnVJdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gX3JjTWVudS5JdGVtR3JvdXApIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBpdGVtLnByb3BzLmNoaWxkcmVuLm1hcChjbG9uZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfcmVhY3QuY2xvbmVFbGVtZW50KShpdGVtLCB7fSwgY2hpbGRyZW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBjbG9uZShpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHY6IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgX3JjTWVudTJbJ2RlZmF1bHQnXSxcbiAgICAgICAgICAgIF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgcmVmOiAnbWVudScsXG4gICAgICAgICAgICAgIGRlZmF1bHRBY3RpdmVGaXJzdDogZGVmYXVsdEFjdGl2ZUZpcnN0T3B0aW9uLFxuICAgICAgICAgICAgICBzdHlsZTogZHJvcGRvd25NZW51U3R5bGVcbiAgICAgICAgICAgIH0sIGFjdGl2ZUtleVByb3BzLCB7XG4gICAgICAgICAgICAgIG11bHRpcGxlOiBtdWx0aXBsZSxcbiAgICAgICAgICAgICAgZm9jdXNhYmxlOiBmYWxzZVxuICAgICAgICAgICAgfSwgbWVudVByb3BzLCB7XG4gICAgICAgICAgICAgIHNlbGVjdGVkS2V5czogc2VsZWN0ZWRLZXlzLFxuICAgICAgICAgICAgICBwcmVmaXhDbHM6IHByZWZpeENscyArICctbWVudScgfSksXG4gICAgICAgICAgICBjbG9uZWRNZW51SXRlbXNcbiAgICAgICAgICApXG4gICAgICAgIH07XG4gICAgICB9KSgpO1xuXG4gICAgICBpZiAodHlwZW9mIF9yZXQgPT09ICdvYmplY3QnKSByZXR1cm4gX3JldC52O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnZGl2JyxcbiAgICAgIG51bGwsXG4gICAgICB0aGlzLnByb3BzLnNlYXJjaCxcbiAgICAgIHRoaXMucmVuZGVyTWVudSgpXG4gICAgKTtcbiAgfVxufSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IERyb3Bkb3duTWVudTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtc2VsZWN0Mi9+L3JjLXNlbGVjdC9saWIvRHJvcGRvd25NZW51LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBPcHRpb24gPSAoZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKE9wdGlvbiwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gT3B0aW9uKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPcHRpb24pO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoT3B0aW9uLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gT3B0aW9uO1xufSkoX3JlYWN0MlsnZGVmYXVsdCddLkNvbXBvbmVudCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IE9wdGlvbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtc2VsZWN0Mi9+L3JjLXNlbGVjdC9saWIvT3B0aW9uLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBJbnB1dEZvcm1GaWVsZCA9IHJlcXVpcmUoJy4vSW5wdXRGb3JtRmllbGQnKTtcbnZhciBGb3JtYXR0ZXIgPSByZXF1aXJlKFwidXhjb3JlLWZvcm1hdHRlclwiKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBOdW1iZXJJbnB1dEZvcm1GaWVsZCA9IGZ1bmN0aW9uIChfSW5wdXRGb3JtRmllbGQpIHtcbiAgICBfaW5oZXJpdHMoTnVtYmVySW5wdXRGb3JtRmllbGQsIF9JbnB1dEZvcm1GaWVsZCk7XG5cbiAgICBmdW5jdGlvbiBOdW1iZXJJbnB1dEZvcm1GaWVsZChwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTnVtYmVySW5wdXRGb3JtRmllbGQpO1xuXG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfSW5wdXRGb3JtRmllbGQuY2FsbCh0aGlzLCBwcm9wcykpO1xuICAgIH1cblxuICAgIE51bWJlcklucHV0Rm9ybUZpZWxkLnByb3RvdHlwZS5mb3JtYXRWYWx1ZSA9IGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSByZXR1cm4gXCJcIjtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSArIFwiXCI7XG4gICAgICAgIGlmIChtZS5wcm9wcy5qc3h0eXBlID09IFwibW9uZXlcIikge1xuICAgICAgICAgICAgaWYgKHZhbHVlLm1hdGNoKC9cXC4oXFxkKykvKSAmJiB2YWx1ZS5tYXRjaCgvXFwuKFxcZCspLylbMV0ubGVuZ3RoID4gbWUucHJvcHMuZml4ZWROdW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRm9ybWF0dGVyLm1vbmV5KHZhbHVlLCBtZS5wcm9wcy5kZWxpbWl0ZXIsIG1lLnByb3BzLmZpeGVkTnVtKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZvcm1hdHRlci5tb25leSh2YWx1ZSwgbWUucHJvcHMuZGVsaW1pdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtZS5wcm9wcy5qc3h0eXBlID09IFwiY25tb2JpbGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIEZvcm1hdHRlci5jbm1vYmlsZSh2YWx1ZSwgbWUucHJvcHMuZGVsaW1pdGVyKTtcbiAgICAgICAgfSBlbHNlIGlmIChtZS5wcm9wcy5qc3h0eXBlID09IFwiY2FyZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gRm9ybWF0dGVyLmNhcmQodmFsdWUsIG1lLnByb3BzLmRlbGltaXRlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTnVtYmVySW5wdXRGb3JtRmllbGQucHJvdG90eXBlLmRlRm9ybWF0VmFsdWUgPSBmdW5jdGlvbiBkZUZvcm1hdFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIGlmIChtZS5wcm9wcy5qc3h0eXBlID09IFwibW9uZXlcIiB8fCBtZS5wcm9wcy5qc3h0eXBlID09IFwiY25tb2JpbGVcIiB8fCBtZS5wcm9wcy5qc3h0eXBlID09IFwiY2FyZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuc3BsaXQobWUucHJvcHMuZGVsaW1pdGVyKS5qb2luKFwiXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIE51bWJlcklucHV0Rm9ybUZpZWxkLnByb3RvdHlwZS5hZGRTcGVjaWZpY0NsYXNzID0gZnVuY3Rpb24gYWRkU3BlY2lmaWNDbGFzcygpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgaWYgKG1lLnByb3BzLmpzeHByZWZpeENscyA9PSBcImt1bWEtdXhmb3JtLWZpZWxkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBtZS5wcm9wcy5qc3hwcmVmaXhDbHMgKyBcIiBrdW1hLW51bWJlci1pbnB1dC11eGZvcm0tZmllbGRcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtZS5wcm9wcy5qc3hwcmVmaXhDbHM7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIE51bWJlcklucHV0Rm9ybUZpZWxkO1xufShJbnB1dEZvcm1GaWVsZCk7XG5cbk51bWJlcklucHV0Rm9ybUZpZWxkLmRpc3BsYXlOYW1lID0gXCJOdW1iZXJJbnB1dEZvcm1GaWVsZFwiO1xuTnVtYmVySW5wdXRGb3JtRmllbGQucHJvcFR5cGVzID0gYXNzaWduKHt9LCBJbnB1dEZvcm1GaWVsZC5wcm9wVHlwZXMsIHtcbiAgICBqc3h0eXBlOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGRlbGltaXRlcjogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBmaXhlZE51bTogUmVhY3QuUHJvcFR5cGVzLm51bWJlclxufSk7XG5OdW1iZXJJbnB1dEZvcm1GaWVsZC5kZWZhdWx0UHJvcHMgPSBhc3NpZ24oe30sIElucHV0Rm9ybUZpZWxkLmRlZmF1bHRQcm9wcywge1xuICAgIGpzeHR5cGU6ICcnLFxuICAgIGRlbGltaXRlcjogJyAnXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBOdW1iZXJJbnB1dEZvcm1GaWVsZDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vYnVpbGQvRm9ybUZpZWxkL051bWJlcklucHV0Rm9ybUZpZWxkLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEZvcm1GaWVsZCA9IHJlcXVpcmUoJy4vRm9ybUZpZWxkJyk7XG52YXIgQ29uc3RhbnRzID0gcmVxdWlyZSgndXhjb3JlLWNvbnN0Jyk7XG52YXIgY2xhc3NuYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcbnZhciBDYWxlbmRhciA9IHJlcXVpcmUoJ3V4Y29yZS1jYWxlbmRhcicpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcbnZhciB1cGRhdGUgPSBSZWFjdC5hZGRvbnMudXBkYXRlO1xudmFyIGRlZXBjb3B5ID0gcmVxdWlyZSgnZGVlcGNvcHknKTtcblxudmFyIERhdGVGb3JtRmllbGQgPSBmdW5jdGlvbiAoX0Zvcm1GaWVsZCkge1xuICAgIF9pbmhlcml0cyhEYXRlRm9ybUZpZWxkLCBfRm9ybUZpZWxkKTtcblxuICAgIGZ1bmN0aW9uIERhdGVGb3JtRmllbGQocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERhdGVGb3JtRmllbGQpO1xuXG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfRm9ybUZpZWxkLmNhbGwodGhpcywgcHJvcHMpKTtcbiAgICB9XG5cbiAgICBEYXRlRm9ybUZpZWxkLnByb3RvdHlwZS5oYW5kbGVDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVDaGFuZ2UodmFsdWUpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgbWUuaGFuZGxlRGF0YUNoYW5nZShuZXcgRGF0ZSh2YWx1ZSkudG9KU09OKCkpO1xuICAgIH07XG5cbiAgICBEYXRlRm9ybUZpZWxkLnByb3RvdHlwZS5oYW5kbGVDYXNjYWRlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlQ2FzY2FkZUNoYW5nZShpLCB2YWx1ZSkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgdmFsdWVzID0gZGVlcGNvcHkobWUuc3RhdGUudmFsdWUpIHx8IFtdO1xuICAgICAgICB2YWx1ZXNbaV0gPSBuZXcgRGF0ZSh2YWx1ZSkudG9KU09OKCk7XG4gICAgICAgIGlmIChpID09IDAgJiYgISF2YWx1ZXNbMV0gJiYgbmV3IERhdGUodmFsdWUpLmdldFRpbWUoKSA+IG5ldyBEYXRlKHZhbHVlc1sxXSkuZ2V0VGltZSgpKSB7XG4gICAgICAgICAgICB2YWx1ZXMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT0gMSAmJiAhIXZhbHVlc1swXSAmJiBuZXcgRGF0ZSh2YWx1ZSkuZ2V0VGltZSgpIDwgbmV3IERhdGUodmFsdWVzWzBdKS5nZXRUaW1lKCkpIHtcbiAgICAgICAgICAgIHZhbHVlc1swXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBtZS5oYW5kbGVEYXRhQ2hhbmdlKHZhbHVlcyk7XG4gICAgfTtcblxuICAgIERhdGVGb3JtRmllbGQucHJvdG90eXBlLmFkZFNwZWNpZmljQ2xhc3MgPSBmdW5jdGlvbiBhZGRTcGVjaWZpY0NsYXNzKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBpZiAobWUucHJvcHMuanN4cHJlZml4Q2xzID09IFwia3VtYS11eGZvcm0tZmllbGRcIikge1xuICAgICAgICAgICAgdmFyIHN0ciA9IG1lLnByb3BzLmpzeHByZWZpeENscyArIFwiIGt1bWEtZGF0ZS11eGZvcm0tZmllbGRcIjtcbiAgICAgICAgICAgIGlmIChtZS5wcm9wcy5qc3h0eXBlID09IFwiY2FzY2FkZVwiKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9IFwiIGt1bWEtY2FzY2FkZS1kYXRlLXV4Zm9ybS1maWVsZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtZS5wcm9wcy5qc3hwcmVmaXhDbHM7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgRGF0ZUZvcm1GaWVsZC5wcm90b3R5cGUucmVuZGVyRmllbGQgPSBmdW5jdGlvbiByZW5kZXJGaWVsZCgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIF9tZSRwcm9wcyA9IG1lLnByb3BzO1xuICAgICAgICB2YXIgb25TZWxlY3QgPSBfbWUkcHJvcHMub25TZWxlY3Q7XG4gICAgICAgIHZhciBzdHlsZSA9IF9tZSRwcm9wcy5zdHlsZTtcbiAgICAgICAgdmFyIHByZWZpeENscyA9IF9tZSRwcm9wcy5wcmVmaXhDbHM7XG4gICAgICAgIHZhciB2YWx1ZSA9IF9tZSRwcm9wcy52YWx1ZTtcbiAgICAgICAgdmFyIGpzeHR5cGUgPSBfbWUkcHJvcHMuanN4dHlwZTtcbiAgICAgICAgdmFyIGpzeGZyb20gPSBfbWUkcHJvcHMuanN4ZnJvbTtcbiAgICAgICAgdmFyIGpzeHRvID0gX21lJHByb3BzLmpzeHRvO1xuICAgICAgICB2YXIgZGlzYWJsZWREYXRlID0gX21lJHByb3BzLmRpc2FibGVkRGF0ZTtcblxuICAgICAgICB2YXIgb3RoZXJzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9tZSRwcm9wcywgWydvblNlbGVjdCcsICdzdHlsZScsICdwcmVmaXhDbHMnLCAndmFsdWUnLCAnanN4dHlwZScsICdqc3hmcm9tJywgJ2pzeHRvJywgJ2Rpc2FibGVkRGF0ZSddKTtcblxuICAgICAgICB2YXIgZnJvbSA9ICEhanN4ZnJvbSA/IG5ldyBEYXRlKGpzeGZyb20pLmdldFRpbWUoKSA6IDA7XG4gICAgICAgIHZhciB0byA9ICEhanN4dG8gPyBuZXcgRGF0ZShqc3h0bykuZ2V0VGltZSgpIDogSW5maW5pdHk7XG4gICAgICAgIHZhciBtb2RlID0gbWUucHJvcHMuanN4bW9kZSB8fCBtZS5wcm9wcy5tb2RlO1xuICAgICAgICBpZiAobW9kZSA9PSBDb25zdGFudHMuTU9ERS5FRElUKSB7XG4gICAgICAgICAgICBpZiAoanN4dHlwZSA9PSBcInNpbmdsZVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FsZW5kYXIsIF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1lLnN0YXRlLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBvblNlbGVjdDogbWUuaGFuZGxlQ2hhbmdlLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZERhdGU6IGZ1bmN0aW9uIGRpc2FibGVkRGF0ZShjdXJyZW50LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQuZ2V0VGltZSgpIDwgZnJvbSB8fCBjdXJyZW50LmdldFRpbWUoKSA+IHRvO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgb3RoZXJzKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGpzeHR5cGUgPT0gXCJjYXNjYWRlXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJyID0gW107XG4gICAgICAgICAgICAgICAgdmFyIG90aGVyczEgPSBhc3NpZ24oe30sIG90aGVycyk7XG4gICAgICAgICAgICAgICAgdmFyIG90aGVyczIgPSBhc3NpZ24oe30sIG90aGVycyk7XG4gICAgICAgICAgICAgICAgaWYgKG1lLnN0YXRlLnZhbHVlICYmIG1lLnN0YXRlLnZhbHVlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIG90aGVyczEgPSBhc3NpZ24oe30sIG90aGVycywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1lLnN0YXRlLnZhbHVlWzBdXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG90aGVyczEgPSBhc3NpZ24oe30sIG90aGVycywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtZS5zdGF0ZS52YWx1ZSAmJiBtZS5zdGF0ZS52YWx1ZVsxXSkge1xuICAgICAgICAgICAgICAgICAgICBvdGhlcnMyID0gYXNzaWduKHt9LCBvdGhlcnMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtZS5zdGF0ZS52YWx1ZVsxXVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdGhlcnMyID0gYXNzaWduKHt9LCBvdGhlcnMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcnIucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KENhbGVuZGFyLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAgICAgIGtleTogJ2NhbGVuZGFyMScsXG4gICAgICAgICAgICAgICAgICAgIG9uU2VsZWN0OiBtZS5oYW5kbGVDYXNjYWRlQ2hhbmdlLmJpbmQobWUsIDApLFxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZERhdGU6IGZ1bmN0aW9uIGRpc2FibGVkRGF0ZShjdXJyZW50LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQuZ2V0VGltZSgpIDwgZnJvbSB8fCBjdXJyZW50LmdldFRpbWUoKSA+IHRvO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgb3RoZXJzMSkpKTtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICAgICAgICAgIHsga2V5OiAnc3BsaXQnLCBjbGFzc05hbWU6ICdrdW1hLXV4Zm9ybS1zcGxpdCcgfSxcbiAgICAgICAgICAgICAgICAgICAgJy0nXG4gICAgICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgICAgICBhcnIucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KENhbGVuZGFyLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAgICAgIGtleTogJ2NhbGVuZGFyMicsXG4gICAgICAgICAgICAgICAgICAgIG9uU2VsZWN0OiBtZS5oYW5kbGVDYXNjYWRlQ2hhbmdlLmJpbmQobWUsIDEpLFxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZERhdGU6IGZ1bmN0aW9uIGRpc2FibGVkRGF0ZShjdXJyZW50LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vdyA9IGN1cnJlbnQuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0ID0gbWUuc3RhdGUudmFsdWUgPyBtZS5zdGF0ZS52YWx1ZVswXSA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IG5ldyBEYXRlKGZpcnN0KS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm93IDwgZnJvbSB8fCBub3cgPiB0byB8fCBub3cgPCBmaXJzdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIG90aGVyczIpKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtb2RlID09IENvbnN0YW50cy5NT0RFLlZJRVcpIHtcbiAgICAgICAgICAgIGlmIChqc3h0eXBlID09IFwic2luZ2xlXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICBtZS5zdGF0ZS52YWx1ZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICEhbWUuc3RhdGUudmFsdWUgPyBtZS5zdGF0ZS52YWx1ZS5qb2luKFwiIC0gXCIpIDogXCJcIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIERhdGVGb3JtRmllbGQ7XG59KEZvcm1GaWVsZCk7XG5cbkRhdGVGb3JtRmllbGQuZGlzcGxheU5hbWUgPSBcIkRhdGVGb3JtRmllbGRcIjtcbkRhdGVGb3JtRmllbGQucHJvcFR5cGVzID0gYXNzaWduKEZvcm1GaWVsZC5wcm9wVHlwZXMsIHtcbiAgICBqc3h0eXBlOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nXG59KTtcbkRhdGVGb3JtRmllbGQuZGVmYXVsdFByb3BzID0gYXNzaWduKEZvcm1GaWVsZC5kZWZhdWx0UHJvcHMsIHtcbiAgICBsb2NhbGU6ICd6aC1jbicsXG4gICAgaGFzVHJpZ2dlcjogdHJ1ZSxcbiAgICBqc3h0eXBlOiBcInNpbmdsZVwiXG59KTtcbm1vZHVsZS5leHBvcnRzID0gRGF0ZUZvcm1GaWVsZDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vYnVpbGQvRm9ybUZpZWxkL0RhdGVGb3JtRmllbGQuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFJjQ2FsZW5kYXIgPSByZXF1aXJlKCdyYy1jYWxlbmRhcicpO1xudmFyIERhdGVwaWNrZXIgPSByZXF1aXJlKCcuL1BpY2tlcicpO1xudmFyIEdyZWdvcmlhbkNhbGVuZGFyID0gcmVxdWlyZSgnZ3JlZ29yaWFuLWNhbGVuZGFyJyk7XG52YXIgRGF0ZVRpbWVGb3JtYXQgPSByZXF1aXJlKCdncmVnb3JpYW4tY2FsZW5kYXItZm9ybWF0Jyk7XG52YXIgUmNNb250aENhbGVuZGFyID0gcmVxdWlyZSgncmMtY2FsZW5kYXIvbGliL01vbnRoQ2FsZW5kYXInKTtcbnZhciBSY1llYXJDYWxlbmRhciA9IHJlcXVpcmUoJy4vWWVhckNhbGVuZGFyJyk7XG52YXIgY2xhc3NTZXQgPSByZXF1aXJlKCdyYy11dGlsJykuY2xhc3NTZXQ7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBkZWZhdWx0VmFsdWVMb2NhbGUgPSB7fTtcbnZhciBDYWxlbmRhckxvY2FsZSA9IHt9O1xuZGVmYXVsdFZhbHVlTG9jYWxlWyd6aC1jbiddID0gcmVxdWlyZSgnZ3JlZ29yaWFuLWNhbGVuZGFyL2xpYi9sb2NhbGUvemgtY24nKTtcbmRlZmF1bHRWYWx1ZUxvY2FsZVsnZW4tdXMnXSA9IHJlcXVpcmUoJ2dyZWdvcmlhbi1jYWxlbmRhci9saWIvbG9jYWxlL2VuLXVzJyk7XG5DYWxlbmRhckxvY2FsZVsnemgtY24nXSA9IHJlcXVpcmUoJ3JjLWNhbGVuZGFyL2xpYi9sb2NhbGUvemgtY24nKTtcbkNhbGVuZGFyTG9jYWxlWydlbi11cyddID0gcmVxdWlyZSgncmMtY2FsZW5kYXIvbGliL2xvY2FsZS9lbi11cycpO1xuXG5mdW5jdGlvbiBnZXRHcmVnb3JpYW5DYWxlbmRhckRhdGUoZGF0ZSwgbG9jYWxlKSB7XG4gICAgZGVmYXVsdFZhbHVlTG9jYWxlW2xvY2FsZV0udGltZXpvbmVPZmZzZXQgPSAtbmV3IERhdGUoKS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgIHZhciB2YWx1ZSA9IG5ldyBHcmVnb3JpYW5DYWxlbmRhcihkZWZhdWx0VmFsdWVMb2NhbGVbbG9jYWxlXSk7XG4gICAgdmFsdWUuc2V0VGltZShuZXcgRGF0ZShkYXRlKS52YWx1ZU9mKCkpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2FsZW5kYXJDb250YWluZXIoKSB7XG4gICAgdmFyIGMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjLmNsYXNzTmFtZSA9ICd1eGNvcmUnO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYyk7XG4gICAgcmV0dXJuIGM7XG59XG5cbnZhciBDYWxlbmRhciA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzKENhbGVuZGFyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIENhbGVuZGFyKHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYWxlbmRhcik7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7fTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBwID0gbWUucHJvcHM7XG4gICAgICAgIHZhciBmb3JtYXR0ZXIgPSBuZXcgRGF0ZVRpbWVGb3JtYXQocC5mb3JtYXQpO1xuICAgICAgICB2YXIgY2FsZW5kYXJPcHRpb25zID0ge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBwLmNsYXNzTmFtZSxcbiAgICAgICAgICAgIHN0eWxlOiBwLnN0eWxlLFxuICAgICAgICAgICAgZGlzYWJsZWREYXRlOiBwLmRpc2FibGVkRGF0ZSxcbiAgICAgICAgICAgIHNob3dXZWVrTnVtYmVyOiBwLnNob3dXZWVrTnVtYmVyLFxuICAgICAgICAgICAgc2hvd1RvZGF5OiBwLnNob3dUb2RheSxcbiAgICAgICAgICAgIHNob3dUaW1lOiBwLnNob3dUaW1lLFxuICAgICAgICAgICAgbG9jYWxlOiBDYWxlbmRhckxvY2FsZVtwLmxvY2FsZV0sXG4gICAgICAgICAgICBvcmllbnQ6IFsndG9wJywgJ2xlZnQnXSxcbiAgICAgICAgICAgIHByZWZpeENsczogJ2t1bWEtY2FsZW5kYXInXG4gICAgICAgIH07XG4gICAgICAgIHZhciBwaWNrZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgZGlzYWJsZWQ6IHAuZGlzYWJsZWQsXG4gICAgICAgICAgICBmb3JtYXR0ZXI6IGZvcm1hdHRlcixcbiAgICAgICAgICAgIGFkanVzdE9yaWVudE9uQ2FsZW5kYXJPdmVyZmxvdzogZmFsc2UsXG4gICAgICAgICAgICBwcmVmaXhDbHM6ICdrdW1hLWNhbGVuZGFyLXBpY2tlcicsXG4gICAgICAgICAgICBnZXRDYWxlbmRhckNvbnRhaW5lcjogZ2V0Q2FsZW5kYXJDb250YWluZXJcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAocC52YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZ2V0R3JlZ29yaWFuQ2FsZW5kYXJEYXRlKHAudmFsdWUsIHAubG9jYWxlKTtcbiAgICAgICAgICAgIHBpY2tlck9wdGlvbnMudmFsdWUgPSBjYWxlbmRhck9wdGlvbnMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBpY2tlck9wdGlvbnMudmFsdWUgPSBjYWxlbmRhck9wdGlvbnMudmFsdWUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHAuZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBnZXRHcmVnb3JpYW5DYWxlbmRhckRhdGUocC5kZWZhdWx0VmFsdWUsIHAubG9jYWxlKTtcbiAgICAgICAgICAgIGNhbGVuZGFyT3B0aW9ucy5kZWZhdWx0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHBpY2tlck9wdGlvbnMuZGVmYXVsdFZhbHVlID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBnZXRHcmVnb3JpYW5DYWxlbmRhckRhdGUobmV3IERhdGUoKS5nZXRUaW1lKCksIHAubG9jYWxlKTtcbiAgICAgICAgICAgIGNhbGVuZGFyT3B0aW9ucy5kZWZhdWx0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocC5oYXNUcmlnZ2VyKSB7XG4gICAgICAgICAgICBwaWNrZXJPcHRpb25zLnRyaWdnZXIgPSBSZWFjdC5jcmVhdGVFbGVtZW50KCdpJywgeyBjbGFzc05hbWU6ICdrdW1hLWljb24ga3VtYS1pY29uLWNhbGVuZGVyJyB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYWxlbmRhciA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmNDYWxlbmRhciwgY2FsZW5kYXJPcHRpb25zKTtcblxuICAgICAgICBmdW5jdGlvbiBfb25DaGFuZ2Uodikge1xuICAgICAgICAgICAgdmFyIGRhdGUgPSB2LmdldFRpbWUoKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGdldEdyZWdvcmlhbkNhbGVuZGFyRGF0ZShkYXRlLCBwLmxvY2FsZSk7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uU2VsZWN0KG5ldyBEYXRlKGRhdGUpLCBmb3JtYXR0ZXIuZm9ybWF0KHZhbHVlKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgIERhdGVwaWNrZXIsXG4gICAgICAgICAgICBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAgY2FsZW5kYXI6IGNhbGVuZGFyLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBfb25DaGFuZ2UuYmluZChtZSlcbiAgICAgICAgICAgIH0sIHBpY2tlck9wdGlvbnMpLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnaW5wdXQnLCB7IGRpc2FibGVkOiBtZS5wcm9wcy5kaXNhYmxlZCwgcGxhY2Vob2xkZXI6IHRoaXMucHJvcHMucGxhY2Vob2xkZXIsIGNsYXNzTmFtZTogJ2t1bWEtY2FsZW5kYXItcGlja2VyLWlucHV0IGt1bWEtaW5wdXQnIH0pXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHJldHVybiBDYWxlbmRhcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuQ2FsZW5kYXIuZGlzcGxheU5hbWUgPSAnQ2FsZW5kYXInO1xuQ2FsZW5kYXIuZGVmYXVsdFByb3BzID0ge1xuICAgIGZvcm1hdDogJ3l5eXktTU0tZGQnLFxuICAgIHBsYWNlaG9sZGVyOiAn6K+36YCJ5oup5pel5pyfJyxcbiAgICBvblNlbGVjdDogZnVuY3Rpb24gb25TZWxlY3QoKSB7fSxcbiAgICBsb2NhbGU6ICd6aC1jbicsXG4gICAgaGFzVHJpZ2dlcjogZmFsc2Vcbn07XG5DYWxlbmRhci5wcm9wVHlwZXMgPSB7XG4gICAgZm9ybWF0OiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHBsYWNlaG9sZGVyOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9uU2VsZWN0OiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBsb2NhbGU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgaGFzVHJpZ2dlcjogUmVhY3QuUHJvcFR5cGVzLmJvb2xcbn07XG5cbnZhciBNb250aENhbGVuZGFyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQyKSB7XG4gICAgX2luaGVyaXRzKE1vbnRoQ2FsZW5kYXIsIF9SZWFjdCRDb21wb25lbnQyKTtcblxuICAgIGZ1bmN0aW9uIE1vbnRoQ2FsZW5kYXIocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1vbnRoQ2FsZW5kYXIpO1xuXG4gICAgICAgIHZhciBfdGhpczIgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50Mi5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICAgICAgX3RoaXMyLnN0YXRlID0ge307XG4gICAgICAgIHJldHVybiBfdGhpczI7XG4gICAgfVxuXG4gICAgTW9udGhDYWxlbmRhci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgcCA9IG1lLnByb3BzO1xuICAgICAgICB2YXIgZm9ybWF0dGVyID0gbmV3IERhdGVUaW1lRm9ybWF0KHAuZm9ybWF0KTtcbiAgICAgICAgdmFyIGNhbGVuZGFyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogcC5jbGFzc05hbWUsXG4gICAgICAgICAgICBzdHlsZTogcC5zdHlsZSxcbiAgICAgICAgICAgIGxvY2FsZTogQ2FsZW5kYXJMb2NhbGVbcC5sb2NhbGVdLFxuICAgICAgICAgICAgb3JpZW50OiBbJ3RvcCcsICdsZWZ0J10sXG4gICAgICAgICAgICBwcmVmaXhDbHM6ICdrdW1hLWNhbGVuZGFyJ1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcGlja2VyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGRpc2FibGVkOiBwLmRpc2FibGVkLFxuICAgICAgICAgICAgZm9ybWF0dGVyOiBmb3JtYXR0ZXIsXG4gICAgICAgICAgICBhZGp1c3RPcmllbnRPbkNhbGVuZGFyT3ZlcmZsb3c6IGZhbHNlLFxuICAgICAgICAgICAgcHJlZml4Q2xzOiAna3VtYS1jYWxlbmRhci1waWNrZXInLFxuICAgICAgICAgICAgZ2V0Q2FsZW5kYXJDb250YWluZXI6IGdldENhbGVuZGFyQ29udGFpbmVyXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHAudmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGdldEdyZWdvcmlhbkNhbGVuZGFyRGF0ZShwLnZhbHVlLCBwLmxvY2FsZSk7XG4gICAgICAgICAgICBwaWNrZXJPcHRpb25zLnZhbHVlID0gY2FsZW5kYXJPcHRpb25zLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwaWNrZXJPcHRpb25zLnZhbHVlID0gY2FsZW5kYXJPcHRpb25zLnZhbHVlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwLmRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZ2V0R3JlZ29yaWFuQ2FsZW5kYXJEYXRlKHAuZGVmYXVsdFZhbHVlLCBwLmxvY2FsZSk7XG4gICAgICAgICAgICBjYWxlbmRhck9wdGlvbnMuZGVmYXVsdFZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbGVuZGFyID0gUmVhY3QuY3JlYXRlRWxlbWVudChSY01vbnRoQ2FsZW5kYXIsIGNhbGVuZGFyT3B0aW9ucyk7XG5cbiAgICAgICAgZnVuY3Rpb24gX29uQ2hhbmdlKHYpIHtcbiAgICAgICAgICAgIHZhciBkYXRlID0gdi5nZXRUaW1lKCk7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBnZXRHcmVnb3JpYW5DYWxlbmRhckRhdGUoZGF0ZSwgcC5sb2NhbGUpO1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vblNlbGVjdChuZXcgRGF0ZShkYXRlKSwgZm9ybWF0dGVyLmZvcm1hdCh2YWx1ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBEYXRlcGlja2VyLFxuICAgICAgICAgICAgX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgIGNhbGVuZGFyOiBjYWxlbmRhcixcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogX29uQ2hhbmdlLmJpbmQobWUpXG4gICAgICAgICAgICB9LCBwaWNrZXJPcHRpb25zKSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JywgeyBkaXNhYmxlZDogbWUucHJvcHMuZGlzYWJsZWQsIHBsYWNlaG9sZGVyOiB0aGlzLnByb3BzLnBsYWNlaG9sZGVyLCBjbGFzc05hbWU6ICdrdW1hLWNhbGVuZGFyLXBpY2tlci1pbnB1dCBrdW1hLWlucHV0JyB9KVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gTW9udGhDYWxlbmRhcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuTW9udGhDYWxlbmRhci5kaXNwbGF5TmFtZSA9ICdNb250aENhbGVuZGFyJztcbk1vbnRoQ2FsZW5kYXIuZGVmYXVsdFByb3BzID0ge1xuICAgIGZvcm1hdDogJ3l5eXktTU0nLFxuICAgIHBsYWNlaG9sZGVyOiAn6K+36YCJ5oup5pyI5Lu9JyxcbiAgICBvblNlbGVjdDogZnVuY3Rpb24gb25TZWxlY3QoKSB7fSxcbiAgICBsb2NhbGU6ICd6aC1jbidcbn07XG5Nb250aENhbGVuZGFyLnByb3BUeXBlcyA9IHtcbiAgICBmb3JtYXQ6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgcGxhY2Vob2xkZXI6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgb25TZWxlY3Q6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIGxvY2FsZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZ1xufTtcblxudmFyIFllYXJDYWxlbmRhciA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50Mykge1xuICAgIF9pbmhlcml0cyhZZWFyQ2FsZW5kYXIsIF9SZWFjdCRDb21wb25lbnQzKTtcblxuICAgIGZ1bmN0aW9uIFllYXJDYWxlbmRhcihwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgWWVhckNhbGVuZGFyKTtcblxuICAgICAgICB2YXIgX3RoaXMzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudDMuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgICAgIF90aGlzMy5zdGF0ZSA9IHt9O1xuICAgICAgICByZXR1cm4gX3RoaXMzO1xuICAgIH1cblxuICAgIFllYXJDYWxlbmRhci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgcCA9IG1lLnByb3BzO1xuICAgICAgICB2YXIgZm9ybWF0dGVyID0gbmV3IERhdGVUaW1lRm9ybWF0KHAuZm9ybWF0KTtcbiAgICAgICAgdmFyIGNhbGVuZGFyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogcC5jbGFzc05hbWUsXG4gICAgICAgICAgICBzdHlsZTogcC5zdHlsZSxcbiAgICAgICAgICAgIGxvY2FsZTogQ2FsZW5kYXJMb2NhbGVbcC5sb2NhbGVdLFxuICAgICAgICAgICAgb3JpZW50OiBbJ3RvcCcsICdsZWZ0J10sXG4gICAgICAgICAgICBwcmVmaXhDbHM6ICdrdW1hLWNhbGVuZGFyJ1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcGlja2VyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGRpc2FibGVkOiBwLmRpc2FibGVkLFxuICAgICAgICAgICAgZm9ybWF0dGVyOiBmb3JtYXR0ZXIsXG4gICAgICAgICAgICBhZGp1c3RPcmllbnRPbkNhbGVuZGFyT3ZlcmZsb3c6IGZhbHNlLFxuICAgICAgICAgICAgcHJlZml4Q2xzOiAna3VtYS1jYWxlbmRhci1waWNrZXInLFxuICAgICAgICAgICAgZ2V0Q2FsZW5kYXJDb250YWluZXI6IGdldENhbGVuZGFyQ29udGFpbmVyXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHAudmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGdldEdyZWdvcmlhbkNhbGVuZGFyRGF0ZShwLnZhbHVlLCBwLmxvY2FsZSk7XG4gICAgICAgICAgICBwaWNrZXJPcHRpb25zLnZhbHVlID0gY2FsZW5kYXJPcHRpb25zLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwaWNrZXJPcHRpb25zLnZhbHVlID0gY2FsZW5kYXJPcHRpb25zLnZhbHVlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwLmRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZ2V0R3JlZ29yaWFuQ2FsZW5kYXJEYXRlKHAuZGVmYXVsdFZhbHVlLCBwLmxvY2FsZSk7XG4gICAgICAgICAgICBjYWxlbmRhck9wdGlvbnMuZGVmYXVsdFZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbGVuZGFyID0gUmVhY3QuY3JlYXRlRWxlbWVudChSY1llYXJDYWxlbmRhciwgY2FsZW5kYXJPcHRpb25zKTtcblxuICAgICAgICBmdW5jdGlvbiBfb25DaGFuZ2Uodikge1xuICAgICAgICAgICAgdmFyIGRhdGUgPSB2LmdldFRpbWUoKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGdldEdyZWdvcmlhbkNhbGVuZGFyRGF0ZShkYXRlLCBwLmxvY2FsZSk7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uU2VsZWN0KG5ldyBEYXRlKGRhdGUpLCBmb3JtYXR0ZXIuZm9ybWF0KHZhbHVlKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgIERhdGVwaWNrZXIsXG4gICAgICAgICAgICBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAgY2FsZW5kYXI6IGNhbGVuZGFyLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBfb25DaGFuZ2UuYmluZChtZSlcbiAgICAgICAgICAgIH0sIHBpY2tlck9wdGlvbnMpLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnaW5wdXQnLCB7IGRpc2FibGVkOiBtZS5wcm9wcy5kaXNhYmxlZCwgcGxhY2Vob2xkZXI6IHRoaXMucHJvcHMucGxhY2Vob2xkZXIsIGNsYXNzTmFtZTogJ2t1bWEtY2FsZW5kYXItcGlja2VyLWlucHV0IGt1bWEtaW5wdXQnIH0pXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHJldHVybiBZZWFyQ2FsZW5kYXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblllYXJDYWxlbmRhci5kaXNwbGF5TmFtZSA9ICdZZWFyQ2FsZW5kYXInO1xuWWVhckNhbGVuZGFyLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBmb3JtYXQ6ICd5eXl5JyxcbiAgICBwbGFjZWhvbGRlcjogJ+ivt+mAieaLqeW5tOS7vScsXG4gICAgb25TZWxlY3Q6IGZ1bmN0aW9uIG9uU2VsZWN0KCkge30sXG4gICAgbG9jYWxlOiAnemgtY24nXG59O1xuWWVhckNhbGVuZGFyLnByb3BUeXBlcyA9IHtcbiAgICBmb3JtYXQ6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgcGxhY2Vob2xkZXI6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgb25TZWxlY3Q6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIGxvY2FsZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZ1xufTtcblxuQ2FsZW5kYXIuTW9udGhDYWxlbmRhciA9IE1vbnRoQ2FsZW5kYXI7XG5DYWxlbmRhci5ZZWFyQ2FsZW5kYXIgPSBZZWFyQ2FsZW5kYXI7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FsZW5kYXI7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL2J1aWxkL0NhbGVuZGFyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX0NhbGVuZGFyID0gcmVxdWlyZSgnLi9DYWxlbmRhcicpO1xuXG52YXIgX0NhbGVuZGFyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NhbGVuZGFyKTtcblxudmFyIF9QaWNrZXIgPSByZXF1aXJlKCcuL1BpY2tlcicpO1xuXG52YXIgX1BpY2tlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9QaWNrZXIpO1xuXG52YXIgX01vbnRoQ2FsZW5kYXIgPSByZXF1aXJlKCcuL01vbnRoQ2FsZW5kYXInKTtcblxudmFyIF9Nb250aENhbGVuZGFyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01vbnRoQ2FsZW5kYXIpO1xuXG5fQ2FsZW5kYXIyWydkZWZhdWx0J10uUGlja2VyID0gX1BpY2tlcjJbJ2RlZmF1bHQnXTtcbl9DYWxlbmRhcjJbJ2RlZmF1bHQnXS5Nb250aENhbGVuZGFyID0gX01vbnRoQ2FsZW5kYXIyWydkZWZhdWx0J107XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IF9DYWxlbmRhcjJbJ2RlZmF1bHQnXTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9pbmRleC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX2dyZWdvcmlhbkNhbGVuZGFyRm9ybWF0ID0gcmVxdWlyZSgnZ3JlZ29yaWFuLWNhbGVuZGFyLWZvcm1hdCcpO1xuXG52YXIgX2dyZWdvcmlhbkNhbGVuZGFyRm9ybWF0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dyZWdvcmlhbkNhbGVuZGFyRm9ybWF0KTtcblxudmFyIF9ncmVnb3JpYW5DYWxlbmRhciA9IHJlcXVpcmUoJ2dyZWdvcmlhbi1jYWxlbmRhcicpO1xuXG52YXIgX2dyZWdvcmlhbkNhbGVuZGFyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dyZWdvcmlhbkNhbGVuZGFyKTtcblxudmFyIF9yY1V0aWwgPSByZXF1aXJlKCdyYy11dGlsJyk7XG5cbnZhciBfZGF0ZURhdGVUYWJsZSA9IHJlcXVpcmUoJy4vZGF0ZS9EYXRlVGFibGUnKTtcblxudmFyIF9kYXRlRGF0ZVRhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RhdGVEYXRlVGFibGUpO1xuXG52YXIgX2NhbGVuZGFyQ2FsZW5kYXJIZWFkZXIgPSByZXF1aXJlKCcuL2NhbGVuZGFyL0NhbGVuZGFySGVhZGVyJyk7XG5cbnZhciBfY2FsZW5kYXJDYWxlbmRhckhlYWRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jYWxlbmRhckNhbGVuZGFySGVhZGVyKTtcblxudmFyIF9jYWxlbmRhckNhbGVuZGFyRm9vdGVyID0gcmVxdWlyZSgnLi9jYWxlbmRhci9DYWxlbmRhckZvb3RlcicpO1xuXG52YXIgX2NhbGVuZGFyQ2FsZW5kYXJGb290ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2FsZW5kYXJDYWxlbmRhckZvb3Rlcik7XG5cbnZhciBfbWl4aW5DYWxlbmRhck1peGluID0gcmVxdWlyZSgnLi9taXhpbi9DYWxlbmRhck1peGluJyk7XG5cbnZhciBfbWl4aW5DYWxlbmRhck1peGluMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21peGluQ2FsZW5kYXJNaXhpbik7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiBnb1N0YXJ0TW9udGgoKSB7XG4gIHZhciBuZXh0ID0gdGhpcy5zdGF0ZS52YWx1ZS5jbG9uZSgpO1xuICBuZXh0LnNldERheU9mTW9udGgoMSk7XG4gIHRoaXMuc2V0VmFsdWUobmV4dCk7XG59XG5cbmZ1bmN0aW9uIGdvRW5kTW9udGgoKSB7XG4gIHZhciBuZXh0ID0gdGhpcy5zdGF0ZS52YWx1ZS5jbG9uZSgpO1xuICBuZXh0LnNldERheU9mTW9udGgobmV4dC5nZXRBY3R1YWxNYXhpbXVtKF9ncmVnb3JpYW5DYWxlbmRhcjJbJ2RlZmF1bHQnXS5NT05USCkpO1xuICB0aGlzLnNldFZhbHVlKG5leHQpO1xufVxuXG5mdW5jdGlvbiBnb01vbnRoKGRpcmVjdGlvbikge1xuICB2YXIgbmV4dCA9IHRoaXMuc3RhdGUudmFsdWUuY2xvbmUoKTtcbiAgbmV4dC5hZGRNb250aChkaXJlY3Rpb24pO1xuICB0aGlzLnNldFZhbHVlKG5leHQpO1xufVxuXG5mdW5jdGlvbiBnb1llYXIoZGlyZWN0aW9uKSB7XG4gIHZhciBuZXh0ID0gdGhpcy5zdGF0ZS52YWx1ZS5jbG9uZSgpO1xuICBuZXh0LmFkZFllYXIoZGlyZWN0aW9uKTtcbiAgdGhpcy5zZXRWYWx1ZShuZXh0KTtcbn1cblxuZnVuY3Rpb24gZ29XZWVrKGRpcmVjdGlvbikge1xuICB2YXIgbmV4dCA9IHRoaXMuc3RhdGUudmFsdWUuY2xvbmUoKTtcbiAgbmV4dC5hZGRXZWVrT2ZZZWFyKGRpcmVjdGlvbik7XG4gIHRoaXMuc2V0VmFsdWUobmV4dCk7XG59XG5cbmZ1bmN0aW9uIGdvRGF5KGRpcmVjdGlvbikge1xuICB2YXIgbmV4dCA9IHRoaXMuc3RhdGUudmFsdWUuY2xvbmUoKTtcbiAgbmV4dC5hZGREYXlPZk1vbnRoKGRpcmVjdGlvbik7XG4gIHRoaXMuc2V0VmFsdWUobmV4dCk7XG59XG5cbnZhciBDYWxlbmRhciA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnQ2FsZW5kYXInLFxuXG4gIG1peGluczogW19taXhpbkNhbGVuZGFyTWl4aW4yWydkZWZhdWx0J11dLFxuXG4gIHByb3BUeXBlczoge1xuICAgIHZhbHVlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm9iamVjdCxcbiAgICBkZWZhdWx0VmFsdWU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIGNsYXNzTmFtZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmcsXG4gICAgb3JpZW50OiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmFycmF5T2YoX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5vbmVPZihbJ2xlZnQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbSddKSksXG4gICAgbG9jYWxlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm9iamVjdCxcbiAgICBzaG93V2Vla051bWJlcjogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLFxuICAgIHN0eWxlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm9iamVjdCxcbiAgICBzaG93VG9kYXk6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCxcbiAgICB2aXNpYmxlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmJvb2wsXG4gICAgc2hvd1RpbWU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCxcbiAgICBvblNlbGVjdDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLFxuICAgIG9uT2s6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYyxcbiAgICBwcmVmaXhDbHM6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9uS2V5RG93bjogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLFxuICAgIG9uQ2xlYXI6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNoYW5nZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLFxuICAgIG9uRm9jdXM6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkJsdXI6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuY1xuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzaG93VG9kYXk6IHRydWUsXG4gICAgICBvbkNsZWFyOiBub29wLFxuICAgICAgb25Pazogbm9vcFxuICAgIH07XG4gIH0sXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB0aGlzLmRhdGVGb3JtYXR0ZXIgPSBuZXcgX2dyZWdvcmlhbkNhbGVuZGFyRm9ybWF0MlsnZGVmYXVsdCddKHByb3BzLmxvY2FsZS5kYXRlRm9ybWF0KTtcbiAgICB2YXIgb3JpZW50ID0gcHJvcHMub3JpZW50O1xuICAgIC8vIGJpbmQgbWV0aG9kc1xuICAgIHRoaXMubmV4dE1vbnRoID0gZ29Nb250aC5iaW5kKHRoaXMsIDEpO1xuICAgIHRoaXMucHJldmlvdXNNb250aCA9IGdvTW9udGguYmluZCh0aGlzLCAtMSk7XG4gICAgdGhpcy5uZXh0WWVhciA9IGdvWWVhci5iaW5kKHRoaXMsIDEpO1xuICAgIHRoaXMucHJldmlvdXNZZWFyID0gZ29ZZWFyLmJpbmQodGhpcywgLTEpO1xuICAgIHJldHVybiB7IG9yaWVudDogb3JpZW50IH07XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICBpZiAobmV4dFByb3BzLm9yaWVudCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIG9yaWVudDogbmV4dFByb3BzLm9yaWVudFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChuZXh0UHJvcHMubG9jYWxlICE9PSB0aGlzLnByb3BzLmxvY2FsZSkge1xuICAgICAgdGhpcy5kYXRlRm9ybWF0dGVyID0gbmV3IF9ncmVnb3JpYW5DYWxlbmRhckZvcm1hdDJbJ2RlZmF1bHQnXShuZXh0UHJvcHMubG9jYWxlLmRhdGVGb3JtYXQpO1xuICAgIH1cbiAgfSxcblxuICBvbktleURvd246IGZ1bmN0aW9uIG9uS2V5RG93bihlKSB7XG4gICAgdmFyIGtleUNvZGUgPSBlLmtleUNvZGU7XG4gICAgLy8gbWFjXG4gICAgdmFyIGN0cmxLZXkgPSBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5O1xuICAgIHN3aXRjaCAoa2V5Q29kZSkge1xuICAgICAgY2FzZSBfcmNVdGlsLktleUNvZGUuRE9XTjpcbiAgICAgICAgZ29XZWVrLmNhbGwodGhpcywgMSk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBjYXNlIF9yY1V0aWwuS2V5Q29kZS5VUDpcbiAgICAgICAgZ29XZWVrLmNhbGwodGhpcywgLTEpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgY2FzZSBfcmNVdGlsLktleUNvZGUuTEVGVDpcbiAgICAgICAgaWYgKGN0cmxLZXkpIHtcbiAgICAgICAgICB0aGlzLnByZXZpb3VzWWVhcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdvRGF5LmNhbGwodGhpcywgLTEpO1xuICAgICAgICB9XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBjYXNlIF9yY1V0aWwuS2V5Q29kZS5SSUdIVDpcbiAgICAgICAgaWYgKGN0cmxLZXkpIHtcbiAgICAgICAgICB0aGlzLm5leHRZZWFyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ29EYXkuY2FsbCh0aGlzLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgY2FzZSBfcmNVdGlsLktleUNvZGUuSE9NRTpcbiAgICAgICAgZ29TdGFydE1vbnRoLmNhbGwodGhpcyk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBjYXNlIF9yY1V0aWwuS2V5Q29kZS5FTkQ6XG4gICAgICAgIGdvRW5kTW9udGguY2FsbCh0aGlzKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGNhc2UgX3JjVXRpbC5LZXlDb2RlLlBBR0VfRE9XTjpcbiAgICAgICAgdGhpcy5uZXh0TW9udGgoKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGNhc2UgX3JjVXRpbC5LZXlDb2RlLlBBR0VfVVA6XG4gICAgICAgIHRoaXMucHJldmlvdXNNb250aCgpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgY2FzZSBfcmNVdGlsLktleUNvZGUuRU5URVI6XG4gICAgICAgIHRoaXMub25TZWxlY3QodGhpcy5zdGF0ZS52YWx1ZSk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLnByb3BzLm9uS2V5RG93bihlKTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9LFxuXG4gIG9uQ2xlYXI6IGZ1bmN0aW9uIG9uQ2xlYXIoKSB7XG4gICAgdGhpcy5wcm9wcy5vbkNsZWFyKCk7XG4gIH0sXG5cbiAgb25PazogZnVuY3Rpb24gb25PaygpIHtcbiAgICB0aGlzLnByb3BzLm9uT2sodGhpcy5zdGF0ZS52YWx1ZSk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgbG9jYWxlID0gcHJvcHMubG9jYWxlO1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdmFyIHZhbHVlID0gc3RhdGUudmFsdWU7XG4gICAgdmFyIHByZWZpeENscyA9IHByb3BzLnByZWZpeENscztcbiAgICB2YXIgY2hpbGRyZW4gPSBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICdkaXYnLFxuICAgICAgeyBzdHlsZTogeyBvdXRsaW5lOiAnbm9uZScgfSB9LFxuICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoX2NhbGVuZGFyQ2FsZW5kYXJIZWFkZXIyWydkZWZhdWx0J10sIHtcbiAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgIG9uVmFsdWVDaGFuZ2U6IHRoaXMuc2V0VmFsdWUsXG4gICAgICAgIHByZXZpb3VzWWVhcjogdGhpcy5wcmV2aW91c1llYXIsXG4gICAgICAgIHByZXZpb3VzTW9udGg6IHRoaXMucHJldmlvdXNNb250aCxcbiAgICAgICAgbmV4dE1vbnRoOiB0aGlzLm5leHRNb250aCxcbiAgICAgICAgbmV4dFllYXI6IHRoaXMubmV4dFllYXIsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgcHJlZml4Q2xzOiBwcmVmaXhDbHMgfSksXG4gICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWNhbGVuZGFyLWJvZHknIH0sXG4gICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KF9kYXRlRGF0ZVRhYmxlMlsnZGVmYXVsdCddLCB7XG4gICAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIHByZWZpeENsczogcHJlZml4Q2xzLFxuICAgICAgICAgIGRhdGVSZW5kZXI6IHByb3BzLmRhdGVSZW5kZXIsXG4gICAgICAgICAgb25TZWxlY3Q6IHRoaXMub25TZWxlY3QsXG4gICAgICAgICAgZGlzYWJsZWREYXRlOiBwcm9wcy5kaXNhYmxlZERhdGUsXG4gICAgICAgICAgc2hvd1dlZWtOdW1iZXI6IHByb3BzLnNob3dXZWVrTnVtYmVyLFxuICAgICAgICAgIGRhdGVGb3JtYXR0ZXI6IHRoaXMuZGF0ZUZvcm1hdHRlciB9KVxuICAgICAgKSxcbiAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KF9jYWxlbmRhckNhbGVuZGFyRm9vdGVyMlsnZGVmYXVsdCddLCB7XG4gICAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgICBzaG93Q2xlYXI6IHByb3BzLnNob3dDbGVhcixcbiAgICAgICAgc2hvd09rOiBwcm9wcy5zaG93T2ssXG4gICAgICAgIHByZWZpeENsczogcHJlZml4Q2xzLFxuICAgICAgICBzaG93VG9kYXk6IHByb3BzLnNob3dUb2RheSxcbiAgICAgICAgc2hvd1RpbWU6IHByb3BzLnNob3dUaW1lLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGRpc2FibGVkRGF0ZTogcHJvcHMuZGlzYWJsZWREYXRlLFxuICAgICAgICBkYXRlRm9ybWF0dGVyOiB0aGlzLmRhdGVGb3JtYXR0ZXIsXG4gICAgICAgIG9uQ2xlYXI6IHRoaXMub25DbGVhcixcbiAgICAgICAgb25PazogdGhpcy5vbk9rLFxuICAgICAgICBvblNlbGVjdDogdGhpcy5vblNlbGVjdCxcbiAgICAgICAgb25Ub2RheTogdGhpcy5jaG9vc2VUb2RheVxuICAgICAgfSlcbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXMucmVuZGVyUm9vdCh7XG4gICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICBjbGFzc05hbWU6IHByb3BzLnNob3dXZWVrTnVtYmVyID8gcHJlZml4Q2xzICsgJy13ZWVrLW51bWJlcicgOiAnJ1xuICAgIH0pO1xuICB9LFxuXG4gIGNob29zZVRvZGF5OiBmdW5jdGlvbiBjaG9vc2VUb2RheSgpIHtcbiAgICB2YXIgdG9kYXkgPSB0aGlzLnN0YXRlLnZhbHVlLmNsb25lKCk7XG4gICAgdG9kYXkuc2V0VGltZShEYXRlLm5vdygpKTtcbiAgICB0aGlzLm9uU2VsZWN0KHRvZGF5KTtcbiAgfVxufSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IENhbGVuZGFyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL0NhbGVuZGFyLmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9ncmVnb3JpYW4tY2FsZW5kYXItZm9ybWF0Jyk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL34vZ3JlZ29yaWFuLWNhbGVuZGFyLWZvcm1hdC9pbmRleC5qc1xuICoqLyIsIi8qKlxuICogQGlnbm9yZVxuICogRGF0ZVRpbWVGb3JtYXQgZm9yXG4gKiBJbnNwaXJlZCBieSBEYXRlVGltZUZvcm1hdCBmcm9tIEpESy5cbiAqIEBhdXRob3IgeWltaW5naGVAZ21haWwuY29tXG4gKi9cblxudmFyIEdyZWdvcmlhbkNhbGVuZGFyID0gcmVxdWlyZSgnZ3JlZ29yaWFuLWNhbGVuZGFyJyk7XG52YXIgZW5Vc0xvY2FsZSA9IHJlcXVpcmUoJy4vbG9jYWxlL2VuLXVzJyk7XG52YXIgTUFYX1ZBTFVFID0gTnVtYmVyLk1BWF9WQUxVRTtcbi8qKlxuICogZGF0ZSBvciB0aW1lIHN0eWxlIGVudW1cbiAqIEBlbnVtIHtOdW1iZXJ9IERhdGUuRm9ybWF0dGVyLlN0eWxlXG4gKi9cbnZhciBEYXRlVGltZVN0eWxlID0ge1xuICAvKipcbiAgICogZnVsbCBzdHlsZVxuICAgKi9cbiAgRlVMTDogMCxcbiAgLyoqXG4gICAqIGxvbmcgc3R5bGVcbiAgICovXG4gIExPTkc6IDEsXG4gIC8qKlxuICAgKiBtZWRpdW0gc3R5bGVcbiAgICovXG4gIE1FRElVTTogMixcbiAgLyoqXG4gICAqIHNob3J0IHN0eWxlXG4gICAqL1xuICBTSE9SVDogM1xufTtcblxuLypcbiBMZXR0ZXIgICAgRGF0ZSBvciBUaW1lIENvbXBvbmVudCAgICBQcmVzZW50YXRpb24gICAgRXhhbXBsZXNcbiBHICAgIEVyYSBkZXNpZ25hdG9yICAgIFRleHQgICAgQURcbiB5ICAgIFllYXIgICAgWWVhciAgICAxOTk2OyA5NlxuIE0gICAgTW9udGggaW4geWVhciAgICBNb250aCAgICBKdWx5OyBKdWw7IDA3XG4gdyAgICBXZWVrIGluIHllYXIgICAgTnVtYmVyICAgIDI3XG4gVyAgICBXZWVrIGluIG1vbnRoICAgIE51bWJlciAgICAyXG4gRCAgICBEYXkgaW4geWVhciAgICBOdW1iZXIgICAgMTg5XG4gZCAgICBEYXkgaW4gbW9udGggICAgTnVtYmVyICAgIDEwXG4gRiAgICBEYXkgb2Ygd2VlayBpbiBtb250aCAgICBOdW1iZXIgICAgMlxuIEUgICAgRGF5IGluIHdlZWsgICAgVGV4dCAgICBUdWVzZGF5OyBUdWVcbiBhICAgIEFtL3BtIG1hcmtlciAgICBUZXh0ICAgIFBNXG4gSCAgICBIb3VyIGluIGRheSAoMC0yMykgICAgTnVtYmVyICAgIDBcbiBrICAgIEhvdXIgaW4gZGF5ICgxLTI0KSAgICBOdW1iZXIgICAgMjRcbiBLICAgIEhvdXIgaW4gYW0vcG0gKDAtMTEpICAgIE51bWJlciAgICAwXG4gaCAgICBIb3VyIGluIGFtL3BtICgxLTEyKSAgICBOdW1iZXIgICAgMTJcbiBtICAgIE1pbnV0ZSBpbiBob3VyICAgIE51bWJlciAgICAzMFxuIHMgICAgU2Vjb25kIGluIG1pbnV0ZSAgICBOdW1iZXIgICAgNTVcbiBTICAgIE1pbGxpc2Vjb25kICAgIE51bWJlciAgICA5NzhcbiB4IHogICAgVGltZSB6b25lICAgIEdlbmVyYWwgdGltZSB6b25lICAgIFBhY2lmaWMgU3RhbmRhcmQgVGltZTsgUFNUOyBHTVQtMDg6MDBcbiBaICAgIFRpbWUgem9uZSAgICBSRkMgODIyIHRpbWUgem9uZSAgICAtMDgwMFxuICovXG5cbnZhciBwYXR0ZXJuQ2hhcnMgPSBuZXcgQXJyYXkoR3JlZ29yaWFuQ2FsZW5kYXIuREFZX09GX1dFRUtfSU5fTU9OVEggKyAyKS5qb2luKCcxJyk7XG52YXIgRVJBID0gMDtcbnZhciBjYWxlbmRhckluZGV4TWFwID0ge307XG5cbnBhdHRlcm5DaGFycyA9IHBhdHRlcm5DaGFycy5zcGxpdCgnJyk7XG5wYXR0ZXJuQ2hhcnNbRVJBXSA9ICdHJztcbnBhdHRlcm5DaGFyc1tHcmVnb3JpYW5DYWxlbmRhci5ZRUFSXSA9ICd5JztcbnBhdHRlcm5DaGFyc1tHcmVnb3JpYW5DYWxlbmRhci5NT05USF0gPSAnTSc7XG5wYXR0ZXJuQ2hhcnNbR3JlZ29yaWFuQ2FsZW5kYXIuREFZX09GX01PTlRIXSA9ICdkJztcbnBhdHRlcm5DaGFyc1tHcmVnb3JpYW5DYWxlbmRhci5IT1VSX09GX0RBWV0gPSAnSCc7XG5wYXR0ZXJuQ2hhcnNbR3JlZ29yaWFuQ2FsZW5kYXIuTUlOVVRFU10gPSAnbSc7XG5wYXR0ZXJuQ2hhcnNbR3JlZ29yaWFuQ2FsZW5kYXIuU0VDT05EU10gPSAncyc7XG5wYXR0ZXJuQ2hhcnNbR3JlZ29yaWFuQ2FsZW5kYXIuTUlMTElTRUNPTkRTXSA9ICdTJztcbnBhdHRlcm5DaGFyc1tHcmVnb3JpYW5DYWxlbmRhci5XRUVLX09GX1lFQVJdID0gJ3cnO1xucGF0dGVybkNoYXJzW0dyZWdvcmlhbkNhbGVuZGFyLldFRUtfT0ZfTU9OVEhdID0gJ1cnO1xucGF0dGVybkNoYXJzW0dyZWdvcmlhbkNhbGVuZGFyLkRBWV9PRl9ZRUFSXSA9ICdEJztcbnBhdHRlcm5DaGFyc1tHcmVnb3JpYW5DYWxlbmRhci5EQVlfT0ZfV0VFS19JTl9NT05USF0gPSAnRic7XG5cbihmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGluZGV4IGluIHBhdHRlcm5DaGFycykge1xuICAgIGNhbGVuZGFySW5kZXhNYXBbcGF0dGVybkNoYXJzW2luZGV4XV0gPSBpbmRleDtcbiAgfVxufSkoKTtcblxuZnVuY3Rpb24gbWl4KHQsIHMpIHtcbiAgZm9yICh2YXIgcCBpbiBzKSB7XG4gICAgdFtwXSA9IHNbcF07XG4gIH1cbn1cblxudmFyIFNVQlNUSVRVVEVfUkVHID0gL1xcXFw/XFx7KFtee31dKylcXH0vZztcbnZhciBFTVBUWSA9ICcnO1xuXG5mdW5jdGlvbiBzdWJzdGl0dXRlKHN0ciwgbywgcmVnZXhwKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJyB8fCAhbykge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICByZXR1cm4gc3RyLnJlcGxhY2UocmVnZXhwIHx8IFNVQlNUSVRVVEVfUkVHLCBmdW5jdGlvbiAobWF0Y2gsIG5hbWUpIHtcbiAgICBpZiAobWF0Y2guY2hhckF0KDApID09PSAnXFxcXCcpIHtcbiAgICAgIHJldHVybiBtYXRjaC5zbGljZSgxKTtcbiAgICB9XG4gICAgcmV0dXJuIChvW25hbWVdID09PSB1bmRlZmluZWQpID8gRU1QVFkgOiBvW25hbWVdO1xuICB9KTtcbn1cblxucGF0dGVybkNoYXJzID0gcGF0dGVybkNoYXJzLmpvaW4oJycpICsgJ2Foa0taRSc7XG5cbmZ1bmN0aW9uIGVuY29kZShsYXN0RmllbGQsIGNvdW50LCBjb21waWxlZFBhdHRlcm4pIHtcbiAgY29tcGlsZWRQYXR0ZXJuLnB1c2goe1xuICAgIGZpZWxkOiBsYXN0RmllbGQsXG4gICAgY291bnQ6IGNvdW50XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjb21waWxlKHBhdHRlcm4pIHtcbiAgdmFyIGxlbmd0aCA9IHBhdHRlcm4ubGVuZ3RoO1xuICB2YXIgaW5RdW90ZSA9IGZhbHNlO1xuICB2YXIgY29tcGlsZWRQYXR0ZXJuID0gW107XG4gIHZhciB0bXBCdWZmZXIgPSBudWxsO1xuICB2YXIgY291bnQgPSAwO1xuICB2YXIgbGFzdEZpZWxkID0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBjID0gcGF0dGVybi5jaGFyQXQoaSk7XG5cbiAgICBpZiAoYyA9PT0gJ1xcJycpIHtcbiAgICAgIC8vICcnIGlzIHRyZWF0ZWQgYXMgYSBzaW5nbGUgcXVvdGUgcmVnYXJkbGVzcyBvZiBiZWluZ1xuICAgICAgLy8gaW4gYSBxdW90ZWQgc2VjdGlvbi5cbiAgICAgIGlmICgoaSArIDEpIDwgbGVuZ3RoKSB7XG4gICAgICAgIGMgPSBwYXR0ZXJuLmNoYXJBdChpICsgMSk7XG4gICAgICAgIGlmIChjID09PSAnXFwnJykge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgICBpZiAoY291bnQgIT09IDApIHtcbiAgICAgICAgICAgIGVuY29kZShsYXN0RmllbGQsIGNvdW50LCBjb21waWxlZFBhdHRlcm4pO1xuICAgICAgICAgICAgbGFzdEZpZWxkID0gLTE7XG4gICAgICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpblF1b3RlKSB7XG4gICAgICAgICAgICB0bXBCdWZmZXIgKz0gYztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaW5RdW90ZSkge1xuICAgICAgICBpZiAoY291bnQgIT09IDApIHtcbiAgICAgICAgICBlbmNvZGUobGFzdEZpZWxkLCBjb3VudCwgY29tcGlsZWRQYXR0ZXJuKTtcbiAgICAgICAgICBsYXN0RmllbGQgPSAtMTtcbiAgICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdG1wQnVmZmVyID0gJyc7XG4gICAgICAgIGluUXVvdGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcGlsZWRQYXR0ZXJuLnB1c2goe1xuICAgICAgICAgIHRleHQ6IHRtcEJ1ZmZlclxuICAgICAgICB9KTtcbiAgICAgICAgaW5RdW90ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChpblF1b3RlKSB7XG4gICAgICB0bXBCdWZmZXIgKz0gYztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoIShjID49ICdhJyAmJiBjIDw9ICd6JyB8fCBjID49ICdBJyAmJiBjIDw9ICdaJykpIHtcbiAgICAgIGlmIChjb3VudCAhPT0gMCkge1xuICAgICAgICBlbmNvZGUobGFzdEZpZWxkLCBjb3VudCwgY29tcGlsZWRQYXR0ZXJuKTtcbiAgICAgICAgbGFzdEZpZWxkID0gLTE7XG4gICAgICAgIGNvdW50ID0gMDtcbiAgICAgIH1cbiAgICAgIGNvbXBpbGVkUGF0dGVybi5wdXNoKHtcbiAgICAgICAgdGV4dDogY1xuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAocGF0dGVybkNoYXJzLmluZGV4T2YoYykgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgcGF0dGVybiBjaGFyYWN0ZXIgXCInICsgYyArICdcIicpO1xuICAgIH1cblxuICAgIGlmIChsYXN0RmllbGQgPT09IC0xIHx8IGxhc3RGaWVsZCA9PT0gYykge1xuICAgICAgbGFzdEZpZWxkID0gYztcbiAgICAgIGNvdW50Kys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZW5jb2RlKGxhc3RGaWVsZCwgY291bnQsIGNvbXBpbGVkUGF0dGVybik7XG4gICAgbGFzdEZpZWxkID0gYztcbiAgICBjb3VudCA9IDE7XG4gIH1cblxuICBpZiAoaW5RdW90ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW50ZXJtaW5hdGVkIHF1b3RlJyk7XG4gIH1cblxuICBpZiAoY291bnQgIT09IDApIHtcbiAgICBlbmNvZGUobGFzdEZpZWxkLCBjb3VudCwgY29tcGlsZWRQYXR0ZXJuKTtcbiAgfVxuXG4gIHJldHVybiBjb21waWxlZFBhdHRlcm47XG59XG5cbnZhciB6ZXJvRGlnaXQgPSAnMCc7XG5cbi8vIFRPRE8gemVyb0RpZ2l0IGxvY2FsaXphdGlvbj8/XG5mdW5jdGlvbiB6ZXJvUGFkZGluZ051bWJlcih2YWx1ZSwgbWluRGlnaXRzLCBtYXhEaWdpdHMsIGJ1ZmZlcikge1xuICAvLyBPcHRpbWl6YXRpb24gZm9yIDEsIDIgYW5kIDQgZGlnaXQgbnVtYmVycy4gVGhpcyBzaG91bGRcbiAgLy8gY292ZXIgbW9zdCBjYXNlcyBvZiBmb3JtYXR0aW5nIGRhdGUvdGltZSByZWxhdGVkIGl0ZW1zLlxuICAvLyBOb3RlOiBUaGlzIG9wdGltaXphdGlvbiBjb2RlIGFzc3VtZXMgdGhhdCBtYXhEaWdpdHMgaXNcbiAgLy8gZWl0aGVyIDIgb3IgSW50ZWdlci5NQVhfVkFMVUUgKG1heEludENvdW50IGluIGZvcm1hdCgpKS5cbiAgYnVmZmVyID0gYnVmZmVyIHx8IFtdO1xuICBtYXhEaWdpdHMgPSBtYXhEaWdpdHMgfHwgTUFYX1ZBTFVFO1xuICBpZiAodmFsdWUgPj0gMCkge1xuICAgIGlmICh2YWx1ZSA8IDEwMCAmJiBtaW5EaWdpdHMgPj0gMSAmJiBtaW5EaWdpdHMgPD0gMikge1xuICAgICAgaWYgKHZhbHVlIDwgMTAgJiYgbWluRGlnaXRzID09PSAyKSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKHplcm9EaWdpdCk7XG4gICAgICB9XG4gICAgICBidWZmZXIucHVzaCh2YWx1ZSk7XG4gICAgICByZXR1cm4gYnVmZmVyLmpvaW4oJycpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPj0gMTAwMCAmJiB2YWx1ZSA8IDEwMDAwKSB7XG4gICAgICBpZiAobWluRGlnaXRzID09PSA0KSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlci5qb2luKCcnKTtcbiAgICAgIH1cbiAgICAgIGlmIChtaW5EaWdpdHMgPT09IDIgJiYgbWF4RGlnaXRzID09PSAyKSB7XG4gICAgICAgIHJldHVybiB6ZXJvUGFkZGluZ051bWJlcih2YWx1ZSAlIDEwMCwgMiwgMiwgYnVmZmVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYnVmZmVyLnB1c2godmFsdWUgKyAnJyk7XG4gIHJldHVybiBidWZmZXIuam9pbignJyk7XG59XG5cbi8qKlxuICpcbiAqIGRhdGUgdGltZSBmb3JtYXR0ZXIgZm9yIEdyZWdvcmlhbkNhbGVuZGFyXG4gKlxuICogICAgICBAZXhhbXBsZVxuICpcbiAqICAgICAgICAgIHZhciBjYWxlbmRhciA9IG5ldyBHcmVnb3JpYW5DYWxlbmRhcigyMDEzLDksMjQpO1xuICogICAgICAgICAgLy8gJyB0byBlc2NhcGVcbiAqICAgICAgICAgIHZhciBmb3JtYXR0ZXIgPSBuZXcgR3JlZ29yaWFuQ2FsZW5kYXJGb3JtYXQoXCIndG9kYXkgaXMnICcneXl5eS9NTS9kZCBhJydcIik7XG4gKiAgICAgICAgICBkb2N1bWVudC53cml0ZShmb3JtYXR0ZXIuZm9ybWF0KGNhbGVuZGFyKSk7XG4gKlxuICogQGNsYXNzIEdyZWdvcmlhbkNhbGVuZGFyRm9ybWF0XG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0dGVybiBwYXR0ZXIgc3RyaW5nIG9mIGRhdGUgZm9ybWF0dGVyXG4gKlxuICogPHRhYmxlIGJvcmRlcj1cIjFcIj5cbiAqIDx0aGVhZCB2YWxpZ249XCJib3R0b21cIj5cbiAqIDx0cj48dGggY2xhc3M9XCJoZWFkXCI+TGV0dGVyPC90aD5cbiAqIDx0aCBjbGFzcz1cImhlYWRcIj5EYXRlIG9yIFRpbWUgQ29tcG9uZW50PC90aD5cbiAqIDx0aCBjbGFzcz1cImhlYWRcIj5QcmVzZW50YXRpb248L3RoPlxuICogPHRoIGNsYXNzPVwiaGVhZFwiPkV4YW1wbGVzPC90aD5cbiAqIDwvdHI+XG4gKiA8L3RoZWFkPlxuICogPHRib2R5IHZhbGlnbj1cInRvcFwiPlxuICogPHRyPjx0ZD5HPC90ZD5cbiAqIDx0ZD5FcmEgZGVzaWduYXRvcjwvdGQ+XG4gKiA8dGQ+VGV4dDwvdGQ+XG4gKiA8dGQ+QUQ8L3RkPlxuICogPC90cj5cbiAqIDx0cj48dGQ+eTwvdGQ+XG4gKiA8dGQ+WWVhcjwvdGQ+XG4gKiA8dGQ+WWVhcjwvdGQ+XG4gKiA8dGQ+MTk5NjsgOTY8L3RkPlxuICogPC90cj5cbiAqIDx0cj48dGQ+TTwvdGQ+XG4gKiA8dGQ+TW9udGggaW4geWVhcjwvdGQ+XG4gKiA8dGQ+TW9udGg8L3RkPlxuICogPHRkPkp1bHk7IEp1bDsgMDc8L3RkPlxuICogPC90cj5cbiAqIDx0cj48dGQ+dzwvdGQ+XG4gKiA8dGQ+V2VlayBpbiB5ZWFyPC90ZD5cbiAqIDx0ZD5OdW1iZXI8L3RkPlxuICogPHRkPjI3PC90ZD5cbiAqIDwvdHI+XG4gKiA8dHI+PHRkPlc8L3RkPlxuICogPHRkPldlZWsgaW4gbW9udGg8L3RkPlxuICogPHRkPk51bWJlcjwvdGQ+XG4gKiA8dGQ+MjwvdGQ+XG4gKiA8L3RyPlxuICogPHRyPjx0ZD5EPC90ZD5cbiAqIDx0ZD5EYXkgaW4geWVhcjwvdGQ+XG4gKiA8dGQ+TnVtYmVyPC90ZD5cbiAqIDx0ZD4xODk8L3RkPlxuICogPC90cj5cbiAqIDx0cj48dGQ+ZDwvdGQ+XG4gKiA8dGQ+RGF5IGluIG1vbnRoPC90ZD5cbiAqIDx0ZD5OdW1iZXI8L3RkPlxuICogPHRkPjEwPC90ZD5cbiAqIDwvdHI+XG4gKiA8dHI+PHRkPkY8L3RkPlxuICogPHRkPkRheSBvZiB3ZWVrIGluIG1vbnRoPC90ZD5cbiAqIDx0ZD5OdW1iZXI8L3RkPlxuICogPHRkPjI8L3RkPlxuICogPC90cj5cbiAqIDx0cj48dGQ+RTwvdGQ+XG4gKiA8dGQ+RGF5IGluIHdlZWs8L3RkPlxuICogPHRkPlRleHQ8L3RkPlxuICogPHRkPlR1ZXNkYXk7IFR1ZTwvdGQ+XG4gKiA8L3RyPlxuICogPHRyPjx0ZD5hPC90ZD5cbiAqIDx0ZD5BbS9wbSBtYXJrZXI8L3RkPlxuICogPHRkPlRleHQ8L3RkPlxuICogPHRkPlBNPC90ZD5cbiAqIDwvdHI+XG4gKiA8dHI+PHRkPkg8L3RkPlxuICogICAgICAgPHRkPkhvdXIgaW4gZGF5ICgwLTIzKTwvdGQ+XG4gKiA8dGQ+TnVtYmVyPC90ZD5cbiAqIDx0ZD4wPC90ZD5cbiAqIDwvdHI+XG4gKiA8dHI+PHRkPms8L3RkPlxuICogICAgICAgPHRkPkhvdXIgaW4gZGF5ICgxLTI0KTwvdGQ+XG4gKiA8dGQ+TnVtYmVyPC90ZD5cbiAqIDx0ZD4yNDwvdGQ+XG4gKiA8L3RyPlxuICogPHRyPjx0ZD5LPC90ZD5cbiAqIDx0ZD5Ib3VyIGluIGFtL3BtICgwLTExKTwvdGQ+XG4gKiA8dGQ+TnVtYmVyPC90ZD5cbiAqIDx0ZD4wPC90ZD5cbiAqIDwvdHI+XG4gKiA8dHI+PHRkPmg8L3RkPlxuICogPHRkPkhvdXIgaW4gYW0vcG0gKDEtMTIpPC90ZD5cbiAqIDx0ZD5OdW1iZXI8L3RkPlxuICogPHRkPjEyPC90ZD5cbiAqIDwvdHI+XG4gKiA8dHI+PHRkPm08L3RkPlxuICogPHRkPk1pbnV0ZSBpbiBob3VyPC90ZD5cbiAqIDx0ZD5OdW1iZXI8L3RkPlxuICogPHRkPjMwPC90ZD5cbiAqIDwvdHI+XG4gKiA8dHI+PHRkPnM8L3RkPlxuICogPHRkPlNlY29uZCBpbiBtaW51dGU8L3RkPlxuICogPHRkPk51bWJlcjwvdGQ+XG4gKiA8dGQ+NTU8L3RkPlxuICogPC90cj5cbiAqIDx0cj48dGQ+UzwvdGQ+XG4gKiA8dGQ+TWlsbGlzZWNvbmQ8L3RkPlxuICogPHRkPk51bWJlcjwvdGQ+XG4gKiA8dGQ+OTc4PC90ZD5cbiAqIDwvdHI+XG4gKiA8dHI+PHRkPngvejwvdGQ+XG4gKiA8dGQ+VGltZSB6b25lPC90ZD5cbiAqIDx0ZD5HZW5lcmFsIHRpbWUgem9uZTwvdGQ+XG4gKiA8dGQ+UGFjaWZpYyBTdGFuZGFyZCBUaW1lOyBQU1Q7IEdNVC0wODowMDwvdGQ+XG4gKiA8L3RyPlxuICogPHRyPjx0ZD5aPC90ZD5cbiAqIDx0ZD5UaW1lIHpvbmU8L3RkPlxuICogPHRkPlJGQyA4MjIgdGltZSB6b25lPC90ZD5cbiAqIDx0ZD4tMDgwMDwvdGQ+XG4gKiA8L3RyPlxuICogPC90Ym9keT5cbiAqIDwvdGFibGU+XG5cbiAqIEBwYXJhbSB7T2JqZWN0fSBsb2NhbGUgZm9ybWF0IGxvY2FsZVxuICovXG5mdW5jdGlvbiBEYXRlVGltZUZvcm1hdChwYXR0ZXJuLCBsb2NhbGUpIHtcbiAgdGhpcy5sb2NhbGUgPSBsb2NhbGUgfHwgZW5Vc0xvY2FsZTtcbiAgdGhpcy5vcmlnaW5hbFBhdHRlcm4gPSBwYXR0ZXJuO1xuICB0aGlzLnBhdHRlcm4gPSBjb21waWxlKHBhdHRlcm4pO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRGaWVsZChmaWVsZCwgY291bnQsIGxvY2FsZSwgY2FsZW5kYXIpIHtcbiAgdmFyIGN1cnJlbnQsXG4gICAgdmFsdWU7XG4gIHN3aXRjaCAoZmllbGQpIHtcbiAgICBjYXNlICdHJzpcbiAgICAgIHZhbHVlID0gY2FsZW5kYXIuZ2V0WWVhcigpID4gMCA/IDEgOiAwO1xuICAgICAgY3VycmVudCA9IGxvY2FsZS5lcmFzW3ZhbHVlXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3knOlxuICAgICAgdmFsdWUgPSBjYWxlbmRhci5nZXRZZWFyKCk7XG4gICAgICBpZiAodmFsdWUgPD0gMCkge1xuICAgICAgICB2YWx1ZSA9IDEgLSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSAoemVyb1BhZGRpbmdOdW1iZXIodmFsdWUsIDIsIGNvdW50ICE9PSAyID8gTUFYX1ZBTFVFIDogMikpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnTSc6XG4gICAgICB2YWx1ZSA9IGNhbGVuZGFyLmdldE1vbnRoKCk7XG4gICAgICBpZiAoY291bnQgPj0gNCkge1xuICAgICAgICBjdXJyZW50ID0gbG9jYWxlLm1vbnRoc1t2YWx1ZV07XG4gICAgICB9IGVsc2UgaWYgKGNvdW50ID09PSAzKSB7XG4gICAgICAgIGN1cnJlbnQgPSBsb2NhbGUuc2hvcnRNb250aHNbdmFsdWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudCA9IHplcm9QYWRkaW5nTnVtYmVyKHZhbHVlICsgMSwgY291bnQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnayc6XG4gICAgICBjdXJyZW50ID0gemVyb1BhZGRpbmdOdW1iZXIoY2FsZW5kYXIuZ2V0SG91ck9mRGF5KCkgfHwgMjQsXG4gICAgICAgIGNvdW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0UnOlxuICAgICAgdmFsdWUgPSBjYWxlbmRhci5nZXREYXlPZldlZWsoKTtcbiAgICAgIGN1cnJlbnQgPSBjb3VudCA+PSA0ID9cbiAgICAgICAgbG9jYWxlLndlZWtkYXlzW3ZhbHVlXSA6XG4gICAgICAgIGxvY2FsZS5zaG9ydFdlZWtkYXlzW3ZhbHVlXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2EnOlxuICAgICAgY3VycmVudCA9IGxvY2FsZS5hbXBtc1tjYWxlbmRhci5nZXRIb3VyT2ZEYXkoKSA+PSAxMiA/XG4gICAgICAgIDEgOlxuICAgICAgICAwXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2gnOlxuICAgICAgY3VycmVudCA9IHplcm9QYWRkaW5nTnVtYmVyKGNhbGVuZGFyLlxuICAgICAgICBnZXRIb3VyT2ZEYXkoKSAlIDEyIHx8IDEyLCBjb3VudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdLJzpcbiAgICAgIGN1cnJlbnQgPSB6ZXJvUGFkZGluZ051bWJlcihjYWxlbmRhci5cbiAgICAgICAgZ2V0SG91ck9mRGF5KCkgJSAxMiwgY291bnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnWic6XG4gICAgICB2YXIgb2Zmc2V0ID0gY2FsZW5kYXIuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgIHZhciBwYXJ0cyA9IFtvZmZzZXQgPCAwID8gJy0nIDogJysnXTtcbiAgICAgIG9mZnNldCA9IE1hdGguYWJzKG9mZnNldCk7XG4gICAgICBwYXJ0cy5wdXNoKHplcm9QYWRkaW5nTnVtYmVyKE1hdGguZmxvb3Iob2Zmc2V0IC8gNjApICUgMTAwLCAyKSxcbiAgICAgICAgemVyb1BhZGRpbmdOdW1iZXIob2Zmc2V0ICUgNjAsIDIpKTtcbiAgICAgIGN1cnJlbnQgPSBwYXJ0cy5qb2luKCcnKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQgOlxuICAgICAgLy8gY2FzZSAnZCc6XG4gICAgICAvLyBjYXNlICdIJzpcbiAgICAgIC8vIGNhc2UgJ20nOlxuICAgICAgLy8gY2FzZSAncyc6XG4gICAgICAvLyBjYXNlICdTJzpcbiAgICAgIC8vIGNhc2UgJ0QnOlxuICAgICAgLy8gY2FzZSAnRic6XG4gICAgICAvLyBjYXNlICd3JzpcbiAgICAgIC8vIGNhc2UgJ1cnOlxuICAgICAgdmFyIGluZGV4ID0gY2FsZW5kYXJJbmRleE1hcFtmaWVsZF07XG4gICAgICB2YWx1ZSA9IGNhbGVuZGFyLmdldChpbmRleCk7XG4gICAgICBjdXJyZW50ID0gemVyb1BhZGRpbmdOdW1iZXIodmFsdWUsIGNvdW50KTtcbiAgfVxuICByZXR1cm4gY3VycmVudDtcbn1cblxuZnVuY3Rpb24gbWF0Y2hGaWVsZChkYXRlU3RyLCBzdGFydEluZGV4LCBtYXRjaGVzKSB7XG4gIHZhciBtYXRjaGVkTGVuID0gLTE7XG4gIHZhciBpbmRleCA9IC0xO1xuICB2YXIgaTtcbiAgdmFyIGxlbiA9IG1hdGNoZXMubGVuZ3RoO1xuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgbSA9IG1hdGNoZXNbaV07XG4gICAgdmFyIG1MZW4gPSBtLmxlbmd0aDtcbiAgICBpZiAobUxlbiA+IG1hdGNoZWRMZW4gJiZcbiAgICAgIG1hdGNoUGFydFN0cmluZyhkYXRlU3RyLCBzdGFydEluZGV4LCBtLCBtTGVuKSkge1xuICAgICAgbWF0Y2hlZExlbiA9IG1MZW47XG4gICAgICBpbmRleCA9IGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmRleCA+PSAwID8ge1xuICAgIHZhbHVlOiBpbmRleCxcbiAgICBzdGFydEluZGV4OiBzdGFydEluZGV4ICsgbWF0Y2hlZExlblxuICB9IDogbnVsbDtcbn1cblxuZnVuY3Rpb24gbWF0Y2hQYXJ0U3RyaW5nKGRhdGVTdHIsIHN0YXJ0SW5kZXgsIG1hdGNoLCBtTGVuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbUxlbjsgaSsrKSB7XG4gICAgaWYgKGRhdGVTdHIuY2hhckF0KHN0YXJ0SW5kZXggKyBpKSAhPT0gbWF0Y2guY2hhckF0KGkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXRMZWFkaW5nTnVtYmVyTGVuKHN0cikge1xuICB2YXIgaSwgYztcbiAgdmFyIGxlbiA9IHN0ci5sZW5ndGg7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGMgPSBzdHIuY2hhckF0KGkpO1xuICAgIGlmIChjIDwgJzAnIHx8IGMgPiAnOScpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hOdW1iZXIoZGF0ZVN0ciwgc3RhcnRJbmRleCwgY291bnQsIG9iZXlDb3VudCkge1xuICB2YXIgc3RyID0gZGF0ZVN0cjtcbiAgdmFyIG47XG4gIGlmIChvYmV5Q291bnQpIHtcbiAgICBpZiAoZGF0ZVN0ci5sZW5ndGggPD0gc3RhcnRJbmRleCArIGNvdW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3RyID0gZGF0ZVN0ci5zbGljZShzdGFydEluZGV4LCBzdGFydEluZGV4ICsgY291bnQpO1xuICAgIGlmICghc3RyLm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdHcmVnb3JpYW5DYWxlbmRhckZvcm1hdCBwYXJzZSBlcnJvciwgZGF0ZVN0cjogJyArIGRhdGVTdHIgKyAnLCBwYXR0ZXI6ICcgKyAodGhpcy5vcmlnaW5hbFBhdHRlcm4pKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3RyID0gc3RyLnNsaWNlKHN0YXJ0SW5kZXgpO1xuICB9XG4gIG4gPSBwYXJzZUludChzdHIsIDEwKTtcbiAgaWYgKGlzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdHcmVnb3JpYW5DYWxlbmRhckZvcm1hdCBwYXJzZSBlcnJvciwgZGF0ZVN0cjogJyArIGRhdGVTdHIgKyAnLCBwYXR0ZXI6ICcgKyAodGhpcy5vcmlnaW5hbFBhdHRlcm4pKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbHVlOiBuLFxuICAgIHN0YXJ0SW5kZXg6IHN0YXJ0SW5kZXggKyBnZXRMZWFkaW5nTnVtYmVyTGVuKHN0cilcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VGaWVsZChjYWxlbmRhciwgZGF0ZVN0ciwgc3RhcnRJbmRleCwgZmllbGQsIGNvdW50LCBvYmV5Q291bnQsIHRtcCkge1xuICB2YXIgbWF0Y2gsIHllYXIsIGhvdXI7XG4gIGlmIChkYXRlU3RyLmxlbmd0aCA8PSBzdGFydEluZGV4KSB7XG4gICAgcmV0dXJuIHN0YXJ0SW5kZXg7XG4gIH1cbiAgdmFyIGxvY2FsZSA9IHRoaXMubG9jYWxlO1xuICBzd2l0Y2ggKGZpZWxkKSB7XG4gICAgY2FzZSAnRyc6XG4gICAgICBpZiAoKG1hdGNoID0gbWF0Y2hGaWVsZChkYXRlU3RyLCBzdGFydEluZGV4LCBsb2NhbGUuZXJhcykpKSB7XG4gICAgICAgIGlmIChjYWxlbmRhci5pc1NldFllYXIoKSkge1xuICAgICAgICAgIGlmIChtYXRjaC52YWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgeWVhciA9IGNhbGVuZGFyLmdldFllYXIoKTtcbiAgICAgICAgICAgIGNhbGVuZGFyLnNldFllYXIoMSAtIHllYXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0bXAuZXJhID0gbWF0Y2gudmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3knOlxuICAgICAgaWYgKChtYXRjaCA9IG1hdGNoTnVtYmVyLmNhbGwodGhpcywgZGF0ZVN0ciwgc3RhcnRJbmRleCwgY291bnQsIG9iZXlDb3VudCkpKSB7XG4gICAgICAgIHllYXIgPSBtYXRjaC52YWx1ZTtcbiAgICAgICAgaWYgKCdlcmEnIGluIHRtcCkge1xuICAgICAgICAgIGlmICh0bXAuZXJhID09PSAwKSB7XG4gICAgICAgICAgICB5ZWFyID0gMSAtIHllYXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhbGVuZGFyLnNldFllYXIoeWVhcik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdNJzpcbiAgICAgIHZhciBtb250aDtcbiAgICAgIGlmIChjb3VudCA+PSAzKSB7XG4gICAgICAgIGlmICgobWF0Y2ggPSBtYXRjaEZpZWxkKGRhdGVTdHIsIHN0YXJ0SW5kZXgsIGxvY2FsZVtjb3VudCA9PT0gMyA/XG4gICAgICAgICAgICAnc2hvcnRNb250aHMnIDogJ21vbnRocyddKSkpIHtcbiAgICAgICAgICBtb250aCA9IG1hdGNoLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKG1hdGNoID0gbWF0Y2hOdW1iZXIuY2FsbCh0aGlzLCBkYXRlU3RyLCBzdGFydEluZGV4LCBjb3VudCwgb2JleUNvdW50KSkpIHtcbiAgICAgICAgICBtb250aCA9IG1hdGNoLnZhbHVlIC0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGNhbGVuZGFyLnNldE1vbnRoKG1vbnRoKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2snOlxuICAgICAgaWYgKChtYXRjaCA9IG1hdGNoTnVtYmVyLmNhbGwodGhpcywgZGF0ZVN0ciwgc3RhcnRJbmRleCwgY291bnQsIG9iZXlDb3VudCkpKSB7XG4gICAgICAgIGNhbGVuZGFyLnNldEhvdXJPZkRheShtYXRjaC52YWx1ZSAlIDI0KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0UnOlxuICAgICAgaWYgKChtYXRjaCA9IG1hdGNoRmllbGQoZGF0ZVN0ciwgc3RhcnRJbmRleCwgbG9jYWxlW2NvdW50ID4gMyA/XG4gICAgICAgICAgJ3dlZWtkYXlzJyA6XG4gICAgICAgICAgJ3Nob3J0V2Vla2RheXMnXSkpKSB7XG4gICAgICAgIGNhbGVuZGFyLnNldERheU9mV2VlayhtYXRjaC52YWx1ZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdhJzpcbiAgICAgIGlmICgobWF0Y2ggPSBtYXRjaEZpZWxkKGRhdGVTdHIsIHN0YXJ0SW5kZXgsIGxvY2FsZS5hbXBtcykpKSB7XG4gICAgICAgIGlmIChjYWxlbmRhci5pc1NldEhvdXJPZkRheSgpKSB7XG4gICAgICAgICAgaWYgKG1hdGNoLnZhbHVlKSB7XG4gICAgICAgICAgICBob3VyID0gY2FsZW5kYXIuZ2V0SG91ck9mRGF5KCk7XG4gICAgICAgICAgICBpZiAoaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgIGNhbGVuZGFyLnNldEhvdXJPZkRheSgoaG91ciArIDEyKSAlIDI0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG1wLmFtcG0gPSBtYXRjaC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaCc6XG4gICAgICBpZiAoKG1hdGNoID0gbWF0Y2hOdW1iZXIuY2FsbCh0aGlzLCBkYXRlU3RyLCBzdGFydEluZGV4LCBjb3VudCwgb2JleUNvdW50KSkpIHtcbiAgICAgICAgaG91ciA9IG1hdGNoLnZhbHVlICU9IDEyO1xuICAgICAgICBpZiAodG1wLmFtcG0pIHtcbiAgICAgICAgICBob3VyICs9IDEyO1xuICAgICAgICB9XG4gICAgICAgIGNhbGVuZGFyLnNldEhvdXJPZkRheShob3VyKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0snOlxuICAgICAgaWYgKChtYXRjaCA9IG1hdGNoTnVtYmVyLmNhbGwodGhpcywgZGF0ZVN0ciwgc3RhcnRJbmRleCwgY291bnQsIG9iZXlDb3VudCkpKSB7XG4gICAgICAgIGhvdXIgPSBtYXRjaC52YWx1ZTtcbiAgICAgICAgaWYgKHRtcC5hbXBtKSB7XG4gICAgICAgICAgaG91ciArPSAxMjtcbiAgICAgICAgfVxuICAgICAgICBjYWxlbmRhci5zZXRIb3VyT2ZEYXkoaG91cik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdaJzpcbiAgICAgIHZhciBzaWduID0gMTtcbiAgICAgIHZhciB6b25lQ2hhciA9IGRhdGVTdHIuY2hhckF0KHN0YXJ0SW5kZXgpO1xuICAgICAgaWYgKHpvbmVDaGFyID09PSAnLScpIHtcbiAgICAgICAgc2lnbiA9IC0xO1xuICAgICAgICBzdGFydEluZGV4Kys7XG4gICAgICB9IGVsc2UgaWYgKHpvbmVDaGFyID09PSAnKycpIHtcbiAgICAgICAgc3RhcnRJbmRleCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoKG1hdGNoID0gbWF0Y2hOdW1iZXIuY2FsbCh0aGlzLCBkYXRlU3RyLCBzdGFydEluZGV4LCAyLCB0cnVlKSkpIHtcbiAgICAgICAgdmFyIHpvbmVPZmZzZXQgPSBtYXRjaC52YWx1ZSAqIDYwO1xuICAgICAgICBzdGFydEluZGV4ID0gbWF0Y2guc3RhcnRJbmRleDtcbiAgICAgICAgaWYgKChtYXRjaCA9IG1hdGNoTnVtYmVyLmNhbGwodGhpcywgZGF0ZVN0ciwgc3RhcnRJbmRleCwgMiwgdHJ1ZSkpKSB7XG4gICAgICAgICAgem9uZU9mZnNldCArPSBtYXRjaC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYWxlbmRhci5zZXRUaW1lem9uZU9mZnNldCh6b25lT2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQgOlxuICAgICAgLy8gY2FzZSAnZCc6XG4gICAgICAvLyBjYXNlICdIJzpcbiAgICAgIC8vIGNhc2UgJ20nOlxuICAgICAgLy8gY2FzZSAncyc6XG4gICAgICAvLyBjYXNlICdTJzpcbiAgICAgIC8vIGNhc2UgJ0QnOlxuICAgICAgLy8gY2FzZSAnRic6XG4gICAgICAvLyBjYXNlICd3JzpcbiAgICAgIC8vIGNhc2UgJ1cnXG4gICAgICBpZiAoKG1hdGNoID0gbWF0Y2hOdW1iZXIuY2FsbCh0aGlzLCBkYXRlU3RyLCBzdGFydEluZGV4LCBjb3VudCwgb2JleUNvdW50KSkpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gY2FsZW5kYXJJbmRleE1hcFtmaWVsZF07XG4gICAgICAgIGNhbGVuZGFyLnNldChpbmRleCwgbWF0Y2gudmFsdWUpO1xuICAgICAgfVxuICB9XG4gIGlmIChtYXRjaCkge1xuICAgIHN0YXJ0SW5kZXggPSBtYXRjaC5zdGFydEluZGV4O1xuICB9XG4gIHJldHVybiBzdGFydEluZGV4O1xufVxuXG5taXgoRGF0ZVRpbWVGb3JtYXQucHJvdG90eXBlLCB7XG4gIC8qKlxuICAgKiBmb3JtYXQgYSBHcmVnb3JpYW5EYXRlIGluc3RhbmNlIGFjY29yZGluZyB0byBzcGVjaWZpZWQgcGF0dGVyblxuICAgKiBAcGFyYW0ge0dyZWdvcmlhbkNhbGVuZGFyfSBjYWxlbmRhciBHcmVnb3JpYW5EYXRlIGluc3RhbmNlXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IGZvcm1hdHRlZCBzdHJpbmcgb2YgR3JlZ29yaWFuRGF0ZSBpbnN0YW5jZVxuICAgKi9cbiAgZm9ybWF0OiBmdW5jdGlvbiAoY2FsZW5kYXIpIHtcbiAgICBpZiAoIWNhbGVuZGFyLmlzR3JlZ29yaWFuQ2FsZW5kYXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2FsZW5kYXIgbXVzdCBiZSB0eXBlIG9mIEdyZWdvcmlhbkNhbGVuZGFyJyk7XG4gICAgfVxuICAgIHZhciBpO1xuICAgIHZhciByZXQgPSBbXTtcbiAgICB2YXIgcGF0dGVybiA9IHRoaXMucGF0dGVybjtcbiAgICB2YXIgbGVuID0gcGF0dGVybi5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgY29tcCA9IHBhdHRlcm5baV07XG4gICAgICBpZiAoY29tcC50ZXh0KSB7XG4gICAgICAgIHJldC5wdXNoKGNvbXAudGV4dCk7XG4gICAgICB9IGVsc2UgaWYgKCdmaWVsZCcgaW4gY29tcCkge1xuICAgICAgICByZXQucHVzaChmb3JtYXRGaWVsZChjb21wLmZpZWxkLCBjb21wLmNvdW50LCB0aGlzLmxvY2FsZSwgY2FsZW5kYXIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldC5qb2luKCcnKTtcbiAgfSxcblxuICAvKipcbiAgICogcGFyc2UgYSBmb3JtYXR0ZWQgc3RyaW5nIG9mIEdyZWdvcmlhbkRhdGUgaW5zdGFuY2UgYWNjb3JkaW5nIHRvIHNwZWNpZmllZCBwYXR0ZXJuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRlU3RyIGZvcm1hdHRlZCBzdHJpbmcgb2YgR3JlZ29yaWFuRGF0ZVxuICAgKiBAcmV0dXJucyB7R3JlZ29yaWFuQ2FsZW5kYXJ9XG4gICAqL1xuICBwYXJzZTogZnVuY3Rpb24gKGRhdGVTdHIsIGNhbGVuZGFyTG9jYWxlKSB7XG4gICAgdmFyIGNhbGVuZGFyID0gbmV3IEdyZWdvcmlhbkNhbGVuZGFyKGNhbGVuZGFyTG9jYWxlKTtcbiAgICB2YXIgaTtcbiAgICB2YXIgajtcbiAgICB2YXIgdG1wID0ge307XG4gICAgdmFyIG9iZXlDb3VudCA9IGZhbHNlO1xuICAgIHZhciBkYXRlU3RyTGVuID0gZGF0ZVN0ci5sZW5ndGg7XG4gICAgdmFyIGVycm9ySW5kZXggPSAtMTtcbiAgICB2YXIgc3RhcnRJbmRleCA9IDA7XG4gICAgdmFyIG9sZFN0YXJ0SW5kZXggPSAwO1xuICAgIHZhciBwYXR0ZXJuID0gdGhpcy5wYXR0ZXJuO1xuICAgIHZhciBsZW4gPSBwYXR0ZXJuLmxlbmd0aDtcblxuICAgIGxvb3BQYXR0ZXJuOiB7XG4gICAgICBmb3IgKGkgPSAwOyBlcnJvckluZGV4IDwgMCAmJiBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGNvbXAgPSBwYXR0ZXJuW2ldLCB0ZXh0LCB0ZXh0TGVuO1xuICAgICAgICBvbGRTdGFydEluZGV4ID0gc3RhcnRJbmRleDtcbiAgICAgICAgaWYgKCh0ZXh0ID0gY29tcC50ZXh0KSkge1xuICAgICAgICAgIHRleHRMZW4gPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoKHRleHRMZW4gKyBzdGFydEluZGV4KSA+IGRhdGVTdHJMZW4pIHtcbiAgICAgICAgICAgIGVycm9ySW5kZXggPSBzdGFydEluZGV4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgdGV4dExlbjsgaisrKSB7XG4gICAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJBdChqKSAhPT0gZGF0ZVN0ci5jaGFyQXQoaiArIHN0YXJ0SW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JJbmRleCA9IHN0YXJ0SW5kZXg7XG4gICAgICAgICAgICAgICAgYnJlYWsgbG9vcFBhdHRlcm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0SW5kZXggKz0gdGV4dExlbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoJ2ZpZWxkJyBpbiBjb21wKSB7XG4gICAgICAgICAgb2JleUNvdW50ID0gZmFsc2U7XG4gICAgICAgICAgdmFyIG5leHRDb21wID0gcGF0dGVybltpICsgMV07XG4gICAgICAgICAgaWYgKG5leHRDb21wKSB7XG4gICAgICAgICAgICBpZiAoJ2ZpZWxkJyBpbiBuZXh0Q29tcCkge1xuICAgICAgICAgICAgICBvYmV5Q291bnQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGMgPSBuZXh0Q29tcC50ZXh0LmNoYXJBdCgwKTtcbiAgICAgICAgICAgICAgaWYgKGMgPj0gJzAnICYmIGMgPD0gJzknKSB7XG4gICAgICAgICAgICAgICAgb2JleUNvdW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzdGFydEluZGV4ID0gcGFyc2VGaWVsZC5jYWxsKHRoaXMsIGNhbGVuZGFyLFxuICAgICAgICAgICAgZGF0ZVN0cixcbiAgICAgICAgICAgIHN0YXJ0SW5kZXgsXG4gICAgICAgICAgICBjb21wLmZpZWxkLFxuICAgICAgICAgICAgY29tcC5jb3VudCxcbiAgICAgICAgICAgIG9iZXlDb3VudCxcbiAgICAgICAgICAgIHRtcCk7XG4gICAgICAgICAgaWYgKHN0YXJ0SW5kZXggPT09IG9sZFN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgIGVycm9ySW5kZXggPSBzdGFydEluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlcnJvckluZGV4ID49IDApIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ2Vycm9yIHdoZW4gcGFyc2luZyBkYXRlJyk7XG4gICAgICBjb25zb2xlLmVycm9yKGRhdGVTdHIpO1xuICAgICAgY29uc29sZS5lcnJvcihkYXRlU3RyLnNsaWNlKDAsIGVycm9ySW5kZXgpICsgJ14nKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBjYWxlbmRhcjtcbiAgfVxufSk7XG5cbm1peChEYXRlVGltZUZvcm1hdCwge1xuICBTdHlsZTogRGF0ZVRpbWVTdHlsZSxcblxuICAvKipcbiAgICogZ2V0IGEgZm9ybWF0dGVyIGluc3RhbmNlIG9mIHNob3J0IHN0eWxlIHBhdHRlcm4uXG4gICAqIGVuLXVzOiBNL2QveXkgaDptbSBhXG4gICAqIHpoLWNuOiB5eS1NLWQgYWg6bW1cbiAgICogQHBhcmFtIHtPYmplY3R9IGxvY2FsZSBsb2NhbGUgb2JqZWN0XG4gICAqIEByZXR1cm5zIHtHcmVnb3JpYW5DYWxlbmRhcn1cbiAgICogQHN0YXRpY1xuICAgKi9cbiAgZ2V0SW5zdGFuY2U6IGZ1bmN0aW9uIChsb2NhbGUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXREYXRlVGltZUluc3RhbmNlKERhdGVUaW1lU3R5bGUuU0hPUlQsIERhdGVUaW1lU3R5bGUuU0hPUlQsIGxvY2FsZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGdldCBhIGZvcm1hdHRlciBpbnN0YW5jZSBvZiBzcGVjaWZpZWQgZGF0ZSBzdHlsZS5cbiAgICogQHBhcmFtIHtEYXRlLkZvcm1hdHRlci5TdHlsZX0gZGF0ZVN0eWxlIGRhdGUgZm9ybWF0IHN0eWxlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsb2NhbGVcbiAgICogQHJldHVybnMge0dyZWdvcmlhbkNhbGVuZGFyfVxuICAgKiBAc3RhdGljXG4gICAqL1xuICBnZXREYXRlSW5zdGFuY2U6IGZ1bmN0aW9uIChkYXRlU3R5bGUsIGxvY2FsZSkge1xuICAgIHJldHVybiB0aGlzLmdldERhdGVUaW1lSW5zdGFuY2UoZGF0ZVN0eWxlLCB1bmRlZmluZWQsIGxvY2FsZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGdldCBhIGZvcm1hdHRlciBpbnN0YW5jZSBvZiBzcGVjaWZpZWQgZGF0ZSBzdHlsZSBhbmQgdGltZSBzdHlsZS5cbiAgICogQHBhcmFtIHtEYXRlLkZvcm1hdHRlci5TdHlsZX0gZGF0ZVN0eWxlIGRhdGUgZm9ybWF0IHN0eWxlXG4gICAqIEBwYXJhbSB7RGF0ZS5Gb3JtYXR0ZXIuU3R5bGV9IHRpbWVTdHlsZSB0aW1lIGZvcm1hdCBzdHlsZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbG9jYWxlXG4gICAqIEByZXR1cm5zIHtHcmVnb3JpYW5DYWxlbmRhcn1cbiAgICogQHN0YXRpY1xuICAgKi9cbiAgZ2V0RGF0ZVRpbWVJbnN0YW5jZTogZnVuY3Rpb24gKGRhdGVTdHlsZSwgdGltZVN0eWxlLCBsb2NhbGUpIHtcbiAgICBsb2NhbGUgPSBsb2NhbGUgfHwgZW5Vc0xvY2FsZTtcbiAgICB2YXIgZGF0ZVBhdHRlcm4gPSAnJztcbiAgICBpZiAoZGF0ZVN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRhdGVQYXR0ZXJuID0gbG9jYWxlLmRhdGVQYXR0ZXJuc1tkYXRlU3R5bGVdO1xuICAgIH1cbiAgICB2YXIgdGltZVBhdHRlcm4gPSAnJztcbiAgICBpZiAodGltZVN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRpbWVQYXR0ZXJuID0gbG9jYWxlLnRpbWVQYXR0ZXJuc1t0aW1lU3R5bGVdO1xuICAgIH1cbiAgICB2YXIgcGF0dGVybiA9IGRhdGVQYXR0ZXJuO1xuICAgIGlmICh0aW1lUGF0dGVybikge1xuICAgICAgaWYgKGRhdGVQYXR0ZXJuKSB7XG4gICAgICAgIHBhdHRlcm4gPSBzdWJzdGl0dXRlKGxvY2FsZS5kYXRlVGltZVBhdHRlcm4sIHtcbiAgICAgICAgICBkYXRlOiBkYXRlUGF0dGVybixcbiAgICAgICAgICB0aW1lOiB0aW1lUGF0dGVyblxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdHRlcm4gPSB0aW1lUGF0dGVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRlVGltZUZvcm1hdChwYXR0ZXJuLCBsb2NhbGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBnZXQgYSBmb3JtYXR0ZXIgaW5zdGFuY2Ugb2Ygc3BlY2lmaWVkIHRpbWUgc3R5bGUuXG4gICAqIEBwYXJhbSB7RGF0ZS5Gb3JtYXR0ZXIuU3R5bGV9IHRpbWVTdHlsZSB0aW1lIGZvcm1hdCBzdHlsZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbG9jYWxlXG4gICAqIEByZXR1cm5zIHtHcmVnb3JpYW5DYWxlbmRhcn1cbiAgICogQHN0YXRpY1xuICAgKi9cbiAgZ2V0VGltZUluc3RhbmNlOiBmdW5jdGlvbiAodGltZVN0eWxlLCBsb2NhbGUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXREYXRlVGltZUluc3RhbmNlKHVuZGVmaW5lZCwgdGltZVN0eWxlLCBsb2NhbGUpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRlVGltZUZvcm1hdDtcblxuRGF0ZVRpbWVGb3JtYXQudmVyc2lvbiA9ICdAVkVSU0lPTkAnO1xuXG4vLyBnY19mb3JtYXRAMTYzLmNvbVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9+L3V4Y29yZS1jYWxlbmRhci9+L2dyZWdvcmlhbi1jYWxlbmRhci1mb3JtYXQvbGliL2dyZWdvcmlhbi1jYWxlbmRhci1mb3JtYXQuanNcbiAqKi8iLCIvKlxuICogR3JlZ29yaWFuQ2FsZW5kYXIgY2xhc3NcbiAqIEBpZ25vcmVcbiAqIEBhdXRob3IgeWltaW5naGVAZ21haWwuY29tXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHRvSW50ID0gcGFyc2VJbnQ7XG52YXIgVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgZGVmYXVsdExvY2FsZSA9IHJlcXVpcmUoJy4vbG9jYWxlL2VuLXVzJyk7XG52YXIgQ29uc3QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XG5cbi8qXG4gKiBHcmVnb3JpYW5DYWxlbmRhciBjbGFzcy5cbiAqXG4gKiAtIG5vIGFyZ3VtZW50czpcbiAqICAgQ29uc3RydWN0cyBhIGRlZmF1bHQgR3JlZ29yaWFuQ2FsZW5kYXIgdXNpbmcgdGhlIGN1cnJlbnQgdGltZVxuICogICBpbiB0aGUgZGVmYXVsdCB0aW1lIHpvbmUgd2l0aCB0aGUgZGVmYXVsdCBsb2NhbGUuXG4gKiAtIG9uZSBhcmd1bWVudCBsb2NhbGU6XG4gKiAgIENvbnN0cnVjdHMgYSBHcmVnb3JpYW5DYWxlbmRhclxuICogICBiYXNlZCBvbiB0aGUgY3VycmVudCB0aW1lIGluIHRoZSBkZWZhdWx0IHRpbWUgem9uZSB3aXRoIHRoZSBnaXZlbiBsb2NhbGUuXG4gKlxuICogQGNsYXNzIERhdGUuR3JlZ29yaWFuXG4gKi9cbmZ1bmN0aW9uIEdyZWdvcmlhbkNhbGVuZGFyKGxvYykge1xuICB2YXIgbG9jYWxlID0gbG9jIHx8IGRlZmF1bHRMb2NhbGU7XG5cbiAgdGhpcy5sb2NhbGUgPSBsb2NhbGU7XG5cbiAgdGhpcy5maWVsZHMgPSBbXTtcblxuICAvKlxuICAgKiBUaGUgY3VycmVudGx5IHNldCB0aW1lIGZvciB0aGlzIGRhdGUuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHR5cGUgTnVtYmVyfHVuZGVmaW5lZFxuICAgKi9cbiAgdGhpcy50aW1lID0gdW5kZWZpbmVkO1xuICAvKlxuICAgKiBUaGUgdGltZXpvbmVPZmZzZXQgaW4gbWludXRlcyB1c2VkIGJ5IHRoaXMgZGF0ZS5cbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cbiAgdGhpcy50aW1lem9uZU9mZnNldCA9IGxvY2FsZS50aW1lem9uZU9mZnNldDtcblxuICAvKlxuICAgKiBUaGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICB0aGlzLmZpcnN0RGF5T2ZXZWVrID0gbG9jYWxlLmZpcnN0RGF5T2ZXZWVrO1xuXG4gIC8qXG4gICAqIFRoZSBudW1iZXIgb2YgZGF5cyByZXF1aXJlZCBmb3IgdGhlIGZpcnN0IHdlZWsgaW4gYSBtb250aCBvciB5ZWFyLFxuICAgKiB3aXRoIHBvc3NpYmxlIHZhbHVlcyBmcm9tIDEgdG8gNy5cbiAgICogQEBwcm90ZWN0ZWRcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqL1xuICB0aGlzLm1pbmltYWxEYXlzSW5GaXJzdFdlZWsgPSBsb2NhbGUubWluaW1hbERheXNJbkZpcnN0V2VlaztcblxuICB0aGlzLmZpZWxkc0NvbXB1dGVkID0gZmFsc2U7XG59XG5cblV0aWxzLm1peChHcmVnb3JpYW5DYWxlbmRhciwgQ29uc3QpO1xuXG5VdGlscy5taXgoR3JlZ29yaWFuQ2FsZW5kYXIsIHtcbiAgVXRpbHM6IFV0aWxzLFxuXG4gIGRlZmF1bHRMb2NhbGU6IGRlZmF1bHRMb2NhbGUsXG5cbiAgLypcbiAgICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4geWVhciBpcyBhIGxlYXAgeWVhci5cbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB5ZWFyIGlzIGEgbGVhcCB5ZWFyLiBUbyBzcGVjaWZ5IEJDIHllYXIgbnVtYmVycyxcbiAgICogMSAtIHllYXIgbnVtYmVyIG11c3QgYmUgZ2l2ZW4uIEZvciBleGFtcGxlLCB5ZWFyIEJDIDQgaXMgc3BlY2lmaWVkIGFzIC0zLlxuICAgKiBAcGFyYW0ge051bWJlcn0geWVhciB0aGUgZ2l2ZW4geWVhci5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgdGhlIGdpdmVuIHllYXIgaXMgYSBsZWFwIHllYXI7IGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHN0YXRpY1xuICAgKiBAbWV0aG9kXG4gICAqL1xuICBpc0xlYXBZZWFyOiBVdGlscy5pc0xlYXBZZWFyLFxuXG4gIC8qXG4gICAqIEVudW0gaW5kaWNhdGluZyB5ZWFyIGZpZWxkIG9mIGRhdGVcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqL1xuICBZRUFSOiAxLFxuICAvKlxuICAgKiBFbnVtIGluZGljYXRpbmcgbW9udGggZmllbGQgb2YgZGF0ZVxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICovXG4gIE1PTlRIOiAyLFxuICAvKlxuICAgKiBFbnVtIGluZGljYXRpbmcgdGhlIGRheSBvZiB0aGUgbW9udGhcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqL1xuICBEQVlfT0ZfTU9OVEg6IDMsXG4gIC8qXG4gICAqIEVudW0gaW5kaWNhdGluZyB0aGUgaG91ciAoMjQpLlxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICovXG4gIEhPVVJfT0ZfREFZOiA0LFxuICAvKlxuICAgKiBFbnVtIGluZGljYXRpbmcgdGhlIG1pbnV0ZSBvZiB0aGUgZGF5XG4gICAqIEB0eXBlIE51bWJlclxuICAgKi9cbiAgTUlOVVRFUzogNSxcbiAgLypcbiAgICogRW51bSBpbmRpY2F0aW5nIHRoZSBzZWNvbmQgb2YgdGhlIGRheVxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICovXG4gIFNFQ09ORFM6IDYsXG4gIC8qXG4gICAqIEVudW0gaW5kaWNhdGluZyB0aGUgbWlsbGlzZWNvbmQgb2YgdGhlIGRheVxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICovXG4gIE1JTExJU0VDT05EUzogNyxcbiAgLypcbiAgICogRW51bSBpbmRpY2F0aW5nIHRoZSB3ZWVrIG51bWJlciB3aXRoaW4gdGhlIGN1cnJlbnQgeWVhclxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICovXG4gIFdFRUtfT0ZfWUVBUjogOCxcbiAgLypcbiAgICogRW51bSBpbmRpY2F0aW5nIHRoZSB3ZWVrIG51bWJlciB3aXRoaW4gdGhlIGN1cnJlbnQgbW9udGhcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqL1xuICBXRUVLX09GX01PTlRIOiA5LFxuXG4gIC8qXG4gICAqIEVudW0gaW5kaWNhdGluZyB0aGUgZGF5IG9mIHRoZSBkYXkgbnVtYmVyIHdpdGhpbiB0aGUgY3VycmVudCB5ZWFyXG4gICAqIEB0eXBlIE51bWJlclxuICAgKi9cbiAgREFZX09GX1lFQVI6IDEwLFxuICAvKlxuICAgKiBFbnVtIGluZGljYXRpbmcgdGhlIGRheSBvZiB0aGUgd2Vla1xuICAgKiBAdHlwZSBOdW1iZXJcbiAgICovXG4gIERBWV9PRl9XRUVLOiAxMSxcbiAgLypcbiAgICogRW51bSBpbmRpY2F0aW5nIHRoZSBkYXkgb2YgdGhlIG9yZGluYWwgbnVtYmVyIG9mIHRoZSBkYXkgb2YgdGhlIHdlZWtcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqL1xuICBEQVlfT0ZfV0VFS19JTl9NT05USDogMTIsXG5cbiAgLypcbiAgICogRW51bSBpbmRpY2F0aW5nIGFtXG4gICAqIEB0eXBlIE51bWJlclxuICAgKi9cbiAgQU06IDAsXG4gIC8qXG4gICAqIEVudW0gaW5kaWNhdGluZyBwbVxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICovXG4gIFBNOiAxXG59KTtcblxudmFyIEZJRUxEUyA9IFsnJywgJ1llYXInLCAnTW9udGgnLCAnRGF5T2ZNb250aCcsICdIb3VyT2ZEYXknLCAnTWludXRlcycsICdTZWNvbmRzJywgJ01pbGxpc2Vjb25kcycsICdXZWVrT2ZZZWFyJywgJ1dlZWtPZk1vbnRoJywgJ0RheU9mWWVhcicsICdEYXlPZldlZWsnLCAnRGF5T2ZXZWVrSW5Nb250aCddO1xuXG52YXIgWUVBUiA9IEdyZWdvcmlhbkNhbGVuZGFyLllFQVI7XG52YXIgTU9OVEggPSBHcmVnb3JpYW5DYWxlbmRhci5NT05USDtcbnZhciBEQVlfT0ZfTU9OVEggPSBHcmVnb3JpYW5DYWxlbmRhci5EQVlfT0ZfTU9OVEg7XG52YXIgSE9VUl9PRl9EQVkgPSBHcmVnb3JpYW5DYWxlbmRhci5IT1VSX09GX0RBWTtcbnZhciBNSU5VVEUgPSBHcmVnb3JpYW5DYWxlbmRhci5NSU5VVEVTO1xudmFyIFNFQ09ORFMgPSBHcmVnb3JpYW5DYWxlbmRhci5TRUNPTkRTO1xuXG52YXIgTUlMTElTRUNPTkRTID0gR3JlZ29yaWFuQ2FsZW5kYXIuTUlMTElTRUNPTkRTO1xudmFyIERBWV9PRl9XRUVLX0lOX01PTlRIID0gR3JlZ29yaWFuQ2FsZW5kYXIuREFZX09GX1dFRUtfSU5fTU9OVEg7XG52YXIgREFZX09GX1lFQVIgPSBHcmVnb3JpYW5DYWxlbmRhci5EQVlfT0ZfWUVBUjtcbnZhciBEQVlfT0ZfV0VFSyA9IEdyZWdvcmlhbkNhbGVuZGFyLkRBWV9PRl9XRUVLO1xuXG52YXIgV0VFS19PRl9NT05USCA9IEdyZWdvcmlhbkNhbGVuZGFyLldFRUtfT0ZfTU9OVEg7XG52YXIgV0VFS19PRl9ZRUFSID0gR3JlZ29yaWFuQ2FsZW5kYXIuV0VFS19PRl9ZRUFSO1xuXG52YXIgTU9OVEhfTEVOR1RIID0gWzMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdOyAvLyAwLWJhc2VkXG52YXIgTEVBUF9NT05USF9MRU5HVEggPSBbMzEsIDI5LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV07IC8vIDAtYmFzZWRcblxudmFyIE9ORV9TRUNPTkQgPSAxMDAwO1xudmFyIE9ORV9NSU5VVEUgPSA2MCAqIE9ORV9TRUNPTkQ7XG52YXIgT05FX0hPVVIgPSA2MCAqIE9ORV9NSU5VVEU7XG52YXIgT05FX0RBWSA9IDI0ICogT05FX0hPVVI7XG52YXIgT05FX1dFRUsgPSBPTkVfREFZICogNztcblxudmFyIEVQT0NIX09GRlNFVCA9IDcxOTE2MzsgLy8gRml4ZWQgZGF0ZSBvZiBKYW51YXJ5IDEsIDE5NzAgKEdyZWdvcmlhbilcblxudmFyIG1vZCA9IFV0aWxzLm1vZDtcbnZhciBfaXNMZWFwWWVhciA9IFV0aWxzLmlzTGVhcFllYXI7XG52YXIgZmxvb3JEaXZpZGUgPSBNYXRoLmZsb29yO1xuXG52YXIgTUlOX1ZBTFVFUyA9IFt1bmRlZmluZWQsIDEsIC8vIFlFQVJcbkdyZWdvcmlhbkNhbGVuZGFyLkpBTlVBUlksIC8vIE1PTlRIXG4xLCAvLyBEQVlfT0ZfTU9OVEhcbjAsIC8vIEhPVVJfT0ZfREFZXG4wLCAvLyBNSU5VVEVcbjAsIC8vIFNFQ09ORFNcbjAsIC8vIE1JTExJU0VDT05EU1xuXG4xLCAvLyBXRUVLX09GX1lFQVJcbnVuZGVmaW5lZCwgLy8gV0VFS19PRl9NT05USFxuXG4xLCAvLyBEQVlfT0ZfWUVBUlxuR3JlZ29yaWFuQ2FsZW5kYXIuU1VOREFZLCAvLyBEQVlfT0ZfV0VFS1xuMV07XG5cbi8vIERBWV9PRl9XRUVLX0lOX01PTlRIXG52YXIgTUFYX1ZBTFVFUyA9IFt1bmRlZmluZWQsIDI5MjI3ODk5NCwgLy8gWUVBUlxuR3JlZ29yaWFuQ2FsZW5kYXIuREVDRU1CRVIsIC8vIE1PTlRIXG51bmRlZmluZWQsIC8vIERBWV9PRl9NT05USFxuMjMsIC8vIEhPVVJfT0ZfREFZXG41OSwgLy8gTUlOVVRFXG41OSwgLy8gU0VDT05EU1xuOTk5LCAvLyBNSUxMSVNFQ09ORFNcbnVuZGVmaW5lZCwgLy8gV0VFS19PRl9ZRUFSXG51bmRlZmluZWQsIC8vIFdFRUtfT0ZfTU9OVEhcbnVuZGVmaW5lZCwgLy8gREFZX09GX1lFQVJcbkdyZWdvcmlhbkNhbGVuZGFyLlNBVFVSREFZLCAvLyBEQVlfT0ZfV0VFS1xudW5kZWZpbmVkXTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLSBwcml2YXRlIHN0YXJ0XG5cbi8vIERBWV9PRl9XRUVLX0lOX01PTlRIXG5mdW5jdGlvbiBnZXRNb250aExlbmd0aCh5ZWFyLCBtb250aCkge1xuICByZXR1cm4gX2lzTGVhcFllYXIoeWVhcikgPyBMRUFQX01PTlRIX0xFTkdUSFttb250aF0gOiBNT05USF9MRU5HVEhbbW9udGhdO1xufVxuXG5mdW5jdGlvbiBnZXRZZWFyTGVuZ3RoKHllYXIpIHtcbiAgcmV0dXJuIF9pc0xlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xufVxuXG5mdW5jdGlvbiBhZGp1c3REYXlPZk1vbnRoKHNlbGYpIHtcbiAgdmFyIGZpZWxkcyA9IHNlbGYuZmllbGRzO1xuICB2YXIgeWVhciA9IGZpZWxkc1tZRUFSXTtcbiAgdmFyIG1vbnRoID0gZmllbGRzW01PTlRIXTtcbiAgdmFyIG1vbnRoTGVuID0gZ2V0TW9udGhMZW5ndGgoeWVhciwgbW9udGgpO1xuICB2YXIgZGF5T2ZNb250aCA9IGZpZWxkc1tEQVlfT0ZfTU9OVEhdO1xuICBpZiAoZGF5T2ZNb250aCA+IG1vbnRoTGVuKSB7XG4gICAgc2VsZi5zZXQoREFZX09GX01PTlRILCBtb250aExlbik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGF5T2ZXZWVrRGF0ZU9uT3JCZWZvcmUoZml4ZWREYXRlLCBkYXlPZldlZWspIHtcbiAgLy8gMS4xLjEgaXMgbW9uZGF5XG4gIC8vIG9uZSB3ZWVrIGhhcyA3IGRheXNcbiAgcmV0dXJuIGZpeGVkRGF0ZSAtIG1vZChmaXhlZERhdGUgLSBkYXlPZldlZWssIDcpO1xufVxuXG5mdW5jdGlvbiBnZXRXZWVrTnVtYmVyKHNlbGYsIGZpeGVkRGF5MSwgZml4ZWREYXRlKSB7XG4gIHZhciBmaXhlZERheTFzdCA9IGdldERheU9mV2Vla0RhdGVPbk9yQmVmb3JlKGZpeGVkRGF5MSArIDYsIHNlbGYuZmlyc3REYXlPZldlZWspO1xuICB2YXIgbkRheXMgPSBmaXhlZERheTFzdCAtIGZpeGVkRGF5MTtcbiAgaWYgKG5EYXlzID49IHNlbGYubWluaW1hbERheXNJbkZpcnN0V2Vlaykge1xuICAgIGZpeGVkRGF5MXN0IC09IDc7XG4gIH1cbiAgdmFyIG5vcm1hbGl6ZWREYXlPZlBlcmlvZCA9IGZpeGVkRGF0ZSAtIGZpeGVkRGF5MXN0O1xuICByZXR1cm4gZmxvb3JEaXZpZGUobm9ybWFsaXplZERheU9mUGVyaW9kIC8gNykgKyAxO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tIHByaXZhdGUgZW5kXG5cbkdyZWdvcmlhbkNhbGVuZGFyLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEdyZWdvcmlhbkNhbGVuZGFyLFxuXG4gIGlzR3JlZ29yaWFuQ2FsZW5kYXI6IDEsXG5cbiAgLypcbiAgICogRGV0ZXJtaW5lcyBpZiBjdXJyZW50IHllYXIgaXMgYSBsZWFwIHllYXIuXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4geWVhciBpcyBhIGxlYXAgeWVhci4gVG8gc3BlY2lmeSBCQyB5ZWFyIG51bWJlcnMsXG4gICAqIDEgLSB5ZWFyIG51bWJlciBtdXN0IGJlIGdpdmVuLiBGb3IgZXhhbXBsZSwgeWVhciBCQyA0IGlzIHNwZWNpZmllZCBhcyAtMy5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgdGhlIGdpdmVuIHllYXIgaXMgYSBsZWFwIHllYXI7IGZhbHNlIG90aGVyd2lzZS5cbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyIERhdGUuR3JlZ29yaWFuXG4gICAqL1xuICBpc0xlYXBZZWFyOiBmdW5jdGlvbiBpc0xlYXBZZWFyKCkge1xuICAgIHJldHVybiBfaXNMZWFwWWVhcih0aGlzLmdldFllYXIoKSk7XG4gIH0sXG5cbiAgLypcbiAgICogUmV0dXJuIGxvY2FsIGluZm8gZm9yIGN1cnJlbnQgZGF0ZSBpbnN0YW5jZVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0TG9jYWxlOiBmdW5jdGlvbiBnZXRMb2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxlO1xuICB9LFxuXG4gIC8qXG4gICAqIFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUgZm9yXG4gICAqIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZCBvZiB0aGlzIEdyZWdvcmlhbkNhbGVuZGFyIGluc3RhbmNlLlxuICAgKiBUaGUgbWluaW11bSB2YWx1ZSBpcyBkZWZpbmVkIGFzIHRoZSBzbWFsbGVzdCB2YWx1ZVxuICAgKiByZXR1cm5lZCBieSB0aGUgZ2V0IG1ldGhvZCBmb3IgYW55IHBvc3NpYmxlIHRpbWUgdmFsdWUsXG4gICAqIHRha2luZyBpbnRvIGNvbnNpZGVyYXRpb24gdGhlIGN1cnJlbnQgdmFsdWVzIG9mIHRoZSBnZXRGaXJzdERheU9mV2VlayxcbiAgICogZ2V0TWluaW1hbERheXNJbkZpcnN0V2Vlay5cbiAgICogQHBhcmFtIGZpZWxkIHRoZSBjYWxlbmRhciBmaWVsZC5cbiAgICogQHJldHVybnMge051bWJlcn0gdGhlIG1pbmltdW0gdmFsdWUgZm9yIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICovXG4gIGdldEFjdHVhbE1pbmltdW06IGZ1bmN0aW9uIGdldEFjdHVhbE1pbmltdW0oZmllbGQpIHtcbiAgICBpZiAoTUlOX1ZBTFVFU1tmaWVsZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIE1JTl9WQUxVRVNbZmllbGRdO1xuICAgIH1cbiAgICBpZiAoZmllbGQgPT09IFdFRUtfT0ZfTU9OVEgpIHtcbiAgICAgIHZhciBjYWwgPSB0aGlzLmNsb25lKCk7XG4gICAgICBjYWwuY2xlYXIoKTtcbiAgICAgIGNhbC5zZXQodGhpcy5maWVsZHNbWUVBUl0sIHRoaXMuZmllbGRzW01PTlRIXSwgMSk7XG4gICAgICByZXR1cm4gY2FsLmdldChXRUVLX09GX01PTlRIKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21pbmltdW0gdmFsdWUgbm90IGRlZmluZWQhJyk7XG4gIH0sXG5cbiAgLypcbiAgICogUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZSBmb3IgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkXG4gICAqIG9mIHRoaXMgR3JlZ29yaWFuQ2FsZW5kYXIgaW5zdGFuY2UuXG4gICAqIFRoZSBtYXhpbXVtIHZhbHVlIGlzIGRlZmluZWQgYXMgdGhlIGxhcmdlc3QgdmFsdWUgcmV0dXJuZWRcbiAgICogYnkgdGhlIGdldCBtZXRob2QgZm9yIGFueSBwb3NzaWJsZSB0aW1lIHZhbHVlLCB0YWtpbmcgaW50byBjb25zaWRlcmF0aW9uXG4gICAqIHRoZSBjdXJyZW50IHZhbHVlcyBvZiB0aGUgZ2V0Rmlyc3REYXlPZldlZWssIGdldE1pbmltYWxEYXlzSW5GaXJzdFdlZWsgbWV0aG9kcy5cbiAgICogQHBhcmFtIGZpZWxkIHRoZSBjYWxlbmRhciBmaWVsZC5cbiAgICogQHJldHVybnMge051bWJlcn0gdGhlIG1heGltdW0gdmFsdWUgZm9yIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICovXG4gIGdldEFjdHVhbE1heGltdW06IGZ1bmN0aW9uIGdldEFjdHVhbE1heGltdW0oZmllbGQpIHtcbiAgICBpZiAoTUFYX1ZBTFVFU1tmaWVsZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIE1BWF9WQUxVRVNbZmllbGRdO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdmFyIGZpZWxkcyA9IHRoaXMuZmllbGRzO1xuICAgIHN3aXRjaCAoZmllbGQpIHtcbiAgICAgIGNhc2UgREFZX09GX01PTlRIOlxuICAgICAgICB2YWx1ZSA9IGdldE1vbnRoTGVuZ3RoKGZpZWxkc1tZRUFSXSwgZmllbGRzW01PTlRIXSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFdFRUtfT0ZfWUVBUjpcbiAgICAgICAgdmFyIGVuZE9mWWVhciA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgZW5kT2ZZZWFyLmNsZWFyKCk7XG4gICAgICAgIGVuZE9mWWVhci5zZXQoZmllbGRzW1lFQVJdLCBHcmVnb3JpYW5DYWxlbmRhci5ERUNFTUJFUiwgMzEpO1xuICAgICAgICB2YWx1ZSA9IGVuZE9mWWVhci5nZXQoV0VFS19PRl9ZRUFSKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSAxKSB7XG4gICAgICAgICAgdmFsdWUgPSA1MjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBXRUVLX09GX01PTlRIOlxuICAgICAgICB2YXIgZW5kT2ZNb250aCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgZW5kT2ZNb250aC5jbGVhcigpO1xuICAgICAgICBlbmRPZk1vbnRoLnNldChmaWVsZHNbWUVBUl0sIGZpZWxkc1tNT05USF0sIGdldE1vbnRoTGVuZ3RoKGZpZWxkc1tZRUFSXSwgZmllbGRzW01PTlRIXSkpO1xuICAgICAgICB2YWx1ZSA9IGVuZE9mTW9udGguZ2V0KFdFRUtfT0ZfTU9OVEgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBEQVlfT0ZfWUVBUjpcbiAgICAgICAgdmFsdWUgPSBnZXRZZWFyTGVuZ3RoKGZpZWxkc1tZRUFSXSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIERBWV9PRl9XRUVLX0lOX01PTlRIOlxuICAgICAgICB2YWx1ZSA9IHRvSW50KChnZXRNb250aExlbmd0aChmaWVsZHNbWUVBUl0sIGZpZWxkc1tNT05USF0pIC0gMSkgLyA3KSArIDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21heGltdW0gdmFsdWUgbm90IGRlZmluZWQhJyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcblxuICAvKlxuICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZCBoYXMgYSB2YWx1ZSBzZXQsXG4gICAqIGluY2x1ZGluZyBjYXNlcyB0aGF0IHRoZSB2YWx1ZSBoYXMgYmVlbiBzZXQgYnkgaW50ZXJuYWwgZmllbGRzIGNhbGN1bGF0aW9uc1xuICAgKiB0cmlnZ2VyZWQgYnkgYSBnZXQgbWV0aG9kIGNhbGwuXG4gICAqIEBwYXJhbSBmaWVsZCB0aGUgY2FsZW5kYXIgZmllbGQgdG8gYmUgY2xlYXJlZC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkIGhhcyBhIHZhbHVlIHNldDsgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNTZXQ6IGZ1bmN0aW9uIGlzU2V0KGZpZWxkKSB7XG4gICAgcmV0dXJuIHRoaXMuZmllbGRzW2ZpZWxkXSAhPT0gdW5kZWZpbmVkO1xuICB9LFxuXG4gIC8qXG4gICAqIENvbnZlcnRzIHRoZSB0aW1lIHZhbHVlIChtaWxsaXNlY29uZCBvZmZzZXQgZnJvbSB0aGUgRXBvY2gpXG4gICAqIHRvIGNhbGVuZGFyIGZpZWxkIHZhbHVlcy5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgY29tcHV0ZUZpZWxkczogZnVuY3Rpb24gY29tcHV0ZUZpZWxkcygpIHtcbiAgICB2YXIgdGltZSA9IHRoaXMudGltZTtcbiAgICB2YXIgdGltZXpvbmVPZmZzZXQgPSB0aGlzLnRpbWV6b25lT2Zmc2V0ICogT05FX01JTlVURTtcbiAgICB2YXIgZml4ZWREYXRlID0gdG9JbnQodGltZXpvbmVPZmZzZXQgLyBPTkVfREFZKTtcbiAgICB2YXIgdGltZU9mRGF5ID0gdGltZXpvbmVPZmZzZXQgJSBPTkVfREFZO1xuICAgIGZpeGVkRGF0ZSArPSB0b0ludCh0aW1lIC8gT05FX0RBWSk7XG4gICAgdGltZU9mRGF5ICs9IHRpbWUgJSBPTkVfREFZO1xuICAgIGlmICh0aW1lT2ZEYXkgPj0gT05FX0RBWSkge1xuICAgICAgdGltZU9mRGF5IC09IE9ORV9EQVk7XG4gICAgICBmaXhlZERhdGUrKztcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKHRpbWVPZkRheSA8IDApIHtcbiAgICAgICAgdGltZU9mRGF5ICs9IE9ORV9EQVk7XG4gICAgICAgIGZpeGVkRGF0ZS0tO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZpeGVkRGF0ZSArPSBFUE9DSF9PRkZTRVQ7XG5cbiAgICB2YXIgZGF0ZSA9IFV0aWxzLmdldEdyZWdvcmlhbkRhdGVGcm9tRml4ZWREYXRlKGZpeGVkRGF0ZSk7XG5cbiAgICB2YXIgeWVhciA9IGRhdGUueWVhcjtcblxuICAgIHZhciBmaWVsZHMgPSB0aGlzLmZpZWxkcztcbiAgICBmaWVsZHNbWUVBUl0gPSB5ZWFyO1xuICAgIGZpZWxkc1tNT05USF0gPSBkYXRlLm1vbnRoO1xuICAgIGZpZWxkc1tEQVlfT0ZfTU9OVEhdID0gZGF0ZS5kYXlPZk1vbnRoO1xuICAgIGZpZWxkc1tEQVlfT0ZfV0VFS10gPSBkYXRlLmRheU9mV2VlaztcblxuICAgIGlmICh0aW1lT2ZEYXkgIT09IDApIHtcbiAgICAgIGZpZWxkc1tIT1VSX09GX0RBWV0gPSB0b0ludCh0aW1lT2ZEYXkgLyBPTkVfSE9VUik7XG4gICAgICB2YXIgciA9IHRpbWVPZkRheSAlIE9ORV9IT1VSO1xuICAgICAgZmllbGRzW01JTlVURV0gPSB0b0ludChyIC8gT05FX01JTlVURSk7XG4gICAgICByICU9IE9ORV9NSU5VVEU7XG4gICAgICBmaWVsZHNbU0VDT05EU10gPSB0b0ludChyIC8gT05FX1NFQ09ORCk7XG4gICAgICBmaWVsZHNbTUlMTElTRUNPTkRTXSA9IHIgJSBPTkVfU0VDT05EO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaWVsZHNbSE9VUl9PRl9EQVldID0gZmllbGRzW01JTlVURV0gPSBmaWVsZHNbU0VDT05EU10gPSBmaWVsZHNbTUlMTElTRUNPTkRTXSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGZpeGVkRGF0ZUphbjEgPSBVdGlscy5nZXRGaXhlZERhdGUoeWVhciwgR3JlZ29yaWFuQ2FsZW5kYXIuSkFOVUFSWSwgMSk7XG4gICAgdmFyIGRheU9mWWVhciA9IGZpeGVkRGF0ZSAtIGZpeGVkRGF0ZUphbjEgKyAxO1xuICAgIHZhciBmaXhEYXRlTW9udGgxID0gZml4ZWREYXRlIC0gZGF0ZS5kYXlPZk1vbnRoICsgMTtcblxuICAgIGZpZWxkc1tEQVlfT0ZfWUVBUl0gPSBkYXlPZlllYXI7XG4gICAgZmllbGRzW0RBWV9PRl9XRUVLX0lOX01PTlRIXSA9IHRvSW50KChkYXRlLmRheU9mTW9udGggLSAxKSAvIDcpICsgMTtcblxuICAgIHZhciB3ZWVrT2ZZZWFyID0gZ2V0V2Vla051bWJlcih0aGlzLCBmaXhlZERhdGVKYW4xLCBmaXhlZERhdGUpO1xuXG4gICAgLy8g5pys5ZGo5rKh5pyJ6Laz5aSf55qE5pe26Ze05Zyo5b2T5YmN5bm0XG4gICAgaWYgKHdlZWtPZlllYXIgPT09IDApIHtcbiAgICAgIC8vIElmIHRoZSBkYXRlIGJlbG9uZ3MgdG8gdGhlIGxhc3Qgd2VlayBvZiB0aGVcbiAgICAgIC8vIHByZXZpb3VzIHllYXIsIHVzZSB0aGUgd2VlayBudW1iZXIgb2YgXCIxMi8zMVwiIG9mXG4gICAgICAvLyB0aGUgXCJwcmV2aW91c1wiIHllYXIuXG4gICAgICB2YXIgZml4ZWREZWMzMSA9IGZpeGVkRGF0ZUphbjEgLSAxO1xuICAgICAgdmFyIHByZXZKYW4xID0gZml4ZWREYXRlSmFuMSAtIGdldFllYXJMZW5ndGgoeWVhciAtIDEpO1xuICAgICAgd2Vla09mWWVhciA9IGdldFdlZWtOdW1iZXIodGhpcywgcHJldkphbjEsIGZpeGVkRGVjMzEpO1xuICAgIH0gZWxzZVxuICAgICAgLy8g5pys5ZGo5piv5bm05pyr5pyA5ZCO5LiA5ZGo77yM5Y+v6IO95pyJ6Laz5aSf55qE5pe26Ze05Zyo5paw55qE5LiA5bm0XG4gICAgICBpZiAod2Vla09mWWVhciA+PSA1Mikge1xuICAgICAgICB2YXIgbmV4dEphbjEgPSBmaXhlZERhdGVKYW4xICsgZ2V0WWVhckxlbmd0aCh5ZWFyKTtcbiAgICAgICAgdmFyIG5leHRKYW4xc3QgPSBnZXREYXlPZldlZWtEYXRlT25PckJlZm9yZShuZXh0SmFuMSArIDYsIHRoaXMuZmlyc3REYXlPZldlZWspO1xuICAgICAgICB2YXIgbkRheXMgPSBuZXh0SmFuMXN0IC0gbmV4dEphbjE7XG4gICAgICAgIC8vIOacrOWRqOaciei2s+Wkn+WkqeaVsOWcqOaWsOeahOS4gOW5tFxuICAgICAgICBpZiAobkRheXMgPj0gdGhpcy5taW5pbWFsRGF5c0luRmlyc3RXZWVrICYmXG4gICAgICAgIC8vIOW9k+WkqeehruWunuWcqOacrOWRqO+8jHdlZWtPZlllYXIgPT09IDUzIOaXtuaYr+S4jemcgOimgei/meS4quWIpOaWrVxuICAgICAgICBmaXhlZERhdGUgPj0gbmV4dEphbjFzdCAtIDcpIHtcbiAgICAgICAgICB3ZWVrT2ZZZWFyID0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgZmllbGRzW1dFRUtfT0ZfWUVBUl0gPSB3ZWVrT2ZZZWFyO1xuICAgIGZpZWxkc1tXRUVLX09GX01PTlRIXSA9IGdldFdlZWtOdW1iZXIodGhpcywgZml4RGF0ZU1vbnRoMSwgZml4ZWREYXRlKTtcblxuICAgIHRoaXMuZmllbGRzQ29tcHV0ZWQgPSB0cnVlO1xuICB9LFxuXG4gIC8qXG4gICAqIENvbnZlcnRzIGNhbGVuZGFyIGZpZWxkIHZhbHVlcyB0byB0aGUgdGltZSB2YWx1ZVxuICAgKiAobWlsbGlzZWNvbmQgb2Zmc2V0IGZyb20gdGhlIEVwb2NoKS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgY29tcHV0ZVRpbWU6IGZ1bmN0aW9uIGNvbXB1dGVUaW1lKCkge1xuICAgIGlmICghdGhpcy5pc1NldChZRUFSKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd5ZWFyIG11c3QgYmUgc2V0IGZvciBHcmVnb3JpYW5DYWxlbmRhcicpO1xuICAgIH1cblxuICAgIHZhciBmaWVsZHMgPSB0aGlzLmZpZWxkcztcblxuICAgIHZhciB5ZWFyID0gZmllbGRzW1lFQVJdO1xuICAgIHZhciB0aW1lT2ZEYXkgPSAwO1xuICAgIGlmICh0aGlzLmlzU2V0KEhPVVJfT0ZfREFZKSkge1xuICAgICAgdGltZU9mRGF5ICs9IGZpZWxkc1tIT1VSX09GX0RBWV07XG4gICAgfVxuICAgIHRpbWVPZkRheSAqPSA2MDtcbiAgICB0aW1lT2ZEYXkgKz0gZmllbGRzW01JTlVURV0gfHwgMDtcbiAgICB0aW1lT2ZEYXkgKj0gNjA7XG4gICAgdGltZU9mRGF5ICs9IGZpZWxkc1tTRUNPTkRTXSB8fCAwO1xuICAgIHRpbWVPZkRheSAqPSAxMDAwO1xuICAgIHRpbWVPZkRheSArPSBmaWVsZHNbTUlMTElTRUNPTkRTXSB8fCAwO1xuXG4gICAgdmFyIGZpeGVkRGF0ZSA9IDA7XG5cbiAgICBmaWVsZHNbWUVBUl0gPSB5ZWFyO1xuXG4gICAgZml4ZWREYXRlID0gZml4ZWREYXRlICsgdGhpcy5nZXRGaXhlZERhdGUoKTtcblxuICAgIC8vIG1pbGxpcyByZXByZXNlbnRzIGxvY2FsIHdhbGwtY2xvY2sgdGltZSBpbiBtaWxsaXNlY29uZHMuXG4gICAgdmFyIG1pbGxpcyA9IChmaXhlZERhdGUgLSBFUE9DSF9PRkZTRVQpICogT05FX0RBWSArIHRpbWVPZkRheTtcblxuICAgIG1pbGxpcyAtPSB0aGlzLnRpbWV6b25lT2Zmc2V0ICogT05FX01JTlVURTtcblxuICAgIHRoaXMudGltZSA9IG1pbGxpcztcblxuICAgIHRoaXMuY29tcHV0ZUZpZWxkcygpO1xuICB9LFxuXG4gIC8qXG4gICAqIEZpbGxzIGluIGFueSB1bnNldCBmaWVsZHMgaW4gdGhlIGNhbGVuZGFyIGZpZWxkcy4gRmlyc3QsXG4gICAqIHRoZSBjb21wdXRlVGltZSgpIG1ldGhvZCBpcyBjYWxsZWQgaWYgdGhlIHRpbWUgdmFsdWUgKG1pbGxpc2Vjb25kIG9mZnNldCBmcm9tIHRoZSBFcG9jaClcbiAgICogaGFzIG5vdCBiZWVuIGNhbGN1bGF0ZWQgZnJvbSBjYWxlbmRhciBmaWVsZCB2YWx1ZXMuXG4gICAqIFRoZW4sIHRoZSBjb21wdXRlRmllbGRzKCkgbWV0aG9kIGlzIGNhbGxlZCB0byBjYWxjdWxhdGUgYWxsIGNhbGVuZGFyIGZpZWxkIHZhbHVlcy5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgY29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuICAgIGlmICh0aGlzLnRpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5jb21wdXRlVGltZSgpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuZmllbGRzQ29tcHV0ZWQpIHtcbiAgICAgIHRoaXMuY29tcHV0ZUZpZWxkcygpO1xuICAgIH1cbiAgfSxcblxuICBnZXRGaXhlZERhdGU6IGZ1bmN0aW9uIGdldEZpeGVkRGF0ZSgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgZmllbGRzID0gc2VsZi5maWVsZHM7XG5cbiAgICB2YXIgZmlyc3REYXlPZldlZWtDZmcgPSBzZWxmLmZpcnN0RGF5T2ZXZWVrO1xuXG4gICAgdmFyIHllYXIgPSBmaWVsZHNbWUVBUl07XG5cbiAgICB2YXIgbW9udGggPSBHcmVnb3JpYW5DYWxlbmRhci5KQU5VQVJZO1xuXG4gICAgaWYgKHNlbGYuaXNTZXQoTU9OVEgpKSB7XG4gICAgICBtb250aCA9IGZpZWxkc1tNT05USF07XG4gICAgICBpZiAobW9udGggPiBHcmVnb3JpYW5DYWxlbmRhci5ERUNFTUJFUikge1xuICAgICAgICB5ZWFyICs9IHRvSW50KG1vbnRoIC8gMTIpO1xuICAgICAgICBtb250aCAlPSAxMjtcbiAgICAgIH0gZWxzZSBpZiAobW9udGggPCBHcmVnb3JpYW5DYWxlbmRhci5KQU5VQVJZKSB7XG4gICAgICAgIHllYXIgKz0gZmxvb3JEaXZpZGUobW9udGggLyAxMik7XG4gICAgICAgIG1vbnRoID0gbW9kKG1vbnRoLCAxMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2V0IHRoZSBmaXhlZCBkYXRlIHNpbmNlIEphbiAxLCAxIChHcmVnb3JpYW4pLiBXZSBhcmUgb25cbiAgICAvLyB0aGUgZmlyc3QgZGF5IG9mIGVpdGhlciBgbW9udGgnIG9yIEphbnVhcnkgaW4gJ3llYXInLlxuICAgIHZhciBmaXhlZERhdGUgPSBVdGlscy5nZXRGaXhlZERhdGUoeWVhciwgbW9udGgsIDEpO1xuICAgIHZhciBmaXJzdERheU9mV2VlayA9IHVuZGVmaW5lZDtcbiAgICB2YXIgZGF5T2ZXZWVrID0gc2VsZi5maXJzdERheU9mV2VlaztcblxuICAgIGlmIChzZWxmLmlzU2V0KERBWV9PRl9XRUVLKSkge1xuICAgICAgZGF5T2ZXZWVrID0gZmllbGRzW0RBWV9PRl9XRUVLXTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5pc1NldChNT05USCkpIHtcbiAgICAgIGlmIChzZWxmLmlzU2V0KERBWV9PRl9NT05USCkpIHtcbiAgICAgICAgZml4ZWREYXRlICs9IGZpZWxkc1tEQVlfT0ZfTU9OVEhdIC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzZWxmLmlzU2V0KFdFRUtfT0ZfTU9OVEgpKSB7XG4gICAgICAgICAgZmlyc3REYXlPZldlZWsgPSBnZXREYXlPZldlZWtEYXRlT25PckJlZm9yZShmaXhlZERhdGUgKyA2LCBmaXJzdERheU9mV2Vla0NmZyk7XG5cbiAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGVub3VnaCBkYXlzIGluIHRoZSBmaXJzdCB3ZWVrLCB0aGVuXG4gICAgICAgICAgLy8gbW92ZSB0byB0aGUgcHJldmlvdXMgd2Vlay5cbiAgICAgICAgICBpZiAoZmlyc3REYXlPZldlZWsgLSBmaXhlZERhdGUgPj0gc2VsZi5taW5pbWFsRGF5c0luRmlyc3RXZWVrKSB7XG4gICAgICAgICAgICBmaXJzdERheU9mV2VlayAtPSA3O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChkYXlPZldlZWsgIT09IGZpcnN0RGF5T2ZXZWVrQ2ZnKSB7XG4gICAgICAgICAgICBmaXJzdERheU9mV2VlayA9IGdldERheU9mV2Vla0RhdGVPbk9yQmVmb3JlKGZpcnN0RGF5T2ZXZWVrICsgNiwgZGF5T2ZXZWVrKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmaXhlZERhdGUgPSBmaXJzdERheU9mV2VlayArIDcgKiAoZmllbGRzW1dFRUtfT0ZfTU9OVEhdIC0gMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGRvd2ltID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGlmIChzZWxmLmlzU2V0KERBWV9PRl9XRUVLX0lOX01PTlRIKSkge1xuICAgICAgICAgICAgZG93aW0gPSBmaWVsZHNbREFZX09GX1dFRUtfSU5fTU9OVEhdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb3dpbSA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsYXN0RGF0ZSA9IDcgKiBkb3dpbTtcbiAgICAgICAgICBpZiAoZG93aW0gPCAwKSB7XG4gICAgICAgICAgICBsYXN0RGF0ZSA9IGdldE1vbnRoTGVuZ3RoKHllYXIsIG1vbnRoKSArIDcgKiAoZG93aW0gKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZml4ZWREYXRlID0gZ2V0RGF5T2ZXZWVrRGF0ZU9uT3JCZWZvcmUoZml4ZWREYXRlICsgbGFzdERhdGUgLSAxLCBkYXlPZldlZWspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlIGFyZSBvbiB0aGUgZmlyc3QgZGF5IG9mIHRoZSB5ZWFyLlxuICAgICAgaWYgKHNlbGYuaXNTZXQoREFZX09GX1lFQVIpKSB7XG4gICAgICAgIGZpeGVkRGF0ZSArPSBmaWVsZHNbREFZX09GX1lFQVJdIC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpcnN0RGF5T2ZXZWVrID0gZ2V0RGF5T2ZXZWVrRGF0ZU9uT3JCZWZvcmUoZml4ZWREYXRlICsgNiwgZmlyc3REYXlPZldlZWtDZmcpO1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGVub3VnaCBkYXlzIGluIHRoZSBmaXJzdCB3ZWVrLCB0aGVuIG1vdmVcbiAgICAgICAgLy8gdG8gdGhlIHByZXZpb3VzIHdlZWsuXG4gICAgICAgIGlmIChmaXJzdERheU9mV2VlayAtIGZpeGVkRGF0ZSA+PSBzZWxmLm1pbmltYWxEYXlzSW5GaXJzdFdlZWspIHtcbiAgICAgICAgICBmaXJzdERheU9mV2VlayAtPSA3O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXlPZldlZWsgIT09IGZpcnN0RGF5T2ZXZWVrQ2ZnKSB7XG4gICAgICAgICAgZmlyc3REYXlPZldlZWsgPSBnZXREYXlPZldlZWtEYXRlT25PckJlZm9yZShmaXJzdERheU9mV2VlayArIDYsIGRheU9mV2Vlayk7XG4gICAgICAgIH1cbiAgICAgICAgZml4ZWREYXRlID0gZmlyc3REYXlPZldlZWsgKyA3ICogKGZpZWxkc1tXRUVLX09GX1lFQVJdIC0gMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpeGVkRGF0ZTtcbiAgfSxcblxuICAvKlxuICAgKiBSZXR1cm5zIHRoaXMgQ2FsZW5kYXIncyB0aW1lIHZhbHVlIGluIG1pbGxpc2Vjb25kc1xuICAgKiBAbWVtYmVyIERhdGUuR3JlZ29yaWFuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBjdXJyZW50IHRpbWUgYXMgVVRDIG1pbGxpc2Vjb25kcyBmcm9tIHRoZSBlcG9jaC5cbiAgICovXG4gIGdldFRpbWU6IGZ1bmN0aW9uIGdldFRpbWUoKSB7XG4gICAgaWYgKHRoaXMudGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmNvbXB1dGVUaW1lKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRpbWU7XG4gIH0sXG5cbiAgLypcbiAgICogU2V0cyB0aGlzIENhbGVuZGFyJ3MgY3VycmVudCB0aW1lIGZyb20gdGhlIGdpdmVuIGxvbmcgdmFsdWUuXG4gICAqIEBwYXJhbSB0aW1lIHRoZSBuZXcgdGltZSBpbiBVVEMgbWlsbGlzZWNvbmRzIGZyb20gdGhlIGVwb2NoLlxuICAgKi9cbiAgc2V0VGltZTogZnVuY3Rpb24gc2V0VGltZSh0aW1lKSB7XG4gICAgdGhpcy50aW1lID0gdGltZTtcbiAgICB0aGlzLmZpZWxkc0NvbXB1dGVkID0gZmFsc2U7XG4gICAgdGhpcy5jb21wbGV0ZSgpO1xuICB9LFxuXG4gIC8qXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQHBhcmFtIGZpZWxkIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQHJldHVybnMge051bWJlcn0gdGhlIHZhbHVlIGZvciB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqL1xuICBnZXQ6IGZ1bmN0aW9uIGdldChmaWVsZCkge1xuICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICByZXR1cm4gdGhpcy5maWVsZHNbZmllbGRdO1xuICB9LFxuXG4gIC8qXG4gICAqIFJldHVybnMgdGhlIHllYXIgb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIGdldFllYXJcbiAgICogQHJldHVybnMge051bWJlcn0gdGhlIHllYXIgZm9yIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogUmV0dXJucyB0aGUgbW9udGggb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIGdldE1vbnRoXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBtb250aCBmb3IgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKi9cblxuICAvKlxuICAgKiBSZXR1cm5zIHRoZSBkYXkgb2YgbW9udGggb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIGdldERheU9mTW9udGhcbiAgICogQHJldHVybnMge051bWJlcn0gdGhlIGRheSBvZiBtb250aCBmb3IgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKi9cblxuICAvKlxuICAgKiBSZXR1cm5zIHRoZSBob3VyIG9mIGRheSBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2QgZ2V0SG91ck9mRGF5XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBob3VyIG9mIGRheSBmb3IgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKi9cblxuICAvKlxuICAgKiBSZXR1cm5zIHRoZSBtaW51dGUgb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIGdldE1pbnV0ZVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgbWludXRlIGZvciB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqL1xuXG4gIC8qXG4gICAqIFJldHVybnMgdGhlIHNlY29uZCBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2QgZ2V0U2Vjb25kXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBzZWNvbmQgZm9yIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogUmV0dXJucyB0aGUgbWlsbGlzZWNvbmQgb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIGdldE1pbGxpU2Vjb25kXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBtaWxsaXNlY29uZCBmb3IgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKi9cblxuICAvKlxuICAgKiBSZXR1cm5zIHRoZSB3ZWVrIG9mIHllYXIgb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIGdldFdlZWtPZlllYXJcbiAgICogQHJldHVybnMge051bWJlcn0gdGhlIHdlZWsgb2YgeWVhciBmb3IgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKi9cblxuICAvKlxuICAgKiBSZXR1cm5zIHRoZSB3ZWVrIG9mIG1vbnRoIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBnZXRXZWVrT2ZNb250aFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgd2VlayBvZiBtb250aCBmb3IgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKi9cblxuICAvKlxuICAgKiBSZXR1cm5zIHRoZSBkYXkgb2YgeWVhciBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2QgZ2V0RGF5T2ZZZWFyXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBkYXkgb2YgeWVhciBmb3IgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKi9cblxuICAvKlxuICAgKiBSZXR1cm5zIHRoZSBkYXkgb2Ygd2VlayBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2QgZ2V0RGF5T2ZXZWVrXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBkYXkgb2Ygd2VlayBmb3IgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKi9cblxuICAvKlxuICAgKiBSZXR1cm5zIHRoZSBkYXkgb2Ygd2VlayBpbiBtb250aCBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2QgZ2V0RGF5T2ZXZWVrSW5Nb250aFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgZGF5IG9mIHdlZWsgaW4gbW9udGggZm9yIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogU2V0cyB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQgdG8gdGhlIGdpdmVuIHZhbHVlLlxuICAgKiBAcGFyYW0gZmllbGQgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAcGFyYW0gdiB0aGUgdmFsdWUgdG8gYmUgc2V0IGZvciB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqL1xuICBzZXQ6IGZ1bmN0aW9uIHNldChmaWVsZCwgdikge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmIChsZW4gPT09IDIpIHtcbiAgICAgIHRoaXMuZmllbGRzW2ZpZWxkXSA9IHY7XG4gICAgfSBlbHNlIGlmIChsZW4gPCBNSUxMSVNFQ09ORFMgKyAxKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuZmllbGRzW1lFQVIgKyBpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbGxlZ2FsIGFyZ3VtZW50cyBmb3IgR3JlZ29yaWFuQ2FsZW5kYXIgc2V0Jyk7XG4gICAgfVxuICAgIHRoaXMudGltZSA9IHVuZGVmaW5lZDtcbiAgfSxcblxuICAvKlxuICAgKiBTZXQgdGhlIHllYXIgb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIHNldFllYXJcbiAgICovXG5cbiAgLypcbiAgICogU2V0IHRoZSBtb250aCBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2Qgc2V0TW9udGhcbiAgICovXG5cbiAgLypcbiAgICogU2V0IHRoZSBkYXkgb2YgbW9udGggb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIHNldERheU9mTW9udGhcbiAgICovXG5cbiAgLypcbiAgICogU2V0IHRoZSBob3VyIG9mIGRheSBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2Qgc2V0SG91ck9mRGF5XG4gICAqL1xuXG4gIC8qXG4gICAqIFNldCB0aGUgbWludXRlIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBzZXRNaW51dGVcbiAgICovXG5cbiAgLypcbiAgICogU2V0IHRoZSBzZWNvbmQgb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIHNldFNlY29uZFxuICAgKi9cblxuICAvKlxuICAgKiBTZXQgdGhlIG1pbGxpc2Vjb25kIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBzZXRNaWxsaVNlY29uZFxuICAgKi9cblxuICAvKlxuICAgKiBTZXQgdGhlIHdlZWsgb2YgeWVhciBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2Qgc2V0V2Vla09mWWVhclxuICAgKi9cblxuICAvKlxuICAgKiBTZXQgdGhlIHdlZWsgb2YgbW9udGggb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIHNldFdlZWtPZk1vbnRoXG4gICAqL1xuXG4gIC8qXG4gICAqIFNldCB0aGUgZGF5IG9mIHllYXIgb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIHNldERheU9mWWVhclxuICAgKi9cblxuICAvKlxuICAgKiBTZXQgdGhlIGRheSBvZiB3ZWVrIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBzZXREYXlPZldlZWtcbiAgICovXG5cbiAgLypcbiAgICogU2V0IHRoZSBkYXkgb2Ygd2VlayBpbiBtb250aCBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2Qgc2V0RGF5T2ZXZWVrSW5Nb250aFxuICAgKi9cblxuICAvKlxuICAgKiBhZGQgZm9yIHNwZWNpZmllZCBmaWVsZCBiYXNlZCBvbiB0d28gcnVsZXM6XG4gICAqXG4gICAqICAtIEFkZCBydWxlIDEuIFRoZSB2YWx1ZSBvZiBmaWVsZCBhZnRlciB0aGUgY2FsbCBtaW51cyB0aGUgdmFsdWUgb2YgZmllbGQgYmVmb3JlIHRoZVxuICAgKiAgY2FsbCBpcyBhbW91bnQsIG1vZHVsbyBhbnkgb3ZlcmZsb3cgdGhhdCBoYXMgb2NjdXJyZWQgaW4gZmllbGRcbiAgICogIE92ZXJmbG93IG9jY3VycyB3aGVuIGEgZmllbGQgdmFsdWUgZXhjZWVkcyBpdHMgcmFuZ2UgYW5kLFxuICAgKiAgYXMgYSByZXN1bHQsIHRoZSBuZXh0IGxhcmdlciBmaWVsZCBpcyBpbmNyZW1lbnRlZCBvclxuICAgKiAgZGVjcmVtZW50ZWQgYW5kIHRoZSBmaWVsZCB2YWx1ZSBpcyBhZGp1c3RlZCBiYWNrIGludG8gaXRzIHJhbmdlLlxuICAgKlxuICAgKiAgLSBBZGQgcnVsZSAyLiBJZiBhIHNtYWxsZXIgZmllbGQgaXMgZXhwZWN0ZWQgdG8gYmUgaW52YXJpYW50LFxuICAgKiAgYnV0IGl0IGlzIGltcG9zc2libGUgZm9yIGl0IHRvIGJlIGVxdWFsIHRvIGl0c1xuICAgKiAgcHJpb3IgdmFsdWUgYmVjYXVzZSBvZiBjaGFuZ2VzIGluIGl0cyBtaW5pbXVtIG9yIG1heGltdW0gYWZ0ZXJcbiAgICogIGZpZWxkIGlzIGNoYW5nZWQsIHRoZW4gaXRzIHZhbHVlIGlzIGFkanVzdGVkIHRvIGJlIGFzIGNsb3NlXG4gICAqICBhcyBwb3NzaWJsZSB0byBpdHMgZXhwZWN0ZWQgdmFsdWUuIEEgc21hbGxlciBmaWVsZCByZXByZXNlbnRzIGFcbiAgICogIHNtYWxsZXIgdW5pdCBvZiB0aW1lLiBIT1VSX09GX0RBWSBpcyBhIHNtYWxsZXIgZmllbGQgdGhhblxuICAgKiAgREFZX09GX01PTlRILiBObyBhZGp1c3RtZW50IGlzIG1hZGUgdG8gc21hbGxlciBmaWVsZHNcbiAgICogIHRoYXQgYXJlIG5vdCBleHBlY3RlZCB0byBiZSBpbnZhcmlhbnQuIFRoZSBjYWxlbmRhciBzeXN0ZW1cbiAgICogIGRldGVybWluZXMgd2hhdCBmaWVsZHMgYXJlIGV4cGVjdGVkIHRvIGJlIGludmFyaWFudC5cbiAgICpcbiAgICpcbiAgICogICAgICBAZXhhbXBsZVxuICAgKiAgICAgIHVzZSgnZGF0ZS9ncmVnb3JpYW4nLGZ1bmN0aW9uKFMsIEdyZWdvcmlhbkNhbGVuZGFyKXtcbiAgICogICAgICAgICAgY29uc3QgZCA9IG5ldyBHcmVnb3JpYW5DYWxlbmRhcigpO1xuICAgKiAgICAgICAgICBkLnNldCgyMDEyLCBHcmVnb3JpYW5DYWxlbmRhci5KQU5VQVJZLCAzMSk7XG4gICAqICAgICAgICAgIGQuYWRkKEdyZWdvcmlhbi5NT05USCwxKTtcbiAgICogICAgICAgICAgLy8gMjAxMi0yLTI5XG4gICAqICAgICAgICAgIGRvY3VtZW50LndyaXRlbG4oJzxwPicrZC5nZXRZZWFyKCkrJy0nK2QuZ2V0TW9udGgoKSsnLScrZC5nZXREYXlPZldlZWsoKSlcbiAgICogICAgICAgICAgZC5hZGQoR3JlZ29yaWFuLk1PTlRILDEyKTtcbiAgICogICAgICAgICAgLy8gMjAxMy0yLTI4XG4gICAqICAgICAgICAgIGRvY3VtZW50LndyaXRlbG4oJzxwPicrZC5nZXRZZWFyKCkrJy0nK2QuZ2V0TW9udGgoKSsnLScrZC5nZXREYXlPZldlZWsoKSlcbiAgICogICAgICB9KTtcbiAgICpcbiAgICogQHBhcmFtIGZpZWxkIHRoZSBjYWxlbmRhciBmaWVsZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCBoZSBhbW91bnQgb2YgZGF0ZSBvciB0aW1lIHRvIGJlIGFkZGVkIHRvIHRoZSBmaWVsZC5cbiAgICovXG4gIGFkZDogZnVuY3Rpb24gYWRkKGZpZWxkLCBhKSB7XG4gICAgaWYgKCFhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBhbW91bnQgPSBhO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZmllbGRzID0gc2VsZi5maWVsZHM7XG4gICAgLy8gY29tcHV0ZXIgYW5kIHJldHJpZXZlIG9yaWdpbmFsIHZhbHVlXG4gICAgdmFyIHZhbHVlID0gc2VsZi5nZXQoZmllbGQpO1xuICAgIGlmIChmaWVsZCA9PT0gWUVBUikge1xuICAgICAgdmFsdWUgKz0gYW1vdW50O1xuICAgICAgc2VsZi5zZXQoWUVBUiwgdmFsdWUpO1xuICAgICAgYWRqdXN0RGF5T2ZNb250aChzZWxmKTtcbiAgICB9IGVsc2UgaWYgKGZpZWxkID09PSBNT05USCkge1xuICAgICAgdmFsdWUgKz0gYW1vdW50O1xuICAgICAgdmFyIHllYXJBbW91bnQgPSBmbG9vckRpdmlkZSh2YWx1ZSAvIDEyKTtcbiAgICAgIHZhbHVlID0gbW9kKHZhbHVlLCAxMik7XG4gICAgICBpZiAoeWVhckFtb3VudCkge1xuICAgICAgICBzZWxmLnNldChZRUFSLCBmaWVsZHNbWUVBUl0gKyB5ZWFyQW1vdW50KTtcbiAgICAgIH1cbiAgICAgIHNlbGYuc2V0KE1PTlRILCB2YWx1ZSk7XG4gICAgICBhZGp1c3REYXlPZk1vbnRoKHNlbGYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGZpZWxkKSB7XG4gICAgICAgIGNhc2UgSE9VUl9PRl9EQVk6XG4gICAgICAgICAgYW1vdW50ICo9IE9ORV9IT1VSO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE1JTlVURTpcbiAgICAgICAgICBhbW91bnQgKj0gT05FX01JTlVURTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTRUNPTkRTOlxuICAgICAgICAgIGFtb3VudCAqPSBPTkVfU0VDT05EO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE1JTExJU0VDT05EUzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBXRUVLX09GX01PTlRIOlxuICAgICAgICBjYXNlIFdFRUtfT0ZfWUVBUjpcbiAgICAgICAgY2FzZSBEQVlfT0ZfV0VFS19JTl9NT05USDpcbiAgICAgICAgICBhbW91bnQgKj0gT05FX1dFRUs7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgREFZX09GX1dFRUs6XG4gICAgICAgIGNhc2UgREFZX09GX1lFQVI6XG4gICAgICAgIGNhc2UgREFZX09GX01PTlRIOlxuICAgICAgICAgIGFtb3VudCAqPSBPTkVfREFZO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaWxsZWdhbCBmaWVsZCBmb3IgYWRkJyk7XG4gICAgICB9XG4gICAgICBzZWxmLnNldFRpbWUoc2VsZi50aW1lICsgYW1vdW50KTtcbiAgICB9XG4gIH0sXG5cbiAgLypcbiAgICogYWRkIHRoZSB5ZWFyIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBhZGRZZWFyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgdGhlIHNpZ25lZCBhbW91bnQgdG8gYWRkIHRvIGZpZWxkLlxuICAgKi9cblxuICAvKlxuICAgKiBhZGQgdGhlIG1vbnRoIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBhZGRNb250aFxuICAgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IHRoZSBzaWduZWQgYW1vdW50IHRvIGFkZCB0byBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogYWRkIHRoZSBkYXkgb2YgbW9udGggb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIGFkZERheU9mTW9udGhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCB0aGUgc2lnbmVkIGFtb3VudCB0byBhZGQgdG8gZmllbGQuXG4gICAqL1xuXG4gIC8qXG4gICAqIGFkZCB0aGUgaG91ciBvZiBkYXkgb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIGFkZEhvdXJPZkRheVxuICAgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IHRoZSBzaWduZWQgYW1vdW50IHRvIGFkZCB0byBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogYWRkIHRoZSBtaW51dGUgb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIGFkZE1pbnV0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IHRoZSBzaWduZWQgYW1vdW50IHRvIGFkZCB0byBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogYWRkIHRoZSBzZWNvbmQgb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIGFkZFNlY29uZFxuICAgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IHRoZSBzaWduZWQgYW1vdW50IHRvIGFkZCB0byBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogYWRkIHRoZSBtaWxsaXNlY29uZCBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2QgYWRkTWlsbGlTZWNvbmRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCB0aGUgc2lnbmVkIGFtb3VudCB0byBhZGQgdG8gZmllbGQuXG4gICAqL1xuXG4gIC8qXG4gICAqIGFkZCB0aGUgd2VlayBvZiB5ZWFyIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBhZGRXZWVrT2ZZZWFyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgdGhlIHNpZ25lZCBhbW91bnQgdG8gYWRkIHRvIGZpZWxkLlxuICAgKi9cblxuICAvKlxuICAgKiBhZGQgdGhlIHdlZWsgb2YgbW9udGggb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIGFkZFdlZWtPZk1vbnRoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgdGhlIHNpZ25lZCBhbW91bnQgdG8gYWRkIHRvIGZpZWxkLlxuICAgKi9cblxuICAvKlxuICAgKiBhZGQgdGhlIGRheSBvZiB5ZWFyIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBhZGREYXlPZlllYXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCB0aGUgc2lnbmVkIGFtb3VudCB0byBhZGQgdG8gZmllbGQuXG4gICAqL1xuXG4gIC8qXG4gICAqIGFkZCB0aGUgZGF5IG9mIHdlZWsgb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIGFkZERheU9mV2Vla1xuICAgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IHRoZSBzaWduZWQgYW1vdW50IHRvIGFkZCB0byBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogYWRkIHRoZSBkYXkgb2Ygd2VlayBpbiBtb250aCBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2QgYWRkRGF5T2ZXZWVrSW5Nb250aFxuICAgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IHRoZSBzaWduZWQgYW1vdW50IHRvIGFkZCB0byBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogR2V0IHJvbGxlZCB2YWx1ZSBmb3IgdGhlIGZpZWxkXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGdldFJvbGxlZFZhbHVlOiBmdW5jdGlvbiBnZXRSb2xsZWRWYWx1ZSh2YWx1ZSwgYSwgbWluLCBtYXgpIHtcbiAgICB2YXIgYW1vdW50ID0gYTtcbiAgICB2YXIgZGlmZiA9IHZhbHVlIC0gbWluO1xuICAgIHZhciByYW5nZSA9IG1heCAtIG1pbiArIDE7XG4gICAgYW1vdW50ICU9IHJhbmdlO1xuICAgIHJldHVybiBtaW4gKyAoZGlmZiArIGFtb3VudCArIHJhbmdlKSAlIHJhbmdlO1xuICB9LFxuXG4gIC8qXG4gICAqIEFkZHMgYSBzaWduZWQgYW1vdW50IHRvIHRoZSBzcGVjaWZpZWQgY2FsZW5kYXIgZmllbGQgd2l0aG91dCBjaGFuZ2luZyBsYXJnZXIgZmllbGRzLlxuICAgKiBBIG5lZ2F0aXZlIHJvbGwgYW1vdW50IG1lYW5zIHRvIHN1YnRyYWN0IGZyb20gZmllbGQgd2l0aG91dCBjaGFuZ2luZ1xuICAgKiBsYXJnZXIgZmllbGRzLiBJZiB0aGUgc3BlY2lmaWVkIGFtb3VudCBpcyAwLCB0aGlzIG1ldGhvZCBwZXJmb3JtcyBub3RoaW5nLlxuICAgKlxuICAgKlxuICAgKlxuICAgKiAgICAgIEBleGFtcGxlXG4gICAqICAgICAgY29uc3QgZCA9IG5ldyBHcmVnb3JpYW5DYWxlbmRhcigpO1xuICAgKiAgICAgIGQuc2V0KDE5OTksIEdyZWdvcmlhbkNhbGVuZGFyLkFVR1VTVCwgMzEpO1xuICAgKiAgICAgIC8vIDE5OTktNC0zMFxuICAgKiAgICAgIC8vIFR1ZXNkYXkgSnVuZSAxLCAxOTk5XG4gICAqICAgICAgZC5zZXQoMTk5OSwgR3JlZ29yaWFuQ2FsZW5kYXIuSlVORSwgMSk7XG4gICAqICAgICAgZC5hZGQoR3JlZ29yaWFuLldFRUtfT0ZfTU9OVEgsLTEpOyAvLyA9PT0gZC5hZGQoR3JlZ29yaWFuLldFRUtfT0ZfTU9OVEgsXG4gICAqICAgICAgZC5nZXQoR3JlZ29yaWFuLldFRUtfT0ZfTU9OVEgpKTtcbiAgICogICAgICAvLyAxOTk5LTA2LTI5XG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSBmaWVsZCB0aGUgY2FsZW5kYXIgZmllbGQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgdGhlIHNpZ25lZCBhbW91bnQgdG8gYWRkIHRvIGZpZWxkLlxuICAgKi9cbiAgcm9sbDogZnVuY3Rpb24gcm9sbChmaWVsZCwgYW1vdW50KSB7XG4gICAgaWYgKCFhbW91bnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIC8vIGNvbXB1dGVyIGFuZCByZXRyaWV2ZSBvcmlnaW5hbCB2YWx1ZVxuICAgIHZhciB2YWx1ZSA9IHNlbGYuZ2V0KGZpZWxkKTtcbiAgICB2YXIgbWluID0gc2VsZi5nZXRBY3R1YWxNaW5pbXVtKGZpZWxkKTtcbiAgICB2YXIgbWF4ID0gc2VsZi5nZXRBY3R1YWxNYXhpbXVtKGZpZWxkKTtcbiAgICB2YWx1ZSA9IHNlbGYuZ2V0Um9sbGVkVmFsdWUodmFsdWUsIGFtb3VudCwgbWluLCBtYXgpO1xuXG4gICAgc2VsZi5zZXQoZmllbGQsIHZhbHVlKTtcblxuICAgIC8vIGNvbnNpZGVyIGNvbXB1dGUgdGltZSBwcmlvcml0eVxuICAgIHN3aXRjaCAoZmllbGQpIHtcbiAgICAgIGNhc2UgTU9OVEg6XG4gICAgICAgIGFkanVzdERheU9mTW9udGgoc2VsZik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gb3RoZXIgZmllbGRzIGFyZSBzZXQgYWxyZWFkeSB3aGVuIGdldFxuICAgICAgICBzZWxmLnVwZGF0ZUZpZWxkc0J5U2V0KGZpZWxkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9LFxuXG4gIC8qXG4gICAqIGtlZXAgZmllbGQgc3RhYmxlLlxuICAgKlxuICAgKiAyMDE1LTA5LTI5IHNldE1vbnRoIDIgdnMgcm9sbFNldE1vbnRoIDJcbiAgICpcbiAgICovXG4gIHJvbGxTZXQ6IGZ1bmN0aW9uIHJvbGxTZXQoZmllbGQsIHYpIHtcbiAgICB0aGlzLnNldChmaWVsZCwgdik7XG4gICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgY2FzZSBNT05USDpcbiAgICAgICAgYWRqdXN0RGF5T2ZNb250aCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBvdGhlciBmaWVsZHMgYXJlIHNldCBhbHJlYWR5IHdoZW4gZ2V0XG4gICAgICAgIHRoaXMudXBkYXRlRmllbGRzQnlTZXQoZmllbGQpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0sXG5cbiAgLypcbiAgICogcm9sbCB0aGUgeWVhciBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2Qgcm9sbFllYXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCB0aGUgc2lnbmVkIGFtb3VudCB0byBhZGQgdG8gZmllbGQuXG4gICAqL1xuXG4gIC8qXG4gICAqIHJvbGwgdGhlIG1vbnRoIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCB0aGUgc2lnbmVkIGFtb3VudCB0byBhZGQgdG8gZmllbGQuXG4gICAqIEBtZXRob2Qgcm9sbE1vbnRoXG4gICAqL1xuXG4gIC8qXG4gICAqIHJvbGwgdGhlIGRheSBvZiBtb250aCBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2Qgcm9sbERheU9mTW9udGhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCB0aGUgc2lnbmVkIGFtb3VudCB0byBhZGQgdG8gZmllbGQuXG4gICAqL1xuXG4gIC8qXG4gICAqIHJvbGwgdGhlIGhvdXIgb2YgZGF5IG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCByb2xsSG91ck9mRGF5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgdGhlIHNpZ25lZCBhbW91bnQgdG8gYWRkIHRvIGZpZWxkLlxuICAgKi9cblxuICAvKlxuICAgKiByb2xsIHRoZSBtaW51dGUgb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIHJvbGxNaW51dGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCB0aGUgc2lnbmVkIGFtb3VudCB0byBhZGQgdG8gZmllbGQuXG4gICAqL1xuXG4gIC8qXG4gICAqIHJvbGwgdGhlIHNlY29uZCBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2Qgcm9sbFNlY29uZFxuICAgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IHRoZSBzaWduZWQgYW1vdW50IHRvIGFkZCB0byBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogcm9sbCB0aGUgbWlsbGlzZWNvbmQgb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIHJvbGxNaWxsaVNlY29uZFxuICAgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IHRoZSBzaWduZWQgYW1vdW50IHRvIGFkZCB0byBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogcm9sbCB0aGUgd2VlayBvZiB5ZWFyIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCByb2xsV2Vla09mWWVhclxuICAgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IHRoZSBzaWduZWQgYW1vdW50IHRvIGFkZCB0byBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogcm9sbCB0aGUgd2VlayBvZiBtb250aCBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2Qgcm9sbFdlZWtPZk1vbnRoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgdGhlIHNpZ25lZCBhbW91bnQgdG8gYWRkIHRvIGZpZWxkLlxuICAgKi9cblxuICAvKlxuICAgKiByb2xsIHRoZSBkYXkgb2YgeWVhciBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2Qgcm9sbERheU9mWWVhclxuICAgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IHRoZSBzaWduZWQgYW1vdW50IHRvIGFkZCB0byBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogcm9sbCB0aGUgZGF5IG9mIHdlZWsgb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIHJvbGxEYXlPZldlZWtcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCB0aGUgc2lnbmVkIGFtb3VudCB0byBhZGQgdG8gZmllbGQuXG4gICAqL1xuXG4gIC8qXG4gICAqIHJlbW92ZSBvdGhlciBwcmlvcml0eSBmaWVsZHMgd2hlbiBjYWxsIGdldEZpeGVkRGF0ZVxuICAgKiBwcmVjb25kaXRpb246IG90aGVyIGZpZWxkcyBhcmUgYWxsIHNldCBvciBjb21wdXRlZFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICB1cGRhdGVGaWVsZHNCeVNldDogZnVuY3Rpb24gdXBkYXRlRmllbGRzQnlTZXQoZmllbGQpIHtcbiAgICB2YXIgZmllbGRzID0gdGhpcy5maWVsZHM7XG4gICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgY2FzZSBXRUVLX09GX01PTlRIOlxuICAgICAgICBmaWVsZHNbREFZX09GX01PTlRIXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERBWV9PRl9ZRUFSOlxuICAgICAgICBmaWVsZHNbTU9OVEhdID0gdW5kZWZpbmVkO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgREFZX09GX1dFRUs6XG4gICAgICAgIGZpZWxkc1tEQVlfT0ZfTU9OVEhdID0gdW5kZWZpbmVkO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgV0VFS19PRl9ZRUFSOlxuICAgICAgICBmaWVsZHNbREFZX09GX1lFQVJdID0gdW5kZWZpbmVkO1xuICAgICAgICBmaWVsZHNbTU9OVEhdID0gdW5kZWZpbmVkO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSxcblxuICAvKlxuICAgKiBnZXQgY3VycmVudCBkYXRlIGluc3RhbmNlJ3MgdGltZXpvbmUgb2Zmc2V0XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRUaW1lem9uZU9mZnNldDogZnVuY3Rpb24gZ2V0VGltZXpvbmVPZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGltZXpvbmVPZmZzZXQ7XG4gIH0sXG5cbiAgLypcbiAgICogc2V0IGN1cnJlbnQgZGF0ZSBpbnN0YW5jZSdzIHRpbWV6b25lIG9mZnNldFxuICAgKi9cbiAgc2V0VGltZXpvbmVPZmZzZXQ6IGZ1bmN0aW9uIHNldFRpbWV6b25lT2Zmc2V0KHRpbWV6b25lT2Zmc2V0KSB7XG4gICAgaWYgKHRoaXMudGltZXpvbmVPZmZzZXQgIT09IHRpbWV6b25lT2Zmc2V0KSB7XG4gICAgICB0aGlzLmZpZWxkc0NvbXB1dGVkID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy50aW1lem9uZU9mZnNldCA9IHRpbWV6b25lT2Zmc2V0O1xuICAgIH1cbiAgfSxcblxuICAvKlxuICAgKiBzZXQgZmlyc3QgZGF5IG9mIHdlZWsgZm9yIGN1cnJlbnQgZGF0ZSBpbnN0YW5jZVxuICAgKi9cbiAgc2V0Rmlyc3REYXlPZldlZWs6IGZ1bmN0aW9uIHNldEZpcnN0RGF5T2ZXZWVrKGZpcnN0RGF5T2ZXZWVrKSB7XG4gICAgaWYgKHRoaXMuZmlyc3REYXlPZldlZWsgIT09IGZpcnN0RGF5T2ZXZWVrKSB7XG4gICAgICB0aGlzLmZpcnN0RGF5T2ZXZWVrID0gZmlyc3REYXlPZldlZWs7XG4gICAgICB0aGlzLmZpZWxkc0NvbXB1dGVkID0gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qXG4gICAqIEdldHMgd2hhdCB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrIGlzOyBlLmcuLCBTVU5EQVkgaW4gdGhlIFUuUy4sIE1PTkRBWSBpbiBGcmFuY2UuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAqL1xuICBnZXRGaXJzdERheU9mV2VlazogZnVuY3Rpb24gZ2V0Rmlyc3REYXlPZldlZWsoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlyc3REYXlPZldlZWs7XG4gIH0sXG5cbiAgLypcbiAgICogU2V0cyB3aGF0IHRoZSBtaW5pbWFsIGRheXMgcmVxdWlyZWQgaW4gdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIgYXJlOyBGb3IgZXhhbXBsZSxcbiAgICogaWYgdGhlIGZpcnN0IHdlZWsgaXMgZGVmaW5lZCBhcyBvbmUgdGhhdCBjb250YWlucyB0aGUgZmlyc3QgZGF5IG9mIHRoZSBmaXJzdCBtb250aCBvZiBhIHllYXIsXG4gICAqIGNhbGwgdGhpcyBtZXRob2Qgd2l0aCB2YWx1ZSAxLlxuICAgKiBJZiBpdCBtdXN0IGJlIGEgZnVsbCB3ZWVrLCB1c2UgdmFsdWUgNy5cbiAgICogQHBhcmFtIG1pbmltYWxEYXlzSW5GaXJzdFdlZWsgdGhlIGdpdmVuIG1pbmltYWwgZGF5cyByZXF1aXJlZCBpbiB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICovXG4gIHNldE1pbmltYWxEYXlzSW5GaXJzdFdlZWs6IGZ1bmN0aW9uIHNldE1pbmltYWxEYXlzSW5GaXJzdFdlZWsobWluaW1hbERheXNJbkZpcnN0V2Vlaykge1xuICAgIGlmICh0aGlzLm1pbmltYWxEYXlzSW5GaXJzdFdlZWsgIT09IG1pbmltYWxEYXlzSW5GaXJzdFdlZWspIHtcbiAgICAgIHRoaXMubWluaW1hbERheXNJbkZpcnN0V2VlayA9IG1pbmltYWxEYXlzSW5GaXJzdFdlZWs7XG4gICAgICB0aGlzLmZpZWxkc0NvbXB1dGVkID0gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qXG4gICAqIEdldHMgd2hhdCB0aGUgbWluaW1hbCBkYXlzIHJlcXVpcmVkIGluIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyIGFyZTsgZS5nLixcbiAgICogaWYgdGhlIGZpcnN0IHdlZWsgaXMgZGVmaW5lZCBhcyBvbmUgdGhhdCBjb250YWlucyB0aGUgZmlyc3QgZGF5IG9mIHRoZSBmaXJzdCBtb250aCBvZiBhIHllYXIsXG4gICAqIHRoaXMgbWV0aG9kIHJldHVybnMgMS5cbiAgICogSWYgdGhlIG1pbmltYWwgZGF5cyByZXF1aXJlZCBtdXN0IGJlIGEgZnVsbCB3ZWVrLCB0aGlzIG1ldGhvZCByZXR1cm5zIDcuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBtaW5pbWFsIGRheXMgcmVxdWlyZWQgaW4gdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAqL1xuICBnZXRNaW5pbWFsRGF5c0luRmlyc3RXZWVrOiBmdW5jdGlvbiBnZXRNaW5pbWFsRGF5c0luRmlyc3RXZWVrKCkge1xuICAgIHJldHVybiB0aGlzLm1pbmltYWxEYXlzSW5GaXJzdFdlZWs7XG4gIH0sXG5cbiAgLypcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHdlZWtzIGluIHRoZSB3ZWVrIHllYXJcbiAgICogcmVwcmVzZW50ZWQgYnkgdGhpcyBHcmVnb3JpYW5DYWxlbmRhci5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUsIGlmIHRoaXMgR3JlZ29yaWFuQ2FsZW5kYXIncyBkYXRlIGlzXG4gICAqIERlY2VtYmVyIDMxLCAyMDA4IHdpdGggdGhlIElTT1xuICAgKiA4NjAxIGNvbXBhdGlibGUgc2V0dGluZywgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gNTMgZm9yIHRoZVxuICAgKiBwZXJpb2Q6IERlY2VtYmVyIDI5LCAyMDA4IHRvIEphbnVhcnkgMywgMjAxMFxuICAgKiB3aGlsZSBnZXRBY3R1YWxNYXhpbXVtKFdFRUtfT0ZfWUVBUikgd2lsbCByZXR1cm5cbiAgICogNTIgZm9yIHRoZSBwZXJpb2Q6IERlY2VtYmVyIDMxLCAyMDA3IHRvIERlY2VtYmVyIDI4LCAyMDA4LlxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBudW1iZXIgb2Ygd2Vla3MgaW4gdGhlIHdlZWsgeWVhci5cbiAgICovXG4gIGdldFdlZWtzSW5XZWVrWWVhcjogZnVuY3Rpb24gZ2V0V2Vla3NJbldlZWtZZWFyKCkge1xuICAgIHZhciB3ZWVrWWVhciA9IHRoaXMuZ2V0V2Vla1llYXIoKTtcbiAgICBpZiAod2Vla1llYXIgPT09IHRoaXMuZ2V0KFlFQVIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRBY3R1YWxNYXhpbXVtKFdFRUtfT0ZfWUVBUik7XG4gICAgfVxuICAgIC8vIFVzZSB0aGUgMm5kIHdlZWsgZm9yIGNhbGN1bGF0aW5nIHRoZSBtYXggb2YgV0VFS19PRl9ZRUFSXG4gICAgdmFyIGdjID0gdGhpcy5jbG9uZSgpO1xuICAgIGdjLmNsZWFyKCk7XG4gICAgZ2Muc2V0V2Vla0RhdGUod2Vla1llYXIsIDIsIHRoaXMuZ2V0KERBWV9PRl9XRUVLKSk7XG4gICAgcmV0dXJuIGdjLmdldEFjdHVhbE1heGltdW0oV0VFS19PRl9ZRUFSKTtcbiAgfSxcblxuICAvKlxuICAgKiBSZXR1cm5zIHRoZSB3ZWVrIHllYXIgcmVwcmVzZW50ZWQgYnkgdGhpcyBHcmVnb3JpYW5DYWxlbmRhci5cbiAgICogVGhlIGRhdGVzIGluIHRoZSB3ZWVrcyBiZXR3ZWVuIDEgYW5kIHRoZVxuICAgKiBtYXhpbXVtIHdlZWsgbnVtYmVyIG9mIHRoZSB3ZWVrIHllYXIgaGF2ZSB0aGUgc2FtZSB3ZWVrIHllYXIgdmFsdWVcbiAgICogdGhhdCBtYXkgYmUgb25lIHllYXIgYmVmb3JlIG9yIGFmdGVyIHRoZSBjYWxlbmRhciB5ZWFyIHZhbHVlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSB3ZWVrIHllYXIgcmVwcmVzZW50ZWQgYnkgdGhpcyBHcmVnb3JpYW5DYWxlbmRhci5cbiAgICovXG4gIGdldFdlZWtZZWFyOiBmdW5jdGlvbiBnZXRXZWVrWWVhcigpIHtcbiAgICB2YXIgeWVhciA9IHRoaXMuZ2V0KFlFQVIpOyAvLyBpbXBsaWNpdGx5ICBjb21wbGV0ZVxuICAgIHZhciB3ZWVrT2ZZZWFyID0gdGhpcy5nZXQoV0VFS19PRl9ZRUFSKTtcbiAgICB2YXIgbW9udGggPSB0aGlzLmdldChNT05USCk7XG4gICAgaWYgKG1vbnRoID09PSBHcmVnb3JpYW5DYWxlbmRhci5KQU5VQVJZKSB7XG4gICAgICBpZiAod2Vla09mWWVhciA+PSA1Mikge1xuICAgICAgICAtLXllYXI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtb250aCA9PT0gR3JlZ29yaWFuQ2FsZW5kYXIuREVDRU1CRVIpIHtcbiAgICAgIGlmICh3ZWVrT2ZZZWFyID09PSAxKSB7XG4gICAgICAgICsreWVhcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHllYXI7XG4gIH0sXG4gIC8qXG4gICAqIFNldHMgdGhpcyBHcmVnb3JpYW5DYWxlbmRhciB0byB0aGUgZGF0ZSBnaXZlbiBieSB0aGUgZGF0ZSBzcGVjaWZpZXJzIC0gd2Vla1llYXIsXG4gICAqIHdlZWtPZlllYXIsIGFuZCBkYXlPZldlZWsuIHdlZWtPZlllYXIgZm9sbG93cyB0aGUgV0VFS19PRl9ZRUFSIG51bWJlcmluZy5cbiAgICogVGhlIGRheU9mV2VlayB2YWx1ZSBtdXN0IGJlIG9uZSBvZiB0aGUgREFZX09GX1dFRUsgdmFsdWVzOiBTVU5EQVkgdG8gU0FUVVJEQVkuXG4gICAqXG4gICAqIEBwYXJhbSB3ZWVrWWVhciAgICB0aGUgd2VlayB5ZWFyXG4gICAqIEBwYXJhbSB3ZWVrT2ZZZWFyICB0aGUgd2VlayBudW1iZXIgYmFzZWQgb24gd2Vla1llYXJcbiAgICogQHBhcmFtIGRheU9mV2VlayAgIHRoZSBkYXkgb2Ygd2VlayB2YWx1ZVxuICAgKi9cbiAgc2V0V2Vla0RhdGU6IGZ1bmN0aW9uIHNldFdlZWtEYXRlKHdlZWtZZWFyLCB3ZWVrT2ZZZWFyLCBkYXlPZldlZWspIHtcbiAgICBpZiAoZGF5T2ZXZWVrIDwgR3JlZ29yaWFuQ2FsZW5kYXIuU1VOREFZIHx8IGRheU9mV2VlayA+IEdyZWdvcmlhbkNhbGVuZGFyLlNBVFVSREFZKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZGF5T2ZXZWVrOiAnICsgZGF5T2ZXZWVrKTtcbiAgICB9XG4gICAgdmFyIGZpZWxkcyA9IHRoaXMuZmllbGRzO1xuICAgIC8vIFRvIGF2b2lkIGNoYW5naW5nIHRoZSB0aW1lIG9mIGRheSBmaWVsZHMgYnkgZGF0ZVxuICAgIC8vIGNhbGN1bGF0aW9ucywgdXNlIGEgY2xvbmUgd2l0aCB0aGUgR01UIHRpbWUgem9uZS5cbiAgICB2YXIgZ2MgPSB0aGlzLmNsb25lKCk7XG4gICAgZ2MuY2xlYXIoKTtcbiAgICBnYy5zZXRUaW1lem9uZU9mZnNldCgwKTtcbiAgICBnYy5zZXQoWUVBUiwgd2Vla1llYXIpO1xuICAgIGdjLnNldChXRUVLX09GX1lFQVIsIDEpO1xuICAgIGdjLnNldChEQVlfT0ZfV0VFSywgdGhpcy5nZXRGaXJzdERheU9mV2VlaygpKTtcbiAgICB2YXIgZGF5cyA9IGRheU9mV2VlayAtIHRoaXMuZ2V0Rmlyc3REYXlPZldlZWsoKTtcbiAgICBpZiAoZGF5cyA8IDApIHtcbiAgICAgIGRheXMgKz0gNztcbiAgICB9XG4gICAgZGF5cyArPSA3ICogKHdlZWtPZlllYXIgLSAxKTtcbiAgICBpZiAoZGF5cyAhPT0gMCkge1xuICAgICAgZ2MuYWRkKERBWV9PRl9ZRUFSLCBkYXlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2MuY29tcGxldGUoKTtcbiAgICB9XG4gICAgZmllbGRzW1lFQVJdID0gZ2MuZ2V0KFlFQVIpO1xuICAgIGZpZWxkc1tNT05USF0gPSBnYy5nZXQoTU9OVEgpO1xuICAgIGZpZWxkc1tEQVlfT0ZfTU9OVEhdID0gZ2MuZ2V0KERBWV9PRl9NT05USCk7XG4gICAgdGhpcy5jb21wbGV0ZSgpO1xuICB9LFxuICAvKlxuICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgY29weSBvZiB0aGlzIG9iamVjdC5cbiAgICogQHJldHVybnMge0RhdGUuR3JlZ29yaWFufVxuICAgKi9cbiAgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgIGlmICh0aGlzLnRpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5jb21wdXRlVGltZSgpO1xuICAgIH1cbiAgICB2YXIgY2FsID0gbmV3IEdyZWdvcmlhbkNhbGVuZGFyKHRoaXMubG9jYWxlKTtcbiAgICBjYWwuc2V0VGltZXpvbmVPZmZzZXQoY2FsLmdldFRpbWV6b25lT2Zmc2V0KCkpO1xuICAgIGNhbC5zZXRGaXJzdERheU9mV2VlayhjYWwuZ2V0Rmlyc3REYXlPZldlZWsoKSk7XG4gICAgY2FsLnNldE1pbmltYWxEYXlzSW5GaXJzdFdlZWsoY2FsLmdldE1pbmltYWxEYXlzSW5GaXJzdFdlZWsoKSk7XG4gICAgY2FsLnNldFRpbWUodGhpcy50aW1lKTtcbiAgICByZXR1cm4gY2FsO1xuICB9LFxuXG4gIC8qXG4gICAqIENvbXBhcmVzIHRoaXMgR3JlZ29yaWFuQ2FsZW5kYXIgdG8gdGhlIHNwZWNpZmllZCBPYmplY3QuXG4gICAqIFRoZSByZXN1bHQgaXMgdHJ1ZSBpZiBhbmQgb25seSBpZiB0aGUgYXJndW1lbnQgaXMgYSBHcmVnb3JpYW5DYWxlbmRhciBvYmplY3RcbiAgICogdGhhdCByZXByZXNlbnRzIHRoZSBzYW1lIHRpbWUgdmFsdWUgKG1pbGxpc2Vjb25kIG9mZnNldCBmcm9tIHRoZSBFcG9jaClcbiAgICogdW5kZXIgdGhlIHNhbWUgQ2FsZW5kYXIgcGFyYW1ldGVycyBhbmQgR3JlZ29yaWFuIGNoYW5nZSBkYXRlIGFzIHRoaXMgb2JqZWN0LlxuICAgKiBAcGFyYW0ge0RhdGUuR3JlZ29yaWFufSBvYmogdGhlIG9iamVjdCB0byBjb21wYXJlIHdpdGguXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoaXMgb2JqZWN0IGlzIGVxdWFsIHRvIG9iajsgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZXF1YWxzOiBmdW5jdGlvbiBlcXVhbHMob2JqKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VGltZSgpID09PSBvYmouZ2V0VGltZSgpICYmIHRoaXMuZmlyc3REYXlPZldlZWsgPT09IG9iai5maXJzdERheU9mV2VlayAmJiB0aGlzLnRpbWV6b25lT2Zmc2V0ID09PSBvYmoudGltZXpvbmVPZmZzZXQgJiYgdGhpcy5taW5pbWFsRGF5c0luRmlyc3RXZWVrID09PSBvYmoubWluaW1hbERheXNJbkZpcnN0V2VlaztcbiAgfSxcblxuICAvKlxuICAgKiBTZXRzIGFsbCB0aGUgY2FsZW5kYXIgZmllbGQgdmFsdWVzIG9yIHNwZWNpZmllZCBmaWVsZCBhbmQgdGhlIHRpbWUgdmFsdWVcbiAgICogKG1pbGxpc2Vjb25kIG9mZnNldCBmcm9tIHRoZSBFcG9jaCkgb2YgdGhpcyBDYWxlbmRhciB1bmRlZmluZWQuXG4gICAqIFRoaXMgbWVhbnMgdGhhdCBpc1NldCgpIHdpbGwgcmV0dXJuIGZhbHNlIGZvciBhbGwgdGhlIGNhbGVuZGFyIGZpZWxkcyxcbiAgICogYW5kIHRoZSBkYXRlIGFuZCB0aW1lIGNhbGN1bGF0aW9ucyB3aWxsIHRyZWF0IHRoZSBmaWVsZHMgYXMgaWYgdGhleSBoYWQgbmV2ZXIgYmVlbiBzZXQuXG4gICAqIEBwYXJhbSBbZmllbGRdIHRoZSBjYWxlbmRhciBmaWVsZCB0byBiZSBjbGVhcmVkLlxuICAgKi9cbiAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKGZpZWxkKSB7XG4gICAgaWYgKGZpZWxkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZmllbGQgPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5maWVsZHNbZmllbGRdID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0aGlzLnRpbWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5maWVsZHNDb21wdXRlZCA9IGZhbHNlO1xuICB9XG59O1xuXG52YXIgR3JlZ29yaWFuQ2FsZW5kYXJQcm90byA9IEdyZWdvcmlhbkNhbGVuZGFyLnByb3RvdHlwZTtcblxuVXRpbHMuZWFjaChGSUVMRFMsIGZ1bmN0aW9uIChmLCBpbmRleCkge1xuICBpZiAoZikge1xuICAgIEdyZWdvcmlhbkNhbGVuZGFyUHJvdG9bJ2dldCcgKyBmXSA9IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldChpbmRleCk7XG4gICAgfTtcblxuICAgIEdyZWdvcmlhbkNhbGVuZGFyUHJvdG9bJ2lzU2V0JyArIGZdID0gZnVuY3Rpb24gaXNTZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1NldChpbmRleCk7XG4gICAgfTtcblxuICAgIEdyZWdvcmlhbkNhbGVuZGFyUHJvdG9bJ3NldCcgKyBmXSA9IGZ1bmN0aW9uIHNldCh2KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXQoaW5kZXgsIHYpO1xuICAgIH07XG5cbiAgICBHcmVnb3JpYW5DYWxlbmRhclByb3RvWydhZGQnICsgZl0gPSBmdW5jdGlvbiBhZGQodikge1xuICAgICAgcmV0dXJuIHRoaXMuYWRkKGluZGV4LCB2KTtcbiAgICB9O1xuXG4gICAgR3JlZ29yaWFuQ2FsZW5kYXJQcm90b1sncm9sbCcgKyBmXSA9IGZ1bmN0aW9uIHJvbGwodikge1xuICAgICAgcmV0dXJuIHRoaXMucm9sbChpbmRleCwgdik7XG4gICAgfTtcblxuICAgIEdyZWdvcmlhbkNhbGVuZGFyUHJvdG9bJ3JvbGxTZXQnICsgZl0gPSBmdW5jdGlvbiByb2xsU2V0KHYpIHtcbiAgICAgIHJldHVybiB0aGlzLnJvbGxTZXQoaW5kZXgsIHYpO1xuICAgIH07XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyZWdvcmlhbkNhbGVuZGFyO1xuLypcbiBodHRwOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS83L2RvY3MvYXBpL2phdmEvdXRpbC9HcmVnb3JpYW5DYWxlbmRhci5odG1sXG5cbiBUT0RPXG4gLSBkYXkgc2F2aW5nIHRpbWVcbiAtIGkxOG5cbiAtIGp1bGlhbiBjYWxlbmRhclxuICovXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL34vZ3JlZ29yaWFuLWNhbGVuZGFyL2xpYi9ncmVnb3JpYW4tY2FsZW5kYXIuanNcbiAqKi8iLCIvKipcbiAqIGVuLXVzIGxvY2FsZVxuICogQGlnbm9yZVxuICogQGF1dGhvciB5aW1pbmdoZUBnbWFpbC5jb21cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGVyYXM6IFsnQkMnLCAnQUQnXSxcbiAgbW9udGhzOiBbJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsXG4gICAgJ0F1Z3VzdCcsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddLFxuICBzaG9ydE1vbnRoczogWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgJ09jdCcsICdOb3YnLCAnRGVjJ10sXG4gIHdlZWtkYXlzOiBbJ1N1bmRheScsICdNb25kYXknLCAnVHVlc2RheScsICdXZWRuZXNkYXknLCAnVGh1cnNkYXknLCAnRnJpZGF5JyxcbiAgICAnU2F0dXJkYXknXSxcbiAgc2hvcnRXZWVrZGF5czogWydTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnXSxcbiAgdmVyeVNob3J0V2Vla2RheXM6IFsnU3UnLCAnTW8nLCAnVHUnLCAnV2UnLCAnVGgnLCAnRnInLCAnU2EnXSxcbiAgYW1wbXM6IFsnQU0nLCAnUE0nXSxcbiAgZGF0ZVBhdHRlcm5zOiBbJ0VFRUUsIE1NTU0gZCwgeXl5eScsICdNTU1NIGQsIHl5eXknLCAnTU1NIGQsIHl5eXknLCAnTS9kL3l5J10sXG4gIHRpbWVQYXR0ZXJuczogWydoOm1tOnNzIGEgXFwnR01UXFwnWicsICdoOm1tOnNzIGEnLCAnaDptbTpzcyBhJywgJ2g6bW0gYSddLFxuICBkYXRlVGltZVBhdHRlcm46ICd7ZGF0ZX0ge3RpbWV9J1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9+L3V4Y29yZS1jYWxlbmRhci9+L2dyZWdvcmlhbi1jYWxlbmRhci1mb3JtYXQvbGliL2xvY2FsZS9lbi11cy5qc1xuICoqLyIsInZhciBzZWVkID0gMDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gRGF0ZS5ub3coKSArICdfJyArIChzZWVkKyspO1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLXV0aWwvbGliL2d1aWQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgZmlsZSBjb250YWlucyBhbiB1bm1vZGlmaWVkIHZlcnNpb24gb2Y6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi92MC4xMi4wL3NyYy92ZW5kb3Ivc3R1YnMvY3guanNcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBoZXJlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvdjAuMTIuMC9MSUNFTlNFXG4gKiBBbiBhZGRpdGlvbmFsIGdyYW50IG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGhlcmU6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi92MC4xMi4wL1BBVEVOVFNcbiAqL1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBtYXJrIHN0cmluZyBsaXRlcmFscyByZXByZXNlbnRpbmcgQ1NTIGNsYXNzIG5hbWVzXG4gKiBzbyB0aGF0IHRoZXkgY2FuIGJlIHRyYW5zZm9ybWVkIHN0YXRpY2FsbHkuIFRoaXMgYWxsb3dzIGZvciBtb2R1bGFyaXphdGlvblxuICogYW5kIG1pbmlmaWNhdGlvbiBvZiBDU1MgY2xhc3MgbmFtZXMuXG4gKlxuICogSW4gc3RhdGljX3Vwc3RyZWFtLCB0aGlzIGZ1bmN0aW9uIGlzIGFjdHVhbGx5IGltcGxlbWVudGVkLCBidXQgaXQgc2hvdWxkXG4gKiBldmVudHVhbGx5IGJlIHJlcGxhY2VkIHdpdGggc29tZXRoaW5nIG1vcmUgZGVzY3JpcHRpdmUsIGFuZCB0aGUgdHJhbnNmb3JtXG4gKiB0aGF0IGlzIHVzZWQgaW4gdGhlIG1haW4gc3RhY2sgc2hvdWxkIGJlIHBvcnRlZCBmb3IgdXNlIGVsc2V3aGVyZS5cbiAqXG4gKiBAcGFyYW0gc3RyaW5nfG9iamVjdCBjbGFzc05hbWUgdG8gbW9kdWxhcml6ZSwgb3IgYW4gb2JqZWN0IG9mIGtleS92YWx1ZXMuXG4gKiAgICAgICAgICAgICAgICAgICAgICBJbiB0aGUgb2JqZWN0IGNhc2UsIHRoZSB2YWx1ZXMgYXJlIGNvbmRpdGlvbnMgdGhhdFxuICogICAgICAgICAgICAgICAgICAgICAgZGV0ZXJtaW5lIGlmIHRoZSBjbGFzc05hbWUga2V5cyBzaG91bGQgYmUgaW5jbHVkZWQuXG4gKiBAcGFyYW0gW3N0cmluZyAuLi5dICBWYXJpYWJsZSBsaXN0IG9mIGNsYXNzTmFtZXMgaW4gdGhlIHN0cmluZyBjYXNlLlxuICogQHJldHVybiBzdHJpbmcgICAgICAgUmVuZGVyYWJsZSBzcGFjZS1zZXBhcmF0ZWQgQ1NTIGNsYXNzTmFtZS5cbiAqL1xuZnVuY3Rpb24gY3goY2xhc3NOYW1lcykge1xuICBpZiAodHlwZW9mIGNsYXNzTmFtZXMgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGNsYXNzTmFtZXMpLmZpbHRlcihmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgICAgIHJldHVybiBjbGFzc05hbWVzW2NsYXNzTmFtZV07XG4gICAgfSkuam9pbignICcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuam9pbi5jYWxsKGFyZ3VtZW50cywgJyAnKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGN4O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtdXRpbC9saWIvY2xhc3NTZXQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgZmlsZSBjb250YWlucyBhbiB1bm1vZGlmaWVkIHZlcnNpb24gb2Y6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi92MC4xMi4wL3NyYy91dGlscy9qb2luQ2xhc3Nlcy5qc1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGhlcmU6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi92MC4xMi4wL0xJQ0VOU0VcbiAqIEFuIGFkZGl0aW9uYWwgZ3JhbnQgb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaGVyZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL3YwLjEyLjAvUEFURU5UU1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvbWJpbmVzIG11bHRpcGxlIGNsYXNzTmFtZSBzdHJpbmdzIGludG8gb25lLlxuICogaHR0cDovL2pzcGVyZi5jb20vam9pbmNsYXNzZXMtYXJncy12cy1hcnJheVxuICpcbiAqIEBwYXJhbSB7Li4uP3N0cmluZ30gY2xhc3Nlc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGpvaW5DbGFzc2VzKGNsYXNzTmFtZSAvKiwgLi4uICovICkge1xuICBpZiAoIWNsYXNzTmFtZSkge1xuICAgIGNsYXNzTmFtZSA9ICcnO1xuICB9XG4gIHZhciBuZXh0Q2xhc3M7XG4gIHZhciBhcmdMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICBpZiAoYXJnTGVuZ3RoID4gMSkge1xuICAgIGZvciAodmFyIGlpID0gMTsgaWkgPCBhcmdMZW5ndGg7IGlpKyspIHtcbiAgICAgIG5leHRDbGFzcyA9IGFyZ3VtZW50c1tpaV07XG4gICAgICBpZiAobmV4dENsYXNzKSB7XG4gICAgICAgIGNsYXNzTmFtZSA9IChjbGFzc05hbWUgPyBjbGFzc05hbWUgKyAnICcgOiAnJykgKyBuZXh0Q2xhc3M7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjbGFzc05hbWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gam9pbkNsYXNzZXM7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vfi91eGNvcmUtY2FsZW5kYXIvfi9yYy11dGlsL2xpYi9qb2luQ2xhc3Nlcy5qc1xuICoqLyIsIi8qKlxuICogQGlnbm9yZVxuICogc29tZSBrZXktY29kZXMgZGVmaW5pdGlvbiBhbmQgdXRpbHMgZnJvbSBjbG9zdXJlLWxpYnJhcnlcbiAqIEBhdXRob3IgeWltaW5naGVAZ21haWwuY29tXG4gKi9cblxudmFyIEtleUNvZGUgPSB7XG4gIC8qKlxuICAgKiBNQUNfRU5URVJcbiAgICovXG4gIE1BQ19FTlRFUjogMyxcbiAgLyoqXG4gICAqIEJBQ0tTUEFDRVxuICAgKi9cbiAgQkFDS1NQQUNFOiA4LFxuICAvKipcbiAgICogVEFCXG4gICAqL1xuICBUQUI6IDksXG4gIC8qKlxuICAgKiBOVU1MT0NLIG9uIEZGL1NhZmFyaSBNYWNcbiAgICovXG4gIE5VTV9DRU5URVI6IDEyLCAvLyBOVU1MT0NLIG9uIEZGL1NhZmFyaSBNYWNcbiAgLyoqXG4gICAqIEVOVEVSXG4gICAqL1xuICBFTlRFUjogMTMsXG4gIC8qKlxuICAgKiBTSElGVFxuICAgKi9cbiAgU0hJRlQ6IDE2LFxuICAvKipcbiAgICogQ1RSTFxuICAgKi9cbiAgQ1RSTDogMTcsXG4gIC8qKlxuICAgKiBBTFRcbiAgICovXG4gIEFMVDogMTgsXG4gIC8qKlxuICAgKiBQQVVTRVxuICAgKi9cbiAgUEFVU0U6IDE5LFxuICAvKipcbiAgICogQ0FQU19MT0NLXG4gICAqL1xuICBDQVBTX0xPQ0s6IDIwLFxuICAvKipcbiAgICogRVNDXG4gICAqL1xuICBFU0M6IDI3LFxuICAvKipcbiAgICogU1BBQ0VcbiAgICovXG4gIFNQQUNFOiAzMixcbiAgLyoqXG4gICAqIFBBR0VfVVBcbiAgICovXG4gIFBBR0VfVVA6IDMzLCAvLyBhbHNvIE5VTV9OT1JUSF9FQVNUXG4gIC8qKlxuICAgKiBQQUdFX0RPV05cbiAgICovXG4gIFBBR0VfRE9XTjogMzQsIC8vIGFsc28gTlVNX1NPVVRIX0VBU1RcbiAgLyoqXG4gICAqIEVORFxuICAgKi9cbiAgRU5EOiAzNSwgLy8gYWxzbyBOVU1fU09VVEhfV0VTVFxuICAvKipcbiAgICogSE9NRVxuICAgKi9cbiAgSE9NRTogMzYsIC8vIGFsc28gTlVNX05PUlRIX1dFU1RcbiAgLyoqXG4gICAqIExFRlRcbiAgICovXG4gIExFRlQ6IDM3LCAvLyBhbHNvIE5VTV9XRVNUXG4gIC8qKlxuICAgKiBVUFxuICAgKi9cbiAgVVA6IDM4LCAvLyBhbHNvIE5VTV9OT1JUSFxuICAvKipcbiAgICogUklHSFRcbiAgICovXG4gIFJJR0hUOiAzOSwgLy8gYWxzbyBOVU1fRUFTVFxuICAvKipcbiAgICogRE9XTlxuICAgKi9cbiAgRE9XTjogNDAsIC8vIGFsc28gTlVNX1NPVVRIXG4gIC8qKlxuICAgKiBQUklOVF9TQ1JFRU5cbiAgICovXG4gIFBSSU5UX1NDUkVFTjogNDQsXG4gIC8qKlxuICAgKiBJTlNFUlRcbiAgICovXG4gIElOU0VSVDogNDUsIC8vIGFsc28gTlVNX0lOU0VSVFxuICAvKipcbiAgICogREVMRVRFXG4gICAqL1xuICBERUxFVEU6IDQ2LCAvLyBhbHNvIE5VTV9ERUxFVEVcbiAgLyoqXG4gICAqIFpFUk9cbiAgICovXG4gIFpFUk86IDQ4LFxuICAvKipcbiAgICogT05FXG4gICAqL1xuICBPTkU6IDQ5LFxuICAvKipcbiAgICogVFdPXG4gICAqL1xuICBUV086IDUwLFxuICAvKipcbiAgICogVEhSRUVcbiAgICovXG4gIFRIUkVFOiA1MSxcbiAgLyoqXG4gICAqIEZPVVJcbiAgICovXG4gIEZPVVI6IDUyLFxuICAvKipcbiAgICogRklWRVxuICAgKi9cbiAgRklWRTogNTMsXG4gIC8qKlxuICAgKiBTSVhcbiAgICovXG4gIFNJWDogNTQsXG4gIC8qKlxuICAgKiBTRVZFTlxuICAgKi9cbiAgU0VWRU46IDU1LFxuICAvKipcbiAgICogRUlHSFRcbiAgICovXG4gIEVJR0hUOiA1NixcbiAgLyoqXG4gICAqIE5JTkVcbiAgICovXG4gIE5JTkU6IDU3LFxuICAvKipcbiAgICogUVVFU1RJT05fTUFSS1xuICAgKi9cbiAgUVVFU1RJT05fTUFSSzogNjMsIC8vIG5lZWRzIGxvY2FsaXphdGlvblxuICAvKipcbiAgICogQVxuICAgKi9cbiAgQTogNjUsXG4gIC8qKlxuICAgKiBCXG4gICAqL1xuICBCOiA2NixcbiAgLyoqXG4gICAqIENcbiAgICovXG4gIEM6IDY3LFxuICAvKipcbiAgICogRFxuICAgKi9cbiAgRDogNjgsXG4gIC8qKlxuICAgKiBFXG4gICAqL1xuICBFOiA2OSxcbiAgLyoqXG4gICAqIEZcbiAgICovXG4gIEY6IDcwLFxuICAvKipcbiAgICogR1xuICAgKi9cbiAgRzogNzEsXG4gIC8qKlxuICAgKiBIXG4gICAqL1xuICBIOiA3MixcbiAgLyoqXG4gICAqIElcbiAgICovXG4gIEk6IDczLFxuICAvKipcbiAgICogSlxuICAgKi9cbiAgSjogNzQsXG4gIC8qKlxuICAgKiBLXG4gICAqL1xuICBLOiA3NSxcbiAgLyoqXG4gICAqIExcbiAgICovXG4gIEw6IDc2LFxuICAvKipcbiAgICogTVxuICAgKi9cbiAgTTogNzcsXG4gIC8qKlxuICAgKiBOXG4gICAqL1xuICBOOiA3OCxcbiAgLyoqXG4gICAqIE9cbiAgICovXG4gIE86IDc5LFxuICAvKipcbiAgICogUFxuICAgKi9cbiAgUDogODAsXG4gIC8qKlxuICAgKiBRXG4gICAqL1xuICBROiA4MSxcbiAgLyoqXG4gICAqIFJcbiAgICovXG4gIFI6IDgyLFxuICAvKipcbiAgICogU1xuICAgKi9cbiAgUzogODMsXG4gIC8qKlxuICAgKiBUXG4gICAqL1xuICBUOiA4NCxcbiAgLyoqXG4gICAqIFVcbiAgICovXG4gIFU6IDg1LFxuICAvKipcbiAgICogVlxuICAgKi9cbiAgVjogODYsXG4gIC8qKlxuICAgKiBXXG4gICAqL1xuICBXOiA4NyxcbiAgLyoqXG4gICAqIFhcbiAgICovXG4gIFg6IDg4LFxuICAvKipcbiAgICogWVxuICAgKi9cbiAgWTogODksXG4gIC8qKlxuICAgKiBaXG4gICAqL1xuICBaOiA5MCxcbiAgLyoqXG4gICAqIE1FVEFcbiAgICovXG4gIE1FVEE6IDkxLCAvLyBXSU5fS0VZX0xFRlRcbiAgLyoqXG4gICAqIFdJTl9LRVlfUklHSFRcbiAgICovXG4gIFdJTl9LRVlfUklHSFQ6IDkyLFxuICAvKipcbiAgICogQ09OVEVYVF9NRU5VXG4gICAqL1xuICBDT05URVhUX01FTlU6IDkzLFxuICAvKipcbiAgICogTlVNX1pFUk9cbiAgICovXG4gIE5VTV9aRVJPOiA5NixcbiAgLyoqXG4gICAqIE5VTV9PTkVcbiAgICovXG4gIE5VTV9PTkU6IDk3LFxuICAvKipcbiAgICogTlVNX1RXT1xuICAgKi9cbiAgTlVNX1RXTzogOTgsXG4gIC8qKlxuICAgKiBOVU1fVEhSRUVcbiAgICovXG4gIE5VTV9USFJFRTogOTksXG4gIC8qKlxuICAgKiBOVU1fRk9VUlxuICAgKi9cbiAgTlVNX0ZPVVI6IDEwMCxcbiAgLyoqXG4gICAqIE5VTV9GSVZFXG4gICAqL1xuICBOVU1fRklWRTogMTAxLFxuICAvKipcbiAgICogTlVNX1NJWFxuICAgKi9cbiAgTlVNX1NJWDogMTAyLFxuICAvKipcbiAgICogTlVNX1NFVkVOXG4gICAqL1xuICBOVU1fU0VWRU46IDEwMyxcbiAgLyoqXG4gICAqIE5VTV9FSUdIVFxuICAgKi9cbiAgTlVNX0VJR0hUOiAxMDQsXG4gIC8qKlxuICAgKiBOVU1fTklORVxuICAgKi9cbiAgTlVNX05JTkU6IDEwNSxcbiAgLyoqXG4gICAqIE5VTV9NVUxUSVBMWVxuICAgKi9cbiAgTlVNX01VTFRJUExZOiAxMDYsXG4gIC8qKlxuICAgKiBOVU1fUExVU1xuICAgKi9cbiAgTlVNX1BMVVM6IDEwNyxcbiAgLyoqXG4gICAqIE5VTV9NSU5VU1xuICAgKi9cbiAgTlVNX01JTlVTOiAxMDksXG4gIC8qKlxuICAgKiBOVU1fUEVSSU9EXG4gICAqL1xuICBOVU1fUEVSSU9EOiAxMTAsXG4gIC8qKlxuICAgKiBOVU1fRElWSVNJT05cbiAgICovXG4gIE5VTV9ESVZJU0lPTjogMTExLFxuICAvKipcbiAgICogRjFcbiAgICovXG4gIEYxOiAxMTIsXG4gIC8qKlxuICAgKiBGMlxuICAgKi9cbiAgRjI6IDExMyxcbiAgLyoqXG4gICAqIEYzXG4gICAqL1xuICBGMzogMTE0LFxuICAvKipcbiAgICogRjRcbiAgICovXG4gIEY0OiAxMTUsXG4gIC8qKlxuICAgKiBGNVxuICAgKi9cbiAgRjU6IDExNixcbiAgLyoqXG4gICAqIEY2XG4gICAqL1xuICBGNjogMTE3LFxuICAvKipcbiAgICogRjdcbiAgICovXG4gIEY3OiAxMTgsXG4gIC8qKlxuICAgKiBGOFxuICAgKi9cbiAgRjg6IDExOSxcbiAgLyoqXG4gICAqIEY5XG4gICAqL1xuICBGOTogMTIwLFxuICAvKipcbiAgICogRjEwXG4gICAqL1xuICBGMTA6IDEyMSxcbiAgLyoqXG4gICAqIEYxMVxuICAgKi9cbiAgRjExOiAxMjIsXG4gIC8qKlxuICAgKiBGMTJcbiAgICovXG4gIEYxMjogMTIzLFxuICAvKipcbiAgICogTlVNTE9DS1xuICAgKi9cbiAgTlVNTE9DSzogMTQ0LFxuICAvKipcbiAgICogU0VNSUNPTE9OXG4gICAqL1xuICBTRU1JQ09MT046IDE4NiwgLy8gbmVlZHMgbG9jYWxpemF0aW9uXG4gIC8qKlxuICAgKiBEQVNIXG4gICAqL1xuICBEQVNIOiAxODksIC8vIG5lZWRzIGxvY2FsaXphdGlvblxuICAvKipcbiAgICogRVFVQUxTXG4gICAqL1xuICBFUVVBTFM6IDE4NywgLy8gbmVlZHMgbG9jYWxpemF0aW9uXG4gIC8qKlxuICAgKiBDT01NQVxuICAgKi9cbiAgQ09NTUE6IDE4OCwgLy8gbmVlZHMgbG9jYWxpemF0aW9uXG4gIC8qKlxuICAgKiBQRVJJT0RcbiAgICovXG4gIFBFUklPRDogMTkwLCAvLyBuZWVkcyBsb2NhbGl6YXRpb25cbiAgLyoqXG4gICAqIFNMQVNIXG4gICAqL1xuICBTTEFTSDogMTkxLCAvLyBuZWVkcyBsb2NhbGl6YXRpb25cbiAgLyoqXG4gICAqIEFQT1NUUk9QSEVcbiAgICovXG4gIEFQT1NUUk9QSEU6IDE5MiwgLy8gbmVlZHMgbG9jYWxpemF0aW9uXG4gIC8qKlxuICAgKiBTSU5HTEVfUVVPVEVcbiAgICovXG4gIFNJTkdMRV9RVU9URTogMjIyLCAvLyBuZWVkcyBsb2NhbGl6YXRpb25cbiAgLyoqXG4gICAqIE9QRU5fU1FVQVJFX0JSQUNLRVRcbiAgICovXG4gIE9QRU5fU1FVQVJFX0JSQUNLRVQ6IDIxOSwgLy8gbmVlZHMgbG9jYWxpemF0aW9uXG4gIC8qKlxuICAgKiBCQUNLU0xBU0hcbiAgICovXG4gIEJBQ0tTTEFTSDogMjIwLCAvLyBuZWVkcyBsb2NhbGl6YXRpb25cbiAgLyoqXG4gICAqIENMT1NFX1NRVUFSRV9CUkFDS0VUXG4gICAqL1xuICBDTE9TRV9TUVVBUkVfQlJBQ0tFVDogMjIxLCAvLyBuZWVkcyBsb2NhbGl6YXRpb25cbiAgLyoqXG4gICAqIFdJTl9LRVlcbiAgICovXG4gIFdJTl9LRVk6IDIyNCxcbiAgLyoqXG4gICAqIE1BQ19GRl9NRVRBXG4gICAqL1xuICBNQUNfRkZfTUVUQTogMjI0LCAvLyBGaXJlZm94IChHZWNrbykgZmlyZXMgdGhpcyBmb3IgdGhlIG1ldGEga2V5IGluc3RlYWQgb2YgOTFcbiAgLyoqXG4gICAqIFdJTl9JTUVcbiAgICovXG4gIFdJTl9JTUU6IDIyOVxufTtcblxuLypcbiB3aGV0aGVyIHRleHQgYW5kIG1vZGlmaWVkIGtleSBpcyBlbnRlcmVkIGF0IHRoZSBzYW1lIHRpbWUuXG4gKi9cbktleUNvZGUuaXNUZXh0TW9kaWZ5aW5nS2V5RXZlbnQgPSBmdW5jdGlvbiAoZSkge1xuICB2YXIga2V5Q29kZSA9IGUua2V5Q29kZTtcbiAgaWYgKGUuYWx0S2V5ICYmICFlLmN0cmxLZXkgfHwgZS5tZXRhS2V5IHx8XG4gICAgICAvLyBGdW5jdGlvbiBrZXlzIGRvbid0IGdlbmVyYXRlIHRleHRcbiAgICBrZXlDb2RlID49IEtleUNvZGUuRjEgJiYga2V5Q29kZSA8PSBLZXlDb2RlLkYxMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRoZSBmb2xsb3dpbmcga2V5cyBhcmUgcXVpdGUgaGFybWxlc3MsIGV2ZW4gaW4gY29tYmluYXRpb24gd2l0aFxuICAvLyBDVFJMLCBBTFQgb3IgU0hJRlQuXG4gIHN3aXRjaCAoa2V5Q29kZSkge1xuICAgIGNhc2UgS2V5Q29kZS5BTFQ6XG4gICAgY2FzZSBLZXlDb2RlLkNBUFNfTE9DSzpcbiAgICBjYXNlIEtleUNvZGUuQ09OVEVYVF9NRU5VOlxuICAgIGNhc2UgS2V5Q29kZS5DVFJMOlxuICAgIGNhc2UgS2V5Q29kZS5ET1dOOlxuICAgIGNhc2UgS2V5Q29kZS5FTkQ6XG4gICAgY2FzZSBLZXlDb2RlLkVTQzpcbiAgICBjYXNlIEtleUNvZGUuSE9NRTpcbiAgICBjYXNlIEtleUNvZGUuSU5TRVJUOlxuICAgIGNhc2UgS2V5Q29kZS5MRUZUOlxuICAgIGNhc2UgS2V5Q29kZS5NQUNfRkZfTUVUQTpcbiAgICBjYXNlIEtleUNvZGUuTUVUQTpcbiAgICBjYXNlIEtleUNvZGUuTlVNTE9DSzpcbiAgICBjYXNlIEtleUNvZGUuTlVNX0NFTlRFUjpcbiAgICBjYXNlIEtleUNvZGUuUEFHRV9ET1dOOlxuICAgIGNhc2UgS2V5Q29kZS5QQUdFX1VQOlxuICAgIGNhc2UgS2V5Q29kZS5QQVVTRTpcbiAgICBjYXNlIEtleUNvZGUuUFJJTlRfU0NSRUVOOlxuICAgIGNhc2UgS2V5Q29kZS5SSUdIVDpcbiAgICBjYXNlIEtleUNvZGUuU0hJRlQ6XG4gICAgY2FzZSBLZXlDb2RlLlVQOlxuICAgIGNhc2UgS2V5Q29kZS5XSU5fS0VZOlxuICAgIGNhc2UgS2V5Q29kZS5XSU5fS0VZX1JJR0hUOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuLypcbiB3aGV0aGVyIGNoYXJhY3RlciBpcyBlbnRlcmVkLlxuICovXG5LZXlDb2RlLmlzQ2hhcmFjdGVyS2V5ID0gZnVuY3Rpb24gKGtleUNvZGUpIHtcbiAgaWYgKGtleUNvZGUgPj0gS2V5Q29kZS5aRVJPICYmXG4gICAga2V5Q29kZSA8PSBLZXlDb2RlLk5JTkUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChrZXlDb2RlID49IEtleUNvZGUuTlVNX1pFUk8gJiZcbiAgICBrZXlDb2RlIDw9IEtleUNvZGUuTlVNX01VTFRJUExZKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoa2V5Q29kZSA+PSBLZXlDb2RlLkEgJiZcbiAgICBrZXlDb2RlIDw9IEtleUNvZGUuWikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gU2FmYXJpIHNlbmRzIHplcm8ga2V5IGNvZGUgZm9yIG5vbi1sYXRpbiBjaGFyYWN0ZXJzLlxuICBpZiAod2luZG93Lm5hdmlnYXRpb24udXNlckFnZW50LmluZGV4T2YoJ1dlYktpdCcpICE9PSAtMSAmJiBrZXlDb2RlID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBzd2l0Y2ggKGtleUNvZGUpIHtcbiAgICBjYXNlIEtleUNvZGUuU1BBQ0U6XG4gICAgY2FzZSBLZXlDb2RlLlFVRVNUSU9OX01BUks6XG4gICAgY2FzZSBLZXlDb2RlLk5VTV9QTFVTOlxuICAgIGNhc2UgS2V5Q29kZS5OVU1fTUlOVVM6XG4gICAgY2FzZSBLZXlDb2RlLk5VTV9QRVJJT0Q6XG4gICAgY2FzZSBLZXlDb2RlLk5VTV9ESVZJU0lPTjpcbiAgICBjYXNlIEtleUNvZGUuU0VNSUNPTE9OOlxuICAgIGNhc2UgS2V5Q29kZS5EQVNIOlxuICAgIGNhc2UgS2V5Q29kZS5FUVVBTFM6XG4gICAgY2FzZSBLZXlDb2RlLkNPTU1BOlxuICAgIGNhc2UgS2V5Q29kZS5QRVJJT0Q6XG4gICAgY2FzZSBLZXlDb2RlLlNMQVNIOlxuICAgIGNhc2UgS2V5Q29kZS5BUE9TVFJPUEhFOlxuICAgIGNhc2UgS2V5Q29kZS5TSU5HTEVfUVVPVEU6XG4gICAgY2FzZSBLZXlDb2RlLk9QRU5fU1FVQVJFX0JSQUNLRVQ6XG4gICAgY2FzZSBLZXlDb2RlLkJBQ0tTTEFTSDpcbiAgICBjYXNlIEtleUNvZGUuQ0xPU0VfU1FVQVJFX0JSQUNLRVQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEtleUNvZGU7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vfi91eGNvcmUtY2FsZW5kYXIvfi9yYy11dGlsL2xpYi9LZXlDb2RlLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHNoYWxsb3dFcXVhbFxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFBlcmZvcm1zIGVxdWFsaXR5IGJ5IGl0ZXJhdGluZyB0aHJvdWdoIGtleXMgb24gYW4gb2JqZWN0IGFuZCByZXR1cm5pbmdcbiAqIGZhbHNlIHdoZW4gYW55IGtleSBoYXMgdmFsdWVzIHdoaWNoIGFyZSBub3Qgc3RyaWN0bHkgZXF1YWwgYmV0d2VlblxuICogb2JqQSBhbmQgb2JqQi4gUmV0dXJucyB0cnVlIHdoZW4gdGhlIHZhbHVlcyBvZiBhbGwga2V5cyBhcmUgc3RyaWN0bHkgZXF1YWwuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKG9iakEgPT09IG9iakIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIga2V5O1xuICAvLyBUZXN0IGZvciBBJ3Mga2V5cyBkaWZmZXJlbnQgZnJvbSBCLlxuICBmb3IgKGtleSBpbiBvYmpBKSB7XG4gICAgaWYgKG9iakEuaGFzT3duUHJvcGVydHkoa2V5KSAmJlxuICAgICAgICAoIW9iakIuaGFzT3duUHJvcGVydHkoa2V5KSB8fCBvYmpBW2tleV0gIT09IG9iakJba2V5XSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gVGVzdCBmb3IgQidzIGtleXMgbWlzc2luZyBmcm9tIEEuXG4gIGZvciAoa2V5IGluIG9iakIpIHtcbiAgICBpZiAob2JqQi5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICFvYmpBLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hhbGxvd0VxdWFsO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtdXRpbC9saWIvc2hhbGxvd0VxdWFsLmpzXG4gKiovIiwiLyoqXG4gKiBTYWZlIGNoYWluZWQgZnVuY3Rpb25cbiAqXG4gKiBXaWxsIG9ubHkgY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIGlmIG5lZWRlZCxcbiAqIG90aGVyd2lzZSB3aWxsIHBhc3MgYmFjayBleGlzdGluZyBmdW5jdGlvbnMgb3IgbnVsbC5cbiAqXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb258bnVsbH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKCkge1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcblxuICByZXR1cm4gZnVuY3Rpb24gY2hhaW5lZEZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFyZ3NbaV0gJiYgYXJnc1tpXS5hcHBseSkge1xuICAgICAgICBhcmdzW2ldLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUNoYWluZWRGdW5jdGlvbjtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLXV0aWwvbGliL2NyZWF0ZUNoYWluZWRGdW5jdGlvbi5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgZXZlbnRUeXBlLCBjYWxsYmFjaykge1xuICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIGlmICh0YXJnZXQuYXR0YWNoRXZlbnQpIHtcbiAgICB0YXJnZXQuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50VHlwZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiB7XG4gICAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGFyZ2V0LmRldGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtdXRpbC9saWIvRG9tL2FkZEV2ZW50TGlzdGVuZXIuanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb290LCBub2RlKSB7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUgPT09IHJvb3QpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLXV0aWwvbGliL0RvbS9jb250YWlucy5qc1xuICoqLyIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNoaWxkcmVuKSB7XG4gIHZhciByZXQgPSBbXTtcbiAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGMpIHtcbiAgICByZXQucHVzaChjKTtcbiAgfSk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtdXRpbC9saWIvQ2hpbGRyZW4vdG9BcnJheS5qc1xuICoqLyIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbmZ1bmN0aW9uIG1pcnJvcihvKSB7XG4gIHJldHVybiBvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAvLyByZXR1cm4gUmVhY3RGcmFnbWVudFxuICByZXR1cm4gUmVhY3QuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBtaXJyb3IpO1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLXV0aWwvbGliL0NoaWxkcmVuL21hcFNlbGYuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgZGVzYyA9IHBhcmVudCA9IGdldHRlciA9IHVuZGVmaW5lZDsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9EYXRlVEhlYWQgPSByZXF1aXJlKCcuL0RhdGVUSGVhZCcpO1xuXG52YXIgX0RhdGVUSGVhZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EYXRlVEhlYWQpO1xuXG52YXIgX0RhdGVUQm9keSA9IHJlcXVpcmUoJy4vRGF0ZVRCb2R5Jyk7XG5cbnZhciBfRGF0ZVRCb2R5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RhdGVUQm9keSk7XG5cbnZhciBEYXRlVGFibGUgPSAoZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKERhdGVUYWJsZSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gRGF0ZVRhYmxlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEYXRlVGFibGUpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoRGF0ZVRhYmxlLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRGF0ZVRhYmxlLCBbe1xuICAgIGtleTogJ3JlbmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICB2YXIgcHJlZml4Q2xzID0gcHJvcHMucHJlZml4Q2xzO1xuICAgICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAndGFibGUnLFxuICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy10YWJsZScsIGNlbGxTcGFjaW5nOiAnMCcsIHJvbGU6ICdncmlkJyB9LFxuICAgICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChfRGF0ZVRIZWFkMlsnZGVmYXVsdCddLCBwcm9wcyksXG4gICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KF9EYXRlVEJvZHkyWydkZWZhdWx0J10sIHByb3BzKVxuICAgICAgKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRGF0ZVRhYmxlO1xufSkoX3JlYWN0MlsnZGVmYXVsdCddLkNvbXBvbmVudCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IERhdGVUYWJsZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9kYXRlL0RhdGVUYWJsZS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBkZXNjID0gcGFyZW50ID0gZ2V0dGVyID0gdW5kZWZpbmVkOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX0RhdGVDb25zdGFudHMgPSByZXF1aXJlKCcuL0RhdGVDb25zdGFudHMnKTtcblxudmFyIF9EYXRlQ29uc3RhbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RhdGVDb25zdGFudHMpO1xuXG52YXIgRGF0ZVRIZWFkID0gKGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhEYXRlVEhlYWQsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIERhdGVUSGVhZCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGF0ZVRIZWFkKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKERhdGVUSGVhZC5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKERhdGVUSGVhZCwgW3tcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gICAgICB2YXIgbG9jYWxlID0gcHJvcHMubG9jYWxlO1xuICAgICAgdmFyIHByZWZpeENscyA9IHByb3BzLnByZWZpeENscztcbiAgICAgIHZhciB2ZXJ5U2hvcnRXZWVrZGF5cyA9IFtdO1xuICAgICAgdmFyIHdlZWtEYXlzID0gW107XG4gICAgICB2YXIgZmlyc3REYXlPZldlZWsgPSB2YWx1ZS5nZXRGaXJzdERheU9mV2VlaygpO1xuICAgICAgdmFyIHNob3dXZWVrTnVtYmVyRWwgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX0RhdGVDb25zdGFudHMyWydkZWZhdWx0J10uREFURV9DT0xfQ09VTlQ7IGkrKykge1xuICAgICAgICB2YXIgaW5kZXggPSAoZmlyc3REYXlPZldlZWsgKyBpKSAlIF9EYXRlQ29uc3RhbnRzMlsnZGVmYXVsdCddLkRBVEVfQ09MX0NPVU5UO1xuICAgICAgICB2ZXJ5U2hvcnRXZWVrZGF5c1tpXSA9IGxvY2FsZS5mb3JtYXQudmVyeVNob3J0V2Vla2RheXNbaW5kZXhdO1xuICAgICAgICB3ZWVrRGF5c1tpXSA9IGxvY2FsZS5mb3JtYXQud2Vla2RheXNbaW5kZXhdO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcHMuc2hvd1dlZWtOdW1iZXIpIHtcbiAgICAgICAgc2hvd1dlZWtOdW1iZXJFbCA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICd0aCcsXG4gICAgICAgICAgeyByb2xlOiAnY29sdW1uaGVhZGVyJywgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWNvbHVtbi1oZWFkZXIgJyArIHByZWZpeENscyArICctd2Vlay1udW1iZXItaGVhZGVyJyB9LFxuICAgICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctY29sdW1uLWhlYWRlci1pbm5lcicgfSxcbiAgICAgICAgICAgICd4J1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZhciB3ZWVrRGF5c0VscyA9IHdlZWtEYXlzLm1hcChmdW5jdGlvbiAoZGF5LCB4aW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICd0aCcsXG4gICAgICAgICAgeyBrZXk6IHhpbmRleCwgcm9sZTogJ2NvbHVtbmhlYWRlcicsIHRpdGxlOiBkYXksIGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1jb2x1bW4taGVhZGVyJyB9LFxuICAgICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctY29sdW1uLWhlYWRlci1pbm5lcicgfSxcbiAgICAgICAgICAgIHZlcnlTaG9ydFdlZWtkYXlzW3hpbmRleF1cbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ3RoZWFkJyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ3RyJyxcbiAgICAgICAgICB7IHJvbGU6ICdyb3cnIH0sXG4gICAgICAgICAgc2hvd1dlZWtOdW1iZXJFbCxcbiAgICAgICAgICB3ZWVrRGF5c0Vsc1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEYXRlVEhlYWQ7XG59KShfcmVhY3QyWydkZWZhdWx0J10uQ29tcG9uZW50KTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gRGF0ZVRIZWFkO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL2RhdGUvRGF0ZVRIZWFkLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHtcbiAgREFURV9ST1dfQ09VTlQ6IDYsXG4gIERBVEVfQ09MX0NPVU5UOiA3XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vfi91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9saWIvZGF0ZS9EYXRlQ29uc3RhbnRzLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IGRlc2MgPSBwYXJlbnQgPSBnZXR0ZXIgPSB1bmRlZmluZWQ7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfRGF0ZUNvbnN0YW50cyA9IHJlcXVpcmUoJy4vRGF0ZUNvbnN0YW50cycpO1xuXG52YXIgX0RhdGVDb25zdGFudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRGF0ZUNvbnN0YW50cyk7XG5cbmZ1bmN0aW9uIGlzU2FtZURheShvbmUsIHR3bykge1xuICByZXR1cm4gb25lLmdldFllYXIoKSA9PT0gdHdvLmdldFllYXIoKSAmJiBvbmUuZ2V0TW9udGgoKSA9PT0gdHdvLmdldE1vbnRoKCkgJiYgb25lLmdldERheU9mTW9udGgoKSA9PT0gdHdvLmdldERheU9mTW9udGgoKTtcbn1cblxuZnVuY3Rpb24gYmVmb3JlQ3VycmVudE1vbnRoWWVhcihjdXJyZW50LCB0b2RheSkge1xuICBpZiAoY3VycmVudC5nZXRZZWFyKCkgPCB0b2RheS5nZXRZZWFyKCkpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gY3VycmVudC5nZXRZZWFyKCkgPT09IHRvZGF5LmdldFllYXIoKSAmJiBjdXJyZW50LmdldE1vbnRoKCkgPCB0b2RheS5nZXRNb250aCgpO1xufVxuXG5mdW5jdGlvbiBhZnRlckN1cnJlbnRNb250aFllYXIoY3VycmVudCwgdG9kYXkpIHtcbiAgaWYgKGN1cnJlbnQuZ2V0WWVhcigpID4gdG9kYXkuZ2V0WWVhcigpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIGN1cnJlbnQuZ2V0WWVhcigpID09PSB0b2RheS5nZXRZZWFyKCkgJiYgY3VycmVudC5nZXRNb250aCgpID4gdG9kYXkuZ2V0TW9udGgoKTtcbn1cblxuZnVuY3Rpb24gZ2V0SWRGcm9tRGF0ZShkKSB7XG4gIHJldHVybiAncmMtY2FsZW5kYXItJyArIGQuZ2V0WWVhcigpICsgJy0nICsgZC5nZXRNb250aCgpICsgJy0nICsgZC5nZXREYXlPZk1vbnRoKCk7XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiBoYW5kbGVEYXlDbGljayhjdXJyZW50KSB7XG4gIHRoaXMucHJvcHMub25TZWxlY3QoY3VycmVudCk7XG59XG5cbnZhciBEYXRlVEJvZHkgPSAoZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKERhdGVUQm9keSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gRGF0ZVRCb2R5KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEYXRlVEJvZHkpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoRGF0ZVRCb2R5LnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRGF0ZVRCb2R5LCBbe1xuICAgIGtleTogJ3JlbmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICB2YXIgaSA9IHVuZGVmaW5lZDtcbiAgICAgIHZhciBqID0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB2YXIgZGF0ZVRhYmxlID0gW107XG4gICAgICB2YXIgc2hvd1dlZWtOdW1iZXIgPSBwcm9wcy5zaG93V2Vla051bWJlcjtcbiAgICAgIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuICAgICAgdmFyIHRvZGF5ID0gdmFsdWUuY2xvbmUoKTtcbiAgICAgIHZhciBwcmVmaXhDbHMgPSBwcm9wcy5wcmVmaXhDbHM7XG4gICAgICB2YXIgY2VsbENsYXNzID0gcHJlZml4Q2xzICsgJy1jZWxsJztcbiAgICAgIHZhciB3ZWVrTnVtYmVyQ2VsbENsYXNzID0gcHJlZml4Q2xzICsgJy13ZWVrLW51bWJlci1jZWxsJztcbiAgICAgIHZhciBkYXRlQ2xhc3MgPSBwcmVmaXhDbHMgKyAnLWRhdGUnO1xuICAgICAgdmFyIGRhdGVSZW5kZXIgPSBwcm9wcy5kYXRlUmVuZGVyO1xuICAgICAgdmFyIGRpc2FibGVkRGF0ZSA9IHByb3BzLmRpc2FibGVkRGF0ZTtcbiAgICAgIHZhciBkYXRlRm9ybWF0dGVyID0gdGhpcy5wcm9wcy5kYXRlRm9ybWF0dGVyO1xuICAgICAgdmFyIHRvZGF5Q2xhc3MgPSBwcmVmaXhDbHMgKyAnLXRvZGF5JztcbiAgICAgIHZhciBzZWxlY3RlZENsYXNzID0gcHJlZml4Q2xzICsgJy1zZWxlY3RlZC1kYXknO1xuICAgICAgdmFyIGxhc3RNb250aERheUNsYXNzID0gcHJlZml4Q2xzICsgJy1sYXN0LW1vbnRoLWNlbGwnO1xuICAgICAgdmFyIG5leHRNb250aERheUNsYXNzID0gcHJlZml4Q2xzICsgJy1uZXh0LW1vbnRoLWJ0bi1kYXknO1xuICAgICAgdmFyIGRpc2FibGVkQ2xhc3MgPSBwcmVmaXhDbHMgKyAnLWRpc2FibGVkLWNlbGwnO1xuICAgICAgdmFyIGZpcnN0RGlzYWJsZUNsYXNzID0gcHJlZml4Q2xzICsgJy1kaXNhYmxlZC1jZWxsLWZpcnN0LW9mLXJvdyc7XG4gICAgICB2YXIgbGFzdERpc2FibGVDbGFzcyA9IHByZWZpeENscyArICctZGlzYWJsZWQtY2VsbC1sYXN0LW9mLXJvdyc7XG4gICAgICB0b2RheS5zZXRUaW1lKERhdGUubm93KCkpO1xuICAgICAgdmFyIG1vbnRoMSA9IHZhbHVlLmNsb25lKCk7XG4gICAgICBtb250aDEuc2V0KHZhbHVlLmdldFllYXIoKSwgdmFsdWUuZ2V0TW9udGgoKSwgMSk7XG4gICAgICB2YXIgZGF5ID0gbW9udGgxLmdldERheU9mV2VlaygpO1xuICAgICAgdmFyIGxhc3RNb250aERpZmZEYXkgPSAoZGF5ICsgNyAtIHZhbHVlLmdldEZpcnN0RGF5T2ZXZWVrKCkpICUgNztcbiAgICAgIC8vIGNhbGN1bGF0ZSBsYXN0IG1vbnRoXG4gICAgICB2YXIgbGFzdE1vbnRoMSA9IG1vbnRoMS5jbG9uZSgpO1xuICAgICAgbGFzdE1vbnRoMS5hZGREYXlPZk1vbnRoKDAgLSBsYXN0TW9udGhEaWZmRGF5KTtcbiAgICAgIHZhciBwYXNzZWQgPSAwO1xuICAgICAgZm9yIChpID0gMDsgaSA8IF9EYXRlQ29uc3RhbnRzMlsnZGVmYXVsdCddLkRBVEVfUk9XX0NPVU5UOyBpKyspIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IF9EYXRlQ29uc3RhbnRzMlsnZGVmYXVsdCddLkRBVEVfQ09MX0NPVU5UOyBqKyspIHtcbiAgICAgICAgICBjdXJyZW50ID0gbGFzdE1vbnRoMTtcbiAgICAgICAgICBpZiAocGFzc2VkKSB7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5jbG9uZSgpO1xuICAgICAgICAgICAgY3VycmVudC5hZGREYXlPZk1vbnRoKHBhc3NlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGVUYWJsZS5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgIHBhc3NlZCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgdGFibGVIdG1sID0gW107XG4gICAgICBwYXNzZWQgPSAwO1xuICAgICAgZm9yIChpID0gMDsgaSA8IF9EYXRlQ29uc3RhbnRzMlsnZGVmYXVsdCddLkRBVEVfUk9XX0NPVU5UOyBpKyspIHtcbiAgICAgICAgdmFyIHdlZWtOdW1iZXJDZWxsID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgZGF0ZUNlbGxzID0gW107XG4gICAgICAgIGlmIChzaG93V2Vla051bWJlcikge1xuICAgICAgICAgIHdlZWtOdW1iZXJDZWxsID0gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAndGQnLFxuICAgICAgICAgICAgeyBrZXk6IGRhdGVUYWJsZVtwYXNzZWRdLmdldFdlZWtPZlllYXIoKSwgcm9sZTogJ2dyaWRjZWxsJyxcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiB3ZWVrTnVtYmVyQ2VsbENsYXNzIH0sXG4gICAgICAgICAgICBkYXRlVGFibGVbcGFzc2VkXS5nZXRXZWVrT2ZZZWFyKClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBfRGF0ZUNvbnN0YW50czJbJ2RlZmF1bHQnXS5EQVRFX0NPTF9DT1VOVDsgaisrKSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBudWxsO1xuICAgICAgICAgIHZhciBsYXN0ID0gbnVsbDtcbiAgICAgICAgICBjdXJyZW50ID0gZGF0ZVRhYmxlW3Bhc3NlZF07XG4gICAgICAgICAgaWYgKGogPCBfRGF0ZUNvbnN0YW50czJbJ2RlZmF1bHQnXS5EQVRFX0NPTF9DT1VOVCAtIDEpIHtcbiAgICAgICAgICAgIG5leHQgPSBkYXRlVGFibGVbcGFzc2VkICsgMV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChqID4gMCkge1xuICAgICAgICAgICAgbGFzdCA9IGRhdGVUYWJsZVtwYXNzZWQgLSAxXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNscyA9IGNlbGxDbGFzcztcbiAgICAgICAgICB2YXIgZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgIGlmIChpc1NhbWVEYXkoY3VycmVudCwgdG9kYXkpKSB7XG4gICAgICAgICAgICBjbHMgKz0gJyAnICsgdG9kYXlDbGFzcztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzU2FtZURheShjdXJyZW50LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNscyArPSAnICcgKyBzZWxlY3RlZENsYXNzO1xuICAgICAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYmVmb3JlQ3VycmVudE1vbnRoWWVhcihjdXJyZW50LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNscyArPSAnICcgKyBsYXN0TW9udGhEYXlDbGFzcztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFmdGVyQ3VycmVudE1vbnRoWWVhcihjdXJyZW50LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNscyArPSAnICcgKyBuZXh0TW9udGhEYXlDbGFzcztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRpc2FibGVkRGF0ZSkge1xuICAgICAgICAgICAgaWYgKGRpc2FibGVkRGF0ZShjdXJyZW50LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgY2xzICs9ICcgJyArIGRpc2FibGVkQ2xhc3M7XG4gICAgICAgICAgICAgIGRpc2FibGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICBpZiAoIWxhc3QgfHwgIWRpc2FibGVkRGF0ZShsYXN0LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjbHMgKz0gJyAnICsgZmlyc3REaXNhYmxlQ2xhc3M7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIW5leHQgfHwgIWRpc2FibGVkRGF0ZShuZXh0LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjbHMgKz0gJyAnICsgbGFzdERpc2FibGVDbGFzcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBkYXRlSHRtbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAoZGF0ZVJlbmRlcikge1xuICAgICAgICAgICAgZGF0ZUh0bWwgPSBkYXRlUmVuZGVyKGN1cnJlbnQsIHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0ZUh0bWwgPSBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAga2V5OiBnZXRJZEZyb21EYXRlKGN1cnJlbnQpLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogZGF0ZUNsYXNzLFxuICAgICAgICAgICAgICAgICdhcmlhLXNlbGVjdGVkJzogc2VsZWN0ZWQsXG4gICAgICAgICAgICAgICAgJ2FyaWEtZGlzYWJsZWQnOiBkaXNhYmxlZCB9LFxuICAgICAgICAgICAgICBjdXJyZW50LmdldERheU9mTW9udGgoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkYXRlQ2VsbHMucHVzaChfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICd0ZCcsXG4gICAgICAgICAgICB7IGtleTogcGFzc2VkLCBvbkNsaWNrOiBkaXNhYmxlZCA/IG5vb3AgOiBoYW5kbGVEYXlDbGljay5iaW5kKHRoaXMsIGN1cnJlbnQpLCByb2xlOiAnZ3JpZGNlbGwnLFxuICAgICAgICAgICAgICB0aXRsZTogZGF0ZUZvcm1hdHRlci5mb3JtYXQoY3VycmVudCksIGNsYXNzTmFtZTogY2xzIH0sXG4gICAgICAgICAgICBkYXRlSHRtbFxuICAgICAgICAgICkpO1xuXG4gICAgICAgICAgcGFzc2VkKys7XG4gICAgICAgIH1cbiAgICAgICAgdGFibGVIdG1sLnB1c2goX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ3RyJyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IGksXG4gICAgICAgICAgICByb2xlOiAncm93JyB9LFxuICAgICAgICAgIHdlZWtOdW1iZXJDZWxsLFxuICAgICAgICAgIGRhdGVDZWxsc1xuICAgICAgICApKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ3Rib2R5JyxcbiAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICd0Ym9keScgfSxcbiAgICAgICAgdGFibGVIdG1sXG4gICAgICApO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEYXRlVEJvZHk7XG59KShfcmVhY3QyWydkZWZhdWx0J10uQ29tcG9uZW50KTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gRGF0ZVRCb2R5O1xuXG5EYXRlVEJvZHkucHJvcFR5cGVzID0ge1xuICBkYXRlRm9ybWF0dGVyOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm9iamVjdFxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9kYXRlL0RhdGVUQm9keS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBkZXNjID0gcGFyZW50ID0gZ2V0dGVyID0gdW5kZWZpbmVkOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX21vbnRoTW9udGhQYW5lbCA9IHJlcXVpcmUoJy4uL21vbnRoL01vbnRoUGFuZWwnKTtcblxudmFyIF9tb250aE1vbnRoUGFuZWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbW9udGhNb250aFBhbmVsKTtcblxudmFyIF9ncmVnb3JpYW5DYWxlbmRhckZvcm1hdCA9IHJlcXVpcmUoJ2dyZWdvcmlhbi1jYWxlbmRhci1mb3JtYXQnKTtcblxudmFyIF9ncmVnb3JpYW5DYWxlbmRhckZvcm1hdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ncmVnb3JpYW5DYWxlbmRhckZvcm1hdCk7XG5cbnZhciBfeWVhclllYXJQYW5lbCA9IHJlcXVpcmUoJy4uL3llYXIvWWVhclBhbmVsJyk7XG5cbnZhciBfeWVhclllYXJQYW5lbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF95ZWFyWWVhclBhbmVsKTtcblxudmFyIF9yY1V0aWwgPSByZXF1aXJlKCdyYy11dGlsJyk7XG5cbnZhciBfcmNVdGlsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JjVXRpbCk7XG5cbnZhciB0b0ZyYWdtZW50ID0gX3JjVXRpbDJbJ2RlZmF1bHQnXS5DaGlsZHJlbi5tYXBTZWxmO1xuXG52YXIgQ2FsZW5kYXJIZWFkZXIgPSAoZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKENhbGVuZGFySGVhZGVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBDYWxlbmRhckhlYWRlcihwcm9wcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYWxlbmRhckhlYWRlcik7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihDYWxlbmRhckhlYWRlci5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5jYWxsKHRoaXMsIHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge307XG4gICAgdGhpcy55ZWFyRm9ybWF0dGVyID0gbmV3IF9ncmVnb3JpYW5DYWxlbmRhckZvcm1hdDJbJ2RlZmF1bHQnXShwcm9wcy5sb2NhbGUueWVhckZvcm1hdCk7XG4gICAgdGhpcy5tb250aEZvcm1hdHRlciA9IG5ldyBfZ3JlZ29yaWFuQ2FsZW5kYXJGb3JtYXQyWydkZWZhdWx0J10ocHJvcHMubG9jYWxlLm1vbnRoRm9ybWF0KTtcbiAgICB0aGlzLnNob3dNb250aFBhbmVsID0gdGhpcy5zaG93TW9udGhQYW5lbC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc2hvd1llYXJQYW5lbCA9IHRoaXMuc2hvd1llYXJQYW5lbC5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25TZWxlY3QgPSB0aGlzLm9uU2VsZWN0LmJpbmQodGhpcyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ2FsZW5kYXJIZWFkZXIsIFt7XG4gICAga2V5OiAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICB2YXIgbG9jYWxlID0gdGhpcy5wcm9wcy5sb2NhbGU7XG4gICAgICBpZiAobmV4dFByb3BzLmxvY2FsZSAhPT0gbG9jYWxlKSB7XG4gICAgICAgIHRoaXMueWVhckZvcm1hdHRlciA9IG5ldyBfZ3JlZ29yaWFuQ2FsZW5kYXJGb3JtYXQyWydkZWZhdWx0J10obG9jYWxlLnllYXJGb3JtYXQpO1xuICAgICAgICB0aGlzLm1vbnRoRm9ybWF0dGVyID0gbmV3IF9ncmVnb3JpYW5DYWxlbmRhckZvcm1hdDJbJ2RlZmF1bHQnXShsb2NhbGUubW9udGhGb3JtYXQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uU2VsZWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25TZWxlY3QodmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBzaG93TW9udGhQYW5lbDogMCxcbiAgICAgICAgc2hvd1llYXJQYW5lbDogMFxuICAgICAgfSk7XG4gICAgICB0aGlzLnByb3BzLm9uVmFsdWVDaGFuZ2UodmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldE1vbnRoWWVhckVsZW1lbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNb250aFllYXJFbGVtZW50KCkge1xuICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciBwcmVmaXhDbHMgPSBwcm9wcy5wcmVmaXhDbHM7XG4gICAgICB2YXIgbG9jYWxlID0gcHJvcHMubG9jYWxlO1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5wcm9wcy52YWx1ZTtcbiAgICAgIHZhciBtb250aEJlZm9yZVllYXIgPSBsb2NhbGUubW9udGhCZWZvcmVZZWFyO1xuICAgICAgdmFyIHNlbGVjdENsYXNzTmFtZSA9IHByZWZpeENscyArICctJyArIChtb250aEJlZm9yZVllYXIgPyAnbXktc2VsZWN0JyA6ICd5bS1zZWxlY3QnKTtcbiAgICAgIHZhciB5ZWFyID0gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdhJyxcbiAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICcteWVhci1zZWxlY3QnLFxuICAgICAgICAgIHJvbGU6ICdidXR0b24nLFxuICAgICAgICAgIG9uQ2xpY2s6IHRoaXMuc2hvd1llYXJQYW5lbCxcbiAgICAgICAgICB0aXRsZTogbG9jYWxlLm1vbnRoU2VsZWN0IH0sXG4gICAgICAgIHRoaXMueWVhckZvcm1hdHRlci5mb3JtYXQodmFsdWUpXG4gICAgICApO1xuICAgICAgdmFyIG1vbnRoID0gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdhJyxcbiAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctbW9udGgtc2VsZWN0JyxcbiAgICAgICAgICByb2xlOiAnYnV0dG9uJyxcbiAgICAgICAgICBvbkNsaWNrOiB0aGlzLnNob3dNb250aFBhbmVsLFxuICAgICAgICAgIHRpdGxlOiBsb2NhbGUubW9udGhTZWxlY3QgfSxcbiAgICAgICAgdGhpcy5tb250aEZvcm1hdHRlci5mb3JtYXQodmFsdWUpXG4gICAgICApO1xuICAgICAgdmFyIG15ID0gW107XG4gICAgICBpZiAobW9udGhCZWZvcmVZZWFyKSB7XG4gICAgICAgIG15ID0gW21vbnRoLCB5ZWFyXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG15ID0gW3llYXIsIG1vbnRoXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ3NwYW4nLFxuICAgICAgICB7IGNsYXNzTmFtZTogc2VsZWN0Q2xhc3NOYW1lIH0sXG4gICAgICAgIHRvRnJhZ21lbnQobXkpXG4gICAgICApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgdmFyIHByZWZpeENscyA9IHByb3BzLnByZWZpeENscztcbiAgICAgIHZhciBsb2NhbGUgPSBwcm9wcy5sb2NhbGU7XG4gICAgICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgICAgIHZhciBQYW5lbENsYXNzID0gbnVsbDtcbiAgICAgIGlmIChzdGF0ZS5zaG93TW9udGhQYW5lbCkge1xuICAgICAgICBQYW5lbENsYXNzID0gX21vbnRoTW9udGhQYW5lbDJbJ2RlZmF1bHQnXTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuc2hvd1llYXJQYW5lbCkge1xuICAgICAgICBQYW5lbENsYXNzID0gX3llYXJZZWFyUGFuZWwyWydkZWZhdWx0J107XG4gICAgICB9XG4gICAgICB2YXIgcGFuZWwgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoUGFuZWxDbGFzcykge1xuICAgICAgICBwYW5lbCA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFBhbmVsQ2xhc3MsIHsgbG9jYWxlOiBsb2NhbGUsIGRlZmF1bHRWYWx1ZTogdmFsdWUsIHJvb3RQcmVmaXhDbHM6IHByZWZpeENscywgb25TZWxlY3Q6IHRoaXMub25TZWxlY3QgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdkaXYnLFxuICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1oZWFkZXInIH0sXG4gICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICdhJyxcbiAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1wcmV2LXllYXItYnRuJyxcbiAgICAgICAgICAgIHJvbGU6ICdidXR0b24nLFxuICAgICAgICAgICAgb25DbGljazogcHJvcHMucHJldmlvdXNZZWFyLFxuICAgICAgICAgICAgdGl0bGU6IGxvY2FsZS5wcmV2aW91c1llYXIgfSxcbiAgICAgICAgICAnwqsnXG4gICAgICAgICksXG4gICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICdhJyxcbiAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1wcmV2LW1vbnRoLWJ0bicsXG4gICAgICAgICAgICByb2xlOiAnYnV0dG9uJyxcbiAgICAgICAgICAgIG9uQ2xpY2s6IHByb3BzLnByZXZpb3VzTW9udGgsXG4gICAgICAgICAgICB0aXRsZTogbG9jYWxlLnByZXZpb3VzTW9udGggfSxcbiAgICAgICAgICAn4oC5J1xuICAgICAgICApLFxuICAgICAgICB0aGlzLmdldE1vbnRoWWVhckVsZW1lbnQoKSxcbiAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ2EnLFxuICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLW5leHQtbW9udGgtYnRuJyxcbiAgICAgICAgICAgIG9uQ2xpY2s6IHByb3BzLm5leHRNb250aCxcbiAgICAgICAgICAgIHRpdGxlOiBsb2NhbGUubmV4dE1vbnRoIH0sXG4gICAgICAgICAgJ+KAuidcbiAgICAgICAgKSxcbiAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ2EnLFxuICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLW5leHQteWVhci1idG4nLFxuICAgICAgICAgICAgb25DbGljazogcHJvcHMubmV4dFllYXIsXG4gICAgICAgICAgICB0aXRsZTogbG9jYWxlLm5leHRZZWFyIH0sXG4gICAgICAgICAgJ8K7J1xuICAgICAgICApLFxuICAgICAgICBwYW5lbFxuICAgICAgKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzaG93TW9udGhQYW5lbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3dNb250aFBhbmVsKCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHNob3dNb250aFBhbmVsOiAxLFxuICAgICAgICBzaG93WWVhclBhbmVsOiAwXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzaG93WWVhclBhbmVsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvd1llYXJQYW5lbCgpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBzaG93TW9udGhQYW5lbDogMCxcbiAgICAgICAgc2hvd1llYXJQYW5lbDogMVxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENhbGVuZGFySGVhZGVyO1xufSkoX3JlYWN0MlsnZGVmYXVsdCddLkNvbXBvbmVudCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IENhbGVuZGFySGVhZGVyO1xuXG5DYWxlbmRhckhlYWRlci5wcm9wVHlwZXMgPSB7XG4gIGxvY2FsZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5vYmplY3QsXG4gIHZhbHVlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm9iamVjdCxcbiAgb25WYWx1ZUNoYW5nZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jXG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL2NhbGVuZGFyL0NhbGVuZGFySGVhZGVyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcmNVdGlsID0gcmVxdWlyZSgncmMtdXRpbCcpO1xuXG52YXIgX3llYXJZZWFyUGFuZWwgPSByZXF1aXJlKCcuLi95ZWFyL1llYXJQYW5lbCcpO1xuXG52YXIgX3llYXJZZWFyUGFuZWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfeWVhclllYXJQYW5lbCk7XG5cbnZhciBST1cgPSA0O1xudmFyIENPTCA9IDM7XG5cbmZ1bmN0aW9uIGdvWWVhcihkaXJlY3Rpb24pIHtcbiAgdmFyIG5leHQgPSB0aGlzLnN0YXRlLnZhbHVlLmNsb25lKCk7XG4gIG5leHQuYWRkWWVhcihkaXJlY3Rpb24pO1xuICB0aGlzLnNldEFuZENoYW5nZVZhbHVlKG5leHQpO1xufVxuXG5mdW5jdGlvbiBjaG9vc2VNb250aChtb250aCkge1xuICB2YXIgbmV4dCA9IHRoaXMuc3RhdGUudmFsdWUuY2xvbmUoKTtcbiAgbmV4dC5zZXRNb250aChtb250aCk7XG4gIHRoaXMuc2V0QW5kU2VsZWN0VmFsdWUobmV4dCk7XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG52YXIgTW9udGhQYW5lbCA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnTW9udGhQYW5lbCcsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgb25DaGFuZ2U6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvblNlbGVjdDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jXG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiBnZXREZWZhdWx0UHJvcHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uQ2hhbmdlOiBub29wLFxuICAgICAgb25TZWxlY3Q6IG5vb3BcbiAgICB9O1xuICB9LFxuXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgLy8gYmluZCBtZXRob2RzXG4gICAgdGhpcy5uZXh0WWVhciA9IGdvWWVhci5iaW5kKHRoaXMsIDEpO1xuICAgIHRoaXMucHJldmlvdXNZZWFyID0gZ29ZZWFyLmJpbmQodGhpcywgLTEpO1xuICAgIHRoaXMucHJlZml4Q2xzID0gcHJvcHMucm9vdFByZWZpeENscyArICctbW9udGgtcGFuZWwnO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogcHJvcHMudmFsdWUgfHwgcHJvcHMuZGVmYXVsdFZhbHVlXG4gICAgfTtcbiAgfSxcblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIGlmICgndmFsdWUnIGluIG5leHRQcm9wcykge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHZhbHVlOiBuZXh0UHJvcHMudmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICBvblllYXJQYW5lbFNlbGVjdDogZnVuY3Rpb24gb25ZZWFyUGFuZWxTZWxlY3QoY3VycmVudCkge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgc2hvd1llYXJQYW5lbDogMFxuICAgIH0pO1xuICAgIHRoaXMuc2V0QW5kQ2hhbmdlVmFsdWUoY3VycmVudCk7XG4gIH0sXG5cbiAgZ2V0TW9udGhzOiBmdW5jdGlvbiBnZXRNb250aHMoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgIHZhciBjdXJyZW50ID0gdmFsdWUuY2xvbmUoKTtcbiAgICB2YXIgbG9jYWxlID0gcHJvcHMubG9jYWxlO1xuICAgIHZhciBtb250aHMgPSBbXTtcbiAgICB2YXIgc2hvcnRNb250aHMgPSBsb2NhbGUuZm9ybWF0LnNob3J0TW9udGhzO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBST1c7IGkrKykge1xuICAgICAgbW9udGhzW2ldID0gW107XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IENPTDsgaisrKSB7XG4gICAgICAgIGN1cnJlbnQuc2V0TW9udGgoaW5kZXgpO1xuICAgICAgICBtb250aHNbaV1bal0gPSB7XG4gICAgICAgICAgdmFsdWU6IGluZGV4LFxuICAgICAgICAgIGNvbnRlbnQ6IHNob3J0TW9udGhzW2luZGV4XSxcbiAgICAgICAgICB0aXRsZTogc2hvcnRNb250aHNbaW5kZXhdXG4gICAgICAgIH07XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vbnRocztcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgIHZhciBsb2NhbGUgPSBwcm9wcy5sb2NhbGU7XG4gICAgdmFyIG1vbnRocyA9IHRoaXMuZ2V0TW9udGhzKCk7XG4gICAgdmFyIHllYXIgPSB2YWx1ZS5nZXRZZWFyKCk7XG4gICAgdmFyIGN1cnJlbnRNb250aCA9IHZhbHVlLmdldE1vbnRoKCk7XG4gICAgdmFyIHByZWZpeENscyA9IHRoaXMucHJlZml4Q2xzO1xuICAgIHZhciBtb250aHNFbHMgPSBtb250aHMubWFwKGZ1bmN0aW9uIChtb250aCwgaW5kZXgpIHtcbiAgICAgIHZhciB0ZHMgPSBtb250aC5tYXAoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgdmFyIF9jbGFzc05hbWVNYXA7XG5cbiAgICAgICAgdmFyIGRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChwcm9wcy5kaXNhYmxlZERhdGUpIHtcbiAgICAgICAgICB2YXIgdGVzdFZhbHVlID0gdmFsdWUuY2xvbmUoKTtcbiAgICAgICAgICB0ZXN0VmFsdWUuc2V0TW9udGgobS52YWx1ZSk7XG4gICAgICAgICAgZGlzYWJsZWQgPSBwcm9wcy5kaXNhYmxlZERhdGUodGVzdFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2xhc3NOYW1lTWFwID0gKF9jbGFzc05hbWVNYXAgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWVNYXAsIHByZWZpeENscyArICctY2VsbCcsIDEpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzTmFtZU1hcCwgcHJlZml4Q2xzICsgJy1jZWxsLWRpc2FibGVkJywgZGlzYWJsZWQpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzTmFtZU1hcCwgcHJlZml4Q2xzICsgJy1zZWxlY3RlZC1jZWxsJywgbS52YWx1ZSA9PT0gY3VycmVudE1vbnRoKSwgX2NsYXNzTmFtZU1hcCk7XG4gICAgICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAndGQnLFxuICAgICAgICAgIHsgcm9sZTogJ2dyaWRjZWxsJyxcbiAgICAgICAgICAgIGtleTogbS52YWx1ZSxcbiAgICAgICAgICAgIG9uQ2xpY2s6IGRpc2FibGVkID8gbnVsbCA6IGNob29zZU1vbnRoLmJpbmQoX3RoaXMsIG0udmFsdWUpLFxuICAgICAgICAgICAgdGl0bGU6IG0udGl0bGUsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICgwLCBfcmNVdGlsLmNsYXNzU2V0KShjbGFzc05hbWVNYXApIH0sXG4gICAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnYScsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1tb250aCcgfSxcbiAgICAgICAgICAgIG0uY29udGVudFxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAndHInLFxuICAgICAgICB7IGtleTogaW5kZXgsIHJvbGU6ICdyb3cnIH0sXG4gICAgICAgIHRkc1xuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHZhciB5ZWFyUGFuZWwgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHRoaXMuc3RhdGUuc2hvd1llYXJQYW5lbCkge1xuICAgICAgeWVhclBhbmVsID0gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoX3llYXJZZWFyUGFuZWwyWydkZWZhdWx0J10sIHsgbG9jYWxlOiBsb2NhbGUsIHZhbHVlOiB2YWx1ZSwgcm9vdFByZWZpeENsczogcHJvcHMucm9vdFByZWZpeENscyxcbiAgICAgICAgb25TZWxlY3Q6IHRoaXMub25ZZWFyUGFuZWxTZWxlY3QgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgJ2RpdicsXG4gICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzLCBzdHlsZTogcHJvcHMuc3R5bGUgfSxcbiAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctaGVhZGVyJyB9LFxuICAgICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctcHJldi15ZWFyLWJ0bicsXG4gICAgICAgICAgICAgIHJvbGU6ICdidXR0b24nLFxuICAgICAgICAgICAgICBvbkNsaWNrOiB0aGlzLnByZXZpb3VzWWVhcixcbiAgICAgICAgICAgICAgdGl0bGU6IGxvY2FsZS5wcmV2aW91c1llYXIgfSxcbiAgICAgICAgICAgICfCqydcbiAgICAgICAgICApLFxuICAgICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICcteWVhci1zZWxlY3QnLFxuICAgICAgICAgICAgICByb2xlOiAnYnV0dG9uJyxcbiAgICAgICAgICAgICAgb25DbGljazogdGhpcy5zaG93WWVhclBhbmVsLFxuICAgICAgICAgICAgICB0aXRsZTogbG9jYWxlLnllYXJTZWxlY3QgfSxcbiAgICAgICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLXllYXItc2VsZWN0LWNvbnRlbnQnIH0sXG4gICAgICAgICAgICAgIHllYXJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy15ZWFyLXNlbGVjdC1hcnJvdycgfSxcbiAgICAgICAgICAgICAgJ3gnXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSxcbiAgICAgICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLW5leHQteWVhci1idG4nLFxuICAgICAgICAgICAgICByb2xlOiAnYnV0dG9uJyxcbiAgICAgICAgICAgICAgb25DbGljazogdGhpcy5uZXh0WWVhcixcbiAgICAgICAgICAgICAgdGl0bGU6IGxvY2FsZS5uZXh0WWVhciB9LFxuICAgICAgICAgICAgJ8K7J1xuICAgICAgICAgIClcbiAgICAgICAgKSxcbiAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctYm9keScgfSxcbiAgICAgICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICd0YWJsZScsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy10YWJsZScsIGNlbGxTcGFjaW5nOiAnMCcsIHJvbGU6ICdncmlkJyB9LFxuICAgICAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICd0Ym9keScsXG4gICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLXRib2R5JyB9LFxuICAgICAgICAgICAgICBtb250aHNFbHNcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICksXG4gICAgICB5ZWFyUGFuZWxcbiAgICApO1xuICB9LFxuXG4gIHNldEFuZENoYW5nZVZhbHVlOiBmdW5jdGlvbiBzZXRBbmRDaGFuZ2VWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMuc2V0VmFsdWUodmFsdWUpO1xuICAgIHRoaXMucHJvcHMub25DaGFuZ2UodmFsdWUpO1xuICB9LFxuXG4gIHNldEFuZFNlbGVjdFZhbHVlOiBmdW5jdGlvbiBzZXRBbmRTZWxlY3RWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMuc2V0VmFsdWUodmFsdWUpO1xuICAgIHRoaXMucHJvcHMub25TZWxlY3QodmFsdWUpO1xuICB9LFxuXG4gIHNldFZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICghKCd2YWx1ZScgaW4gdGhpcy5wcm9wcykpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICBzaG93WWVhclBhbmVsOiBmdW5jdGlvbiBzaG93WWVhclBhbmVsKCkge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgc2hvd1llYXJQYW5lbDogMVxuICAgIH0pO1xuICB9XG59KTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gTW9udGhQYW5lbDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9tb250aC9Nb250aFBhbmVsLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IGRlc2MgPSBwYXJlbnQgPSBnZXR0ZXIgPSB1bmRlZmluZWQ7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcmNVdGlsID0gcmVxdWlyZSgncmMtdXRpbCcpO1xuXG52YXIgX2RlY2FkZURlY2FkZVBhbmVsID0gcmVxdWlyZSgnLi4vZGVjYWRlL0RlY2FkZVBhbmVsJyk7XG5cbnZhciBfZGVjYWRlRGVjYWRlUGFuZWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVjYWRlRGVjYWRlUGFuZWwpO1xuXG52YXIgUk9XID0gNDtcbnZhciBDT0wgPSAzO1xuXG5mdW5jdGlvbiBnb1llYXIoZGlyZWN0aW9uKSB7XG4gIHZhciBuZXh0ID0gdGhpcy5zdGF0ZS52YWx1ZS5jbG9uZSgpO1xuICBuZXh0LmFkZFllYXIoZGlyZWN0aW9uKTtcbiAgdGhpcy5zZXRTdGF0ZSh7IHZhbHVlOiBuZXh0IH0pO1xufVxuXG5mdW5jdGlvbiBjaG9vc2VZZWFyKHllYXIpIHtcbiAgdmFyIG5leHQgPSB0aGlzLnN0YXRlLnZhbHVlLmNsb25lKCk7XG4gIG5leHQuc2V0WWVhcih5ZWFyKTtcbiAgdGhpcy5wcm9wcy5vblNlbGVjdChuZXh0KTtcbn1cblxudmFyIFllYXJQYW5lbCA9IChmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoWWVhclBhbmVsLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBZZWFyUGFuZWwocHJvcHMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFllYXJQYW5lbCk7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihZZWFyUGFuZWwucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuY2FsbCh0aGlzLCBwcm9wcyk7XG4gICAgdGhpcy5wcmVmaXhDbHMgPSBwcm9wcy5yb290UHJlZml4Q2xzICsgJy15ZWFyLXBhbmVsJztcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgdmFsdWU6IHByb3BzLnZhbHVlIHx8IHByb3BzLmRlZmF1bHRWYWx1ZVxuICAgIH07XG4gICAgdGhpcy5uZXh0RGVjYWRlID0gZ29ZZWFyLmJpbmQodGhpcywgMTApO1xuICAgIHRoaXMucHJldmlvdXNEZWNhZGUgPSBnb1llYXIuYmluZCh0aGlzLCAtMTApO1xuICAgIFsnc2hvd0RlY2FkZVBhbmVsJywgJ29uRGVjYWRlUGFuZWxTZWxlY3QnXS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgICBfdGhpc1ttXSA9IF90aGlzW21dLmJpbmQoX3RoaXMpO1xuICAgIH0pO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFllYXJQYW5lbCwgW3tcbiAgICBrZXk6ICdvbkRlY2FkZVBhbmVsU2VsZWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25EZWNhZGVQYW5lbFNlbGVjdChjdXJyZW50KSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgdmFsdWU6IGN1cnJlbnQsXG4gICAgICAgIHNob3dEZWNhZGVQYW5lbDogMFxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0WWVhcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRZZWFycygpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgICB2YXIgY3VycmVudFllYXIgPSB2YWx1ZS5nZXRZZWFyKCk7XG4gICAgICB2YXIgc3RhcnRZZWFyID0gcGFyc2VJbnQoY3VycmVudFllYXIgLyAxMCwgMTApICogMTA7XG4gICAgICB2YXIgcHJldmlvdXNZZWFyID0gc3RhcnRZZWFyIC0gMTtcbiAgICAgIHZhciBlbmRZZWFyID0gc3RhcnRZZWFyICsgOTtcbiAgICAgIHZhciB5ZWFycyA9IFtdO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgUk9XOyBpKyspIHtcbiAgICAgICAgeWVhcnNbaV0gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBDT0w7IGorKykge1xuICAgICAgICAgIHZhciB5ZWFyID0gcHJldmlvdXNZZWFyICsgaW5kZXg7XG4gICAgICAgICAgdmFyIGNvbnRlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKHllYXIgPCBzdGFydFllYXIpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSAnJztcbiAgICAgICAgICB9IGVsc2UgaWYgKHllYXIgPiBlbmRZZWFyKSB7XG4gICAgICAgICAgICBjb250ZW50ID0gJyc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSB5ZWFyICsgJyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHllYXJzW2ldW2pdID0ge1xuICAgICAgICAgICAgY29udGVudDogY29udGVudCxcbiAgICAgICAgICAgIHllYXI6IHllYXIsXG4gICAgICAgICAgICB0aXRsZTogY29udGVudFxuICAgICAgICAgIH07XG4gICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHllYXJzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICAgIHZhciBsb2NhbGUgPSBwcm9wcy5sb2NhbGU7XG4gICAgICB2YXIgeWVhcnMgPSB0aGlzLmdldFllYXJzKCk7XG4gICAgICB2YXIgY3VycmVudFllYXIgPSB2YWx1ZS5nZXRZZWFyKCk7XG4gICAgICB2YXIgc3RhcnRZZWFyID0gcGFyc2VJbnQoY3VycmVudFllYXIgLyAxMCwgMTApICogMTA7XG4gICAgICB2YXIgZW5kWWVhciA9IHN0YXJ0WWVhciArIDk7XG4gICAgICB2YXIgcHJlZml4Q2xzID0gdGhpcy5wcmVmaXhDbHM7XG5cbiAgICAgIHZhciB5ZWFzRWxzID0geWVhcnMubWFwKGZ1bmN0aW9uIChyb3csIGluZGV4KSB7XG4gICAgICAgIHZhciB0ZHMgPSByb3cubWFwKGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgdmFyIF9jbGFzc05hbWVNYXA7XG5cbiAgICAgICAgICB2YXIgY2xhc3NOYW1lTWFwID0gKF9jbGFzc05hbWVNYXAgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWVNYXAsIHByZWZpeENscyArICctY2VsbCcsIDEpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzTmFtZU1hcCwgcHJlZml4Q2xzICsgJy1zZWxlY3RlZC1jZWxsJywgeS55ZWFyID09PSBjdXJyZW50WWVhciksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NOYW1lTWFwLCBwcmVmaXhDbHMgKyAnLWxhc3QtZGVjYWRlLWNlbGwnLCB5LnllYXIgPCBzdGFydFllYXIpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzTmFtZU1hcCwgcHJlZml4Q2xzICsgJy1uZXh0LWRlY2FkZS1jZWxsJywgeS55ZWFyID4gZW5kWWVhciksIF9jbGFzc05hbWVNYXApO1xuICAgICAgICAgIHZhciBjbGlja0hhbmRsZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKHkueWVhciA8IHN0YXJ0WWVhcikge1xuICAgICAgICAgICAgY2xpY2tIYW5kbGVyID0gX3RoaXMyLnByZXZpb3VzRGVjYWRlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoeS55ZWFyID4gZW5kWWVhcikge1xuICAgICAgICAgICAgY2xpY2tIYW5kbGVyID0gX3RoaXMyLm5leHREZWNhZGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsaWNrSGFuZGxlciA9IGNob29zZVllYXIuYmluZChfdGhpczIsIHkueWVhcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICd0ZCcsXG4gICAgICAgICAgICB7IHJvbGU6ICdncmlkY2VsbCcsXG4gICAgICAgICAgICAgIHRpdGxlOiB5LnRpdGxlLFxuICAgICAgICAgICAgICBrZXk6IHkuY29udGVudCxcbiAgICAgICAgICAgICAgb25DbGljazogY2xpY2tIYW5kbGVyLFxuICAgICAgICAgICAgICBjbGFzc05hbWU6ICgwLCBfcmNVdGlsLmNsYXNzU2V0KShjbGFzc05hbWVNYXApXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy15ZWFyJyB9LFxuICAgICAgICAgICAgICB5LmNvbnRlbnRcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICd0cicsXG4gICAgICAgICAgeyBrZXk6IGluZGV4LCByb2xlOiAncm93JyB9LFxuICAgICAgICAgIHRkc1xuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBkZWNhZGVQYW5lbCA9IHVuZGVmaW5lZDtcbiAgICAgIGlmICh0aGlzLnN0YXRlLnNob3dEZWNhZGVQYW5lbCkge1xuICAgICAgICBkZWNhZGVQYW5lbCA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KF9kZWNhZGVEZWNhZGVQYW5lbDJbJ2RlZmF1bHQnXSwgeyBsb2NhbGU6IGxvY2FsZSwgdmFsdWU6IHZhbHVlLCByb290UHJlZml4Q2xzOiBwcm9wcy5yb290UHJlZml4Q2xzLFxuICAgICAgICAgIG9uU2VsZWN0OiB0aGlzLm9uRGVjYWRlUGFuZWxTZWxlY3QgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIHsgY2xhc3NOYW1lOiB0aGlzLnByZWZpeENscyB9LFxuICAgICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1oZWFkZXInIH0sXG4gICAgICAgICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1wcmV2LWRlY2FkZS1idG4nLFxuICAgICAgICAgICAgICAgIHJvbGU6ICdidXR0b24nLFxuICAgICAgICAgICAgICAgIG9uQ2xpY2s6IHRoaXMucHJldmlvdXNEZWNhZGUsXG4gICAgICAgICAgICAgICAgdGl0bGU6IGxvY2FsZS5wcmV2aW91c0RlY2FkZSB9LFxuICAgICAgICAgICAgICAnwqsnXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctZGVjYWRlLXNlbGVjdCcsXG4gICAgICAgICAgICAgICAgcm9sZTogJ2J1dHRvbicsXG4gICAgICAgICAgICAgICAgb25DbGljazogdGhpcy5zaG93RGVjYWRlUGFuZWwsXG4gICAgICAgICAgICAgICAgdGl0bGU6IGxvY2FsZS5kZWNhZGVTZWxlY3QgfSxcbiAgICAgICAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWRlY2FkZS1zZWxlY3QtY29udGVudCcgfSxcbiAgICAgICAgICAgICAgICBzdGFydFllYXIsXG4gICAgICAgICAgICAgICAgJy0nLFxuICAgICAgICAgICAgICAgIGVuZFllYXJcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWRlY2FkZS1zZWxlY3QtYXJyb3cnIH0sXG4gICAgICAgICAgICAgICAgJ3gnXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1uZXh0LWRlY2FkZS1idG4nLFxuICAgICAgICAgICAgICAgIHJvbGU6ICdidXR0b24nLFxuICAgICAgICAgICAgICAgIG9uQ2xpY2s6IHRoaXMubmV4dERlY2FkZSxcbiAgICAgICAgICAgICAgICB0aXRsZTogbG9jYWxlLm5leHREZWNhZGUgfSxcbiAgICAgICAgICAgICAgJ8K7J1xuICAgICAgICAgICAgKVxuICAgICAgICAgICksXG4gICAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWJvZHknIH0sXG4gICAgICAgICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgJ3RhYmxlJyxcbiAgICAgICAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctdGFibGUnLCBjZWxsU3BhY2luZzogJzAnLCByb2xlOiAnZ3JpZCcgfSxcbiAgICAgICAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ3Rib2R5JyxcbiAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy10Ym9keScgfSxcbiAgICAgICAgICAgICAgICB5ZWFzRWxzXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgICksXG4gICAgICAgIGRlY2FkZVBhbmVsXG4gICAgICApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Nob3dEZWNhZGVQYW5lbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3dEZWNhZGVQYW5lbCgpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBzaG93RGVjYWRlUGFuZWw6IDFcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBZZWFyUGFuZWw7XG59KShfcmVhY3QyWydkZWZhdWx0J10uQ29tcG9uZW50KTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gWWVhclBhbmVsO1xuXG5ZZWFyUGFuZWwuZGVmYXVsdFByb3BzID0ge1xuICBvblNlbGVjdDogZnVuY3Rpb24gb25TZWxlY3QoKSB7fVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi95ZWFyL1llYXJQYW5lbC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBkZXNjID0gcGFyZW50ID0gZ2V0dGVyID0gdW5kZWZpbmVkOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JjVXRpbCA9IHJlcXVpcmUoJ3JjLXV0aWwnKTtcblxudmFyIFJPVyA9IDQ7XG52YXIgQ09MID0gMztcblxuZnVuY3Rpb24gZ29ZZWFyKGRpcmVjdGlvbikge1xuICB2YXIgbmV4dCA9IHRoaXMuc3RhdGUudmFsdWUuY2xvbmUoKTtcbiAgbmV4dC5hZGRZZWFyKGRpcmVjdGlvbik7XG4gIHRoaXMuc2V0U3RhdGUoe1xuICAgIHZhbHVlOiBuZXh0XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjaG9vc2VEZWNhZGUoeWVhciwgZSkge1xuICB2YXIgbmV4dCA9IHRoaXMuc3RhdGUudmFsdWUuY2xvbmUoKTtcbiAgbmV4dC5zZXRZZWFyKHllYXIpO1xuICB0aGlzLnByb3BzLm9uU2VsZWN0KG5leHQpO1xuICBlLnByZXZlbnREZWZhdWx0KCk7XG59XG5cbnZhciBEZWNhZGVQYW5lbCA9IChmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoRGVjYWRlUGFuZWwsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIERlY2FkZVBhbmVsKHByb3BzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERlY2FkZVBhbmVsKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKERlY2FkZVBhbmVsLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmNhbGwodGhpcywgcHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICB2YWx1ZTogcHJvcHMudmFsdWUgfHwgcHJvcHMuZGVmYXVsdFZhbHVlXG4gICAgfTtcblxuICAgIC8vIGJpbmQgbWV0aG9kc1xuICAgIHRoaXMucHJlZml4Q2xzID0gcHJvcHMucm9vdFByZWZpeENscyArICctZGVjYWRlLXBhbmVsJztcbiAgICB0aGlzLm5leHRDZW50dXJ5ID0gZ29ZZWFyLmJpbmQodGhpcywgMTAwKTtcbiAgICB0aGlzLnByZXZpb3VzQ2VudHVyeSA9IGdvWWVhci5iaW5kKHRoaXMsIC0xMDApO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKERlY2FkZVBhbmVsLCBbe1xuICAgIGtleTogJ3JlbmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgICB2YXIgbG9jYWxlID0gdGhpcy5wcm9wcy5sb2NhbGU7XG4gICAgICB2YXIgY3VycmVudFllYXIgPSB2YWx1ZS5nZXRZZWFyKCk7XG4gICAgICB2YXIgc3RhcnRZZWFyID0gcGFyc2VJbnQoY3VycmVudFllYXIgLyAxMDAsIDEwKSAqIDEwMDtcbiAgICAgIHZhciBwcmVZZWFyID0gc3RhcnRZZWFyIC0gMTA7XG4gICAgICB2YXIgZW5kWWVhciA9IHN0YXJ0WWVhciArIDk5O1xuICAgICAgdmFyIGRlY2FkZXMgPSBbXTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgcHJlZml4Q2xzID0gdGhpcy5wcmVmaXhDbHM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgUk9XOyBpKyspIHtcbiAgICAgICAgZGVjYWRlc1tpXSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IENPTDsgaisrKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0RGVjYWRlID0gcHJlWWVhciArIGluZGV4ICogMTA7XG4gICAgICAgICAgdmFyIGVuZERlY2FkZSA9IHByZVllYXIgKyBpbmRleCAqIDEwICsgOTtcbiAgICAgICAgICBkZWNhZGVzW2ldW2pdID0ge1xuICAgICAgICAgICAgc3RhcnREZWNhZGU6IHN0YXJ0RGVjYWRlLFxuICAgICAgICAgICAgZW5kRGVjYWRlOiBlbmREZWNhZGVcbiAgICAgICAgICB9O1xuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGRlY2FkZXNFbHMgPSBkZWNhZGVzLm1hcChmdW5jdGlvbiAocm93LCBkZWNhZGVJbmRleCkge1xuICAgICAgICB2YXIgdGRzID0gcm93Lm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHZhciBfY2xhc3NOYW1lTWFwO1xuXG4gICAgICAgICAgdmFyIGRTdGFydERlY2FkZSA9IGQuc3RhcnREZWNhZGU7XG4gICAgICAgICAgdmFyIGRFbmREZWNhZGUgPSBkLmVuZERlY2FkZTtcbiAgICAgICAgICB2YXIgaXNMYXN0ID0gZFN0YXJ0RGVjYWRlIDwgc3RhcnRZZWFyO1xuICAgICAgICAgIHZhciBpc05leHQgPSBkRW5kRGVjYWRlID4gZW5kWWVhcjtcbiAgICAgICAgICB2YXIgY2xhc3NOYW1lTWFwID0gKF9jbGFzc05hbWVNYXAgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWVNYXAsIHByZWZpeENscyArICctY2VsbCcsIDEpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzTmFtZU1hcCwgcHJlZml4Q2xzICsgJy1zZWxlY3RlZC1jZWxsJywgZFN0YXJ0RGVjYWRlIDw9IGN1cnJlbnRZZWFyICYmIGN1cnJlbnRZZWFyIDw9IGRFbmREZWNhZGUpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzTmFtZU1hcCwgcHJlZml4Q2xzICsgJy1sYXN0LWNlbnR1cnktY2VsbCcsIGlzTGFzdCksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NOYW1lTWFwLCBwcmVmaXhDbHMgKyAnLW5leHQtY2VudHVyeS1jZWxsJywgaXNOZXh0KSwgX2NsYXNzTmFtZU1hcCk7XG4gICAgICAgICAgdmFyIGNvbnRlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdmFyIGNsaWNrSGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAoaXNMYXN0KSB7XG4gICAgICAgICAgICBjbGlja0hhbmRsZXIgPSBfdGhpcy5wcmV2aW91c0NlbnR1cnk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc05leHQpIHtcbiAgICAgICAgICAgIGNsaWNrSGFuZGxlciA9IF90aGlzLm5leHRDZW50dXJ5O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZW50ID0gZFN0YXJ0RGVjYWRlICsgJy0nICsgZEVuZERlY2FkZTtcbiAgICAgICAgICAgIGNsaWNrSGFuZGxlciA9IGNob29zZURlY2FkZS5iaW5kKF90aGlzLCBkU3RhcnREZWNhZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAndGQnLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBrZXk6IGRTdGFydERlY2FkZSxcbiAgICAgICAgICAgICAgb25DbGljazogY2xpY2tIYW5kbGVyLFxuICAgICAgICAgICAgICByb2xlOiAnZ3JpZGNlbGwnLFxuICAgICAgICAgICAgICBjbGFzc05hbWU6ICgwLCBfcmNVdGlsLmNsYXNzU2V0KShjbGFzc05hbWVNYXApXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1kZWNhZGUnIH0sXG4gICAgICAgICAgICAgIGNvbnRlbnRcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICd0cicsXG4gICAgICAgICAgeyBrZXk6IGRlY2FkZUluZGV4LCByb2xlOiAncm93JyB9LFxuICAgICAgICAgIHRkc1xuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIHsgY2xhc3NOYW1lOiB0aGlzLnByZWZpeENscyB9LFxuICAgICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1oZWFkZXInIH0sXG4gICAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnYScsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1wcmV2LWNlbnR1cnktYnRuJyxcbiAgICAgICAgICAgICAgcm9sZTogJ2J1dHRvbicsXG4gICAgICAgICAgICAgIG9uQ2xpY2s6IHRoaXMucHJldmlvdXNDZW50dXJ5LFxuICAgICAgICAgICAgICB0aXRsZTogbG9jYWxlLnByZXZpb3VzQ2VudHVyeSB9LFxuICAgICAgICAgICAgJ8KrJ1xuICAgICAgICAgICksXG4gICAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWNlbnR1cnknIH0sXG4gICAgICAgICAgICBzdGFydFllYXIsXG4gICAgICAgICAgICAnLScsXG4gICAgICAgICAgICBlbmRZZWFyXG4gICAgICAgICAgKSxcbiAgICAgICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLW5leHQtY2VudHVyeS1idG4nLFxuICAgICAgICAgICAgICByb2xlOiAnYnV0dG9uJyxcbiAgICAgICAgICAgICAgb25DbGljazogdGhpcy5uZXh0Q2VudHVyeSxcbiAgICAgICAgICAgICAgdGl0bGU6IGxvY2FsZS5uZXh0Q2VudHVyeSB9LFxuICAgICAgICAgICAgJ8K7J1xuICAgICAgICAgIClcbiAgICAgICAgKSxcbiAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctYm9keScgfSxcbiAgICAgICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICd0YWJsZScsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy10YWJsZScsIGNlbGxTcGFjaW5nOiAnMCcsIHJvbGU6ICdncmlkJyB9LFxuICAgICAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICd0Ym9keScsXG4gICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLXRib2R5JyB9LFxuICAgICAgICAgICAgICBkZWNhZGVzRWxzXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEZWNhZGVQYW5lbDtcbn0pKF9yZWFjdDJbJ2RlZmF1bHQnXS5Db21wb25lbnQpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBEZWNhZGVQYW5lbDtcblxuRGVjYWRlUGFuZWwucHJvcFR5cGVzID0ge1xuICBsb2NhbGU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMub2JqZWN0XG59O1xuXG5EZWNhZGVQYW5lbC5kZWZhdWx0UHJvcHMgPSB7XG4gIG9uU2VsZWN0OiBmdW5jdGlvbiBvblNlbGVjdCgpIHt9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL2RlY2FkZS9EZWNhZGVQYW5lbC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBkZXNjID0gcGFyZW50ID0gZ2V0dGVyID0gdW5kZWZpbmVkOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3RpbWVUaW1lID0gcmVxdWlyZSgnLi4vdGltZS9UaW1lJyk7XG5cbnZhciBfdGltZVRpbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGltZVRpbWUpO1xuXG52YXIgX3JjVXRpbCA9IHJlcXVpcmUoJ3JjLXV0aWwnKTtcblxudmFyIF9yY1V0aWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmNVdGlsKTtcblxudmFyIHRvRnJhZ21lbnQgPSBfcmNVdGlsMlsnZGVmYXVsdCddLkNoaWxkcmVuLm1hcFNlbGY7XG5cbnZhciBDYWxlbmRhckZvb3RlciA9IChmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoQ2FsZW5kYXJGb290ZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIENhbGVuZGFyRm9vdGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYWxlbmRhckZvb3Rlcik7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihDYWxlbmRhckZvb3Rlci5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENhbGVuZGFyRm9vdGVyLCBbe1xuICAgIGtleTogJ2dldFRvZGF5VGltZVN0cicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRvZGF5VGltZVN0cigpIHtcbiAgICAgIHZhciB0b2RheSA9IHRoaXMuZ2V0VG9kYXlUaW1lKCk7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5kYXRlRm9ybWF0dGVyLmZvcm1hdCh0b2RheSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0VG9kYXlUaW1lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VG9kYXlUaW1lKCkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5wcm9wcy52YWx1ZTtcbiAgICAgIHZhciB0b2RheSA9IHZhbHVlLmNsb25lKCk7XG4gICAgICB0b2RheS5zZXRUaW1lKERhdGUubm93KCkpO1xuICAgICAgcmV0dXJuIHRvZGF5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgICAgIHZhciBsb2NhbGUgPSBwcm9wcy5sb2NhbGU7XG4gICAgICB2YXIgcHJlZml4Q2xzID0gcHJvcHMucHJlZml4Q2xzO1xuICAgICAgdmFyIGZvb3RlckVsID0gbnVsbDtcbiAgICAgIGlmIChwcm9wcy5zaG93VG9kYXkgfHwgcHJvcHMuc2hvd1RpbWUpIHtcbiAgICAgICAgdmFyIG5vd0VsID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgbG9jYWxlTm93ID0gbG9jYWxlLnRvZGF5O1xuICAgICAgICBpZiAocHJvcHMuc2hvd1RpbWUpIHtcbiAgICAgICAgICBsb2NhbGVOb3cgPSBsb2NhbGUubm93IHx8IGxvY2FsZS50b2RheTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcHMuc2hvd1RvZGF5KSB7XG4gICAgICAgICAgdmFyIGRpc2FibGVkVG9kYXkgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgZGlzYWJsZWRUb2RheUNsYXNzID0gJyc7XG4gICAgICAgICAgaWYgKHByb3BzLmRpc2FibGVkRGF0ZSkge1xuICAgICAgICAgICAgZGlzYWJsZWRUb2RheSA9IHByb3BzLmRpc2FibGVkRGF0ZSh0aGlzLmdldFRvZGF5VGltZSgpLCB2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoZGlzYWJsZWRUb2RheSkge1xuICAgICAgICAgICAgICBkaXNhYmxlZFRvZGF5Q2xhc3MgPSBwcmVmaXhDbHMgKyAnLXRvZGF5LWJ0bi1kaXNhYmxlZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vd0VsID0gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnYScsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy10b2RheS1idG4gJyArIGRpc2FibGVkVG9kYXlDbGFzcyxcbiAgICAgICAgICAgICAgcm9sZTogJ2J1dHRvbicsXG4gICAgICAgICAgICAgIG9uQ2xpY2s6IGRpc2FibGVkVG9kYXkgPyBudWxsIDogcHJvcHMub25Ub2RheSxcbiAgICAgICAgICAgICAgdGl0bGU6IHRoaXMuZ2V0VG9kYXlUaW1lU3RyKCkgfSxcbiAgICAgICAgICAgIGxvY2FsZU5vd1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNsZWFyRWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChwcm9wcy5zaG93Q2xlYXIpIHtcbiAgICAgICAgICBjbGVhckVsID0gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnYScsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1jbGVhci1idG4nLFxuICAgICAgICAgICAgICByb2xlOiAnYnV0dG9uJyxcbiAgICAgICAgICAgICAgb25DbGljazogcHJvcHMub25DbGVhciB9LFxuICAgICAgICAgICAgbG9jYWxlLmNsZWFyXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2tCdG4gPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChwcm9wcy5zaG93T2spIHtcbiAgICAgICAgICBva0J0biA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctb2stYnRuJyxcbiAgICAgICAgICAgICAgcm9sZTogJ2J1dHRvbicsXG4gICAgICAgICAgICAgIG9uQ2xpY2s6IHByb3BzLm9uT2sgfSxcbiAgICAgICAgICAgIGxvY2FsZS5va1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZvb3RlckJ0biA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG5vd0VsIHx8IGNsZWFyRWwpIHtcbiAgICAgICAgICBmb290ZXJCdG4gPSBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWZvb3Rlci1idG4nIH0sXG4gICAgICAgICAgICB0b0ZyYWdtZW50KFtub3dFbCwgb2tCdG4sIGNsZWFyRWxdKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRpbWVFbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHByb3BzLnNob3dUaW1lKSB7XG4gICAgICAgICAgdGltZUVsID0gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoX3RpbWVUaW1lMlsnZGVmYXVsdCddLCB7IHZhbHVlOiB2YWx1ZSwgcHJlZml4Q2xzOiBwcmVmaXhDbHMsIGxvY2FsZTogbG9jYWxlLCBvbkNoYW5nZTogcHJvcHMub25TZWxlY3QgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9vdGVyRWwgPSBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1mb290ZXInIH0sXG4gICAgICAgICAgdGltZUVsLFxuICAgICAgICAgIGZvb3RlckJ0blxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm9vdGVyRWw7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENhbGVuZGFyRm9vdGVyO1xufSkoX3JlYWN0MlsnZGVmYXVsdCddLkNvbXBvbmVudCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IENhbGVuZGFyRm9vdGVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL2NhbGVuZGFyL0NhbGVuZGFyRm9vdGVyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IGRlc2MgPSBwYXJlbnQgPSBnZXR0ZXIgPSB1bmRlZmluZWQ7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcmNVdGlsID0gcmVxdWlyZSgncmMtdXRpbCcpO1xuXG52YXIgX3JjVXRpbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yY1V0aWwpO1xuXG52YXIgX1RpbWVQYW5lbCA9IHJlcXVpcmUoJy4vVGltZVBhbmVsJyk7XG5cbnZhciBfVGltZVBhbmVsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1RpbWVQYW5lbCk7XG5cbnZhciBzZXRIb3VyT2ZEYXkgPSAnc2V0SG91ck9mRGF5JztcbnZhciBzZXRNaW51dGVzID0gJ3NldE1pbnV0ZXMnO1xudmFyIHNldFNlY29uZHMgPSAnc2V0U2Vjb25kcyc7XG5cbmZ1bmN0aW9uIHBhZGRpbmcobnVtYmVyKSB7XG4gIHZhciByZXQgPSBudW1iZXI7XG4gIGlmIChyZXQgPCAxMCkge1xuICAgIHJldCA9ICcwJyArIHJldDtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBsb29wKHZhbHVlLCBtaW4sIG1heCkge1xuICB2YXIgcmV0ID0gdmFsdWU7XG4gIGlmIChyZXQgPT09IG1pbiAtIDEpIHtcbiAgICByZXQgPSBtYXg7XG4gIH0gZWxzZSBpZiAocmV0ID09PSBtYXggKyAxKSB7XG4gICAgcmV0ID0gbWluO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGtleURvd25XcmFwKG1ldGhvZCwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uS2V5RG93bihlKSB7XG4gICAgdmFyIHZhbHVlID0gZS50YXJnZXQudmFsdWU7XG4gICAgdmFyIG51bWJlciA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgdmFyIGtleUNvZGUgPSBlLmtleUNvZGU7XG4gICAgdmFyIGhhbmRsZWQgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGtleUNvZGUgPT09IF9yY1V0aWwuS2V5Q29kZS5ET1dOKSB7XG4gICAgICBudW1iZXIrKztcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBoYW5kbGVkID0gMTtcbiAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IF9yY1V0aWwuS2V5Q29kZS5VUCkge1xuICAgICAgbnVtYmVyLS07XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaGFuZGxlZCA9IDE7XG4gICAgfVxuICAgIGlmIChoYW5kbGVkKSB7XG4gICAgICBudW1iZXIgPSBsb29wKG51bWJlciwgbWluLCBtYXgpO1xuICAgICAgdmFyIHRpbWUgPSB0aGlzLnByb3BzLnZhbHVlLmNsb25lKCk7XG4gICAgICB0aW1lW21ldGhvZF0obnVtYmVyKTtcbiAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UodGltZSwgZSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgVGltZSA9IChmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoVGltZSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gVGltZShwcm9wcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGltZSk7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihUaW1lLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmNhbGwodGhpcywgcHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBzaG93SG91clBhbmVsOiAwLFxuICAgICAgc2hvd01pbnV0ZVBhbmVsOiAwLFxuICAgICAgc2hvd1NlY29uZFBhbmVsOiAwXG4gICAgfTtcbiAgICB2YXIgZXZlbnRzID0gWydvbkhvdXJLZXlEb3duJywgJ29uTWludXRlS2V5RG93bicsICdvblNlY29uZEtleURvd24nLCAnb25Ib3VyQ2xpY2snLCAnb25NaW51dGVDbGljaycsICdvblNlY29uZENsaWNrJywgJ29uU2VsZWN0UGFuZWwnXTtcbiAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICAgICAgX3RoaXNbbV0gPSBfdGhpc1ttXS5iaW5kKF90aGlzKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUaW1lLCBbe1xuICAgIGtleTogJ3Nob3VsZENvbXBvbmVudFVwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpIHtcbiAgICAgIHJldHVybiBfcmNVdGlsMlsnZGVmYXVsdCddLlB1cmVSZW5kZXJNaXhpbi5zaG91bGRDb21wb25lbnRVcGRhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvblNlbGVjdFBhbmVsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25TZWxlY3RQYW5lbCh2YWx1ZSwgc2V0dGVyKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHNob3dIb3VyUGFuZWw6IDAsXG4gICAgICAgIHNob3dNaW51dGVQYW5lbDogMCxcbiAgICAgICAgc2hvd1NlY29uZFBhbmVsOiAwXG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGllOSBoYXMgYnJva2VuIGZvY3VzXG4gICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5maW5kRE9NTm9kZShfdGhpczIucmVmc1tzZXR0ZXJdKS5mb2N1cygpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkhvdXJDbGljaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uSG91ckNsaWNrKCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHNob3dIb3VyUGFuZWw6IDEsXG4gICAgICAgIHNob3dNaW51dGVQYW5lbDogMCxcbiAgICAgICAgc2hvd1NlY29uZFBhbmVsOiAwXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbk1pbnV0ZUNsaWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25NaW51dGVDbGljaygpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBzaG93SG91clBhbmVsOiAwLFxuICAgICAgICBzaG93TWludXRlUGFuZWw6IDEsXG4gICAgICAgIHNob3dTZWNvbmRQYW5lbDogMFxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25TZWNvbmRDbGljaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uU2Vjb25kQ2xpY2soKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgc2hvd0hvdXJQYW5lbDogMCxcbiAgICAgICAgc2hvd01pbnV0ZVBhbmVsOiAwLFxuICAgICAgICBzaG93U2Vjb25kUGFuZWw6IDFcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgdmFyIHByZWZpeENscyA9IHByb3BzLnByZWZpeENscztcbiAgICAgIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuICAgICAgdmFyIGxvY2FsZSA9IHByb3BzLmxvY2FsZTtcbiAgICAgIHZhciBob3VyID0gdmFsdWUuZ2V0SG91ck9mRGF5KCk7XG4gICAgICB2YXIgbWludXRlID0gdmFsdWUuZ2V0TWludXRlcygpO1xuICAgICAgdmFyIHNlY29uZCA9IHZhbHVlLmdldFNlY29uZHMoKTtcbiAgICAgIHZhciBwYW5lbCA9IHVuZGVmaW5lZDtcbiAgICAgIHZhciBjb21tb25Qcm9wcyA9IHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBvblNlbGVjdDogdGhpcy5vblNlbGVjdFBhbmVsLFxuICAgICAgICByb290UHJlZml4Q2xzOiBwcmVmaXhDbHNcbiAgICAgIH07XG4gICAgICBpZiAoc3RhdGUuc2hvd0hvdXJQYW5lbCkge1xuICAgICAgICBwYW5lbCA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KF9UaW1lUGFuZWwyWydkZWZhdWx0J10sIF9leHRlbmRzKHsgcm93Q291bnQ6IDYsIGNvbENvdW50OiA0LCBnZXR0ZXI6ICdnZXRIb3VyT2ZEYXknLCBzZXR0ZXI6IHNldEhvdXJPZkRheSxcbiAgICAgICAgICB0aXRsZTogbG9jYWxlLmhvdXJQYW5lbFRpdGxlXG4gICAgICAgIH0sIGNvbW1vblByb3BzKSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLnNob3dNaW51dGVQYW5lbCkge1xuICAgICAgICBwYW5lbCA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KF9UaW1lUGFuZWwyWydkZWZhdWx0J10sIF9leHRlbmRzKHsgcm93Q291bnQ6IDYsIGNvbENvdW50OiAxMCwgZ2V0dGVyOiAnZ2V0TWludXRlcycsIHNldHRlcjogc2V0TWludXRlcyxcbiAgICAgICAgICB0aXRsZTogbG9jYWxlLm1pbnV0ZVBhbmVsVGl0bGVcbiAgICAgICAgfSwgY29tbW9uUHJvcHMpKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuc2hvd1NlY29uZFBhbmVsKSB7XG4gICAgICAgIHBhbmVsID0gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoX1RpbWVQYW5lbDJbJ2RlZmF1bHQnXSwgX2V4dGVuZHMoeyByb3dDb3VudDogNiwgY29sQ291bnQ6IDEwLCBnZXR0ZXI6ICdnZXRTZWNvbmRzJywgc2V0dGVyOiBzZXRTZWNvbmRzLFxuICAgICAgICAgIHRpdGxlOiBsb2NhbGUuc2Vjb25kUGFuZWxUaXRsZVxuICAgICAgICB9LCBjb21tb25Qcm9wcykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnc3BhbicsXG4gICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLXRpbWUnIH0sXG4gICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KCdpbnB1dCcsIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLXRpbWUtaW5wdXQnLFxuICAgICAgICAgIHRpdGxlOiBsb2NhbGUuaG91cklucHV0LFxuICAgICAgICAgIHJlZjogc2V0SG91ck9mRGF5LFxuICAgICAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiBwYWRkaW5nKGhvdXIpLFxuICAgICAgICAgIG9uQ2xpY2s6IHRoaXMub25Ib3VyQ2xpY2ssXG4gICAgICAgICAgb25LZXlEb3duOiB0aGlzLm9uSG91cktleURvd24gfSksXG4gICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy10aW1lLW1pbnV0ZScgfSxcbiAgICAgICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAnIDogJ1xuICAgICAgICAgICksXG4gICAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoJ2lucHV0JywgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctdGltZS1pbnB1dCcsXG4gICAgICAgICAgICB0aXRsZTogbG9jYWxlLm1pbnV0ZUlucHV0LFxuICAgICAgICAgICAgcmVmOiBzZXRNaW51dGVzLFxuICAgICAgICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogcGFkZGluZyhtaW51dGUpLFxuICAgICAgICAgICAgb25DbGljazogdGhpcy5vbk1pbnV0ZUNsaWNrLFxuICAgICAgICAgICAgb25LZXlEb3duOiB0aGlzLm9uTWludXRlS2V5RG93biB9KVxuICAgICAgICApLFxuICAgICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctdGltZS1zZWNvbmQnIH0sXG4gICAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgJyA6ICdcbiAgICAgICAgICApLFxuICAgICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KCdpbnB1dCcsIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLXRpbWUtaW5wdXQnLFxuICAgICAgICAgICAgdGl0bGU6IGxvY2FsZS5zZWNvbmRJbnB1dCxcbiAgICAgICAgICAgIHJlZjogc2V0U2Vjb25kcyxcbiAgICAgICAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHBhZGRpbmcoc2Vjb25kKSxcbiAgICAgICAgICAgIG9uQ2xpY2s6IHRoaXMub25TZWNvbmRDbGljayxcbiAgICAgICAgICAgIG9uS2V5RG93bjogdGhpcy5vblNlY29uZEtleURvd24gfSlcbiAgICAgICAgKSxcbiAgICAgICAgcGFuZWxcbiAgICAgICk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRpbWU7XG59KShfcmVhY3QyWydkZWZhdWx0J10uQ29tcG9uZW50KTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gVGltZTtcblxuVGltZS5wcm90b3R5cGUub25Ib3VyS2V5RG93biA9IGtleURvd25XcmFwKCdzZXRIb3VyT2ZEYXknLCAwLCAyMyk7XG5UaW1lLnByb3RvdHlwZS5vbk1pbnV0ZUtleURvd24gPSBrZXlEb3duV3JhcCgnc2V0TWludXRlcycsIDAsIDU5KTtcblRpbWUucHJvdG90eXBlLm9uU2Vjb25kS2V5RG93biA9IGtleURvd25XcmFwKCdzZXRTZWNvbmRzJywgMCwgNTkpO1xuXG5UaW1lLnByb3BUeXBlcyA9IHtcbiAgb25DaGFuZ2U6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuY1xufTtcblxuVGltZS5kZWZhdWx0UHJvcHMgPSB7XG4gIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZSgpIHt9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL3RpbWUvVGltZS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBkZXNjID0gcGFyZW50ID0gZ2V0dGVyID0gdW5kZWZpbmVkOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JjVXRpbCA9IHJlcXVpcmUoJ3JjLXV0aWwnKTtcblxuZnVuY3Rpb24gY2hvb3NlKGhvdXIsIGUpIHtcbiAgdmFyIG5leHQgPSB0aGlzLnN0YXRlLnZhbHVlLmNsb25lKCk7XG4gIHZhciBtZXRob2QgPSB0aGlzLnByb3BzLnNldHRlcjtcbiAgbmV4dFttZXRob2RdKGhvdXIpO1xuICB0aGlzLnByb3BzLm9uU2VsZWN0KG5leHQsIG1ldGhvZCk7XG4gIGUucHJldmVudERlZmF1bHQoKTtcbn1cblxudmFyIFRpbWVQYW5lbCA9IChmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoVGltZVBhbmVsLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBUaW1lUGFuZWwocHJvcHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGltZVBhbmVsKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKFRpbWVQYW5lbC5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5jYWxsKHRoaXMsIHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgdmFsdWU6IHByb3BzLnZhbHVlXG4gICAgfTtcbiAgICB0aGlzLnByZWZpeENscyA9IHByb3BzLnJvb3RQcmVmaXhDbHMgKyAnLXRpbWUtcGFuZWwnO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRpbWVQYW5lbCwgW3tcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciBtZXRob2QgPSBwcm9wcy5nZXR0ZXI7XG4gICAgICB2YXIgY3VycmVudEhvdXIgPSB2YWx1ZVttZXRob2RdKCk7XG4gICAgICB2YXIgZGF0YSA9IFtdO1xuICAgICAgdmFyIHByZWZpeENscyA9IHRoaXMucHJlZml4Q2xzO1xuICAgICAgdmFyIFJPVyA9IHByb3BzLnJvd0NvdW50O1xuICAgICAgdmFyIENPTCA9IHByb3BzLmNvbENvdW50O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFJPVzsgaSsrKSB7XG4gICAgICAgIGRhdGFbaV0gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBDT0w7IGorKykge1xuICAgICAgICAgIGRhdGFbaV1bal0gPSBpICogQ09MICsgajtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaG91cnNFbHMgPSBkYXRhLm1hcChmdW5jdGlvbiAocm93LCBpbmRleCkge1xuICAgICAgICB2YXIgdGRzID0gcm93Lm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHZhciBfY2xhc3NOYW1lTWFwO1xuXG4gICAgICAgICAgdmFyIGNsYXNzTmFtZU1hcCA9IChfY2xhc3NOYW1lTWFwID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NOYW1lTWFwLCBwcmVmaXhDbHMgKyAnLWNlbGwnLCAxKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWVNYXAsIHByZWZpeENscyArICctc2VsZWN0ZWQtY2VsbCcsIGQgPT09IGN1cnJlbnRIb3VyKSwgX2NsYXNzTmFtZU1hcCk7XG4gICAgICAgICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ3RkJyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAga2V5OiBkLFxuICAgICAgICAgICAgICBvbkNsaWNrOiBjaG9vc2UuYmluZChfdGhpcywgZCksXG4gICAgICAgICAgICAgIHJvbGU6ICdncmlkY2VsbCcsXG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogKDAsIF9yY1V0aWwuY2xhc3NTZXQpKGNsYXNzTmFtZU1hcCkgfSxcbiAgICAgICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAnYScsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IHByZWZpeENscyArICctdGltZScgfSxcbiAgICAgICAgICAgICAgZFxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ3RyJyxcbiAgICAgICAgICB7IGtleTogaW5kZXgsIHJvbGU6ICdyb3cnIH0sXG4gICAgICAgICAgdGRzXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyB9LFxuICAgICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1oZWFkZXInIH0sXG4gICAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLXRpdGxlJyB9LFxuICAgICAgICAgICAgcHJvcHMudGl0bGVcbiAgICAgICAgICApXG4gICAgICAgICksXG4gICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICdkaXYnLFxuICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWJvZHknIH0sXG4gICAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAndGFibGUnLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctdGFibGUnLCBjZWxsU3BhY2luZzogJzAnLCByb2xlOiAnZ3JpZCcgfSxcbiAgICAgICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAndGJvZHknLFxuICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy10Ym9keScgfSxcbiAgICAgICAgICAgICAgaG91cnNFbHNcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRpbWVQYW5lbDtcbn0pKF9yZWFjdDJbJ2RlZmF1bHQnXS5Db21wb25lbnQpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBUaW1lUGFuZWw7XG5cblRpbWVQYW5lbC5kZWZhdWx0UHJvcHMgPSB7XG4gIG9uU2VsZWN0OiBmdW5jdGlvbiBvblNlbGVjdCgpIHt9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL3RpbWUvVGltZVBhbmVsLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfbG9jYWxlRW5VcyA9IHJlcXVpcmUoJy4uL2xvY2FsZS9lbi11cycpO1xuXG52YXIgX2xvY2FsZUVuVXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbG9jYWxlRW5Vcyk7XG5cbnZhciBfcmNVdGlsID0gcmVxdWlyZSgncmMtdXRpbCcpO1xuXG52YXIgX2dyZWdvcmlhbkNhbGVuZGFyID0gcmVxdWlyZSgnZ3JlZ29yaWFuLWNhbGVuZGFyJyk7XG5cbnZhciBfZ3JlZ29yaWFuQ2FsZW5kYXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ3JlZ29yaWFuQ2FsZW5kYXIpO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gZ2V0Tm93KCkge1xuICB2YXIgdmFsdWUgPSBuZXcgX2dyZWdvcmlhbkNhbGVuZGFyMlsnZGVmYXVsdCddKCk7XG4gIHZhbHVlLnNldFRpbWUoRGF0ZS5ub3coKSk7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm93QnlDdXJyZW50U3RhdGVWYWx1ZSh2YWx1ZSkge1xuICB2YXIgcmV0ID0gdW5kZWZpbmVkO1xuICBpZiAodmFsdWUpIHtcbiAgICByZXQgPSB2YWx1ZS5jbG9uZSgpO1xuICAgIHJldC5zZXRUaW1lKERhdGUubm93KCkpO1xuICB9IGVsc2Uge1xuICAgIHJldCA9IGdldE5vdygpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbnZhciBDYWxlbmRhck1peGluID0ge1xuICBwcm9wVHlwZXM6IHtcbiAgICB2YWx1ZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5vYmplY3QsXG4gICAgZGVmYXVsdFZhbHVlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm9iamVjdCxcbiAgICBjbGFzc05hbWU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9yaWVudDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5hcnJheU9mKF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMub25lT2YoWydsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nXSkpLFxuICAgIGxvY2FsZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5vYmplY3QsXG4gICAgc3R5bGU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIHZpc2libGU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCxcbiAgICBvblNlbGVjdDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLFxuICAgIHByZWZpeENsczogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmcsXG4gICAgb25LZXlEb3duOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25DaGFuZ2U6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkZvY3VzOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25CbHVyOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmNcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbG9jYWxlOiBfbG9jYWxlRW5VczJbJ2RlZmF1bHQnXSxcbiAgICAgIHN0eWxlOiB7fSxcbiAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICBwcmVmaXhDbHM6ICdyYy1jYWxlbmRhcicsXG4gICAgICBjbGFzc05hbWU6ICcnLFxuICAgICAgb25LZXlEb3duOiBub29wLFxuICAgICAgb25TZWxlY3Q6IG5vb3AsXG4gICAgICBvbkNoYW5nZTogbm9vcCxcbiAgICAgIG9uRm9jdXM6IG5vb3AsXG4gICAgICBvbkJsdXI6IG5vb3BcbiAgICB9O1xuICB9LFxuXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWUgfHwgcHJvcHMuZGVmYXVsdFZhbHVlIHx8IGdldE5vdygpO1xuICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZSB9O1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgdmFyIHZhbHVlID0gbmV4dFByb3BzLnZhbHVlO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlIHx8IG5leHRQcm9wcy5kZWZhdWx0VmFsdWUgfHwgZ2V0Tm93QnlDdXJyZW50U3RhdGVWYWx1ZSh0aGlzLnN0YXRlLnZhbHVlKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICBzaG91bGRDb21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy52aXNpYmxlIHx8IG5leHRQcm9wcy52aXNpYmxlO1xuICB9LFxuXG4gIG9uU2VsZWN0OiBmdW5jdGlvbiBvblNlbGVjdCh2YWx1ZSwga2V5RG93bkV2ZW50KSB7XG4gICAgdGhpcy5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgaWYgKCFrZXlEb3duRXZlbnQpIHtcbiAgICAgIGlmICh0aGlzLmlzQWxsb3dlZERhdGUodmFsdWUpKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25TZWxlY3QodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBvbkZvY3VzOiBmdW5jdGlvbiBvbkZvY3VzKCkge1xuICAgIGlmICh0aGlzLl9ibHVyVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9ibHVyVGltZXIpO1xuICAgICAgdGhpcy5fYmx1clRpbWVyID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcm9wcy5vbkZvY3VzKCk7XG4gICAgfVxuICB9LFxuXG4gIG9uQmx1cjogZnVuY3Rpb24gb25CbHVyKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5fYmx1clRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fYmx1clRpbWVyKTtcbiAgICB9XG4gICAgdGhpcy5fYmx1clRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5wcm9wcy5vbkJsdXIoKTtcbiAgICB9LCAxMDApO1xuICB9LFxuXG4gIHJlbmRlclJvb3Q6IGZ1bmN0aW9uIHJlbmRlclJvb3QobmV3UHJvcHMpIHtcbiAgICB2YXIgX2NsYXNzTmFtZTtcblxuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgcHJlZml4Q2xzID0gcHJvcHMucHJlZml4Q2xzO1xuXG4gICAgdmFyIGNsYXNzTmFtZSA9IChfY2xhc3NOYW1lID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NOYW1lLCBwcmVmaXhDbHMsIDEpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzTmFtZSwgcHJlZml4Q2xzICsgJy1oaWRkZW4nLCAhcHJvcHMudmlzaWJsZSksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NOYW1lLCBwcm9wcy5jbGFzc05hbWUsICEhcHJvcHMuY2xhc3NOYW1lKSwgX2NsYXNzTmFtZSk7XG5cbiAgICB2YXIgb3JpZW50ID0gc3RhdGUub3JpZW50O1xuICAgIGlmIChvcmllbnQpIHtcbiAgICAgIG9yaWVudC5mb3JFYWNoKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIGNsYXNzTmFtZVtwcmVmaXhDbHMgKyAnLW9yaWVudC0nICsgb10gPSAxO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgJ2RpdicsXG4gICAgICB7IGNsYXNzTmFtZTogKDAsIF9yY1V0aWwuY2xhc3NTZXQpKGNsYXNzTmFtZSkgKyAnICcgKyBuZXdQcm9wcy5jbGFzc05hbWUsIHN0eWxlOiB0aGlzLnByb3BzLnN0eWxlLFxuICAgICAgICB0YWJJbmRleDogJzAnLCBvbkZvY3VzOiB0aGlzLm9uRm9jdXMsXG4gICAgICAgIG9uQmx1cjogdGhpcy5vbkJsdXIsIG9uS2V5RG93bjogdGhpcy5vbktleURvd24gfSxcbiAgICAgIG5ld1Byb3BzLmNoaWxkcmVuXG4gICAgKTtcbiAgfSxcblxuICBzZXRWYWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUodmFsdWUpIHtcbiAgICBpZiAoISgndmFsdWUnIGluIHRoaXMucHJvcHMpKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh2YWx1ZSk7XG4gIH0sXG5cbiAgaXNBbGxvd2VkRGF0ZTogZnVuY3Rpb24gaXNBbGxvd2VkRGF0ZSh2YWx1ZSkge1xuICAgIHZhciBkaXNhYmxlZERhdGUgPSB0aGlzLnByb3BzLmRpc2FibGVkRGF0ZTtcbiAgICByZXR1cm4gIWRpc2FibGVkRGF0ZSB8fCAhZGlzYWJsZWREYXRlKHZhbHVlKTtcbiAgfSxcblxuICBzZXRPcmllbnQ6IGZ1bmN0aW9uIHNldE9yaWVudChvcmllbnQpIHtcbiAgICAvLyBGSVhNRTogaGFjayB0byBwcmV2ZW50IGJyZWFraW5nIHJjLWFuaW1hdGVcbiAgICBpZiAodGhpcy5zdGF0ZS5vcmllbnQgPT09IG9yaWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLm9yaWVudCA9IG9yaWVudDtcbiAgICB2YXIgcHJlZml4Q2xzID0gdGhpcy5wcm9wcy5wcmVmaXhDbHM7XG4gICAgdmFyIHJvb3QgPSBfcmVhY3QyWydkZWZhdWx0J10uZmluZERPTU5vZGUodGhpcyk7XG4gICAgdmFyIGNsYXNzTmFtZSA9IHJvb3QuY2xhc3NOYW1lLnJlcGxhY2UobmV3IFJlZ0V4cChwcmVmaXhDbHMgKyAnLW9yaWVudC1cXFxcdysnLCAnZycpLCAnJyk7XG4gICAgaWYgKG9yaWVudCkge1xuICAgICAgb3JpZW50LmZvckVhY2goZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgY2xhc3NOYW1lICs9ICcgJyArIHByZWZpeENscyArICctb3JpZW50LScgKyBvO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJvb3QuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICB9XG59O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBDYWxlbmRhck1peGluO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL21peGluL0NhbGVuZGFyTWl4aW4uanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfZ3JlZ29yaWFuQ2FsZW5kYXJGb3JtYXRMaWJMb2NhbGVFblVzID0gcmVxdWlyZSgnZ3JlZ29yaWFuLWNhbGVuZGFyLWZvcm1hdC9saWIvbG9jYWxlL2VuLXVzJyk7XG5cbnZhciBfZ3JlZ29yaWFuQ2FsZW5kYXJGb3JtYXRMaWJMb2NhbGVFblVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dyZWdvcmlhbkNhbGVuZGFyRm9ybWF0TGliTG9jYWxlRW5Vcyk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHtcbiAgdG9kYXk6ICdUb2RheScsXG4gIG5vdzogJ05vdycsXG4gIG9rOiAnT2snLFxuICBjbGVhcjogJ0NsZWFyJyxcbiAgaG91clBhbmVsVGl0bGU6ICdTZWxlY3QgaG91cicsXG4gIG1pbnV0ZVBhbmVsVGl0bGU6ICdTZWxlY3QgbWludXRlJyxcbiAgc2Vjb25kUGFuZWxUaXRsZTogJ1NlbGVjdCBzZWNvbmQnLFxuICBtb250aFNlbGVjdDogJ0Nob29zZSBhIG1vbnRoJyxcbiAgeWVhclNlbGVjdDogJ0Nob29zZSBhIHllYXInLFxuICBkZWNhZGVTZWxlY3Q6ICdDaG9vc2UgYSBkZWNhZGUnLFxuICB5ZWFyRm9ybWF0OiAneXl5eScsXG4gIGRhdGVGb3JtYXQ6ICdNL2QveXl5eScsXG4gIG1vbnRoRm9ybWF0OiAnTU1NTScsXG4gIG1vbnRoQmVmb3JlWWVhcjogdHJ1ZSxcbiAgcHJldmlvdXNNb250aDogJ1ByZXZpb3VzIG1vbnRoIChQYWdlVXApJyxcbiAgbmV4dE1vbnRoOiAnTmV4dCBtb250aCAoUGFnZURvd24pJyxcbiAgaG91cklucHV0OiAnTGFzdCBob3VyKFVwKSwgTmV4dCBob3VyKERvd24pJyxcbiAgbWludXRlSW5wdXQ6ICdMYXN0IG1pbnV0ZShVcCksIE5leHQgbWludXRlKERvd24pJyxcbiAgc2Vjb25kSW5wdXQ6ICdMYXN0IHNlY29uZChVcCksIE5leHQgc2Vjb25kKERvd24pJyxcbiAgcHJldmlvdXNZZWFyOiAnTGFzdCB5ZWFyIChDb250cm9sICsgbGVmdCknLFxuICBuZXh0WWVhcjogJ05leHQgeWVhciAoQ29udHJvbCArIHJpZ2h0KScsXG4gIHByZXZpb3VzRGVjYWRlOiAnTGFzdCBkZWNhZGUnLFxuICBuZXh0RGVjYWRlOiAnTmV4dCBkZWNhZGUnLFxuICBwcmV2aW91c0NlbnR1cnk6ICdMYXN0IGNlbnR1cnknLFxuICBuZXh0Q2VudHVyeTogJ05leHQgY2VudHVyeScsXG4gIGZvcm1hdDogX2dyZWdvcmlhbkNhbGVuZGFyRm9ybWF0TGliTG9jYWxlRW5VczJbJ2RlZmF1bHQnXVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9sb2NhbGUvZW4tdXMuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9ncmVnb3JpYW5DYWxlbmRhckZvcm1hdCA9IHJlcXVpcmUoJ2dyZWdvcmlhbi1jYWxlbmRhci1mb3JtYXQnKTtcblxudmFyIF9ncmVnb3JpYW5DYWxlbmRhckZvcm1hdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ncmVnb3JpYW5DYWxlbmRhckZvcm1hdCk7XG5cbnZhciBfcmNVdGlsID0gcmVxdWlyZSgncmMtdXRpbCcpO1xuXG52YXIgX3JjVXRpbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yY1V0aWwpO1xuXG52YXIgX3JjQWxpZ24gPSByZXF1aXJlKCdyYy1hbGlnbicpO1xuXG52YXIgX3JjQWxpZ24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmNBbGlnbik7XG5cbnZhciBfcmNBbmltYXRlID0gcmVxdWlyZSgncmMtYW5pbWF0ZScpO1xuXG52YXIgX3JjQW5pbWF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yY0FuaW1hdGUpO1xuXG52YXIgdG9GcmFnbWVudCA9IF9yY1V0aWwyWydkZWZhdWx0J10uQ2hpbGRyZW4ubWFwU2VsZjtcblxudmFyIG9yaWVudE1hcCA9IHtcbiAgdGw6IFsndG9wJywgJ2xlZnQnXSxcbiAgdHI6IFsndG9wJywgJ3JpZ2h0J10sXG4gIGJsOiBbJ2JvdHRvbScsICdsZWZ0J10sXG4gIGJyOiBbJ2JvdHRvbScsICdyaWdodCddXG59O1xuXG5mdW5jdGlvbiBnZXRJbW11dGFibGVPcmllbnQob3JpZW50KSB7XG4gIGlmIChvcmllbnQpIHtcbiAgICBmb3IgKHZhciBpIGluIG9yaWVudE1hcCkge1xuICAgICAgaWYgKG9yaWVudE1hcC5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICB2YXIgb3JpZ2luYWwgPSBvcmllbnRNYXBbaV07XG4gICAgICAgIGlmIChvcmlnaW5hbFswXSA9PT0gb3JpZW50WzBdICYmIG9yaWdpbmFsWzFdID09PSBvcmllbnRbMV0pIHtcbiAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJldmVudChlKSB7XG4gIGUucHJldmVudERlZmF1bHQoKTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIHJlZkZuKGZpZWxkLCBjb21wb25lbnQpIHtcbiAgdGhpc1tmaWVsZF0gPSBjb21wb25lbnQ7XG59XG5cbi8qKlxuICogRGF0ZVBpY2tlciA9IHdyYXAgaW5wdXQgdXNpbmcgQ2FsZW5kYXJcbiAqL1xudmFyIFBpY2tlciA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUGlja2VyJyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBvbkNoYW5nZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLFxuICAgIG9uT3BlbjogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLFxuICAgIG9uQ2xvc2U6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYyxcbiAgICBjYWxlbmRhcjogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5lbGVtZW50LFxuICAgIHN0eWxlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm9iamVjdCxcbiAgICBvcGVuOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmJvb2wsXG4gICAgZGVmYXVsdE9wZW46IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCxcbiAgICBwcmVmaXhDbHM6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGFkanVzdE9yaWVudE9uQ2FsZW5kYXJPdmVyZmxvdzogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5vbmVPZlR5cGUoW19yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCwgX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5vYmplY3RdKVxuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwcmVmaXhDbHM6ICdyYy1jYWxlbmRhci1waWNrZXInLFxuICAgICAgYWRqdXN0T3JpZW50T25DYWxlbmRhck92ZXJmbG93OiB0cnVlLFxuICAgICAgc3R5bGU6IHt9LFxuICAgICAgZGVmYXVsdE9wZW46IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IG5vb3AsXG4gICAgICBvbk9wZW46IG5vb3AsXG4gICAgICBvbkNsb3NlOiBub29wLFxuICAgICAgZm9ybWF0dGVyOiBuZXcgX2dyZWdvcmlhbkNhbGVuZGFyRm9ybWF0MlsnZGVmYXVsdCddKCd5eXl5LU1NLWRkJylcbiAgICB9O1xuICB9LFxuXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIG9wZW4gPSB1bmRlZmluZWQ7XG4gICAgaWYgKCdvcGVuJyBpbiBwcm9wcykge1xuICAgICAgb3BlbiA9IHByb3BzLm9wZW47XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wZW4gPSBwcm9wcy5kZWZhdWx0T3BlbjtcbiAgICB9XG4gICAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWUgfHwgcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIHRoaXMuc2F2ZUNhbGVuZGFyUmVmID0gcmVmRm4uYmluZCh0aGlzLCAnY2FsZW5kYXJJbnN0YW5jZScpO1xuICAgIHRoaXMuc2F2ZUlucHV0UmVmID0gcmVmRm4uYmluZCh0aGlzLCAnaW5wdXRJbnN0YW5jZScpO1xuICAgIHJldHVybiB7IG9wZW46IG9wZW4sIHZhbHVlOiB2YWx1ZSB9O1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgdmFyIHZhbHVlID0gbmV4dFByb3BzLnZhbHVlO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBudWxsIHNwZWNpYWwgbWVhbmluZ1xuICAgICAgdmFsdWUgPSB2YWx1ZSB8fCBuZXh0UHJvcHMuZGVmYXVsdFZhbHVlIHx8IG51bGw7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCdvcGVuJyBpbiBuZXh0UHJvcHMpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBvcGVuOiBuZXh0UHJvcHMub3BlblxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIGlmICh0aGlzLmhhdmVPcGVuZWQpIHtcbiAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5yZW5kZXIodGhpcy5nZXRDYWxlbmRhckVsZW1lbnQoKSwgdGhpcy5nZXRDYWxlbmRhckNvbnRhaW5lcigpKTtcbiAgICB9XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLmNhbGVuZGFyQ29udGFpbmVyKSB7XG4gICAgICBfcmVhY3QyWydkZWZhdWx0J10udW5tb3VudENvbXBvbmVudEF0Tm9kZSh0aGlzLmNhbGVuZGFyQ29udGFpbmVyKTtcbiAgICAgIHRoaXMuY2FsZW5kYXJDb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNhbGVuZGFyQ29udGFpbmVyKTtcbiAgICAgIHRoaXMuY2FsZW5kYXJDb250YWluZXIgPSBudWxsO1xuICAgIH1cbiAgfSxcblxuICBvbkNhbGVuZGFyQWxpZ246IGZ1bmN0aW9uIG9uQ2FsZW5kYXJBbGlnbihub2RlLCBhbGlnbikge1xuICAgIHZhciBwb2ludHMgPSBhbGlnbi5wb2ludHM7XG4gICAgdmFyIG5ld09yaWVudCA9IG9yaWVudE1hcFtwb2ludHNbMF1dO1xuICAgIHRoaXMuY2FsZW5kYXJJbnN0YW5jZS5zZXRPcmllbnQobmV3T3JpZW50KTtcbiAgICAvLyBmb2N1cyBhZnRlciBhbGlnblxuICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5maW5kRE9NTm9kZSh0aGlzLmNhbGVuZGFySW5zdGFuY2UpLmZvY3VzKCk7XG4gIH0sXG5cbiAgb25JbnB1dENsaWNrOiBmdW5jdGlvbiBvbklucHV0Q2xpY2soKSB7XG4gICAgdGhpcy50b2dnbGUoKTtcbiAgfSxcblxuICBvblRyaWdnZXJDbGljazogZnVuY3Rpb24gb25UcmlnZ2VyQ2xpY2soKSB7XG4gICAgdGhpcy50b2dnbGUoKTtcbiAgfSxcblxuICBvbktleURvd246IGZ1bmN0aW9uIG9uS2V5RG93bihlKSB7XG4gICAgLy8gZG93blxuICAgIGlmIChlLmtleUNvZGUgPT09IF9yY1V0aWwuS2V5Q29kZS5ET1dOKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLm9wZW4oKTtcbiAgICB9XG4gIH0sXG5cbiAgb25DYWxlbmRhcktleURvd246IGZ1bmN0aW9uIG9uQ2FsZW5kYXJLZXlEb3duKGUpIHtcbiAgICBpZiAoZS5rZXlDb2RlID09PSBfcmNVdGlsLktleUNvZGUuRVNDKSB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgdGhpcy5jbG9zZSh0aGlzLmZvY3VzSW5wdXQpO1xuICAgIH1cbiAgfSxcblxuICBvbkNhbGVuZGFyU2VsZWN0OiBmdW5jdGlvbiBvbkNhbGVuZGFyU2VsZWN0KHZhbHVlKSB7XG4gICAgdmFyIGN1cnJlbnRWYWx1ZSA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9KTtcbiAgICBpZiAoIXRoaXMucHJvcHMuY2FsZW5kYXIucHJvcHMuc2hvd1RpbWUpIHtcbiAgICAgIHRoaXMuY2xvc2UodGhpcy5mb2N1c0lucHV0KTtcbiAgICB9XG4gICAgaWYgKCFjdXJyZW50VmFsdWUgfHwgY3VycmVudFZhbHVlLmdldFRpbWUoKSAhPT0gdmFsdWUuZ2V0VGltZSgpKSB7XG4gICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgb25DYWxlbmRhckJsdXI6IGZ1bmN0aW9uIG9uQ2FsZW5kYXJCbHVyKCkge1xuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0aGlzLmdldElucHV0RE9NTm9kZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGlmIGludmlzaWJsZSwgd2lsbCBub3QgdHJpZ2dlciBibHVyXG4gICAgLy8gZG8gbm90IHNldCBpZiBhbHJlYWR5IGZhbHNlLCBhdm9pZCBydWluIGFuaW1hdGVcbiAgICB0aGlzLmNsb3NlKCk7XG4gIH0sXG5cbiAgb25DYWxlbmRhck9rOiBmdW5jdGlvbiBvbkNhbGVuZGFyT2soKSB7XG4gICAgdGhpcy5jbG9zZSh0aGlzLmZvY3VzSW5wdXQpO1xuICB9LFxuXG4gIG9uQ2FsZW5kYXJDbGVhcjogZnVuY3Rpb24gb25DYWxlbmRhckNsZWFyKCkge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcbiAgICB0aGlzLmNsb3NlKHRoaXMuZm9jdXNJbnB1dCk7XG4gICAgaWYgKHRoaXMuc3RhdGUudmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UobnVsbCk7XG4gICAgfVxuICB9LFxuXG4gIG9uQ2FsZW5kYXJDaGFuZ2U6IGZ1bmN0aW9uIG9uQ2FsZW5kYXJDaGFuZ2UodmFsdWUpIHtcbiAgICB0aGlzLmNhbGVuZGFySW5zdGFuY2Uuc2V0U3RhdGUoe1xuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSk7XG4gIH0sXG5cbiAgZ2V0SW5wdXRET01Ob2RlOiBmdW5jdGlvbiBnZXRJbnB1dERPTU5vZGUoKSB7XG4gICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5maW5kRE9NTm9kZSh0aGlzLmlucHV0SW5zdGFuY2UpO1xuICB9LFxuXG4gIGdldFRyYW5zaXRpb25OYW1lOiBmdW5jdGlvbiBnZXRUcmFuc2l0aW9uTmFtZSgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciB0cmFuc2l0aW9uTmFtZSA9IHByb3BzLnRyYW5zaXRpb25OYW1lO1xuICAgIGlmICghdHJhbnNpdGlvbk5hbWUgJiYgcHJvcHMuYW5pbWF0aW9uKSB7XG4gICAgICB0cmFuc2l0aW9uTmFtZSA9IHByb3BzLnByZWZpeENscyArICctJyArIHByb3BzLmFuaW1hdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zaXRpb25OYW1lO1xuICB9LFxuXG4gIGdldENhbGVuZGFyQ29udGFpbmVyOiBmdW5jdGlvbiBnZXRDYWxlbmRhckNvbnRhaW5lcigpIHtcbiAgICBpZiAoIXRoaXMuY2FsZW5kYXJDb250YWluZXIpIHtcbiAgICAgIHRoaXMuY2FsZW5kYXJDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMuY2FsZW5kYXJDb250YWluZXIuY2xhc3NOYW1lID0gdGhpcy5wcm9wcy5wcmVmaXhDbHMgKyAnLWNvbnRhaW5lcic7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuY2FsZW5kYXJDb250YWluZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jYWxlbmRhckNvbnRhaW5lcjtcbiAgfSxcblxuICBnZXRBbGlnbjogZnVuY3Rpb24gZ2V0QWxpZ24ob3JpZW50KSB7XG4gICAgdmFyIHBvaW50cyA9IFsndGwnLCAnYmwnXTtcbiAgICB2YXIgb2Zmc2V0ID0gWzAsIDVdO1xuICAgIHZhciBhZGp1c3RPcmllbnRPbkNhbGVuZGFyT3ZlcmZsb3cgPSB0aGlzLnByb3BzLmFkanVzdE9yaWVudE9uQ2FsZW5kYXJPdmVyZmxvdztcbiAgICBpZiAob3JpZW50LmluZGV4T2YoJ3RvcCcpICE9PSAtMSAmJiBvcmllbnQuaW5kZXhPZignbGVmdCcpICE9PSAtMSkge1xuICAgICAgcG9pbnRzID0gWyd0bCcsICdibCddO1xuICAgIH0gZWxzZSBpZiAob3JpZW50LmluZGV4T2YoJ3RvcCcpICE9PSAtMSAmJiBvcmllbnQuaW5kZXhPZigncmlnaHQnKSAhPT0gLTEpIHtcbiAgICAgIHBvaW50cyA9IFsndHInLCAnYnInXTtcbiAgICB9IGVsc2UgaWYgKG9yaWVudC5pbmRleE9mKCdib3R0b20nKSAhPT0gLTEgJiYgb3JpZW50LmluZGV4T2YoJ2xlZnQnKSAhPT0gLTEpIHtcbiAgICAgIHBvaW50cyA9IFsnYmwnLCAndGwnXTtcbiAgICAgIG9mZnNldCA9IFswLCAtNV07XG4gICAgfSBlbHNlIGlmIChvcmllbnQuaW5kZXhPZignYm90dG9tJykgIT09IC0xICYmIG9yaWVudC5pbmRleE9mKCdyaWdodCcpICE9PSAtMSkge1xuICAgICAgcG9pbnRzID0gWydicicsICd0ciddO1xuICAgICAgb2Zmc2V0ID0gWzAsIC01XTtcbiAgICB9XG4gICAgdmFyIGFkanVzdFggPSB1bmRlZmluZWQ7XG4gICAgdmFyIGFkanVzdFkgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGFkanVzdE9yaWVudE9uQ2FsZW5kYXJPdmVyZmxvdyA9PT0gdHJ1ZSkge1xuICAgICAgYWRqdXN0WCA9IGFkanVzdFkgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIWFkanVzdE9yaWVudE9uQ2FsZW5kYXJPdmVyZmxvdykge1xuICAgICAgYWRqdXN0WCA9IGFkanVzdFkgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWRqdXN0WCA9IGFkanVzdE9yaWVudE9uQ2FsZW5kYXJPdmVyZmxvdy54O1xuICAgICAgYWRqdXN0WSA9IGFkanVzdE9yaWVudE9uQ2FsZW5kYXJPdmVyZmxvdy55O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcG9pbnRzOiBwb2ludHMsXG4gICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgIG92ZXJmbG93OiB7XG4gICAgICAgIGFkanVzdFg6IGFkanVzdFgsXG4gICAgICAgIGFkanVzdFk6IGFkanVzdFlcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuXG4gIGdldENhbGVuZGFyRWxlbWVudDogZnVuY3Rpb24gZ2V0Q2FsZW5kYXJFbGVtZW50KCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgY2FsZW5kYXJQcm9wID0gcHJvcHMuY2FsZW5kYXI7XG4gICAgdmFyIG9yaWVudCA9IHVuZGVmaW5lZDtcbiAgICAvLyByZSBhbGlnbiB3aGVuIG9wZW5cbiAgICBpZiAoc3RhdGUub3Blbikge1xuICAgICAgb3JpZW50ID0gZ2V0SW1tdXRhYmxlT3JpZW50KGNhbGVuZGFyUHJvcC5wcm9wcy5vcmllbnQpIHx8IG9yaWVudE1hcC50bDtcbiAgICB9XG4gICAgdmFyIGNhbGVuZGFyRWxlbWVudCA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jbG9uZUVsZW1lbnQoY2FsZW5kYXJQcm9wLCB7XG4gICAgICByZWY6ICgwLCBfcmNVdGlsLmNyZWF0ZUNoYWluZWRGdW5jdGlvbikoY2FsZW5kYXJQcm9wLnJlZiwgdGhpcy5zYXZlQ2FsZW5kYXJSZWYpLFxuICAgICAgdmFsdWU6IHN0YXRlLnZhbHVlLFxuICAgICAgdmlzaWJsZTogc3RhdGUub3BlbixcbiAgICAgIG9yaWVudDogb3JpZW50LFxuICAgICAgb25CbHVyOiB0aGlzLm9uQ2FsZW5kYXJCbHVyLFxuICAgICAgb25LZXlEb3duOiB0aGlzLm9uQ2FsZW5kYXJLZXlEb3duLFxuICAgICAgb25DaGFuZ2U6ICgwLCBfcmNVdGlsLmNyZWF0ZUNoYWluZWRGdW5jdGlvbikoY2FsZW5kYXJQcm9wLnByb3BzLm9uQ2hhbmdlLCB0aGlzLm9uQ2FsZW5kYXJDaGFuZ2UpLFxuICAgICAgb25PazogKDAsIF9yY1V0aWwuY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKShjYWxlbmRhclByb3AucHJvcHMub25PaywgdGhpcy5vbkNhbGVuZGFyT2spLFxuICAgICAgb25TZWxlY3Q6ICgwLCBfcmNVdGlsLmNyZWF0ZUNoYWluZWRGdW5jdGlvbikoY2FsZW5kYXJQcm9wLnByb3BzLm9uU2VsZWN0LCB0aGlzLm9uQ2FsZW5kYXJTZWxlY3QpLFxuICAgICAgb25DbGVhcjogKDAsIF9yY1V0aWwuY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKShjYWxlbmRhclByb3AucHJvcHMub25DbGVhciwgdGhpcy5vbkNhbGVuZGFyQ2xlYXIpXG4gICAgfSk7XG4gICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgX3JjQW5pbWF0ZTJbJ2RlZmF1bHQnXSxcbiAgICAgIHtcbiAgICAgICAgY29tcG9uZW50OiAnJyxcbiAgICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgICB0cmFuc2l0aW9uQXBwZWFyOiB0cnVlLFxuICAgICAgICBzaG93UHJvcDogJ2NhbGVuZGFyT3BlbicsXG4gICAgICAgIHRyYW5zaXRpb25OYW1lOiB0aGlzLmdldFRyYW5zaXRpb25OYW1lKCkgfSxcbiAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICBfcmNBbGlnbjJbJ2RlZmF1bHQnXSxcbiAgICAgICAgeyB0YXJnZXQ6IHRoaXMuZ2V0SW5wdXRET01Ob2RlLFxuICAgICAgICAgIGtleTogJ2NhbGVuZGFyJyxcbiAgICAgICAgICBvbkFsaWduOiB0aGlzLm9uQ2FsZW5kYXJBbGlnbixcbiAgICAgICAgICBjYWxlbmRhck9wZW46IHN0YXRlLm9wZW4sXG4gICAgICAgICAgZGlzYWJsZWQ6ICFzdGF0ZS5vcGVuLFxuICAgICAgICAgIGFsaWduOiBvcmllbnQgJiYgdGhpcy5nZXRBbGlnbihvcmllbnQpIH0sXG4gICAgICAgIGNhbGVuZGFyRWxlbWVudFxuICAgICAgKVxuICAgICk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF9jbGFzc2VzO1xuXG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgZGlzYWJsZWQgPSBwcm9wcy5kaXNhYmxlZDtcbiAgICB2YXIgcHJlZml4Q2xzID0gcHJvcHMucHJlZml4Q2xzO1xuICAgIHZhciBpbnB1dCA9IHByb3BzLmNoaWxkcmVuO1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdmFyIHZhbHVlID0gc3RhdGUudmFsdWU7XG4gICAgdGhpcy5oYXZlT3BlbmVkID0gdGhpcy5oYXZlT3BlbmVkIHx8IHN0YXRlLm9wZW47XG4gICAgdmFyIGlucHV0VmFsdWUgPSAnJztcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGlucHV0VmFsdWUgPSBwcm9wcy5mb3JtYXR0ZXIuZm9ybWF0KHZhbHVlKTtcbiAgICB9XG4gICAgaW5wdXQgPSBfcmVhY3QyWydkZWZhdWx0J10uY2xvbmVFbGVtZW50KGlucHV0LCB7XG4gICAgICByZWY6ICgwLCBfcmNVdGlsLmNyZWF0ZUNoYWluZWRGdW5jdGlvbikoaW5wdXQucmVmLCB0aGlzLnNhdmVJbnB1dFJlZiksXG4gICAgICBkaXNhYmxlZDogZGlzYWJsZWQsXG4gICAgICBvbkNoYW5nZTogbm9vcCxcbiAgICAgIG9uQ2xpY2s6IGRpc2FibGVkID8gbm9vcCA6IHRoaXMub25JbnB1dENsaWNrLFxuICAgICAgdmFsdWU6IGlucHV0VmFsdWUsXG4gICAgICBvbktleURvd246IGRpc2FibGVkID8gbm9vcCA6IHRoaXMub25LZXlEb3duXG4gICAgfSk7XG4gICAgdmFyIGNsYXNzZXMgPSAoX2NsYXNzZXMgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc2VzLCBwcmVmaXhDbHMsIDEpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzZXMsIHByZWZpeENscyArICctb3BlbicsIHN0YXRlLm9wZW4pLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzZXMsIHByZWZpeENscyArICctZGlzYWJsZWQnLCBkaXNhYmxlZCksIF9jbGFzc2VzKTtcbiAgICB2YXIgdHJpZ2dlciA9IHByb3BzLnRyaWdnZXI7XG4gICAgaWYgKHRyaWdnZXIpIHtcbiAgICAgIHRyaWdnZXIgPSBfcmVhY3QyWydkZWZhdWx0J10uY2xvbmVFbGVtZW50KHRyaWdnZXIsIHtcbiAgICAgICAgdW5zZWxlY3RhYmxlOiB0cnVlLFxuICAgICAgICBvbk1vdXNlRG93bjogcHJldmVudCxcbiAgICAgICAgb25DbGljazogZGlzYWJsZWQgPyBub29wIDogdGhpcy5vblRyaWdnZXJDbGlja1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICdzcGFuJyxcbiAgICAgIHsgY2xhc3NOYW1lOiAoMCwgX3JjVXRpbC5jbGFzc1NldCkoY2xhc3NlcyksIHN0eWxlOiBwcm9wcy5zdHlsZSB9LFxuICAgICAgdG9GcmFnbWVudChbaW5wdXQsIHRyaWdnZXJdKVxuICAgICk7XG4gIH0sXG5cbiAgZm9jdXNJbnB1dDogZnVuY3Rpb24gZm9jdXNJbnB1dCgpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUub3Blbikge1xuICAgICAgdGhpcy5nZXRJbnB1dERPTU5vZGUoKS5mb2N1cygpO1xuICAgIH1cbiAgfSxcblxuICBzZXRPcGVuOiBmdW5jdGlvbiBzZXRPcGVuKG9wZW4sIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUub3BlbiAhPT0gb3Blbikge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIG9wZW46IG9wZW5cbiAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICAgIHZhciBfZXZlbnQgPSB7XG4gICAgICAgIG9wZW46IG9wZW5cbiAgICAgIH07XG4gICAgICBpZiAob3Blbikge1xuICAgICAgICB0aGlzLnByb3BzLm9uT3BlbihfZXZlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNsb3NlKF9ldmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHRvZ2dsZTogZnVuY3Rpb24gdG9nZ2xlKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLm9wZW4pIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vcGVuKCk7XG4gICAgfVxuICB9LFxuXG4gIG9wZW46IGZ1bmN0aW9uIG9wZW4oY2FsbGJhY2spIHtcbiAgICB0aGlzLnNldE9wZW4odHJ1ZSwgY2FsbGJhY2spO1xuICB9LFxuXG4gIGNsb3NlOiBmdW5jdGlvbiBjbG9zZShjYWxsYmFjaykge1xuICAgIHRoaXMuc2V0T3BlbihmYWxzZSwgY2FsbGJhY2spO1xuICB9XG59KTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gUGlja2VyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvbGliL1BpY2tlci5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLy8gZXhwb3J0IHRoaXMgcGFja2FnZSdzIGFwaVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9BbGlnbiA9IHJlcXVpcmUoJy4vQWxpZ24nKTtcblxudmFyIF9BbGlnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BbGlnbik7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IF9BbGlnbjJbJ2RlZmF1bHQnXTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWFsaWduL2xpYi9pbmRleC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBkZXNjID0gcGFyZW50ID0gZ2V0dGVyID0gdW5kZWZpbmVkOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX2RvbUFsaWduID0gcmVxdWlyZSgnZG9tLWFsaWduJyk7XG5cbnZhciBfZG9tQWxpZ24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZG9tQWxpZ24pO1xuXG52YXIgX3JjVXRpbCA9IHJlcXVpcmUoJ3JjLXV0aWwnKTtcblxudmFyIF9yY1V0aWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmNVdGlsKTtcblxuZnVuY3Rpb24gaXNXaW5kb3cob2JqKSB7XG4gIC8qZXNsaW50LWRpc2FibGUgZXFlcWVxICovXG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT0gb2JqLndpbmRvdztcbiAgLyplc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xufVxuXG5mdW5jdGlvbiBidWZmZXIoZm4sIG1zKSB7XG4gIHZhciB0aW1lcjtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgfVxuICAgIHRpbWVyID0gc2V0VGltZW91dChmbiwgbXMpO1xuICB9O1xufVxuXG52YXIgQWxpZ24gPSAoZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKEFsaWduLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBBbGlnbihwcm9wcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBbGlnbik7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihBbGlnbi5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMuaGFuZGxlV2luZG93UmVzaXplID0gdGhpcy5oYW5kbGVXaW5kb3dSZXNpemUuYmluZCh0aGlzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBbGlnbiwgW3tcbiAgICBrZXk6ICdjb21wb25lbnREaWRNb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIC8vIGlmIHBhcmVudCByZWYgbm90IGF0dGFjaGVkIC4uLi4gdXNlIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkXG4gICAgICBpZiAoIXByb3BzLmRpc2FibGVkKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBfcmVhY3QyWydkZWZhdWx0J10uZmluZERPTU5vZGUodGhpcyk7XG4gICAgICAgIHByb3BzLm9uQWxpZ24oc291cmNlLCAoMCwgX2RvbUFsaWduMlsnZGVmYXVsdCddKShzb3VyY2UsIHByb3BzLnRhcmdldCgpLCBwcm9wcy5hbGlnbikpO1xuICAgICAgICBpZiAocHJvcHMubW9uaXRvcldpbmRvd1Jlc2l6ZSkge1xuICAgICAgICAgIHRoaXMuc3RhcnRNb25pdG9yV2luZG93UmVzaXplKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzdGFydE1vbml0b3JXaW5kb3dSZXNpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydE1vbml0b3JXaW5kb3dSZXNpemUoKSB7XG4gICAgICBpZiAoIXRoaXMucmVzaXplSGFuZGxlcikge1xuICAgICAgICB0aGlzLnJlc2l6ZUhhbmRsZXIgPSBfcmNVdGlsMlsnZGVmYXVsdCddLkRvbS5hZGRFdmVudExpc3RlbmVyKHdpbmRvdywgJ3Jlc2l6ZScsIGJ1ZmZlcih0aGlzLmhhbmRsZVdpbmRvd1Jlc2l6ZSwgdGhpcy5wcm9wcy5tb25pdG9yQnVmZmVyVGltZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3N0b3BNb25pdG9yV2luZG93UmVzaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcE1vbml0b3JXaW5kb3dSZXNpemUoKSB7XG4gICAgICBpZiAodGhpcy5yZXNpemVIYW5kbGVyKSB7XG4gICAgICAgIHRoaXMucmVzaXplSGFuZGxlci5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5yZXNpemVIYW5kbGVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdoYW5kbGVXaW5kb3dSZXNpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVXaW5kb3dSZXNpemUoKSB7XG4gICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgaWYgKCFwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgICB2YXIgc291cmNlID0gX3JlYWN0MlsnZGVmYXVsdCddLmZpbmRET01Ob2RlKHRoaXMpO1xuICAgICAgICBwcm9wcy5vbkFsaWduKHNvdXJjZSwgKDAsIF9kb21BbGlnbjJbJ2RlZmF1bHQnXSkoc291cmNlLCBwcm9wcy50YXJnZXQoKSwgcHJvcHMuYWxpZ24pKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wb25lbnRXaWxsVW5tb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgdGhpcy5zdG9wTW9uaXRvcldpbmRvd1Jlc2l6ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBvbmVudERpZFVwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgIHZhciByZUFsaWduID0gZmFsc2U7XG4gICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgdmFyIGN1cnJlbnRUYXJnZXQ7XG5cbiAgICAgIGlmICghcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgaWYgKHByZXZQcm9wcy5kaXNhYmxlZCB8fCBwcmV2UHJvcHMuYWxpZ24gIT09IHByb3BzLmFsaWduKSB7XG4gICAgICAgICAgcmVBbGlnbiA9IHRydWU7XG4gICAgICAgICAgY3VycmVudFRhcmdldCA9IHByb3BzLnRhcmdldCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBsYXN0VGFyZ2V0ID0gcHJldlByb3BzLnRhcmdldCgpO1xuICAgICAgICAgIGN1cnJlbnRUYXJnZXQgPSBwcm9wcy50YXJnZXQoKTtcbiAgICAgICAgICBpZiAoaXNXaW5kb3cobGFzdFRhcmdldCkgJiYgaXNXaW5kb3coY3VycmVudFRhcmdldCkpIHtcbiAgICAgICAgICAgIHJlQWxpZ24gPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxhc3RUYXJnZXQgIT09IGN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgICAgIHJlQWxpZ24gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVBbGlnbikge1xuICAgICAgICB2YXIgc291cmNlID0gX3JlYWN0MlsnZGVmYXVsdCddLmZpbmRET01Ob2RlKHRoaXMpO1xuICAgICAgICBwcm9wcy5vbkFsaWduKHNvdXJjZSwgKDAsIF9kb21BbGlnbjJbJ2RlZmF1bHQnXSkoc291cmNlLCBjdXJyZW50VGFyZ2V0LCBwcm9wcy5hbGlnbikpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcHMubW9uaXRvcldpbmRvd1Jlc2l6ZSAmJiAhcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5zdGFydE1vbml0b3JXaW5kb3dSZXNpemUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RvcE1vbml0b3JXaW5kb3dSZXNpemUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLkNoaWxkcmVuLm9ubHkodGhpcy5wcm9wcy5jaGlsZHJlbik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEFsaWduO1xufSkoX3JlYWN0MlsnZGVmYXVsdCddLkNvbXBvbmVudCk7XG5cbkFsaWduLmRlZmF1bHRQcm9wcyA9IHtcbiAgdGFyZ2V0OiBmdW5jdGlvbiB0YXJnZXQoKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfSxcbiAgb25BbGlnbjogZnVuY3Rpb24gb25BbGlnbigpIHt9LFxuICBtb25pdG9yQnVmZmVyVGltZTogNTAsXG4gIG1vbml0b3JXaW5kb3dSZXNpemU6IGZhbHNlLFxuICBkaXNhYmxlZDogZmFsc2Vcbn07XG5cbkFsaWduLlByb3BUeXBlcyA9IHtcbiAgYWxpZ246IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIHRhcmdldDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLFxuICBvbkFsaWduOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmMsXG4gIG1vbml0b3JCdWZmZXJUaW1lOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm51bWJlcixcbiAgbW9uaXRvcldpbmRvd1Jlc2l6ZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLFxuICBkaXNhYmxlZDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sXG59O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBBbGlnbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWFsaWduL2xpYi9BbGlnbi5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX0NoaWxkcmVuVXRpbHMgPSByZXF1aXJlKCcuL0NoaWxkcmVuVXRpbHMnKTtcblxudmFyIF9DaGlsZHJlblV0aWxzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NoaWxkcmVuVXRpbHMpO1xuXG52YXIgX0FuaW1hdGVDaGlsZCA9IHJlcXVpcmUoJy4vQW5pbWF0ZUNoaWxkJyk7XG5cbnZhciBfQW5pbWF0ZUNoaWxkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0FuaW1hdGVDaGlsZCk7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgX3V0aWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbCk7XG5cbnZhciBkZWZhdWx0S2V5ID0gJ3JjX2FuaW1hdGVfJyArIERhdGUubm93KCk7XG5cbmZ1bmN0aW9uIGdldENoaWxkcmVuRnJvbVByb3BzKHByb3BzKSB7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICBpZiAoX3JlYWN0MlsnZGVmYXVsdCddLmlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSkge1xuICAgIGlmICghY2hpbGRyZW4ua2V5KSB7XG4gICAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNsb25lRWxlbWVudChjaGlsZHJlbiwge1xuICAgICAgICBrZXk6IGRlZmF1bHRLZXlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG52YXIgQW5pbWF0ZSA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnQW5pbWF0ZScsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgY29tcG9uZW50OiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmFueSxcbiAgICBhbmltYXRpb246IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIHRyYW5zaXRpb25OYW1lOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLnN0cmluZyxcbiAgICB0cmFuc2l0aW9uRW50ZXI6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCxcbiAgICB0cmFuc2l0aW9uQXBwZWFyOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmJvb2wsXG4gICAgdHJhbnNpdGlvbkxlYXZlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmJvb2wsXG4gICAgb25FbmQ6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkVudGVyOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25MZWF2ZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLFxuICAgIG9uQXBwZWFyOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmMsXG4gICAgc2hvd1Byb3A6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nXG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiBnZXREZWZhdWx0UHJvcHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuaW1hdGlvbjoge30sXG4gICAgICBjb21wb25lbnQ6ICdzcGFuJyxcbiAgICAgIHRyYW5zaXRpb25FbnRlcjogdHJ1ZSxcbiAgICAgIHRyYW5zaXRpb25MZWF2ZTogdHJ1ZSxcbiAgICAgIHRyYW5zaXRpb25BcHBlYXI6IGZhbHNlLFxuICAgICAgb25FbmQ6IG5vb3AsXG4gICAgICBvbkVudGVyOiBub29wLFxuICAgICAgb25MZWF2ZTogbm9vcCxcbiAgICAgIG9uQXBwZWFyOiBub29wXG4gICAgfTtcbiAgfSxcblxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgICB0aGlzLmN1cnJlbnRseUFuaW1hdGluZ0tleXMgPSB7fTtcbiAgICB0aGlzLmtleXNUb0VudGVyID0gW107XG4gICAgdGhpcy5rZXlzVG9MZWF2ZSA9IFtdO1xuICAgIHJldHVybiB7XG4gICAgICBjaGlsZHJlbjogKDAsIF9DaGlsZHJlblV0aWxzLnRvQXJyYXlDaGlsZHJlbikoZ2V0Q2hpbGRyZW5Gcm9tUHJvcHModGhpcy5wcm9wcykpXG4gICAgfTtcbiAgfSxcblxuICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBzaG93UHJvcCA9IHRoaXMucHJvcHMuc2hvd1Byb3A7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5zdGF0ZS5jaGlsZHJlbjtcbiAgICBpZiAoc2hvd1Byb3ApIHtcbiAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiAhIWMucHJvcHNbc2hvd1Byb3BdO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgIF90aGlzLnBlcmZvcm1BcHBlYXIoYy5rZXkpO1xuICAgIH0pO1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgbmV4dENoaWxkcmVuID0gKDAsIF9DaGlsZHJlblV0aWxzLnRvQXJyYXlDaGlsZHJlbikoZ2V0Q2hpbGRyZW5Gcm9tUHJvcHMobmV4dFByb3BzKSk7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgc2hvd1Byb3AgPSBwcm9wcy5zaG93UHJvcDtcbiAgICB2YXIgZXhjbHVzaXZlID0gcHJvcHMuZXhjbHVzaXZlO1xuICAgIHZhciBjdXJyZW50bHlBbmltYXRpbmdLZXlzID0gdGhpcy5jdXJyZW50bHlBbmltYXRpbmdLZXlzO1xuICAgIC8vIGxhc3QgcHJvcHMgY2hpbGRyZW4gaWYgZXhjbHVzaXZlXG4gICAgLy8gZXhjbHVzaXZlIG5lZWRzIGltbWVkaWF0ZSByZXNwb25zZVxuICAgIHZhciBjdXJyZW50Q2hpbGRyZW4gPSB0aGlzLnN0YXRlLmNoaWxkcmVuO1xuICAgIC8vIGluIGNhc2UgZGVzdHJveSBpbiBzaG93UHJvcCBtb2RlXG4gICAgdmFyIG5ld0NoaWxkcmVuID0gW107XG4gICAgaWYgKHNob3dQcm9wKSB7XG4gICAgICBjdXJyZW50Q2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY3VycmVudENoaWxkKSB7XG4gICAgICAgIHZhciBuZXh0Q2hpbGQgPSAoMCwgX0NoaWxkcmVuVXRpbHMuZmluZENoaWxkSW5DaGlsZHJlbkJ5S2V5KShuZXh0Q2hpbGRyZW4sIGN1cnJlbnRDaGlsZC5rZXkpO1xuICAgICAgICB2YXIgbmV3Q2hpbGQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgoIW5leHRDaGlsZCB8fCAhbmV4dENoaWxkLnByb3BzW3Nob3dQcm9wXSkgJiYgY3VycmVudENoaWxkLnByb3BzW3Nob3dQcm9wXSkge1xuICAgICAgICAgIG5ld0NoaWxkID0gX3JlYWN0MlsnZGVmYXVsdCddLmNsb25lRWxlbWVudChuZXh0Q2hpbGQgfHwgY3VycmVudENoaWxkLCBfZGVmaW5lUHJvcGVydHkoe30sIHNob3dQcm9wLCB0cnVlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3Q2hpbGQgPSBuZXh0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0NoaWxkKSB7XG4gICAgICAgICAgbmV3Q2hpbGRyZW4ucHVzaChuZXdDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbmV4dENoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKG5leHRDaGlsZCkge1xuICAgICAgICBpZiAoISgwLCBfQ2hpbGRyZW5VdGlscy5maW5kQ2hpbGRJbkNoaWxkcmVuQnlLZXkpKGN1cnJlbnRDaGlsZHJlbiwgbmV4dENoaWxkLmtleSkpIHtcbiAgICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKG5leHRDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdDaGlsZHJlbiA9IF9DaGlsZHJlblV0aWxzMlsnZGVmYXVsdCddLm1lcmdlQ2hpbGRyZW4oY3VycmVudENoaWxkcmVuLCBuZXh0Q2hpbGRyZW4pO1xuICAgIH1cblxuICAgIC8vIGV4Y2x1c2l2ZSBuZWVkcyBpbW1lZGlhdGUgcmVzcG9uc2VcbiAgICBpZiAoZXhjbHVzaXZlKSB7XG4gICAgICBPYmplY3Qua2V5cyhjdXJyZW50bHlBbmltYXRpbmdLZXlzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX3RoaXMyLnN0b3Aoa2V5KTtcbiAgICAgIH0pO1xuICAgICAgY3VycmVudENoaWxkcmVuID0gKDAsIF9DaGlsZHJlblV0aWxzLnRvQXJyYXlDaGlsZHJlbikoZ2V0Q2hpbGRyZW5Gcm9tUHJvcHMocHJvcHMpKTtcbiAgICB9XG5cbiAgICAvLyBuZWVkIHJlbmRlciB0byBhdm9pZCB1cGRhdGVcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGNoaWxkcmVuOiBuZXdDaGlsZHJlblxuICAgIH0pO1xuXG4gICAgbmV4dENoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgIHZhciBrZXkgPSBjLmtleTtcbiAgICAgIGlmIChjdXJyZW50bHlBbmltYXRpbmdLZXlzW2tleV0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGhhc1ByZXYgPSAoMCwgX0NoaWxkcmVuVXRpbHMuZmluZENoaWxkSW5DaGlsZHJlbkJ5S2V5KShjdXJyZW50Q2hpbGRyZW4sIGtleSk7XG4gICAgICBpZiAoc2hvd1Byb3ApIHtcbiAgICAgICAgdmFyIHNob3dJbk5leHQgPSBjLnByb3BzW3Nob3dQcm9wXTtcbiAgICAgICAgaWYgKGhhc1ByZXYpIHtcbiAgICAgICAgICB2YXIgc2hvd0luTm93ID0gKDAsIF9DaGlsZHJlblV0aWxzLmZpbmRTaG93bkNoaWxkSW5DaGlsZHJlbkJ5S2V5KShjdXJyZW50Q2hpbGRyZW4sIGtleSwgc2hvd1Byb3ApO1xuICAgICAgICAgIGlmICghc2hvd0luTm93ICYmIHNob3dJbk5leHQpIHtcbiAgICAgICAgICAgIF90aGlzMi5rZXlzVG9FbnRlci5wdXNoKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNob3dJbk5leHQpIHtcbiAgICAgICAgICBfdGhpczIua2V5c1RvRW50ZXIucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFoYXNQcmV2KSB7XG4gICAgICAgIF90aGlzMi5rZXlzVG9FbnRlci5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjdXJyZW50Q2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgdmFyIGtleSA9IGMua2V5O1xuICAgICAgaWYgKGN1cnJlbnRseUFuaW1hdGluZ0tleXNba2V5XSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaGFzTmV4dCA9ICgwLCBfQ2hpbGRyZW5VdGlscy5maW5kQ2hpbGRJbkNoaWxkcmVuQnlLZXkpKG5leHRDaGlsZHJlbiwga2V5KTtcbiAgICAgIGlmIChzaG93UHJvcCkge1xuICAgICAgICB2YXIgc2hvd0luTm93ID0gYy5wcm9wc1tzaG93UHJvcF07XG4gICAgICAgIGlmIChoYXNOZXh0KSB7XG4gICAgICAgICAgdmFyIHNob3dJbk5leHQgPSAoMCwgX0NoaWxkcmVuVXRpbHMuZmluZFNob3duQ2hpbGRJbkNoaWxkcmVuQnlLZXkpKG5leHRDaGlsZHJlbiwga2V5LCBzaG93UHJvcCk7XG4gICAgICAgICAgaWYgKCFzaG93SW5OZXh0ICYmIHNob3dJbk5vdykge1xuICAgICAgICAgICAgX3RoaXMyLmtleXNUb0xlYXZlLnB1c2goa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2hvd0luTm93KSB7XG4gICAgICAgICAgX3RoaXMyLmtleXNUb0xlYXZlLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghaGFzTmV4dCkge1xuICAgICAgICBfdGhpczIua2V5c1RvTGVhdmUucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIHZhciBrZXlzVG9FbnRlciA9IHRoaXMua2V5c1RvRW50ZXI7XG4gICAgdGhpcy5rZXlzVG9FbnRlciA9IFtdO1xuICAgIGtleXNUb0VudGVyLmZvckVhY2godGhpcy5wZXJmb3JtRW50ZXIpO1xuICAgIHZhciBrZXlzVG9MZWF2ZSA9IHRoaXMua2V5c1RvTGVhdmU7XG4gICAgdGhpcy5rZXlzVG9MZWF2ZSA9IFtdO1xuICAgIGtleXNUb0xlYXZlLmZvckVhY2godGhpcy5wZXJmb3JtTGVhdmUpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHN0YXRlQ2hpbGRyZW4gPSB0aGlzLnN0YXRlLmNoaWxkcmVuO1xuICAgIHZhciBjaGlsZHJlbiA9IG51bGw7XG4gICAgaWYgKHN0YXRlQ2hpbGRyZW4pIHtcbiAgICAgIGNoaWxkcmVuID0gc3RhdGVDaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGlmICghY2hpbGQua2V5KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHNldCBrZXkgZm9yIDxyYy1hbmltYXRlPiBjaGlsZHJlbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICBfQW5pbWF0ZUNoaWxkMlsnZGVmYXVsdCddLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGtleTogY2hpbGQua2V5LFxuICAgICAgICAgICAgcmVmOiBjaGlsZC5rZXksXG4gICAgICAgICAgICBhbmltYXRpb246IHByb3BzLmFuaW1hdGlvbixcbiAgICAgICAgICAgIHRyYW5zaXRpb25OYW1lOiBwcm9wcy50cmFuc2l0aW9uTmFtZSxcbiAgICAgICAgICAgIHRyYW5zaXRpb25FbnRlcjogcHJvcHMudHJhbnNpdGlvbkVudGVyLFxuICAgICAgICAgICAgdHJhbnNpdGlvbkFwcGVhcjogcHJvcHMudHJhbnNpdGlvbkFwcGVhcixcbiAgICAgICAgICAgIHRyYW5zaXRpb25MZWF2ZTogcHJvcHMudHJhbnNpdGlvbkxlYXZlIH0sXG4gICAgICAgICAgY2hpbGRcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgQ29tcG9uZW50ID0gcHJvcHMuY29tcG9uZW50O1xuICAgIGlmIChDb21wb25lbnQpIHtcbiAgICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICB0aGlzLnByb3BzLFxuICAgICAgICBjaGlsZHJlblxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkcmVuWzBdIHx8IG51bGw7XG4gIH0sXG5cbiAgcGVyZm9ybUVudGVyOiBmdW5jdGlvbiBwZXJmb3JtRW50ZXIoa2V5KSB7XG4gICAgLy8gbWF5IGFscmVhZHkgcmVtb3ZlIGJ5IGV4Y2x1c2l2ZVxuICAgIGlmICh0aGlzLnJlZnNba2V5XSkge1xuICAgICAgdGhpcy5jdXJyZW50bHlBbmltYXRpbmdLZXlzW2tleV0gPSB0cnVlO1xuICAgICAgdGhpcy5yZWZzW2tleV0uY29tcG9uZW50V2lsbEVudGVyKHRoaXMuaGFuZGxlRG9uZUFkZGluZy5iaW5kKHRoaXMsIGtleSwgJ2VudGVyJykpO1xuICAgIH1cbiAgfSxcblxuICBwZXJmb3JtQXBwZWFyOiBmdW5jdGlvbiBwZXJmb3JtQXBwZWFyKGtleSkge1xuICAgIGlmICh0aGlzLnJlZnNba2V5XSkge1xuICAgICAgdGhpcy5jdXJyZW50bHlBbmltYXRpbmdLZXlzW2tleV0gPSB0cnVlO1xuICAgICAgdGhpcy5yZWZzW2tleV0uY29tcG9uZW50V2lsbEFwcGVhcih0aGlzLmhhbmRsZURvbmVBZGRpbmcuYmluZCh0aGlzLCBrZXksICdhcHBlYXInKSk7XG4gICAgfVxuICB9LFxuXG4gIGhhbmRsZURvbmVBZGRpbmc6IGZ1bmN0aW9uIGhhbmRsZURvbmVBZGRpbmcoa2V5LCB0eXBlKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICBkZWxldGUgdGhpcy5jdXJyZW50bHlBbmltYXRpbmdLZXlzW2tleV07XG4gICAgdmFyIGN1cnJlbnRDaGlsZHJlbiA9ICgwLCBfQ2hpbGRyZW5VdGlscy50b0FycmF5Q2hpbGRyZW4pKGdldENoaWxkcmVuRnJvbVByb3BzKHByb3BzKSk7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWRDaGlsZEJ5S2V5KGN1cnJlbnRDaGlsZHJlbiwga2V5KSkge1xuICAgICAgLy8gZXhjbHVzaXZlIHdpbGwgbm90IG5lZWQgdGhpc1xuICAgICAgdGhpcy5wZXJmb3JtTGVhdmUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgPT09ICdhcHBlYXInKSB7XG4gICAgICAgIGlmIChfdXRpbDJbJ2RlZmF1bHQnXS5hbGxvd0FwcGVhckNhbGxiYWNrKHByb3BzKSkge1xuICAgICAgICAgIHByb3BzLm9uQXBwZWFyKGtleSk7XG4gICAgICAgICAgcHJvcHMub25FbmQoa2V5LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKF91dGlsMlsnZGVmYXVsdCddLmFsbG93RW50ZXJDYWxsYmFjayhwcm9wcykpIHtcbiAgICAgICAgICBwcm9wcy5vbkVudGVyKGtleSk7XG4gICAgICAgICAgcHJvcHMub25FbmQoa2V5LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBwZXJmb3JtTGVhdmU6IGZ1bmN0aW9uIHBlcmZvcm1MZWF2ZShrZXkpIHtcbiAgICAvLyBtYXkgYWxyZWFkeSByZW1vdmUgYnkgZXhjbHVzaXZlXG4gICAgaWYgKHRoaXMucmVmc1trZXldKSB7XG4gICAgICB0aGlzLmN1cnJlbnRseUFuaW1hdGluZ0tleXNba2V5XSA9IHRydWU7XG4gICAgICB0aGlzLnJlZnNba2V5XS5jb21wb25lbnRXaWxsTGVhdmUodGhpcy5oYW5kbGVEb25lTGVhdmluZy5iaW5kKHRoaXMsIGtleSkpO1xuICAgIH1cbiAgfSxcblxuICBoYW5kbGVEb25lTGVhdmluZzogZnVuY3Rpb24gaGFuZGxlRG9uZUxlYXZpbmcoa2V5KSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICBkZWxldGUgdGhpcy5jdXJyZW50bHlBbmltYXRpbmdLZXlzW2tleV07XG4gICAgdmFyIGN1cnJlbnRDaGlsZHJlbiA9ICgwLCBfQ2hpbGRyZW5VdGlscy50b0FycmF5Q2hpbGRyZW4pKGdldENoaWxkcmVuRnJvbVByb3BzKHByb3BzKSk7XG4gICAgLy8gaW4gY2FzZSBzdGF0ZSBjaGFuZ2UgaXMgdG9vIGZhc3RcbiAgICBpZiAodGhpcy5pc1ZhbGlkQ2hpbGRCeUtleShjdXJyZW50Q2hpbGRyZW4sIGtleSkpIHtcbiAgICAgIHRoaXMucGVyZm9ybUVudGVyKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChfdXRpbDJbJ2RlZmF1bHQnXS5hbGxvd0xlYXZlQ2FsbGJhY2socHJvcHMpKSB7XG4gICAgICAgIHByb3BzLm9uTGVhdmUoa2V5KTtcbiAgICAgICAgcHJvcHMub25FbmQoa2V5LCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc01vdW50ZWQoKSAmJiAhKDAsIF9DaGlsZHJlblV0aWxzLmlzU2FtZUNoaWxkcmVuKSh0aGlzLnN0YXRlLmNoaWxkcmVuLCBjdXJyZW50Q2hpbGRyZW4sIHByb3BzLnNob3dQcm9wKSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBjaGlsZHJlbjogY3VycmVudENoaWxkcmVuXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBpc1ZhbGlkQ2hpbGRCeUtleTogZnVuY3Rpb24gaXNWYWxpZENoaWxkQnlLZXkoY3VycmVudENoaWxkcmVuLCBrZXkpIHtcbiAgICB2YXIgc2hvd1Byb3AgPSB0aGlzLnByb3BzLnNob3dQcm9wO1xuICAgIGlmIChzaG93UHJvcCkge1xuICAgICAgcmV0dXJuICgwLCBfQ2hpbGRyZW5VdGlscy5maW5kU2hvd25DaGlsZEluQ2hpbGRyZW5CeUtleSkoY3VycmVudENoaWxkcmVuLCBrZXksIHNob3dQcm9wKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBfQ2hpbGRyZW5VdGlscy5maW5kQ2hpbGRJbkNoaWxkcmVuQnlLZXkpKGN1cnJlbnRDaGlsZHJlbiwga2V5KTtcbiAgfSxcblxuICBzdG9wOiBmdW5jdGlvbiBzdG9wKGtleSkge1xuICAgIGRlbGV0ZSB0aGlzLmN1cnJlbnRseUFuaW1hdGluZ0tleXNba2V5XTtcbiAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5yZWZzW2tleV07XG4gICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgY29tcG9uZW50LnN0b3AoKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBBbmltYXRlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvfi9yYy1hbmltYXRlL2xpYi9BbmltYXRlLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciB1dGlscyA9IHtcbiAgdG9BcnJheUNoaWxkcmVuOiBmdW5jdGlvbiB0b0FycmF5Q2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgX3JlYWN0MlsnZGVmYXVsdCddLkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjKSB7XG4gICAgICByZXQucHVzaChjKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIGZpbmRDaGlsZEluQ2hpbGRyZW5CeUtleTogZnVuY3Rpb24gZmluZENoaWxkSW5DaGlsZHJlbkJ5S2V5KGNoaWxkcmVuLCBrZXkpIHtcbiAgICB2YXIgcmV0ID0gbnVsbDtcbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYy5rZXkgPT09IGtleSkge1xuICAgICAgICAgIHJldCA9IGM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIGZpbmRTaG93bkNoaWxkSW5DaGlsZHJlbkJ5S2V5OiBmdW5jdGlvbiBmaW5kU2hvd25DaGlsZEluQ2hpbGRyZW5CeUtleShjaGlsZHJlbiwga2V5LCBzaG93UHJvcCkge1xuICAgIHZhciByZXQgPSBudWxsO1xuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYy5rZXkgPT09IGtleSAmJiBjLnByb3BzW3Nob3dQcm9wXSkge1xuICAgICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHdvIGNoaWxkIHdpdGggc2FtZSBrZXkgZm9yIDxyYy1hbmltYXRlPiBjaGlsZHJlbicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXQgPSBjO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICBmaW5kSGlkZGVuQ2hpbGRJbkNoaWxkcmVuQnlLZXk6IGZ1bmN0aW9uIGZpbmRIaWRkZW5DaGlsZEluQ2hpbGRyZW5CeUtleShjaGlsZHJlbiwga2V5LCBzaG93UHJvcCkge1xuICAgIHZhciBmb3VuZCA9IDA7XG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3VuZCA9IGMua2V5ID09PSBrZXkgJiYgIWMucHJvcHNbc2hvd1Byb3BdO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBmb3VuZDtcbiAgfSxcblxuICBpc1NhbWVDaGlsZHJlbjogZnVuY3Rpb24gaXNTYW1lQ2hpbGRyZW4oYzEsIGMyLCBzaG93UHJvcCkge1xuICAgIHZhciBzYW1lID0gYzEubGVuZ3RoID09PSBjMi5sZW5ndGg7XG4gICAgaWYgKHNhbWUpIHtcbiAgICAgIGMxLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkLCBpKSB7XG4gICAgICAgIHZhciBjaGlsZDIgPSBjMltpXTtcbiAgICAgICAgaWYgKGNoaWxkLmtleSAhPT0gY2hpbGQyLmtleSkge1xuICAgICAgICAgIHNhbWUgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChzaG93UHJvcCAmJiBjaGlsZC5wcm9wc1tzaG93UHJvcF0gIT09IGNoaWxkMi5wcm9wc1tzaG93UHJvcF0pIHtcbiAgICAgICAgICBzYW1lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc2FtZTtcbiAgfSxcblxuICBtZXJnZUNoaWxkcmVuOiBmdW5jdGlvbiBtZXJnZUNoaWxkcmVuKHByZXYsIG5leHQpIHtcbiAgICB2YXIgcmV0ID0gW107XG5cbiAgICAvLyBGb3IgZWFjaCBrZXkgb2YgYG5leHRgLCB0aGUgbGlzdCBvZiBrZXlzIHRvIGluc2VydCBiZWZvcmUgdGhhdCBrZXkgaW5cbiAgICAvLyB0aGUgY29tYmluZWQgbGlzdFxuICAgIHZhciBuZXh0Q2hpbGRyZW5QZW5kaW5nID0ge307XG4gICAgdmFyIHBlbmRpbmdDaGlsZHJlbiA9IFtdO1xuICAgIHByZXYuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKHV0aWxzLmZpbmRDaGlsZEluQ2hpbGRyZW5CeUtleShuZXh0LCBjLmtleSkpIHtcbiAgICAgICAgaWYgKHBlbmRpbmdDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICBuZXh0Q2hpbGRyZW5QZW5kaW5nW2Mua2V5XSA9IHBlbmRpbmdDaGlsZHJlbjtcbiAgICAgICAgICBwZW5kaW5nQ2hpbGRyZW4gPSBbXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVuZGluZ0NoaWxkcmVuLnB1c2goYyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBuZXh0LmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgIGlmIChuZXh0Q2hpbGRyZW5QZW5kaW5nLmhhc093blByb3BlcnR5KGMua2V5KSkge1xuICAgICAgICByZXQgPSByZXQuY29uY2F0KG5leHRDaGlsZHJlblBlbmRpbmdbYy5rZXldKTtcbiAgICAgIH1cbiAgICAgIHJldC5wdXNoKGMpO1xuICAgIH0pO1xuXG4gICAgcmV0ID0gcmV0LmNvbmNhdChwZW5kaW5nQ2hpbGRyZW4pO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gdXRpbHM7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vfi91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9+L3JjLWFuaW1hdGUvbGliL0NoaWxkcmVuVXRpbHMuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9jc3NBbmltYXRpb24gPSByZXF1aXJlKCdjc3MtYW5pbWF0aW9uJyk7XG5cbnZhciBfY3NzQW5pbWF0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Nzc0FuaW1hdGlvbik7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgX3V0aWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbCk7XG5cbnZhciB0cmFuc2l0aW9uTWFwID0ge1xuICBlbnRlcjogJ3RyYW5zaXRpb25FbnRlcicsXG4gIGFwcGVhcjogJ3RyYW5zaXRpb25BcHBlYXInLFxuICBsZWF2ZTogJ3RyYW5zaXRpb25MZWF2ZSdcbn07XG5cbnZhciBBbmltYXRlQ2hpbGQgPSBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ0FuaW1hdGVDaGlsZCcsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgY2hpbGRyZW46IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYW55XG4gIH0sXG5cbiAgdHJhbnNpdGlvbjogZnVuY3Rpb24gdHJhbnNpdGlvbihhbmltYXRpb25UeXBlLCBmaW5pc2hDYWxsYmFjaykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgbm9kZSA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5maW5kRE9NTm9kZSh0aGlzKTtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciB0cmFuc2l0aW9uTmFtZSA9IHByb3BzLnRyYW5zaXRpb25OYW1lO1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIHZhciBlbmQgPSBmdW5jdGlvbiBlbmQoKSB7XG4gICAgICBfdGhpcy5zdG9wcGVyID0gbnVsbDtcbiAgICAgIGZpbmlzaENhbGxiYWNrKCk7XG4gICAgfTtcbiAgICBpZiAoKF9jc3NBbmltYXRpb24uaXNDc3NBbmltYXRpb25TdXBwb3J0ZWQgfHwgIXByb3BzLmFuaW1hdGlvblthbmltYXRpb25UeXBlXSkgJiYgdHJhbnNpdGlvbk5hbWUgJiYgcHJvcHNbdHJhbnNpdGlvbk1hcFthbmltYXRpb25UeXBlXV0pIHtcbiAgICAgIHRoaXMuc3RvcHBlciA9ICgwLCBfY3NzQW5pbWF0aW9uMlsnZGVmYXVsdCddKShub2RlLCB0cmFuc2l0aW9uTmFtZSArICctJyArIGFuaW1hdGlvblR5cGUsIGVuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RvcHBlciA9IHByb3BzLmFuaW1hdGlvblthbmltYXRpb25UeXBlXShub2RlLCBlbmQpO1xuICAgIH1cbiAgfSxcblxuICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgIGlmICh0aGlzLnN0b3BwZXIpIHtcbiAgICAgIHRoaXMuc3RvcHBlci5zdG9wKCk7XG4gICAgICB0aGlzLnN0b3BwZXIgPSBudWxsO1xuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5zdG9wKCk7XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbEVudGVyOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsRW50ZXIoZG9uZSkge1xuICAgIGlmIChfdXRpbDJbJ2RlZmF1bHQnXS5pc0VudGVyU3VwcG9ydGVkKHRoaXMucHJvcHMpKSB7XG4gICAgICB0aGlzLnRyYW5zaXRpb24oJ2VudGVyJywgZG9uZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvbmUoKTtcbiAgICB9XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbEFwcGVhcjogZnVuY3Rpb24gY29tcG9uZW50V2lsbEFwcGVhcihkb25lKSB7XG4gICAgaWYgKF91dGlsMlsnZGVmYXVsdCddLmlzQXBwZWFyU3VwcG9ydGVkKHRoaXMucHJvcHMpKSB7XG4gICAgICB0aGlzLnRyYW5zaXRpb24oJ2FwcGVhcicsIGRvbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb25lKCk7XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxMZWF2ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbExlYXZlKGRvbmUpIHtcbiAgICBpZiAoX3V0aWwyWydkZWZhdWx0J10uaXNMZWF2ZVN1cHBvcnRlZCh0aGlzLnByb3BzKSkge1xuICAgICAgdGhpcy50cmFuc2l0aW9uKCdsZWF2ZScsIGRvbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb25lKCk7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICB9XG59KTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gQW5pbWF0ZUNoaWxkO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvfi9yYy1hbmltYXRlL2xpYi9BbmltYXRlQ2hpbGQuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9tb250aE1vbnRoUGFuZWwgPSByZXF1aXJlKCcuL21vbnRoL01vbnRoUGFuZWwnKTtcblxudmFyIF9tb250aE1vbnRoUGFuZWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbW9udGhNb250aFBhbmVsKTtcblxudmFyIF9taXhpbkNhbGVuZGFyTWl4aW4gPSByZXF1aXJlKCcuL21peGluL0NhbGVuZGFyTWl4aW4nKTtcblxudmFyIF9taXhpbkNhbGVuZGFyTWl4aW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWl4aW5DYWxlbmRhck1peGluKTtcblxudmFyIF9yY1V0aWwgPSByZXF1aXJlKCdyYy11dGlsJyk7XG5cbnZhciBNb250aENhbGVuZGFyID0gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdNb250aENhbGVuZGFyJyxcblxuICBtaXhpbnM6IFtfbWl4aW5DYWxlbmRhck1peGluMlsnZGVmYXVsdCddXSxcblxuICBvbktleURvd246IGZ1bmN0aW9uIG9uS2V5RG93bihlKSB7XG4gICAgdmFyIGtleUNvZGUgPSBlLmtleUNvZGU7XG4gICAgdmFyIGN0cmxLZXkgPSBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5O1xuICAgIHZhciBzdGF0ZVZhbHVlID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICB2YXIgdmFsdWUgPSBzdGF0ZVZhbHVlO1xuICAgIHN3aXRjaCAoa2V5Q29kZSkge1xuICAgICAgY2FzZSBfcmNVdGlsLktleUNvZGUuRE9XTjpcbiAgICAgICAgdmFsdWUgPSBzdGF0ZVZhbHVlLmNsb25lKCk7XG4gICAgICAgIHZhbHVlLmFkZE1vbnRoKDMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX3JjVXRpbC5LZXlDb2RlLlVQOlxuICAgICAgICB2YWx1ZSA9IHN0YXRlVmFsdWUuY2xvbmUoKTtcbiAgICAgICAgdmFsdWUuYWRkTW9udGgoLTMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX3JjVXRpbC5LZXlDb2RlLkxFRlQ6XG4gICAgICAgIHZhbHVlID0gc3RhdGVWYWx1ZS5jbG9uZSgpO1xuICAgICAgICBpZiAoY3RybEtleSkge1xuICAgICAgICAgIHZhbHVlLmFkZFllYXIoLTEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlLmFkZE1vbnRoKC0xKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX3JjVXRpbC5LZXlDb2RlLlJJR0hUOlxuICAgICAgICB2YWx1ZSA9IHN0YXRlVmFsdWUuY2xvbmUoKTtcbiAgICAgICAgaWYgKGN0cmxLZXkpIHtcbiAgICAgICAgICB2YWx1ZS5hZGRZZWFyKDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlLmFkZE1vbnRoKDEpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfcmNVdGlsLktleUNvZGUuRU5URVI6XG4gICAgICAgIHRoaXMub25TZWxlY3Qoc3RhdGVWYWx1ZSk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT09IHN0YXRlVmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0VmFsdWUodmFsdWUpO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGNoaWxkcmVuID0gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoX21vbnRoTW9udGhQYW5lbDJbJ2RlZmF1bHQnXSwgeyBsb2NhbGU6IHByb3BzLmxvY2FsZSxcbiAgICAgIGRpc2FibGVkRGF0ZTogcHJvcHMuZGlzYWJsZWREYXRlLFxuICAgICAgc3R5bGU6IHsgcG9zaXRpb246ICdyZWxhdGl2ZScgfSxcbiAgICAgIHZhbHVlOiB0aGlzLnN0YXRlLnZhbHVlLFxuICAgICAgcm9vdFByZWZpeENsczogcHJvcHMucHJlZml4Q2xzLFxuICAgICAgb25DaGFuZ2U6IHRoaXMuc2V0VmFsdWUsXG4gICAgICBvblNlbGVjdDogdGhpcy5vblNlbGVjdCB9KTtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJSb290KHtcbiAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgIH0pO1xuICB9XG59KTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gTW9udGhDYWxlbmRhcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9+L3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL2xpYi9Nb250aENhbGVuZGFyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2dyZWdvcmlhbkNhbGVuZGFyRm9ybWF0ID0gcmVxdWlyZSgnZ3JlZ29yaWFuLWNhbGVuZGFyLWZvcm1hdCcpO1xuXG52YXIgX2dyZWdvcmlhbkNhbGVuZGFyRm9ybWF0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dyZWdvcmlhbkNhbGVuZGFyRm9ybWF0KTtcblxudmFyIF9yY1V0aWwgPSByZXF1aXJlKCdyYy11dGlsJyk7XG5cbnZhciBfcmNVdGlsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JjVXRpbCk7XG5cbnZhciBfcmNBbGlnbiA9IHJlcXVpcmUoJ3JjLWFsaWduJyk7XG5cbnZhciBfcmNBbGlnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yY0FsaWduKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbi8vIGltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG4vLyBpbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcblxudmFyIHRvRnJhZ21lbnQgPSBfcmNVdGlsMltcImRlZmF1bHRcIl0uQ2hpbGRyZW4ubWFwU2VsZjtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIG9yaWVudE1hcCA9IHtcbiAgdGw6IFsndG9wJywgJ2xlZnQnXSxcbiAgdHI6IFsndG9wJywgJ3JpZ2h0J10sXG4gIGJsOiBbJ2JvdHRvbScsICdsZWZ0J10sXG4gIGJyOiBbJ2JvdHRvbScsICdyaWdodCddXG59O1xuXG5mdW5jdGlvbiBnZXRJbW11dGFibGVPcmllbnQob3JpZW50KSB7XG4gIGlmIChvcmllbnQpIHtcbiAgICBmb3IgKHZhciBpIGluIG9yaWVudE1hcCkge1xuICAgICAgaWYgKG9yaWVudE1hcC5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICB2YXIgb3JpZ2luYWwgPSBvcmllbnRNYXBbaV07XG4gICAgICAgIGlmIChvcmlnaW5hbFswXSA9PT0gb3JpZW50WzBdICYmIG9yaWdpbmFsWzFdID09PSBvcmllbnRbMV0pIHtcbiAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJldmVudChlKSB7XG4gIGUucHJldmVudERlZmF1bHQoKTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIHJlZkZuKGZpZWxkLCBjb21wb25lbnQpIHtcbiAgdGhpc1tmaWVsZF0gPSBjb21wb25lbnQ7XG59XG5cbi8qKlxuICogRGF0ZVBpY2tlciA9IHdyYXAgaW5wdXQgdXNpbmcgQ2FsZW5kYXJcbiAqL1xudmFyIFBpY2tlciA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdQaWNrZXInLFxuXG4gIHByb3BUeXBlczoge1xuICAgIG9uQ2hhbmdlOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbk9wZW46IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uQ2xvc2U6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIGNhbGVuZGFyOiBSZWFjdC5Qcm9wVHlwZXMuZWxlbWVudCxcbiAgICBzdHlsZTogUmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBvcGVuOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBkZWZhdWx0T3BlbjogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgcHJlZml4Q2xzOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGFkanVzdE9yaWVudE9uQ2FsZW5kYXJPdmVyZmxvdzogUmVhY3QuUHJvcFR5cGVzLm9uZU9mVHlwZShbUmVhY3QuUHJvcFR5cGVzLmJvb2wsIFJlYWN0LlByb3BUeXBlcy5vYmplY3RdKSxcbiAgICBnZXRDYWxlbmRhckNvbnRhaW5lcjogUmVhY3QuUHJvcFR5cGVzLmZ1bmNcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHJlZml4Q2xzOiAncmMtY2FsZW5kYXItcGlja2VyJyxcbiAgICAgIGFkanVzdE9yaWVudE9uQ2FsZW5kYXJPdmVyZmxvdzogdHJ1ZSxcbiAgICAgIHN0eWxlOiB7fSxcbiAgICAgIGRlZmF1bHRPcGVuOiBmYWxzZSxcbiAgICAgIG9uQ2hhbmdlOiBub29wLFxuICAgICAgb25PcGVuOiBub29wLFxuICAgICAgb25DbG9zZTogbm9vcCxcbiAgICAgIGZvcm1hdHRlcjogbmV3IF9ncmVnb3JpYW5DYWxlbmRhckZvcm1hdDJbXCJkZWZhdWx0XCJdKCd5eXl5LU1NLWRkJyksXG4gICAgICBnZXRDYWxlbmRhckNvbnRhaW5lcjogZnVuY3Rpb24gZ2V0Q2FsZW5kYXJDb250YWluZXIoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5ib2R5O1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIG9wZW4gPSB1bmRlZmluZWQ7XG4gICAgaWYgKCdvcGVuJyBpbiBwcm9wcykge1xuICAgICAgb3BlbiA9IHByb3BzLm9wZW47XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wZW4gPSBwcm9wcy5kZWZhdWx0T3BlbjtcbiAgICB9XG4gICAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWUgfHwgcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIHRoaXMuc2F2ZUNhbGVuZGFyUmVmID0gcmVmRm4uYmluZCh0aGlzLCAnY2FsZW5kYXJJbnN0YW5jZScpO1xuICAgIHRoaXMuc2F2ZUlucHV0UmVmID0gcmVmRm4uYmluZCh0aGlzLCAnaW5wdXRJbnN0YW5jZScpO1xuICAgIHJldHVybiB7IG9wZW46IG9wZW4sIHZhbHVlOiB2YWx1ZSB9O1xuICB9LFxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIHZhciB2YWx1ZSA9IG5leHRQcm9wcy52YWx1ZTtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gbnVsbCBzcGVjaWFsIG1lYW5pbmdcbiAgICAgIHZhbHVlID0gdmFsdWUgfHwgbmV4dFByb3BzLmRlZmF1bHRWYWx1ZSB8fCBudWxsO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICgnb3BlbicgaW4gbmV4dFByb3BzKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgb3BlbjogbmV4dFByb3BzLm9wZW5cbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgY29tcG9uZW50RGlkVXBkYXRlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgaWYgKHRoaXMuaGF2ZU9wZW5lZCkge1xuICAgICAgUmVhY3RET00ucmVuZGVyKHRoaXMuZ2V0Q2FsZW5kYXJFbGVtZW50KCksIHRoaXMuZ2V0Q2FsZW5kYXJDb250YWluZXIoKSk7XG4gICAgfVxuICB9LFxuICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuY2FsZW5kYXJDb250YWluZXIpIHtcbiAgICAgIFJlYWN0LnVubW91bnRDb21wb25lbnRBdE5vZGUodGhpcy5jYWxlbmRhckNvbnRhaW5lcik7XG4gICAgICB0aGlzLmNhbGVuZGFyQ29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5jYWxlbmRhckNvbnRhaW5lcik7XG4gICAgICB0aGlzLmNhbGVuZGFyQ29udGFpbmVyID0gbnVsbDtcbiAgICB9XG4gIH0sXG4gIG9uQ2FsZW5kYXJBbGlnbjogZnVuY3Rpb24gb25DYWxlbmRhckFsaWduKG5vZGUsIGFsaWduKSB7XG4gICAgdmFyIHBvaW50cyA9IGFsaWduLnBvaW50cztcbiAgICB2YXIgbmV3T3JpZW50ID0gb3JpZW50TWFwW3BvaW50c1swXV07XG4gICAgdGhpcy5jYWxlbmRhckluc3RhbmNlLnNldE9yaWVudChuZXdPcmllbnQpO1xuICAgIC8vIGZvY3VzIGFmdGVyIGFsaWduXG4gICAgUmVhY3RET00uZmluZERPTU5vZGUodGhpcy5jYWxlbmRhckluc3RhbmNlKS5mb2N1cygpO1xuICB9LFxuICBvbklucHV0Q2xpY2s6IGZ1bmN0aW9uIG9uSW5wdXRDbGljaygpIHtcbiAgICB0aGlzLnRvZ2dsZSgpO1xuICB9LFxuICBvblRyaWdnZXJDbGljazogZnVuY3Rpb24gb25UcmlnZ2VyQ2xpY2soKSB7XG4gICAgdGhpcy50b2dnbGUoKTtcbiAgfSxcbiAgb25LZXlEb3duOiBmdW5jdGlvbiBvbktleURvd24oZSkge1xuICAgIC8vIGRvd25cbiAgICBpZiAoZS5rZXlDb2RlID09PSBfcmNVdGlsLktleUNvZGUuRE9XTikge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5vcGVuKCk7XG4gICAgfVxuICB9LFxuICBvbkNhbGVuZGFyS2V5RG93bjogZnVuY3Rpb24gb25DYWxlbmRhcktleURvd24oZSkge1xuICAgIGlmIChlLmtleUNvZGUgPT09IF9yY1V0aWwuS2V5Q29kZS5FU0MpIHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB0aGlzLmNsb3NlKHRoaXMuZm9jdXNJbnB1dCk7XG4gICAgfVxuICB9LFxuICBvbkNhbGVuZGFyU2VsZWN0OiBmdW5jdGlvbiBvbkNhbGVuZGFyU2VsZWN0KHZhbHVlKSB7XG4gICAgdmFyIGN1cnJlbnRWYWx1ZSA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9KTtcbiAgICBpZiAoIXRoaXMucHJvcHMuY2FsZW5kYXIucHJvcHMuc2hvd1RpbWUpIHtcbiAgICAgIHRoaXMuY2xvc2UodGhpcy5mb2N1c0lucHV0KTtcbiAgICB9XG4gICAgaWYgKCFjdXJyZW50VmFsdWUgfHwgY3VycmVudFZhbHVlLmdldFRpbWUoKSAhPT0gdmFsdWUuZ2V0VGltZSgpKSB7XG4gICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHZhbHVlKTtcbiAgICB9XG4gIH0sXG4gIG9uQ2FsZW5kYXJCbHVyOiBmdW5jdGlvbiBvbkNhbGVuZGFyQmx1cigpIHtcbiAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdGhpcy5nZXRJbnB1dERPTU5vZGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBpZiBpbnZpc2libGUsIHdpbGwgbm90IHRyaWdnZXIgYmx1clxuICAgIC8vIGRvIG5vdCBzZXQgaWYgYWxyZWFkeSBmYWxzZSwgYXZvaWQgcnVpbiBhbmltYXRlXG4gICAgdGhpcy5jbG9zZSgpO1xuICB9LFxuICBvbkNhbGVuZGFyT2s6IGZ1bmN0aW9uIG9uQ2FsZW5kYXJPaygpIHtcbiAgICB0aGlzLmNsb3NlKHRoaXMuZm9jdXNJbnB1dCk7XG4gIH0sXG4gIG9uQ2FsZW5kYXJDbGVhcjogZnVuY3Rpb24gb25DYWxlbmRhckNsZWFyKCkge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcbiAgICB0aGlzLmNsb3NlKHRoaXMuZm9jdXNJbnB1dCk7XG4gICAgaWYgKHRoaXMuc3RhdGUudmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UobnVsbCk7XG4gICAgfVxuICB9LFxuICBvbkNhbGVuZGFyQ2hhbmdlOiBmdW5jdGlvbiBvbkNhbGVuZGFyQ2hhbmdlKHZhbHVlKSB7XG4gICAgdGhpcy5jYWxlbmRhckluc3RhbmNlLnNldFN0YXRlKHtcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0pO1xuICB9LFxuICBnZXRJbnB1dERPTU5vZGU6IGZ1bmN0aW9uIGdldElucHV0RE9NTm9kZSgpIHtcbiAgICByZXR1cm4gUmVhY3RET00uZmluZERPTU5vZGUodGhpcy5pbnB1dEluc3RhbmNlKTtcbiAgfSxcbiAgZ2V0VHJhbnNpdGlvbk5hbWU6IGZ1bmN0aW9uIGdldFRyYW5zaXRpb25OYW1lKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHRyYW5zaXRpb25OYW1lID0gcHJvcHMudHJhbnNpdGlvbk5hbWU7XG4gICAgaWYgKCF0cmFuc2l0aW9uTmFtZSAmJiBwcm9wcy5hbmltYXRpb24pIHtcbiAgICAgIHRyYW5zaXRpb25OYW1lID0gcHJvcHMucHJlZml4Q2xzICsgJy0nICsgcHJvcHMuYW5pbWF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNpdGlvbk5hbWU7XG4gIH0sXG4gIGdldENhbGVuZGFyQ29udGFpbmVyOiBmdW5jdGlvbiBnZXRDYWxlbmRhckNvbnRhaW5lcigpIHtcbiAgICBpZiAoIXRoaXMuY2FsZW5kYXJDb250YWluZXIpIHtcbiAgICAgIHRoaXMuY2FsZW5kYXJDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMuY2FsZW5kYXJDb250YWluZXIuY2xhc3NOYW1lID0gdGhpcy5wcm9wcy5wcmVmaXhDbHMgKyAnLWNvbnRhaW5lcic7XG4gICAgICB0aGlzLnByb3BzLmdldENhbGVuZGFyQ29udGFpbmVyKCkuYXBwZW5kQ2hpbGQodGhpcy5jYWxlbmRhckNvbnRhaW5lcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNhbGVuZGFyQ29udGFpbmVyO1xuICB9LFxuICBnZXRBbGlnbjogZnVuY3Rpb24gZ2V0QWxpZ24ob3JpZW50KSB7XG4gICAgdmFyIHBvaW50cyA9IFsndGwnLCAnYmwnXTtcbiAgICB2YXIgb2Zmc2V0ID0gWzAsIDVdO1xuICAgIHZhciBhZGp1c3RPcmllbnRPbkNhbGVuZGFyT3ZlcmZsb3cgPSB0aGlzLnByb3BzLmFkanVzdE9yaWVudE9uQ2FsZW5kYXJPdmVyZmxvdztcbiAgICBpZiAob3JpZW50LmluZGV4T2YoJ3RvcCcpICE9PSAtMSAmJiBvcmllbnQuaW5kZXhPZignbGVmdCcpICE9PSAtMSkge1xuICAgICAgcG9pbnRzID0gWyd0bCcsICdibCddO1xuICAgIH0gZWxzZSBpZiAob3JpZW50LmluZGV4T2YoJ3RvcCcpICE9PSAtMSAmJiBvcmllbnQuaW5kZXhPZigncmlnaHQnKSAhPT0gLTEpIHtcbiAgICAgIHBvaW50cyA9IFsndHInLCAnYnInXTtcbiAgICB9IGVsc2UgaWYgKG9yaWVudC5pbmRleE9mKCdib3R0b20nKSAhPT0gLTEgJiYgb3JpZW50LmluZGV4T2YoJ2xlZnQnKSAhPT0gLTEpIHtcbiAgICAgIHBvaW50cyA9IFsnYmwnLCAndGwnXTtcbiAgICAgIG9mZnNldCA9IFswLCAtNV07XG4gICAgfSBlbHNlIGlmIChvcmllbnQuaW5kZXhPZignYm90dG9tJykgIT09IC0xICYmIG9yaWVudC5pbmRleE9mKCdyaWdodCcpICE9PSAtMSkge1xuICAgICAgcG9pbnRzID0gWydicicsICd0ciddO1xuICAgICAgb2Zmc2V0ID0gWzAsIC01XTtcbiAgICB9XG4gICAgdmFyIGFkanVzdFggPSB1bmRlZmluZWQ7XG4gICAgdmFyIGFkanVzdFkgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGFkanVzdE9yaWVudE9uQ2FsZW5kYXJPdmVyZmxvdyA9PT0gdHJ1ZSkge1xuICAgICAgYWRqdXN0WCA9IGFkanVzdFkgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIWFkanVzdE9yaWVudE9uQ2FsZW5kYXJPdmVyZmxvdykge1xuICAgICAgYWRqdXN0WCA9IGFkanVzdFkgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWRqdXN0WCA9IGFkanVzdE9yaWVudE9uQ2FsZW5kYXJPdmVyZmxvdy54O1xuICAgICAgYWRqdXN0WSA9IGFkanVzdE9yaWVudE9uQ2FsZW5kYXJPdmVyZmxvdy55O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcG9pbnRzOiBwb2ludHMsXG4gICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgIG92ZXJmbG93OiB7XG4gICAgICAgIGFkanVzdFg6IGFkanVzdFgsXG4gICAgICAgIGFkanVzdFk6IGFkanVzdFlcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBnZXRDYWxlbmRhckVsZW1lbnQ6IGZ1bmN0aW9uIGdldENhbGVuZGFyRWxlbWVudCgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdmFyIGNhbGVuZGFyUHJvcCA9IHByb3BzLmNhbGVuZGFyO1xuICAgIHZhciBvcmllbnQgPSB1bmRlZmluZWQ7XG4gICAgLy8gcmUgYWxpZ24gd2hlbiBvcGVuXG4gICAgaWYgKHN0YXRlLm9wZW4pIHtcbiAgICAgIG9yaWVudCA9IGdldEltbXV0YWJsZU9yaWVudChjYWxlbmRhclByb3AucHJvcHMub3JpZW50KSB8fCBvcmllbnRNYXAudGw7XG4gICAgfVxuICAgIHZhciBjYWxlbmRhckVsZW1lbnQgPSBSZWFjdC5jbG9uZUVsZW1lbnQoY2FsZW5kYXJQcm9wLCB7XG4gICAgICByZWY6ICgwLCBfcmNVdGlsLmNyZWF0ZUNoYWluZWRGdW5jdGlvbikoY2FsZW5kYXJQcm9wLnJlZiwgdGhpcy5zYXZlQ2FsZW5kYXJSZWYpLFxuICAgICAgdmFsdWU6IHN0YXRlLnZhbHVlLFxuICAgICAgdmlzaWJsZTogc3RhdGUub3BlbixcbiAgICAgIG9yaWVudDogb3JpZW50LFxuICAgICAgb25CbHVyOiB0aGlzLm9uQ2FsZW5kYXJCbHVyLFxuICAgICAgb25LZXlEb3duOiB0aGlzLm9uQ2FsZW5kYXJLZXlEb3duLFxuICAgICAgb25DaGFuZ2U6ICgwLCBfcmNVdGlsLmNyZWF0ZUNoYWluZWRGdW5jdGlvbikoY2FsZW5kYXJQcm9wLnByb3BzLm9uQ2hhbmdlLCB0aGlzLm9uQ2FsZW5kYXJDaGFuZ2UpLFxuICAgICAgb25PazogKDAsIF9yY1V0aWwuY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKShjYWxlbmRhclByb3AucHJvcHMub25PaywgdGhpcy5vbkNhbGVuZGFyT2spLFxuICAgICAgb25TZWxlY3Q6ICgwLCBfcmNVdGlsLmNyZWF0ZUNoYWluZWRGdW5jdGlvbikoY2FsZW5kYXJQcm9wLnByb3BzLm9uU2VsZWN0LCB0aGlzLm9uQ2FsZW5kYXJTZWxlY3QpLFxuICAgICAgb25DbGVhcjogKDAsIF9yY1V0aWwuY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKShjYWxlbmRhclByb3AucHJvcHMub25DbGVhciwgdGhpcy5vbkNhbGVuZGFyQ2xlYXIpXG4gICAgfSk7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBfcmNBbGlnbjJbXCJkZWZhdWx0XCJdLFxuICAgICAgeyB0YXJnZXQ6IHRoaXMuZ2V0SW5wdXRET01Ob2RlLFxuICAgICAgICBrZXk6ICdjYWxlbmRhcicsXG4gICAgICAgIG9uQWxpZ246IHRoaXMub25DYWxlbmRhckFsaWduLFxuICAgICAgICBjYWxlbmRhck9wZW46IHN0YXRlLm9wZW4sXG4gICAgICAgIGRpc2FibGVkOiAhc3RhdGUub3BlbixcbiAgICAgICAgYWxpZ246IG9yaWVudCAmJiB0aGlzLmdldEFsaWduKG9yaWVudCkgfSxcbiAgICAgIGNhbGVuZGFyRWxlbWVudFxuICAgICk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfY2xhc3NlcztcblxuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGRpc2FibGVkID0gcHJvcHMuZGlzYWJsZWQ7XG4gICAgdmFyIHByZWZpeENscyA9IHByb3BzLnByZWZpeENscztcbiAgICB2YXIgaW5wdXQgPSBwcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHZhciB2YWx1ZSA9IHN0YXRlLnZhbHVlO1xuICAgIHRoaXMuaGF2ZU9wZW5lZCA9IHRoaXMuaGF2ZU9wZW5lZCB8fCBzdGF0ZS5vcGVuO1xuICAgIHZhciBpbnB1dFZhbHVlID0gJyc7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBpbnB1dFZhbHVlID0gcHJvcHMuZm9ybWF0dGVyLmZvcm1hdCh2YWx1ZSk7XG4gICAgfVxuICAgIGlucHV0ID0gUmVhY3QuY2xvbmVFbGVtZW50KGlucHV0LCB7XG4gICAgICByZWY6ICgwLCBfcmNVdGlsLmNyZWF0ZUNoYWluZWRGdW5jdGlvbikoaW5wdXQucmVmLCB0aGlzLnNhdmVJbnB1dFJlZiksXG4gICAgICBkaXNhYmxlZDogZGlzYWJsZWQsXG4gICAgICBvbkNoYW5nZTogbm9vcCxcbiAgICAgIG9uQ2xpY2s6IGRpc2FibGVkID8gbm9vcCA6IHRoaXMub25JbnB1dENsaWNrLFxuICAgICAgdmFsdWU6IGlucHV0VmFsdWUsXG4gICAgICBvbktleURvd246IGRpc2FibGVkID8gbm9vcCA6IHRoaXMub25LZXlEb3duXG4gICAgfSk7XG4gICAgdmFyIGNsYXNzZXMgPSAoX2NsYXNzZXMgPSB7fSwgX2NsYXNzZXNbcHJlZml4Q2xzXSA9IDEsIF9jbGFzc2VzW3ByZWZpeENscyArICctb3BlbiddID0gc3RhdGUub3BlbiwgX2NsYXNzZXNbcHJlZml4Q2xzICsgJy1kaXNhYmxlZCddID0gZGlzYWJsZWQsIF9jbGFzc2VzKTtcbiAgICB2YXIgdHJpZ2dlciA9IHByb3BzLnRyaWdnZXI7XG4gICAgaWYgKHRyaWdnZXIpIHtcbiAgICAgIHRyaWdnZXIgPSBSZWFjdC5jbG9uZUVsZW1lbnQodHJpZ2dlciwge1xuICAgICAgICB1bnNlbGVjdGFibGU6IHRydWUsXG4gICAgICAgIG9uTW91c2VEb3duOiBwcmV2ZW50LFxuICAgICAgICBvbkNsaWNrOiBkaXNhYmxlZCA/IG5vb3AgOiB0aGlzLm9uVHJpZ2dlckNsaWNrXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnc3BhbicsXG4gICAgICB7IGNsYXNzTmFtZTogKDAsIF9yY1V0aWwuY2xhc3NTZXQpKGNsYXNzZXMpLCBzdHlsZTogcHJvcHMuc3R5bGUgfSxcbiAgICAgIHRvRnJhZ21lbnQoW2lucHV0LCB0cmlnZ2VyXSlcbiAgICApO1xuICB9LFxuICBmb2N1c0lucHV0OiBmdW5jdGlvbiBmb2N1c0lucHV0KCkge1xuICAgIGlmICghdGhpcy5zdGF0ZS5vcGVuKSB7XG4gICAgICB0aGlzLmdldElucHV0RE9NTm9kZSgpLmZvY3VzKCk7XG4gICAgfVxuICB9LFxuICBzZXRPcGVuOiBmdW5jdGlvbiBzZXRPcGVuKG9wZW4sIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUub3BlbiAhPT0gb3Blbikge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIG9wZW46IG9wZW5cbiAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICAgIHZhciBldmVudCA9IHtcbiAgICAgICAgb3Blbjogb3BlblxuICAgICAgfTtcbiAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25PcGVuKGV2ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJvcHMub25DbG9zZShldmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICB0b2dnbGU6IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5vcGVuKSB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3BlbigpO1xuICAgIH1cbiAgfSxcbiAgb3BlbjogZnVuY3Rpb24gb3BlbihjYWxsYmFjaykge1xuICAgIHRoaXMuc2V0T3Blbih0cnVlLCBjYWxsYmFjayk7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiBjbG9zZShjYWxsYmFjaykge1xuICAgIHRoaXMuc2V0T3BlbihmYWxzZSwgY2FsbGJhY2spO1xuICB9XG59KTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBQaWNrZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vfi91eGNvcmUtY2FsZW5kYXIvYnVpbGQvUGlja2VyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX1llYXJQYW5lbCA9IHJlcXVpcmUoJ3JjLWNhbGVuZGFyL2xpYi95ZWFyL1llYXJQYW5lbCcpO1xuXG52YXIgX1llYXJQYW5lbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ZZWFyUGFuZWwpO1xuXG52YXIgX0NhbGVuZGFyTWl4aW4gPSByZXF1aXJlKCdyYy1jYWxlbmRhci9saWIvbWl4aW4vQ2FsZW5kYXJNaXhpbicpO1xuXG52YXIgX0NhbGVuZGFyTWl4aW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2FsZW5kYXJNaXhpbik7XG5cbnZhciBfcmNVdGlsID0gcmVxdWlyZSgncmMtdXRpbCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgWWVhckNhbGVuZGFyID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgIGRpc3BsYXlOYW1lOiAnWWVhckNhbGVuZGFyJyxcblxuICAgIG1peGluczogW19DYWxlbmRhck1peGluMltcImRlZmF1bHRcIl1dLFxuXG4gICAgb25LZXlEb3duOiBmdW5jdGlvbiBvbktleURvd24oZSkge1xuICAgICAgICB2YXIga2V5Q29kZSA9IGUua2V5Q29kZTtcbiAgICAgICAgdmFyIGN0cmxLZXkgPSBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5O1xuICAgICAgICB2YXIgc3RhdGVWYWx1ZSA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgICAgIHZhciB2YWx1ZSA9IHN0YXRlVmFsdWU7XG4gICAgICAgIHN3aXRjaCAoa2V5Q29kZSkge1xuICAgICAgICAgICAgY2FzZSBfcmNVdGlsLktleUNvZGUuRE9XTjpcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHN0YXRlVmFsdWUuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICB2YWx1ZS5hZGRNb250aCgzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgX3JjVXRpbC5LZXlDb2RlLlVQOlxuICAgICAgICAgICAgICAgIHZhbHVlID0gc3RhdGVWYWx1ZS5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIHZhbHVlLmFkZE1vbnRoKC0zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgX3JjVXRpbC5LZXlDb2RlLkxFRlQ6XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBzdGF0ZVZhbHVlLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgaWYgKGN0cmxLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuYWRkWWVhcigtMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuYWRkTW9udGgoLTEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgX3JjVXRpbC5LZXlDb2RlLlJJR0hUOlxuICAgICAgICAgICAgICAgIHZhbHVlID0gc3RhdGVWYWx1ZS5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIGlmIChjdHJsS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmFkZFllYXIoMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuYWRkTW9udGgoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBfcmNVdGlsLktleUNvZGUuRU5URVI6XG4gICAgICAgICAgICAgICAgdGhpcy5vblNlbGVjdChzdGF0ZVZhbHVlKTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICE9PSBzdGF0ZVZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gUmVhY3QuY3JlYXRlRWxlbWVudChfWWVhclBhbmVsMltcImRlZmF1bHRcIl0sIHsgbG9jYWxlOiBwcm9wcy5sb2NhbGUsXG4gICAgICAgICAgICBkaXNhYmxlZERhdGU6IHByb3BzLmRpc2FibGVkRGF0ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnN0YXRlLnZhbHVlLFxuICAgICAgICAgICAgcm9vdFByZWZpeENsczogcHJvcHMucHJlZml4Q2xzLFxuICAgICAgICAgICAgb25DaGFuZ2U6IHRoaXMuc2V0VmFsdWUsXG4gICAgICAgICAgICBvblNlbGVjdDogdGhpcy5vblNlbGVjdCB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyUm9vdCh7XG4gICAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gWWVhckNhbGVuZGFyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL2J1aWxkL1llYXJDYWxlbmRhci5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9ncmVnb3JpYW5DYWxlbmRhckZvcm1hdExpYkxvY2FsZVpoQ24gPSByZXF1aXJlKCdncmVnb3JpYW4tY2FsZW5kYXItZm9ybWF0L2xpYi9sb2NhbGUvemgtY24nKTtcblxudmFyIF9ncmVnb3JpYW5DYWxlbmRhckZvcm1hdExpYkxvY2FsZVpoQ24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ3JlZ29yaWFuQ2FsZW5kYXJGb3JtYXRMaWJMb2NhbGVaaENuKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0ge1xuICB0b2RheTogJ+S7iuWkqScsXG4gIG5vdzogJ+atpOWIuycsXG4gIG9rOiAn56Gu5a6aJyxcbiAgY2xlYXI6ICfmuIXpmaQnLFxuICBwcmV2aW91c01vbnRoOiAn5LiK5Liq5pyIICjnv7vpobXkuIrplK4pJyxcbiAgbmV4dE1vbnRoOiAn5LiL5Liq5pyIICjnv7vpobXkuIvplK4pJyxcbiAgbW9udGhTZWxlY3Q6ICfpgInmi6nmnIjku70nLFxuICB5ZWFyU2VsZWN0OiAn6YCJ5oup5bm05Lu9JyxcbiAgZGVjYWRlU2VsZWN0OiAn6YCJ5oup5bm05LujJyxcbiAgaG91cklucHV0OiAn5LiK5LiA5bCP5pe2KOS4iuaWueWQkemUriksIOS4i+S4gOWwj+aXtijkuIvmlrnlkJHplK4pJyxcbiAgbWludXRlSW5wdXQ6ICfkuIrkuIDliIbpkp8o5LiK5pa55ZCR6ZSuKSwg5LiL5LiA5YiG6ZKfKOS4i+aWueWQkemUriknLFxuICBzZWNvbmRJbnB1dDogJ+S4iuS4gOenkijkuIrmlrnlkJHplK4pLCDkuIvkuIDlsI/ml7Yo5LiL5pa55ZCR6ZSuKScsXG4gIGhvdXJQYW5lbFRpdGxlOiAn6YCJ5oup5bCP5pe2JyxcbiAgbWludXRlUGFuZWxUaXRsZTogJ+mAieaLqeWIhumSnycsXG4gIHNlY29uZFBhbmVsVGl0bGU6ICfpgInmi6nnp5InLFxuICB5ZWFyRm9ybWF0OiAneXl5eVxcJ+W5tFxcJycsXG4gIG1vbnRoRm9ybWF0OiAnTVxcJ+aciFxcJycsXG4gIGRhdGVGb3JtYXQ6ICd5eXl5XFwn5bm0XFwnTVxcJ+aciFxcJ2RcXCfml6VcXCcnLFxuICBwcmV2aW91c1llYXI6ICfkuIrkuIDlubQgKENvbnRyb2zplK7liqDlt6bmlrnlkJHplK4pJyxcbiAgbmV4dFllYXI6ICfkuIvkuIDlubQgKENvbnRyb2zplK7liqDlj7PmlrnlkJHplK4pJyxcbiAgcHJldmlvdXNEZWNhZGU6ICfkuIrkuIDlubTku6MnLFxuICBuZXh0RGVjYWRlOiAn5LiL5LiA5bm05LujJyxcbiAgcHJldmlvdXNDZW50dXJ5OiAn5LiK5LiA5LiW57qqJyxcbiAgbmV4dENlbnR1cnk6ICfkuIvkuIDkuJbnuqonLFxuICBmb3JtYXQ6IF9ncmVnb3JpYW5DYWxlbmRhckZvcm1hdExpYkxvY2FsZVpoQ24yWydkZWZhdWx0J11cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vfi91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9saWIvbG9jYWxlL3poLWNuLmpzXG4gKiovIiwiLyoqXG4gKiB6aC1jbiBsb2NhbGVcbiAqIEBpZ25vcmVcbiAqIEBhdXRob3IgeWltaW5naGVAZ21haWwuY29tXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICBlcmFzOiBbJ+WFrOWFg+WJjScsICflhazlhYMnXSxcbiAgbW9udGhzOiBbJ+S4gOaciCcsICfkuozmnIgnLCAn5LiJ5pyIJywgJ+Wbm+aciCcsICfkupTmnIgnLCAn5YWt5pyIJyxcbiAgICAn5LiD5pyIJywgJ+WFq+aciCcsICfkuZ3mnIgnLCAn5Y2B5pyIJywgJ+WNgeS4gOaciCcsICfljYHkuozmnIgnXSxcbiAgc2hvcnRNb250aHM6IFsn5LiA5pyIJywgJ+S6jOaciCcsICfkuInmnIgnLCAn5Zub5pyIJywgJ+S6lOaciCcsICflha3mnIgnLFxuICAgICfkuIPmnIgnLCAn5YWr5pyIJywgJ+S5neaciCcsICfljYHmnIgnLCAn5Y2B5LiA5pyIJywgJ+WNgeS6jOaciCddLFxuICB3ZWVrZGF5czogWyfmmJ/mnJ/lpKknLCAn5pif5pyf5LiAJywgJ+aYn+acn+S6jCcsICfmmJ/mnJ/kuIknLCAn5pif5pyf5ZubJyxcbiAgICAn5pif5pyf5LqUJywgJ+aYn+acn+WFrSddLFxuICBzaG9ydFdlZWtkYXlzOiBbJ+WRqOaXpScsICflkajkuIAnLCAn5ZGo5LqMJywgJ+WRqOS4iScsICflkajlm5snLCAn5ZGo5LqUJyxcbiAgICAn5ZGo5YWtJ10sXG4gIHZlcnlTaG9ydFdlZWtkYXlzOiBbJ+aXpScsICfkuIAnLCAn5LqMJywgJ+S4iScsICflm5snLCAn5LqUJywgJ+WFrSddLFxuICBhbXBtczogWyfkuIrljYgnLCAn5LiL5Y2IJ10sXG4gIC8qanNoaW50IHF1b3RtYXJrOiBmYWxzZSovXG4gIGRhdGVQYXR0ZXJuczogW1wieXl5eSflubQnTSfmnIgnZCfml6UnIEVFRUVcIiwgXCJ5eXl5J+W5tCdNJ+aciCdkJ+aXpSdcIiwgXCJ5eXl5LU0tZFwiLCBcInl5LU0tZFwiXSxcbiAgdGltZVBhdHRlcm5zOiBbXCJhaGgn5pe2J21tJ+WIhidzcyfnp5InICdHTVQnWlwiLCBcImFoaCfml7YnbW0n5YiGJ3NzJ+enkidcIiwgXCJIOm1tOnNzXCIsIFwiYWg6bW1cIl0sXG4gIGRhdGVUaW1lUGF0dGVybjogJ3tkYXRlfSB7dGltZX0nXG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL34vZ3JlZ29yaWFuLWNhbGVuZGFyLWZvcm1hdC9saWIvbG9jYWxlL3poLWNuLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEZvcm1GaWVsZCA9IHJlcXVpcmUoJy4vRm9ybUZpZWxkJyk7XG52YXIgQ29uc3RhbnRzID0gcmVxdWlyZShcInV4Y29yZS1jb25zdFwiKTtcbnZhciBDaGVja2JveEdyb3VwID0gcmVxdWlyZShcInV4Y29yZS1jaGVja2JveC1ncm91cFwiKTtcbnZhciBJdGVtID0gQ2hlY2tib3hHcm91cC5JdGVtO1xuXG52YXIgQ2hlY2tib3hHcm91cEZvcm1GaWVsZCA9IGZ1bmN0aW9uIChfRm9ybUZpZWxkKSB7XG4gICAgX2luaGVyaXRzKENoZWNrYm94R3JvdXBGb3JtRmllbGQsIF9Gb3JtRmllbGQpO1xuXG4gICAgZnVuY3Rpb24gQ2hlY2tib3hHcm91cEZvcm1GaWVsZChwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2hlY2tib3hHcm91cEZvcm1GaWVsZCk7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Gb3JtRmllbGQuY2FsbCh0aGlzLCBwcm9wcykpO1xuICAgIH1cblxuICAgIENoZWNrYm94R3JvdXBGb3JtRmllbGQucHJvdG90eXBlLmhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZSh2YWx1ZSkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBtZS5oYW5kbGVEYXRhQ2hhbmdlKHZhbHVlKTtcbiAgICB9O1xuXG4gICAgQ2hlY2tib3hHcm91cEZvcm1GaWVsZC5wcm90b3R5cGUuYWRkU3BlY2lmaWNDbGFzcyA9IGZ1bmN0aW9uIGFkZFNwZWNpZmljQ2xhc3MoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIGlmIChtZS5wcm9wcy5qc3hwcmVmaXhDbHMgPT0gXCJrdW1hLXV4Zm9ybS1maWVsZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbWUucHJvcHMuanN4cHJlZml4Q2xzICsgXCIga3VtYS1jaGVja2JveC1ncm91cC11eGZvcm0tZmllbGRcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtZS5wcm9wcy5qc3hwcmVmaXhDbHM7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hlY2tib3hHcm91cEZvcm1GaWVsZC5wcm90b3R5cGUucmVuZGVyRmllbGQgPSBmdW5jdGlvbiByZW5kZXJGaWVsZCgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIG1vZGUgPSBtZS5wcm9wcy5qc3htb2RlIHx8IG1lLnByb3BzLm1vZGU7XG4gICAgICAgIGlmIChtb2RlID09IENvbnN0YW50cy5NT0RFLkVESVQpIHtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgIENoZWNrYm94R3JvdXAsXG4gICAgICAgICAgICAgICAgeyBkaXNhYmxlZDogISFtZS5wcm9wcy5qc3hkaXNhYmxlZCwgb25DaGFuZ2U6IG1lLmhhbmRsZUNoYW5nZS5iaW5kKG1lKSwgdmFsdWU6IG1lLnN0YXRlLnZhbHVlIHx8IFtdIH0sXG4gICAgICAgICAgICAgICAgbWUucHJvcHMuY2hpbGRyZW5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobWUuc3RhdGUudmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0QXJyID0gbWUucHJvcHMuY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjaGlsZCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lLnN0YXRlLnZhbHVlLmluZGV4T2YoY2hpbGQucHJvcHMudmFsdWUpICE9IC0xO1xuICAgICAgICAgICAgICAgIH0pLm1hcChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0ucHJvcHMudGV4dDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgXCJzcGFuXCIsXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHRleHRBcnIuam9pbihcIiBcIilcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBDaGVja2JveEdyb3VwRm9ybUZpZWxkO1xufShGb3JtRmllbGQpO1xuXG5DaGVja2JveEdyb3VwRm9ybUZpZWxkLkl0ZW0gPSBJdGVtO1xuQ2hlY2tib3hHcm91cEZvcm1GaWVsZC5wcm9wVHlwZXMgPSBGb3JtRmllbGQucHJvcFR5cGVzO1xuQ2hlY2tib3hHcm91cEZvcm1GaWVsZC5kZWZhdWx0UHJvcHMgPSBGb3JtRmllbGQuZGVmYXVsdFByb3BzO1xuQ2hlY2tib3hHcm91cEZvcm1GaWVsZC5kaXNwbGF5TmFtZSA9IFwiQ2hlY2tib3hHcm91cEZvcm1GaWVsZFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoZWNrYm94R3JvdXBGb3JtRmllbGQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL2J1aWxkL0Zvcm1GaWVsZC9DaGVja2JveEdyb3VwRm9ybUZpZWxkLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgRm9ybUZpZWxkID0gcmVxdWlyZSgnLi9Gb3JtRmllbGQnKTtcbnZhciBDb25zdGFudHMgPSByZXF1aXJlKFwidXhjb3JlLWNvbnN0XCIpO1xudmFyIFNlbGVjdCA9IHJlcXVpcmUoJ3V4Y29yZS1zZWxlY3QyJyk7XG52YXIgT3B0aW9uID0gU2VsZWN0Lk9wdGlvbjtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcbnZhciB1cGRhdGUgPSBSZWFjdC5hZGRvbnMudXBkYXRlO1xuXG52YXIgQ2FzY2FkZVNlbGVjdEZvcm1GaWVsZCA9IGZ1bmN0aW9uIChfRm9ybUZpZWxkKSB7XG4gICAgX2luaGVyaXRzKENhc2NhZGVTZWxlY3RGb3JtRmllbGQsIF9Gb3JtRmllbGQpO1xuXG4gICAgZnVuY3Rpb24gQ2FzY2FkZVNlbGVjdEZvcm1GaWVsZChwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FzY2FkZVNlbGVjdEZvcm1GaWVsZCk7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Gb3JtRmllbGQuY2FsbCh0aGlzLCBwcm9wcykpO1xuICAgIH1cblxuICAgIENhc2NhZGVTZWxlY3RGb3JtRmllbGQucHJvdG90eXBlLmdldERhdGFMZW5ndGggPSBmdW5jdGlvbiBnZXREYXRhTGVuZ3RoKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbWUucHJvcHMuanN4ZGF0YS5sZW5ndGg7XG4gICAgfTtcblxuICAgIENhc2NhZGVTZWxlY3RGb3JtRmllbGQucHJvdG90eXBlLmhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZShpLCB2YWx1ZSkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgdmFsdWVzID0gdXBkYXRlKG1lLnN0YXRlLnZhbHVlLCB7fSkgfHwgW107XG4gICAgICAgIGlmICghIXZhbHVlc1tpXSkge1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWVzW2ldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgbWUuaGFuZGxlRGF0YUNoYW5nZSh2YWx1ZXMpO1xuICAgIH07XG5cbiAgICBDYXNjYWRlU2VsZWN0Rm9ybUZpZWxkLnByb3RvdHlwZS5hZGRTcGVjaWZpY0NsYXNzID0gZnVuY3Rpb24gYWRkU3BlY2lmaWNDbGFzcygpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgaWYgKG1lLnByb3BzLmpzeHByZWZpeENscyA9PSBcImt1bWEtdXhmb3JtLWZpZWxkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBtZS5wcm9wcy5qc3hwcmVmaXhDbHMgKyBcIiBrdW1hLWNhc2NhZGUtc2VsZWN0LXV4Zm9ybS1maWVsZFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1lLnByb3BzLmpzeHByZWZpeENscztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBDYXNjYWRlU2VsZWN0Rm9ybUZpZWxkLnByb3RvdHlwZS5yZW5kZXJGaWVsZCA9IGZ1bmN0aW9uIHJlbmRlckZpZWxkKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgbGVuZ3RoID0gbWUuZ2V0RGF0YUxlbmd0aCgpO1xuICAgICAgICB2YXIgYXJyID0gW107XG4gICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgIHZhciBtb2RlID0gbWUucHJvcHMuanN4bW9kZSB8fCBtZS5wcm9wcy5tb2RlO1xuICAgICAgICBpZiAobW9kZSA9PSBDb25zdGFudHMuTU9ERS5FRElUKSB7XG4gICAgICAgICAgICB2YXIgX3JldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gbWUucHJvcHMuanN4ZGF0YS5jb250ZW50cztcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdjogdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiDlpoLmnpwgdmFsdWUg5a2Y5Zyo55u45bqU55qE5YC877yM5YiZ5aGr5YWF5LiL5LiA57qn55qE6YCJ5oup77yMXG4gICAgICAgICAgICAgICAgICog5aaC5p6cIHZhbHVlIOS4jeWtmOWcqO+8jOWImeWhq+WFheepuuaVsOe7hO+8jFxuICAgICAgICAgICAgICAgICAqIOWmguaenCBkYXRhIOS4reS4jeWMheWQqyBjb250ZW50c++8jOWImeivgeaYjue6p+iBlOmAieaLqeeUn+aIkOW3sue7k+adn++8jOWImei3s+WHuuW+queOr1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ZVZhbHVlID0gbWUuc3RhdGUudmFsdWUgfHwgW107IC8vIOmihOmYsiB2YWx1ZSDmmK8gdW5kZWZpbmVkIOeahOaDheWGtVxuXG4gICAgICAgICAgICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGRhdGEubWFwKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT3B0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsga2V5OiBpbmRleCwgdmFsdWU6IGl0ZW0udmFsdWUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmOiBcImVsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IFwic2VsZWN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25MYWJlbFByb3A6IFwiY2hpbGRyZW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBtZS5wcm9wcy5qc3hzdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dTZWFyY2g6IG1lLnByb3BzLmpzeHNob3dTZWFyY2gsXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogbWUucHJvcHMuanN4cGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0T3B0aW9ucy5vbkNoYW5nZSA9IG1lLmhhbmRsZUNoYW5nZS5iaW5kKG1lLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0T3B0aW9ucy52YWx1ZSA9IHN0YXRlVmFsdWVbaV0gfHwgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2goUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBrZXk6IFwic3BsaXRcIiArIGksIGNsYXNzTmFtZTogJ2t1bWEtdXhmb3JtLXNwbGl0JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICctJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2goUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgIFNlbGVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9leHRlbmRzKHt9LCBzZWxlY3RPcHRpb25zLCB7IGtleTogaSB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghIXN0YXRlVmFsdWVbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLnZhbHVlID09IHN0YXRlVmFsdWVbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLmNvbnRlbnRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhKSByZXR1cm4gJ2JyZWFrJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfcmV0MiA9IF9sb29wKGkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChfcmV0MiA9PT0gJ2JyZWFrJykgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgICBpZiAoKHR5cGVvZiBfcmV0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihfcmV0KSkgPT09IFwib2JqZWN0XCIpIHJldHVybiBfcmV0LnY7XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PSBDb25zdGFudHMuTU9ERS5WSUVXKSB7XG4gICAgICAgICAgICBpZiAobWUuc3RhdGUudmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gbWUucHJvcHMuanN4ZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRBcnIgPSBtZS5zdGF0ZS52YWx1ZS5tYXAoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5jb250ZW50cy5maWx0ZXIoZnVuY3Rpb24gKGVsZSwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGUudmFsdWUgPT0gaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEudGV4dDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGFyci5wdXNoKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGtleTogJ2Nhc2NhZGUnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0QXJyLmpvaW4oXCIgXCIpXG4gICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ2FzY2FkZVNlbGVjdEZvcm1GaWVsZDtcbn0oRm9ybUZpZWxkKTtcblxuQ2FzY2FkZVNlbGVjdEZvcm1GaWVsZC5wcm9wVHlwZXMgPSBhc3NpZ24oe30sIEZvcm1GaWVsZC5wcm9wVHlwZXMsIHtcbiAgICBqc3hzdHlsZTogUmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBqc3hzaG93U2VhcmNoOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBqc3hwbGFjZWhvbGRlcjogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBqc3hkYXRhOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0XG59KTtcbkNhc2NhZGVTZWxlY3RGb3JtRmllbGQuZGVmYXVsdFByb3BzID0gYXNzaWduKHt9LCBGb3JtRmllbGQuZGVmYXVsdFByb3BzLCB7XG4gICAganN4c2hvd1NlYXJjaDogZmFsc2UsXG4gICAganN4cGxhY2Vob2xkZXI6IFwi6K+35LiL5ouJ6YCJ5oupXCJcbn0pO1xuQ2FzY2FkZVNlbGVjdEZvcm1GaWVsZC5kaXNwbGF5TmFtZSA9IFwiQ2FzY2FkZVNlbGVjdEZvcm1GaWVsZFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhc2NhZGVTZWxlY3RGb3JtRmllbGQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL2J1aWxkL0Zvcm1GaWVsZC9DYXNjYWRlU2VsZWN0Rm9ybUZpZWxkLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcbnZhciBjbGFzc25hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIE90aGVyRm9ybUZpZWxkID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoT3RoZXJGb3JtRmllbGQsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gT3RoZXJGb3JtRmllbGQocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE90aGVyRm9ybUZpZWxkKTtcblxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSk7XG4gICAgfVxuXG4gICAgT3RoZXJGb3JtRmllbGQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIF9jbGFzc25hbWVzO1xuXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogY2xhc3NuYW1lcygoX2NsYXNzbmFtZXMgPSB7fSwgX2NsYXNzbmFtZXNbbWUucHJvcHMuanN4cHJlZml4Q2xzXSA9IHRydWUsIF9jbGFzc25hbWVzW21lLnByb3BzLmNsYXNzTmFtZV0gPSAhIW1lLnByb3BzLmNsYXNzTmFtZSwgX2NsYXNzbmFtZXMpKSwgc3R5bGU6IGFzc2lnbih7fSwgbWUucHJvcHMuc3R5bGUsIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogbWUucHJvcHMuanN4c2hvdyA/IFwidGFibGVcIiA6IFwibm9uZVwiXG4gICAgICAgICAgICAgICAgfSkgfSxcbiAgICAgICAgICAgIG1lLnByb3BzLmNoaWxkcmVuXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHJldHVybiBPdGhlckZvcm1GaWVsZDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuT3RoZXJGb3JtRmllbGQuZGVmYXVsdFByb3BzID0ge1xuICAgIGpzeHByZWZpeENsczogXCJrdW1hLXV4Zm9ybS1maWVsZCBrdW1hLW90aGVyLXV4Zm9ybS1maWVsZFwiLCAvLyDpu5jorqTnsbvlkI1cbiAgICBqc3hmbGV4OiAxLCAvLyDljaAgRm9ybSDnmoTmr5TkvovvvIznsbvkvLzkuo4gY3NzMyDkuK3nmoQgZmxleC1ib3hcbiAgICBqc3hzaG93OiB0cnVlXG59O1xuXG5PdGhlckZvcm1GaWVsZC5wcm9wVHlwZXMgPSB7XG4gICAganN4cHJlZml4Q2xzOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGpzeGZsZXg6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAganN4c2hvdzogUmVhY3QuUHJvcFR5cGVzLmJvb2xcbn07XG5cbk90aGVyRm9ybUZpZWxkLmRpc3BsYXlOYW1lID0gXCJPdGhlckZvcm1GaWVsZFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE90aGVyRm9ybUZpZWxkO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9idWlsZC9Gb3JtRmllbGQvT3RoZXJGb3JtRmllbGQuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xudmFyIGNsYXNzbmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZShcIm9iamVjdC1hc3NpZ25cIik7XG5cbnZhciBCdXR0b25Hcm91cEZvcm1GaWVsZCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzKEJ1dHRvbkdyb3VwRm9ybUZpZWxkLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIEJ1dHRvbkdyb3VwRm9ybUZpZWxkKHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdXR0b25Hcm91cEZvcm1GaWVsZCk7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuICAgIH1cblxuICAgIEJ1dHRvbkdyb3VwRm9ybUZpZWxkLnByb3RvdHlwZS5fcHJvY2Vzc0NoaWxkID0gZnVuY3Rpb24gX3Byb2Nlc3NDaGlsZCgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIGxlbmd0aCA9IFJlYWN0LkNoaWxkcmVuLmNvdW50KG1lLnByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWxlbWVudHMgPSBSZWFjdC5DaGlsZHJlbi5tYXAobWUucHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IHt9O1xuICAgICAgICAgICAgaWYgKGNoaWxkLnByb3BzLmFjdGlvbiA9PSBcInN1Ym1pdFwiKSB7XG4gICAgICAgICAgICAgICAgcHJvcHMub25DbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBtZS5wcm9wcy5nZXRWYWx1ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQucHJvcHMub25DbGljayhkYXRhKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoaWxkLnByb3BzLmFjdGlvbiA9PSBcInJlc2V0XCIpIHtcbiAgICAgICAgICAgICAgICBwcm9wcy5vbkNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInJlc2V0XCIpO1xuICAgICAgICAgICAgICAgICAgICBtZS5wcm9wcy5yZXNldFZhbHVlcygpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCBwcm9wcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9O1xuXG4gICAgQnV0dG9uR3JvdXBGb3JtRmllbGQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIF9jbGFzc25hbWVzO1xuXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IG1lLl9wcm9jZXNzQ2hpbGQoKTtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBjbGFzc25hbWVzKChfY2xhc3NuYW1lcyA9IHt9LCBfY2xhc3NuYW1lc1ttZS5wcm9wcy5qc3hwcmVmaXhDbHNdID0gdHJ1ZSwgX2NsYXNzbmFtZXNbbWUucHJvcHMuY2xhc3NOYW1lXSA9ICEhbWUucHJvcHMuY2xhc3NOYW1lLCBfY2xhc3NuYW1lcykpLCBzdHlsZTogYXNzaWduKHt9LCBtZS5wcm9wcy5zdHlsZSwge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBtZS5wcm9wcy5qc3hzaG93ID8gXCJ0YWJsZVwiIDogXCJub25lXCJcbiAgICAgICAgICAgICAgICB9KSB9LFxuICAgICAgICAgICAgISFlbGVtZW50cyAmJiBlbGVtZW50c1xuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gQnV0dG9uR3JvdXBGb3JtRmllbGQ7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbkJ1dHRvbkdyb3VwRm9ybUZpZWxkLnByb3BUeXBlcyA9IHtcbiAgICBqc3hwcmVmaXhDbHM6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAganN4ZmxleDogUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICBqc3hzaG93OiBSZWFjdC5Qcm9wVHlwZXMuYm9vbFxufTtcbkJ1dHRvbkdyb3VwRm9ybUZpZWxkLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBqc3hwcmVmaXhDbHM6IFwia3VtYS11eGZvcm0tZmllbGQga3VtYS1idXR0b24tZ3JvdXAtdXhmb3JtLWZpZWxkXCIsIC8vIOm7mOiupOexu+WQjVxuICAgIGpzeGZsZXg6IDEsIC8vIOWNoCBGb3JtIOeahOavlOS+i++8jOexu+S8vOS6jiBjc3MzIOS4reeahCBmbGV4LWJveFxuICAgIGpzeHNob3c6IHRydWVcbn07XG5CdXR0b25Hcm91cEZvcm1GaWVsZC5kaXNwbGF5TmFtZSA9IFwiQnV0dG9uR3JvdXBGb3JtRmllbGRcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBCdXR0b25Hcm91cEZvcm1GaWVsZDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vYnVpbGQvRm9ybUZpZWxkL0J1dHRvbkdyb3VwRm9ybUZpZWxkLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEZvcm1GaWVsZCA9IHJlcXVpcmUoJy4vRm9ybUZpZWxkJyk7XG52YXIgQ29uc3RhbnRzID0gcmVxdWlyZShcInV4Y29yZS1jb25zdFwiKTtcbnZhciBUaW55bWNlID0gcmVxdWlyZShcInV4Y29yZS10aW55bWNlXCIpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIEVkaXRvckZvcm1GaWVsZCA9IGZ1bmN0aW9uIChfRm9ybUZpZWxkKSB7XG4gICAgX2luaGVyaXRzKEVkaXRvckZvcm1GaWVsZCwgX0Zvcm1GaWVsZCk7XG5cbiAgICBmdW5jdGlvbiBFZGl0b3JGb3JtRmllbGQocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVkaXRvckZvcm1GaWVsZCk7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Gb3JtRmllbGQuY2FsbCh0aGlzLCBwcm9wcykpO1xuICAgIH1cblxuICAgIEVkaXRvckZvcm1GaWVsZC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIGlmICghbWUuX2lzRXF1YWwobmV4dFByb3BzLnZhbHVlLCBtZS5wcm9wcy52YWx1ZSkpIHtcbiAgICAgICAgICAgIG1lLmhhbmRsZURhdGFDaGFuZ2UobmV4dFByb3BzLnZhbHVlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBFZGl0b3JGb3JtRmllbGQucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIHByZXZNb2RlID0gcHJldlByb3BzLmpzeG1vZGUgfHwgcHJldlByb3BzLm1vZGU7XG4gICAgICAgIHZhciBtb2RlID0gbWUucHJvcHMuanN4bW9kZSB8fCBtZS5wcm9wcy5tb2RlO1xuICAgICAgICBpZiAocHJldk1vZGUgPT0gQ29uc3RhbnRzLk1PREUuVklFVyAmJiBtb2RlID09IENvbnN0YW50cy5NT0RFLkVESVQpIHtcbiAgICAgICAgICAgIG1lLnJlZnMudGlueW1jZS5yZXNldFZhbHVlKG1lLnN0YXRlLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBFZGl0b3JGb3JtRmllbGQucHJvdG90eXBlLl9pc0VxdWFsID0gZnVuY3Rpb24gX2lzRXF1YWwoYSwgYikge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYSkgPT0gSlNPTi5zdHJpbmdpZnkoYik7XG4gICAgfTtcblxuICAgIEVkaXRvckZvcm1GaWVsZC5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKGUsIGVkaXRvcikge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBtZS5oYW5kbGVEYXRhQ2hhbmdlKGVkaXRvci5nZXRDb250ZW50KCkpO1xuICAgIH07XG5cbiAgICBFZGl0b3JGb3JtRmllbGQucHJvdG90eXBlLmhhbmRsZUtleXVwID0gZnVuY3Rpb24gaGFuZGxlS2V5dXAoZSwgZWRpdG9yKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIG1lLmhhbmRsZURhdGFDaGFuZ2UoZWRpdG9yLmdldENvbnRlbnQoKSk7XG4gICAgfTtcblxuICAgIEVkaXRvckZvcm1GaWVsZC5wcm90b3R5cGUuYWRkU3BlY2lmaWNDbGFzcyA9IGZ1bmN0aW9uIGFkZFNwZWNpZmljQ2xhc3MoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIGlmIChtZS5wcm9wcy5qc3hwcmVmaXhDbHMgPT0gXCJrdW1hLXV4Zm9ybS1maWVsZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbWUucHJvcHMuanN4cHJlZml4Q2xzICsgXCIga3VtYS1lZGl0b3ItdXhmb3JtLWZpZWxkXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbWUucHJvcHMuanN4cHJlZml4Q2xzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEVkaXRvckZvcm1GaWVsZC5wcm90b3R5cGUucmVuZGVyRmllbGQgPSBmdW5jdGlvbiByZW5kZXJGaWVsZCgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIG1vZGUgPSBtZS5wcm9wcy5qc3htb2RlIHx8IG1lLnByb3BzLm1vZGU7XG4gICAgICAgIGlmIChtZS5zdGF0ZS5mcm9tUmVzZXQgJiYgbW9kZSA9PSBDb25zdGFudHMuTU9ERS5FRElUKSB7XG4gICAgICAgICAgICBtZS5yZWZzLnRpbnltY2UucmVzZXRWYWx1ZShtZS5wcm9wcy5qc3hjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9kZSA9PSBDb25zdGFudHMuTU9ERS5FRElUKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChUaW55bWNlLCB7IHJlZjogXCJ0aW55bWNlXCIsXG4gICAgICAgICAgICAgICAgY29uZmlnOiBtZS5wcm9wcy5qc3hjb25maWcsXG4gICAgICAgICAgICAgICAgY29udGVudDogbWUuc3RhdGUudmFsdWUsXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IG1lLmhhbmRsZUNoYW5nZS5iaW5kKG1lKSxcbiAgICAgICAgICAgICAgICBvbktleXVwOiBtZS5oYW5kbGVLZXl1cC5iaW5kKG1lKSB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGtleTogXCJ0ZXh0XCIsIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7IF9faHRtbDogbWUuc3RhdGUudmFsdWUgfSB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gRWRpdG9yRm9ybUZpZWxkO1xufShGb3JtRmllbGQpO1xuXG5FZGl0b3JGb3JtRmllbGQucHJvcFR5cGVzID0gYXNzaWduKHt9LCBGb3JtRmllbGQucHJvcFR5cGVzKTtcbkVkaXRvckZvcm1GaWVsZC5kZWZhdWx0UHJvcHMgPSBhc3NpZ24oe30sIEZvcm1GaWVsZC5kZWZhdWx0UHJvcHMsIHtcbiAgICBqc3hjb25maWc6IHt9LFxuICAgIGpzeGNvbnRlbnQ6IFwiXCJcbn0pO1xuRWRpdG9yRm9ybUZpZWxkLmRpc3BsYXlOYW1lID0gXCJFZGl0b3JGb3JtRmllbGRcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBFZGl0b3JGb3JtRmllbGQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL2J1aWxkL0Zvcm1GaWVsZC9FZGl0b3JGb3JtRmllbGQuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVGlueW1jZSBDb21wb25lbnQgZm9yIHV4Y29yZVxuICogQGF1dGhvciBldGVybmFsc2t5XG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgVXhjb3JlIFRlYW0sIEFsaW53LlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vVGlueW1jZScpO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtdGlueW1jZS9idWlsZC9pbmRleC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBUaW55bWNlIENvbXBvbmVudCBmb3IgdXhjb3JlXG4gKiBJbnNwaXJlZCBieSByZWFjdC10aW55bWNlOiBodHRwczovL2dpdGh1Yi5jb20vbXphYnJpc2tpZS9yZWFjdC10aW55bWNlXG4gKiBAYXV0aG9yIGV0ZXJuYWxza3lcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBVeGNvcmUgVGVhbSwgQWxpbncuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgRWRpdG9yQ29uZmlnID0gcmVxdWlyZSgnLi9lZGl0b3JDb25maWcnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG4vLyBJbmNsdWRlIGFsbCBvZiB0aGUgTmF0aXZlIERPTSBhbmQgY3VzdG9tIGV2ZW50cyBmcm9tOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RpbnltY2UvdGlueW1jZS9ibG9iL21hc3Rlci90b29scy9kb2NzL3RpbnltY2UuRWRpdG9yLmpzI0w1LUwxMlxudmFyIEVWRU5UUyA9IFsnZm9jdXNpbicsICdmb2N1c291dCcsICdjbGljaycsICdkYmxjbGljaycsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdtb3VzZW1vdmUnLCAnbW91c2VvdmVyJywgJ2JlZm9yZXBhc3RlJywgJ3Bhc3RlJywgJ2N1dCcsICdjb3B5JywgJ3NlbGVjdGlvbmNoYW5nZScsICdtb3VzZW91dCcsICdtb3VzZWVudGVyJywgJ21vdXNlbGVhdmUnLCAna2V5ZG93bicsICdrZXlwcmVzcycsICdrZXl1cCcsICdjb250ZXh0bWVudScsICdkcmFnZW5kJywgJ2RyYWdvdmVyJywgJ2RyYWdnZXN0dXJlJywgJ2RyYWdkcm9wJywgJ2Ryb3AnLCAnZHJhZycsICdCZWZvcmVSZW5kZXJVSScsICdTZXRBdHRyaWInLCAnUHJlSW5pdCcsICdQb3N0UmVuZGVyJywgJ2luaXQnLCAnZGVhY3RpdmF0ZScsICdhY3RpdmF0ZScsICdOb2RlQ2hhbmdlJywgJ0JlZm9yZUV4ZWNDb21tYW5kJywgJ0V4ZWNDb21tYW5kJywgJ3Nob3cnLCAnaGlkZScsICdQcm9ncmVzc1N0YXRlJywgJ0xvYWRDb250ZW50JywgJ1NhdmVDb250ZW50JywgJ0JlZm9yZVNldENvbnRlbnQnLCAnU2V0Q29udGVudCcsICdCZWZvcmVHZXRDb250ZW50JywgJ0dldENvbnRlbnQnLCAnVmlzdWFsQWlkJywgJ3JlbW92ZScsICdzdWJtaXQnLCAncmVzZXQnLCAnQmVmb3JlQWRkVW5kbycsICdBZGRVbmRvJywgJ2NoYW5nZScsICd1bmRvJywgJ3JlZG8nLCAnQ2xlYXJVbmRvcycsICdPYmplY3RTZWxlY3RlZCcsICdPYmplY3RSZXNpemVTdGFydCcsICdPYmplY3RSZXNpemVkJywgJ1ByZVByb2Nlc3MnLCAnUG9zdFByb2Nlc3MnLCAnZm9jdXMnLCAnYmx1ciddO1xuXG4vLyBOb3RlOiBiZWNhdXNlIHRoZSBjYXBpdGFsaXphdGlvbiBvZiB0aGUgZXZlbnRzIGlzIHdlaXJkLCB3ZSdyZSBnb2luZyB0byBnZXRcbi8vIHNvbWUgaW5jb25zaXN0ZW50bHktbmFtZWQgaGFuZGxlcnMsIGZvciBleGFtcGxlIGNvbXBhcmU6XG4vLyAnb25Nb3VzZWxlYXZlJyBhbmQgJ29uTm9kZUNoYW5nZSdcbnZhciBIQU5ETEVSX05BTUVTID0gRVZFTlRTLm1hcChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ29uJyArIHV0aWwudWNfZmlyc3QoZXZlbnQpO1xufSk7XG5cbnZhciBUaW55bWNlID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoVGlueW1jZSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBUaW55bWNlKHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUaW55bWNlKTtcblxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSk7XG4gICAgfVxuXG4gICAgVGlueW1jZS5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgICBpZiAoKHR5cGVvZiB0aW55bWNlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih0aW55bWNlKSkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUaW55TUNFIGlzIG5vdCBmb3VuZCBpbiBnbG9iYWwsIGluaXQgZmFpbGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaWQgPSB0aGlzLmlkIHx8IHV0aWwudXVpZCgpO1xuICAgIH07XG5cbiAgICBUaW55bWNlLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLl9pbml0KHRoaXMucHJvcHMuY29uZmlnKTtcbiAgICB9O1xuXG4gICAgVGlueW1jZS5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlKCk7XG4gICAgfTtcblxuICAgIFRpbnltY2UucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICBpZiAoIXV0aWwuaXNFcXVhbChuZXh0UHJvcHMuY29uZmlnLCB0aGlzLnByb3BzLmNvbmZpZykpIHtcbiAgICAgICAgICAgIHRoaXMuX2luaXQobmV4dFByb3BzLmNvbmZpZywgbmV4dFByb3BzLmNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFRpbnltY2UucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMpIHtcbiAgICAgICAgcmV0dXJuICF1dGlsLmlzRXF1YWwodGhpcy5wcm9wcy5jb250ZW50LCBuZXh0UHJvcHMuY29udGVudCkgfHwgIXV0aWwuaXNFcXVhbCh0aGlzLnByb3BzLmNvbmZpZywgbmV4dFByb3BzLmNvbmZpZyk7XG4gICAgfTtcblxuICAgIFRpbnltY2UucHJvdG90eXBlLnJlc2V0VmFsdWUgPSBmdW5jdGlvbiByZXNldFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRpbnltY2UuZ2V0KHRoaXMuaWQpLnNldENvbnRlbnQodmFsdWUpO1xuICAgIH07XG5cbiAgICBUaW55bWNlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIF9pbml0KGNvbmZpZywgY29udGVudCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBpZiAobWUuX2lzSW5pdCkge1xuICAgICAgICAgICAgbWUuX3JlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhpZGUgdGhlIHRleHRhcmVhIHVudGlsIGluaXQgZmluaXNoZWRcbiAgICAgICAgUmVhY3RET00uZmluZERPTU5vZGUobWUpLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgY29uZmlnLnNlbGVjdG9yID0gJyMnICsgbWUuaWQ7XG4gICAgICAgIGNvbmZpZyA9IGFzc2lnbih7fSwgRWRpdG9yQ29uZmlnLCBjb25maWcpO1xuICAgICAgICBpZiAoIWNvbmZpZy5sYW5ndWFnZSkge1xuICAgICAgICAgICAgY29uZmlnLmxhbmd1YWdlID0gJ3poX0NOJztcbiAgICAgICAgfVxuICAgICAgICBjb25maWcuc2V0dXAgPSBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgICAgICBFVkVOVFMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBtZS5wcm9wc1tIQU5ETEVSX05BTUVTW2luZGV4XV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSByZXR1cm47XG4gICAgICAgICAgICAgICAgZWRpdG9yLm9uKGV2ZW50LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBuYXRpdmUgRE9NIGV2ZW50cyBkb24ndCBoYXZlIGFjY2VzcyB0byB0aGUgZWRpdG9yIHNvIHdlIHBhc3MgaXQgaGVyZVxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyKGUsIGVkaXRvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gc2V0IGNvbnRlbnQgaGVyZSBiZWNhdXNlIHRoZSB0ZXh0YXJlYSB3aWxsIHN0aWxsIGhhdmUgdGhlXG4gICAgICAgICAgICAvLyBvbGQgYHRoaXMucHJvcHMuY29udGVudGBcbiAgICAgICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgZWRpdG9yLm9uKCdpbml0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBlZGl0b3Iuc2V0Q29udGVudChjb250ZW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGlueW1jZS5iYXNlVVJMID0gJy8vZy5hbGljZG4uY29tL3V4Y29yZS91eGNvcmUtbGliL3RpbnltY2UvNC4yLjUvJztcbiAgICAgICAgdGlueW1jZS5pbml0KGNvbmZpZyk7XG4gICAgICAgIFJlYWN0RE9NLmZpbmRET01Ob2RlKG1lKS5zdHlsZS52aXNpYmlsaXR5ID0gXCJcIjtcbiAgICAgICAgbWUuX2lzSW5pdCA9IHRydWU7XG4gICAgfTtcblxuICAgIFRpbnltY2UucHJvdG90eXBlLl9yZW1vdmUgPSBmdW5jdGlvbiBfcmVtb3ZlKCkge1xuICAgICAgICB0aW55bWNlLkVkaXRvck1hbmFnZXIuZXhlY0NvbW1hbmQoXCJtY2VSZW1vdmVFZGl0b3JcIiwgdHJ1ZSwgdGhpcy5pZCk7XG4gICAgICAgIHRoaXMuX2lzSW5pdCA9IGZhbHNlO1xuICAgIH07XG5cbiAgICBUaW55bWNlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScsIHsgaWQ6IHRoaXMuaWQsIGRlZmF1bHRWYWx1ZTogdGhpcy5wcm9wcy5jb250ZW50IH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gVGlueW1jZTtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuVGlueW1jZS5kZWZhdWx0UHJvcHMgPSB7XG4gICAgY29uZmlnOiB7fSxcbiAgICBjb250ZW50OiAnJ1xufTtcblxuLy8gaHR0cDovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3JldXNhYmxlLWNvbXBvbmVudHMuaHRtbFxuVGlueW1jZS5wcm9wVHlwZXMgPSB7XG4gICAgY29uZmlnOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIGNvbnRlbnQ6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmdcbn07XG5cbi8vYWRkIGhhbmRsZXIgcHJvcFR5cGVzXG5IQU5ETEVSX05BTUVTLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBUaW55bWNlLnByb3BUeXBlc1tuYW1lXSA9IFJlYWN0LlByb3BUeXBlcy5mdW5jO1xufSk7XG5cblRpbnltY2UuZGlzcGxheU5hbWUgPSBcIlRpbnltY2VcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBUaW55bWNlO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtdGlueW1jZS9idWlsZC9UaW55bWNlLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY291bnQgPSAwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICB1Y19maXJzdDogZnVuY3Rpb24gdWNfZmlyc3Qoc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xuICAgIH0sXG4gICAgdXVpZDogZnVuY3Rpb24gdXVpZCgpIHtcbiAgICAgICAgcmV0dXJuICd1eGNvcmUtdGlueW1jZS0nICsgY291bnQrKztcbiAgICB9LFxuICAgIGlzRXF1YWw6IGZ1bmN0aW9uIGlzRXF1YWwoYSwgYikge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYSkgPT0gSlNPTi5zdHJpbmdpZnkoYik7XG4gICAgfVxufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLXRpbnltY2UvYnVpbGQvdXRpbC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBwbHVnaW5zID0gWydsaXN0cycsICdocicsICdlbW90aWNvbnMnLCAndGV4dGNvbG9yJywgJ2luc2VydGRhdGV0aW1lJywgJ2xpbmsnLCAndGFibGUnLCAncGFzdGUnLCAncHJldmlldycsICd3b3JkY291bnQnLCAnaW1hZ2UnLCAndXBsb2FkJ107XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0ge1xuXHR0aGVtZTogJ21vZGVybicsXG5cdGhlaWdodDogNDAwLFxuXHRleHRlcm5hbF9wbHVnaW5zOiB7XG5cdFx0J2Vtb3RpY29ucyc6ICcvL2cuYWxpY2RuLmNvbS91eGNvcmUvdXhjb3JlLWxpYi90aW55bWNlLzQuMi41L3BsdWdpbnMvZW1vdGljb25zL3BsdWdpbi5taW4uanMnLFxuXHRcdCd1cGxvYWQnOiAnLy9nLmFsaWNkbi5jb20vdXhjb3JlL3V4Y29yZS1saWIvdGlueW1jZS80LjIuNS9wbHVnaW5zL3VwbG9hZC9wbHVnaW4ubWluLmpzJyxcblx0XHQndGV4dGNvbG9yJzogJy8vZy5hbGljZG4uY29tL3V4Y29yZS91eGNvcmUtbGliL3RpbnltY2UvNC4yLjUvcGx1Z2lucy90ZXh0Y29sb3IvcGx1Z2luLm1pbi5qcycsXG5cdFx0J2hyJzogJy8vZy5hbGljZG4uY29tL3V4Y29yZS91eGNvcmUtbGliL3RpbnltY2UvNC4yLjUvcGx1Z2lucy9oci9wbHVnaW4ubWluLmpzJ1xuXHR9LFxuXHRyZXNpemU6IHRydWUsIC8vIOaYr+WQpuWPr+S7pem8oOagh+aLluWKqOe8lui+keWZqOaUueWPmOWkp+Wwj1xuXHRib3JkZXJfd2lkdGg6IDEsIC8vIOe8lui+keWZqOeahOi+ueahhuWuveW6plxuXHRjb252ZXJ0X3VybHM6IGZhbHNlLCAvLyDlvZPkvaBpbnNlcnRDb250ZW5055qE5pe25YCZ77yM5Y+W5raI5LiA5Lqb6IqC54K5c3Jj55qE6L2s5o2iXG5cdHZpc3VhbDogZmFsc2UsIC8vIHRhYmxl55qE6Jma5qGG5piv5ZCm5pi+56S677yM55Sx5LqO5aSn5paH5pys6K6+572u6Jma5qGG5b6I6ICX5oCn6IO977yM5omA5Lul5Y+W5raI5o6JXG5cdGtlZXBfdmFsdWVzOiBmYWxzZSwgLy8g5b+F6aG76K6+572uZmFsc2XnlKjmnaXmj5Dpq5jmgKfog71cblx0Zm9yY2VkX3Jvb3RfYmxvY2s6ICdkaXYnLCAvLyDlvZPnqbrmlofmnKznmoTml7blgJnvvIx0aW55bWNl5Lya6K6+572u5LiA5Liq5qC56IqC54K577yM6buY6K6k5pivUO+8jOaIkeS7rOimgeaUueaIkGRpduavlOi+g+WQiOeQhlxuXHRzaG93X3N5c3RlbV9kZWZhdWx0X2ZvbnQ6IHRydWUsIC8vIOaYr+WQpuW8gOWQr+ezu+e7n+Wtl+S9k+eahOaOoua1i+OAglxuXHRsaW5rX3RpdGxlOiB0cnVlLCAvLyBsaW5rIHBsdWdpbnMgZW5hYmxlIHRpdGxlIGVkaXRcblx0cGx1Z2luczogcGx1Z2lucyxcblx0Y3NzRmlsZXM6IFsnc3R5bGVzL3NraW4uY3NzJywgJ3N0eWxlcy9za2luLWV4dC5jc3MnXSxcblx0dG9vbGJhcjE6ICdwcmV2aWV3IHVuZG8gcmVkbyB8IGZvbnRzZWxlY3QgZm9udHNpemVzZWxlY3QgfCBib2xkIGl0YWxpYyB1bmRlcmxpbmUgc3RyaWtldGhyb3VnaCByZW1vdmVmb3JtYXQgfCBmb3JlY29sb3IgYmFja2NvbG9yIHwgbGluayB8IGVtb3RpY29ucyB1cGxvYWQnLFxuXHR0b29sYmFyMjogJ2FsaWdubGVmdCBhbGlnbmNlbnRlciBhbGlnbnJpZ2h0IGFsaWduanVzdGlmeSB8IGJ1bGxpc3QgbnVtbGlzdCBvdXRkZW50IGluZGVudCB8IHRhYmxlIGhyIGluc2VydHRpbWUnLFxuXHR1cGxvYWRDb25maWc6IHtcblx0XHRcImlucHV0TmFtZVwiOiBcImltYWdlVXBsb2FkSW5wdXRcIixcblx0XHRcImFjdGlvblVybFwiOiBcImh0dHA6Ly90ZXN0LmFsaWJhYmEtaW5jLmNvbS93b3JrL3hzZXJ2aWNlL2h0dHAvdXBsb2FkaW1hZ2UuanNvblwiLFxuXHRcdFwiZXJyb3JDYWxsYmFja1wiOiBmdW5jdGlvbiBlcnJvckNhbGxiYWNrKCkge1xuXHRcdFx0Y29uc29sZS5sb2coJ2Vycm9yQ2FsbGJhY2snLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cdFx0XCJwcm9ncmVzc0NhbGxiYWNrXCI6IGZ1bmN0aW9uIHByb2dyZXNzQ2FsbGJhY2soKSB7XG5cdFx0XHRjb25zb2xlLmxvZygncHJvZ3Jlc3NDYWxsYmFjaycsIGFyZ3VtZW50cyk7XG5cdFx0fVxuXHR9LFxuXHR3b3JkY291bnRfY291bnRyZWdleDogL1teXFx4MDAtXFx4ZmZdKy9nXG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS10aW55bWNlL2J1aWxkL2VkaXRvckNvbmZpZy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogQ3JlYXRlZCBieSB4eSBvbiAxNS80LzEzLlxuICovXG52YXIgU2VsZWN0Rm9ybUZpZWxkID0gcmVxdWlyZSgnLi9TZWxlY3RGb3JtRmllbGQnKTtcbnZhciBDb25zdGFudHMgPSByZXF1aXJlKFwidXhjb3JlLWNvbnN0XCIpO1xudmFyIFNlbGVjdCA9IHJlcXVpcmUoJ3V4Y29yZS1zZWxlY3QyJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xudmFyIGRlZXBjb3B5ID0gcmVxdWlyZSgnZGVlcGNvcHknKTtcbnZhciBjbGFzc25hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xudmFyIE9wdGlvbiA9IFNlbGVjdC5PcHRpb247XG5cbnZhciBzZWxlY3RPcHRpb25zID0gWydvblNlbGVjdCcsICdvbkRlc2VsZWN0JywgJ2dldFBvcHVwQ29udGFpbmVyJywgJ2ZpbHRlck9wdGlvbicsICdhbGxvd0NsZWFyJywgJ3NlYXJjaFBsYWNlaG9sZGVyJywgJ3RhZ3MnLCAnZGlzYWJsZWQnLCAnc2hvd1NlYXJjaCcsICdwbGFjZWhvbGRlcicsICdvcHRpb25MYWJlbFByb3AnLCAnbWF4VGFnVGV4dExlbmd0aCcsICdkcm9wZG93bk1hdGNoU2VsZWN0V2lkdGgnLCAnZHJvcGRvd25DbGFzc05hbWUnLCAnbm90Rm91bmRDb250ZW50J107XG5cbnZhciBTZWFyY2hGb3JtRmllbGQgPSBmdW5jdGlvbiAoX1NlbGVjdEZvcm1GaWVsZCkge1xuICAgIF9pbmhlcml0cyhTZWFyY2hGb3JtRmllbGQsIF9TZWxlY3RGb3JtRmllbGQpO1xuXG4gICAgZnVuY3Rpb24gU2VhcmNoRm9ybUZpZWxkKHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTZWFyY2hGb3JtRmllbGQpO1xuXG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfU2VsZWN0Rm9ybUZpZWxkLmNhbGwodGhpcywgcHJvcHMpKTtcbiAgICB9XG5cbiAgICBTZWFyY2hGb3JtRmllbGQucHJvdG90eXBlLmFkZFNwZWNpZmljQ2xhc3MgPSBmdW5jdGlvbiBhZGRTcGVjaWZpY0NsYXNzKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBpZiAobWUucHJvcHMuanN4cHJlZml4Q2xzID09IFwia3VtYS11eGZvcm0tZmllbGRcIikge1xuICAgICAgICAgICAgcmV0dXJuIG1lLnByb3BzLmpzeHByZWZpeENscyArIFwiIGt1bWEtc2VhcmNoLXV4Zm9ybS1maWVsZFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1lLnByb3BzLmpzeHByZWZpeENscztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTZWFyY2hGb3JtRmllbGQucHJvdG90eXBlLl9wcm9jZXNzQWR2YW5jZWQgPSBmdW5jdGlvbiBfcHJvY2Vzc0FkdmFuY2VkKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgYWR2YW5jZWRPcHRpb25zID0gbWUucHJvcHMuYWR2YW5jZWRPcHRpb25zO1xuXG4gICAgICAgIHJldHVybiBhZHZhbmNlZE9wdGlvbnMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICBPcHRpb24sXG4gICAgICAgICAgICAgICAgeyBrZXk6IGl0ZW0udmFsdWUsIHRpdGxlOiBpdGVtLnRleHQgfSxcbiAgICAgICAgICAgICAgICBpdGVtLnRleHRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBTZWFyY2hGb3JtRmllbGQucHJvdG90eXBlLl9wcm9jZXNzQ2xhc3NPcHRpb25zID0gZnVuY3Rpb24gX3Byb2Nlc3NDbGFzc09wdGlvbnMoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBjbGFzc09wdGlvbnMgPSBtZS5wcm9wcy5jbGFzc09wdGlvbnM7XG5cbiAgICAgICAgcmV0dXJuIGNsYXNzT3B0aW9ucy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgIE9wdGlvbixcbiAgICAgICAgICAgICAgICB7IGtleTogaXRlbS52YWx1ZSwgdGl0bGU6IGl0ZW0udGV4dCB9LFxuICAgICAgICAgICAgICAgIGl0ZW0udGV4dFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIFNlYXJjaEZvcm1GaWVsZC5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKHZhbHVlLCBsYWJlbCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgc3RhdGVWYWx1ZSA9IGRlZXBjb3B5KG1lLnN0YXRlLnZhbHVlKSB8fCB7fTtcbiAgICAgICAgc3RhdGVWYWx1ZS5tYWluID0gdmFsdWU7XG4gICAgICAgIG1lLmhhbmRsZURhdGFDaGFuZ2Uoc3RhdGVWYWx1ZSwgZmFsc2UsIGxhYmVsKTtcbiAgICB9O1xuXG4gICAgU2VhcmNoRm9ybUZpZWxkLnByb3RvdHlwZS5oYW5kbGVDbGFzc0NoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUNsYXNzQ2hhbmdlKHZhbHVlKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBzdGF0ZVZhbHVlID0gZGVlcGNvcHkobWUuc3RhdGUudmFsdWUpIHx8IHt9O1xuICAgICAgICB2YXIgbGFiZWwgPSBtZS5zdGF0ZS5sYWJlbDtcbiAgICAgICAgc3RhdGVWYWx1ZVtcImNsYXNzXCJdID0gdmFsdWU7XG4gICAgICAgIG1lLmhhbmRsZURhdGFDaGFuZ2Uoc3RhdGVWYWx1ZSwgZmFsc2UsIGxhYmVsKTtcbiAgICB9O1xuXG4gICAgU2VhcmNoRm9ybUZpZWxkLnByb3RvdHlwZS5oYW5kbGVBZHZhbmNlZENoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUFkdmFuY2VkQ2hhbmdlKHZhbHVlKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBzdGF0ZVZhbHVlID0gZGVlcGNvcHkobWUuc3RhdGUudmFsdWUpIHx8IHt9O1xuICAgICAgICB2YXIgbGFiZWwgPSBtZS5zdGF0ZS5sYWJlbDtcbiAgICAgICAgc3RhdGVWYWx1ZS5hZHZhbmNlZCA9IHZhbHVlO1xuICAgICAgICBtZS5oYW5kbGVEYXRhQ2hhbmdlKHN0YXRlVmFsdWUsIGZhbHNlLCBsYWJlbCk7XG4gICAgfTtcblxuICAgIFNlYXJjaEZvcm1GaWVsZC5wcm90b3R5cGUuaGFuZGxlSWNvbkNsaWNrID0gZnVuY3Rpb24gaGFuZGxlSWNvbkNsaWNrKGUpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgbWUucHJvcHMub25JY29uQ2xpY2soZSk7XG4gICAgfTtcblxuICAgIFNlYXJjaEZvcm1GaWVsZC5wcm90b3R5cGUucmVuZGVyRmllbGQgPSBmdW5jdGlvbiByZW5kZXJGaWVsZCgpIHtcbiAgICAgICAgdmFyIF9vcHRpb25zO1xuXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgICAgdmFyIG1vZGUgPSBtZS5wcm9wcy5qc3htb2RlIHx8IG1lLnByb3BzLm1vZGU7XG5cbiAgICAgICAgdmFyIG9wdGlvbnMgPSAoX29wdGlvbnMgPSB7XG4gICAgICAgICAgICByZWY6IFwiZWxcIixcbiAgICAgICAgICAgIGtleTogXCJzZWxlY3RcIixcbiAgICAgICAgICAgIG9wdGlvbkZpbHRlclByb3A6IG1lLnByb3BzLm9wdGlvbkZpbHRlclByb3AsXG4gICAgICAgICAgICBjb21ib2JveDogbWUucHJvcHMuY29tYm9ib3gsXG4gICAgICAgICAgICBvbkNoYW5nZTogbWUuaGFuZGxlQ2hhbmdlLmJpbmQobWUpLFxuICAgICAgICAgICAgb25TZWFyY2g6IG1lLmhhbmRsZVNlYXJjaC5iaW5kKG1lKVxuICAgICAgICB9LCBfb3B0aW9uc1sna2V5J10gPSAnc2VhcmNoJywgX29wdGlvbnMpO1xuXG4gICAgICAgIHNlbGVjdE9wdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpdGVtIGluIG1lLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1tpdGVtXSA9IG1lLnByb3BzW2l0ZW1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoT2JqZWN0LmtleXMobWUucHJvcHMuanN4ZGF0YSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgb3B0aW9ucy5vcHRpb25GaWx0ZXJQcm9wID0gJ3RpdGxlJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG9ubHkganN4ZmV0Y2hVcmwgbW9kZSBuZWVkIHBhc3MgbGFiZWwsIGZvciB0aGUgb3B0aW9ucyBhbHdheXMgY2hhbmdlLlxuICAgICAgICAvLyB3aGVuIG1vdW50ZWQsIHN0YXRlLmxhYmVsIGlzIHVuZGVmaW5lZCwgd2hpY2ggY2F1c2UgZGVmYWx1dFZhbHVlIGNhbm5vdCBiZSB1c2VkLlxuICAgICAgICBpZiAoISFtZS5wcm9wcy5qc3hmZXRjaFVybCAmJiAhIW1lLnN0YXRlLmxhYmVsICYmIG1lLnN0YXRlLmxhYmVsLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgb3B0aW9ucy5sYWJlbCA9IG1lLnN0YXRlLmxhYmVsIHx8IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtZS5wcm9wcy5jb21ib2JveCB8fCBtZS5zdGF0ZS5mcm9tUmVzZXQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMudmFsdWUgPSBtZS5zdGF0ZS52YWx1ZS5tYWluIHx8IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEhbWUucHJvcHMuanN4ZmV0Y2hVcmwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZmlsdGVyT3B0aW9uID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtZS5wcm9wcy50aWR5ICYmIG1lLnByb3BzLmNsYXNzT3B0aW9ucyBpbnN0YW5jZW9mIEFycmF5ICYmIG1lLnByb3BzLmNsYXNzT3B0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBhcnIucHVzaChtZS5yZW5kZXJDbGFzc09wdGlvbnMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgYXJyLnB1c2goUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgIFNlbGVjdCxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBtZS5fcHJvY2Vzc0RhdGEoKVxuICAgICAgICApKTtcblxuICAgICAgICBpZiAoIW1lLnByb3BzLnRpZHkgJiYgbWUucHJvcHMuYWR2YW5jZWRPcHRpb25zIGluc3RhbmNlb2YgQXJyYXkgJiYgbWUucHJvcHMuYWR2YW5jZWRPcHRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGFyci5wdXNoKG1lLnJlbmRlckFkdmFuY2VkT3B0aW9ucygpKTtcbiAgICAgICAgfVxuICAgICAgICBhcnIucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6IGNsYXNzbmFtZXMoe1xuICAgICAgICAgICAgICAgICAgICBcImt1bWEtc2VhcmNoLXV4Zm9ybS1maWVsZC1pY29uXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIFwidGlkeS1wYXR0ZXJuXCI6IG1lLnByb3BzLnRpZHlcbiAgICAgICAgICAgICAgICB9KSwga2V5OiAnaWNvbicsIG9uQ2xpY2s6IG1lLmhhbmRsZUljb25DbGljay5iaW5kKG1lKSB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnaScsIHsgY2xhc3NOYW1lOiAna3VtYS1pY29uIGt1bWEtaWNvbi1zZWFyY2gnIH0pXG4gICAgICAgICkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH07XG5cbiAgICBTZWFyY2hGb3JtRmllbGQucHJvdG90eXBlLnJlbmRlckNsYXNzT3B0aW9ucyA9IGZ1bmN0aW9uIHJlbmRlckNsYXNzT3B0aW9ucygpIHtcbiAgICAgICAgdmFyIF9jbGFzc25hbWVzLCBfY2xhc3NuYW1lczI7XG5cbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIF9tZSRwcm9wcyRjbGFzc0NvbmZpZyA9IG1lLnByb3BzLmNsYXNzQ29uZmlnO1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gX21lJHByb3BzJGNsYXNzQ29uZmlnLmNsYXNzTmFtZTtcbiAgICAgICAgdmFyIGRyb3Bkb3duQ2xhc3NOYW1lID0gX21lJHByb3BzJGNsYXNzQ29uZmlnLmRyb3Bkb3duQ2xhc3NOYW1lO1xuICAgICAgICB2YXIgb25DaGFuZ2UgPSBfbWUkcHJvcHMkY2xhc3NDb25maWcub25DaGFuZ2U7XG5cbiAgICAgICAgdmFyIG90aGVyT3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfbWUkcHJvcHMkY2xhc3NDb25maWcsIFsnY2xhc3NOYW1lJywgJ2Ryb3Bkb3duQ2xhc3NOYW1lJywgJ29uQ2hhbmdlJ10pO1xuXG4gICAgICAgIHZhciBvcHRpb25zID0gYXNzaWduKHt9LCB7XG4gICAgICAgICAgICBzaG93U2VhcmNoOiBmYWxzZSxcbiAgICAgICAgICAgIGtleTogJ2NsYXNzJyxcbiAgICAgICAgICAgIGRyb3Bkb3duQ2xhc3NOYW1lOiBjbGFzc25hbWVzKChfY2xhc3NuYW1lcyA9IHtcbiAgICAgICAgICAgICAgICBcImt1bWEtdXhmb3JtLWNsYXNzLWRyb3Bkb3duXCI6IHRydWVcbiAgICAgICAgICAgIH0sIF9jbGFzc25hbWVzW2Ryb3Bkb3duQ2xhc3NOYW1lXSA9ICEhZHJvcGRvd25DbGFzc05hbWUsIF9jbGFzc25hbWVzKSksXG4gICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXMoKF9jbGFzc25hbWVzMiA9IHtcbiAgICAgICAgICAgICAgICBcImt1bWEtdXhmb3JtLWNsYXNzLXNlYXJjaFwiOiB0cnVlXG4gICAgICAgICAgICB9LCBfY2xhc3NuYW1lczJbY2xhc3NOYW1lXSA9ICEhY2xhc3NOYW1lLCBfY2xhc3NuYW1lczIpKSxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiBtZS5oYW5kbGVDbGFzc0NoYW5nZS5iaW5kKG1lKVxuICAgICAgICB9LCBvdGhlck9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgIFNlbGVjdCxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBtZS5fcHJvY2Vzc0NsYXNzT3B0aW9ucygpXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIFNlYXJjaEZvcm1GaWVsZC5wcm90b3R5cGUucmVuZGVyQWR2YW5jZWRPcHRpb25zID0gZnVuY3Rpb24gcmVuZGVyQWR2YW5jZWRPcHRpb25zKCkge1xuICAgICAgICB2YXIgX2NsYXNzbmFtZXMzO1xuXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBfbWUkcHJvcHMkYWR2YW5jZWRDb24gPSBtZS5wcm9wcy5hZHZhbmNlZENvbmZpZztcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IF9tZSRwcm9wcyRhZHZhbmNlZENvbi5jbGFzc05hbWU7XG4gICAgICAgIHZhciBvbkNoYW5nZSA9IF9tZSRwcm9wcyRhZHZhbmNlZENvbi5vbkNoYW5nZTtcblxuICAgICAgICB2YXIgb3RoZXJPcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9tZSRwcm9wcyRhZHZhbmNlZENvbiwgWydjbGFzc05hbWUnLCAnb25DaGFuZ2UnXSk7XG5cbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhc3NpZ24oe30sIHtcbiAgICAgICAgICAgIHNob3dTZWFyY2g6IGZhbHNlLFxuICAgICAgICAgICAga2V5OiAnYWR2YW5jZWQnLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc25hbWVzKChfY2xhc3NuYW1lczMgPSB7XG4gICAgICAgICAgICAgICAgJ2t1bWEtdXhmb3JtLWFkdmFuY2VkLXNlYXJjaCc6IHRydWVcbiAgICAgICAgICAgIH0sIF9jbGFzc25hbWVzM1tjbGFzc05hbWVdID0gISFjbGFzc05hbWUsIF9jbGFzc25hbWVzMykpLFxuICAgICAgICAgICAgb25DaGFuZ2U6IG1lLmhhbmRsZUFkdmFuY2VkQ2hhbmdlLmJpbmQobWUpXG4gICAgICAgIH0sIG90aGVyT3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgU2VsZWN0LFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIG1lLl9wcm9jZXNzQWR2YW5jZWQoKVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2VhcmNoRm9ybUZpZWxkO1xufShTZWxlY3RGb3JtRmllbGQpO1xuXG5TZWFyY2hGb3JtRmllbGQuT3B0aW9uID0gT3B0aW9uO1xuU2VhcmNoRm9ybUZpZWxkLmRpc3BsYXlOYW1lID0gXCJTZWFyY2hGb3JtRmllbGRcIjtcblNlYXJjaEZvcm1GaWVsZC5wcm9wVHlwZXMgPSBhc3NpZ24oe30sIFNlbGVjdEZvcm1GaWVsZC5wcm9wVHlwZXMsIHtcbiAgICBhZHZhbmNlZE9wdGlvbnM6IFJlYWN0LlByb3BUeXBlcy5hcnJheSxcbiAgICBhZHZhbmNlZENvbmZpZzogUmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBjbGFzc09wdGlvbnM6IFJlYWN0LlByb3BUeXBlcy5hcnJheSxcbiAgICBjbGFzc0NvbmZpZzogUmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICB0aWR5OiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBvbkljb25DbGljazogUmVhY3QuUHJvcFR5cGVzLmZ1bmNcbn0pO1xuU2VhcmNoRm9ybUZpZWxkLmRlZmF1bHRQcm9wcyA9IGFzc2lnbih7fSwgU2VsZWN0Rm9ybUZpZWxkLmRlZmF1bHRQcm9wcywge1xuICAgIGpzeHNob3dMYWJlbDogZmFsc2UsXG4gICAgY29tYm9ib3g6IHRydWUsXG4gICAgYWR2YW5jZWRDb25maWc6IHt9LFxuICAgIGNsYXNzQ29uZmlnOiB7fSxcbiAgICB0aWR5OiBmYWxzZSxcbiAgICBvbkljb25DbGljazogZnVuY3Rpb24gb25JY29uQ2xpY2soKSB7fVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2VhcmNoRm9ybUZpZWxkO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9idWlsZC9Gb3JtRmllbGQvU2VhcmNoRm9ybUZpZWxkLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdyaWQgQ29tcG9uZW50IGZvciB1eGNvcmVcbiAqIEBhdXRob3IgZXRlcm5hbGt5XG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgVXhjb3JlIFRlYW0sIEFsaW53LlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vR3JpZCcpO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtZ3JpZC9idWlsZC9pbmRleC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKlxuICogSW5zcGlyZWQgYnkgcmVhY3QtYm9vdHN0cmFwOiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3QtYm9vdHN0cmFwL3JlYWN0LWJvb3RzdHJhcC8gXG4gKi9cblxudmFyIGNsYXNzTmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG52YXIgZWxlbWVudFR5cGUgPSByZXF1aXJlKCdyZWFjdC1wcm9wLXR5cGVzL2xpYi9lbGVtZW50VHlwZScpO1xudmFyIFJvdyA9IHJlcXVpcmUoXCIuL1Jvd1wiKTtcbnZhciBDb2wgPSByZXF1aXJlKFwiLi9Db2xcIik7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBHcmlkID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoR3JpZCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBHcmlkKHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHcmlkKTtcblxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKEdyaWQpLmNhbGwodGhpcywgcHJvcHMpKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoR3JpZCwgW3tcbiAgICAgICAga2V5OiAncmVuZGVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgICAgIHZhciBDb21wb25lbnRDbGFzcyA9IHRoaXMucHJvcHMuY29tcG9uZW50Q2xhc3M7XG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy5wcm9wcy5mbHVpZCA/ICdrdW1hLWNvbnRhaW5lci1mbHVpZCcgOiAna3VtYS1jb250YWluZXInO1xuXG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICBDb21wb25lbnRDbGFzcyxcbiAgICAgICAgICAgICAgICBfZXh0ZW5kcyh7fSwgdGhpcy5wcm9wcywge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXModGhpcy5wcm9wcy5jbGFzc05hbWUsIGNsYXNzTmFtZSkgfSksXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5jaGlsZHJlblxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBHcmlkO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5HcmlkLmRpc3BsYXlOYW1lID0gXCJHcmlkXCI7XG5HcmlkLnByb3BUeXBlcyA9IHtcbiAgICAvKipcbiAgICAgKiBUdXJuIGFueSBmaXhlZC13aWR0aCBncmlkIGxheW91dCBpbnRvIGEgZnVsbC13aWR0aCBsYXlvdXQgYnkgdGhpcyBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEFkZHMgYGNvbnRhaW5lci1mbHVpZGAgY2xhc3MuXG4gICAgICovXG4gICAgZmx1aWQ6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIC8qKlxuICAgICAqIFlvdSBjYW4gdXNlIGEgY3VzdG9tIGVsZW1lbnQgZm9yIHRoaXMgY29tcG9uZW50XG4gICAgICovXG4gICAgY29tcG9uZW50Q2xhc3M6IGVsZW1lbnRUeXBlXG59O1xuXG5HcmlkLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb21wb25lbnRDbGFzczogJ2RpdicsXG4gICAgZmx1aWQ6IGZhbHNlXG59O1xuXG5HcmlkLlJvdyA9IFJvdztcbkdyaWQuQ29sID0gQ29sO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyaWQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1ncmlkL2J1aWxkL0dyaWQuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX2NvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBwcm9wIHByb3ZpZGVzIGEgdHlwZSBvZiBlbGVtZW50LlxuICpcbiAqIFRoZSB0eXBlIG9mIGVsZW1lbnQgY2FuIGJlIHByb3ZpZGVkIGluIHR3byBmb3JtczpcbiAqIC0gdGFnIG5hbWUgKHN0cmluZylcbiAqIC0gYSByZXR1cm4gdmFsdWUgb2YgUmVhY3QuY3JlYXRlQ2xhc3MoLi4uKVxuICpcbiAqIEBwYXJhbSBwcm9wc1xuICogQHBhcmFtIHByb3BOYW1lXG4gKiBAcGFyYW0gY29tcG9uZW50TmFtZVxuICogQHJldHVybnMge0Vycm9yfHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgdmFyIGVyckJlZ2lubmluZyA9IF9jb21tb24uZXJyTXNnKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgJy4gRXhwZWN0ZWQgYW4gRWxlbWVudCBgdHlwZWAnKTtcblxuICBpZiAodHlwZW9mIHByb3BzW3Byb3BOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChfcmVhY3QyWydkZWZhdWx0J10uaXNWYWxpZEVsZW1lbnQocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcihlcnJCZWdpbm5pbmcgKyAnLCBub3QgYW4gYWN0dWFsIEVsZW1lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHByb3BzW3Byb3BOYW1lXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoZXJyQmVnaW5uaW5nICsgJyBzdWNoIGFzIGEgdGFnIG5hbWUgb3IgcmV0dXJuIHZhbHVlIG9mIFJlYWN0LmNyZWF0ZUNsYXNzKC4uLiknKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gX2NvbW1vbi5jcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWdyaWQvfi9yZWFjdC1wcm9wLXR5cGVzL2xpYi9lbGVtZW50VHlwZS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZXJyTXNnID0gZXJyTXNnO1xuZXhwb3J0cy5jcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlciA9IGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyO1xuXG5mdW5jdGlvbiBlcnJNc2cocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBtc2dDb250aW51YXRpb24pIHtcbiAgcmV0dXJuICdJbnZhbGlkIHByb3AgXFwnJyArIHByb3BOYW1lICsgJ1xcJyBvZiB2YWx1ZSBcXCcnICsgcHJvcHNbcHJvcE5hbWVdICsgJ1xcJycgKyAoJyBzdXBwbGllZCB0byBcXCcnICsgY29tcG9uZW50TmFtZSArICdcXCcnICsgbXNnQ29udGludWF0aW9uKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgY2hhaW4tYWJsZSBpc1JlcXVpcmVkIHZhbGlkYXRvclxuICpcbiAqIExhcmdlbHkgY29waWVkIGRpcmVjdGx5IGZyb206XG4gKiAgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvMC4xMS1zdGFibGUvc3JjL2NvcmUvUmVhY3RQcm9wVHlwZXMuanMjTDk0XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8ICc8PGFub255bW91cz4+JztcbiAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1JlcXVpcmVkIHByb3AgXFwnJyArIHByb3BOYW1lICsgJ1xcJyB3YXMgbm90IHNwZWNpZmllZCBpbiBcXCcnICsgY29tcG9uZW50TmFtZSArICdcXCcuJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblxuICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWdyaWQvfi9yZWFjdC1wcm9wLXR5cGVzL2xpYi9jb21tb24uanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIGNsYXNzTmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG52YXIgZWxlbWVudFR5cGUgPSByZXF1aXJlKCdyZWFjdC1wcm9wLXR5cGVzL2xpYi9lbGVtZW50VHlwZScpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgUm93ID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoUm93LCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIFJvdyhwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUm93KTtcblxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKFJvdykuY2FsbCh0aGlzLCBwcm9wcykpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhSb3csIFt7XG4gICAgICAgIGtleTogJ3JlbmRlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgICAgICB2YXIgQ29tcG9uZW50Q2xhc3MgPSB0aGlzLnByb3BzLmNvbXBvbmVudENsYXNzO1xuXG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICBDb21wb25lbnRDbGFzcyxcbiAgICAgICAgICAgICAgICBfZXh0ZW5kcyh7fSwgdGhpcy5wcm9wcywgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXModGhpcy5wcm9wcy5jbGFzc05hbWUsICdrdW1hLXJvdycpIH0pLFxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuY2hpbGRyZW5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUm93O1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5Sb3cuZGlzcGxheU5hbWUgPSBcIlJvd1wiO1xuUm93LnByb3BUeXBlcyA9IHtcbiAgICAvKipcbiAgICAgKiBZb3UgY2FuIHVzZSBhIGN1c3RvbSBlbGVtZW50IGZvciB0aGlzIGNvbXBvbmVudFxuICAgICAqL1xuICAgIGNvbXBvbmVudENsYXNzOiBlbGVtZW50VHlwZVxufTtcblJvdy5kZWZhdWx0UHJvcHMgPSB7XG4gICAgY29tcG9uZW50Q2xhc3M6ICdkaXYnXG59O1xubW9kdWxlLmV4cG9ydHMgPSBSb3c7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1ncmlkL2J1aWxkL1Jvdy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgY2xhc3NOYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcbnZhciBzdHlsZU1hcHMgPSByZXF1aXJlKCcuL1N0eWxlTWFwcycpO1xudmFyIGVsZW1lbnRUeXBlID0gcmVxdWlyZSgncmVhY3QtcHJvcC10eXBlcy9saWIvZWxlbWVudFR5cGUnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIENvbCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhDb2wsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIENvbChwcm9wcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb2wpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihDb2wpLmNhbGwodGhpcywgcHJvcHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDb2wsIFt7XG4gICAga2V5OiAncmVuZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBDb21wb25lbnRDbGFzcyA9IHRoaXMucHJvcHMuY29tcG9uZW50Q2xhc3M7XG4gICAgICB2YXIgY2xhc3NlcyA9IHt9O1xuXG4gICAgICBPYmplY3Qua2V5cyhzdHlsZU1hcHMuU0laRVMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgc2l6ZSA9IHN0eWxlTWFwcy5TSVpFU1trZXldO1xuICAgICAgICB2YXIgcHJvcCA9IHNpemU7XG4gICAgICAgIHZhciBjbGFzc1BhcnQgPSBzaXplICsgJy0nO1xuXG4gICAgICAgIGlmIChfdGhpczIucHJvcHNbcHJvcF0pIHtcbiAgICAgICAgICBjbGFzc2VzWydjb2wtJyArIGNsYXNzUGFydCArIF90aGlzMi5wcm9wc1twcm9wXV0gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvcCA9IHNpemUgKyAnT2Zmc2V0JztcbiAgICAgICAgY2xhc3NQYXJ0ID0gc2l6ZSArICctb2Zmc2V0LSc7XG4gICAgICAgIGlmIChfdGhpczIucHJvcHNbcHJvcF0gPj0gMCkge1xuICAgICAgICAgIGNsYXNzZXNbJ2NvbC0nICsgY2xhc3NQYXJ0ICsgX3RoaXMyLnByb3BzW3Byb3BdXSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9wID0gc2l6ZSArICdQdXNoJztcbiAgICAgICAgY2xhc3NQYXJ0ID0gc2l6ZSArICctcHVzaC0nO1xuICAgICAgICBpZiAoX3RoaXMyLnByb3BzW3Byb3BdID49IDApIHtcbiAgICAgICAgICBjbGFzc2VzWydjb2wtJyArIGNsYXNzUGFydCArIF90aGlzMi5wcm9wc1twcm9wXV0gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvcCA9IHNpemUgKyAnUHVsbCc7XG4gICAgICAgIGNsYXNzUGFydCA9IHNpemUgKyAnLXB1bGwtJztcbiAgICAgICAgaWYgKF90aGlzMi5wcm9wc1twcm9wXSA+PSAwKSB7XG4gICAgICAgICAgY2xhc3Nlc1snY29sLScgKyBjbGFzc1BhcnQgKyBfdGhpczIucHJvcHNbcHJvcF1dID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICBDb21wb25lbnRDbGFzcyxcbiAgICAgICAgX2V4dGVuZHMoe30sIHRoaXMucHJvcHMsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHRoaXMucHJvcHMuY2xhc3NOYW1lLCBjbGFzc2VzKSB9KSxcbiAgICAgICAgdGhpcy5wcm9wcy5jaGlsZHJlblxuICAgICAgKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29sO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5Db2wuZGlzcGxheU5hbWUgPSBcIkNvbFwiO1xuQ29sLnByb3BUeXBlcyA9IHtcbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgY29sdW1ucyB5b3Ugd2lzaCB0byBzcGFuXG4gICAqXG4gICAqIGZvciBFeHRyYSBzbWFsbCBkZXZpY2VzIFBob25lcyAoPDc2OHB4KVxuICAgKlxuICAgKiBjbGFzcy1wcmVmaXggYGNvbC14cy1gXG4gICAqL1xuICB4czogUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgY29sdW1ucyB5b3Ugd2lzaCB0byBzcGFuXG4gICAqXG4gICAqIGZvciBTbWFsbCBkZXZpY2VzIFRhYmxldHMgKOKJpTc2OHB4KVxuICAgKlxuICAgKiBjbGFzcy1wcmVmaXggYGNvbC1zbS1gXG4gICAqL1xuICBzbTogUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgY29sdW1ucyB5b3Ugd2lzaCB0byBzcGFuXG4gICAqXG4gICAqIGZvciBNZWRpdW0gZGV2aWNlcyBEZXNrdG9wcyAo4omlOTkycHgpXG4gICAqXG4gICAqIGNsYXNzLXByZWZpeCBgY29sLW1kLWBcbiAgICovXG4gIG1kOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBjb2x1bW5zIHlvdSB3aXNoIHRvIHNwYW5cbiAgICpcbiAgICogZm9yIExhcmdlIGRldmljZXMgRGVza3RvcHMgKOKJpTEyMDBweClcbiAgICpcbiAgICogY2xhc3MtcHJlZml4IGBjb2wtbGctYFxuICAgKi9cbiAgbGc6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gIC8qKlxuICAgKiBNb3ZlIGNvbHVtbnMgdG8gdGhlIHJpZ2h0XG4gICAqXG4gICAqIGZvciBFeHRyYSBzbWFsbCBkZXZpY2VzIFBob25lc1xuICAgKlxuICAgKiBjbGFzcy1wcmVmaXggYGNvbC14cy1vZmZzZXQtYFxuICAgKi9cbiAgeHNPZmZzZXQ6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gIC8qKlxuICAgKiBNb3ZlIGNvbHVtbnMgdG8gdGhlIHJpZ2h0XG4gICAqXG4gICAqIGZvciBTbWFsbCBkZXZpY2VzIFRhYmxldHNcbiAgICpcbiAgICogY2xhc3MtcHJlZml4IGBjb2wtc20tb2Zmc2V0LWBcbiAgICovXG4gIHNtT2Zmc2V0OiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAvKipcbiAgICogTW92ZSBjb2x1bW5zIHRvIHRoZSByaWdodFxuICAgKlxuICAgKiBmb3IgTWVkaXVtIGRldmljZXMgRGVza3RvcHNcbiAgICpcbiAgICogY2xhc3MtcHJlZml4IGBjb2wtbWQtb2Zmc2V0LWBcbiAgICovXG4gIG1kT2Zmc2V0OiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAvKipcbiAgICogTW92ZSBjb2x1bW5zIHRvIHRoZSByaWdodFxuICAgKlxuICAgKiBmb3IgTGFyZ2UgZGV2aWNlcyBEZXNrdG9wc1xuICAgKlxuICAgKiBjbGFzcy1wcmVmaXggYGNvbC1sZy1vZmZzZXQtYFxuICAgKi9cbiAgbGdPZmZzZXQ6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gIC8qKlxuICAgKiBDaGFuZ2UgdGhlIG9yZGVyIG9mIGdyaWQgY29sdW1ucyB0byB0aGUgcmlnaHRcbiAgICpcbiAgICogZm9yIEV4dHJhIHNtYWxsIGRldmljZXMgUGhvbmVzXG4gICAqXG4gICAqIGNsYXNzLXByZWZpeCBgY29sLXhzLXB1c2gtYFxuICAgKi9cbiAgeHNQdXNoOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAvKipcbiAgICogQ2hhbmdlIHRoZSBvcmRlciBvZiBncmlkIGNvbHVtbnMgdG8gdGhlIHJpZ2h0XG4gICAqXG4gICAqIGZvciBTbWFsbCBkZXZpY2VzIFRhYmxldHNcbiAgICpcbiAgICogY2xhc3MtcHJlZml4IGBjb2wtc20tcHVzaC1gXG4gICAqL1xuICBzbVB1c2g6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gIC8qKlxuICAgKiBDaGFuZ2UgdGhlIG9yZGVyIG9mIGdyaWQgY29sdW1ucyB0byB0aGUgcmlnaHRcbiAgICpcbiAgICogZm9yIE1lZGl1bSBkZXZpY2VzIERlc2t0b3BzXG4gICAqXG4gICAqIGNsYXNzLXByZWZpeCBgY29sLW1kLXB1c2gtYFxuICAgKi9cbiAgbWRQdXNoOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAvKipcbiAgICogQ2hhbmdlIHRoZSBvcmRlciBvZiBncmlkIGNvbHVtbnMgdG8gdGhlIHJpZ2h0XG4gICAqXG4gICAqIGZvciBMYXJnZSBkZXZpY2VzIERlc2t0b3BzXG4gICAqXG4gICAqIGNsYXNzLXByZWZpeCBgY29sLWxnLXB1c2gtYFxuICAgKi9cbiAgbGdQdXNoOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAvKipcbiAgICogQ2hhbmdlIHRoZSBvcmRlciBvZiBncmlkIGNvbHVtbnMgdG8gdGhlIGxlZnRcbiAgICpcbiAgICogZm9yIEV4dHJhIHNtYWxsIGRldmljZXMgUGhvbmVzXG4gICAqXG4gICAqIGNsYXNzLXByZWZpeCBgY29sLXhzLXB1bGwtYFxuICAgKi9cbiAgeHNQdWxsOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAvKipcbiAgICogQ2hhbmdlIHRoZSBvcmRlciBvZiBncmlkIGNvbHVtbnMgdG8gdGhlIGxlZnRcbiAgICpcbiAgICogZm9yIFNtYWxsIGRldmljZXMgVGFibGV0c1xuICAgKlxuICAgKiBjbGFzcy1wcmVmaXggYGNvbC1zbS1wdWxsLWBcbiAgICovXG4gIHNtUHVsbDogUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgLyoqXG4gICAqIENoYW5nZSB0aGUgb3JkZXIgb2YgZ3JpZCBjb2x1bW5zIHRvIHRoZSBsZWZ0XG4gICAqXG4gICAqIGZvciBNZWRpdW0gZGV2aWNlcyBEZXNrdG9wc1xuICAgKlxuICAgKiBjbGFzcy1wcmVmaXggYGNvbC1tZC1wdWxsLWBcbiAgICovXG4gIG1kUHVsbDogUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgLyoqXG4gICAqIENoYW5nZSB0aGUgb3JkZXIgb2YgZ3JpZCBjb2x1bW5zIHRvIHRoZSBsZWZ0XG4gICAqXG4gICAqIGZvciBMYXJnZSBkZXZpY2VzIERlc2t0b3BzXG4gICAqXG4gICAqIGNsYXNzLXByZWZpeCBgY29sLWxnLXB1bGwtYFxuICAgKi9cbiAgbGdQdWxsOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAvKipcbiAgICogWW91IGNhbiB1c2UgYSBjdXN0b20gZWxlbWVudCBmb3IgdGhpcyBjb21wb25lbnRcbiAgICovXG4gIGNvbXBvbmVudENsYXNzOiBlbGVtZW50VHlwZVxufTtcblxuQ29sLmRlZmF1bHRQcm9wcyA9IHtcbiAgY29tcG9uZW50Q2xhc3M6ICdkaXYnXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWdyaWQvYnVpbGQvQ29sLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBTSVpFUzoge1xuICAgICAgICAnbGFyZ2UnOiAnbGcnLFxuICAgICAgICAnbWVkaXVtJzogJ21kJyxcbiAgICAgICAgJ3NtYWxsJzogJ3NtJyxcbiAgICAgICAgJ3hzbWFsbCc6ICd4cycsXG4gICAgICAgICdsZyc6ICdsZycsXG4gICAgICAgICdtZCc6ICdtZCcsXG4gICAgICAgICdzbSc6ICdzbScsXG4gICAgICAgICd4cyc6ICd4cydcbiAgICB9XG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtZ3JpZC9idWlsZC9TdHlsZU1hcHMuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTGF5b3V0IENvbXBvbmVudCBmb3IgdXhjb3JlXG4gKiBAYXV0aG9yIFxuICpcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIFV4Y29yZSBUZWFtLCBBbGludy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL0xheW91dCcpO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtbGF5b3V0L2J1aWxkL2luZGV4LmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4qIEBhdXRob3I6IGV0ZXJuYWxza3lcbiogQHRpbWU6ICAgMTAvMjYgMjAxNVxuKi9cblxudmFyIExlZnQgPSByZXF1aXJlKFwiLi9MZWZ0XCIpO1xudmFyIFJpZ2h0ID0gcmVxdWlyZShcIi4vUmlnaHRcIik7XG52YXIgY2xhc3NuYW1lcyA9IHJlcXVpcmUoXCJjbGFzc25hbWVzXCIpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgTGF5b3V0ID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoTGF5b3V0LCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIExheW91dChwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGF5b3V0KTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTGF5b3V0KS5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7fTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhMYXlvdXQsIFt7XG4gICAgICAgIGtleTogXCJwcm9jZXNzQ2hpbGRyZW5cIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NDaGlsZHJlbigpIHtcbiAgICAgICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBtZS5wcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgICAgIHZhciBsZWZ0QWRhcHRpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciByaWdodEFkYXB0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICBSZWFjdC5DaGlsZHJlbi5tYXAoY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZCAmJiB0eXBlb2YgY2hpbGQudHlwZSA9PSAnZnVuY3Rpb24nICYmIGNoaWxkLnR5cGUuZGlzcGxheU5hbWUgPT0gJ0xlZnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmxlZnQgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgbGVmdEFkYXB0aXZlID0gISFjaGlsZC5wcm9wcy5hZGFwdGl2ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkICYmIHR5cGVvZiBjaGlsZC50eXBlID09ICdmdW5jdGlvbicgJiYgY2hpbGQudHlwZS5kaXNwbGF5TmFtZSA9PSAnUmlnaHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnJpZ2h0ID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0QWRhcHRpdmUgPSAhIWNoaWxkLnByb3BzLmFkYXB0aXZlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS5zdWZmaXggPSBtZS5nZXRTdWZmaXgobGVmdEFkYXB0aXZlLCByaWdodEFkYXB0aXZlKTtcbiAgICAgICAgICAgIGlmIChtZS5zdWZmaXggPT0gJ3JmJykge1xuICAgICAgICAgICAgICAgIG1lLnJpZ2h0U3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbkxlZnQ6IC1tZS5yaWdodC5wcm9wcy53aWR0aFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbWUubGVmdFN0eWxlID0ge1xuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nUmlnaHQ6IG1lLnJpZ2h0LnByb3BzLndpZHRoXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWUuc3VmZml4ID09ICdsZicpIHtcbiAgICAgICAgICAgICAgICBtZS5yaWdodFN0eWxlID0ge1xuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nTGVmdDogbWUubGVmdC5wcm9wcy53aWR0aFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbWUubGVmdFN0eWxlID0ge1xuICAgICAgICAgICAgICAgICAgICBtYXJnaW5SaWdodDogLW1lLmxlZnQucHJvcHMud2lkdGhcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lLmdlbmVyYXRlQ2xhc3MobWUuc3VmZml4KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImdldFN1ZmZpeFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3VmZml4KGxlZnRBZGFwdGl2ZSwgcmlnaHRBZGFwdGl2ZSkge1xuICAgICAgICAgICAgdmFyIHN1ZmZpeCA9ICcnO1xuICAgICAgICAgICAgLy8g5aaC5p6c6YO95piv6Z2e6Ieq6YCC5bqU77yM5YiZ5Li6IGZpeGVkXG4gICAgICAgICAgICBpZiAoIWxlZnRBZGFwdGl2ZSAmJiAhcmlnaHRBZGFwdGl2ZSkge1xuICAgICAgICAgICAgICAgIHN1ZmZpeCA9ICdmaXhlZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyDlt6bkvqflrprlrr3vvIzlj7Pkvqfoh6rpgILlupTvvIxsZlxuICAgICAgICAgICAgZWxzZSBpZiAoIWxlZnRBZGFwdGl2ZSAmJiByaWdodEFkYXB0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1ZmZpeCA9ICdsZic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIOW3puS+p+iHqumAguW6lO+8jOWPs+S+p+WumuWuve+8jHJmXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobGVmdEFkYXB0aXZlICYmICFyaWdodEFkYXB0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWZmaXggPSAncmYnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImxlZnQgYW5kIHJpZ2h0IGNhbm5vdCBiZSBib3RoIGFkYXB0aXZlLCBsYXlvdXQgZ2VuZXJhdGlvbiBmYWlsZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdWZmaXg7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJnZW5lcmF0ZUNsYXNzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZW5lcmF0ZUNsYXNzKHN1ZmZpeCkge1xuICAgICAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBSZWFjdC5DaGlsZHJlbi5jb3VudChtZS5wcm9wcy5jaGlsZHJlbik7XG4gICAgICAgICAgICB2YXIgbGF5b3V0Q2xzID0gJyc7XG4gICAgICAgICAgICB2YXIgbGVmdENscyA9ICcnO1xuICAgICAgICAgICAgdmFyIHJpZ2h0Q2xzID0gJyc7XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGggPT0gMikge1xuICAgICAgICAgICAgICAgIGxheW91dENscyA9ICdrdW1hLWxheW91dC0yYyc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxlbmd0aENscyA9PSAzKSB7XG4gICAgICAgICAgICAgICAgbGF5b3V0Q2xzID0gJ2t1bWEtbGF5b3V0LTNjJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImNoaWxkcmVuIGxlbmd0aCBzaG91bGQgYmUgMiBvciAzLCBsYXlvdXQgZ2VuZXJhdGlvbiBmYWlsZWRcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxlZnRDbHMgPSBsYXlvdXRDbHMgKyAnLWxlZnQtJyArIHN1ZmZpeDtcbiAgICAgICAgICAgIHJpZ2h0Q2xzID0gbGF5b3V0Q2xzICsgJy1yaWdodC0nICsgc3VmZml4O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsYXlvdXRDbHM6IGxheW91dENscyxcbiAgICAgICAgICAgICAgICBsZWZ0Q2xzOiBsZWZ0Q2xzLFxuICAgICAgICAgICAgICAgIHJpZ2h0Q2xzOiByaWdodENsc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInJlbmRlckxlZnRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckxlZnQoY2xzKSB7XG4gICAgICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCEhbWUubGVmdCkge1xuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NuYW1lcztcblxuICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQobWUubGVmdCwge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXMoKF9jbGFzc25hbWVzID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lcywgbWUubGVmdC5wcm9wcy5jbGFzc05hbWUsICEhbWUubGVmdC5wcm9wcy5jbGFzc05hbWUpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMsIGNscy5sZWZ0Q2xzLCB0cnVlKSwgX2NsYXNzbmFtZXMpKSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IG1lLmxlZnRTdHlsZSB8fCB7fSxcbiAgICAgICAgICAgICAgICAgICAga2V5OiAnbGVmdCdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInJlbmRlclJpZ2h0XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJSaWdodChjbHMpIHtcbiAgICAgICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoISFtZS5yaWdodCkge1xuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NuYW1lczI7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KG1lLnJpZ2h0LCB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lcygoX2NsYXNzbmFtZXMyID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lczIsIG1lLnJpZ2h0LnByb3BzLmNsYXNzTmFtZSwgISFtZS5yaWdodC5wcm9wcy5jbGFzc05hbWUpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMyLCBjbHMucmlnaHRDbHMsIHRydWUpLCBfY2xhc3NuYW1lczIpKSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IG1lLnJpZ2h0U3R5bGUgfHwge30sXG4gICAgICAgICAgICAgICAgICAgIGtleTogJ3JpZ2h0J1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwicmVuZGVyTGF5b3V0XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJMYXlvdXQoY2xzKSB7XG4gICAgICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgICAgICAgaWYgKG1lLnN1ZmZpeCA9PSAnbGYnKSB7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2gobWUucmVuZGVyUmlnaHQoY2xzKSk7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2gobWUucmVuZGVyTGVmdChjbHMpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2gobWUucmVuZGVyTGVmdChjbHMpKTtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChtZS5yZW5kZXJSaWdodChjbHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJyZW5kZXJcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgICAgIHZhciBfY2xhc3NuYW1lczM7XG5cbiAgICAgICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY2xzID0gbWUucHJvY2Vzc0NoaWxkcmVuKCk7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBjbGFzc25hbWVzKChfY2xhc3NuYW1lczMgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc25hbWVzMywgbWUucHJvcHMuY2xhc3NOYW1lLCAhIW1lLnByb3BzLmNsYXNzTmFtZSksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lczMsIGNscy5sYXlvdXRDbHMsIHRydWUpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMzLCBcImZuLWNsZWFyXCIsIHRydWUpLCBfY2xhc3NuYW1lczMpKSB9LFxuICAgICAgICAgICAgICAgIG1lLnJlbmRlckxheW91dChjbHMpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIExheW91dDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuTGF5b3V0LkxlZnQgPSBMZWZ0O1xuTGF5b3V0LlJpZ2h0ID0gUmlnaHQ7XG5MYXlvdXQuZGlzcGxheU5hbWUgPSBcIkxheW91dFwiO1xuTGF5b3V0LmRlZmF1bHRQcm9wcyA9IHt9O1xuTGF5b3V0LnByb3BUeXBlcyA9IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBMYXlvdXQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1sYXlvdXQvYnVpbGQvTGF5b3V0LmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEl0ZW0gPSByZXF1aXJlKCcuL0xheW91dEl0ZW0nKTtcblxudmFyIExlZnQgPSBmdW5jdGlvbiAoX0l0ZW0pIHtcbiAgICBfaW5oZXJpdHMoTGVmdCwgX0l0ZW0pO1xuXG4gICAgZnVuY3Rpb24gTGVmdChwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGVmdCk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKExlZnQpLmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgICAgICBfdGhpcy5zdGF0ZSA9IHt9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIExlZnQ7XG59KEl0ZW0pO1xuXG5MZWZ0LmRpc3BsYXlOYW1lID0gXCJMZWZ0XCI7XG5MZWZ0LmRlZmF1bHRQcm9wcyA9IEl0ZW0uZGVmYXVsdFByb3BzO1xuTGVmdC5wcm9wVHlwZXMgPSBJdGVtLnByb3BUeXBlcztcbm1vZHVsZS5leHBvcnRzID0gTGVmdDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWxheW91dC9idWlsZC9MZWZ0LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBjbGFzc25hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIExheW91dEl0ZW0gPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhMYXlvdXRJdGVtLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIExheW91dEl0ZW0ocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExheW91dEl0ZW0pO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihMYXlvdXRJdGVtKS5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7fTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhMYXlvdXRJdGVtLCBbe1xuICAgICAgICBrZXk6ICdyZW5kZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHt9O1xuICAgICAgICAgICAgaWYgKCFtZS5wcm9wcy5hZGFwdGl2ZSkge1xuICAgICAgICAgICAgICAgIHN0eWxlLndpZHRoID0gbWUucHJvcHMud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogY2xhc3NuYW1lcyhfZGVmaW5lUHJvcGVydHkoe30sIG1lLnByb3BzLmNsYXNzTmFtZSwgISFtZS5wcm9wcy5jbGFzc05hbWUpKSwgc3R5bGU6IGFzc2lnbih7fSwgc3R5bGUsIG1lLnByb3BzLnN0eWxlKSB9LFxuICAgICAgICAgICAgICAgIG1lLnByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIExheW91dEl0ZW07XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbkxheW91dEl0ZW0uZGlzcGxheU5hbWUgPSBcIkxheW91dEl0ZW1cIjtcbkxheW91dEl0ZW0uZGVmYXVsdFByb3BzID0ge1xuICAgIHdpZHRoOiA1MDBcbn07XG5MYXlvdXRJdGVtLnByb3BUeXBlcyA9IHtcbiAgICB3aWR0aDogUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICBhZGFwdGl2ZTogUmVhY3QuUHJvcFR5cGVzLmJvb2xcbn07XG5tb2R1bGUuZXhwb3J0cyA9IExheW91dEl0ZW07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1sYXlvdXQvYnVpbGQvTGF5b3V0SXRlbS5qc1xuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBJdGVtID0gcmVxdWlyZSgnLi9MYXlvdXRJdGVtJyk7XG5cbnZhciBSaWdodCA9IGZ1bmN0aW9uIChfSXRlbSkge1xuICAgIF9pbmhlcml0cyhSaWdodCwgX0l0ZW0pO1xuXG4gICAgZnVuY3Rpb24gUmlnaHQocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJpZ2h0KTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoUmlnaHQpLmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgICAgICBfdGhpcy5zdGF0ZSA9IHt9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJpZ2h0O1xufShJdGVtKTtcblxuUmlnaHQuZGlzcGxheU5hbWUgPSBcIlJpZ2h0XCI7XG5SaWdodC5kZWZhdWx0UHJvcHMgPSBJdGVtLmRlZmF1bHRQcm9wcztcblJpZ2h0LnByb3BUeXBlcyA9IEl0ZW0ucHJvcFR5cGVzO1xubW9kdWxlLmV4cG9ydHMgPSBSaWdodDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWxheW91dC9idWlsZC9SaWdodC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNZW50aW9uIENvbXBvbmVudCBmb3IgdXhjb3JlXG4gKiBAYXV0aG9yXG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgVXhjb3JlIFRlYW0sIEFsaW53LlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vTWVudGlvbicpO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtbWVudGlvbi9idWlsZC9pbmRleC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JlYWN0RG9tID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBfcmVhY3REb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3REb20pO1xuXG52YXIgX3BhbmVsID0gcmVxdWlyZSgnLi9wYW5lbCcpO1xuXG52YXIgX3BhbmVsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhbmVsKTtcblxudmFyIF9lZGl0b3IgPSByZXF1aXJlKCcuL2VkaXRvcicpO1xuXG52YXIgX2VkaXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lZGl0b3IpO1xuXG52YXIgX2tleWNvZGUgPSByZXF1aXJlKCcuL2tleWNvZGUnKTtcblxudmFyIF91dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGF1dGhvcjogdmluY2VudC5iaWFuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuXG52YXIgX19tYXRjaFRpbWVyID0gdm9pZCAwO1xuXG52YXIgTWVudGlvbiA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzKE1lbnRpb24sIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gTWVudGlvbihwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVudGlvbik7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICAgICAgICBtZW50aW9uTGlzdDogW10sXG4gICAgICAgICAgICBjdXJzb3JQb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhbmVsVmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBwYW5lbElkeDogMFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgTWVudGlvbi5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgICAgIGlmIChwcmV2U3RhdGUubWVudGlvbkxpc3QubGVuZ3RoICE9PSB0aGlzLnN0YXRlLm1lbnRpb25MaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgcGFuZWxWaXNpYmxlOiB0aGlzLnN0YXRlLm1lbnRpb25MaXN0Lmxlbmd0aCA+IDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJldlN0YXRlLnBhbmVsVmlzaWJsZSAmJiB0aGlzLnN0YXRlLnBhbmVsVmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgcGFuZWxJZHg6IDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIE1lbnRpb24ucHJvdG90eXBlLnNlbGVjdEl0ZW0gPSBmdW5jdGlvbiBzZWxlY3RJdGVtKGRhdGEpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgIHQ6IG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWVudGlvbkxpc3Q6IFtdXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBNZW50aW9uLnByb3RvdHlwZS5ydW5NYXRjaGVyID0gZnVuY3Rpb24gcnVuTWF0Y2hlcihzdHIpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgX19tYXRjaFRpbWVyICYmIGNsZWFyVGltZW91dChfX21hdGNoVGltZXIpO1xuICAgICAgICBfX21hdGNoVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMi5fbWF0Y2hlcihzdHIpO1xuICAgICAgICB9LmJpbmQodGhpcyksIHRoaXMucHJvcHMuZGVsYXkpO1xuICAgIH07XG5cbiAgICBNZW50aW9uLnByb3RvdHlwZS5fbWF0Y2hlciA9IGZ1bmN0aW9uIF9tYXRjaGVyKHN0cikge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhgbWF0Y2hlciBydW4gd2l0aDogJHtzdHJ9YCk7XG4gICAgICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgc291cmNlID0gX3Byb3BzLnNvdXJjZTtcbiAgICAgICAgdmFyIG1hdGNoUmFuZ2UgPSBfcHJvcHMubWF0Y2hSYW5nZTtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHBhbmVsVmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBtZW50aW9uTGlzdDogW11cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzdHIubGVuZ3RoID49IG1hdGNoUmFuZ2VbMF0gJiYgc3RyLmxlbmd0aCA8PSBtYXRjaFJhbmdlWzFdKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmV4dChzb3VyY2UuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmluZGV4T2Yoc3RyKSAhPT0gLTE7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzb3VyY2Uoc3RyLCB0aGlzLl9uZXh0LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIE1lbnRpb24ucHJvdG90eXBlLnNldFBhbmVsUG9zID0gZnVuY3Rpb24gc2V0UGFuZWxQb3MocG9zKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSAoMCwgX3V0aWwuZ2V0U2Nyb2xsT2Zmc2V0KSgpO1xuICAgICAgICBwb3MgPSB7XG4gICAgICAgICAgICB4OiBwb3MueCArIG9mZnNldC54LFxuICAgICAgICAgICAgeTogcG9zLnkgKyBvZmZzZXQueVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGN1cnNvclBvc2l0aW9uOiBwb3NcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIE1lbnRpb24ucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gX25leHQobWF0Y2hSZXN1bHQpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZm9ybWF0dGVyKSB7XG4gICAgICAgICAgICBtYXRjaFJlc3VsdCA9IHRoaXMucHJvcHMuZm9ybWF0dGVyKG1hdGNoUmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIG1lbnRpb25MaXN0OiBtYXRjaFJlc3VsdFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgTWVudGlvbi5wcm90b3R5cGUub25LZXl1cCA9IGZ1bmN0aW9uIG9uS2V5dXAoZSkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5wYW5lbFZpc2libGUpIHtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IHRoaXMuc3RhdGUubWVudGlvbkxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgc3dpdGNoIChlLmtleUNvZGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIF9rZXljb2RlLktFWUNPREUuVVA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFuZWxJZHg6IHRoaXMuc3RhdGUucGFuZWxJZHggPT09IDAgPyBjb3VudCAtIDEgOiB0aGlzLnN0YXRlLnBhbmVsSWR4IC0gMVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBfa2V5Y29kZS5LRVlDT0RFLkRPV046XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFuZWxJZHg6IHRoaXMuc3RhdGUucGFuZWxJZHggPT09IGNvdW50IC0gMSA/IDAgOiB0aGlzLnN0YXRlLnBhbmVsSWR4ICsgMVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBfa2V5Y29kZS5LRVlDT0RFLkVOVEVSOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdEl0ZW0odGhpcy5zdGF0ZS5tZW50aW9uTGlzdFt0aGlzLnN0YXRlLnBhbmVsSWR4XSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVudGlvbkxpc3Q6IFtdXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBNZW50aW9uLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBwYW5lbFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgbGVmdDogdGhpcy5zdGF0ZS5jdXJzb3JQb3NpdGlvbi54LFxuICAgICAgICAgICAgdG9wOiB0aGlzLnN0YXRlLmN1cnNvclBvc2l0aW9uLnlcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHdpZHRoID0gcHJvcHMud2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSBwcm9wcy5oZWlnaHQ7XG4gICAgICAgIHZhciBwcmVmaXhDbHMgPSBwcm9wcy5wcmVmaXhDbHM7XG5cbiAgICAgICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHsgb25LZXlVcDogdGhpcy5vbktleXVwLmJpbmQodGhpcykgfSxcbiAgICAgICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgX2VkaXRvcjJbXCJkZWZhdWx0XCJdLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4Q2xzOiBwcmVmaXhDbHMsXG4gICAgICAgICAgICAgICAgICAgIHBhbmVsVmlzaWJsZTogdGhpcy5zdGF0ZS5wYW5lbFZpc2libGUsXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXI6IHRoaXMucnVuTWF0Y2hlci5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICBtZW50aW9uVGFyZ2V0OiB0aGlzLnN0YXRlLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3Vyc29yUG9zOiB0aGlzLnNldFBhbmVsUG9zLmJpbmQodGhpcyksXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogcHJvcHMubWVudGlvbkZvcm1hdHRlcixcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6IHByb3BzLm9uQ2hhbmdlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwcm9wcy5jaGlsZHJlblxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX3BhbmVsMltcImRlZmF1bHRcIl0sIHtcbiAgICAgICAgICAgICAgICBwcmVmaXhDbHM6IHByZWZpeENscyxcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiB0aGlzLnN0YXRlLnBhbmVsVmlzaWJsZSxcbiAgICAgICAgICAgICAgICBpZHg6IHRoaXMuc3RhdGUucGFuZWxJZHgsXG4gICAgICAgICAgICAgICAgbGlzdDogdGhpcy5zdGF0ZS5tZW50aW9uTGlzdCxcbiAgICAgICAgICAgICAgICBvblNlbGVjdDogdGhpcy5zZWxlY3RJdGVtLmJpbmQodGhpcyksXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVyOiBwcm9wcy5wYW5lbEZvcm1hdHRlcixcbiAgICAgICAgICAgICAgICBzdHlsZTogcGFuZWxQb3NpdGlvbiB9KVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gTWVudGlvbjtcbn0oX3JlYWN0MltcImRlZmF1bHRcIl0uQ29tcG9uZW50KTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBNZW50aW9uO1xuXG5NZW50aW9uLmRpc3BsYXlOYW1lID0gJ3V4Y29yZS1tZW50aW9uJztcbk1lbnRpb24ucHJvcFR5cGUgPSB7XG4gICAgcHJlZml4Q2xzOiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHdpZHRoOiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMubnVtYmVyLFxuICAgIGhlaWdodDogX3JlYWN0MltcImRlZmF1bHRcIl0uUHJvcFR5cGVzLm51bWJlcixcbiAgICBzb3VyY2U6IF9yZWFjdDJbXCJkZWZhdWx0XCJdLlByb3BUeXBlcy5vbmVPZlR5cGUoW19yZWFjdDJbXCJkZWZhdWx0XCJdLlByb3BUeXBlcy5hcnJheSwgX3JlYWN0MltcImRlZmF1bHRcIl0uUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBkZWxheTogX3JlYWN0MltcImRlZmF1bHRcIl0uUHJvcFR5cGVzLm51bWJlcixcbiAgICBtYXRjaFJhbmdlOiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMuYXJyYXlPZihfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMubnVtYmVyKSxcbiAgICBmb3JtYXR0ZXI6IF9yZWFjdDJbXCJkZWZhdWx0XCJdLlByb3BUeXBlcy5mdW5jLFxuICAgIHBhbmVsRm9ybWF0dGVyOiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMuZnVuYyxcbiAgICBtZW50aW9uRm9ybWF0dGVyOiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNoYW5nZTogX3JlYWN0MltcImRlZmF1bHRcIl0uUHJvcFR5cGVzLmZ1bmNcbn07XG5NZW50aW9uLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBwcmVmaXhDbHM6ICdrdW1hLW1lbnRpb24nLFxuICAgIHdpZHRoOiAyMDAsXG4gICAgaGVpZ2h0OiAxMDAsXG4gICAgc291cmNlOiBbXSxcbiAgICBkZWxheTogMTAwLFxuICAgIG1hdGNoUmFuZ2U6IFsyLCA4XSxcbiAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uIGZvcm1hdHRlcihkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG4gICAgcGFuZWxGb3JtYXR0ZXI6IGZ1bmN0aW9uIHBhbmVsRm9ybWF0dGVyKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuICcnICsgZGF0YS50ZXh0O1xuICAgIH0sXG4gICAgbWVudGlvbkZvcm1hdHRlcjogZnVuY3Rpb24gbWVudGlvbkZvcm1hdHRlcihkYXRhKSB7XG4gICAgICAgIHJldHVybiAnQCcgKyBkYXRhLnRleHQ7XG4gICAgfSxcbiAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoZSwgdmFsdWUpIHt9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1tZW50aW9uL2J1aWxkL01lbnRpb24uanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9jbGFzc25hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xuXG52YXIgX2NsYXNzbmFtZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NuYW1lcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBQYW5lbCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG5cdF9pbmhlcml0cyhQYW5lbCwgX1JlYWN0JENvbXBvbmVudCk7XG5cblx0ZnVuY3Rpb24gUGFuZWwocHJvcHMpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGFuZWwpO1xuXG5cdFx0cmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuXHR9XG5cblx0UGFuZWwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcblx0XHR2YXIgX3RoaXMyID0gdGhpcztcblxuXHRcdHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG5cdFx0dmFyIG9uU2VsZWN0ID0gcHJvcHMub25TZWxlY3Q7XG5cdFx0dmFyIGxpc3QgPSBwcm9wcy5saXN0O1xuXHRcdHZhciBzdHlsZSA9IHByb3BzLnN0eWxlO1xuXHRcdHZhciB2aXNpYmxlID0gcHJvcHMudmlzaWJsZTtcblx0XHR2YXIgaWR4ID0gcHJvcHMuaWR4O1xuXHRcdHZhciBmb3JtYXR0ZXIgPSBwcm9wcy5mb3JtYXR0ZXI7XG5cdFx0dmFyIHByZWZpeENscyA9IHByb3BzLnByZWZpeENscztcblxuXHRcdHZhciBjbHNPYmogPSB7fTtcblx0XHRjbHNPYmpbcHJlZml4Q2xzICsgJy1wYW5lbCddID0gdHJ1ZTtcblx0XHRjbHNPYmpbcHJlZml4Q2xzICsgJy1wYW5lbC12aXNpYmxlJ10gPSB2aXNpYmxlO1xuXHRcdHZhciBjbHMgPSAoMCwgX2NsYXNzbmFtZXMyW1wiZGVmYXVsdFwiXSkoY2xzT2JqKTtcblx0XHRyZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcblx0XHRcdCd1bCcsXG5cdFx0XHR7IGNsYXNzTmFtZTogY2xzLCBzdHlsZTogc3R5bGUgfSxcblx0XHRcdGxpc3QubWFwKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuXHRcdFx0XHR2YXIgaXRlbUNsc09iaiA9IHt9O1xuXHRcdFx0XHRpdGVtQ2xzT2JqW3ByZWZpeENscyArICctcGFuZWwtaXRlbSddID0gdHJ1ZTtcblx0XHRcdFx0aXRlbUNsc09ialtwcmVmaXhDbHMgKyAnLXBhbmVsLWl0ZW0tY3VycmVudCddID0gaWR4ID09PSBpbmRleDtcblx0XHRcdFx0dmFyIGl0ZW1DbHMgPSAoMCwgX2NsYXNzbmFtZXMyW1wiZGVmYXVsdFwiXSkoaXRlbUNsc09iaik7XG5cdFx0XHRcdHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuXHRcdFx0XHRcdCdsaScsXG5cdFx0XHRcdFx0eyBjbGFzc05hbWU6IGl0ZW1DbHMsIGtleTogaW5kZXgsIG9uQ2xpY2s6IG9uU2VsZWN0LmJpbmQoX3RoaXMyLCBpdGVtKSB9LFxuXHRcdFx0XHRcdF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoJ2RpdicsIHsgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHsgX19odG1sOiBmb3JtYXR0ZXIoaXRlbSkgfSB9KVxuXHRcdFx0XHQpO1xuXHRcdFx0fSlcblx0XHQpO1xuXHR9O1xuXG5cdHJldHVybiBQYW5lbDtcbn0oX3JlYWN0MltcImRlZmF1bHRcIl0uQ29tcG9uZW50KTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBQYW5lbDtcblxuUGFuZWwuZGlzcGxheU5hbWUgPSAndXhjb3JlLW1lbnRpb24tcGFuZWwnO1xuUGFuZWwucHJvcFR5cGUgPSB7XG5cdHByZWZpeENsczogX3JlYWN0MltcImRlZmF1bHRcIl0uUHJvcFR5cGVzLnN0cmluZyxcblx0bGlzdDogX3JlYWN0MltcImRlZmF1bHRcIl0uUHJvcFR5cGVzLmFycmF5LFxuXHRzdHlsZTogX3JlYWN0MltcImRlZmF1bHRcIl0uUHJvcFR5cGVzLm9iamVjdCxcblx0aWR4OiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMubnVtYmVyLFxuXHRvblNlbGVjdDogX3JlYWN0MltcImRlZmF1bHRcIl0uUHJvcFR5cGVzLmZ1bmMsXG5cdGZvcm1hdHRlcjogX3JlYWN0MltcImRlZmF1bHRcIl0uUHJvcFR5cGVzLmZ1bmNcbn07XG5QYW5lbC5kZWZhdWx0UHJvcHMgPSB7XG5cdHByZWZpeENsczogJycsXG5cdGxpc3Q6IFtdLFxuXHRzdHlsZToge30sXG5cdGlkeDogMCxcblx0b25TZWxlY3Q6IG51bGwsXG5cdGZvcm1hdHRlcjogJydcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLW1lbnRpb24vYnVpbGQvcGFuZWwuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxucmVxdWlyZSgnLi9yYW5neS1wb3NpdGlvbicpO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIF9rZXljb2RlID0gcmVxdWlyZSgnLi9rZXljb2RlJyk7XG5cbnZhciBfY2xhc3NuYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcblxudmFyIF9jbGFzc25hbWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzbmFtZXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuLy8gaW1wb3J0IHJhbmd5IGZyb20gJ3Jhbmd5JztcblxuXG52YXIgX19zdG9yZSA9IHt9O1xuLy93ZWJraXQgYnJvd3NlcnMgc3VwcG9ydCAncGxhaW50ZXh0LW9ubHknXG52YXIgY29udGVudEVkaXRhYmxlVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScsICdQTEFJTlRFWFQtT05MWScpO1xuICAgIHJldHVybiBkaXYuY29udGVudEVkaXRhYmxlID09PSAncGxhaW50ZXh0LW9ubHknID8gJ3BsYWludGV4dC1vbmx5JyA6IHRydWU7XG59KCk7XG5cbnZhciBFZGl0b3IgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhFZGl0b3IsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gRWRpdG9yKHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFZGl0b3IpO1xuXG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpKTtcbiAgICB9XG5cbiAgICBFZGl0b3IucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIC8vIGxldCBlZGl0b3IgPSB0aGlzLnJlZnMuZWRpdG9yO1xuICAgIH07XG5cbiAgICBFZGl0b3IucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICBpZiAobmV4dFByb3BzLm1lbnRpb25UYXJnZXQgJiYgKCF0aGlzLnByb3BzLm1lbnRpb25UYXJnZXQgfHwgdGhpcy5wcm9wcy5tZW50aW9uVGFyZ2V0LnQgIT09IG5leHRQcm9wcy5tZW50aW9uVGFyZ2V0LnQpKSB7XG4gICAgICAgICAgICB0aGlzLmluc2VydE1lbnRpb25UYXJnZXQobmV4dFByb3BzLm1lbnRpb25UYXJnZXQuZGF0YSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgRWRpdG9yLnByb3RvdHlwZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbiBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuY2hpbGRyZW4gIT09IG5leHRQcm9wcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBFZGl0b3IucHJvdG90eXBlLm9uS2V5ZG93biA9IGZ1bmN0aW9uIG9uS2V5ZG93bihlKSB7XG4gICAgICAgIHN3aXRjaCAoZS5rZXlDb2RlKSB7XG4gICAgICAgICAgICBjYXNlIF9rZXljb2RlLktFWUNPREUuVVA6XG4gICAgICAgICAgICBjYXNlIF9rZXljb2RlLktFWUNPREUuRE9XTjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5wYW5lbFZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgX2tleWNvZGUuS0VZQ09ERS5FTlRFUjpcbiAgICAgICAgICAgICAgICAvLyBpbnNlcnQgYnIgYXQgdGhlIGVuZCBvZiBsaW5lXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5wcm9wcy5wYW5lbFZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMucmVmcy5lZGl0b3I7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWwgPSByYW5neS5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gc2VsLmdldFJhbmdlQXQoMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGVkaXRvciBpcyBiclxuICAgICAgICAgICAgICAgICAgICAvLyByZWZlciB0bzogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82MDIzMzA3L2RlYWxpbmctd2l0aC1saW5lLWJyZWFrcy1vbi1jb250ZW50ZWRpdGFibGUtZGl2XG4gICAgICAgICAgICAgICAgICAgIGlmICghZWRpdG9yLmxhc3RDaGlsZCB8fCBlZGl0b3IubGFzdENoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdicicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdicicpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZUJyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnInKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UuZGVsZXRlQ29udGVudHMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UuaW5zZXJ0Tm9kZShub2RlQnIpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydEFmdGVyKG5vZGVCcik7XG4gICAgICAgICAgICAgICAgICAgIHNlbC5zZXRTaW5nbGVSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gICAgIHRoaXMucHJvcHMub25DaGFuZ2UoJ3h4eCcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEVkaXRvci5wcm90b3R5cGUub25LZXl1cCA9IGZ1bmN0aW9uIG9uS2V5dXAoZSkge1xuICAgICAgICAvLyBpZiAodGhpcy5wcm9wcy5wYW5lbFZpc2libGUpIHtyZXR1cm47fVxuICAgICAgICBzd2l0Y2ggKGUua2V5Q29kZSkge1xuICAgICAgICAgICAgY2FzZSBfa2V5Y29kZS5LRVlDT0RFLlVQOlxuICAgICAgICAgICAgY2FzZSBfa2V5Y29kZS5LRVlDT0RFLkRPV046XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMucGFuZWxWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIF9rZXljb2RlLktFWUNPREUuRU5URVI6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHZhciBzZWwgPSByYW5neS5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBzZWwuZ2V0UmFuZ2VBdCgwKTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXIubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQocmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXIsIDApO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luU3RyID0gcmFuZ2UudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ciA9ICgwLCBfdXRpbC5wYXJzZVN0ckJ5RGVsaW1pdGVyKShvcmlnaW5TdHIsICdAJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNlbmQgc3RyIHRvIG1hdGNoZXJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5tYXRjaGVyKHN0cik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuc2V0Q3Vyc29yUG9zKHJhbmdlLmdldEVuZENsaWVudFBvcygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldCByYW5nZSdzIHN0YXJ0IHBvc2l0aW9uIGJlZm9yZSBkZWxpbWl0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyLCBvcmlnaW5TdHIubGVuZ3RoIC0gc3RyLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSByYW5nZSBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgX19zdG9yZS5ib29rbWFyayA9IHJhbmdlLmdldEJvb2ttYXJrKHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBFZGl0b3IucHJvdG90eXBlLmluc2VydE1lbnRpb25UYXJnZXQgPSBmdW5jdGlvbiBpbnNlcnRNZW50aW9uVGFyZ2V0KG1lbnRpb25EYXRhKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKG1lbnRpb25EYXRhKTtcbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMucmVmcy5lZGl0b3I7XG4gICAgICAgIHZhciBzZWwgPSByYW5neS5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgdmFyIGZvcm1hdHRlciA9IHRoaXMucHJvcHMuZm9ybWF0dGVyO1xuICAgICAgICBpZiAoX19zdG9yZS5ib29rbWFyaykge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gc2VsLmdldFJhbmdlQXQoMCk7XG4gICAgICAgICAgICByYW5nZS5tb3ZlVG9Cb29rbWFyayhfX3N0b3JlLmJvb2ttYXJrKTtcbiAgICAgICAgICAgIHZhciBtZW50aW9uTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgICAgICBtZW50aW9uTm9kZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnYnV0dG9uJyk7XG4gICAgICAgICAgICBtZW50aW9uTm9kZS5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgICAgICAgICBtZW50aW9uTm9kZS5jbGFzc05hbWUgPSB0aGlzLnByb3BzLnByZWZpeENscyArICctbm9kZSc7XG4gICAgICAgICAgICBtZW50aW9uTm9kZS52YWx1ZSA9IGZvcm1hdHRlcihtZW50aW9uRGF0YSk7XG4gICAgICAgICAgICAvLyBkZWxldGUgb3JpZ2luIGNvbnRlbnQgaW4gcmFuZ2VcbiAgICAgICAgICAgIHJhbmdlLmRlbGV0ZUNvbnRlbnRzKCk7XG4gICAgICAgICAgICByYW5nZS5pbnNlcnROb2RlKG1lbnRpb25Ob2RlKTtcbiAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlQWZ0ZXIobWVudGlvbk5vZGUpO1xuICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBlZGl0b3IuZm9jdXMoKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEVkaXRvci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICB2YXIgc3R5bGUgPSB7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy5wcm9wcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5wcm9wcy5oZWlnaHRcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9ICgwLCBfY2xhc3NuYW1lczJbXCJkZWZhdWx0XCJdKSh0aGlzLnByb3BzLnByZWZpeENscywgdGhpcy5wcm9wcy5wcmVmaXhDbHMgKyAnLWVkaXRvcicpO1xuICAgICAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6IGNsYXNzTmFtZSwgcmVmOiAnZWRpdG9yJyxcbiAgICAgICAgICAgICAgICBvbktleVVwOiB0aGlzLm9uS2V5dXAuYmluZCh0aGlzKSxcbiAgICAgICAgICAgICAgICBvbktleURvd246IHRoaXMub25LZXlkb3duLmJpbmQodGhpcyksXG4gICAgICAgICAgICAgICAgY29udGVudEVkaXRhYmxlOiBjb250ZW50RWRpdGFibGVWYWx1ZSxcbiAgICAgICAgICAgICAgICBvbklucHV0OiB0aGlzLmVtaXRDaGFuZ2UuYmluZCh0aGlzKSxcbiAgICAgICAgICAgICAgICBvbkJsdXI6IHRoaXMuZW1pdENoYW5nZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBzdHlsZSB9LFxuICAgICAgICAgICAgdGhpcy5wcm9wcy5jaGlsZHJlblxuICAgICAgICApO1xuICAgIH07XG5cbiAgICBFZGl0b3IucHJvdG90eXBlLmVtaXRDaGFuZ2UgPSBmdW5jdGlvbiBlbWl0Q2hhbmdlKGUpIHtcbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMucmVmcy5lZGl0b3I7XG4gICAgICAgIHZhciBub2RlcyA9IGVkaXRvci5jaGlsZE5vZGVzO1xuICAgICAgICB2YXIgY29udGVudCA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbm9kZXMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChub2Rlc1tpXS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHZhciB0YWdOYW1lID0gbm9kZXNbaV0udGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGlmICh0YWdOYW1lID09PSAnaW5wdXQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gJyAnICsgbm9kZXNbaV0udmFsdWUgKyAnICc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0YWdOYW1lID09PSAnYnInKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChub2Rlc1tpXS5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gbm9kZXNbaV0udGV4dENvbnRlbnQgfHwgbm9kZXNbaV0ubm9kZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UoZSwgY29udGVudCk7XG4gICAgfTtcblxuICAgIHJldHVybiBFZGl0b3I7XG59KF9yZWFjdDJbXCJkZWZhdWx0XCJdLkNvbXBvbmVudCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gRWRpdG9yO1xuXG5FZGl0b3IuZGlzcGxheU5hbWUgPSAndXhjb3JlLW1lbnRpb24tZWRpdG9yJztcbkVkaXRvci5wcm9wVHlwZSA9IHtcbiAgICBwcmVmaXhDbHM6IF9yZWFjdDJbXCJkZWZhdWx0XCJdLlByb3BUeXBlcy5zdHJpbmcsXG4gICAgd2lkdGg6IF9yZWFjdDJbXCJkZWZhdWx0XCJdLlByb3BUeXBlcy5udW1iZXIsXG4gICAgaGVpZ2h0OiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMubnVtYmVyLFxuICAgIG1lbnRpb25UYXJnZXQ6IF9yZWFjdDJbXCJkZWZhdWx0XCJdLlByb3BUeXBlcy5vYmplY3QsXG4gICAgbWF0Y2hlcjogX3JlYWN0MltcImRlZmF1bHRcIl0uUHJvcFR5cGVzLmZ1bmMsXG4gICAgc2V0Q3Vyc29yUG9zOiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMuZnVuYyxcbiAgICBwYW5lbFZpc2libGU6IF9yZWFjdDJbXCJkZWZhdWx0XCJdLlByb3BUeXBlcy5ib29sLFxuICAgIGZvcm1hdHRlcjogX3JlYWN0MltcImRlZmF1bHRcIl0uUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25DaGFuZ2U6IF9yZWFjdDJbXCJkZWZhdWx0XCJdLlByb3BUeXBlcy5mdW5jXG59O1xuRWRpdG9yLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBwcmVmaXhDbHM6ICcnLFxuICAgIHdpZHRoOiAyMDAsXG4gICAgaGVpZ2h0OiAxMDAsXG4gICAgbWVudGlvblRhcmdldDogbnVsbCxcbiAgICBtYXRjaGVyOiBmdW5jdGlvbiBtYXRjaGVyKCkge30sXG4gICAgc2V0Q3Vyc29yUG9zOiBmdW5jdGlvbiBzZXRDdXJzb3JQb3MoKSB7fSxcbiAgICBwYW5lbFZpc2libGU6IGZhbHNlLFxuICAgIGZvcm1hdHRlcjogZnVuY3Rpb24gZm9ybWF0dGVyKCkge30sXG4gICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKCkge31cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLW1lbnRpb24vYnVpbGQvZWRpdG9yLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG4vKipcbiAqIFBvc2l0aW9uIG1vZHVsZSBmb3IgUmFuZ3kuXG4gKiBFeHRlbnNpb25zIHRvIFJhbmdlIGFuZCBTZWxlY3Rpb24gb2JqZWN0cyB0byBwcm92aWRlIGFjY2VzcyB0byBwaXhlbCBwb3NpdGlvbnMgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0IG9yIGRvY3VtZW50LlxuICpcbiAqIFBhcnQgb2YgUmFuZ3ksIGEgY3Jvc3MtYnJvd3NlciBKYXZhU2NyaXB0IHJhbmdlIGFuZCBzZWxlY3Rpb24gbGlicmFyeVxuICogaHR0cHM6Ly9naXRodWIuY29tL3RpbWRvd24vcmFuZ3lcbiAqXG4gKiBEZXBlbmRzIG9uIFJhbmd5IGNvcmUuXG4gKlxuICogQ29weXJpZ2h0ICUlYnVpbGQ6eWVhciUlLCBUaW0gRG93blxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogVmVyc2lvbjogJSVidWlsZDp2ZXJzaW9uJSVcbiAqIEJ1aWxkIGRhdGU6ICUlYnVpbGQ6ZGF0ZSUlXG4gKi9cbi8vIGltcG9ydCByYW5neSBmcm9tICdyYW5neSc7XG5pZiAodHlwZW9mIHJhbmd5ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJhbmd5LmNyZWF0ZU1vZHVsZShcIlBvc2l0aW9uXCIsIFtcIldyYXBwZWRTZWxlY3Rpb25cIl0sIGZ1bmN0aW9uIChhcGksIG1vZHVsZSkge1xuICAgICAgICAvL3ZhciBsb2cgPSBsb2c0amF2YXNjcmlwdC5nZXRMb2dnZXIoXCJyYW5neS5wb3NpdGlvblwiKTtcblxuICAgICAgICB2YXIgTlVNQkVSID0gXCJudW1iZXJcIixcbiAgICAgICAgICAgIFVOREVGID0gXCJ1bmRlZmluZWRcIjtcbiAgICAgICAgdmFyIFdyYXBwZWRSYW5nZSA9IGFwaS5XcmFwcGVkUmFuZ2U7XG4gICAgICAgIHZhciBXcmFwcGVkVGV4dFJhbmdlID0gYXBpLldyYXBwZWRUZXh0UmFuZ2U7XG4gICAgICAgIHZhciBkb20gPSBhcGkuZG9tLFxuICAgICAgICAgICAgdXRpbCA9IGFwaS51dGlsLFxuICAgICAgICAgICAgRG9tUG9zaXRpb24gPSBkb20uRG9tUG9zaXRpb247XG5cbiAgICAgICAgLy8gRmVhdHVyZSBkZXRlY3Rpb25cblxuICAgICAgICAvL3ZhciBjYXJldFBvc2l0aW9uRnJvbVBvaW50U3VwcG9ydGVkID0gKHR5cGVvZiBkb2N1bWVudC5jYXJldFBvc2l0aW9uRnJvbVBvaW50ICE9IFVOREVGKTtcblxuICAgICAgICAvLyBTaW5jZSBSYW5neSBjYW4gZGVhbCB3aXRoIG11bHRpcGxlIGRvY3VtZW50cyB3aGljaCBjb3VsZCBiZSBpbiBkaWZmZXJlbnQgbW9kZXMsIHdlIGhhdmUgdG8gZG8gdGhlIGNoZWNrcyBldmVyeVxuICAgICAgICAvLyB0aW1lLCB1bmxlc3Mgd2UgY2FjaGUgYSBnZXRTY3JvbGxQb3NpdGlvbiBmdW5jdGlvbiBpbiBlYWNoIGRvY3VtZW50LiBUaGlzIHdvdWxkIG5lY2Vzc2FyaWx5IHBvbGx1dGUgdGhlXG4gICAgICAgIC8vIGRvY3VtZW50J3MgZ2xvYmFsIG5hbWVzcGFjZSwgd2hpY2ggSSdtIGNob29zaW5nIHRvIHZpZXcgYXMgYSBncmVhdGVyIGV2aWwgdGhhbiBhIHNsaWdodCBwZXJmb3JtYW5jZSBoaXQuXG4gICAgICAgIGZ1bmN0aW9uIGdldFNjcm9sbFBvc2l0aW9uKHdpbikge1xuICAgICAgICAgICAgdmFyIHggPSAwLFxuICAgICAgICAgICAgICAgIHkgPSAwO1xuICAgICAgICAgICAgaWYgKF90eXBlb2Yod2luLnBhZ2VYT2Zmc2V0KSA9PSBOVU1CRVIgJiYgX3R5cGVvZih3aW4ucGFnZVlPZmZzZXQpID09IE5VTUJFUikge1xuICAgICAgICAgICAgICAgIHggPSB3aW4ucGFnZVhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgeSA9IHdpbi5wYWdlWU9mZnNldDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvYyA9IHdpbi5kb2N1bWVudDtcbiAgICAgICAgICAgICAgICB2YXIgZG9jRWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgIHZhciBjb21wYXRNb2RlID0gZG9jLmNvbXBhdE1vZGU7XG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbEVsID0gdHlwZW9mIGNvbXBhdE1vZGUgPT0gXCJzdHJpbmdcIiAmJiBjb21wYXRNb2RlLmluZGV4T2YoXCJDU1NcIikgPj0gMCAmJiBkb2NFbCA/IGRvY0VsIDogZG9tLmdldEJvZHkoZG9jKTtcblxuICAgICAgICAgICAgICAgIGlmIChzY3JvbGxFbCAmJiBfdHlwZW9mKHNjcm9sbEVsLnNjcm9sbExlZnQpID09IE5VTUJFUiAmJiBfdHlwZW9mKHNjcm9sbEVsLnNjcm9sbFRvcCkgPT0gTlVNQkVSKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gc2Nyb2xsRWwuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBzY3JvbGxFbC5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7fVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEFuY2VzdG9yRWxlbWVudChub2RlLCB0YWdOYW1lKSB7XG4gICAgICAgICAgICB0YWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09IHRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIFJlY3QodG9wLCByaWdodCwgYm90dG9tLCBsZWZ0KSB7XG4gICAgICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAgICAgICAgIHRoaXMuYm90dG9tID0gYm90dG9tO1xuICAgICAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVJlbGF0aXZlUmVjdChyZWN0LCBkeCwgZHkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVjdChyZWN0LnRvcCArIGR5LCByZWN0LnJpZ2h0ICsgZHgsIHJlY3QuYm90dG9tICsgZHksIHJlY3QubGVmdCArIGR4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFkanVzdENsaWVudFJlY3QocmVjdCwgZG9jKSB7XG4gICAgICAgICAgICAvLyBPbGRlciBJRXMgaGF2ZSBhbiBpc3N1ZSB3aXRoIGEgdHdvIHBpeGVsIG1hcmdpbiBvbiB0aGUgYm9keSBlbGVtZW50XG4gICAgICAgICAgICB2YXIgZHggPSAwLFxuICAgICAgICAgICAgICAgIGR5ID0gMDtcbiAgICAgICAgICAgIHZhciBkb2NFbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgYm9keSA9IGRvbS5nZXRCb2R5KGRvYyk7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jRWwuY2xpZW50V2lkdGggPT09IDAgJiYgX3R5cGVvZihib2R5LmNsaWVudFRvcCkgPT0gTlVNQkVSID8gYm9keSA6IGRvY0VsO1xuICAgICAgICAgICAgdmFyIGNsaWVudExlZnQgPSBjb250YWluZXIuY2xpZW50TGVmdCxcbiAgICAgICAgICAgICAgICBjbGllbnRUb3AgPSBjb250YWluZXIuY2xpZW50VG9wO1xuICAgICAgICAgICAgaWYgKGNsaWVudExlZnQpIHtcbiAgICAgICAgICAgICAgICBkeCA9IC1jbGllbnRMZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNsaWVudFRvcCkge1xuICAgICAgICAgICAgICAgIGR5ID0gLWNsaWVudFRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVSZWxhdGl2ZVJlY3QocmVjdCwgZHgsIGR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1lcmdlUmVjdHMocmVjdHMpIHtcbiAgICAgICAgICAgIHZhciB0b3BzID0gW10sXG4gICAgICAgICAgICAgICAgYm90dG9tcyA9IFtdLFxuICAgICAgICAgICAgICAgIGxlZnRzID0gW10sXG4gICAgICAgICAgICAgICAgcmlnaHRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcmVjdHMubGVuZ3RoLCByZWN0OyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICByZWN0ID0gcmVjdHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9wcy5wdXNoKHJlY3QudG9wKTtcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tcy5wdXNoKHJlY3QuYm90dG9tKTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdHMucHVzaChyZWN0LmxlZnQpO1xuICAgICAgICAgICAgICAgICAgICByaWdodHMucHVzaChyZWN0LnJpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlY3QoTWF0aC5taW4uYXBwbHkoTWF0aCwgdG9wcyksIE1hdGgubWF4LmFwcGx5KE1hdGgsIHJpZ2h0cyksIE1hdGgubWF4LmFwcGx5KE1hdGgsIGJvdHRvbXMpLCBNYXRoLm1pbi5hcHBseShNYXRoLCBsZWZ0cykpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0VGV4dFJhbmdlUG9zaXRpb24oZG9jLCB4LCB5KSB7XG4gICAgICAgICAgICB2YXIgdGV4dFJhbmdlID0gZG9tLmdldEJvZHkoZG9jKS5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgICAgIHRleHRSYW5nZS5tb3ZlVG9Qb2ludCh4LCB5KTtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IG5ldyBhcGkuV3JhcHBlZFRleHRSYW5nZSh0ZXh0UmFuZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEb21Qb3NpdGlvbihyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2FyZXRQb3NpdGlvbkZyb21Qb2ludChkb2MsIHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSBkb2MuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCh4LCB5KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRG9tUG9zaXRpb24ocG9zLm9mZnNldE5vZGUsIHBvcy5vZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2FyZXRSYW5nZUZyb21Qb2ludChkb2MsIHgsIHkpIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGRvYy5jYXJldFJhbmdlRnJvbVBvaW50KHgsIHkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEb21Qb3NpdGlvbihyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0TGFzdFJhbmdlUmVjdChyYW5nZSkge1xuICAgICAgICAgICAgdmFyIHJlY3RzID0gKHJhbmdlLm5hdGl2ZVJhbmdlIHx8IHJhbmdlKS5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICAgICAgcmV0dXJuIHJlY3RzLmxlbmd0aCA+IDAgPyByZWN0c1tyZWN0cy5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwb2ludElzSW5PckFib3ZlUmVjdCh4LCB5LCByZWN0KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInBvaW50SXNJbk9yQWJvdmVSZWN0XCIsIHgsIHksIE1hdGguZmxvb3IocmVjdC50b3ApLCBNYXRoLmZsb29yKHJlY3QucmlnaHQpLCBNYXRoLmZsb29yKHJlY3QuYm90dG9tKSwgTWF0aC5mbG9vcihyZWN0LmxlZnQpKTtcbiAgICAgICAgICAgIHJldHVybiB5IDwgcmVjdC5ib3R0b20gJiYgeCA+PSByZWN0LmxlZnQgJiYgeCA8PSByZWN0LnJpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcG9zaXRpb25Gcm9tUG9pbnQoZG9jLCB4LCB5LCBmYXZvdXJQcmVjZWRpbmdQb3NpdGlvbikge1xuICAgICAgICAgICAgdmFyIGVsID0gZG9jLmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZWxlbWVudEZyb21Qb2ludCBpcyBcIiwgZWwpO1xuXG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBhcGkuY3JlYXRlUmFuZ2UoZG9jKTtcbiAgICAgICAgICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhlbCk7XG4gICAgICAgICAgICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcblxuICAgICAgICAgICAgdmFyIG5vZGUgPSBlbC5maXJzdENoaWxkLFxuICAgICAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICAgICAgICByZWN0LFxuICAgICAgICAgICAgICAgIHRleHRMZW47XG5cbiAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IGRvbS5nZXROb2RlSW5kZXgoZWwpO1xuICAgICAgICAgICAgICAgIGlmICghZmF2b3VyUHJlY2VkaW5nUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgKytvZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTZWFyY2ggdGhyb3VnaCB0aGUgdGV4dCBub2RlIGNoaWxkcmVuIG9mIGVsXG4gICAgICAgICAgICAgICAgbWFpbjogd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdvIHRocm91Z2ggdGhlIHRleHQgbm9kZSBjaGFyYWN0ZXIgYnkgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKG9mZnNldCA9IDAsIHRleHRMZW4gPSBub2RlLmxlbmd0aDsgb2Zmc2V0IDw9IHRleHRMZW47ICsrb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdCA9IGdldExhc3RSYW5nZVJlY3QocmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWN0ICYmIHBvaW50SXNJbk9yQWJvdmVSZWN0KHgsIHksIHJlY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIGdvbmUgcGFzdCB0aGUgcG9pbnQuIE5vdyB3ZSBjaGVjayB3aGljaCBzaWRlIChsZWZ0IG9yIHJpZ2h0KSBvZiB0aGUgY2hhcmFjdGVyIHRoZSBwb2ludCBpcyBuZWFyZXIgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY3QucmlnaHQgLSB4ID4geCAtIHJlY3QubGVmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1vZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgbWFpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZEFmdGVyKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdCA9IGdldExhc3RSYW5nZVJlY3QocmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY3QgJiYgcG9pbnRJc0luT3JBYm92ZVJlY3QoeCwgeSwgcmVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBkb20uZ2V0Tm9kZUluZGV4KG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmF2b3VyUHJlY2VkaW5nUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKytvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gZWw7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IGVsLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEb21Qb3NpdGlvbihub2RlLCBvZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlQ2FyZXRQb3NpdGlvbkZyb21Qb2ludEdldHRlcihkb2MpIHtcbiAgICAgICAgICAgIGlmIChhcGkuZmVhdHVyZXMuaW1wbGVtZW50c1RleHRSYW5nZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRUZXh0UmFuZ2VQb3NpdGlvbjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihkb2MuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCkgIT0gVU5ERUYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FyZXRQb3NpdGlvbkZyb21Qb2ludDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihkb2MuY2FyZXRSYW5nZUZyb21Qb2ludCkgIT0gVU5ERUYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FyZXRSYW5nZUZyb21Qb2ludDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihkb2MuZWxlbWVudEZyb21Qb2ludCkgIT0gVU5ERUYgJiYgcmFuZ2VTdXBwb3J0c0dldENsaWVudFJlY3RzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uRnJvbVBvaW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBtb2R1bGUuY3JlYXRlRXJyb3IoXCJjcmVhdGVDYXJldFBvc2l0aW9uRnJvbVBvaW50R2V0dGVyKCk6IEJyb3dzZXIgZG9lcyBub3QgcHJvdmlkZSBhIHJlY29nbmlzZWQgbWV0aG9kIHRvIGNyZWF0ZSBhIHNlbGVjdGlvbiBmcm9tIHBpeGVsIGNvb3JkaW5hdGVzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlUmFuZ2VGcm9tUG9pbnRzKHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZLCBkb2MpIHtcbiAgICAgICAgICAgIGRvYyA9IGRvbS5nZXRDb250ZW50RG9jdW1lbnQoZG9jLCBtb2R1bGUsIFwiY3JlYXRlUmFuZ2VGcm9tUG9pbnRzXCIpO1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uRmluZGVyID0gY3JlYXRlQ2FyZXRQb3NpdGlvbkZyb21Qb2ludEdldHRlcihkb2MpO1xuICAgICAgICAgICAgdmFyIHN0YXJ0UG9zID0gcG9zaXRpb25GaW5kZXIoZG9jLCBzdGFydFgsIHN0YXJ0WSwgZmFsc2UpO1xuICAgICAgICAgICAgdmFyIGVuZFBvcyA9IHBvc2l0aW9uRmluZGVyKGRvYywgZW5kWCwgZW5kWSwgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhzdGFydFBvcy5ub2RlLCBzdGFydFBvcy5vZmZzZXQsIGVuZFBvcy5ub2RlLCBlbmRQb3Mub2Zmc2V0KTtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGFwaS5jcmVhdGVSYW5nZShkb2MpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnRBbmRFbmQoc3RhcnRQb3Mubm9kZSwgc3RhcnRQb3Mub2Zmc2V0LCBlbmRQb3Mubm9kZSwgZW5kUG9zLm9mZnNldCk7XG4gICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtb3ZlU2VsZWN0aW9uVG9Qb2ludHMoYW5jaG9yWCwgYW5jaG9yWSwgZm9jdXNYLCBmb2N1c1ksIGRvYykge1xuICAgICAgICAgICAgdmFyIHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZO1xuXG4gICAgICAgICAgICAvLyBEZXRlY3QgYmFja3dhcmQgc2VsZWN0aW9uIGZvciBjb29yZGluYXRlcyBhbmQgZmxpcCBzdGFydCBhbmQgZW5kIGNvb3JkaW5hdGVzIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgdmFyIGJhY2t3YXJkID0gZm9jdXNZIDwgYW5jaG9yWSB8fCBhbmNob3JZID09IGZvY3VzWSAmJiBmb2N1c1ggPCBhbmNob3JYO1xuXG4gICAgICAgICAgICBpZiAoYmFja3dhcmQpIHtcbiAgICAgICAgICAgICAgICBzdGFydFggPSBmb2N1c1g7XG4gICAgICAgICAgICAgICAgc3RhcnRZID0gZm9jdXNZO1xuICAgICAgICAgICAgICAgIGVuZFggPSBhbmNob3JYO1xuICAgICAgICAgICAgICAgIGVuZFkgPSBhbmNob3JZO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFydFggPSBhbmNob3JYO1xuICAgICAgICAgICAgICAgIHN0YXJ0WSA9IGFuY2hvclk7XG4gICAgICAgICAgICAgICAgZW5kWCA9IGZvY3VzWDtcbiAgICAgICAgICAgICAgICBlbmRZID0gZm9jdXNZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2VsID0gcmFuZ3kuZ2V0U2VsZWN0aW9uKGRvYyk7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBjcmVhdGVSYW5nZUZyb21Qb2ludHMoc3RhcnRYLCBzdGFydFksIGVuZFgsIGVuZFksIGRvYyk7XG4gICAgICAgICAgICBzZWwuc2V0U2luZ2xlUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIHNlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRlc3QgdGhhdCA8c3Bhbj4gZWxlbWVudHMgc3VwcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAgICAgICAgdmFyIHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgdmFyIGVsZW1lbnRTdXBwb3J0c0dldEJvdW5kaW5nQ2xpZW50UmVjdCA9IHV0aWwuaXNIb3N0TWV0aG9kKHNwYW4sIFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCIpO1xuICAgICAgICBzcGFuID0gbnVsbDtcblxuICAgICAgICAvLyBUZXN0IGZvciBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgc3VwcG9ydCBpbiBSYW5nZVxuICAgICAgICB2YXIgcmFuZ2VTdXBwb3J0c0dldENsaWVudFJlY3RzID0gZmFsc2UsXG4gICAgICAgICAgICByYW5nZVN1cHBvcnRzR2V0Qm91bmRpbmdDbGllbnRSZWN0ID0gZmFsc2U7XG4gICAgICAgIGlmIChhcGkuZmVhdHVyZXMuaW1wbGVtZW50c0RvbVJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgdGVzdFJhbmdlID0gYXBpLmNyZWF0ZU5hdGl2ZVJhbmdlKCk7XG4gICAgICAgICAgICByYW5nZVN1cHBvcnRzR2V0Q2xpZW50UmVjdHMgPSB1dGlsLmlzSG9zdE1ldGhvZCh0ZXN0UmFuZ2UsIFwiZ2V0Q2xpZW50UmVjdHNcIik7XG4gICAgICAgICAgICByYW5nZVN1cHBvcnRzR2V0Qm91bmRpbmdDbGllbnRSZWN0ID0gdXRpbC5pc0hvc3RNZXRob2QodGVzdFJhbmdlLCBcImdldEJvdW5kaW5nQ2xpZW50UmVjdFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHV0aWwuZXh0ZW5kKGFwaS5mZWF0dXJlcywge1xuICAgICAgICAgICAgcmFuZ2VTdXBwb3J0c0dldEJvdW5kaW5nQ2xpZW50UmVjdDogcmFuZ2VTdXBwb3J0c0dldEJvdW5kaW5nQ2xpZW50UmVjdCxcbiAgICAgICAgICAgIHJhbmdlU3VwcG9ydHNHZXRDbGllbnRSZWN0czogcmFuZ2VTdXBwb3J0c0dldENsaWVudFJlY3RzLFxuICAgICAgICAgICAgZWxlbWVudFN1cHBvcnRzR2V0Qm91bmRpbmdDbGllbnRSZWN0OiBlbGVtZW50U3VwcG9ydHNHZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGNyZWF0ZUNsaWVudEJvdW5kYXJ5UG9zR2V0dGVyID0gZnVuY3Rpb24gY3JlYXRlQ2xpZW50Qm91bmRhcnlQb3NHZXR0ZXIoaXNTdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyB2YXIgYm91bmRhcnlSYW5nZSA9IHRoaXMuY2xvbmVSYW5nZSgpO1xuICAgICAgICAgICAgICAgIC8vIGJvdW5kYXJ5UmFuZ2UuY29sbGFwc2UoaXNTdGFydCk7XG4gICAgICAgICAgICAgICAgLy8gdmFyIHJlY3QgPSBib3VuZGFyeVJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB4OiByZWN0W2lzU3RhcnQgPyBcImxlZnRcIiA6IFwicmlnaHRcIl0sXG4gICAgICAgICAgICAgICAgICAgIHk6IHJlY3RbaXNTdGFydCA/IFwidG9wXCIgOiBcImJvdHRvbVwiXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciByYW5nZVByb3RvID0gYXBpLnJhbmdlUHJvdG90eXBlO1xuXG4gICAgICAgIGlmIChhcGkuZmVhdHVyZXMuaW1wbGVtZW50c1RleHRSYW5nZSAmJiBlbGVtZW50U3VwcG9ydHNHZXRCb3VuZGluZ0NsaWVudFJlY3QpIHtcbiAgICAgICAgICAgIHJhbmdlUHJvdG8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgYSBUZXh0UmFuZ2VcbiAgICAgICAgICAgICAgICB2YXIgdGV4dFJhbmdlID0gV3JhcHBlZFRleHRSYW5nZS5yYW5nZVRvVGV4dFJhbmdlKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgLy8gV29yayBhcm91bmQgdGFibGUgcHJvYmxlbXMgKHRhYmxlIGNlbGwgYm91bmRpbmcgcmVjdHMgc2VlbSBub3QgdG8gY291bnQgaWYgVGV4dFJhbmdlIHNwYW5zIGNlbGxzKVxuICAgICAgICAgICAgICAgIHZhciBjZWxscyA9IHRoaXMuZ2V0Tm9kZXMoWzFdLCBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgvXnRbZGhdJC9pLnRlc3QoZWwudGFnTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIE1lcmdlIHJlY3RzIGZvciBlYWNoIGNlbGwgc2VsZWN0ZWQgYnkgdGhlIHJhbmdlIGludG8gb3ZlcmFsbCByZWN0XG4gICAgICAgICAgICAgICAgdmFyIHJlY3QsXG4gICAgICAgICAgICAgICAgICAgIHJlY3RzID0gW107XG4gICAgICAgICAgICAgICAgaWYgKGNlbGxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RUYWJsZSA9IGdldEFuY2VzdG9yRWxlbWVudCh0aGlzLnN0YXJ0Q29udGFpbmVyLCBcInRhYmxlXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBjZWxsLCB0ZW1wVGV4dFJhbmdlLCB0YWJsZSwgc3ViUmFuZ2U7IGNlbGwgPSBjZWxsc1tpXTsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgbm9uLXRhYmxlIHNlY3Rpb25zIG9mIHRoZSByYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGUgPSBnZXRBbmNlc3RvckVsZW1lbnQoY2VsbCwgXCJ0YWJsZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbGFzdFRhYmxlIHx8IHRhYmxlICE9IGxhc3RUYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIGEgc2VjdGlvbiBvZiB0aGUgcmFuZ2UgcHJpb3IgdG8gdGhlIGN1cnJlbnQgdGFibGUsIG9yIGx5aW5nIGJldHdlZW4gdGFibGVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1lcmdlIGluIGl0cyByZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViUmFuZ2UgPSB0aGlzLmNsb25lUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdFRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YlJhbmdlLnNldFN0YXJ0QWZ0ZXIobGFzdFRhYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViUmFuZ2Uuc2V0RW5kQmVmb3JlKHRhYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWN0cy5wdXNoKFdyYXBwZWRUZXh0UmFuZ2UucmFuZ2VUb1RleHRSYW5nZShzdWJSYW5nZSkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250YWluc05vZGUoY2VsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWN0cy5wdXNoKGNlbGwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wVGV4dFJhbmdlID0gdGV4dFJhbmdlLmR1cGxpY2F0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBUZXh0UmFuZ2UubW92ZVRvRWxlbWVudFRleHQoY2VsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBUZXh0UmFuZ2UuY29tcGFyZUVuZFBvaW50cyhcIlN0YXJ0VG9TdGFydFwiLCB0ZXh0UmFuZ2UpID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBUZXh0UmFuZ2Uuc2V0RW5kUG9pbnQoXCJTdGFydFRvU3RhcnRcIiwgdGV4dFJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRlbXBUZXh0UmFuZ2UuY29tcGFyZUVuZFBvaW50cyhcIkVuZFRvRW5kXCIsIHRleHRSYW5nZSkgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wVGV4dFJhbmdlLnNldEVuZFBvaW50KFwiRW5kVG9FbmRcIiwgdGV4dFJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdHMucHVzaCh0ZW1wVGV4dFJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RUYWJsZSA9IHRhYmxlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTWVyZ2UgaW4gdGhlIHJlY3QgZm9yIGFueSBjb250ZW50IGx5aW5nIGFmdGVyIHRoZSBmaW5hbCB0YWJsZVxuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kVGFibGUgPSBnZXRBbmNlc3RvckVsZW1lbnQodGhpcy5lbmRDb250YWluZXIsIFwidGFibGVcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZW5kVGFibGUgJiYgbGFzdFRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJSYW5nZSA9IHRoaXMuY2xvbmVSYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViUmFuZ2Uuc2V0U3RhcnRBZnRlcihsYXN0VGFibGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdHMucHVzaChXcmFwcGVkVGV4dFJhbmdlLnJhbmdlVG9UZXh0UmFuZ2Uoc3ViUmFuZ2UpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZWN0ID0gbWVyZ2VSZWN0cyhyZWN0cyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdCA9IHRleHRSYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYWRqdXN0Q2xpZW50UmVjdChyZWN0LCBkb20uZ2V0RG9jdW1lbnQodGhpcy5zdGFydENvbnRhaW5lcikpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChhcGkuZmVhdHVyZXMuaW1wbGVtZW50c0RvbVJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgY3JlYXRlV3JhcHBlZFJhbmdlID0gZnVuY3Rpb24gY3JlYXRlV3JhcHBlZFJhbmdlKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlIGluc3RhbmNlb2YgV3JhcHBlZFJhbmdlID8gcmFuZ2UgOiBuZXcgV3JhcHBlZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocmFuZ2VTdXBwb3J0c0dldEJvdW5kaW5nQ2xpZW50UmVjdCkge1xuICAgICAgICAgICAgICAgIHJhbmdlUHJvdG8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmF0aXZlUmFuZ2UgPSBjcmVhdGVXcmFwcGVkUmFuZ2UodGhpcykubmF0aXZlUmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRlc3QgZm9yIFdlYktpdCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgYnVnIChodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjUzMjQpXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWN0ID0gbmF0aXZlUmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgfHwgbmF0aXZlUmFuZ2UuZ2V0Q2xpZW50UmVjdHMoKVswXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkanVzdENsaWVudFJlY3QocmVjdCwgZG9tLmdldERvY3VtZW50KHRoaXMuc3RhcnRDb250YWluZXIpKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlU3VwcG9ydHNHZXRDbGllbnRSZWN0cykge1xuXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUNsaWVudEJvdW5kYXJ5UG9zR2V0dGVyID0gZnVuY3Rpb24gY3JlYXRlQ2xpZW50Qm91bmRhcnlQb3NHZXR0ZXIoaXNTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF0aXZlUmFuZ2UgPSBjcmVhdGVXcmFwcGVkUmFuZ2UodGhpcykubmF0aXZlUmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3RzID0gbmF0aXZlUmFuZ2UuZ2V0Q2xpZW50UmVjdHMoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWN0cy5sZW5ndGggPT09IDAgJiYgZWxlbWVudFN1cHBvcnRzR2V0Qm91bmRpbmdDbGllbnRSZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1N0YXJ0KSB7fVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG5hdGl2ZVJhbmdlLCBuYXRpdmVSYW5nZS5nZXRDbGllbnRSZWN0cygpLCBuYXRpdmVSYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbGxhcHNlZCAmJiB0aGlzLnN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlID09PSAxICYmIHRoaXMuc3RhcnRPZmZzZXQgPCB0aGlzLnN0YXJ0Q29udGFpbmVyLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHRoaXMuc3RhcnRDb250YWluZXIuY2hpbGROb2Rlc1t0aGlzLnN0YXJ0T2Zmc2V0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuLmdldENsaWVudFJlY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cobiwgbi5nZXRDbGllbnRSZWN0cygpLCB0aGlzLnN0YXJ0Q29udGFpbmVyLmdldENsaWVudFJlY3RzKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3QgPSByZWN0c1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IHJlY3QubGVmdCwgeTogcmVjdC50b3AgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3QgPSByZWN0c1tyZWN0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IHJlY3QucmlnaHQsIHk6IHJlY3QuYm90dG9tIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBtb2R1bGUuY3JlYXRlRXJyb3IoXCJDYW5ub3QgZ2V0IHBvc2l0aW9uIGZvciByYW5nZSBcIiArIHRoaXMuaW5zcGVjdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGdldEVsZW1lbnRCb3VuZGluZ0NsaWVudFJlY3QgPSBlbGVtZW50U3VwcG9ydHNHZXRCb3VuZGluZ0NsaWVudFJlY3QgPyBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkanVzdENsaWVudFJlY3QoZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGRvbS5nZXREb2N1bWVudChlbCkpO1xuICAgICAgICAgICAgICAgIH0gOlxuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyB2ZXJ5IG5haXZlLiBUaGVyZSBhcmUgbWFueSBicm93c2VyIHF1aXJrcyB0aGF0IG1ha2UgaXQgZXh0cmVtZWx5XG4gICAgICAgICAgICAgICAgLy8gZGlmZmljdWx0IHRvIGdldCBhY2N1cmF0ZSBlbGVtZW50IGNvb3JkaW5hdGVzIGluIGFsbCBzaXR1YXRpb25zXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0RWwgPSBlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gZWwub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBlbC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChvZmZzZXRFbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBvZmZzZXRFbC5vZmZzZXRMZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgeSArPSBvZmZzZXRFbC5vZmZzZXRUb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRFbCA9IG9mZnNldEVsLm9mZnNldFBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGp1c3RDbGllbnRSZWN0KG5ldyBSZWN0KHksIHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCksIGRvbS5nZXREb2N1bWVudChlbCkpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YXIgZ2V0UmVjdEZyb21Cb3VuZGFyaWVzID0gZnVuY3Rpb24gZ2V0UmVjdEZyb21Cb3VuZGFyaWVzKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWN0O1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zcGxpdEJvdW5kYXJpZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2UuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZS5pbnNlcnROb2RlKHNwYW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdCA9IGdldEVsZW1lbnRCb3VuZGluZ0NsaWVudFJlY3Qoc3Bhbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3Bhbik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBUaGlzIGlzbid0IHJpZ2h0LiBJJ20gbm90IHN1cmUgaXQgY2FuIGJlIG1hZGUgcmlnaHQgc2Vuc2libHkuIENvbnNpZGVyIHdoYXQgdG8gZG8uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGRvZXNuJ3QgY29uc2lkZXIgYWxsIHRoZSBsaW5lIGJveGVzIGl0IG5lZWRzIHRvIGNvbnNpZGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdvcmtpbmdSYW5nZSA9IHJhbmdlLmNsb25lUmFuZ2UoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBzdGFydCByZWN0YW5nbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtpbmdSYW5nZS5jb2xsYXBzZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtpbmdSYW5nZS5pbnNlcnROb2RlKHNwYW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0UmVjdCA9IGdldEVsZW1lbnRCb3VuZGluZ0NsaWVudFJlY3Qoc3Bhbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3Bhbik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgZW5kIHJlY3RhbmdsZVxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2luZ1JhbmdlLmNvbGxhcHNlVG9Qb2ludChyYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JraW5nUmFuZ2UuaW5zZXJ0Tm9kZShzcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmRSZWN0ID0gZ2V0RWxlbWVudEJvdW5kaW5nQ2xpZW50UmVjdChzcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzcGFuKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWVyZ2UgdGhlIHN0YXJ0IGFuZCBlbmQgcmVjdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWN0cyA9IFtzdGFydFJlY3QsIGVuZFJlY3RdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNZXJnZSBpbiByZWN0YW5nbGVzIGZvciBhbGwgZWxlbWVudHMgaW4gdGhlIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudHMgPSByYW5nZS5nZXROb2RlcyhbMV0sIGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByYW5nZS5jb250YWluc05vZGUoZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RzLnB1c2goZ2V0RWxlbWVudEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50c1tpXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdCA9IG1lcmdlUmVjdHMocmVjdHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYW4gdXBcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uubm9ybWFsaXplQm91bmRhcmllcygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVjdDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmFuZ2VQcm90by5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFJlY3RGcm9tQm91bmRhcmllcyhjcmVhdGVXcmFwcGVkUmFuZ2UocmFuZ2UpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZURvY3VtZW50Qm91bmRhcnlQb3NHZXR0ZXIoaXNTdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gdGhpc1tcImdldFwiICsgKGlzU3RhcnQgPyBcIlN0YXJ0XCIgOiBcIkVuZFwiKSArIFwiQ2xpZW50UG9zXCJdKCk7XG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbFBvcyA9IGdldFNjcm9sbFBvc2l0aW9uKGRvbS5nZXRXaW5kb3codGhpcy5zdGFydENvbnRhaW5lcikpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IHBvcy54ICsgc2Nyb2xsUG9zLngsIHk6IHBvcy55ICsgc2Nyb2xsUG9zLnkgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB1dGlsLmV4dGVuZChyYW5nZVByb3RvLCB7XG4gICAgICAgICAgICBnZXRCb3VuZGluZ0RvY3VtZW50UmVjdDogZnVuY3Rpb24gZ2V0Qm91bmRpbmdEb2N1bWVudFJlY3QoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbFBvcyA9IGdldFNjcm9sbFBvc2l0aW9uKGRvbS5nZXRXaW5kb3codGhpcy5zdGFydENvbnRhaW5lcikpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVSZWxhdGl2ZVJlY3QodGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgc2Nyb2xsUG9zLngsIHNjcm9sbFBvcy55KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFN0YXJ0Q2xpZW50UG9zOiBjcmVhdGVDbGllbnRCb3VuZGFyeVBvc0dldHRlcih0cnVlKSxcbiAgICAgICAgICAgIGdldEVuZENsaWVudFBvczogY3JlYXRlQ2xpZW50Qm91bmRhcnlQb3NHZXR0ZXIoZmFsc2UpLFxuXG4gICAgICAgICAgICBnZXRTdGFydERvY3VtZW50UG9zOiBjcmVhdGVEb2N1bWVudEJvdW5kYXJ5UG9zR2V0dGVyKHRydWUpLFxuICAgICAgICAgICAgZ2V0RW5kRG9jdW1lbnRQb3M6IGNyZWF0ZURvY3VtZW50Qm91bmRhcnlQb3NHZXR0ZXIoZmFsc2UpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEFkZCBTZWxlY3Rpb24gbWV0aG9kc1xuICAgICAgICBmdW5jdGlvbiBjb21wYXJlUmFuZ2VzKHIxLCByMikge1xuICAgICAgICAgICAgcmV0dXJuIHIxLmNvbXBhcmVCb3VuZGFyeVBvaW50cyhyMi5TVEFSVF9UT19TVEFSVCwgcjIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlU2VsZWN0aW9uUmVjdEdldHRlcihpc0RvY3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByYW5nZU1ldGhvZE5hbWUgPSBcImdldEJvdW5kaW5nXCIgKyAoaXNEb2N1bWVudCA/IFwiRG9jdW1lbnRcIiA6IFwiQ2xpZW50XCIpICsgXCJSZWN0XCI7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3RzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJhbmdlQ291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICByZWN0cy5wdXNoKHRoaXMuZ2V0UmFuZ2VBdChpKVtyYW5nZU1ldGhvZE5hbWVdKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2VSZWN0cyhyZWN0cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlU2VsZWN0aW9uQm91bmRhcnlQb3NHZXR0ZXIoaXNTdGFydCwgaXNEb2N1bWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yYW5nZUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwb3NUeXBlID0gaXNEb2N1bWVudCA/IFwiRG9jdW1lbnRcIiA6IFwiQ2xpZW50XCI7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2VzID0gdGhpcy5nZXRBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3JkZXIgdGhlIHJhbmdlcyBieSBwb3NpdGlvbiB3aXRoaW4gdGhlIERPTVxuICAgICAgICAgICAgICAgICAgICByYW5nZXMuc29ydChjb21wYXJlUmFuZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaXNTdGFydCA/IHJhbmdlc1swXVtcImdldFN0YXJ0XCIgKyBwb3NUeXBlICsgXCJQb3NcIl0oKSA6IHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV1bXCJnZXRFbmRcIiArIHBvc1R5cGUgKyBcIlBvc1wiXSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHV0aWwuZXh0ZW5kKGFwaS5zZWxlY3Rpb25Qcm90b3R5cGUsIHtcbiAgICAgICAgICAgIGdldEJvdW5kaW5nQ2xpZW50UmVjdDogY3JlYXRlU2VsZWN0aW9uUmVjdEdldHRlcihmYWxzZSksXG4gICAgICAgICAgICBnZXRCb3VuZGluZ0RvY3VtZW50UmVjdDogY3JlYXRlU2VsZWN0aW9uUmVjdEdldHRlcih0cnVlKSxcblxuICAgICAgICAgICAgZ2V0U3RhcnRDbGllbnRQb3M6IGNyZWF0ZVNlbGVjdGlvbkJvdW5kYXJ5UG9zR2V0dGVyKHRydWUsIGZhbHNlKSxcbiAgICAgICAgICAgIGdldEVuZENsaWVudFBvczogY3JlYXRlU2VsZWN0aW9uQm91bmRhcnlQb3NHZXR0ZXIoZmFsc2UsIGZhbHNlKSxcblxuICAgICAgICAgICAgZ2V0U3RhcnREb2N1bWVudFBvczogY3JlYXRlU2VsZWN0aW9uQm91bmRhcnlQb3NHZXR0ZXIodHJ1ZSwgdHJ1ZSksXG4gICAgICAgICAgICBnZXRFbmREb2N1bWVudFBvczogY3JlYXRlU2VsZWN0aW9uQm91bmRhcnlQb3NHZXR0ZXIoZmFsc2UsIHRydWUpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGFwaS5wb3NpdGlvbkZyb21Qb2ludCA9IGZ1bmN0aW9uICh4LCB5LCBkb2MpIHtcbiAgICAgICAgICAgIGRvYyA9IGRvbS5nZXRDb250ZW50RG9jdW1lbnQoZG9jLCBtb2R1bGUsIFwicG9zaXRpb25Gcm9tUG9pbnRcIik7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlQ2FyZXRQb3NpdGlvbkZyb21Qb2ludEdldHRlcihkb2MpKGRvYywgeCwgeSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgYXBpLmNyZWF0ZVJhbmdlRnJvbVBvaW50cyA9IGNyZWF0ZVJhbmdlRnJvbVBvaW50cztcbiAgICAgICAgYXBpLm1vdmVTZWxlY3Rpb25Ub1BvaW50cyA9IG1vdmVTZWxlY3Rpb25Ub1BvaW50cztcbiAgICB9KTtcbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLW1lbnRpb24vYnVpbGQvcmFuZ3ktcG9zaXRpb24uanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4vKipcbiAqIFtwYXJzZVN0ckJ5RGVsaW1pdGVyIGRlc2NyaXB0aW9uXVxuICogQG1ldGhvZCBwYXJzZVN0ckJ5RGVsaW1pdGVyXG4gKiBAcGFyYW0gIHtbc3RyaW5nXX0gc3RyICAgICAgID0gJycgIFtvcmlnaW4gc3RyXVxuICogQHBhcmFtICB7W3N0cmluZ119IGRlbGltaXRlciA9ICdAJyBbZGVsaW1pdGVyIHN0cl1cbiAqIEByZXR1cm4ge1tzdHJpbmddfVxuICovXG5mdW5jdGlvbiBwYXJzZVN0ckJ5RGVsaW1pdGVyKCkge1xuXHR2YXIgc3RyID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gJycgOiBhcmd1bWVudHNbMF07XG5cdHZhciBkZWxpbWl0ZXIgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyAnQCcgOiBhcmd1bWVudHNbMV07XG5cblx0dmFyIGlkeCA9IHN0ci5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRpZiAoaWR4ICE9PSAtMSkge1xuXHRcdHN0ciA9IHN0ci5zdWJzdHJpbmcoaWR4ICsgMSk7XG5cdH0gZWxzZSB7XG5cdFx0c3RyID0gJyc7XG5cdH1cblx0cmV0dXJuIHN0cjtcbn1cblxuLyoqXG4gKiBbZ2V0IHdpbmRvdyBzY3JvbGwgb2Zmc2V0XVxuICogQG1ldGhvZCBnZXRTY3JvbGxPZmZzZXRcbiAqL1xuZnVuY3Rpb24gZ2V0U2Nyb2xsT2Zmc2V0KCkge1xuXHR2YXIgb2Zmc2V0ID0ge307XG5cdGlmICh3aW5kb3cucGFnZVhPZmZzZXQpIHtcblx0XHRvZmZzZXQueCA9IHdpbmRvdy5wYWdlWE9mZnNldDtcblx0fSBlbHNlIHtcblx0XHRvZmZzZXQueCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0O1xuXHR9XG5cdGlmICh3aW5kb3cucGFnZVlPZmZzZXQpIHtcblx0XHRvZmZzZXQueSA9IHdpbmRvdy5wYWdlWU9mZnNldDtcblx0fSBlbHNlIHtcblx0XHRvZmZzZXQueSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3A7XG5cdH1cblx0cmV0dXJuIG9mZnNldDtcbn1cblxuZXhwb3J0cy5wYXJzZVN0ckJ5RGVsaW1pdGVyID0gcGFyc2VTdHJCeURlbGltaXRlcjtcbmV4cG9ydHMuZ2V0U2Nyb2xsT2Zmc2V0ID0gZ2V0U2Nyb2xsT2Zmc2V0O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtbWVudGlvbi9idWlsZC91dGlsLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgS0VZQ09ERSA9IGV4cG9ydHMuS0VZQ09ERSA9IHtcbiAgIERPV046IDQwLFxuICAgVVA6IDM4LFxuICAgRVNDOiAyNyxcbiAgIFRBQjogOSxcbiAgIEVOVEVSOiAxMyxcbiAgIENUUkw6IDE3LFxuICAgQkFDS1NQQUNFOiA4LFxuICAgREVMRVRFOiA0NlxufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLW1lbnRpb24vYnVpbGQva2V5Y29kZS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNZW51IENvbXBvbmVudCBmb3IgdXhjb3JlXG4gKiBAYXV0aG9yIHZpbmNlbnQuYmlhblxuICpcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIFV4Y29yZSBUZWFtLCBBbGludy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL01lbnUnKTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLW1lbnUvYnVpbGQvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yY01lbnUgPSByZXF1aXJlKCdyYy1tZW51Jyk7XG5cbnZhciBfcmNNZW51MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JjTWVudSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogTWVudSBDb21wb25lbnQgZm9yIHV4Y29yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGF1dGhvciB2aW5jZW50LmJpYW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBVeGNvcmUgVGVhbSwgQWxpbncuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cblxudmFyIE1lbnUgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhNZW51LCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIE1lbnUoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNZW51KTtcblxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9XG5cbiAgICBNZW51LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm1vZGUgPT09ICdpbmxpbmUnKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfcmNNZW51MltcImRlZmF1bHRcIl0sIHRoaXMucHJvcHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX3JjTWVudTJbXCJkZWZhdWx0XCJdLCB0aGlzLnByb3BzKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gTWVudTtcbn0oX3JlYWN0MltcImRlZmF1bHRcIl0uQ29tcG9uZW50KTtcblxuTWVudS5kZWZhdWx0UHJvcHMgPSB7XG4gICAgcHJlZml4Q2xzOiAna3VtYS1tZW51J1xufTtcbk1lbnUucHJvcFR5cGVzID0ge1xuICAgIHByZWZpeENsczogX3JlYWN0MltcImRlZmF1bHRcIl0uUHJvcFR5cGVzLnN0cmluZ1xufTtcblxuTWVudS5TdWJNZW51ID0gX3JjTWVudS5TdWJNZW51O1xuTWVudS5JdGVtID0gX3JjTWVudS5JdGVtO1xuTWVudS5EaXZpZGVyID0gX3JjTWVudS5EaXZpZGVyO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IE1lbnU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLW1lbnUvYnVpbGQvTWVudS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNdWx0aXNlbGVjdCBDb21wb25lbnQgZm9yIHV4Y29yZVxuICogQGF1dGhvciBwZWlqaWUuZHBqXG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgVXhjb3JlIFRlYW0sIEFsaW53LlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vTXVsdGlTZWxlY3QnKTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLW11bHRpLXNlbGVjdC9idWlsZC9pbmRleC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIE11bHRpU2VsZWN0IENvbXBvbmVudCBmb3IgdXhjb3JlXG4gKiBAYXV0aG9yIHBlaWppZS5kcGpcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBVeGNvcmUgVGVhbSwgQWxpbncuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcbnZhciBEcm9wZG93biA9IHJlcXVpcmUoJ3V4Y29yZS1kcm9wZG93bicpO1xudmFyIENoZWNrYm94R3JvdXAgPSByZXF1aXJlKCd1eGNvcmUtY2hlY2tib3gtZ3JvdXAnKTtcbnZhciBCdXR0b24gPSByZXF1aXJlKCd1eGNvcmUtYnV0dG9uJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xudmFyIGNsYXNzbmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG5cbnZhciBNdWx0aVNlbGVjdCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhNdWx0aVNlbGVjdCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTXVsdGlTZWxlY3QocHJvcHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTXVsdGlTZWxlY3QpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHZpc2libGU6IGZhbHNlXG4gICAgfTtcblxuICAgIF90aGlzLmxhc3RWYWx1ZSA9IF90aGlzLnByb3BzLnZhbHVlIHx8IFtdO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIE11bHRpU2VsZWN0LnByb3RvdHlwZS5oYW5kbGVDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVDaGFuZ2UodmFsdWUpIHtcbiAgICB2YXIgbWUgPSB0aGlzLFxuICAgICAgICBwcm9wcyA9IHRoaXMucHJvcHM7XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBbXTtcbiAgICBpZiAocHJvcHMubWF4U2VsZWN0ICYmIHZhbHVlLmxlbmd0aCA+IHByb3BzLm1heFNlbGVjdCkge1xuICAgICAgbmV3VmFsdWUgPSBtZS5sYXN0VmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XG4gICAgICBtZS5sYXN0VmFsdWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBwcm9wcy5vbkNoYW5nZShuZXdWYWx1ZSk7XG4gIH07XG5cbiAgTXVsdGlTZWxlY3QucHJvdG90eXBlLmhhbmRsZVNlbGVjdEFsbCA9IGZ1bmN0aW9uIGhhbmRsZVNlbGVjdEFsbCgpIHtcbiAgICB2YXIgbWUgPSB0aGlzLFxuICAgICAgICBwcm9wcyA9IHRoaXMucHJvcHM7XG5cbiAgICB2YXIgdmFsdWVMaXN0ID0gW107XG4gICAgaWYgKHByb3BzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0LkNoaWxkcmVuLm1hcChwcm9wcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKCFpdGVtLnByb3BzLmRpc2FibGVkIHx8IG1lLl9oYXNTZWxlY3RlZC5jYWxsKG1lLCBpdGVtLnByb3BzLnZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlTGlzdC5wdXNoKGl0ZW0ucHJvcHMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBwcm9wcy5vbkNoYW5nZSh2YWx1ZUxpc3QpO1xuICB9O1xuXG4gIE11bHRpU2VsZWN0LnByb3RvdHlwZS5oYW5kbGVDbGVhciA9IGZ1bmN0aW9uIGhhbmRsZUNsZWFyKCkge1xuICAgIHZhciBtZSA9IHRoaXMsXG4gICAgICAgIHByb3BzID0gdGhpcy5wcm9wcztcblxuICAgIHZhciB2YWx1ZUxpc3QgPSBbXTtcblxuICAgIGlmIChwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdC5DaGlsZHJlbi5tYXAocHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtLnByb3BzLmRpc2FibGVkICYmIG1lLl9oYXNTZWxlY3RlZC5jYWxsKG1lLCBpdGVtLnByb3BzLnZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlTGlzdC5wdXNoKGl0ZW0ucHJvcHMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBwcm9wcy5vbkNoYW5nZSh2YWx1ZUxpc3QpO1xuICB9O1xuXG4gIE11bHRpU2VsZWN0LnByb3RvdHlwZS5oYW5kbGVTdWJtaXQgPSBmdW5jdGlvbiBoYW5kbGVTdWJtaXQoKSB7XG4gICAgdmFyIG1lID0gdGhpcyxcbiAgICAgICAgcHJvcHMgPSB0aGlzLnByb3BzO1xuXG4gICAgdmFyIGxhYmVsTGlzdCA9IFtdLFxuICAgICAgICB2YWx1ZUxpc3QgPSBbXTtcblxuICAgIFJlYWN0LkNoaWxkcmVuLm1hcChwcm9wcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIGlmIChtZS5faGFzU2VsZWN0ZWQuY2FsbChtZSwgaXRlbS5wcm9wcy52YWx1ZSkpIHtcbiAgICAgICAgbGFiZWxMaXN0LnB1c2goaXRlbS5wcm9wc1twcm9wcy5vcHRpb25MYWJlbFByb3BdKTtcbiAgICAgICAgdmFsdWVMaXN0LnB1c2goaXRlbS5wcm9wcy52YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBwcm9wcy5vblN1Ym1pdCh2YWx1ZUxpc3QsIGxhYmVsTGlzdCk7XG5cbiAgICBtZS5zZXRTdGF0ZSh7XG4gICAgICB2aXNpYmxlOiBmYWxzZVxuICAgIH0pO1xuICB9O1xuXG4gIE11bHRpU2VsZWN0LnByb3RvdHlwZS5fcHJvY2Vzc0xhYmVsID0gZnVuY3Rpb24gX3Byb2Nlc3NMYWJlbCh0eXBlKSB7XG4gICAgdmFyIG1lID0gdGhpcyxcbiAgICAgICAgcHJvcHMgPSB0aGlzLnByb3BzO1xuXG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHJlcyA9IFJlYWN0LkNoaWxkcmVuLm1hcChwcm9wcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIGlmIChtZS5faGFzU2VsZWN0ZWQuY2FsbChtZSwgaXRlbS5wcm9wcy52YWx1ZSkpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSAnY29udGVudCc6XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogcHJvcHMucHJlZml4Q2xzICsgJy1zZWxlY3Rpb25fX2Nob2ljZV9fY29udGVudCcgfSxcbiAgICAgICAgICAgICAgaXRlbS5wcm9wc1twcm9wcy5vcHRpb25MYWJlbFByb3BdLFxuICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogcHJvcHMucHJlZml4Q2xzICsgJy1zZWxlY3Rpb25fX2Nob2ljZV9fYnJlYWsnIH0sXG4gICAgICAgICAgICAgICAgcHJvcHMudGl0bGVCcmVha1N0clxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd0aXRsZSc6XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5wcm9wc1twcm9wcy5vcHRpb25MYWJlbFByb3BdICsgcHJvcHMudGl0bGVCcmVha1N0cjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAocmVzLmxlbmd0aCA9PSAwKSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnY29udGVudCc6XG4gICAgICAgICAgcmVzID0gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcm9wcy5wcmVmaXhDbHMgKyAnLXNlbGVjdGlvbl9fcGxhY2Vob2xkZXInIH0sXG4gICAgICAgICAgICBwcm9wcy5wbGFjZWhvbGRlclxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndGl0bGUnOlxuICAgICAgICAgIHJlcyA9IFtwcm9wcy5wbGFjZWhvbGRlcl07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlID09ICd0aXRsZScpIHtcbiAgICAgICAgdmFyIGxlbiA9IHJlcy5sZW5ndGg7XG4gICAgICAgIHJlc1tsZW4gLSAxXSA9IHJlc1tsZW4gLSAxXS5zbGljZSgwLCByZXNbbGVuIC0gMV0ubGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGUgPT0gJ3RpdGxlJyA/IHJlcy5qb2luKCcnKSA6IHJlcztcbiAgfTtcblxuICBNdWx0aVNlbGVjdC5wcm90b3R5cGUuX2hhc1NlbGVjdGVkID0gZnVuY3Rpb24gX2hhc1NlbGVjdGVkKHZhbHVlKSB7XG4gICAgdmFyIG1lID0gdGhpcztcblxuICAgIHJldHVybiBtZS5wcm9wcy52YWx1ZS5pbmRleE9mKHZhbHVlKSAhPSAtMTtcbiAgfTtcblxuICBNdWx0aVNlbGVjdC5wcm90b3R5cGUuX2hhbmRsZVZpc2JsZUNoYW5nZSA9IGZ1bmN0aW9uIF9oYW5kbGVWaXNibGVDaGFuZ2UodmlzaWJsZSkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAocHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICB2aXNpYmxlOiB2aXNpYmxlXG4gICAgfSk7XG4gIH07XG5cbiAgTXVsdGlTZWxlY3QucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX2NsYXNzbmFtZXMsIF9jbGFzc25hbWVzMiwgX2NsYXNzbmFtZXMzLCBfY2xhc3NuYW1lczQ7XG5cbiAgICB2YXIgbWUgPSB0aGlzLFxuICAgICAgICBwcm9wcyA9IHRoaXMucHJvcHM7XG5cbiAgICAvLyDmo4Dmn6XmmK/lkKblj6/ku6Xngrnlh7sg5YWo6YCJXG4gICAgdmFyIGNhblNlbGVjdEl0ZW1OdW1iZXJzID0gMDtcblxuICAgIFJlYWN0LkNoaWxkcmVuLm1hcChwcm9wcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAhaXRlbS5wcm9wcy5kaXNhYmxlZCAmJiBjYW5TZWxlY3RJdGVtTnVtYmVycysrO1xuICAgIH0pO1xuXG4gICAgdmFyIG1lbnUgPSBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgJ2RpdicsXG4gICAgICB7IGNsYXNzTmFtZTogcHJvcHMucHJlZml4Q2xzICsgJy1kcm9wZG93bi1ib3JkZXInIH0sXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgeyBjbGFzc05hbWU6IHByb3BzLnByZWZpeENscyArICctY29udGVudCcgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICBDaGVja2JveEdyb3VwLFxuICAgICAgICAgIHsgb25DaGFuZ2U6IG1lLmhhbmRsZUNoYW5nZS5iaW5kKG1lKSxcbiAgICAgICAgICAgIHZhbHVlOiBwcm9wcy52YWx1ZSB9LFxuICAgICAgICAgIFJlYWN0LkNoaWxkcmVuLm1hcChwcm9wcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDaGVja2JveEdyb3VwLkl0ZW0sIF9leHRlbmRzKHt9LCBpdGVtLnByb3BzLCB7IGtleTogaW5kZXgsIGpzeGRpc2FibGVkOiBwcm9wcy5kaXNhYmxlZCB9KSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKSxcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdkaXYnLFxuICAgICAgICB7IGNsYXNzTmFtZTogcHJvcHMucHJlZml4Q2xzICsgJy1mb290ZXInIH0sXG4gICAgICAgICEhcHJvcHMubWF4U2VsZWN0ICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ3AnLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgJ+acgOWkmumAiScsXG4gICAgICAgICAgcHJvcHMubWF4U2VsZWN0LFxuICAgICAgICAgICfkuKonXG4gICAgICAgICksXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgQnV0dG9uLFxuICAgICAgICAgIHsgYWRkaXRpb25DbGFzczogY2xhc3NuYW1lcygoX2NsYXNzbmFtZXMgPSB7fSwgX2NsYXNzbmFtZXNbcHJvcHMucHJlZml4Q2xzICsgJy1idXR0b24nXSA9IHRydWUsIF9jbGFzc25hbWVzW3Byb3BzLnByZWZpeENscyArICctYnV0dG9uLWhpZGRlbiddID0gIXByb3BzLnNob3dTZWxlY3RBbGwsIF9jbGFzc25hbWVzKSksXG4gICAgICAgICAgICBzaXplOiAnc21hbGwnLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IHByb3BzLm1heFNlbGVjdCAmJiBwcm9wcy5tYXhTZWxlY3QgPCBjYW5TZWxlY3RJdGVtTnVtYmVycyA/IHRydWUgOiBmYWxzZSxcbiAgICAgICAgICAgIG9uQ2xpY2s6IG1lLmhhbmRsZVNlbGVjdEFsbC5iaW5kKG1lKSB9LFxuICAgICAgICAgICflhajpgIknXG4gICAgICAgICksXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgQnV0dG9uLFxuICAgICAgICAgIHsgYWRkaXRpb25DbGFzczogY2xhc3NuYW1lcygoX2NsYXNzbmFtZXMyID0ge30sIF9jbGFzc25hbWVzMltwcm9wcy5wcmVmaXhDbHMgKyAnLWJ1dHRvbiddID0gdHJ1ZSwgX2NsYXNzbmFtZXMyW3Byb3BzLnByZWZpeENscyArICctYnV0dG9uLWhpZGRlbiddID0gIXByb3BzLnNob3dDbGVhciwgX2NsYXNzbmFtZXMyKSksXG4gICAgICAgICAgICBzaXplOiAnc21hbGwnLFxuICAgICAgICAgICAgb25DbGljazogbWUuaGFuZGxlQ2xlYXIuYmluZChtZSkgfSxcbiAgICAgICAgICAn5riF56m6J1xuICAgICAgICApLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIEJ1dHRvbixcbiAgICAgICAgICB7IGFkZGl0aW9uQ2xhc3M6IHByb3BzLnByZWZpeENscyArICctYnV0dG9uJyxcbiAgICAgICAgICAgIHNpemU6ICdzbWFsbCcsXG4gICAgICAgICAgICBvbkNsaWNrOiBtZS5oYW5kbGVTdWJtaXQuYmluZChtZSkgfSxcbiAgICAgICAgICAn56Gu6K6kJ1xuICAgICAgICApXG4gICAgICApXG4gICAgKTtcblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgJ2RpdicsXG4gICAgICBudWxsLFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgRHJvcGRvd24sXG4gICAgICAgIHsgb3ZlcmxheTogbWVudSxcbiAgICAgICAgICBtaW5PdmVybGF5V2lkdGhNYXRjaFRyaWdnZXI6IGZhbHNlLFxuICAgICAgICAgIHZpc2libGU6IG1lLnN0YXRlLnZpc2libGUsXG4gICAgICAgICAgb25WaXNpYmxlQ2hhbmdlOiBtZS5faGFuZGxlVmlzYmxlQ2hhbmdlLmJpbmQobWUpLFxuICAgICAgICAgIHRyaWdnZXI6IFtcImNsaWNrXCJdLFxuICAgICAgICAgIG92ZXJsYXlDbGFzc05hbWU6IGNsYXNzbmFtZXMoKF9jbGFzc25hbWVzMyA9IHt9LCBfY2xhc3NuYW1lczNbcHJvcHMucHJlZml4Q2xzICsgJy1kcm9wZG93biddID0gdHJ1ZSwgX2NsYXNzbmFtZXMzW3Byb3BzLmRyb3Bkb3duQ2xhc3NOYW1lXSA9ICEhcHJvcHMuZHJvcGRvd25DbGFzc05hbWUsIF9jbGFzc25hbWVzMykpIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgIHsgY2xhc3NOYW1lOiBjbGFzc25hbWVzKChfY2xhc3NuYW1lczQgPSB7fSwgX2NsYXNzbmFtZXM0W3Byb3BzLnByZWZpeENsc10gPSB0cnVlLCBfY2xhc3NuYW1lczRbcHJvcHMuY2xhc3NOYW1lXSA9ICEhcHJvcHMuY2xhc3NOYW1lLCBfY2xhc3NuYW1lczRbcHJvcHMucHJlZml4Q2xzICsgJy1vcGVuJ10gPSBtZS5zdGF0ZS52aXNpYmxlLCBfY2xhc3NuYW1lczRbcHJvcHMucHJlZml4Q2xzICsgJy1kaXNhYmxlZCddID0gcHJvcHMuZGlzYWJsZWQsIF9jbGFzc25hbWVzNCkpIH0sXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcm9wcy5wcmVmaXhDbHMgKyAnLXNlbGVjdGlvbiAnICsgcHJvcHMucHJlZml4Q2xzICsgJy1zZWxlY3Rpb24tLW11bHRpcGxlJyB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogcHJvcHMucHJlZml4Q2xzICsgJy1zZWxlY3Rpb24tLW11bHRpcGxlLS1jb250ZW50JywgdGl0bGU6IG1lLl9wcm9jZXNzTGFiZWwoJ3RpdGxlJykgfSxcbiAgICAgICAgICAgICAgbWUuX3Byb2Nlc3NMYWJlbCgnY29udGVudCcpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnc3BhbicsIHsgY2xhc3NOYW1lOiBwcm9wcy5wcmVmaXhDbHMgKyAnLWFycm93JyB9KVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKVxuICAgICk7XG4gIH07XG5cbiAgcmV0dXJuIE11bHRpU2VsZWN0O1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5NdWx0aVNlbGVjdC5kZWZhdWx0UHJvcHMgPSB7XG4gIHByZWZpeENsczogJ2t1bWEtbXVsdGktc2VsZWN0JyxcbiAgY2xhc3NOYW1lOiAnJyxcbiAgZHJvcGRvd25DbGFzc05hbWU6ICcnLFxuICB2YWx1ZTogW10sXG4gIGRpc2FibGVkOiBmYWxzZSxcbiAgcGxhY2Vob2xkZXI6ICcnLFxuICB0aXRsZUJyZWFrU3RyOiBcIuOAgVwiLFxuICBvcHRpb25MYWJlbFByb3A6IFwidGV4dFwiLFxuICBzaG93U2VsZWN0QWxsOiB0cnVlLFxuICBzaG93Q2xlYXI6IHRydWUsXG4gIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZSgpIHt9LFxuICBvblN1Ym1pdDogZnVuY3Rpb24gb25TdWJtaXQoKSB7fVxufTtcblxuTXVsdGlTZWxlY3QucHJvcFR5cGVzID0ge1xuICBwcmVmaXhDbHM6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gIGNsYXNzTmFtZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgZHJvcGRvd25DbGFzc05hbWU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gIHZhbHVlOiBSZWFjdC5Qcm9wVHlwZXMuYXJyYXksXG4gIGRpc2FibGVkOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgbWF4U2VsZWN0OiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICBwbGFjZWhvbGRlcjogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgdGl0bGVCcmVha1N0cjogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgb3B0aW9uTGFiZWxQcm9wOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICBzaG93U2VsZWN0QWxsOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgc2hvd0NsZWFyOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgb25DaGFuZ2U6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICBvblN1Ym1pdDogUmVhY3QuUHJvcFR5cGVzLmZ1bmNcbn07XG5cbi8vIGh0dHA6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy9yZXVzYWJsZS1jb21wb25lbnRzLmh0bWxcblxuTXVsdGlTZWxlY3QuSXRlbSA9IENoZWNrYm94R3JvdXAuSXRlbTtcblxuTXVsdGlTZWxlY3QuZGlzcGxheU5hbWUgPSBcIk11bHRpU2VsZWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gTXVsdGlTZWxlY3Q7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1tdWx0aS1zZWxlY3QvYnVpbGQvTXVsdGlTZWxlY3QuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfY2xhc3NuYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcblxudmFyIF9jbGFzc25hbWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzbmFtZXMpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcmVhY3REb20gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIF9yZWFjdERvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdERvbSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBzaXplTWFwID0ge1xuXHRzbWFsbDogJ3NtJyxcblx0bWVkaXVtOiAnJyxcblx0bGFyZ2U6ICdsZydcbn0sXG4gICAgdHlwZU1hcCA9IHtcblx0cHJpbWFyeTogJ3ByaW1hcnknLFxuXHRzZWNvbmRhcnk6ICdzZWNvbmRhcnknLFxuXHRkaXNhYmxlZDogJ2Rpc2FibGVkJ1xufSxcbiAgICBjbHNQcmVmaXggPSAna3VtYS1idXR0b24nO1xuXG52YXIgQnV0dG9uID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcblx0X2luaGVyaXRzKEJ1dHRvbiwgX1JlYWN0JENvbXBvbmVudCk7XG5cblx0ZnVuY3Rpb24gQnV0dG9uKHByb3BzKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1dHRvbik7XG5cblx0XHRyZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSk7XG5cdH1cblxuXHRCdXR0b24ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcblx0XHR2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuXHRcdHZhciB0eXBlID0gcHJvcHMuZGlzYWJsZWQgPyAnZGlzYWJsZWQnIDogcHJvcHMudHlwZTtcblx0XHR2YXIgY2xzT2JqID0ge307XG5cdFx0aWYgKHByb3BzLmNsYXNzTmFtZSkge1xuXHRcdFx0Y2xzT2JqW3Byb3BzLmNsYXNzTmFtZV0gPSB0cnVlO1xuXHRcdH1cblx0XHRpZiAoc2l6ZU1hcFtwcm9wcy5zaXplXSkge1xuXHRcdFx0Y2xzT2JqW2Nsc1ByZWZpeCArICctJyArIHNpemVNYXBbcHJvcHMuc2l6ZV1dID0gdHJ1ZTtcblx0XHR9XG5cdFx0dmFyIGNsYXNzTmFtZSA9ICgwLCBfY2xhc3NuYW1lczJbXCJkZWZhdWx0XCJdKShjbHNQcmVmaXgsIGNsc1ByZWZpeCArICctJyArIHR5cGVNYXBbdHlwZV0sIGNsc09iaik7XG5cdFx0dmFyIHByb3BFdmVudHMgPSB7fTtcblx0XHRPYmplY3Qua2V5cyhwcm9wcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRpZiAoa2V5LmluZGV4T2YoJ29uJykgPT09IDApIHtcblx0XHRcdFx0cHJvcEV2ZW50c1trZXldID0gcHJvcHNba2V5XTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcblx0XHRcdCdidXR0b24nLFxuXHRcdFx0X2V4dGVuZHMoeyBjbGFzc05hbWU6IGNsYXNzTmFtZSwgZGlzYWJsZWQ6IHByb3BzLmRpc2FibGVkIH0sIHByb3BFdmVudHMpLFxuXHRcdFx0cHJvcHMuY2hpbGRyZW5cblx0XHQpO1xuXHR9O1xuXG5cdHJldHVybiBCdXR0b247XG59KF9yZWFjdDJbXCJkZWZhdWx0XCJdLkNvbXBvbmVudCk7XG5cbkJ1dHRvbi5kaXNwbGF5TmFtZSA9ICd1eGNvcmUtYnV0dG9uJztcbkJ1dHRvbi5wcm9wVHlwZXMgPSB7XG5cdHNpemU6IF9yZWFjdDJbXCJkZWZhdWx0XCJdLlByb3BUeXBlcy5vbmVPZihPYmplY3Qua2V5cyhzaXplTWFwKSksXG5cdHR5cGU6IF9yZWFjdDJbXCJkZWZhdWx0XCJdLlByb3BUeXBlcy5vbmVPZihPYmplY3Qua2V5cyh0eXBlTWFwKSksXG5cdGRpc2FibGVkOiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMub25lT2YoWydkaXNhYmxlZCcsIHRydWUsIGZhbHNlXSksXG5cdGNsYXNzTmFtZTogX3JlYWN0MltcImRlZmF1bHRcIl0uUHJvcFR5cGVzLnN0cmluZ1xufTtcbkJ1dHRvbi5kZWZhdWx0UHJvcHMgPSB7XG5cdHNpemU6ICdtZWRpdW0nLFxuXHR0eXBlOiAncHJpbWFyeScsXG5cdGRpc2FibGVkOiBmYWxzZSxcblx0Y2xhc3NOYW1lOiAnJ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCdXR0b247XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1tdWx0aS1zZWxlY3Qvfi91eGNvcmUtYnV0dG9uL2J1aWxkL0J1dHRvbi5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBQYWdpbmF0aW9uIENvbXBvbmVudCBmb3IgdXhjb3JlXG4gKiBAYXV0aG9yIFxuICpcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIFV4Y29yZSBUZWFtLCBBbGludy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL1BhZ2luYXRpb24nKTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLXBhZ2luYXRpb24vYnVpbGQvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBGb3JrZWQgZnJvbSBwcm9qZWN0IHJjLXBhZ2luYXRpb25cbiAqIEBtYWludGFpbmVyIGV0ZXJuYWxza3lcbiAqL1xuXG52YXIgU2VsZWN0ID0gcmVxdWlyZSgndXhjb3JlLXNlbGVjdDInKTtcbnZhciBQYWdlciA9IHJlcXVpcmUoJy4vUGFnZXInKTtcbnZhciBPcHRpb25zID0gcmVxdWlyZSgnLi9PcHRpb25zJyk7XG52YXIgS0VZQ09ERSA9IHJlcXVpcmUoJy4vS2V5Q29kZScpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xudmFyIGkxOG4gPSByZXF1aXJlKCcuL2xvY2FsZScpO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxudmFyIFBhZ2luYXRpb24gPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUGFnaW5hdGlvbiwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUGFnaW5hdGlvbihwcm9wcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQYWdpbmF0aW9uKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBjdXJyZW50OiBwcm9wcy5jdXJyZW50LFxuICAgICAgX2N1cnJlbnQ6IHByb3BzLmN1cnJlbnQsXG4gICAgICBwYWdlU2l6ZTogcHJvcHMucGFnZVNpemVcbiAgICB9O1xuXG4gICAgWydyZW5kZXInLCAnX2hhbmRsZUNoYW5nZScsICdfaGFuZGxlS2V5VXAnLCAnX2hhbmRsZUtleURvd24nLCAnX2NoYW5nZVBhZ2VTaXplJywgJ19pc1ZhbGlkJywgJ19wcmV2JywgJ19uZXh0JywgJ19oYXNQcmV2JywgJ19oYXNOZXh0JywgJ19qdW1wUHJldicsICdfanVtcE5leHQnXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgIHJldHVybiBfdGhpc1ttZXRob2RdID0gX3RoaXNbbWV0aG9kXS5iaW5kKF90aGlzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBQYWdpbmF0aW9uLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICBpZiAobmV4dFByb3BzLmN1cnJlbnQgIT0gdGhpcy5wcm9wcy5jdXJyZW50KSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgY3VycmVudDogbmV4dFByb3BzLmN1cnJlbnQsXG4gICAgICAgIF9jdXJyZW50OiBuZXh0UHJvcHMuY3VycmVudFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG5leHRQcm9wcy5wYWdlU2l6ZSAhPSB0aGlzLnByb3BzLnBhZ2VTaXplKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgcGFnZVNpemU6IG5leHRQcm9wcy5wYWdlU2l6ZVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIFBhZ2luYXRpb24ucHJvdG90eXBlLnJlbmRlclRvdGFsID0gZnVuY3Rpb24gcmVuZGVyVG90YWwoKSB7XG4gICAgdmFyIHByZWZpeCA9IHRoaXMucHJvcHMubG9jYWxlID09ICd6aC1jbicgPyBcIuWFsVwiIDogXCJcIjtcbiAgICBpZiAodGhpcy5wcm9wcy5zaG93VG90YWwpIHtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnbGknLFxuICAgICAgICB7IGNsYXNzTmFtZTogdGhpcy5wcm9wcy5wcmVmaXhDbHMgKyBcIi10b3RhbFwiIH0sXG4gICAgICAgIHByZWZpeCArIHRoaXMucHJvcHMudG90YWwgKyBpMThuW3RoaXMucHJvcHMubG9jYWxlXVsnaXRlbSddXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICBQYWdpbmF0aW9uLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcblxuICAgIHZhciBwcmVmaXhDbHMgPSBwcm9wcy5wcmVmaXhDbHM7XG4gICAgdmFyIGFsbFBhZ2VzID0gdGhpcy5fY2FsY1BhZ2UoKTtcbiAgICB2YXIgcGFnZXJMaXN0ID0gW107XG4gICAgdmFyIGp1bXBQcmV2ID0gbnVsbDtcbiAgICB2YXIganVtcE5leHQgPSBudWxsO1xuICAgIHZhciBmaXJzdFBhZ2VyID0gbnVsbDtcbiAgICB2YXIgbGFzdFBhZ2VyID0gbnVsbDtcblxuICAgIGlmIChwcm9wcy5zaW1wbGUpIHtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAndWwnLFxuICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJyAnICsgcHJlZml4Q2xzICsgJy1zaW1wbGUgJyArIHByb3BzLmNsYXNzTmFtZSB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICdkaXYnLFxuICAgICAgICAgIHsgdGl0bGU6ICdQYWdlICcgKyB0aGlzLnN0YXRlLmN1cnJlbnQgKyAnIG9mICcgKyBhbGxQYWdlcywgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLXNpbXBsZS1wYWdlcicgfSxcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctY3VycmVudCcgfSxcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuX2N1cnJlbnRcbiAgICAgICAgICApLFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1zbGFzaCcgfSxcbiAgICAgICAgICAgICcvJ1xuICAgICAgICAgICksXG4gICAgICAgICAgYWxsUGFnZXNcbiAgICAgICAgKSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnbGknLFxuICAgICAgICAgIHsgdGl0bGU6ICdQcmV2aW91cyBQYWdlJywgb25DbGljazogdGhpcy5fcHJldiwgY2xhc3NOYW1lOiAodGhpcy5faGFzUHJldigpID8gJycgOiBwcmVmaXhDbHMgKyAnLWRpc2FibGVkICcpICsgKHByZWZpeENscyArICctcHJldicpIH0sXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnYScsIHsgY2xhc3NOYW1lOiAna3VtYS1pY29uIGt1bWEtaWNvbi10cmlhbmdsZS1sZWZ0JyB9KVxuICAgICAgICApLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICdsaScsXG4gICAgICAgICAgeyB0aXRsZTogJ05leHQgUGFnZScsIG9uQ2xpY2s6IHRoaXMuX25leHQsIGNsYXNzTmFtZTogKHRoaXMuX2hhc05leHQoKSA/ICcnIDogcHJlZml4Q2xzICsgJy1kaXNhYmxlZCAnKSArIChwcmVmaXhDbHMgKyAnLW5leHQnKSB9LFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2EnLCB7IGNsYXNzTmFtZTogJ2t1bWEtaWNvbiBrdW1hLWljb24tdHJpYW5nbGUtcmlnaHQnIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGFsbFBhZ2VzIDw9IDkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IGFsbFBhZ2VzOyBpKyspIHtcbiAgICAgICAgdmFyIGFjdGl2ZSA9IHRoaXMuc3RhdGUuY3VycmVudCA9PT0gaTtcbiAgICAgICAgcGFnZXJMaXN0LnB1c2goUmVhY3QuY3JlYXRlRWxlbWVudChQYWdlciwgeyByb290UHJlZml4Q2xzOiBwcmVmaXhDbHMsIG9uQ2xpY2s6IHRoaXMuX2hhbmRsZUNoYW5nZS5iaW5kKHRoaXMsIGkpLCBrZXk6IGksIHBhZ2U6IGksIGFjdGl2ZTogYWN0aXZlIH0pKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAganVtcFByZXYgPSBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnbGknLFxuICAgICAgICB7IHRpdGxlOiAnUHJldmlvdXMgNSBQYWdlJywga2V5OiAncHJldicsIG9uQ2xpY2s6IHRoaXMuX2p1bXBQcmV2LCBjbGFzc05hbWU6IHByZWZpeENscyArICctanVtcC1wcmV2JyB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdhJywgbnVsbClcbiAgICAgICk7XG4gICAgICBqdW1wTmV4dCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdsaScsXG4gICAgICAgIHsgdGl0bGU6ICdOZXh0IDUgUGFnZScsIGtleTogJ25leHQnLCBvbkNsaWNrOiB0aGlzLl9qdW1wTmV4dCwgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWp1bXAtbmV4dCcgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnYScsIG51bGwpXG4gICAgICApO1xuICAgICAgbGFzdFBhZ2VyID0gUmVhY3QuY3JlYXRlRWxlbWVudChQYWdlciwgeyBsYXN0OiB0cnVlLCByb290UHJlZml4Q2xzOiBwcmVmaXhDbHMsIG9uQ2xpY2s6IHRoaXMuX2hhbmRsZUNoYW5nZS5iaW5kKHRoaXMsIGFsbFBhZ2VzKSwga2V5OiBhbGxQYWdlcywgcGFnZTogYWxsUGFnZXMsIGFjdGl2ZTogZmFsc2UgfSk7XG4gICAgICBmaXJzdFBhZ2VyID0gUmVhY3QuY3JlYXRlRWxlbWVudChQYWdlciwgeyByb290UHJlZml4Q2xzOiBwcmVmaXhDbHMsIG9uQ2xpY2s6IHRoaXMuX2hhbmRsZUNoYW5nZS5iaW5kKHRoaXMsIDEpLCBrZXk6IDEsIHBhZ2U6IDEsIGFjdGl2ZTogZmFsc2UgfSk7XG5cbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5zdGF0ZS5jdXJyZW50O1xuXG4gICAgICB2YXIgbGVmdCA9IE1hdGgubWF4KDEsIGN1cnJlbnQgLSAyKTtcbiAgICAgIHZhciByaWdodCA9IE1hdGgubWluKGN1cnJlbnQgKyAyLCBhbGxQYWdlcyk7XG5cbiAgICAgIGlmIChjdXJyZW50IC0gMSA8PSAyKSB7XG4gICAgICAgIHJpZ2h0ID0gMSArIDQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbGxQYWdlcyAtIGN1cnJlbnQgPD0gMikge1xuICAgICAgICBsZWZ0ID0gYWxsUGFnZXMgLSA0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfaSA9IGxlZnQ7IF9pIDw9IHJpZ2h0OyBfaSsrKSB7XG4gICAgICAgIHZhciBfYWN0aXZlID0gY3VycmVudCA9PT0gX2k7XG4gICAgICAgIHBhZ2VyTGlzdC5wdXNoKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUGFnZXIsIHsgcm9vdFByZWZpeENsczogcHJlZml4Q2xzLCBvbkNsaWNrOiB0aGlzLl9oYW5kbGVDaGFuZ2UuYmluZCh0aGlzLCBfaSksIGtleTogX2ksIHBhZ2U6IF9pLCBhY3RpdmU6IF9hY3RpdmUgfSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudCAtIDEgPj0gNCkge1xuICAgICAgICBwYWdlckxpc3QudW5zaGlmdChqdW1wUHJldik7XG4gICAgICB9XG4gICAgICBpZiAoYWxsUGFnZXMgLSBjdXJyZW50ID49IDQpIHtcbiAgICAgICAgcGFnZXJMaXN0LnB1c2goanVtcE5leHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAobGVmdCAhPT0gMSkge1xuICAgICAgICBwYWdlckxpc3QudW5zaGlmdChmaXJzdFBhZ2VyKTtcbiAgICAgIH1cbiAgICAgIGlmIChyaWdodCAhPT0gYWxsUGFnZXMpIHtcbiAgICAgICAgcGFnZXJMaXN0LnB1c2gobGFzdFBhZ2VyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICd1bCcsXG4gICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJyAnICsgcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgICB1bnNlbGVjdGFibGU6ICd1bnNlbGVjdGFibGUnIH0sXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnbGknLFxuICAgICAgICB7IHRpdGxlOiAnUHJldmlvdXMgUGFnZScsIG9uQ2xpY2s6IHRoaXMuX3ByZXYsIGNsYXNzTmFtZTogKHRoaXMuX2hhc1ByZXYoKSA/ICcnIDogcHJlZml4Q2xzICsgJy1kaXNhYmxlZCAnKSArIChwcmVmaXhDbHMgKyAnLXByZXYnKSB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdhJywgeyBjbGFzc05hbWU6ICdrdW1hLWljb24ga3VtYS1pY29uLXRyaWFuZ2xlLWxlZnQnIH0pXG4gICAgICApLFxuICAgICAgcGFnZXJMaXN0LFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2xpJyxcbiAgICAgICAgeyB0aXRsZTogJ05leHQgUGFnZScsIG9uQ2xpY2s6IHRoaXMuX25leHQsIGNsYXNzTmFtZTogKHRoaXMuX2hhc05leHQoKSA/ICcnIDogcHJlZml4Q2xzICsgJy1kaXNhYmxlZCAnKSArIChwcmVmaXhDbHMgKyAnLW5leHQnKSB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdhJywgeyBjbGFzc05hbWU6ICdrdW1hLWljb24ga3VtYS1pY29uLXRyaWFuZ2xlLXJpZ2h0JyB9KVxuICAgICAgKSxcbiAgICAgIHRoaXMucmVuZGVyVG90YWwoKSxcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoT3B0aW9ucywgeyByb290UHJlZml4Q2xzOiBwcmVmaXhDbHMsXG4gICAgICAgIGxvY2FsZTogcHJvcHMubG9jYWxlLFxuICAgICAgICBzZWxlY3RDb21wb25lbnRDbGFzczogcHJvcHMuc2VsZWN0Q29tcG9uZW50Q2xhc3MsXG4gICAgICAgIHNlbGVjdFByZWZpeENsczogcHJvcHMuc2VsZWN0UHJlZml4Q2xzLFxuICAgICAgICBjaGFuZ2VTaXplOiB0aGlzLnByb3BzLnNob3dTaXplQ2hhbmdlciA/IHRoaXMuX2NoYW5nZVBhZ2VTaXplLmJpbmQodGhpcykgOiBudWxsLFxuICAgICAgICBjdXJyZW50OiB0aGlzLnN0YXRlLmN1cnJlbnQsXG4gICAgICAgIHBhZ2VTaXplOiBwcm9wcy5wYWdlU2l6ZSxcbiAgICAgICAgc2l6ZU9wdGlvbnM6IHByb3BzLnNpemVPcHRpb25zLFxuICAgICAgICBxdWlja0dvOiB0aGlzLnByb3BzLnNob3dRdWlja0p1bXBlciA/IHRoaXMuX2hhbmRsZUNoYW5nZS5iaW5kKHRoaXMpIDogbnVsbCB9KVxuICAgICk7XG4gIH07XG5cbiAgLy8gcHJpdmF0ZSBtZXRob2RzXG5cbiAgUGFnaW5hdGlvbi5wcm90b3R5cGUuX2NhbGNQYWdlID0gZnVuY3Rpb24gX2NhbGNQYWdlKHApIHtcbiAgICB2YXIgcGFnZVNpemUgPSBwO1xuICAgIGlmICh0eXBlb2YgcGFnZVNpemUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwYWdlU2l6ZSA9IHRoaXMuc3RhdGUucGFnZVNpemU7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmZsb29yKCh0aGlzLnByb3BzLnRvdGFsIC0gMSkgLyBwYWdlU2l6ZSkgKyAxO1xuICB9O1xuXG4gIFBhZ2luYXRpb24ucHJvdG90eXBlLl9pc1ZhbGlkID0gZnVuY3Rpb24gX2lzVmFsaWQocGFnZSkge1xuICAgIHJldHVybiB0eXBlb2YgcGFnZSA9PT0gJ251bWJlcicgJiYgcGFnZSA+PSAxICYmIHBhZ2UgIT09IHRoaXMuc3RhdGUuY3VycmVudDtcbiAgfTtcblxuICBQYWdpbmF0aW9uLnByb3RvdHlwZS5faGFuZGxlS2V5RG93biA9IGZ1bmN0aW9uIF9oYW5kbGVLZXlEb3duKGV2dCkge1xuICAgIGlmIChldnQua2V5Q29kZSA9PT0gS0VZQ09ERS5BUlJPV19VUCB8fCBldnQua2V5Q29kZSA9PT0gS0VZQ09ERS5BUlJPV19ET1dOKSB7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH07XG5cbiAgUGFnaW5hdGlvbi5wcm90b3R5cGUuX2hhbmRsZUtleVVwID0gZnVuY3Rpb24gX2hhbmRsZUtleVVwKGV2dCkge1xuICAgIHZhciBfdmFsID0gZXZ0LnRhcmdldC52YWx1ZTtcbiAgICB2YXIgdmFsID0gdm9pZCAwO1xuXG4gICAgaWYgKF92YWwgPT09ICcnKSB7XG4gICAgICB2YWwgPSBfdmFsO1xuICAgIH0gZWxzZSBpZiAoaXNOYU4oTnVtYmVyKF92YWwpKSkge1xuICAgICAgdmFsID0gdGhpcy5zdGF0ZS5fY3VycmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsID0gTnVtYmVyKF92YWwpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgX2N1cnJlbnQ6IHZhbFxuICAgIH0pO1xuXG4gICAgaWYgKGV2dC5rZXlDb2RlID09PSBLRVlDT0RFLkVOVEVSKSB7XG4gICAgICB0aGlzLl9oYW5kbGVDaGFuZ2UodmFsKTtcbiAgICB9IGVsc2UgaWYgKGV2dC5rZXlDb2RlID09PSBLRVlDT0RFLkFSUk9XX1VQKSB7XG4gICAgICB0aGlzLl9oYW5kbGVDaGFuZ2UodmFsIC0gMSk7XG4gICAgfSBlbHNlIGlmIChldnQua2V5Q29kZSA9PT0gS0VZQ09ERS5BUlJPV19ET1dOKSB7XG4gICAgICB0aGlzLl9oYW5kbGVDaGFuZ2UodmFsICsgMSk7XG4gICAgfVxuICB9O1xuXG4gIFBhZ2luYXRpb24ucHJvdG90eXBlLl9jaGFuZ2VQYWdlU2l6ZSA9IGZ1bmN0aW9uIF9jaGFuZ2VQYWdlU2l6ZShzaXplKSB7XG4gICAgaWYgKHR5cGVvZiBzaXplID09PSAnbnVtYmVyJykge1xuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLnN0YXRlLmN1cnJlbnQ7XG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBwYWdlU2l6ZTogc2l6ZVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLnN0YXRlLmN1cnJlbnQgPiB0aGlzLl9jYWxjUGFnZShzaXplKSkge1xuICAgICAgICBjdXJyZW50ID0gdGhpcy5fY2FsY1BhZ2Uoc2l6ZSk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIGN1cnJlbnQ6IGN1cnJlbnQsXG4gICAgICAgICAgX2N1cnJlbnQ6IGN1cnJlbnRcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHJvcHMub25TaG93U2l6ZUNoYW5nZShjdXJyZW50LCBzaXplKTtcbiAgICB9XG4gIH07XG5cbiAgUGFnaW5hdGlvbi5wcm90b3R5cGUuX2hhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIF9oYW5kbGVDaGFuZ2UocCkge1xuICAgIHZhciBwYWdlID0gcDtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIGlmICh0aGlzLl9pc1ZhbGlkKHBhZ2UpKSB7XG4gICAgICBpZiAocGFnZSA+IHRoaXMuX2NhbGNQYWdlKCkpIHtcbiAgICAgICAgcGFnZSA9IHRoaXMuX2NhbGNQYWdlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgY3VycmVudDogcGFnZSxcbiAgICAgICAgX2N1cnJlbnQ6IHBhZ2VcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWUucHJvcHMub25DaGFuZ2UocGFnZSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHBhZ2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuY3VycmVudDtcbiAgfTtcblxuICBQYWdpbmF0aW9uLnByb3RvdHlwZS5fcHJldiA9IGZ1bmN0aW9uIF9wcmV2KCkge1xuICAgIGlmICh0aGlzLl9oYXNQcmV2KCkpIHtcbiAgICAgIHRoaXMuX2hhbmRsZUNoYW5nZSh0aGlzLnN0YXRlLmN1cnJlbnQgLSAxKTtcbiAgICB9XG4gIH07XG5cbiAgUGFnaW5hdGlvbi5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiBfbmV4dCgpIHtcbiAgICBpZiAodGhpcy5faGFzTmV4dCgpKSB7XG4gICAgICB0aGlzLl9oYW5kbGVDaGFuZ2UodGhpcy5zdGF0ZS5jdXJyZW50ICsgMSk7XG4gICAgfVxuICB9O1xuXG4gIFBhZ2luYXRpb24ucHJvdG90eXBlLl9qdW1wUHJldiA9IGZ1bmN0aW9uIF9qdW1wUHJldigpIHtcbiAgICB0aGlzLl9oYW5kbGVDaGFuZ2UoTWF0aC5tYXgoMSwgdGhpcy5zdGF0ZS5jdXJyZW50IC0gNSkpO1xuICB9O1xuXG4gIFBhZ2luYXRpb24ucHJvdG90eXBlLl9qdW1wTmV4dCA9IGZ1bmN0aW9uIF9qdW1wTmV4dCgpIHtcbiAgICB0aGlzLl9oYW5kbGVDaGFuZ2UoTWF0aC5taW4odGhpcy5fY2FsY1BhZ2UoKSwgdGhpcy5zdGF0ZS5jdXJyZW50ICsgNSkpO1xuICB9O1xuXG4gIFBhZ2luYXRpb24ucHJvdG90eXBlLl9oYXNQcmV2ID0gZnVuY3Rpb24gX2hhc1ByZXYoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuY3VycmVudCA+IDE7XG4gIH07XG5cbiAgUGFnaW5hdGlvbi5wcm90b3R5cGUuX2hhc05leHQgPSBmdW5jdGlvbiBfaGFzTmV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5jdXJyZW50IDwgdGhpcy5fY2FsY1BhZ2UoKTtcbiAgfTtcblxuICByZXR1cm4gUGFnaW5hdGlvbjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuUGFnaW5hdGlvbi5wcm9wVHlwZXMgPSB7XG4gIGN1cnJlbnQ6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gIHRvdGFsOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICBsb2NhbGU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gIHNob3dUb3RhbDogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gIHBhZ2VTaXplOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICBzaXplT3B0aW9uczogUmVhY3QuUHJvcFR5cGVzLmFycmF5LFxuICBvbkNoYW5nZTogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gIHNob3dTaXplQ2hhbmdlcjogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gIG9uU2hvd1NpemVDaGFuZ2U6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICBzZWxlY3RDb21wb25lbnRDbGFzczogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gIHNob3dRdWlja0p1bXBlcjogUmVhY3QuUHJvcFR5cGVzLmJvb2xcbn07XG5cblBhZ2luYXRpb24uZGVmYXVsdFByb3BzID0ge1xuICBjdXJyZW50OiAxLFxuICB0b3RhbDogMCxcbiAgbG9jYWxlOiAnemgtY24nLFxuICBzaG93VG90YWw6IGZhbHNlLFxuICBwYWdlU2l6ZTogMTAsXG4gIHNpemVPcHRpb25zOiBbMTAsIDIwLCAzMCwgNDBdLFxuICBvbkNoYW5nZTogbm9vcCxcbiAgY2xhc3NOYW1lOiAnJyxcbiAgc2VsZWN0UHJlZml4Q2xzOiAna3VtYS1zZWxlY3QyJyxcbiAgcHJlZml4Q2xzOiAna3VtYS1wYWdlJyxcbiAgc2VsZWN0Q29tcG9uZW50Q2xhc3M6IFNlbGVjdCxcbiAgc2hvd1F1aWNrSnVtcGVyOiBmYWxzZSxcbiAgc2hvd1NpemVDaGFuZ2VyOiBmYWxzZSxcbiAgb25TaG93U2l6ZUNoYW5nZTogbm9vcFxufTtcblxuUGFnaW5hdGlvbi5kaXNwbGF5TmFtZSA9ICdQYWdpbmF0aW9uJztcblxubW9kdWxlLmV4cG9ydHMgPSBQYWdpbmF0aW9uO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtcGFnaW5hdGlvbi9idWlsZC9QYWdpbmF0aW9uLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIFBhZ2VyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFBhZ2VyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBQYWdlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGFnZXIpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBQYWdlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHByZWZpeENscyA9IHByb3BzLnJvb3RQcmVmaXhDbHMgKyAnLWl0ZW0nO1xuICAgIHZhciBjbHMgPSBwcmVmaXhDbHMgKyAnICcgKyBwcmVmaXhDbHMgKyAnLScgKyBwcm9wcy5wYWdlO1xuXG4gICAgaWYgKHByb3BzLmFjdGl2ZSkge1xuICAgICAgY2xzID0gY2xzICsgJyAnICsgcHJlZml4Q2xzICsgJy1hY3RpdmUnO1xuICAgIH1cblxuICAgIHZhciB0aXRsZSA9IHZvaWQgMDtcbiAgICBpZiAocHJvcHMucGFnZSA9PT0gMSkge1xuICAgICAgdGl0bGUgPSAnRmlyc3QgUGFnZSc7XG4gICAgfSBlbHNlIGlmIChwcm9wcy5sYXN0KSB7XG4gICAgICB0aXRsZSA9ICdMYXN0IFBhZ2U6ICcgKyBwcm9wcy5wYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZSA9ICdQYWdlICcgKyBwcm9wcy5wYWdlO1xuICAgIH1cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICdsaScsXG4gICAgICB7IHRpdGxlOiB0aXRsZSwgY2xhc3NOYW1lOiBjbHMsIG9uQ2xpY2s6IHByb3BzLm9uQ2xpY2sgfSxcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdhJyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcHJvcHMucGFnZVxuICAgICAgKVxuICAgICk7XG4gIH07XG5cbiAgcmV0dXJuIFBhZ2VyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5QYWdlci5wcm9wVHlwZXMgPSB7XG4gIHBhZ2U6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gIGFjdGl2ZTogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gIGxhc3Q6IFJlYWN0LlByb3BUeXBlcy5ib29sXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhZ2VyO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtcGFnaW5hdGlvbi9idWlsZC9QYWdlci5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG52YXIgS0VZQ09ERSA9IHJlcXVpcmUoJy4vS2V5Q29kZScpO1xudmFyIGkxOG4gPSByZXF1aXJlKCcuL2xvY2FsZScpO1xuXG52YXIgT3B0aW9ucyA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhPcHRpb25zLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBPcHRpb25zKHByb3BzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE9wdGlvbnMpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGN1cnJlbnQ6IHByb3BzLmN1cnJlbnQsXG4gICAgICBfY3VycmVudDogcHJvcHMuY3VycmVudFxuICAgIH07XG5cbiAgICBbJ19oYW5kbGVDaGFuZ2UnLCAnX2NoYW5nZVNpemUnLCAnX2dvJ10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICByZXR1cm4gX3RoaXNbbWV0aG9kXSA9IF90aGlzW21ldGhvZF0uYmluZChfdGhpcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgT3B0aW9ucy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHZhciBwcmVmaXhDbHMgPSBwcm9wcy5yb290UHJlZml4Q2xzICsgJy1vcHRpb25zJztcbiAgICB2YXIgc2l6ZU9wdGlvbnMgPSBwcm9wcy5zaXplT3B0aW9ucztcbiAgICB2YXIgcGFnZVNpemUgPSBwcm9wcy5wYWdlU2l6ZTtcbiAgICB2YXIgY2hhbmdlU2l6ZSA9IHByb3BzLmNoYW5nZVNpemU7XG4gICAgdmFyIHF1aWNrR28gPSBwcm9wcy5xdWlja0dvO1xuICAgIHZhciBTZWxlY3QgPSBwcm9wcy5zZWxlY3RDb21wb25lbnRDbGFzcztcbiAgICB2YXIgY2hhbmdlU2VsZWN0ID0gbnVsbDtcbiAgICB2YXIgZ29JbnB1dCA9IG51bGw7XG5cbiAgICBpZiAoIShjaGFuZ2VTaXplIHx8IHF1aWNrR28pKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoY2hhbmdlU2l6ZSAmJiBTZWxlY3QpIHtcbiAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBPcHRpb24gPSBTZWxlY3QuT3B0aW9uO1xuICAgICAgICBjaGFuZ2VTZWxlY3QgPSBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIFNlbGVjdCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwcmVmaXhDbHM6IHByb3BzLnNlbGVjdFByZWZpeENscywgc2hvd1NlYXJjaDogZmFsc2UsXG4gICAgICAgICAgICBjbGFzc05hbWU6IHByZWZpeENscyArICctc2l6ZS1jaGFuZ2VyJyxcbiAgICAgICAgICAgIG9wdGlvbkxhYmVsUHJvcDogJ2NoaWxkcmVuJyxcbiAgICAgICAgICAgIGRyb3Bkb3duQ2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLXNpemUtY2hhbmdlci1kcm9wZG93bicsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHNpemVPcHRpb25zLmluZGV4T2YocGFnZVNpemUpID09IC0xID8gc2l6ZU9wdGlvbnNbMF0gKyBcIlwiIDogcGFnZVNpemUgKyBcIlwiLFxuICAgICAgICAgICAgb25DaGFuZ2U6IF90aGlzMi5fY2hhbmdlU2l6ZSB9LFxuICAgICAgICAgIHNpemVPcHRpb25zLm1hcChmdW5jdGlvbiAob3B0aW9uLCBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgIE9wdGlvbixcbiAgICAgICAgICAgICAgeyBrZXk6IG9wdGlvbiwgdmFsdWU6IG9wdGlvbiArIFwiXCIgfSxcbiAgICAgICAgICAgICAgb3B0aW9uICsgaTE4bltwcm9wcy5sb2NhbGVdWydpdGVtc19wZXJfcGFnZSddXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9KSgpO1xuICAgIH1cblxuICAgIGlmIChxdWlja0dvKSB7XG4gICAgICBnb0lucHV0ID0gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIHsgdGl0bGU6ICdRdWljayBqdW1wIHRvIHBhZ2UnLCBjbGFzc05hbWU6IHByZWZpeENscyArICctcXVpY2stanVtcGVyJyB9LFxuICAgICAgICBpMThuW3Byb3BzLmxvY2FsZV1bJ2p1bXBfdG8nXSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnaW5wdXQnLCB7IHR5cGU6ICd0ZXh0JywgdmFsdWU6IHN0YXRlLl9jdXJyZW50LCBvbkNoYW5nZTogdGhpcy5faGFuZGxlQ2hhbmdlLmJpbmQodGhpcyksIG9uS2V5VXA6IHRoaXMuX2dvLmJpbmQodGhpcykgfSksXG4gICAgICAgIGkxOG5bcHJvcHMubG9jYWxlXVsncGFnZSddXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgJ2RpdicsXG4gICAgICB7IGNsYXNzTmFtZTogJycgKyBwcmVmaXhDbHMgfSxcbiAgICAgIGNoYW5nZVNlbGVjdCxcbiAgICAgIGdvSW5wdXRcbiAgICApO1xuICB9O1xuXG4gIE9wdGlvbnMucHJvdG90eXBlLl9jaGFuZ2VTaXplID0gZnVuY3Rpb24gX2NoYW5nZVNpemUodmFsdWUpIHtcbiAgICB0aGlzLnByb3BzLmNoYW5nZVNpemUoTnVtYmVyKHZhbHVlKSk7XG4gIH07XG5cbiAgT3B0aW9ucy5wcm90b3R5cGUuX2hhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIF9oYW5kbGVDaGFuZ2UoZXZ0KSB7XG4gICAgdmFyIF92YWwgPSBldnQudGFyZ2V0LnZhbHVlO1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBfY3VycmVudDogX3ZhbFxuICAgIH0pO1xuICB9O1xuXG4gIE9wdGlvbnMucHJvdG90eXBlLl9nbyA9IGZ1bmN0aW9uIF9nbyhlKSB7XG4gICAgdmFyIF92YWwgPSBlLnRhcmdldC52YWx1ZTtcbiAgICBpZiAoX3ZhbCA9PT0gJycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHZhbCA9IE51bWJlcih0aGlzLnN0YXRlLl9jdXJyZW50KTtcbiAgICBpZiAoaXNOYU4odmFsKSkge1xuICAgICAgdmFsID0gdGhpcy5zdGF0ZS5jdXJyZW50O1xuICAgIH1cbiAgICBpZiAoZS5rZXlDb2RlID09PSBLRVlDT0RFLkVOVEVSKSB7XG4gICAgICB2YXIgYyA9IHRoaXMucHJvcHMucXVpY2tHbyh2YWwpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIF9jdXJyZW50OiBjLFxuICAgICAgICBjdXJyZW50OiBjXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIE9wdGlvbnM7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbk9wdGlvbnMucHJvcFR5cGVzID0ge1xuICBjaGFuZ2VTaXplOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgcXVpY2tHbzogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gIHNlbGVjdENvbXBvbmVudENsYXNzOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgY3VycmVudDogUmVhY3QuUHJvcFR5cGVzLm51bWJlclxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPcHRpb25zO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtcGFnaW5hdGlvbi9idWlsZC9PcHRpb25zLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBaRVJPOiA0OCxcbiAgTklORTogNTcsXG5cbiAgTlVNUEFEX1pFUk86IDk2LFxuICBOVU1QQURfTklORTogMTA1LFxuXG4gIEJBQ0tTUEFDRTogOCxcbiAgREVMRVRFOiA0NixcbiAgRU5URVI6IDEzLFxuXG4gIEFSUk9XX1VQOiAzOCxcbiAgQVJST1dfRE9XTjogNDBcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1wYWdpbmF0aW9uL2J1aWxkL0tleUNvZGUuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBsb2NhbGUgPSB7XG4gICAgXCJlbi11c1wiOiB7XG4gICAgICAgIGl0ZW1zX3Blcl9wYWdlOiAnL3BhZ2UnLFxuICAgICAgICBqdW1wX3RvOiAnR290bycsXG4gICAgICAgIHBhZ2U6ICcnLFxuXG4gICAgICAgIC8vIFBhZ2luYXRpb24uanNcbiAgICAgICAgaXRlbTogJyBlbnRyaWVzJ1xuICAgIH0sXG4gICAgXCJ6aC1jblwiOiB7XG4gICAgICAgIC8vIE9wdGlvbnMuanNcbiAgICAgICAgaXRlbXNfcGVyX3BhZ2U6ICfmnaEv6aG1JyxcbiAgICAgICAganVtcF90bzogJ+i3s+iHsycsXG4gICAgICAgIHBhZ2U6ICfpobUnLFxuXG4gICAgICAgIC8vIFBhZ2luYXRpb24uanNcbiAgICAgICAgaXRlbTogJ+adoSdcbiAgICB9XG59O1xubG9jYWxlWydlbiddID0gbG9jYWxlWydlbi11cyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxvY2FsZTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLXBhZ2luYXRpb24vYnVpbGQvbG9jYWxlLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFBvcG92ZXIgQ29tcG9uZW50IGZvciB1eGNvcmVcbiAqIEBhdXRob3IgZXRlcm5hbHNreVxuICpcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIFV4Y29yZSBUZWFtLCBBbGludy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL1BvcG92ZXInKTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLXBvcG92ZXIvYnVpbGQvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBQb3BvdmVyIENvbXBvbmVudCBmb3IgdXhjb3JlXG4gKiBAYXV0aG9yIGV0ZXJuYWxza3lcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBVeGNvcmUgVGVhbSwgQWxpbncuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIFRvb2x0aXAgPSByZXF1aXJlKFwicmMtdG9vbHRpcFwiKTtcbnZhciBCdXR0b24gPSByZXF1aXJlKFwidXhjb3JlLWJ1dHRvblwiKTtcblxudmFyIFBvcG92ZXIgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhQb3BvdmVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIFBvcG92ZXIocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBvcG92ZXIpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgdmlzaWJsZTogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIFBvcG92ZXIucHJvdG90eXBlLmhhbmRsZU9rQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVPa0NsaWNrKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBtZS5wcm9wcy5vbk9rKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG1lLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBQb3BvdmVyLnByb3RvdHlwZS5oYW5kbGVDYW5jZWxDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNhbmNlbENsaWNrKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBtZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICB2aXNpYmxlOiBmYWxzZVxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBtZS5wcm9wcy5vbkNhbmNlbCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgUG9wb3Zlci5wcm90b3R5cGUuaGFuZGxlVmlzaWJsZUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZVZpc2libGVDaGFuZ2UodmlzaWJsZSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHZpc2libGU6IHZpc2libGVcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIFBvcG92ZXIucHJvdG90eXBlLl9yZW5kZXJCdXR0b24gPSBmdW5jdGlvbiBfcmVuZGVyQnV0dG9uKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBpZiAobWUucHJvcHMuc2hvd0J1dHRvbikge1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6IG1lLnByb3BzLnByZWZpeENscyArIFwiLWJ1dHRvbi1ncm91cFwiIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgQnV0dG9uLFxuICAgICAgICAgICAgICAgICAgICB7IHNpemU6ICdzbWFsbCcsIHR5cGU6ICdwcmltYXJ5Jywgb25DbGljazogbWUuaGFuZGxlT2tDbGljay5iaW5kKG1lKSB9LFxuICAgICAgICAgICAgICAgICAgICBtZS5wcm9wcy5va1RleHRcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgIEJ1dHRvbixcbiAgICAgICAgICAgICAgICAgICAgeyBzaXplOiAnc21hbGwnLCB0eXBlOiAnc2Vjb25kYXJ5Jywgb25DbGljazogbWUuaGFuZGxlQ2FuY2VsQ2xpY2suYmluZChtZSkgfSxcbiAgICAgICAgICAgICAgICAgICAgbWUucHJvcHMuY2FuY2VsVGV4dFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgUG9wb3Zlci5wcm90b3R5cGUuX2dlbmVyYXRlT3ZlcmxheSA9IGZ1bmN0aW9uIF9nZW5lcmF0ZU92ZXJsYXkoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgICAgaWYgKG1lLnByb3BzLnRpdGxlKSB7XG4gICAgICAgICAgICBhcnIucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgIHsga2V5OiAndGl0bGUnLCBjbGFzc05hbWU6IG1lLnByb3BzLnByZWZpeENscyArICctdGl0bGUnIH0sXG4gICAgICAgICAgICAgICAgbWUucHJvcHMudGl0bGVcbiAgICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZS5wcm9wcy5vdmVybGF5KSB7XG4gICAgICAgICAgICBhcnIucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgIHsga2V5OiAnY29udGVudCcsIGNsYXNzTmFtZTogbWUucHJvcHMucHJlZml4Q2xzICsgJy1jb250ZW50JyB9LFxuICAgICAgICAgICAgICAgIG1lLnByb3BzLm92ZXJsYXksXG4gICAgICAgICAgICAgICAgbWUuX3JlbmRlckJ1dHRvbigpXG4gICAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIGFyclxuICAgICAgICApO1xuICAgIH07XG5cbiAgICBQb3BvdmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBUb29sdGlwLFxuICAgICAgICAgICAgeyBwbGFjZW1lbnQ6IG1lLnByb3BzLnBsYWNlbWVudCxcbiAgICAgICAgICAgICAgICBvdmVybGF5Q2xhc3NOYW1lOiBtZS5wcm9wcy5vdmVybGF5Q2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIHByZWZpeENsczogbWUucHJvcHMucHJlZml4Q2xzLFxuICAgICAgICAgICAgICAgIHZpc2libGU6IG1lLnN0YXRlLnZpc2libGUsXG4gICAgICAgICAgICAgICAgb25WaXNpYmxlQ2hhbmdlOiBtZS5oYW5kbGVWaXNpYmxlQ2hhbmdlLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgIGRlbGF5OiBtZS5wcm9wcy5kZWxheSxcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uTmFtZTogbWUucHJvcHMudHJhbnNpdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgdHJpZ2dlcjogbWUucHJvcHMudHJpZ2dlcixcbiAgICAgICAgICAgICAgICBvdmVybGF5OiBtZS5fZ2VuZXJhdGVPdmVybGF5KCkgfSxcbiAgICAgICAgICAgIG1lLnByb3BzLmNoaWxkcmVuXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHJldHVybiBQb3BvdmVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5Qb3BvdmVyLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBwcmVmaXhDbHM6ICdrdW1hLXBvcG92ZXInLFxuICAgIGRlbGF5OiAwLFxuICAgIHBsYWNlbWVudDogXCJ0b3BcIixcbiAgICB0cmlnZ2VyOiBcImhvdmVyXCIsXG4gICAgb25PazogZnVuY3Rpb24gb25PayhjYikge1xuICAgICAgICBjYigpO1xuICAgIH0sXG4gICAgb25DYW5jZWw6IGZ1bmN0aW9uIG9uQ2FuY2VsKCkge30sXG4gICAgb2tUZXh0OiBcIuehruWumlwiLFxuICAgIGNhbmNlbFRleHQ6IFwi5Y+W5raIXCIsXG4gICAgc2hvd0J1dHRvbjogZmFsc2Vcbn07XG5cbi8vIGh0dHA6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy9yZXVzYWJsZS1jb21wb25lbnRzLmh0bWxcblBvcG92ZXIucHJvcFR5cGVzID0ge1xuICAgIHByZWZpeENsczogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBkZWxheTogUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICBvdmVybGF5Q2xhc3NOYW1lOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHBsYWNlbWVudDogUmVhY3QuUHJvcFR5cGVzLm9uZU9mKFsndG9wJywgJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0JywgJ3RvcExlZnQnLCAnYm90dG9tTGVmdCcsICdsZWZ0VG9wJywgJ3JpZ2h0VG9wJywgJ3RvcFJpZ2h0JywgJ2JvdHRvbVJpZ2h0JywgJ2xlZnRCb3R0b20nLCAncmlnaHRCb3R0b20nXSksXG4gICAgdHJpZ2dlcjogUmVhY3QuUHJvcFR5cGVzLm9uZU9mKFsnaG92ZXInLCAnY2xpY2snXSksXG4gICAgb25PazogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25DYW5jZWw6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9rVGV4dDogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBjYW5jZWxUZXh0OiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHNob3dCdXR0b246IFJlYWN0LlByb3BUeXBlcy5ib29sXG59O1xuXG5Qb3BvdmVyLmRpc3BsYXlOYW1lID0gXCJQb3BvdmVyXCI7XG5cbm1vZHVsZS5leHBvcnRzID0gUG9wb3ZlcjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLXBvcG92ZXIvYnVpbGQvUG9wb3Zlci5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBQcm9ncmVzcyBDb21wb25lbnQgZm9yIHV4Y29yZVxuICogQGF1dGhvciB2aWNlbnQuYmlhblxuICpcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIFV4Y29yZSBUZWFtLCBBbGludy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIExpbmU6IHJlcXVpcmUoJy4vUHJvZ3Jlc3MnKSxcbiAgQ2lyY2xlOiByZXF1aXJlKCcuL0NpcmNsZScpXG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtcHJvZ3Jlc3MvYnVpbGQvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yZWFjdERvbSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgX3JlYWN0RG9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0RG9tKTtcblxudmFyIF9vYmplY3RBc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBfb2JqZWN0QXNzaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29iamVjdEFzc2lnbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogUHJvZ3Jlc3MgQ29tcG9uZW50IGZvciB1eGNvcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBhdXRob3IgdmluY2VudC5iaWFuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgVXhjb3JlIFRlYW0sIEFsaW53LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG5cbnZhciBwcmVmaXhDbHMgPSAna3VtYS1wcm9ncmVzcyc7XG5cbnZhciBMaW5lID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoTGluZSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBMaW5lKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGluZSk7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfVxuXG4gICAgTGluZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSAoMCwgX29iamVjdEFzc2lnbjJbXCJkZWZhdWx0XCJdKSh7fSwgdGhpcy5wcm9wcyk7XG5cbiAgICAgICAgaWYgKHBhcnNlSW50KHByb3BzLnBlcmNlbnQsIDEwKSA9PT0gMTAwKSB7XG4gICAgICAgICAgICBwcm9wcy5zdGF0dXMgPSAnc3VjY2Vzcyc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJvZ3Jlc3NJbmZvID0gdm9pZCAwO1xuICAgICAgICB2YXIgZnVsbENscyA9ICcnO1xuXG4gICAgICAgIGlmIChwcm9wcy5zaG93SW5mbyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHByb3BzLnN0YXR1cyA9PT0gJ2V4Y2VwdGlvbicpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0luZm8gPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWxpbmUtdGV4dCcgfSxcbiAgICAgICAgICAgICAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudCgnaScsIHsgY2xhc3NOYW1lOiAnaWNvbi1jYXV0aW9uJyB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BzLnN0YXR1cyA9PT0gJ3N1Y2Nlc3MnKSB7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NJbmZvID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1saW5lLXRleHQnIH0sXG4gICAgICAgICAgICAgICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoJ2knLCB7IGNsYXNzTmFtZTogJ2ljb24tc3VjY2VzcycgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0luZm8gPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWxpbmUtdGV4dCcgfSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMucGVyY2VudCxcbiAgICAgICAgICAgICAgICAgICAgJyUnXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZ1bGxDbHMgPSAnICcgKyBwcmVmaXhDbHMgKyAnLWxpbmUtd3JhcC1mdWxsJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwZXJjZW50U3R5bGUgPSB7XG4gICAgICAgICAgICB3aWR0aDogcHJvcHMucGVyY2VudCArICclJyxcbiAgICAgICAgICAgIGhlaWdodDogcHJvcHMuc3Ryb2tlV2lkdGhcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctbGluZS13cmFwIGZuLWNsZWFyIHN0YXR1cy0nICsgcHJvcHMuc3RhdHVzICsgZnVsbENscyB9LFxuICAgICAgICAgICAgcHJvZ3Jlc3NJbmZvLFxuICAgICAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1saW5lLW91dGVyJyB9LFxuICAgICAgICAgICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1saW5lLWlubmVyJyB9LFxuICAgICAgICAgICAgICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KCdkaXYnLCB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1saW5lLWJnJywgc3R5bGU6IHBlcmNlbnRTdHlsZSB9KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIExpbmU7XG59KF9yZWFjdDJbXCJkZWZhdWx0XCJdLkNvbXBvbmVudCk7XG5cbkxpbmUuZGlzcGxheU5hbWUgPSBcIlByb2dyZXNzLUxpbmVcIjtcbkxpbmUucHJvcFR5cGVzID0ge1xuICAgIHN0YXR1czogX3JlYWN0MltcImRlZmF1bHRcIl0uUHJvcFR5cGVzLm9uZU9mKFsnbm9ybWFsJywgJ2V4Y2VwdGlvbicsICdzdWNjZXNzJ10pLFxuICAgIHNob3dJbmZvOiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMuYm9vbCxcbiAgICBwZXJjZW50OiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMubnVtYmVyLFxuICAgIHN0cm9rZVdpZHRoOiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMubnVtYmVyXG59O1xuTGluZS5kZWZhdWx0UHJvcHMgPSB7XG4gICAgcGVyY2VudDogMCxcbiAgICBzdHJva2VXaWR0aDogMTAsXG4gICAgc3RhdHVzOiAnbm9ybWFsJywgLy8gZXhjZXB0aW9uIGFjdGl2ZVxuICAgIHNob3dJbmZvOiB0cnVlXG59O1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IExpbmU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLXByb2dyZXNzL2J1aWxkL1Byb2dyZXNzLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcmVhY3REb20gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIF9yZWFjdERvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdERvbSk7XG5cbnZhciBfb2JqZWN0QXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgX29iamVjdEFzc2lnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vYmplY3RBc3NpZ24pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgZGVmYXVsdFByb3BzID0ge1xuICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgIHRyYWlsV2lkdGg6IDFcbn07XG52YXIgcHJlZml4Q2xzID0gJ2t1bWEtcHJvZ3Jlc3MnO1xuXG52YXIgQ2lyY2xlID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoQ2lyY2xlLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENpcmNsZSk7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfVxuXG4gICAgQ2lyY2xlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9ICgwLCBfb2JqZWN0QXNzaWduMltcImRlZmF1bHRcIl0pKHt9LCB0aGlzLnByb3BzKTtcbiAgICAgICAgdmFyIHN0cm9rZVdpZHRoID0gcHJvcHMuc3Ryb2tlV2lkdGg7XG4gICAgICAgIHZhciByYWRpdXMgPSA1MCAtIHN0cm9rZVdpZHRoIC8gMjtcbiAgICAgICAgdmFyIHBhdGhTdHJpbmcgPSAnTSA1MCw1MCBtIDAsLScgKyByYWRpdXMgKyAnXFxuICAgICAgICAgICAgYSAnICsgcmFkaXVzICsgJywnICsgcmFkaXVzICsgJyAwIDEgMSAwLCcgKyAyICogcmFkaXVzICsgJ1xcbiAgICAgICAgICAgIGEgJyArIHJhZGl1cyArICcsJyArIHJhZGl1cyArICcgMCAxIDEgMCwtJyArIDIgKiByYWRpdXM7XG4gICAgICAgIHZhciBsZW4gPSBNYXRoLlBJICogMiAqIHJhZGl1cztcbiAgICAgICAgdmFyIHBhdGhTdHlsZSA9IHtcbiAgICAgICAgICAgICdzdHJva2VEYXNoYXJyYXknOiBsZW4gKyAncHggJyArIGxlbiArICdweCcsXG4gICAgICAgICAgICAnc3Ryb2tlRGFzaG9mZnNldCc6ICgxMDAgLSBwcm9wcy5wZXJjZW50KSAvIDEwMCAqIGxlbiArICdweCcsXG4gICAgICAgICAgICAndHJhbnNpdGlvbic6ICdzdHJva2UtZGFzaG9mZnNldCAwLjZzIGVhc2UgMHMsIHN0cm9rZSAwLjZzIGVhc2UnXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHByb2dyZXNzSW5mbyA9IHZvaWQgMCxcbiAgICAgICAgICAgIHRleHRTdHlsZSA9IHtcbiAgICAgICAgICAgIGxpbmVIZWlnaHQ6IHByb3BzLnNpemUgKyAncHgnXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHByb3BzLnNob3dJbmZvID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMuc3RhdHVzID09PSAnZXhjZXB0aW9uJykge1xuICAgICAgICAgICAgICAgIHByb2dyZXNzSW5mbyA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgICAgICAgICAgeyBzdHlsZTogdGV4dFN0eWxlLCBjbGFzc05hbWU6IHByZWZpeENscyArICctY2lyY2xlLXRleHQnIH0sXG4gICAgICAgICAgICAgICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoJ2knLCB7IGNsYXNzTmFtZTogJ2ljb24tY2F1dGlvbicgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wcy5zdGF0dXMgPT09ICdzdWNjZXNzJykge1xuICAgICAgICAgICAgICAgIHByb2dyZXNzSW5mbyA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgICAgICAgICAgeyBzdHlsZTogdGV4dFN0eWxlLCBjbGFzc05hbWU6IHByZWZpeENscyArICctY2lyY2xlLXRleHQnIH0sXG4gICAgICAgICAgICAgICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoJ2knLCB7IGNsYXNzTmFtZTogJ2ljb24tc3VjY2VzcycgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0luZm8gPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICAgICAgICAgIHsgc3R5bGU6IHRleHRTdHlsZSwgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWNpcmNsZS10ZXh0JyB9LFxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5wZXJjZW50LFxuICAgICAgICAgICAgICAgICAgICAnJSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgWydzdHJva2VXaWR0aCcsICd0cmFpbFdpZHRoJ10uZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgaWYgKGl0ZW0gPT09ICd0cmFpbFdpZHRoJyAmJiAhcHJvcHMudHJhaWxXaWR0aCAmJiBwcm9wcy5zdHJva2VXaWR0aCkge1xuICAgICAgICAgICAgICAgIHByb3BzLnRyYWlsV2lkdGggPSBwcm9wcy5zdHJva2VXaWR0aDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXByb3BzW2l0ZW1dKSB7XG4gICAgICAgICAgICAgICAgcHJvcHNbaXRlbV0gPSBkZWZhdWx0UHJvcHNbaXRlbV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2t1bWEtcHJvZ3Jlc3MtY2lyY2xlLXdyYXAgc3RhdHVzLScgKyBwcm9wcy5zdGF0dXMsIHN0eWxlOiB7IHdpZHRoOiBwcm9wcy5zaXplLCBoZWlnaHQ6IHByb3BzLnNpemUgfSB9LFxuICAgICAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAnc3ZnJyxcbiAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2t1bWEtcHJvZ3Jlc3MtY2lyY2xlJywgdmlld0JveDogJzAgMCAxMDAgMTAwJyB9LFxuICAgICAgICAgICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCB7IGNsYXNzTmFtZTogJ2t1bWEtcHJvZ3Jlc3MtY2lyY2xlLXRyYWlsJywgZDogcGF0aFN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IHByb3BzLnRyYWlsV2lkdGgsIGZpbGxPcGFjaXR5OiAnMCcgfSksXG4gICAgICAgICAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudCgncGF0aCcsIHsgY2xhc3NOYW1lOiAna3VtYS1wcm9ncmVzcy1jaXJjbGUtcGF0aCcsIGQ6IHBhdGhTdHJpbmcsIHN0cm9rZUxpbmVjYXA6ICdyb3VuZCcsIHN0cm9rZVdpZHRoOiBwcm9wcy5zdHJva2VXaWR0aCwgZmlsbE9wYWNpdHk6ICcwJywgc3R5bGU6IHBhdGhTdHlsZSB9KVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHByb2dyZXNzSW5mb1xuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ2lyY2xlO1xufShfcmVhY3QyW1wiZGVmYXVsdFwiXS5Db21wb25lbnQpO1xuXG5DaXJjbGUuZGlzcGxheU5hbWUgPSBcIlByb2dyZXNzLUNpcmNsZVwiO1xuQ2lyY2xlLnByb3BUeXBlcyA9IHtcbiAgICBzdGF0dXM6IF9yZWFjdDJbXCJkZWZhdWx0XCJdLlByb3BUeXBlcy5vbmVPZihbJ25vcm1hbCcsICdleGNlcHRpb24nLCAnc3VjY2VzcyddKSxcbiAgICBwZXJjZW50OiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMubnVtYmVyLFxuICAgIHN0cm9rZVdpZHRoOiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMubnVtYmVyLFxuICAgIHNpemU6IF9yZWFjdDJbXCJkZWZhdWx0XCJdLlByb3BUeXBlcy5udW1iZXIsXG4gICAgc2hvd0luZm86IF9yZWFjdDJbXCJkZWZhdWx0XCJdLlByb3BUeXBlcy5ib29sXG59O1xuQ2lyY2xlLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBzdGF0dXM6ICdub3JtYWwnLCAvLyBleGNlcHRpb24gYWN0aXZlXG4gICAgcGVyY2VudDogMCxcbiAgICBzdHJva2VXaWR0aDogNixcbiAgICBzaXplOiAxNTYsXG4gICAgc2hvd0luZm86IHRydWVcbn07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQ2lyY2xlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1wcm9ncmVzcy9idWlsZC9DaXJjbGUuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU3RlcHMgQ29tcG9uZW50IGZvciB1eGNvcmVcbiAqIEBhdXRob3IgdmluY2VudC5iaWFuXG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgVXhjb3JlIFRlYW0sIEFsaW53LlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vU3RlcHMnKTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLXN0ZXBzL2J1aWxkL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogU3RlcHMgQ29tcG9uZW50IGZvciB1eGNvcmVcbiAqIEBhdXRob3IgdmluY2VudC5iaWFuXG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgVXhjb3JlIFRlYW0sIEFsaW53LlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG52YXIgU3RlcCA9IHJlcXVpcmUoXCIuL1N0ZXBcIik7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBTdGVwcyA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzKFN0ZXBzLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIFN0ZXBzKHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdGVwcyk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBpbml0OiBmYWxzZSxcbiAgICAgICAgICAgIHRhaWxXaWR0aDogMFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5fcHJldmlvdXNTdGVwc1dpZHRoID0gMDtcbiAgICAgICAgX3RoaXMuX2l0ZW1zV2lkdGggPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIFN0ZXBzLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgaWYgKG5leHRQcm9wcy5jaGlsZHJlbi5sZW5ndGggIT09IHRoaXMucHJvcHMuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5kaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgJGRvbSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpO1xuICAgICAgICAgICAgdmFyIGxlbiA9IG5leHRQcm9wcy5jaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgICAgICAgICAgdGhpcy5faXRlbXNXaWR0aCA9IG5ldyBBcnJheShsZW4gKyAxKTtcblxuICAgICAgICAgICAgdmFyIGkgPSB2b2lkIDA7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDw9IGxlbiAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2l0ZW1zV2lkdGhbaV0gPSBuZXh0UHJvcHMubWF4RGVzY3JpcHRpb25XaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zV2lkdGhbaV0gPSBuZXh0UHJvcHMubWF4RGVzY3JpcHRpb25XaWR0aDtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZShuZXh0UHJvcHMpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFN0ZXBzLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5kaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgJGRvbSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpO1xuICAgICAgICB2YXIgbGVuID0gJGRvbS5jaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgICAgICB0aGlzLl9pdGVtc1dpZHRoID0gbmV3IEFycmF5KGxlbiArIDEpO1xuXG4gICAgICAgIHZhciBpID0gdm9pZCAwO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDw9IGxlbiAtIDE7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5faXRlbXNXaWR0aFtpXSA9IHRoaXMucHJvcHMubWF4RGVzY3JpcHRpb25XaWR0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pdGVtc1dpZHRoW2ldID0gdGhpcy5wcm9wcy5tYXhEZXNjcmlwdGlvbldpZHRoO1xuICAgICAgICB0aGlzLl9wcmV2aW91c1N0ZXBzV2lkdGggPSBNYXRoLmZsb29yKFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpLm9mZnNldFdpZHRoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG5cbiAgICAgICAgLypcbiAgICAgICAgICog5oqK5pyA5ZCO5LiA5Liq5YWD57Sg6K6+572u5Li6YWJzb2x1dGXvvIzmmK/kuLrkuobpmLLmraLliqjmgIHmt7vliqDlhYPntKDlkI7mu5rliqjmnaHlh7rnjrDlr7zoh7TnmoTluIPlsYDpl67popjjgIJcbiAgICAgICAgICog5pyq5p2l5LiN6ICD6JmRaWU45LiA57G755qE5rWP6KeI5Zmo5ZCO77yM5Lya6YeH55So57qvY3Nz5p2l6YG/5YWN5ZCE56eN6Zeu6aKY44CCXG4gICAgICAgICAqL1xuICAgICAgICAkZG9tLmNoaWxkcmVuW2xlbl0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIOS4i+mdoueahOS7o+eggeaYr+S4uuS6huWFvOWuuXdpbmRvd+ezu+e7n+S4i+a7muWKqOadoeWHuueOsOWQjuS8muWNoOeUqOWuveW6pueahOmXrumimOOAglxuICAgICAgICAgKiBjb21wb25lbnREaWRNb3VudOaXtua7muWKqOadoei/mOS4jeS4gOWumuWHuueOsOS6hu+8jOi/meaXtuWAmeiOt+WPlueahOWuveW6puWPr+iDveS4jeaYr+acgOe7iOWuveW6puOAglxuICAgICAgICAgKiDlr7nkuo7mu5rliqjmnaHkuI3ljaDnlKjlrr3luqbnmoTmtY/op4jlmajvvIzkuIvpnaLnmoTku6PnoIHkuZ/kuI3kuozmrKFyZW5kZXLvvIxfcmVzaXpl6YeM6Z2i5Lya5Yik5pat6KaB5LiN6KaB5pu05paw44CCXG4gICAgICAgICAqL1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMi5fcmVzaXplKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX3Jlc2l6ZUJpbmQgPSB0aGlzLl9yZXNpemUuYmluZCh0aGlzKTtcblxuICAgICAgICBpZiAod2luZG93LmF0dGFjaEV2ZW50KSB7XG4gICAgICAgICAgICB3aW5kb3cuYXR0YWNoRXZlbnQoJ29ucmVzaXplJywgdGhpcy5fcmVzaXplQmluZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fcmVzaXplQmluZCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgU3RlcHMucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5fcmVzaXplKCk7XG4gICAgICAgIHZhciAkZG9tID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG5cbiAgICAgICAgdmFyIGxlbiA9ICRkb20uY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICAgICAgLypcbiAgICAgICAgICog5oqK5pyA5ZCO5LiA5Liq5YWD57Sg6K6+572u5Li6YWJzb2x1dGXvvIzmmK/kuLrkuobpmLLmraLliqjmgIHmt7vliqDlhYPntKDlkI7mu5rliqjmnaHlh7rnjrDlr7zoh7TnmoTluIPlsYDpl67popjjgIJcbiAgICAgICAgICog5pyq5p2l5LiN6ICD6JmRaWU45LiA57G755qE5rWP6KeI5Zmo5ZCO77yM5Lya6YeH55So57qvY3Nz5p2l6YG/5YWN5ZCE56eN6Zeu6aKY44CCXG4gICAgICAgICAqL1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBsZW47IGkrKykge1xuICAgICAgICAgICAgJGRvbS5jaGlsZHJlbltpXS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgIH1cbiAgICAgICAgJGRvbS5jaGlsZHJlbltsZW5dLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICB9O1xuXG4gICAgU3RlcHMucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aW5kb3cuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5kZXRhY2hFdmVudCgnb25yZXNpemUnLCB0aGlzLl9yZXNpemVCaW5kKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9yZXNpemVCaW5kKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTdGVwcy5wcm90b3R5cGUuX3Jlc2l6ZSA9IGZ1bmN0aW9uIF9yZXNpemUoKSB7XG4gICAgICAgIHZhciB3ID0gTWF0aC5mbG9vcihSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKS5vZmZzZXRXaWR0aCk7XG4gICAgICAgIGlmICh0aGlzLl9wcmV2aW91c1N0ZXBzV2lkdGggPT09IHcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcmV2aW91c1N0ZXBzV2lkdGggPSB3O1xuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICB9O1xuXG4gICAgU3RlcHMucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKHByb3BzKSB7XG4gICAgICAgIHByb3BzID0gcHJvcHMgfHwgdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIGxlbiA9IHByb3BzLmNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciB0dyA9IDA7XG4gICAgICAgIHRoaXMuX2l0ZW1zV2lkdGguZm9yRWFjaChmdW5jdGlvbiAodykge1xuICAgICAgICAgICAgdHcgKz0gdztcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBkdyA9IE1hdGguZmxvb3IoKHRoaXMuX3ByZXZpb3VzU3RlcHNXaWR0aCAtIHR3KSAvIGxlbikgLSAxO1xuICAgICAgICBpZiAoZHcgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgaW5pdDogdHJ1ZSxcbiAgICAgICAgICAgIHRhaWxXaWR0aDogZHdcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIFN0ZXBzLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBwcmVmaXhDbHMgPSBwcm9wcy5wcmVmaXhDbHM7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICAgICAgICB2YXIgbWF4RGVzY3JpcHRpb25XaWR0aCA9IHByb3BzLm1heERlc2NyaXB0aW9uV2lkdGg7XG4gICAgICAgIHZhciBpY29uUHJlZml4ID0gcHJvcHMuaWNvblByZWZpeDtcbiAgICAgICAgdmFyIHNpemUgPSBwcm9wcy5zaXplO1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gcHJvcHMuZGlyZWN0aW9uO1xuICAgICAgICB2YXIgc2hvd0ljb24gPSBwcm9wcy5zaG93SWNvbjtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBwcm9wcy5jdXJyZW50O1xuICAgICAgICB2YXIgdHlwZSA9IHByb3BzLnR5cGU7XG5cbiAgICAgICAgdmFyIGxlbiA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBpd3MgPSB0aGlzLl9pdGVtc1dpZHRoO1xuICAgICAgICB2YXIgY2xzTmFtZSA9IHByZWZpeENscztcbiAgICAgICAgLy8gaWYgKHNpemUgPT09ICdzbWFsbCcgJiYgc2hvd0ljb24pIHtcbiAgICAgICAgLy8gICAgIGNsc05hbWUgKz0gYCAke3ByZWZpeENsc30tc21hbGxgO1xuICAgICAgICAvLyB9XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIGNsc05hbWUgKz0gJyAnICsgcHJlZml4Q2xzICsgJy12ZXJ0aWNhbCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbHNOYW1lICs9ICcgJyArIHByZWZpeENscyArICctdHlwZS0nICsgdHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNob3dJY29uKSB7XG4gICAgICAgICAgICBjbHNOYW1lICs9ICcgJyArIHByZWZpeENscyArICctbm9pY29uJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogY2xzTmFtZSB9LFxuICAgICAgICAgICAgUmVhY3QuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBmdW5jdGlvbiAoZWxlLCBpZHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbnAgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ZXBOdW1iZXI6IHNob3dJY29uID8gKGlkeCArIDEpLnRvU3RyaW5nKCkgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgc3RlcExhc3Q6IGlkeCA9PT0gbGVuLFxuICAgICAgICAgICAgICAgICAgICB0YWlsV2lkdGg6IGl3cy5sZW5ndGggPT09IDAgfHwgaWR4ID09PSBsZW4gPyAnYXV0bycgOiBpd3NbaWR4XSArIHRoaXMuc3RhdGUudGFpbFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBwcmVmaXhDbHM6IHByZWZpeENscyxcbiAgICAgICAgICAgICAgICAgICAgaWNvblByZWZpeDogaWNvblByZWZpeCxcbiAgICAgICAgICAgICAgICAgICAgbWF4RGVzY3JpcHRpb25XaWR0aDogbWF4RGVzY3JpcHRpb25XaWR0aFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKCFlbGUucHJvcHMuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIG5wLnN0YXR1cyA9IGlkeCA9PT0gY3VycmVudCA/ICdwcm9jZXNzJyA6IGlkeCA8IGN1cnJlbnQgPyAnZmluaXNoJyA6ICd3YWl0JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChlbGUsIG5wKTtcbiAgICAgICAgICAgIH0sIHRoaXMpXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHJldHVybiBTdGVwcztcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuU3RlcHMuZGVmYXVsdFByb3BzID0ge1xuICAgIHByZWZpeENsczogJ2t1bWEtc3RlcCcsXG4gICAgaWNvblByZWZpeDogJycsXG4gICAgLy8gc2l6ZTogJ2RlZmF1bHQnLFxuICAgIG1heERlc2NyaXB0aW9uV2lkdGg6IDEwMCxcbiAgICBjdXJyZW50OiAwLFxuICAgIGRpcmVjdGlvbjogJycsXG4gICAgc2hvd0ljb246IHRydWUsXG4gICAgdHlwZTogJ2RlZmF1bHQnXG59O1xuXG4vLyBodHRwOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvcmV1c2FibGUtY29tcG9uZW50cy5odG1sXG5TdGVwcy5wcm9wVHlwZXMgPSB7XG4gICAgcHJlZml4Q2xzOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGljb25QcmVmaXg6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgLy8gc2l6ZTogUmVhY3QuUHJvcFR5cGVzLm9uZU9mKFsnZGVmYXVsdCcsICdzbWFsbCddKSxcbiAgICBtYXhEZXNjcmlwdGlvbldpZHRoOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgIGN1cnJlbnQ6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgZGlyZWN0aW9uOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHNob3dJY29uOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICB0eXBlOiBSZWFjdC5Qcm9wVHlwZXMub25lT2YoWydkZWZhdWx0JywgJ3RpdGxlLW9uLXRvcCcsICdsb25nLWRlc2MnXSlcbn07XG5cblN0ZXBzLmRpc3BsYXlOYW1lID0gXCJTdGVwc1wiO1xuXG5TdGVwcy5TdGVwID0gU3RlcDtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBTdGVwcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtc3RlcHMvYnVpbGQvU3RlcHMuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgU3RlcCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzKFN0ZXAsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gU3RlcChwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RlcCk7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuICAgIH1cblxuICAgIFN0ZXAucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIHN0YXR1cyA9IHByb3BzLnN0YXR1cyB8fCAnd2FpdCc7XG4gICAgICAgIHZhciBwcmVmaXhDbHMgPSBwcm9wcy5wcmVmaXhDbHM7XG4gICAgICAgIHZhciBpY29uUHJlZml4ID0gcHJvcHMuaWNvblByZWZpeDtcbiAgICAgICAgdmFyIG1heFdpZHRoID0gcHJvcHMubWF4RGVzY3JpcHRpb25XaWR0aDtcbiAgICAgICAgdmFyIGljb25OYW1lID0gcHJvcHMuaWNvbiA/IHByb3BzLmljb24gOiAnY2hlY2snO1xuICAgICAgICB2YXIgaWNvbiA9IHZvaWQgMCxcbiAgICAgICAgICAgIHN0ZXBDbHMgPSBwcmVmaXhDbHMgKyAnLWl0ZW0gJyArIHByZWZpeENscyArICctc3RhdHVzLScgKyBzdGF0dXMsXG4gICAgICAgICAgICB0YWlsID0gdm9pZCAwLFxuICAgICAgICAgICAgZGVzY3JpcHRpb24gPSB2b2lkIDA7XG4gICAgICAgIGlmICghcHJvcHMuaWNvbiAmJiBzdGF0dXMgIT09ICdwcm9jZXNzJyB8fCAhcHJvcHMuc3RlcExhc3QpIHtcbiAgICAgICAgICAgIGljb24gPSBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1pY29uJyB9LFxuICAgICAgICAgICAgICAgIHByb3BzLnN0ZXBOdW1iZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpY29uID0gUmVhY3QuY3JlYXRlRWxlbWVudCgnc3BhbicsIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWljb24gJyArIGljb25QcmVmaXggKyAnaWNvbiAnICsgaWNvblByZWZpeCArICdpY29uLScgKyBpY29uTmFtZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wcy5zdGVwTGFzdCkge1xuICAgICAgICAgICAgc3RlcENscyArPSAnICcgKyBwcmVmaXhDbHMgKyAnLWl0ZW0tbGFzdCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YWlsID0gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy10YWlsJyB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2knLCBudWxsKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcHMuaWNvbikge1xuICAgICAgICAgICAgc3RlcENscyArPSAnICcgKyBwcmVmaXhDbHMgKyAnLWN1c3RvbSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BzLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbiA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctZGVzY3JpcHRpb24nIH0sXG4gICAgICAgICAgICAgICAgcHJvcHMuZGVzY3JpcHRpb25cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6ICcnICsgc3RlcENscywgc3R5bGU6IHsgd2lkdGg6IHByb3BzLnRhaWxXaWR0aCB9IH0sXG4gICAgICAgICAgICB0YWlsLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1oZWFkJyB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1oZWFkLWlubmVyJyB9LFxuICAgICAgICAgICAgICAgICAgICBpY29uXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctbWFpbicsIHN0eWxlOiB7IG1heFdpZHRoOiBtYXhXaWR0aCB9IH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLXRpdGxlJyB9LFxuICAgICAgICAgICAgICAgICAgICBwcm9wcy50aXRsZVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb25cbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFN0ZXA7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RlcDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLXN0ZXBzL2J1aWxkL1N0ZXAuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVGFibGUgQ29tcG9uZW50IGZvciB1eGNvcmVcbiAqIEBhdXRob3IgemhvdXF1YW4ueWV6cVxuICpcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIFV4Y29yZSBUZWFtLCBBbGludy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL1RhYmxlJyk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS10YWJsZS9idWlsZC9pbmRleC5qc1xuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogVGFibGUgQ29tcG9uZW50IGZvciB1eGNvcmVcbiAqIEBhdXRob3IgemhvdXF1YW4ueWV6cVxuICpcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIFVYQ29yZSBUZWFtLCBBbGludy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxudmFyIEhlYWRlciA9IHJlcXVpcmUoXCIuL0hlYWRlclwiKTtcbnZhciBUYm9keSA9IHJlcXVpcmUoXCIuL1Rib2R5XCIpO1xudmFyIEFjdGlvbkJhciA9IHJlcXVpcmUoXCIuL0FjdGlvbkJhclwiKTtcbnZhciBDZWxsRmllbGQgPSByZXF1aXJlKCcuL0NlbGwvQ2VsbEZpZWxkJyk7XG52YXIgUGFnaW5hdGlvbiA9IHJlcXVpcmUoXCJ1eGNvcmUtcGFnaW5hdGlvblwiKTtcbnZhciBDb25zdCA9IHJlcXVpcmUoJ3V4Y29yZS1jb25zdCcpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcbnZhciBkZWVwY29weSA9IHJlcXVpcmUoJ2RlZXBjb3B5Jyk7XG52YXIgZGVlcEVxdWFsID0gcmVxdWlyZSgnZGVlcC1lcXVhbCcpO1xudmFyIGNsYXNzbmFtZXMgPSByZXF1aXJlKFwiY2xhc3NuYW1lc1wiKTtcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgVGFibGUgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhUYWJsZSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBUYWJsZShwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGFibGUpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgICAgIF90aGlzLnVpZCA9IDA7XG4gICAgICAgIF90aGlzLmZpZWxkcyA9IHt9O1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGRhdGE6IF90aGlzLmFkZFZhbHVlc0luRGF0YShkZWVwY29weShfdGhpcy5wcm9wcy5qc3hkYXRhKSksIC8vIGNoZWNrYm94IOWGhemDqOS6pOS6klxuICAgICAgICAgICAgY29sdW1uczogX3RoaXMucHJvY2Vzc0NvbHVtbigpLCAvLyBjb2x1bW4g5YaF6YOo5Lqk5LqSXG4gICAgICAgICAgICBzaG93TWFzazogX3RoaXMucHJvcHMuc2hvd01hc2ssIC8vIGZldGNoRGF0YSDml7bnmoTlhoXpg6jnirbmgIHmlLnlj5hcbiAgICAgICAgICAgIHBhZ2VTaXplOiBwcm9wcy5wYWdlU2l6ZSwgLy8gcGFnaW5hdGlvbiDnm7jlhbNcbiAgICAgICAgICAgIGN1cnJlbnRQYWdlOiBwcm9wcy5jdXJyZW50UGFnZSwgLy8gcGFnaW5hdGlvbiDnm7jlhbNcbiAgICAgICAgICAgIGFjdGl2ZUNvbHVtbjogbnVsbCxcbiAgICAgICAgICAgIHNlYXJjaFR4dDogXCJcIixcbiAgICAgICAgICAgIHBhc3NlZERhdGE6IG51bGwsXG4gICAgICAgICAgICBwYXJhbXM6IG51bGwsXG4gICAgICAgICAgICBzZWxlY3RlZDogW10sXG4gICAgICAgICAgICBleHBhbmRlZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIFRhYmxlLnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmZldGNoRGF0YU9uTW91bnQpIHtcbiAgICAgICAgICAgIHRoaXMuZmV0Y2hEYXRhKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgVGFibGUucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIG1lLmVsID0gUmVhY3RET00uZmluZERPTU5vZGUobWUpO1xuICAgICAgICBpZiAoISFtZS5zdGF0ZS5kYXRhICYmICEhbWUuc3RhdGUuZGF0YS5kYXRhcykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVGFibGU6ICdjb250ZW50LmRhdGEnIHJhdGhlciB0aGFuICdjb250ZW50LmRhdGFzJyBpcyByZWNvbW1lbmRlZCwgdGhlIHN1cHBvcnQgZm9yICdjb250ZW50LmRhdGFzJyB3aWxsIGJlIGVuZCBmcm9tIHZlci4gMS4zLjBcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lLnByb3BzLnN1YkNvbXApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRhYmxlOiBzdWJDb21wIGlzIGRlcHJlY2F0ZWQsIHVzZSByZW5kZXJTdWJDb21wIGluc3RlYWQuXCIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFRhYmxlLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIG5ld0RhdGEgPSB7fTtcbiAgICAgICAgaWYgKCEhbmV4dFByb3BzLmpzeGRhdGEgJiYgISFtZS5wcm9wcy5qc3hkYXRhICYmICFtZS5faXNFcXVhbChuZXh0UHJvcHMuanN4ZGF0YSwgbWUucHJvcHMuanN4ZGF0YSkpIHtcbiAgICAgICAgICAgIC8vIERhdGEgaGFzIGNoYW5nZWQsIHNvIHVpZCB3aGljaCBpcyB1c2VkIHRvIG1hcmsgdGhlIGRhdGEgc2hvdWxkIGJlIHJlc2V0LlxuICAgICAgICAgICAgbWUudWlkID0gMDtcbiAgICAgICAgICAgIG5ld0RhdGFbJ2RhdGEnXSA9IG1lLmFkZFZhbHVlc0luRGF0YShkZWVwY29weShuZXh0UHJvcHMuanN4ZGF0YSkpO1xuICAgICAgICAgICAgbWUuZGF0YSA9IGRlZXBjb3B5KG5ld0RhdGFbJ2RhdGEnXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRQcm9wcy5wYWdlU2l6ZSAhPSBtZS5wcm9wcy5wYWdlU2l6ZSkge1xuICAgICAgICAgICAgbmV3RGF0YVsncGFnZVNpemUnXSA9IG5leHRQcm9wcy5wYWdlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dFByb3BzLmN1cnJlbnRQYWdlICE9IG1lLnByb3BzLmN1cnJlbnRQYWdlKSB7XG4gICAgICAgICAgICBuZXdEYXRhWydjdXJyZW50UGFnZSddID0gbmV4dFByb3BzLmN1cnJlbnRQYWdlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIW5leHRQcm9wcy5qc3hjb2x1bW5zICYmICEhbWUucHJvcHMuanN4Y29sdW1ucyAmJiAhbWUuX2lzRXF1YWwobmV4dFByb3BzLmpzeGNvbHVtbnMsIG1lLnByb3BzLmpzeGNvbHVtbnMpKSB7XG4gICAgICAgICAgICBuZXdEYXRhWydjb2x1bW5zJ10gPSBtZS5wcm9jZXNzQ29sdW1uKG5leHRQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgbWUuc2V0U3RhdGUobmV3RGF0YSk7XG4gICAgfTtcblxuICAgIFRhYmxlLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGb3IgaW5saW5lIGVkaXRcbiAgICAgKiByZWNlaXZlIGNoYW5nZXMgZnJvbSBjZWxsIGZpZWxkIGFuZCBjaGFuZ2Ugc3RhdGUuZGF0YVxuICAgICAqIGluZm9ybSB1c2VycyBvZiB0aGUgY2hhbmdlIHdpdGggZGF0YUtleSAmIHBhc3NcbiAgICAgKi9cblxuICAgIFRhYmxlLnByb3RvdHlwZS5oYW5kbGVEYXRhQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlRGF0YUNoYW5nZShvYmopIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIGpzeGlkID0gb2JqLmpzeGlkO1xuICAgICAgICB2YXIgY29sdW1uID0gb2JqLmNvbHVtbjtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqLnZhbHVlO1xuICAgICAgICB2YXIgdGV4dCA9IG9iai50ZXh0O1xuICAgICAgICB2YXIgcGFzcyA9IG9iai5wYXNzO1xuXG4gICAgICAgIHZhciBkYXRhS2V5ID0gY29sdW1uLmRhdGFLZXk7XG4gICAgICAgIHZhciBlZGl0S2V5ID0gY29sdW1uLmVkaXRLZXkgfHwgZGF0YUtleTtcbiAgICAgICAgdmFyIGRhdGEgPSBkZWVwY29weShtZS5zdGF0ZS5kYXRhKTtcbiAgICAgICAgdmFyIGNoYW5nZWREYXRhID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5kYXRhW2ldLmpzeGlkID09IGpzeGlkKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5kYXRhW2ldW2RhdGFLZXldID0gdGV4dDtcbiAgICAgICAgICAgICAgICBkYXRhLmRhdGFbaV1bZWRpdEtleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkRGF0YSA9IGRhdGEuZGF0YVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbWUucHJvcHMub25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgIGRhdGE6IG1lLnN0YXRlLmRhdGEsXG4gICAgICAgICAgICAgICAgZWRpdEtleTogZWRpdEtleSxcbiAgICAgICAgICAgICAgICBkYXRhS2V5OiBkYXRhS2V5LFxuICAgICAgICAgICAgICAgIGNoYW5nZWREYXRhOiBjaGFuZ2VkRGF0YSxcbiAgICAgICAgICAgICAgICBwYXNzOiBwYXNzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJlZ2lzdGVyIENlbGxGaWVsZCB0byBUYWJsZSBmb3IgdGhlIGdsb2JhbCB2YWxpZGF0aW9uXG4gICAgICogQHBhcmFtIGZpZWxkIHtlbGVtZW50fSB0aGUgY2VsbCBmaWVsZCB0byBiZSByZWdpc3RlcmVkXG4gICAgICovXG5cbiAgICBUYWJsZS5wcm90b3R5cGUuYXR0YWNoQ2VsbEZpZWxkID0gZnVuY3Rpb24gYXR0YWNoQ2VsbEZpZWxkKHZhbGlkYXRlLCBuYW1lKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlRhYmxlOiBuYW1lIGNhbiBub3QgYmUgZW1wdHksIGNoZWNrIHRoZSBkYXRhS2V5IG9mIHRoZSBjb2x1bW4gY29uZmlnXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUuZmllbGRzW25hbWVdID0gdmFsaWRhdGU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogY2FuY2VsIHRoZSBDZWxsRmllbGQgd2hlbiBpdCBpcyB1bm1vdW50ZWQuXG4gICAgICogQHBhcmFtIGZpZWxkIHtlbGVtZW50fSB0aGUgY2VsbCBmaWVsZCB0byBiZSBjYW5jZWxlZC5cbiAgICAgKi9cblxuICAgIFRhYmxlLnByb3RvdHlwZS5kZXRhY2hDZWxsRmllbGQgPSBmdW5jdGlvbiBkZXRhY2hDZWxsRmllbGQobmFtZSkge1xuICAgICAgICBkZWxldGUgdGhpcy5maWVsZHNbbmFtZV07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNpbXBsZSBtZXRob2QgdG8gY29tcGFyZSB0d28gZGF0YXMsIFxuICAgICAqIG9ubHkgc3VwcG9ydCB0aGUgZGF0YSB3aGljaCBKU09OIGNhbiBwYXJzZS5cbiAgICAgKi9cblxuICAgIFRhYmxlLnByb3RvdHlwZS5faXNFcXVhbCA9IGZ1bmN0aW9uIF9pc0VxdWFsKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGRlZXBFcXVhbChhLCBiKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZ2V0IFF1ZXJ5IE9iamVjdCBieSBjb21iaW5pbmcgZGF0YSBmcm9tIHNlYXJjaEJhciwgY29sdW1uIG9yZGVyLCBwYWdpbmF0aW9uXG4gICAgICogYW5kIGZldGNoUGFyYW1zLlxuICAgICAqIEBwYXJhbSBmcm9tIHtzdHJpbmd9IHVzZWQgaW4gcHJvcHMuYmVmb3JlRmV0Y2hcbiAgICAgKi9cblxuICAgIFRhYmxlLnByb3RvdHlwZS5nZXRRdWVyeU9iaiA9IGZ1bmN0aW9uIGdldFF1ZXJ5T2JqKGZyb20pIHtcblxuICAgICAgICB2YXIgbWUgPSB0aGlzLFxuICAgICAgICAgICAgcXVlcnlPYmogPSB7fTtcbiAgICAgICAgaWYgKG1lLnByb3BzLnBhc3NlZERhdGEpIHtcbiAgICAgICAgICAgIHZhciBxdWVyeUtleXMgPSBtZS5wcm9wcy5xdWVyeUtleXM7XG4gICAgICAgICAgICBpZiAoIXF1ZXJ5S2V5cykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5T2JqID0gbWUucHJvcHMucGFzc2VkRGF0YTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVlcnlLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWUucHJvcHMucGFzc2VkRGF0YVtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5T2JqW2tleV0gPSBtZS5wcm9wcy5wYXNzZWREYXRhW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBhZ2luYXRpb25cbiAgICAgICAgcXVlcnlPYmogPSBhc3NpZ24oe30sIHF1ZXJ5T2JqLCB7XG4gICAgICAgICAgICBwYWdlU2l6ZTogbWUuc3RhdGUucGFnZVNpemUsXG4gICAgICAgICAgICBjdXJyZW50UGFnZTogbWUuc3RhdGUuY3VycmVudFBhZ2VcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gY29sdW1uIG9yZGVyXG4gICAgICAgIHZhciBhY3RpdmVDb2x1bW4gPSBtZS5zdGF0ZS5hY3RpdmVDb2x1bW47XG4gICAgICAgIHZhciBvcmRlclR5cGUgPSBtZS5zdGF0ZS5vcmRlclR5cGU7XG4gICAgICAgIGlmICghIWFjdGl2ZUNvbHVtbikge1xuICAgICAgICAgICAgcXVlcnlPYmogPSBhc3NpZ24oe30sIHF1ZXJ5T2JqLCB7XG4gICAgICAgICAgICAgICAgb3JkZXJDb2x1bW46IGFjdGl2ZUNvbHVtbi5kYXRhS2V5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghIW9yZGVyVHlwZSAmJiBvcmRlclR5cGUgIT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlPYmoub3JkZXJUeXBlID0gb3JkZXJUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2VhcmNoIHF1ZXJ5XG4gICAgICAgIHZhciBzZWFyY2hUeHQgPSBtZS5zdGF0ZS5zZWFyY2hUeHQ7XG4gICAgICAgIGlmICghIXNlYXJjaFR4dCkge1xuICAgICAgICAgICAgcXVlcnlPYmogPSBhc3NpZ24oe30sIHF1ZXJ5T2JqLCB7XG4gICAgICAgICAgICAgICAgc2VhcmNoVHh0OiBzZWFyY2hUeHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmV0Y2hQYXJhbXMgaGFzIHRoZSB0b3AgcHJpb3JpdHlcbiAgICAgICAgaWYgKCEhbWUucHJvcHMuZmV0Y2hQYXJhbXMpIHtcbiAgICAgICAgICAgIHF1ZXJ5T2JqID0gYXNzaWduKHt9LCBxdWVyeU9iaiwgbWUucHJvcHMuZmV0Y2hQYXJhbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1lLnByb3BzLmJlZm9yZUZldGNoKHF1ZXJ5T2JqLCBmcm9tKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZmV0Y2ggRGF0YSB2aWEgQWpheFxuICAgICAqIEBwYXJhbSBmcm9tIHtzdHJpbmd9IHRlbGwgZmV0Y2hEYXRhIHdoZXJlIGl0IGlzIGludm9rZWQsIHRoZSBwYXJhbSB3aWxsIGJlIFxuICAgICAqIHBhc3NlZCB0byBwcm9wcy5iZWZvcmVGZXRjaCBpbiBvcmRlciB0byBoZWxwIHRoZSB1c2VyLlxuICAgICAqL1xuXG4gICAgVGFibGUucHJvdG90eXBlLmZldGNoRGF0YSA9IGZ1bmN0aW9uIGZldGNoRGF0YShmcm9tKSB7XG5cbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgLy8gcmVzZXQgdWlkIGNhdXNlIHRhYmxlIGRhdGEgaGFzIGNoYW5nZWRcbiAgICAgICAgbWUudWlkID0gMDtcblxuICAgICAgICAvLyBmZXRjaFVybCBoYXMgdGhlIHRvcCBwcmlvcml0eS5cbiAgICAgICAgaWYgKCEhbWUucHJvcHMuZmV0Y2hVcmwpIHtcbiAgICAgICAgICAgIGlmIChtZS5hamF4KSB7XG4gICAgICAgICAgICAgICAgbWUuYWpheC5hYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtZS5zdGF0ZS5zaG93TWFzaykge1xuICAgICAgICAgICAgICAgIG1lLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgc2hvd01hc2s6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhamF4T3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICB1cmw6IG1lLnByb3BzLmZldGNoVXJsLFxuICAgICAgICAgICAgICAgIGRhdGE6IG1lLmdldFF1ZXJ5T2JqKGZyb20pLFxuICAgICAgICAgICAgICAgIGNhY2hlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogXCJqc29uXCIsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gc3VjY2VzcyhyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzID09PSB0cnVlIHx8IHJlc3VsdC5oYXNFcnJvciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfZGF0YSA9IHJlc3VsdC5jb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb2Nlc3NlZERhdGEgPSBtZS5hZGRWYWx1ZXNJbkRhdGEobWUucHJvcHMucHJvY2Vzc0RhdGEoZGVlcGNvcHkoX2RhdGEpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXBkYXRlT2JqID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHByb2Nlc3NlZERhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvd01hc2s6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3NlZERhdGEuY3VycmVudFBhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZU9iai5jdXJyZW50UGFnZSA9IHByb2Nlc3NlZERhdGEuY3VycmVudFBhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5kYXRhID0gZGVlcGNvcHkocHJvY2Vzc2VkRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5zZXRTdGF0ZSh1cGRhdGVPYmopO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUucHJvcHMub25GZXRjaEVycm9yKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoL1xcLmpzb25wLy50ZXN0KG1lLnByb3BzLmZldGNoVXJsKSkge1xuICAgICAgICAgICAgICAgIGFqYXhPcHRpb25zLmRhdGFUeXBlID0gXCJqc29ucFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5hamF4ID0gJC5hamF4KGFqYXhPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmICghIW1lLnByb3BzLnBhc3NlZERhdGEpIHtcblxuICAgICAgICAgICAgaWYgKCFtZS5wcm9wcy5xdWVyeUtleXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IG1lLmFkZFZhbHVlc0luRGF0YShtZS5wcm9wcy5wcm9jZXNzRGF0YShkZWVwY29weShtZS5wcm9wcy5wYXNzZWREYXRhKSkpO1xuICAgICAgICAgICAgICAgIG1lLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG1lLmRhdGEgPSBkZWVwY29weShkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgbWUucHJvcHMucXVlcnlLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZS5wcm9wcy5wYXNzZWREYXRhW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFba2V5XSA9IG1lLnByb3BzLnBhc3NlZERhdGFba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9jZXNzZWREYXRhID0gbWUuYWRkVmFsdWVzSW5EYXRhKG1lLnByb3BzLnByb2Nlc3NEYXRhKGRlZXBjb3B5KGRhdGEpKSk7XG4gICAgICAgICAgICAgICAgICAgIG1lLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHByb2Nlc3NlZERhdGFcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG1lLmRhdGEgPSBkZWVwY29weShwcm9jZXNzZWREYXRhKTtcbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEhdGhpcy5wcm9wcy5qc3hkYXRhKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuYWRkVmFsdWVzSW5EYXRhKGRlZXBjb3B5KHRoaXMucHJvcHMuanN4ZGF0YSkpO1xuICAgICAgICAgICAgbWUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbWUuZGF0YSA9IGRlZXBjb3B5KGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9kZWZhdWx0IHdpbGwgY3JlYXRlIG9uZSByb3dcbiAgICAgICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgICAgIGRhdGE6IFt7XG4gICAgICAgICAgICAgICAgICAgIGpzeGlkOiBtZS51aWQrKyxcbiAgICAgICAgICAgICAgICAgICAgX19tb2RlX186IENvbnN0Lk1PREUuRURJVFxuICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIFwiY3VycmVudFBhZ2VcIjogMSxcbiAgICAgICAgICAgICAgICBcInRvdGFsQ291bnRcIjogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG1lLmRhdGEgPSBkZWVwY29weShkYXRhKTtcbiAgICAgICAgICAgIG1lLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBcImRhdGFcIjogZGVlcGNvcHkoZGF0YSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFRhYmxlLnByb3RvdHlwZS5wcm9jZXNzQ29sdW1uID0gZnVuY3Rpb24gcHJvY2Vzc0NvbHVtbihwcm9wcykge1xuXG4gICAgICAgIHByb3BzID0gcHJvcHMgfHwgdGhpcy5wcm9wcztcblxuICAgICAgICB2YXIgbWUgPSB0aGlzLFxuICAgICAgICAgICAgY29sdW1ucyA9IGRlZXBjb3B5KHByb3BzLmpzeGNvbHVtbnMpLFxuICAgICAgICAgICAgaGFzQ2hlY2tib3hDb2x1bW4gPSBmYWxzZTtcblxuICAgICAgICBjb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgb25lIHJvd1NlbGVjdG9yIGNhbiBiZSByZW5kZXJlZCBpbiBUYWJsZS5cbiAgICAgICAgICAgIGlmIChpdGVtLnR5cGUgPT0gJ2NoZWNrYm94JyB8fCBpdGVtLnR5cGUgPT0gJ3JhZGlvU2VsZWN0b3InIHx8IGl0ZW0udHlwZSA9PSAnY2hlY2tib3hTZWxlY3RvcicpIHtcbiAgICAgICAgICAgICAgICBoYXNDaGVja2JveENvbHVtbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgbWUuY2hlY2tib3hDb2x1bW4gPSBpdGVtO1xuICAgICAgICAgICAgICAgIG1lLmNoZWNrYm94Q29sdW1uS2V5ID0gaXRlbS5kYXRhS2V5O1xuICAgICAgICAgICAgICAgIGl0ZW0ud2lkdGggPSBpdGVtLndpZHRoIHx8IDMyO1xuICAgICAgICAgICAgICAgIGl0ZW0uYWxpZ24gPSBpdGVtLmFsaWduIHx8ICdyaWdodCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGZpbHRlciB0aGUgY29sdW1uIHdoaWNoIGhhcyBhIGRhdGFLZXkgJ2pzeGNoZWNrZWQnICYgJ2pzeHRyZWVJY29uJ1xuXG4gICAgICAgIGNvbHVtbnMgPSBjb2x1bW5zLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZGF0YUtleSAhPT0gJ2pzeGNoZWNrZWQnICYmIGl0ZW0uZGF0YUtleSAhPT0gJ2pzeHRyZWVJY29uJztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaWYgaGlkZGVuIGlzIG5vdCBzZXQsIHRoZW4gaXQncyBmYWxzZVxuICAgICAgICBjb2x1bW5zID0gY29sdW1ucy5tYXAoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICBpdGVtLmhpZGRlbiA9ICEhaXRlbS5oaWRkZW47XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCEhcHJvcHMucm93U2VsZWN0aW9uICYgIWhhc0NoZWNrYm94Q29sdW1uKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oXCJJdCB3aWxsIGJlIGRlcHJlY2F0ZWQgdGhhdCBhIGNoZWNrYm94KHJhZGlvKSBpbiBmaXJzdCBjb2x1bW4gd2l0aG91dCBjb2x1bW4gY29uZmlnLCBZb3Ugc2hvdWxkIHNwZWNpZnkgdGhlIGNvbHVtbiB0eXBlIHdpdGggJ2NoZWNrYm94U2VsZWN0b3InIG9yICdyYWRpb1NlbGVjdG9yJ1wiKTtcbiAgICAgICAgICAgIG1lLmNoZWNrYm94Q29sdW1uID0ge1xuICAgICAgICAgICAgICAgIGRhdGFLZXk6ICdqc3hjaGVja2VkJyxcbiAgICAgICAgICAgICAgICB3aWR0aDogMzIsXG4gICAgICAgICAgICAgICAgdHlwZTogcHJvcHMucm93U2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgYWxpZ246ICdyaWdodCdcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBtZS5jaGVja2JveENvbHVtbktleSA9ICdqc3hjaGVja2VkJztcblxuICAgICAgICAgICAgY29sdW1ucyA9IFttZS5jaGVja2JveENvbHVtbl0uY29uY2F0KGNvbHVtbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm8gcm93U2VsZWN0aW9uIGJ1dCBoYXMgcGFyZW50SGFzQ2hlY2tib3gsIHJlbmRlciBwbGFjZWhvbGRlclxuICAgICAgICBlbHNlIGlmICghIXByb3BzLnBhcmVudEhhc0NoZWNrYm94KSB7XG4gICAgICAgICAgICAgICAgY29sdW1ucyA9IFt7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFLZXk6ICdqc3h3aGl0ZScsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiA0NixcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2VtcHR5J1xuICAgICAgICAgICAgICAgIH1dLmNvbmNhdChjb2x1bW5zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbm8gcm93U2VsZWN0aW9uIGJ1dCBoYXMgcGFyZW50SGFzQ2hlY2ssIHJlbmRlciBwbGFjZWhvbGRlclxuICAgICAgICAgICAgZWxzZSBpZiAoISFwcm9wcy5wYXJlbnRIYXNDaGVjaykge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW5zID0gW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFLZXk6ICdqc3h3aGl0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogNDYsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZW1wdHknXG4gICAgICAgICAgICAgICAgICAgIH1dLmNvbmNhdChjb2x1bW5zKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgaWYgKCghIXByb3BzLnN1YkNvbXAgfHwgISFwcm9wcy5yZW5kZXJTdWJDb21wKSAmJiBwcm9wcy5yZW5kZXJNb2RlbCAhPT0gJ3RyZWUnKSB7XG4gICAgICAgICAgICBjb2x1bW5zID0gW3tcbiAgICAgICAgICAgICAgICBkYXRhS2V5OiAnanN4dHJlZUljb24nLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAzNCxcbiAgICAgICAgICAgICAgICB0eXBlOiAndHJlZUljb24nXG4gICAgICAgICAgICB9XS5jb25jYXQoY29sdW1ucyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm8gc3ViQ29tcCBidXQgaGFzIHBhc3NlZERhdGEsIG1lYW5zIHN1YiBtb2RlLCBwYXJlbnQgc2hvdWxkIGhhcyB0cmVlIGljb24sXG4gICAgICAgIC8vIHJlbmRlciB0cmVlIGljb24gcGxhY2Vob2xkZXJcbiAgICAgICAgZWxzZSBpZiAoISFwcm9wcy5wYXNzZWREYXRhKSB7XG4gICAgICAgICAgICAgICAgY29sdW1ucyA9IFt7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFLZXk6ICdqc3h3aGl0ZScsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAzNCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2VtcHR5J1xuICAgICAgICAgICAgICAgIH1dLmNvbmNhdChjb2x1bW5zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29sdW1ucztcbiAgICB9O1xuXG4gICAgVGFibGUucHJvdG90eXBlLmhhbmRsZUNvbHVtblBpY2tlckNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUNvbHVtblBpY2tlckNoYW5nZShjaGVja2VkS2V5cykge1xuICAgICAgICB2YXIgX2NvbHVtbnMgPSBkZWVwY29weSh0aGlzLnN0YXRlLmNvbHVtbnMpO1xuICAgICAgICB2YXIgbm90UmVuZGVyQ29sdW1ucyA9IFsnanN4Y2hlY2tlZCcsICdqc3h0cmVlSWNvbicsICdqc3h3aGl0ZSddO1xuXG4gICAgICAgIF9jb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoJ2dyb3VwJyBpbiBpdGVtKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5jb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGVsZSwgaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGVja2VkS2V5cy5pbmRleE9mKGVsZS5kYXRhS2V5KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZS5oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZS5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjaGVja2VkS2V5cy5pbmRleE9mKGl0ZW0uZGF0YUtleSkgIT09IC0xIHx8IG5vdFJlbmRlckNvbHVtbnMuaW5kZXhPZihpdGVtLmRhdGFLZXkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGNvbHVtbnM6IF9jb2x1bW5zXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjaGFuZ2UgU2VsZWN0ZWRSb3dzIGRhdGEgdmlhIGNoZWNrYm94LCB0aGlzIGZ1bmN0aW9uIHdpbGwgcGFzcyB0byB0aGUgQ2VsbFxuICAgICAqIEBwYXJhbSBjaGVja2VkIHtib29sZWFufSB0aGUgY2hlY2tib3ggc3RhdHVzXG4gICAgICogQHBhcmFtIHJvd0luZGV4IHtudW1iZXJ9IHRoZSByb3cgSW5kZXhcbiAgICAgKiBAcGFyYW0gZnJvbU1vdW50IHtib29sZWFufSBvblNlbGVjdCBpcyBjYWxsZWQgZnJvbSBjZWxsIE1vdW50IGlzIG5vdCBleHBlY3RlZC5cbiAgICAgKi9cblxuICAgIFRhYmxlLnByb3RvdHlwZS5jaGFuZ2VTZWxlY3RlZCA9IGZ1bmN0aW9uIGNoYW5nZVNlbGVjdGVkKGNoZWNrZWQsIHJvd0luZGV4LCBmcm9tTW91bnQpIHtcblxuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgX2NvbnRlbnQgPSBkZWVwY29weSh0aGlzLnN0YXRlLmRhdGEpO1xuICAgICAgICB2YXIgX2RhdGEgPSBfY29udGVudC5kYXRhcyB8fCBfY29udGVudC5kYXRhO1xuXG4gICAgICAgIG1lLmNoZWNrYm94Q29sdW1uLnR5cGUgPT0gJ3JhZGlvU2VsZWN0b3InID8gX2RhdGEubWFwKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKGl0ZW0uanN4aWQgPT0gcm93SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpdGVtW21lLmNoZWNrYm94Q29sdW1uS2V5XSA9IGNoZWNrZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW1bbWUuY2hlY2tib3hDb2x1bW5LZXldKSB7XG4gICAgICAgICAgICAgICAgaXRlbVttZS5jaGVja2JveENvbHVtbktleV0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkgOiBfZGF0YS5tYXAoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5qc3hpZCA9PSByb3dJbmRleCkge1xuICAgICAgICAgICAgICAgIGl0ZW1bbWUuY2hlY2tib3hDb2x1bW5LZXldID0gY2hlY2tlZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZGF0YTogX2NvbnRlbnRcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFmcm9tTW91bnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IG1lLnN0YXRlLmRhdGEuZGF0YXMgfHwgbWUuc3RhdGUuZGF0YS5kYXRhO1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZFJvd3MgPSBkYXRhLmZpbHRlcihmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1bbWUuY2hlY2tib3hDb2x1bW5LZXldID09IHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgISFtZS5wcm9wcy5yb3dTZWxlY3Rpb24gJiYgISFtZS5wcm9wcy5yb3dTZWxlY3Rpb24ub25TZWxlY3QgJiYgbWUucHJvcHMucm93U2VsZWN0aW9uLm9uU2VsZWN0KGNoZWNrZWQsIGRhdGFbcm93SW5kZXhdLCBzZWxlY3RlZFJvd3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgVGFibGUucHJvdG90eXBlLnNlbGVjdEFsbCA9IGZ1bmN0aW9uIHNlbGVjdEFsbChjaGVja2VkKSB7XG5cbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIF9jb250ZW50ID0gZGVlcGNvcHkobWUuc3RhdGUuZGF0YSk7XG4gICAgICAgIHZhciBfZGF0YSA9IF9jb250ZW50LmRhdGFzIHx8IF9jb250ZW50LmRhdGE7XG4gICAgICAgIHZhciByb3dTZWxlY3Rpb24gPSBtZS5wcm9wcy5yb3dTZWxlY3Rpb247XG5cbiAgICAgICAgdmFyIHNlbGVjdGVkUm93cyA9IFtdO1xuICAgICAgICBfZGF0YSA9IF9kYXRhLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgY29sdW1uID0gbWUuY2hlY2tib3hDb2x1bW47XG4gICAgICAgICAgICB2YXIga2V5ID0gbWUuY2hlY2tib3hDb2x1bW5LZXk7XG4gICAgICAgICAgICBpZiAoISgnaXNEaXNhYmxlJyBpbiBjb2x1bW4pIHx8ICFjb2x1bW4uaXNEaXNhYmxlKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgaXRlbVtrZXldID0gY2hlY2tlZDtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZFJvd3MucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCEhcm93U2VsZWN0aW9uICYmICEhcm93U2VsZWN0aW9uLm9uU2VsZWN0QWxsKSB7XG4gICAgICAgICAgICByb3dTZWxlY3Rpb24ub25TZWxlY3RBbGwuYXBwbHkobnVsbCwgW2NoZWNrZWQsIGNoZWNrZWQgPyBzZWxlY3RlZFJvd3MgOiBbXV0pO1xuICAgICAgICB9XG4gICAgICAgIG1lLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGRhdGE6IF9jb250ZW50XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBUYWJsZS5wcm90b3R5cGUub25QYWdlQ2hhbmdlID0gZnVuY3Rpb24gb25QYWdlQ2hhbmdlKGN1cnJlbnQpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgbWUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgY3VycmVudFBhZ2U6IGN1cnJlbnRcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbWUuZmV0Y2hEYXRhKFwicGFnaW5hdGlvblwiKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIFRhYmxlLnByb3RvdHlwZS5oYW5kbGVTaG93U2l6ZUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZVNob3dTaXplQ2hhbmdlKGN1cnJlbnQsIHBhZ2VTaXplKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIG1lLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGN1cnJlbnRQYWdlOiBjdXJyZW50LFxuICAgICAgICAgICAgcGFnZVNpemU6IHBhZ2VTaXplXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG1lLmZldGNoRGF0YShcInBhZ2luYXRpb25cIik7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBUYWJsZS5wcm90b3R5cGUucmVuZGVyUGFnZXIgPSBmdW5jdGlvbiByZW5kZXJQYWdlcigpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIF9tZSRzdGF0ZSA9IG1lLnN0YXRlO1xuICAgICAgICB2YXIgZGF0YSA9IF9tZSRzdGF0ZS5kYXRhO1xuICAgICAgICB2YXIgY3VycmVudFBhZ2UgPSBfbWUkc3RhdGUuY3VycmVudFBhZ2U7XG4gICAgICAgIHZhciBwYWdlU2l6ZSA9IF9tZSRzdGF0ZS5wYWdlU2l6ZTtcbiAgICAgICAgdmFyIF9tZSRwcm9wcyA9IG1lLnByb3BzO1xuICAgICAgICB2YXIgc2hvd1BhZ2VyVG90YWwgPSBfbWUkcHJvcHMuc2hvd1BhZ2VyVG90YWw7XG4gICAgICAgIHZhciBzaG93UGFnZXIgPSBfbWUkcHJvcHMuc2hvd1BhZ2VyO1xuICAgICAgICB2YXIgbG9jYWxlID0gX21lJHByb3BzLmxvY2FsZTtcblxuXG4gICAgICAgIGlmIChzaG93UGFnZXIgJiYgZGF0YSAmJiBkYXRhLnRvdGFsQ291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6IFwia3VtYS11eHRhYmxlLXBhZ2VcIiB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUGFnaW5hdGlvbiwgeyBjbGFzc05hbWU6IFwibWluaVwiLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgc2hvd1NpemVDaGFuZ2VyOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzaG93VG90YWw6IHNob3dQYWdlclRvdGFsLFxuICAgICAgICAgICAgICAgICAgICB0b3RhbDogZGF0YS50b3RhbENvdW50LFxuICAgICAgICAgICAgICAgICAgICBvblNob3dTaXplQ2hhbmdlOiBtZS5oYW5kbGVTaG93U2l6ZUNoYW5nZS5iaW5kKG1lKSxcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6IG1lLm9uUGFnZUNoYW5nZS5iaW5kKG1lKSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudDogY3VycmVudFBhZ2UsXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VTaXplOiBwYWdlU2l6ZSB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBUYWJsZS5wcm90b3R5cGUuaGFuZGxlT3JkZXJDb2x1bW5DQiA9IGZ1bmN0aW9uIGhhbmRsZU9yZGVyQ29sdW1uQ0IodHlwZSwgY29sdW1uKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIG1lLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGFjdGl2ZUNvbHVtbjogY29sdW1uLFxuICAgICAgICAgICAgb3JkZXJUeXBlOiB0eXBlXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG1lLmZldGNoRGF0YShcIm9yZGVyXCIpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgVGFibGUucHJvdG90eXBlLmhhbmRsZUFjdGlvbkJhclNlYXJjaCA9IGZ1bmN0aW9uIGhhbmRsZUFjdGlvbkJhclNlYXJjaCh2YWx1ZSkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHNlYXJjaFR4dDogdmFsdWVcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbWUuZmV0Y2hEYXRhKFwic2VhcmNoXCIpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgVGFibGUucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiBnZXREYXRhKHZhbGlkYXRlKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBwYXNzID0gdHJ1ZTtcbiAgICAgICAgaWYgKHZhbGlkYXRlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgZm9yIChuYW1lIGluIG1lLmZpZWxkcykge1xuICAgICAgICAgICAgICAgIHZhciBmaWVsZFBhc3MgPSBtZS5maWVsZHNbbmFtZV0oKTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIG9uZSBmaWVsZCBmYWlscyB0byBwYXNzLCB0aGUgdGFibGUgZmFpbHMgdG8gcGFzc1xuICAgICAgICAgICAgICAgIGlmIChwYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhc3MgPSBmaWVsZFBhc3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZS5wcm9wcy5nZXRTYXZlZERhdGEpIHtcbiAgICAgICAgICAgIC8vIOa7pOmZpOWPr+iDveS4uuepuueahOWFg+e0oFxuICAgICAgICAgICAgdmFyIGRhdGEgPSBkZWVwY29weShtZS5kYXRhKTtcbiAgICAgICAgICAgIGRhdGEuZGF0YSA9IGRhdGEuZGF0YS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbSAhPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICBwYXNzOiBwYXNzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBtZS5zdGF0ZS5kYXRhLFxuICAgICAgICAgICAgICAgIHBhc3M6IHBhc3NcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgVGFibGUucHJvdG90eXBlLmhhc0ZpeENvbHVtbiA9IGZ1bmN0aW9uIGhhc0ZpeENvbHVtbigpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIF9jb2x1bW5zID0gcHJvcHMuanN4Y29sdW1ucy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChpdGVtLmZpeGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoX2NvbHVtbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBUYWJsZS5wcm90b3R5cGUucmVuZGVySGVhZGVyID0gZnVuY3Rpb24gcmVuZGVySGVhZGVyKHJlbmRlckhlYWRlclByb3BzKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLnByb3BzLnNob3dIZWFkZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmhhc0ZpeENvbHVtbigpKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBcImt1bWEtdXh0YWJsZS1oZWFkZXItd3JhcHBlclwiIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChIZWFkZXIsIF9leHRlbmRzKHt9LCByZW5kZXJIZWFkZXJQcm9wcywgeyBmaXhlZENvbHVtbjogXCJmaXhlZFwiLCBrZXk6IFwiZ3JpZC1oZWFkZXItZml4ZWRcIiB9KSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChIZWFkZXIsIF9leHRlbmRzKHt9LCByZW5kZXJIZWFkZXJQcm9wcywgeyBmaXhlZENvbHVtbjogXCJzY3JvbGxcIiwga2V5OiBcImdyaWQtaGVhZGVyLXNjcm9sbFwiIH0pKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6IFwia3VtYS11eHRhYmxlLWhlYWRlci13cmFwcGVyXCIgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEhlYWRlciwgX2V4dGVuZHMoe30sIHJlbmRlckhlYWRlclByb3BzLCB7IGZpeGVkQ29sdW1uOiBcIm5vXCIgfSkpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFRhYmxlLnByb3RvdHlwZS5yZW5kZXJUYm9keSA9IGZ1bmN0aW9uIHJlbmRlclRib2R5KHJlbmRlckJvZHlQcm9wcywgYm9keUhlaWdodCkge1xuXG4gICAgICAgIGlmICh0aGlzLmhhc0ZpeENvbHVtbigpKSB7XG4gICAgICAgICAgICB2YXIgc3ViQ29tcCA9IHJlbmRlckJvZHlQcm9wcy5zdWJDb21wO1xuXG4gICAgICAgICAgICB2YXIgZml4ZWRCb2R5UHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocmVuZGVyQm9keVByb3BzLCBbXCJzdWJDb21wXCJdKTtcblxuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogXCJrdW1hLXV4dGFibGUtYm9keS13cmFwcGVyXCIsIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGJvZHlIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGJvZHksIF9leHRlbmRzKHt9LCBmaXhlZEJvZHlQcm9wcywgeyBmaXhlZENvbHVtbjogXCJmaXhlZFwiLCBrZXk6IFwiZ3JpZC1ib2R5LWZpeGVkXCIgfSkpLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGJvZHksIF9leHRlbmRzKHt9LCByZW5kZXJCb2R5UHJvcHMsIHsgZml4ZWRDb2x1bW46IFwic2Nyb2xsXCIsIGtleTogXCJncmlkLWJvZHktc2Nyb2xsXCIgfSkpXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogXCJrdW1hLXV4dGFibGUtYm9keS13cmFwcGVyXCIsIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGJvZHlIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGJvZHksIF9leHRlbmRzKHt9LCByZW5kZXJCb2R5UHJvcHMsIHsgZml4ZWRDb2x1bW46IFwibm9cIiB9KSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgVGFibGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIF9jbGFzc25hbWVzO1xuXG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBib2R5SGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyBpZiB0YWJsZSBpcyBpbiBzdWIgbW9kZSwgcGVvcGxlIGFsd2F5cyB3YW50IHRvIGFsaWduIHRoZSBwYXJlbnRcbiAgICAgICAgLy8gYW5kIHRoZSBzdWIgdGFibGUsIHNvIHdpZHRoIHNob3VsZCBub3QgYmUgY2FyZWQuXG4gICAgICAgIHZhciBoZWFkZXJIZWlnaHQgPSBwcm9wcy5oZWFkZXJIZWlnaHQ7XG5cblxuICAgICAgICB2YXIgX3N0eWxlID0ge1xuICAgICAgICAgICAgd2lkdGg6ICEhcHJvcHMucGFzc2VkRGF0YSA/IFwiYXV0b1wiIDogcHJvcHMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHByb3BzLmhlaWdodFxuICAgICAgICB9O1xuICAgICAgICB2YXIgYWN0aW9uQmFySGVpZ2h0ID0gcHJvcHMuYWN0aW9uQmFyID8gcHJvcHMuYWN0aW9uQmFySGVpZ2h0IDogMDtcbiAgICAgICAgdmFyIHBhZ2VySGVpZ2h0ID0gcHJvcHMuc2hvd1BhZ2VyICYmIHRoaXMuc3RhdGUuZGF0YSAmJiB0aGlzLnN0YXRlLmRhdGEudG90YWxDb3VudCA/IDUwIDogMDtcblxuICAgICAgICAvLyBkZWNpZGUgd2hldGhlciB0aGUgdGFibGUgaGFzIGNvbHVtbiBncm91cHNcbiAgICAgICAgdmFyIGhhc0dyb3VwID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdGF0ZS5jb2x1bW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoJ2dyb3VwJyBpbiB0aGlzLnN0YXRlLmNvbHVtbnNbaV0pIHtcbiAgICAgICAgICAgICAgICBoYXNHcm91cCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBoZWFkZXJIZWlnaHQgPSBoZWFkZXJIZWlnaHQgfHwgKGhhc0dyb3VwID8gODAgOiA0MCk7XG5cbiAgICAgICAgaWYgKHByb3BzLmhlaWdodCA9PSAnYXV0bycpIHtcbiAgICAgICAgICAgIGJvZHlIZWlnaHQgPSAnYXV0byc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBib2R5SGVpZ2h0ID0gcHJvcHMuaGVpZ2h0ID09IFwiMTAwJVwiID8gcHJvcHMuaGVpZ2h0IDogcHJvcHMuaGVpZ2h0IC0gaGVhZGVySGVpZ2h0IC0gYWN0aW9uQmFySGVpZ2h0IC0gcGFnZXJIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlbmRlckJvZHlQcm9wcyA9IHtcbiAgICAgICAgICAgIGNvbHVtbnM6IHRoaXMuc3RhdGUuY29sdW1ucyxcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuc3RhdGUuZGF0YSA/IHRoaXMuc3RhdGUuZGF0YS5kYXRhcyB8fCB0aGlzLnN0YXRlLmRhdGEuZGF0YSA6IFtdLFxuICAgICAgICAgICAgb25Nb2RpZnlSb3c6IHByb3BzLm9uTW9kaWZ5Um93ID8gcHJvcHMub25Nb2RpZnlSb3cgOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgICAgIHJvd1NlbGVjdGlvbjogcHJvcHMucm93U2VsZWN0aW9uLFxuICAgICAgICAgICAgYWRkUm93Q2xhc3NOYW1lOiBwcm9wcy5hZGRSb3dDbGFzc05hbWUsXG4gICAgICAgICAgICBzdWJDb21wOiBwcm9wcy5zdWJDb21wLFxuICAgICAgICAgICAgcmVuZGVyU3ViQ29tcDogcHJvcHMucmVuZGVyU3ViQ29tcCxcbiAgICAgICAgICAgIG1hc2s6IHRoaXMuc3RhdGUuc2hvd01hc2ssXG4gICAgICAgICAgICBjaGFuZ2VTZWxlY3RlZDogdGhpcy5jaGFuZ2VTZWxlY3RlZC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgcm93SGVpZ2h0OiB0aGlzLnByb3BzLnJvd0hlaWdodCxcbiAgICAgICAgICAgIGhlaWdodDogYm9keUhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoOiBwcm9wcy53aWR0aCxcbiAgICAgICAgICAgIHJvb3Q6IHRoaXMsXG4gICAgICAgICAgICBtb2RlOiBwcm9wcy5tb2RlLFxuICAgICAgICAgICAgcmVuZGVyTW9kZWw6IHByb3BzLnJlbmRlck1vZGVsLFxuICAgICAgICAgICAgbGV2ZWxzOiBwcm9wcy5sZXZlbHMsXG4gICAgICAgICAgICBoYW5kbGVEYXRhQ2hhbmdlOiB0aGlzLmhhbmRsZURhdGFDaGFuZ2UuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGF0dGFjaENlbGxGaWVsZDogdGhpcy5hdHRhY2hDZWxsRmllbGQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGRldGFjaENlbGxGaWVsZDogdGhpcy5kZXRhY2hDZWxsRmllbGQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGtleTogJ2dyaWQtYm9keSdcbiAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbmRlckhlYWRlclByb3BzID0ge1xuICAgICAgICAgICAgY29sdW1uczogdGhpcy5zdGF0ZS5jb2x1bW5zLFxuICAgICAgICAgICAgYWN0aXZlQ29sdW1uOiB0aGlzLnN0YXRlLmFjdGl2ZUNvbHVtbixcbiAgICAgICAgICAgIG9yZGVyVHlwZTogdGhpcy5zdGF0ZS5vcmRlclR5cGUsXG4gICAgICAgICAgICBjaGVja0FsbDogdGhpcy5zZWxlY3RBbGwuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGNvbHVtblBpY2tlcjogcHJvcHMuc2hvd0NvbHVtblBpY2tlcixcbiAgICAgICAgICAgIHNob3dIZWFkZXJCb3JkZXI6IHByb3BzLnNob3dIZWFkZXJCb3JkZXIsXG4gICAgICAgICAgICBoYW5kbGVDb2x1bW5QaWNrZXJDaGFuZ2U6IHRoaXMuaGFuZGxlQ29sdW1uUGlja2VyQ2hhbmdlLmJpbmQodGhpcyksXG4gICAgICAgICAgICBoZWFkZXJIZWlnaHQ6IHByb3BzLmhlYWRlckhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoOiBwcm9wcy53aWR0aCxcbiAgICAgICAgICAgIG1vZGU6IHByb3BzLm1vZGUsXG4gICAgICAgICAgICBvcmRlckNvbHVtbkNCOiB0aGlzLmhhbmRsZU9yZGVyQ29sdW1uQ0IuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGtleTogJ2dyaWQtaGVhZGVyJ1xuXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGFjdGlvbkJhciA9IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAocHJvcHMuYWN0aW9uQmFyIHx8IHByb3BzLnNob3dTZWFyY2gpIHtcbiAgICAgICAgICAgIHZhciByZW5kZXJBY3Rpb25Qcm9wcyA9IHtcbiAgICAgICAgICAgICAgICBvblNlYXJjaDogdGhpcy5oYW5kbGVBY3Rpb25CYXJTZWFyY2guYmluZCh0aGlzKSxcbiAgICAgICAgICAgICAgICBhY3Rpb25CYXJDb25maWc6IHRoaXMucHJvcHMuYWN0aW9uQmFyLFxuICAgICAgICAgICAgICAgIHNob3dTZWFyY2g6IHRoaXMucHJvcHMuc2hvd1NlYXJjaCxcbiAgICAgICAgICAgICAgICBzZWFyY2hCYXJQbGFjZWhvbGRlcjogdGhpcy5wcm9wcy5zZWFyY2hCYXJQbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICBrZXk6ICdncmlkLWFjdGlvbmJhcidcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhY3Rpb25CYXIgPSBSZWFjdC5jcmVhdGVFbGVtZW50KEFjdGlvbkJhciwgcmVuZGVyQWN0aW9uUHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6IGNsYXNzbmFtZXMoKF9jbGFzc25hbWVzID0ge30sIF9jbGFzc25hbWVzW3Byb3BzLmpzeHByZWZpeENsc10gPSB0cnVlLCBfY2xhc3NuYW1lc1tcImt1bWEtc3ViZ3JpZC1tb2RlXCJdID0gISFwcm9wcy5wYXNzZWREYXRhLCBfY2xhc3NuYW1lcykpLCBzdHlsZTogX3N0eWxlIH0sXG4gICAgICAgICAgICBhY3Rpb25CYXIsXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6IFwia3VtYS11eHRhYmxlLWNvbnRlbnRcIiwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAhIXByb3BzLnBhc3NlZERhdGEgPyBcImF1dG9cIiA6IHByb3BzLndpZHRoXG4gICAgICAgICAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckhlYWRlcihyZW5kZXJIZWFkZXJQcm9wcyksXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJUYm9keShyZW5kZXJCb2R5UHJvcHMsIGJvZHlIZWlnaHQpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJQYWdlcigpXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gVXRpbCBNZXRob2QgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgLyoqXG4gICAgICogYWRkIHNvbWUgc3BlY2lmaWMgdmFsdWUgZm9yIGVhY2ggcm93IGRhdGEgd2hpY2ggd2lsbCBiZSB1c2VkIGluIG1hbmlwdWxhdGluZyBkYXRhICYgcmVuZGVyaW5nLlxuICAgICAqIHVzZWQgaW4gcmVjb3JkIEFQSS5cbiAgICAgKi9cblxuICAgIFRhYmxlLnByb3RvdHlwZS5hZGRKU1hJZHNGb3JSZWNvcmQgPSBmdW5jdGlvbiBhZGRKU1hJZHNGb3JSZWNvcmQob2JqQXV4KSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIGlmIChvYmpBdXggaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgb2JqQXV4ID0gb2JqQXV4Lm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmpzeGlkID09IHVuZGVmaW5lZCB8fCBpdGVtLmpzeGlkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5qc3hpZCA9IG1lLnVpZCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0uX19tb2RlX18pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5fX21vZGVfXyA9IENvbnN0Lk1PREUuRURJVDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9iakF1eC5qc3hpZCA9IG1lLnVpZCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmpBdXg7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGFkZCBzb21lIHNwZWNpZmljIHZhbHVlIGZvciBlYWNoIHJvdyBkYXRhIHdoaWNoIHdpbGwgYmUgdXNlZCBpbiBtYW5pcHVsYXRpbmcgZGF0YSAmIHJlbmRlcmluZy5cbiAgICAgKiB1c2VkIGluIG1ldGhvZCBmZXRjaERhdGFcbiAgICAgKi9cblxuICAgIFRhYmxlLnByb3RvdHlwZS5hZGRWYWx1ZXNJbkRhdGEgPSBmdW5jdGlvbiBhZGRWYWx1ZXNJbkRhdGEob2JqQXV4KSB7XG4gICAgICAgIGlmICghb2JqQXV4IHx8ICFvYmpBdXguZGF0YXMgJiYgIW9iakF1eC5kYXRhKSByZXR1cm47XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBkYXRhID0gb2JqQXV4LmRhdGFzIHx8IG9iakF1eC5kYXRhO1xuICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUuanN4aWQgPSBtZS51aWQrKztcbiAgICAgICAgICAgIG5vZGUuX19tb2RlX18gPSBub2RlLl9fbW9kZV9fIHx8IENvbnN0Lk1PREUuVklFVztcbiAgICAgICAgICAgIG1lLmFkZFZhbHVlc0luRGF0YShub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvYmpBdXg7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIG1lcmdlIGRhdGFcbiAgICAgKi9cblxuICAgIFRhYmxlLnByb3RvdHlwZS5tZXJnZURhdGEgPSBmdW5jdGlvbiBtZXJnZURhdGEoZGF0YSwgb2JqKSB7XG4gICAgICAgIHZhciBuZXdEYXRhID0gZGVlcGNvcHkoZGF0YSk7XG5cbiAgICAgICAgLy8gY29kZSBjb21wYXRpYmxlXG4gICAgICAgIGlmICghIW5ld0RhdGEuZGF0YXMpIHtcbiAgICAgICAgICAgIG5ld0RhdGEuZGF0YXMgPSBuZXdEYXRhLmRhdGFzLmNvbmNhdChvYmopO1xuICAgICAgICB9IGVsc2UgaWYgKCEhbmV3RGF0YS5kYXRhKSB7XG4gICAgICAgICAgICBuZXdEYXRhLmRhdGEgPSBuZXdEYXRhLmRhdGEuY29uY2F0KG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgbmV3RGF0YS50b3RhbENvdW50Kys7XG4gICAgICAgIHJldHVybiBuZXdEYXRhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBpbnNlcnQgc29tZSBkYXRhIGludG8gdGhpcy5zdGF0ZS5kYXRhXG4gICAgICogQHBhcmFtIG9iakF1eCB7QXJyYXkgb3IgT2JqZWN0fSBkYXR1bSBvciBkYXRhIG5lZWQgdG8gYmUgaW5zZXJ0ZWRcbiAgICAgKi9cblxuICAgIFRhYmxlLnByb3RvdHlwZS5pbnNlcnRSZWNvcmRzID0gZnVuY3Rpb24gaW5zZXJ0UmVjb3JkcyhvYmpBdXgpIHtcbiAgICAgICAgaWYgKCh0eXBlb2Ygb2JqQXV4ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqQXV4KSkgIT09IFwib2JqZWN0XCIpIHJldHVybjtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgaWYgKCEob2JqQXV4IGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgICBvYmpBdXggPSBbb2JqQXV4XTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iakF1eCA9IHRoaXMuYWRkSlNYSWRzRm9yUmVjb3JkKG9iakF1eCk7XG5cbiAgICAgICAgLy8gbWUuZGF0YSA9IG1lLm1lcmdlRGF0YShtZS5kYXRhLCBvYmpBdXgpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGRhdGE6IG1lLm1lcmdlRGF0YShtZS5zdGF0ZS5kYXRhLCBvYmpBdXgpXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iakF1eH0ge2E6J2InLGM6J2QnLGpzeGlkOicnfVxuICAgICAqL1xuXG5cbiAgICBUYWJsZS5wcm90b3R5cGUudXBkYXRlUmVjb3JkID0gZnVuY3Rpb24gdXBkYXRlUmVjb3JkKG9iakF1eCwgY2IpIHtcbiAgICAgICAgdmFyIF9kYXRhID0gdGhpcy5zdGF0ZS5kYXRhO1xuXG4gICAgICAgIGlmICghX2RhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfZGF0YS5kYXRhIHx8IF9kYXRhLmRhdGFzKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IF9kYXRhLmRhdGEgfHwgX2RhdGEuZGF0YXM7XG5cbiAgICAgICAgICAgIGRhdGEgPSBkYXRhLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmpzeGlkID09IG9iakF1eC5qc3hpZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqQXV4O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCEhX2RhdGEuZGF0YSkge1xuICAgICAgICAgICAgICAgIF9kYXRhLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghIV9kYXRhLmRhdGFzKSB7XG4gICAgICAgICAgICAgICAgX2RhdGEuZGF0YXMgPSBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZGF0YTogX2RhdGFcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgISFjYiAmJiBjYigpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgVGFibGUucHJvdG90eXBlLnN5bmNSZWNvcmQgPSBmdW5jdGlvbiBzeW5jUmVjb3JkKG9iakF1eCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgX2RhdGEgPSBtZS5kYXRhLmRhdGEgfHwgbWUuZGF0YS5kYXRhcztcblxuICAgICAgICBtZS51cGRhdGVSZWNvcmQob2JqQXV4LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3N0YXRlRGF0YSA9IG1lLnN0YXRlLmRhdGEuZGF0YSB8fCBtZS5zdGF0ZS5kYXRhLmRhdGFzO1xuICAgICAgICAgICAgLy8gX2RhdGEuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIC8vICAgICBpZiAoaXRlbS5qc3hpZCA9PSBvYmpBdXguanN4aWQpIHtcbiAgICAgICAgICAgIC8vICAgICAgICAgX2RhdGFbaW5kZXhdID0gX3N0YXRlRGF0YS5maWx0ZXIoKGVsZSkgPT4ge1xuICAgICAgICAgICAgLy8gICAgICAgICAgICAgcmV0dXJuIGVsZS5qc3hpZCA9PSBvYmpBdXguanN4aWRcbiAgICAgICAgICAgIC8vICAgICAgICAgfSlbMF07XG4gICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgLy8gfSk7XG4gICAgICAgICAgICBfc3RhdGVEYXRhLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uanN4aWQgPT0gb2JqQXV4LmpzeGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIF9kYXRhW2luZGV4XSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBUYWJsZS5wcm90b3R5cGUucmVtb3ZlUmVjb3JkcyA9IGZ1bmN0aW9uIHJlbW92ZVJlY29yZHMob2JqQXV4KSB7XG5cbiAgICAgICAgLy9hdCBsZWFzdCBvbmUgcmVjb3JkXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBjb250ZW50ID0gdGhpcy5zdGF0ZS5kYXRhO1xuICAgICAgICB2YXIgZGF0YSA9IGNvbnRlbnQuZGF0YSB8fCBjb250ZW50LmRhdGFzO1xuXG4gICAgICAgIC8vIGRlZXBjb3B5IHByb3RlY3RcbiAgICAgICAgdmFyIF9jb250ZW50ID0gZGVlcGNvcHkoY29udGVudCksXG4gICAgICAgICAgICBfZGF0YSA9IF9jb250ZW50LmRhdGEgfHwgX2NvbnRlbnQuZGF0YXM7XG5cbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmpBdXgpICE9PSBcIltvYmplY3QgQXJyYXldXCIpIHtcbiAgICAgICAgICAgIG9iakF1eCA9IFtvYmpBdXhdO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqQXV4Lm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgX2RhdGEuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCwgaW5kZXgsIGFycmF5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuanN4aWQgPT0gaXRlbS5qc3hpZCkge1xuICAgICAgICAgICAgICAgICAgICBfZGF0YS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBtZS5kYXRhID0gX2NvbnRlbnQ7XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBkYXRhOiBfY29udGVudFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vIENVUkQgZm9yIGdpcmQgLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgVGFibGUucHJvdG90eXBlLmFkZEVtcHR5Um93ID0gZnVuY3Rpb24gYWRkRW1wdHlSb3coKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0UmVjb3Jkcyh7fSk7XG4gICAgfTtcblxuICAgIFRhYmxlLnByb3RvdHlwZS5hZGRSb3cgPSBmdW5jdGlvbiBhZGRSb3cocm93RGF0YSkge1xuICAgICAgICB0aGlzLmluc2VydFJlY29yZHMocm93RGF0YSk7XG4gICAgfTtcblxuICAgIFRhYmxlLnByb3RvdHlwZS5yZXNldFJvdyA9IGZ1bmN0aW9uIHJlc2V0Um93KHJvd0RhdGEpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIHVwZGF0ZURhdGEgPSB7fTtcbiAgICAgICAgdmFyIF9kYXRhID0gbWUuZGF0YS5kYXRhcyB8fCBtZS5kYXRhLmRhdGE7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChfZGF0YVtpXS5qc3hpZCA9PSByb3dEYXRhLmpzeGlkKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRGF0YSA9IGRlZXBjb3B5KF9kYXRhW2ldKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVEYXRhWydfX21vZGVfXyddID0gQ29uc3QuTU9ERS5FRElUO1xuICAgICAgICB0aGlzLnVwZGF0ZVJlY29yZCh1cGRhdGVEYXRhKTtcbiAgICB9O1xuXG4gICAgVGFibGUucHJvdG90eXBlLmRlbFJvdyA9IGZ1bmN0aW9uIGRlbFJvdyhyb3dEYXRhKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlUmVjb3Jkcyhyb3dEYXRhKTtcbiAgICB9O1xuXG4gICAgVGFibGUucHJvdG90eXBlLmVkaXRSb3cgPSBmdW5jdGlvbiBlZGl0Um93KHJvd0RhdGEpIHtcbiAgICAgICAgcm93RGF0YS5fX21vZGVfXyA9IENvbnN0Lk1PREUuRURJVDtcbiAgICAgICAgdGhpcy51cGRhdGVSZWNvcmQocm93RGF0YSk7XG4gICAgfTtcblxuICAgIFRhYmxlLnByb3RvdHlwZS52aWV3Um93ID0gZnVuY3Rpb24gdmlld1Jvdyhyb3dEYXRhKSB7XG4gICAgICAgIHJvd0RhdGEuX19tb2RlX18gPSBDb25zdC5NT0RFLlZJRVc7XG4gICAgICAgIHRoaXMudXBkYXRlUmVjb3JkKHJvd0RhdGEpO1xuICAgIH07XG5cbiAgICBUYWJsZS5wcm90b3R5cGUuc2F2ZVJvdyA9IGZ1bmN0aW9uIHNhdmVSb3cocm93RGF0YSkge1xuICAgICAgICByb3dEYXRhLl9fbW9kZV9fID0gQ29uc3QuTU9ERS5WSUVXO1xuICAgICAgICByb3dEYXRhLl9fZWRpdGVkX18gPSB0cnVlO1xuICAgICAgICB0aGlzLnN5bmNSZWNvcmQocm93RGF0YSk7XG4gICAgfTtcblxuICAgIFRhYmxlLnByb3RvdHlwZS5zYXZlQWxsUm93ID0gZnVuY3Rpb24gc2F2ZUFsbFJvdygpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIGRhdGEgPSBkZWVwY29weShtZS5zdGF0ZS5kYXRhLmRhdGEgfHwgbWUuc3RhdGUuZGF0YS5kYXRhcyk7XG4gICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgbWUuc2F2ZVJvdyhpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIFRhYmxlLnByb3RvdHlwZS5lZGl0QWxsUm93ID0gZnVuY3Rpb24gZWRpdEFsbFJvdygpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIGRhdGEgPSBkZWVwY29weShtZS5kYXRhLmRhdGEgfHwgbWUuZGF0YS5kYXRhcyk7XG4gICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgbWUuZWRpdFJvdyhpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIFRhYmxlLnByb3RvdHlwZS50b2dnbGVTdWJDb21wID0gZnVuY3Rpb24gdG9nZ2xlU3ViQ29tcChyb3dEYXRhKSB7XG4gICAgICAgIHZhciBfY29udGVudCA9IGRlZXBjb3B5KHRoaXMuc3RhdGUuZGF0YSk7XG4gICAgICAgIHZhciBfZGF0YSA9IF9jb250ZW50LmRhdGEgfHwgX2NvbnRlbnQuZGF0YXM7XG5cbiAgICAgICAgaWYgKF9kYXRhKSB7XG4gICAgICAgICAgICBfZGF0YSA9IF9kYXRhLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmpzeGlkID09IHJvd0RhdGEuanN4aWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5zaG93U3ViQ29tcCA9ICFpdGVtLnNob3dTdWJDb21wO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGRhdGE6IF9jb250ZW50XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gVGFibGU7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbjtcblxuVGFibGUuZGVmYXVsdFByb3BzID0ge1xuICAgIGpzeHByZWZpeENsczogXCJrdW1hLXV4dGFibGVcIixcbiAgICBsb2NhbGU6IFwiemgtY25cIixcbiAgICBzaG93SGVhZGVyOiB0cnVlLFxuICAgIHdpZHRoOiBcImF1dG9cIixcbiAgICBoZWlnaHQ6IFwiYXV0b1wiLFxuICAgIG1vZGU6IENvbnN0Lk1PREUuRURJVCxcbiAgICByZW5kZXJNb2RlbDogJycsXG4gICAgbGV2ZWxzOiAxLFxuICAgIGFjdGlvbkJhckhlaWdodDogNDAsXG4gICAgZmV0Y2hEYXRhT25Nb3VudDogdHJ1ZSxcbiAgICBkb3VibGVDbGlja1RvRWRpdDogdHJ1ZSxcbiAgICByb3dTZWxlY3RvcjogJ2NoZWNrYm94U2VsZWN0b3InLFxuICAgIHNob3dQYWdlcjogdHJ1ZSxcbiAgICBzaG93Q29sdW1uUGlja2VyOiB0cnVlLFxuICAgIHNob3dIZWFkZXJCb3JkZXI6IGZhbHNlLFxuICAgIHNob3dQYWdlclRvdGFsOiBmYWxzZSxcbiAgICBzaG93TWFzazogZmFsc2UsXG4gICAgc2hvd1NlYXJjaDogZmFsc2UsXG4gICAgZ2V0U2F2ZWREYXRhOiB0cnVlLFxuICAgIHBhZ2VTaXplOiAxMCxcbiAgICByb3dIZWlnaHQ6IDc2LFxuICAgIGZldGNoUGFyYW1zOiB7fSxcbiAgICBjdXJyZW50UGFnZTogMSxcbiAgICBxdWVyeUtleXM6IFtdLFxuICAgIGVtcHR5VGV4dDogXCLmmoLml6DmlbDmja5cIixcbiAgICBzZWFyY2hCYXJQbGFjZWhvbGRlcjogXCLmkJzntKLooajmoLzlhoXlrrlcIixcbiAgICBwcm9jZXNzRGF0YTogZnVuY3Rpb24gcHJvY2Vzc0RhdGEoZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuICAgIGJlZm9yZUZldGNoOiBmdW5jdGlvbiBiZWZvcmVGZXRjaChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIG9uRmV0Y2hFcnJvcjogZnVuY3Rpb24gb25GZXRjaEVycm9yKCkge30sXG4gICAgYWRkUm93Q2xhc3NOYW1lOiBmdW5jdGlvbiBhZGRSb3dDbGFzc05hbWUoKSB7fSxcbiAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoKSB7fVxufTtcblxuLy8gaHR0cDovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3JldXNhYmxlLWNvbXBvbmVudHMuaHRtbFxuVGFibGUucHJvcFR5cGVzID0ge1xuICAgIGxvY2FsZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBqc3hjb2x1bW5zOiBSZWFjdC5Qcm9wVHlwZXMuYXJyYXlPZihSZWFjdC5Qcm9wVHlwZXMub2JqZWN0KSxcbiAgICB3aWR0aDogUmVhY3QuUHJvcFR5cGVzLm9uZU9mVHlwZShbUmVhY3QuUHJvcFR5cGVzLnN0cmluZywgUmVhY3QuUHJvcFR5cGVzLm51bWJlcl0pLFxuICAgIGhlaWdodDogUmVhY3QuUHJvcFR5cGVzLm9uZU9mVHlwZShbUmVhY3QuUHJvcFR5cGVzLnN0cmluZywgUmVhY3QuUHJvcFR5cGVzLm51bWJlcl0pLFxuICAgIGhlYWRlckhlaWdodDogUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICBwYWdlU2l6ZTogUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICBxdWVyeUtleXM6IFJlYWN0LlByb3BUeXBlcy5hcnJheSxcbiAgICBmZXRjaERhdGFPbk1vdW50OiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBkb3VibGVDbGlja1RvRWRpdDogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgc2hvd0NvbHVtblBpY2tlcjogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgc2hvd1BhZ2VyOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBzaG93UGFnZXJUb3RhbDogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgc2hvd0hlYWRlcjogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgc2hvd0hlYWRlckJvcmRlcjogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgc2hvd01hc2s6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIHNob3dTZWFyY2g6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIHNlYXJjaEJhclBsYWNlaG9sZGVyOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHN1YkNvbXA6IFJlYWN0LlByb3BUeXBlcy5lbGVtZW50LFxuICAgIGVtcHR5VGV4dDogUmVhY3QuUHJvcFR5cGVzLm9uZU9mVHlwZShbUmVhY3QuUHJvcFR5cGVzLnN0cmluZywgUmVhY3QuUHJvcFR5cGVzLmVsZW1lbnRdKSxcbiAgICBqc3hkYXRhOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIGZldGNoVXJsOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGZldGNoUGFyYW1zOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIHJvd1NlbGVjdG9yOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGFjdGlvbkJhcjogUmVhY3QuUHJvcFR5cGVzLm9uZU9mVHlwZShbUmVhY3QuUHJvcFR5cGVzLmFycmF5LCBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0XSksXG4gICAgcHJvY2Vzc0RhdGE6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIGJlZm9yZUZldGNoOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkZldGNoRXJyb3I6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIGFkZFJvd0NsYXNzTmFtZTogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgcGFzc2VkRGF0YTogUmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICAvLyBGb3IgaW5saW5lIGVkaXRcbiAgICBnZXRTYXZlZERhdGE6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIG9uQ2hhbmdlOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICAvLyBGb3IgdHJlZSBNb2RlXG4gICAgcmVuZGVyTW9kZWw6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgbGV2ZWxzOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyXG59O1xuXG5UYWJsZS5kaXNwbGF5TmFtZSA9IFwiVGFibGVcIjtcblRhYmxlLkNlbGxGaWVsZCA9IENlbGxGaWVsZDtcblRhYmxlLkNvbnN0YW50cyA9IENvbnN0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRhYmxlO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtdGFibGUvYnVpbGQvVGFibGUuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBDcmVhdGVkIGJ5IHh5IG9uIDE1LzQvMTMuXG4gKi9cbnZhciBDaGVja0JveCA9IHJlcXVpcmUoJy4uL0NlbGwvQ2hlY2tCb3gnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG52YXIgQ29uc3QgPSByZXF1aXJlKCd1eGNvcmUtY29uc3QnKTtcbnZhciBUcmVlID0gcmVxdWlyZSgndXhjb3JlLXRyZWUnKTtcbnZhciBUb29sdGlwID0gcmVxdWlyZSgndXhjb3JlLXRvb2x0aXAnKTtcbnZhciBjbGFzc25hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xudmFyIFRyZWVOb2RlID0gVHJlZS5UcmVlTm9kZTtcblxuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBIZWFkZXIgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhIZWFkZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gSGVhZGVyKHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIZWFkZXIpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgcGlja2VyRGlzcGxheTogJ25vbmUnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBIZWFkZXIucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIG1lLmhhbmRsZUdsb2JhbENsaWNrID0gdGhpcy5oYW5kbGVHbG9iYWxDbGljay5iaW5kKHRoaXMpO1xuICAgICAgICAkKGRvY3VtZW50KS5vbignY2xpY2sudXhjb3JlLWdyaWQtaGVhZGVyJywgbWUuaGFuZGxlR2xvYmFsQ2xpY2spO1xuICAgIH07XG5cbiAgICBIZWFkZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgICQoZG9jdW1lbnQpLm9mZignY2xpY2sudXhjb3JlLWdyaWQtaGVhZGVyJywgbWUuaGFuZGxlR2xvYmFsQ2xpY2spO1xuICAgIH07XG5cbiAgICBIZWFkZXIucHJvdG90eXBlLmhhbmRsZUdsb2JhbENsaWNrID0gZnVuY3Rpb24gaGFuZGxlR2xvYmFsQ2xpY2soZSkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5jb2x1bW5QaWNrZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZUNvbHVtblBpY2tlcihlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBIZWFkZXIucHJvdG90eXBlLmhpZGVDb2x1bW5QaWNrZXIgPSBmdW5jdGlvbiBoaWRlQ29sdW1uUGlja2VyKGUpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuXG4gICAgICAgIGlmICgkKHRhcmdldCkucGFyZW50cygnLmt1bWEtY29sdW1uLXBpY2tlci1jb250YWluZXInKS5sZW5ndGggPT0gMCAmJiAhJCh0YXJnZXQpLmhhc0NsYXNzKFwia3VtYS1jb2x1bW4tcGlja2VyLWNvbnRhaW5lclwiKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgcGlja2VyRGlzcGxheTogJ25vbmUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBIZWFkZXIucHJvdG90eXBlLmhhbmRsZUNoZWNrQm94Q2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlQ2hlY2tCb3hDaGFuZ2UoKSB7XG4gICAgICAgIHZhciB2ID0gdGhpcy5yZWZzLmNoZWNrYm94LmdldFZhbHVlKCk7XG4gICAgICAgIHRoaXMucHJvcHMuY2hlY2tBbGwuYXBwbHkobnVsbCwgW3ZdKTtcbiAgICB9O1xuXG4gICAgSGVhZGVyLnByb3RvdHlwZS5oYW5kbGVDb2x1bW5QaWNrZXIgPSBmdW5jdGlvbiBoYW5kbGVDb2x1bW5QaWNrZXIoZSkge1xuXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgcGlja2VyRGlzcGxheTogdGhpcy5zdGF0ZS5waWNrZXJEaXNwbGF5ID09ICdibG9jaycgPyAnbm9uZScgOiAnYmxvY2snXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBIZWFkZXIucHJvdG90eXBlLmhhbmRsZVBpY2tlckNoZWNrID0gZnVuY3Rpb24gaGFuZGxlUGlja2VyQ2hlY2soY2hlY2tlZEtleXMpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5oYW5kbGVDb2x1bW5QaWNrZXJDaGFuZ2UoY2hlY2tlZEtleXMpO1xuICAgIH07XG5cbiAgICBIZWFkZXIucHJvdG90eXBlLmdldENoZWNrZWRLZXlzID0gZnVuY3Rpb24gZ2V0Q2hlY2tlZEtleXMoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBjb2x1bW5zID0gbWUucHJvcHMuY29sdW1ucztcblxuICAgICAgICB2YXIgX2NvbHVtbnMgPSBbXTtcbiAgICAgICAgdmFyIGNoZWNrZWRLZXlzID0gW107XG4gICAgICAgIGNvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICgnZ3JvdXAnIGluIGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBfY29sdW1ucyA9IF9jb2x1bW5zLmNvbmNhdChpdGVtLmNvbHVtbnMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfY29sdW1ucy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgX2NvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghaXRlbS5oaWRkZW4pIHtcbiAgICAgICAgICAgICAgICBjaGVja2VkS2V5cy5wdXNoKGl0ZW0uZGF0YUtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2hlY2tlZEtleXM7XG4gICAgfTtcblxuICAgIEhlYWRlci5wcm90b3R5cGUucmVuZGVyQ29sdW1uVHJlZSA9IGZ1bmN0aW9uIHJlbmRlckNvbHVtblRyZWUoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBjb2x1bW5zID0gbWUucHJvcHMuY29sdW1ucztcblxuICAgICAgICB2YXIgbm90UmVuZGVyQ29sdW1ucyA9IFsnanN4Y2hlY2tlZCcsICdqc3h0cmVlSWNvbicsICdqc3h3aGl0ZSddO1xuXG4gICAgICAgIHZhciB0cmVlUHJvcHMgPSB7XG4gICAgICAgICAgICBtdWx0aXBsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNoZWNrYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGRlZmF1bHRDaGVja2VkS2V5czogbWUuZ2V0Q2hlY2tlZEtleXMoKSxcbiAgICAgICAgICAgIG9uQ2hlY2s6IG1lLmhhbmRsZVBpY2tlckNoZWNrLmJpbmQobWUpXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBUcmVlLFxuICAgICAgICAgICAgdHJlZVByb3BzLFxuICAgICAgICAgICAgY29sdW1ucy5tYXAoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vdFJlbmRlckNvbHVtbnMuaW5kZXhPZihpdGVtLmRhdGFLZXkpICE9PSAtMSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICgnZ3JvdXAnIGluIGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICBUcmVlTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsga2V5OiBpdGVtLmdyb3VwLCB0aXRsZTogaXRlbS5ncm91cCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5jb2x1bW5zLm1hcChmdW5jdGlvbiAoY29sdW1uLCBpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChUcmVlTm9kZSwgeyBrZXk6IGNvbHVtbi5kYXRhS2V5LCB0aXRsZTogY29sdW1uLnRpdGxlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChUcmVlTm9kZSwgeyBrZXk6IGl0ZW0uZGF0YUtleSwgdGl0bGU6IGl0ZW0udGl0bGUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtICE9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIEhlYWRlci5wcm90b3R5cGUucmVuZGVyUGlja2VyID0gZnVuY3Rpb24gcmVuZGVyUGlja2VyKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgX3N0eWxlID0ge1xuICAgICAgICAgICAgZGlzcGxheTogdGhpcy5zdGF0ZS5waWNrZXJEaXNwbGF5XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBjbGFzc25hbWVzKHtcbiAgICAgICAgICAgICAgICAgICAgXCJrdW1hLWNvbHVtbi1waWNrZXItY29udGFpbmVyXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIFwiaGFzR3JvdXBcIjogbWUuaGFzR3JvdXBcbiAgICAgICAgICAgICAgICB9KSB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnaScsIHsgY2xhc3NOYW1lOiAna3VtYS1pY29uIGt1bWEtaWNvbi10YXJnZXQtbGlzdCBrdW1hLWNvbHVtbi1waWNrZXInLCBvbkNsaWNrOiB0aGlzLmhhbmRsZUNvbHVtblBpY2tlci5iaW5kKHRoaXMpIH0pLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2t1bWEtdXh0YWJsZS1jb2x1bW5waWNrZXInLCBzdHlsZTogX3N0eWxlLCByZWY6ICdjb2x1bW5waWNrZXInIH0sXG4gICAgICAgICAgICAgICAgbWUucmVuZGVyQ29sdW1uVHJlZSgpXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIEhlYWRlci5wcm90b3R5cGUuaGFuZGxlQ29sdW1uT3JkZXIgPSBmdW5jdGlvbiBoYW5kbGVDb2x1bW5PcmRlcihjb2x1bW4pIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIF9tZSRwcm9wcyA9IG1lLnByb3BzO1xuICAgICAgICB2YXIgb3JkZXJDb2x1bW5DQiA9IF9tZSRwcm9wcy5vcmRlckNvbHVtbkNCO1xuICAgICAgICB2YXIgYWN0aXZlQ29sdW1uID0gX21lJHByb3BzLmFjdGl2ZUNvbHVtbjtcbiAgICAgICAgdmFyIG9yZGVyVHlwZSA9IF9tZSRwcm9wcy5vcmRlclR5cGU7XG5cbiAgICAgICAgdmFyIHR5cGUgPSAnZGVzYyc7XG4gICAgICAgIHZhciB0eXBlTWFwID0ge1xuICAgICAgICAgICAgZGVzYzogJ2FzYycsXG4gICAgICAgICAgICBhc2M6ICdub25lJyxcbiAgICAgICAgICAgIG5vbmU6ICdkZXNjJ1xuICAgICAgICB9O1xuICAgICAgICBpZiAoYWN0aXZlQ29sdW1uICYmIGNvbHVtbi5kYXRhS2V5ID09IGFjdGl2ZUNvbHVtbi5kYXRhS2V5ICYmIG9yZGVyVHlwZSkge1xuICAgICAgICAgICAgdHlwZSA9IHR5cGVNYXBbb3JkZXJUeXBlXTtcbiAgICAgICAgfVxuICAgICAgICBvcmRlckNvbHVtbkNCICYmIG9yZGVyQ29sdW1uQ0IodHlwZSwgY29sdW1uKTtcbiAgICB9O1xuXG4gICAgSGVhZGVyLnByb3RvdHlwZS5yZW5kZXJPcmRlckljb24gPSBmdW5jdGlvbiByZW5kZXJPcmRlckljb24oY29sdW1uKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBfbWUkcHJvcHMyID0gbWUucHJvcHM7XG4gICAgICAgIHZhciBvcmRlclR5cGUgPSBfbWUkcHJvcHMyLm9yZGVyVHlwZTtcbiAgICAgICAgdmFyIGFjdGl2ZUNvbHVtbiA9IF9tZSRwcm9wczIuYWN0aXZlQ29sdW1uO1xuXG4gICAgICAgIGlmIChjb2x1bW4ub3JkZXJlZCkge1xuICAgICAgICAgICAgdmFyIF9jbGFzc25hbWVzLCBfY2xhc3NuYW1lczI7XG5cbiAgICAgICAgICAgIHZhciBkZXNjID0gXCJpY29uZm9udGRvd25cIixcbiAgICAgICAgICAgICAgICBhc2MgPSBcImljb25mb250dXBcIjtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2t1bWEtdXh0YWJsZS1oLXNvcnQnLCBvbkNsaWNrOiBtZS5oYW5kbGVDb2x1bW5PcmRlci5iaW5kKG1lLCBjb2x1bW4pIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnaScsIHsgY2xhc3NOYW1lOiBjbGFzc25hbWVzKChfY2xhc3NuYW1lcyA9IHt9LCBfY2xhc3NuYW1lc1sna3VtYS1pY29uIGt1bWEtaWNvbi0nICsgYXNjXSA9IHRydWUsIF9jbGFzc25hbWVzWydhY3RpdmUnXSA9IGFjdGl2ZUNvbHVtbiAmJiBhY3RpdmVDb2x1bW4uZGF0YUtleSA9PT0gY29sdW1uLmRhdGFLZXkgJiYgb3JkZXJUeXBlID09ICdhc2MnLCBfY2xhc3NuYW1lcykpIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2knLCB7IGNsYXNzTmFtZTogY2xhc3NuYW1lcygoX2NsYXNzbmFtZXMyID0ge30sIF9jbGFzc25hbWVzMlsna3VtYS1pY29uIGt1bWEtaWNvbi0nICsgZGVzY10gPSB0cnVlLCBfY2xhc3NuYW1lczJbJ2FjdGl2ZSddID0gYWN0aXZlQ29sdW1uICYmIGFjdGl2ZUNvbHVtbi5kYXRhS2V5ID09PSBjb2x1bW4uZGF0YUtleSAmJiBvcmRlclR5cGUgPT0gJ2Rlc2MnLCBfY2xhc3NuYW1lczIpKSB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBIZWFkZXIucHJvdG90eXBlLnJlbmRlck1lc3NhZ2VJY29uID0gZnVuY3Rpb24gcmVuZGVyTWVzc2FnZUljb24oY29sdW1uKSB7XG4gICAgICAgIGlmICghY29sdW1uLm1lc3NhZ2UpIHJldHVybjtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBUb29sdGlwLFxuICAgICAgICAgICAgeyBvdmVybGF5OiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdrdW1hLXV4dGFibGUtY29sdW1uLW1lc3NhZ2UnIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbi5tZXNzYWdlXG4gICAgICAgICAgICAgICAgKSB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnaScsIHsgY2xhc3NOYW1lOiAna3VtYS1pY29uIGt1bWEtaWNvbi1pbmZvcm1hdGlvbicgfSlcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgSGVhZGVyLnByb3RvdHlwZS5yZW5kZXJDb2x1bW4gPSBmdW5jdGlvbiByZW5kZXJDb2x1bW4oaXRlbSwgaW5kZXgsIGhhc0dyb3VwLCBsYXN0KSB7XG5cbiAgICAgICAgaWYgKGl0ZW0uaGlkZGVuKSByZXR1cm47XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBub0JvcmRlckNvbHVtbiA9IFsnanN4Y2hlY2tlZCcsICdqc3h0cmVlSWNvbicsICdqc3h3aGl0ZSddO1xuICAgICAgICB2YXIgX3N0eWxlID0ge1xuICAgICAgICAgICAgd2lkdGg6IGl0ZW0ud2lkdGggPyBpdGVtLndpZHRoIDogMTAwLFxuICAgICAgICAgICAgdGV4dEFsaWduOiBpdGVtLmFsaWduID8gaXRlbS5hbGlnbiA6IFwibGVmdFwiXG4gICAgICAgIH07XG4gICAgICAgIHZhciBfdiA9IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoaGFzR3JvdXApIHtcbiAgICAgICAgICAgIGFzc2lnbihfc3R5bGUsIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEwMCxcbiAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiAxMDAgKyAncHgnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpdGVtLnR5cGUgPT0gJ2NoZWNrYm94JyB8fCBpdGVtLnR5cGUgPT0gJ2NoZWNrYm94U2VsZWN0b3InKSB7XG4gICAgICAgICAgICBhc3NpZ24oX3N0eWxlLCB7XG4gICAgICAgICAgICAgICAgcGFkZGluZ1JpZ2h0OiA0LFxuICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiAxMixcbiAgICAgICAgICAgICAgICB3aWR0aDogaXRlbS53aWR0aCA/IGl0ZW0ud2lkdGggOiA5MixcbiAgICAgICAgICAgICAgICBib3JkZXJSaWdodDogJ25vbmUnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGNoZWNrQm94UHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgcmVmOiAnY2hlY2tib3gnLFxuICAgICAgICAgICAgICAgIGRpc2FibGU6IG1lLnByb3BzLm1vZGUgIT09IENvbnN0Lk1PREUuVklFVyA/IGl0ZW0uZGlzYWJsZSA6IHRydWUsXG4gICAgICAgICAgICAgICAgb25jaGFuZ2U6IG1lLmhhbmRsZUNoZWNrQm94Q2hhbmdlLmJpbmQobWUpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBfdiA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2hlY2tCb3gsIGNoZWNrQm94UHJvcHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3YgPSBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgICAgICB7IHRpdGxlOiBpdGVtLnRpdGxlIH0sXG4gICAgICAgICAgICAgICAgaXRlbS50aXRsZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub0JvcmRlckNvbHVtbi5pbmRleE9mKGl0ZW0uZGF0YUtleSkgIT09IC0xIHx8IGxhc3QpIHtcbiAgICAgICAgICAgIGFzc2lnbihfc3R5bGUsIHtcbiAgICAgICAgICAgICAgICBib3JkZXJSaWdodDogJ25vbmUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7IGtleTogaW5kZXgsIGNsYXNzTmFtZTogY2xhc3NuYW1lcyh7XG4gICAgICAgICAgICAgICAgICAgIFwia3VtYS11eHRhYmxlLWNlbGxcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgXCJzaG93LWJvcmRlclwiOiBtZS5wcm9wcy5zaG93SGVhZGVyQm9yZGVyXG4gICAgICAgICAgICAgICAgfSksIHN0eWxlOiBfc3R5bGUgfSxcbiAgICAgICAgICAgIF92LFxuICAgICAgICAgICAgbWUucmVuZGVyTWVzc2FnZUljb24oaXRlbSksXG4gICAgICAgICAgICBtZS5yZW5kZXJPcmRlckljb24oaXRlbSlcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgSGVhZGVyLnByb3RvdHlwZS5yZW5kZXJDb2x1bW5zID0gZnVuY3Rpb24gcmVuZGVyQ29sdW1ucyhfY29sdW1ucykge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgICAgIHZhciBjb2x1bW5zID0gX2NvbHVtbnMubWFwKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIGxhc3QgPSBpbmRleCA9PSBfY29sdW1ucy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKCdncm91cCcgaW4gaXRlbSkge1xuICAgICAgICAgICAgICAgIC8vIEZpcnN0IGRldGVybWluZSB3aGV0aGVyIHRoZSBncm91cCBzaG91bGQgYmUgcmVuZGVyZWQsIGlmIGFsbCBjb2x1bW5zXG4gICAgICAgICAgICAgICAgLy8gaXMgaGlkZGVuLCB0aGUgY29sdW1uIGdyb3VwIHNob3VsZCBub3QgYmUgcmVuZGVyZWQuXG4gICAgICAgICAgICAgICAgdmFyIHNob3VsZFJlbmRlckdyb3VwID0gaXRlbS5jb2x1bW5zLnNvbWUoZnVuY3Rpb24gKGNvbHVtbiwgaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWNvbHVtbi5oaWRkZW47XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFJlbmRlckdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2t1bWEtdXh0YWJsZS1oZWFkZXItY29sdW1uLWdyb3VwJywga2V5OiBpbmRleCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2t1bWEtdXh0YWJsZS1oZWFkZXItZ3JvdXAtbmFtZScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmdyb3VwXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5jb2x1bW5zLm1hcChmdW5jdGlvbiAoY29sdW1uLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lLnJlbmRlckNvbHVtbihjb2x1bW4sIGksIGZhbHNlLCBsYXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWUucmVuZGVyQ29sdW1uKGl0ZW0sIGluZGV4LCBtZS5oYXNHcm91cCwgbGFzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29sdW1ucztcbiAgICB9O1xuXG4gICAgSGVhZGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG5cbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIG1lID0gdGhpcyxcbiAgICAgICAgICAgIF9waWNrZXIgPSB1bmRlZmluZWQsXG4gICAgICAgICAgICBfd2lkdGggPSAwLFxuICAgICAgICAgICAgaGVhZGVyV3JhcENsYXNzTmFtZSA9IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIF9oZWFkZXJTdHlsZSA9IHt9LFxuICAgICAgICAgICAgX2NvbHVtbnMgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKHByb3BzLmNvbHVtblBpY2tlciAmJiAocHJvcHMuZml4ZWRDb2x1bW4gPT0gJ25vJyB8fCBwcm9wcy5maXhlZENvbHVtbiA9PSAnc2Nyb2xsJykpIHtcbiAgICAgICAgICAgIF9waWNrZXIgPSB0aGlzLnJlbmRlclBpY2tlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3BzLmZpeGVkQ29sdW1uID09ICdmaXhlZCcpIHtcbiAgICAgICAgICAgIF9jb2x1bW5zID0gcHJvcHMuY29sdW1ucy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5maXhlZCAmJiAhaXRlbS5oaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLndpZHRoID0gMTAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF93aWR0aCA9IGl0ZW0ud2lkdGggKiAxICsgX3dpZHRoO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFzc2lnbihfaGVhZGVyU3R5bGUsIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogX3dpZHRoLFxuICAgICAgICAgICAgICAgIG1pbldpZHRoOiBfd2lkdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaGVhZGVyV3JhcENsYXNzTmFtZSA9IFwia3VtYS11eHRhYmxlLWhlYWRlci1maXhlZFwiO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BzLmZpeGVkQ29sdW1uID09ICdzY3JvbGwnKSB7XG4gICAgICAgICAgICBfY29sdW1ucyA9IHByb3BzLmNvbHVtbnMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtLmZpeGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWl0ZW0uaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXRlbS53aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS53aWR0aCA9IDEwMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfd2lkdGggPSBpdGVtLndpZHRoICogMSArIF93aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFzc2lnbihfaGVhZGVyU3R5bGUsIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogcHJvcHMud2lkdGggLSBfd2lkdGggLSAzLFxuICAgICAgICAgICAgICAgIG1pbldpZHRoOiBwcm9wcy53aWR0aCAtIF93aWR0aCAtIDNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaGVhZGVyV3JhcENsYXNzTmFtZSA9IFwia3VtYS11eHRhYmxlLWhlYWRlci1zY3JvbGxcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9jb2x1bW5zID0gcHJvcHMuY29sdW1ucztcbiAgICAgICAgICAgIGhlYWRlcldyYXBDbGFzc05hbWUgPSBcImt1bWEtdXh0YWJsZS1oZWFkZXItbm9cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmhhc0dyb3VwID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2NvbHVtbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICgnZ3JvdXAnIGluIF9jb2x1bW5zW2ldKSB7XG4gICAgICAgICAgICAgICAgbWUuaGFzR3JvdXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXNzaWduKF9oZWFkZXJTdHlsZSwge1xuICAgICAgICAgICAgaGVpZ2h0OiBwcm9wcy5oZWFkZXJIZWlnaHQgPyBwcm9wcy5oZWFkZXJIZWlnaHQgOiBtZS5oYXNHcm91cCA/IDgwIDogNTAsXG4gICAgICAgICAgICBsaW5lSGVpZ2h0OiAocHJvcHMuaGVhZGVySGVpZ2h0ID8gcHJvcHMuaGVhZGVySGVpZ2h0IDogNTApICsgXCJweFwiXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogaGVhZGVyV3JhcENsYXNzTmFtZSwgc3R5bGU6IF9oZWFkZXJTdHlsZSB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogcHJvcHMuanN4cHJlZml4Q2xzIH0sXG4gICAgICAgICAgICAgICAgbWUucmVuZGVyQ29sdW1ucyhfY29sdW1ucyksXG4gICAgICAgICAgICAgICAgX3BpY2tlclxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gSGVhZGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG47XG5cbkhlYWRlci5wcm9wVHlwZXMgPSB7fTtcblxuSGVhZGVyLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBqc3hwcmVmaXhDbHM6IFwia3VtYS11eHRhYmxlLWhlYWRlclwiXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhlYWRlcjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLXRhYmxlL2J1aWxkL0hlYWRlci9pbmRleC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIEEgY2hlY2tib3ggZmllbGRcbiAqL1xuXG52YXIgQ29uc3QgPSByZXF1aXJlKCd1eGNvcmUtY29uc3QnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIENoZWNrQm94ID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoQ2hlY2tCb3gsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gQ2hlY2tCb3gocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENoZWNrQm94KTtcblxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSk7XG4gICAgfVxuXG4gICAgQ2hlY2tCb3gucHJvdG90eXBlLmhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZShlKSB7XG4gICAgICAgIHZhciB2ID0gdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgICB2ID0gdiA/ICdjaGVja2VkJyA6ICcnO1xuICAgICAgICB0aGlzLnByb3BzLm9uY2hhbmdlLmFwcGx5KG51bGwsIFtlXSk7XG4gICAgfTtcblxuICAgIENoZWNrQm94LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZzLmNoZWNrYm94LmNoZWNrZWQ7XG4gICAgfTtcblxuICAgIENoZWNrQm94LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG5cbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcblxuICAgICAgICBpZiAocHJvcHMubW9kZSAhPT0gQ29uc3QuTU9ERS5WSUVXKSB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyUHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImt1bWEtY2hlY2tib3hcIixcbiAgICAgICAgICAgICAgICBjaGVja2VkOiB0aGlzLnByb3BzLmpzeGNoZWNrZWQsXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IHRoaXMuaGFuZGxlQ2hhbmdlLmJpbmQodGhpcylcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoISFwcm9wcy5kaXNhYmxlKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyUHJvcHMuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ2xhYmVsJyxcbiAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2t1bWEtdXh0YWJsZS1yb3ctc2VsZWN0b3InIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnaW5wdXQnLCBfZXh0ZW5kcyh7IHR5cGU6ICdjaGVja2JveCcsIHJlZjogJ2NoZWNrYm94JyB9LCByZW5kZXJQcm9wcykpLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3MnLCBudWxsKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgdmFyIHJlbmRlclByb3BzID0ge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJrdW1hLWNoZWNrYm94XCIsXG4gICAgICAgICAgICAgICAgY2hlY2tlZDogdGhpcy5wcm9wcy5qc3hjaGVja2VkLFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ2xhYmVsJyxcbiAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2t1bWEtdXh0YWJsZS1yb3ctc2VsZWN0b3InIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnaW5wdXQnLCBfZXh0ZW5kcyh7IHR5cGU6ICdjaGVja2JveCcsIHJlZjogJ2NoZWNrYm94JyB9LCByZW5kZXJQcm9wcykpLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3MnLCBudWxsKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gQ2hlY2tCb3g7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbjtcblxuQ2hlY2tCb3gucHJvcFR5cGVzID0ge307XG5cbkNoZWNrQm94LmRlZmF1bHRQcm9wcyA9IHt9O1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IENoZWNrQm94O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS10YWJsZS9idWlsZC9DZWxsL0NoZWNrQm94LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRyZWUgQ29tcG9uZW50IGZvciB1eGNvcmVcbiAqIEBhdXRob3IgXG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgVXhjb3JlIFRlYW0sIEFsaW53LlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vVHJlZScpO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtdHJlZS9idWlsZC9pbmRleC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9vYmplY3RBc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBfb2JqZWN0QXNzaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29iamVjdEFzc2lnbik7XG5cbnZhciBfcmNUcmVlID0gcmVxdWlyZSgncmMtdHJlZScpO1xuXG52YXIgX3JjVHJlZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yY1RyZWUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgVHJlZSA9IGZ1bmN0aW9uIChfUmNUcmVlKSB7XG4gICAgX2luaGVyaXRzKFRyZWUsIF9SY1RyZWUpO1xuXG4gICAgZnVuY3Rpb24gVHJlZShwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJlZSk7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SY1RyZWUuY2FsbCh0aGlzLCBwcm9wcykpO1xuICAgIH1cblxuICAgIHJldHVybiBUcmVlO1xufShfcmNUcmVlMltcImRlZmF1bHRcIl0pO1xuXG5UcmVlLmRpc3BsYXlOYW1lID0gJ1RyZWUnO1xuVHJlZS5wcm9wVHlwZXMgPSBfcmNUcmVlMltcImRlZmF1bHRcIl0ucHJvcFR5cGVzO1xuVHJlZS5kZWZhdWx0UHJvcHMgPSAoMCwgX29iamVjdEFzc2lnbjJbXCJkZWZhdWx0XCJdKShfcmNUcmVlMltcImRlZmF1bHRcIl0uZGVmYXVsdFByb3BzLCB7XG4gICAgcHJlZml4Q2xzOiAna3VtYS10cmVlJyxcbiAgICBzaG93SWNvbjogZmFsc2Vcbn0pO1xuXG5UcmVlLlRyZWVOb2RlID0gX3JjVHJlZTJbXCJkZWZhdWx0XCJdLlRyZWVOb2RlO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFRyZWU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLXRyZWUvYnVpbGQvVHJlZS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9UcmVlID0gcmVxdWlyZSgnLi9UcmVlJyk7XG5cbnZhciBfVHJlZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9UcmVlKTtcblxudmFyIF9UcmVlTm9kZSA9IHJlcXVpcmUoJy4vVHJlZU5vZGUnKTtcblxudmFyIF9UcmVlTm9kZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9UcmVlTm9kZSk7XG5cbl9UcmVlMlsnZGVmYXVsdCddLlRyZWVOb2RlID0gX1RyZWVOb2RlMlsnZGVmYXVsdCddO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBfVHJlZTJbJ2RlZmF1bHQnXTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtdHJlZS9+L3JjLXRyZWUvbGliL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gyLCBfeDMsIF94NCkgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeDIsIHByb3BlcnR5ID0gX3gzLCByZWNlaXZlciA9IF94NDsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeDIgPSBwYXJlbnQ7IF94MyA9IHByb3BlcnR5OyBfeDQgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfb2JqZWN0QXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgX29iamVjdEFzc2lnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vYmplY3RBc3NpZ24pO1xuXG52YXIgX2NsYXNzbmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG5cbnZhciBfY2xhc3NuYW1lczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc25hbWVzKTtcblxudmFyIF91dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG52YXIgVHJlZSA9IChmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoVHJlZSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gVHJlZShwcm9wcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJlZSk7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihUcmVlLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmNhbGwodGhpcywgcHJvcHMpO1xuICAgIFsnb25LZXlEb3duJywgJ29uQ2hlY2snXS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgICBfdGhpc1ttXSA9IF90aGlzW21dLmJpbmQoX3RoaXMpO1xuICAgIH0pO1xuICAgIHRoaXMuY29udGV4dG1lbnVLZXlzID0gW107XG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgZXhwYW5kZWRLZXlzOiB0aGlzLmdldERlZmF1bHRFeHBhbmRlZEtleXMocHJvcHMpLFxuICAgICAgY2hlY2tlZEtleXM6IHRoaXMuZ2V0RGVmYXVsdENoZWNrZWRLZXlzKHByb3BzKSxcbiAgICAgIHNlbGVjdGVkS2V5czogdGhpcy5nZXREZWZhdWx0U2VsZWN0ZWRLZXlzKHByb3BzKSxcbiAgICAgIGRyYWdOb2Rlc0tleXM6ICcnLFxuICAgICAgZHJhZ092ZXJOb2RlS2V5OiAnJyxcbiAgICAgIGRyb3BOb2RlS2V5OiAnJ1xuICAgIH07XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVHJlZSwgW3tcbiAgICBrZXk6ICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgIHZhciBleHBhbmRlZEtleXMgPSB0aGlzLmdldERlZmF1bHRFeHBhbmRlZEtleXMobmV4dFByb3BzLCB0cnVlKTtcbiAgICAgIHZhciBjaGVja2VkS2V5cyA9IHRoaXMuZ2V0RGVmYXVsdENoZWNrZWRLZXlzKG5leHRQcm9wcywgdHJ1ZSk7XG4gICAgICB2YXIgc2VsZWN0ZWRLZXlzID0gdGhpcy5nZXREZWZhdWx0U2VsZWN0ZWRLZXlzKG5leHRQcm9wcywgdHJ1ZSk7XG4gICAgICB2YXIgc3QgPSB7fTtcbiAgICAgIGlmIChleHBhbmRlZEtleXMpIHtcbiAgICAgICAgc3QuZXhwYW5kZWRLZXlzID0gZXhwYW5kZWRLZXlzO1xuICAgICAgfVxuICAgICAgaWYgKGNoZWNrZWRLZXlzKSB7XG4gICAgICAgIHN0LmNoZWNrZWRLZXlzID0gY2hlY2tlZEtleXM7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0ZWRLZXlzKSB7XG4gICAgICAgIHN0LnNlbGVjdGVkS2V5cyA9IHNlbGVjdGVkS2V5cztcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0U3RhdGUoc3QpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uRHJhZ1N0YXJ0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25EcmFnU3RhcnQoZSwgdHJlZU5vZGUpIHtcbiAgICAgIHRoaXMuZHJhZ05vZGUgPSB0cmVlTm9kZTtcbiAgICAgIHRoaXMuZHJhZ05vZGVzS2V5cyA9IHRoaXMuZ2V0RHJhZ05vZGVzKHRyZWVOb2RlKTtcbiAgICAgIHZhciBzdCA9IHtcbiAgICAgICAgZHJhZ05vZGVzS2V5czogdGhpcy5kcmFnTm9kZXNLZXlzXG4gICAgICB9O1xuICAgICAgdmFyIGV4cGFuZGVkS2V5cyA9IHRoaXMuZ2V0RXhwYW5kZWRLZXlzKHRyZWVOb2RlLCBmYWxzZSk7XG4gICAgICBpZiAoZXhwYW5kZWRLZXlzKSB7XG4gICAgICAgIC8vIENvbnRyb2xsZWQgZXhwYW5kLCBzYXZlIGFuZCB0aGVuIHJlc2V0XG4gICAgICAgIHRoaXMuZ2V0UmF3RXhwYW5kZWRLZXlzKCk7XG4gICAgICAgIHN0LmV4cGFuZGVkS2V5cyA9IGV4cGFuZGVkS2V5cztcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0U3RhdGUoc3QpO1xuICAgICAgdGhpcy5wcm9wcy5vbkRyYWdTdGFydCh7XG4gICAgICAgIGV2ZW50OiBlLFxuICAgICAgICBub2RlOiB0cmVlTm9kZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25EcmFnRW50ZXJHYXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkRyYWdFbnRlckdhcChlLCB0cmVlTm9kZSkge1xuICAgICAgLy8gY29uc29sZS5sb2coZS5wYWdlWSwgZ2V0T2Zmc2V0KHRyZWVOb2RlLnJlZnMuc2VsZWN0SGFuZGxlKSwgdHJlZU5vZGUucHJvcHMuZXZlbnRLZXkpO1xuICAgICAgdmFyIG9mZnNldFRvcCA9ICgwLCBfdXRpbC5nZXRPZmZzZXQpKHRyZWVOb2RlLnJlZnMuc2VsZWN0SGFuZGxlKS50b3A7XG4gICAgICB2YXIgb2Zmc2V0SGVpZ2h0ID0gdHJlZU5vZGUucmVmcy5zZWxlY3RIYW5kbGUub2Zmc2V0SGVpZ2h0O1xuICAgICAgdmFyIHBhZ2VZID0gZS5wYWdlWTtcbiAgICAgIHZhciBnYXBIZWlnaHQgPSAyO1xuICAgICAgaWYgKHBhZ2VZID4gb2Zmc2V0VG9wICsgb2Zmc2V0SGVpZ2h0IC0gZ2FwSGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuZHJvcFBvc2l0aW9uID0gMTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICBpZiAocGFnZVkgPCBvZmZzZXRUb3AgKyBnYXBIZWlnaHQpIHtcbiAgICAgICAgdGhpcy5kcm9wUG9zaXRpb24gPSAtMTtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdGhpcy5kcm9wUG9zaXRpb24gPSAwO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25EcmFnRW50ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkRyYWdFbnRlcihlLCB0cmVlTm9kZSkge1xuICAgICAgdmFyIGVudGVyR2FwID0gdGhpcy5vbkRyYWdFbnRlckdhcChlLCB0cmVlTm9kZSk7XG4gICAgICBpZiAodGhpcy5kcmFnTm9kZS5wcm9wcy5ldmVudEtleSA9PT0gdHJlZU5vZGUucHJvcHMuZXZlbnRLZXkgJiYgZW50ZXJHYXAgPT09IDApIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgZHJhZ092ZXJOb2RlS2V5OiAnJ1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHN0ID0ge1xuICAgICAgICBkcmFnT3Zlck5vZGVLZXk6IHRyZWVOb2RlLnByb3BzLmV2ZW50S2V5XG4gICAgICB9O1xuICAgICAgdmFyIGV4cGFuZGVkS2V5cyA9IHRoaXMuZ2V0RXhwYW5kZWRLZXlzKHRyZWVOb2RlLCB0cnVlKTtcbiAgICAgIGlmIChleHBhbmRlZEtleXMpIHtcbiAgICAgICAgdGhpcy5nZXRSYXdFeHBhbmRlZEtleXMoKTtcbiAgICAgICAgc3QuZXhwYW5kZWRLZXlzID0gZXhwYW5kZWRLZXlzO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTdGF0ZShzdCk7XG4gICAgICB0aGlzLnByb3BzLm9uRHJhZ0VudGVyKHtcbiAgICAgICAgZXZlbnQ6IGUsXG4gICAgICAgIG5vZGU6IHRyZWVOb2RlLFxuICAgICAgICBleHBhbmRlZEtleXM6IGV4cGFuZGVkS2V5cyAmJiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGV4cGFuZGVkS2V5cykpIHx8IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5zdGF0ZS5leHBhbmRlZEtleXMpKVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25EcmFnT3ZlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRHJhZ092ZXIoZSwgdHJlZU5vZGUpIHtcbiAgICAgIHRoaXMucHJvcHMub25EcmFnT3Zlcih7IGV2ZW50OiBlLCBub2RlOiB0cmVlTm9kZSB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkRyYWdMZWF2ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRHJhZ0xlYXZlKGUsIHRyZWVOb2RlKSB7XG4gICAgICB0aGlzLnByb3BzLm9uRHJhZ0xlYXZlKHsgZXZlbnQ6IGUsIG5vZGU6IHRyZWVOb2RlIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uRHJvcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRHJvcChlLCB0cmVlTm9kZSkge1xuICAgICAgdmFyIGtleSA9IHRyZWVOb2RlLnByb3BzLmV2ZW50S2V5O1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGRyYWdPdmVyTm9kZUtleTogJycsXG4gICAgICAgIGRyb3BOb2RlS2V5OiBrZXlcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMuZHJhZ05vZGVzS2V5cy5pbmRleE9mKGtleSkgPiAtMSkge1xuICAgICAgICBpZiAoY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdjYW4gbm90IGRyb3AgdG8gZHJhZ05vZGUoaW5jbHVkZSBpdFxcJ3MgY2hpbGRyZW4gbm9kZSknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBwb3NBcnIgPSB0cmVlTm9kZS5wcm9wcy5wb3Muc3BsaXQoJy0nKTtcbiAgICAgIHZhciByZXMgPSB7XG4gICAgICAgIGV2ZW50OiBlLFxuICAgICAgICBub2RlOiB0cmVlTm9kZSxcbiAgICAgICAgZHJhZ05vZGU6IHRoaXMuZHJhZ05vZGUsXG4gICAgICAgIGRyYWdOb2Rlc0tleXM6IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5kcmFnTm9kZXNLZXlzKSksXG4gICAgICAgIGRyb3BQb3NpdGlvbjogdGhpcy5kcm9wUG9zaXRpb24gKyBOdW1iZXIocG9zQXJyW3Bvc0Fyci5sZW5ndGggLSAxXSlcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5kcm9wUG9zaXRpb24gIT09IDApIHtcbiAgICAgICAgcmVzLmRyb3BUb0dhcCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoJ2V4cGFuZGVkS2V5cycgaW4gdGhpcy5wcm9wcykge1xuICAgICAgICByZXMucmF3RXhwYW5kZWRLZXlzID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSh0aGlzLl9yYXdFeHBhbmRlZEtleXMpKSB8fCBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuc3RhdGUuZXhwYW5kZWRLZXlzKSk7XG4gICAgICB9XG4gICAgICB0aGlzLnByb3BzLm9uRHJvcChyZXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uRXhwYW5kJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25FeHBhbmQodHJlZU5vZGUpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgZXhwYW5kID0gIXRyZWVOb2RlLnByb3BzLmV4cGFuZGVkO1xuICAgICAgdmFyIGNvbnRyb2xsZWQgPSAoJ2V4cGFuZGVkS2V5cycgaW4gdGhpcy5wcm9wcyk7XG4gICAgICB2YXIgZXhwYW5kZWRLZXlzID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSh0aGlzLnN0YXRlLmV4cGFuZGVkS2V5cykpO1xuICAgICAgdmFyIGluZGV4ID0gZXhwYW5kZWRLZXlzLmluZGV4T2YodHJlZU5vZGUucHJvcHMuZXZlbnRLZXkpO1xuICAgICAgaWYgKCFjb250cm9sbGVkKSB7XG4gICAgICAgIGlmIChleHBhbmQpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBleHBhbmRlZEtleXMucHVzaCh0cmVlTm9kZS5wcm9wcy5ldmVudEtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4cGFuZGVkS2V5cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBleHBhbmRlZEtleXM6IGV4cGFuZGVkS2V5cyB9KTtcbiAgICAgICAgLy8gcmVtZW1iZXIgdGhlIHJldHVybiBvYmplY3QsIHN1Y2ggYXMgZXhwYW5kZWRLZXlzLCBtdXN0IGNsb25lISFcbiAgICAgICAgLy8gc28geW91IGNhbiBhdm9pZCBvdXRlciBjb2RlIGNoYW5nZSBpdC5cbiAgICAgICAgdGhpcy5wcm9wcy5vbkV4cGFuZCh0cmVlTm9kZSwgZXhwYW5kLCBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGV4cGFuZGVkS2V5cykpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJvcHMub25FeHBhbmQodHJlZU5vZGUsICFleHBhbmQsIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoZXhwYW5kZWRLZXlzKSkpO1xuICAgICAgfVxuXG4gICAgICAvLyBhZnRlciBkYXRhIGxvYWRlZCwgbmVlZCBzZXQgbmV3IGV4cGFuZGVkS2V5c1xuICAgICAgaWYgKGV4cGFuZCAmJiB0aGlzLnByb3BzLmxvYWREYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmxvYWREYXRhKHRyZWVOb2RlKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWNvbnRyb2xsZWQpIHtcbiAgICAgICAgICAgIF90aGlzMi5zZXRTdGF0ZSh7IGV4cGFuZGVkS2V5czogZXhwYW5kZWRLZXlzIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25DaGVjaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ2hlY2sodHJlZU5vZGUpIHtcbiAgICAgIHZhciBjaGVja2VkID0gIXRyZWVOb2RlLnByb3BzLmNoZWNrZWQ7XG4gICAgICBpZiAodHJlZU5vZGUucHJvcHMuY2hlY2tQYXJ0KSB7XG4gICAgICAgIGNoZWNrZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIGtleSA9IHRyZWVOb2RlLmtleSB8fCB0cmVlTm9kZS5wcm9wcy5ldmVudEtleTtcbiAgICAgIHZhciBjaGVja2VkS2V5cyA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5zdGF0ZS5jaGVja2VkS2V5cykpO1xuICAgICAgaWYgKGNoZWNrZWQgJiYgY2hlY2tlZEtleXMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgICBjaGVja2VkS2V5cy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgICB2YXIgY2hlY2tLZXlzID0gKDAsIF91dGlsLmdldFRyZWVOb2Rlc1N0YXRlcykodGhpcy5wcm9wcy5jaGlsZHJlbiwgY2hlY2tlZEtleXMsIGNoZWNrZWQsIGtleSk7XG4gICAgICB2YXIgbmV3U3QgPSB7XG4gICAgICAgIGV2ZW50OiAnY2hlY2snLFxuICAgICAgICBub2RlOiB0cmVlTm9kZSxcbiAgICAgICAgY2hlY2tlZDogY2hlY2tlZCxcbiAgICAgICAgY2hlY2tlZE5vZGVzOiBjaGVja0tleXMuY2hlY2tlZE5vZGVzLFxuICAgICAgICBjaGVja2VkTm9kZXNQb3NpdGlvbnM6IGNoZWNrS2V5cy5jaGVja2VkTm9kZXNQb3NpdGlvbnNcbiAgICAgIH07XG4gICAgICBjaGVja2VkS2V5cyA9IGNoZWNrS2V5cy5jaGVja2VkS2V5cztcbiAgICAgIGlmICghKCdjaGVja2VkS2V5cycgaW4gdGhpcy5wcm9wcykpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgY2hlY2tlZEtleXM6IGNoZWNrZWRLZXlzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5wcm9wcy5vbkNoZWNrKGNoZWNrZWRLZXlzLCBuZXdTdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25TZWxlY3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblNlbGVjdCh0cmVlTm9kZSkge1xuICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciBzZWxlY3RlZEtleXMgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzKSk7XG4gICAgICB2YXIgZXZlbnRLZXkgPSB0cmVlTm9kZS5wcm9wcy5ldmVudEtleTtcbiAgICAgIHZhciBpbmRleCA9IHNlbGVjdGVkS2V5cy5pbmRleE9mKGV2ZW50S2V5KTtcbiAgICAgIHZhciBzZWxlY3RlZCA9IHVuZGVmaW5lZDtcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgc2VsZWN0ZWRLZXlzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIGlmICghcHJvcHMubXVsdGlwbGUpIHtcbiAgICAgICAgICBzZWxlY3RlZEtleXMubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBzZWxlY3RlZEtleXMucHVzaChldmVudEtleSk7XG4gICAgICB9XG4gICAgICB2YXIgc2VsZWN0ZWROb2RlcyA9IFtdO1xuICAgICAgaWYgKHNlbGVjdGVkS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgKDAsIF91dGlsLmxvb3BBbGxDaGlsZHJlbikodGhpcy5wcm9wcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICBpZiAoc2VsZWN0ZWRLZXlzLmluZGV4T2YoaXRlbS5rZXkpICE9PSAtMSkge1xuICAgICAgICAgICAgc2VsZWN0ZWROb2Rlcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB2YXIgbmV3U3QgPSB7XG4gICAgICAgIGV2ZW50OiAnc2VsZWN0JyxcbiAgICAgICAgbm9kZTogdHJlZU5vZGUsXG4gICAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZCxcbiAgICAgICAgc2VsZWN0ZWROb2Rlczogc2VsZWN0ZWROb2Rlc1xuICAgICAgfTtcbiAgICAgIGlmICghKCdzZWxlY3RlZEtleXMnIGluIHRoaXMucHJvcHMpKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIHNlbGVjdGVkS2V5czogc2VsZWN0ZWRLZXlzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcHJvcHMub25TZWxlY3Qoc2VsZWN0ZWRLZXlzLCBuZXdTdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25Nb3VzZUVudGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Nb3VzZUVudGVyKGUsIHRyZWVOb2RlKSB7XG4gICAgICB0aGlzLnByb3BzLm9uTW91c2VFbnRlcih7IGV2ZW50OiBlLCBub2RlOiB0cmVlTm9kZSB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbk1vdXNlTGVhdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1vdXNlTGVhdmUoZSwgdHJlZU5vZGUpIHtcbiAgICAgIHRoaXMucHJvcHMub25Nb3VzZUxlYXZlKHsgZXZlbnQ6IGUsIG5vZGU6IHRyZWVOb2RlIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uQ29udGV4dE1lbnUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNvbnRleHRNZW51KGUsIHRyZWVOb2RlKSB7XG4gICAgICB2YXIgc2VsZWN0ZWRLZXlzID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSh0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cykpO1xuICAgICAgdmFyIGV2ZW50S2V5ID0gdHJlZU5vZGUucHJvcHMuZXZlbnRLZXk7XG4gICAgICBpZiAodGhpcy5jb250ZXh0bWVudUtleXMuaW5kZXhPZihldmVudEtleSkgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuY29udGV4dG1lbnVLZXlzLnB1c2goZXZlbnRLZXkpO1xuICAgICAgfVxuICAgICAgdGhpcy5jb250ZXh0bWVudUtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBpbmRleCA9IHNlbGVjdGVkS2V5cy5pbmRleE9mKGtleSk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICBzZWxlY3RlZEtleXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoc2VsZWN0ZWRLZXlzLmluZGV4T2YoZXZlbnRLZXkpID09PSAtMSkge1xuICAgICAgICBzZWxlY3RlZEtleXMucHVzaChldmVudEtleSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgc2VsZWN0ZWRLZXlzOiBzZWxlY3RlZEtleXNcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wcm9wcy5vblJpZ2h0Q2xpY2soeyBldmVudDogZSwgbm9kZTogdHJlZU5vZGUgfSk7XG4gICAgfVxuXG4gICAgLy8gYWxsIGtleWJvYXJkIGV2ZW50cyBjYWxsYmFja3MgcnVuIGZyb20gaGVyZSBhdCBmaXJzdFxuICB9LCB7XG4gICAga2V5OiAnb25LZXlEb3duJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25LZXlEb3duKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRGaWx0ZXJFeHBhbmRlZEtleXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGaWx0ZXJFeHBhbmRlZEtleXMocHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0RXhwYW5kZWRLZXlzID0gcHJvcHMuZGVmYXVsdEV4cGFuZGVkS2V5cztcbiAgICAgIHZhciBleHBhbmRlZFBvc2l0aW9uQXJyID0gW107XG4gICAgICBpZiAocHJvcHMuYXV0b0V4cGFuZFBhcmVudCkge1xuICAgICAgICAoMCwgX3V0aWwubG9vcEFsbENoaWxkcmVuKShwcm9wcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGl0ZW0sIGluZGV4LCBwb3MsIG5ld0tleSkge1xuICAgICAgICAgIGlmIChkZWZhdWx0RXhwYW5kZWRLZXlzLmluZGV4T2YobmV3S2V5KSA+IC0xKSB7XG4gICAgICAgICAgICBleHBhbmRlZFBvc2l0aW9uQXJyLnB1c2gocG9zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdmFyIGZpbHRlckV4cGFuZGVkS2V5cyA9IFtdO1xuICAgICAgKDAsIF91dGlsLmxvb3BBbGxDaGlsZHJlbikocHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChpdGVtLCBpbmRleCwgcG9zLCBuZXdLZXkpIHtcbiAgICAgICAgaWYgKHByb3BzLmRlZmF1bHRFeHBhbmRBbGwpIHtcbiAgICAgICAgICBmaWx0ZXJFeHBhbmRlZEtleXMucHVzaChuZXdLZXkpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BzLmF1dG9FeHBhbmRQYXJlbnQpIHtcbiAgICAgICAgICBleHBhbmRlZFBvc2l0aW9uQXJyLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgIGlmICgocC5zcGxpdCgnLScpLmxlbmd0aCA+IHBvcy5zcGxpdCgnLScpLmxlbmd0aCAmJiAoMCwgX3V0aWwuaXNJbmNsdWRlKShwb3Muc3BsaXQoJy0nKSwgcC5zcGxpdCgnLScpKSB8fCBwb3MgPT09IHApICYmIGZpbHRlckV4cGFuZGVkS2V5cy5pbmRleE9mKG5ld0tleSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgIGZpbHRlckV4cGFuZGVkS2V5cy5wdXNoKG5ld0tleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZpbHRlckV4cGFuZGVkS2V5cy5sZW5ndGggPyBmaWx0ZXJFeHBhbmRlZEtleXMgOiBkZWZhdWx0RXhwYW5kZWRLZXlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldERlZmF1bHRFeHBhbmRlZEtleXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZWZhdWx0RXhwYW5kZWRLZXlzKHByb3BzLCB3aWxsUmVjZWl2ZVByb3BzKSB7XG4gICAgICB2YXIgZXhwYW5kZWRLZXlzID0gd2lsbFJlY2VpdmVQcm9wcyA/IHVuZGVmaW5lZCA6IHRoaXMuZ2V0RmlsdGVyRXhwYW5kZWRLZXlzKHByb3BzKTtcbiAgICAgIGlmICgnZXhwYW5kZWRLZXlzJyBpbiBwcm9wcykge1xuICAgICAgICBleHBhbmRlZEtleXMgPSBwcm9wcy5leHBhbmRlZEtleXMgfHwgW107XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhwYW5kZWRLZXlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldERlZmF1bHRDaGVja2VkS2V5cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlZmF1bHRDaGVja2VkS2V5cyhwcm9wcywgd2lsbFJlY2VpdmVQcm9wcykge1xuICAgICAgdmFyIGNoZWNrZWRLZXlzID0gd2lsbFJlY2VpdmVQcm9wcyA/IHVuZGVmaW5lZCA6IHByb3BzLmRlZmF1bHRDaGVja2VkS2V5cztcbiAgICAgIGlmICgnY2hlY2tlZEtleXMnIGluIHByb3BzKSB7XG4gICAgICAgIGNoZWNrZWRLZXlzID0gcHJvcHMuY2hlY2tlZEtleXMgfHwgW107XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hlY2tlZEtleXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0RGVmYXVsdFNlbGVjdGVkS2V5cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlZmF1bHRTZWxlY3RlZEtleXMocHJvcHMsIHdpbGxSZWNlaXZlUHJvcHMpIHtcbiAgICAgIHZhciBnZXRLZXlzID0gZnVuY3Rpb24gZ2V0S2V5cyhrZXlzKSB7XG4gICAgICAgIGlmIChwcm9wcy5tdWx0aXBsZSkge1xuICAgICAgICAgIHJldHVybiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGtleXMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gW2tleXNbMF1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgICAgfTtcbiAgICAgIHZhciBzZWxlY3RlZEtleXMgPSB3aWxsUmVjZWl2ZVByb3BzID8gdW5kZWZpbmVkIDogZ2V0S2V5cyhwcm9wcy5kZWZhdWx0U2VsZWN0ZWRLZXlzKTtcbiAgICAgIGlmICgnc2VsZWN0ZWRLZXlzJyBpbiBwcm9wcykge1xuICAgICAgICBzZWxlY3RlZEtleXMgPSBnZXRLZXlzKHByb3BzLnNlbGVjdGVkS2V5cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0ZWRLZXlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFJhd0V4cGFuZGVkS2V5cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJhd0V4cGFuZGVkS2V5cygpIHtcbiAgICAgIGlmICghdGhpcy5fcmF3RXhwYW5kZWRLZXlzICYmICdleHBhbmRlZEtleXMnIGluIHRoaXMucHJvcHMpIHtcbiAgICAgICAgdGhpcy5fcmF3RXhwYW5kZWRLZXlzID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSh0aGlzLnN0YXRlLmV4cGFuZGVkS2V5cykpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldE9wZW5UcmFuc2l0aW9uTmFtZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9wZW5UcmFuc2l0aW9uTmFtZSgpIHtcbiAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICB2YXIgdHJhbnNpdGlvbk5hbWUgPSBwcm9wcy5vcGVuVHJhbnNpdGlvbk5hbWU7XG4gICAgICB2YXIgYW5pbWF0aW9uTmFtZSA9IHByb3BzLm9wZW5BbmltYXRpb247XG4gICAgICBpZiAoIXRyYW5zaXRpb25OYW1lICYmIHR5cGVvZiBhbmltYXRpb25OYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICB0cmFuc2l0aW9uTmFtZSA9IHByb3BzLnByZWZpeENscyArICctb3Blbi0nICsgYW5pbWF0aW9uTmFtZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cmFuc2l0aW9uTmFtZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXREcmFnTm9kZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREcmFnTm9kZXModHJlZU5vZGUpIHtcbiAgICAgIHZhciBkcmFnTm9kZXNLZXlzID0gW107XG4gICAgICB2YXIgdFBBcnIgPSB0cmVlTm9kZS5wcm9wcy5wb3Muc3BsaXQoJy0nKTtcbiAgICAgICgwLCBfdXRpbC5sb29wQWxsQ2hpbGRyZW4pKHRoaXMucHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChpdGVtLCBpbmRleCwgcG9zLCBuZXdLZXkpIHtcbiAgICAgICAgdmFyIHBBcnIgPSBwb3Muc3BsaXQoJy0nKTtcbiAgICAgICAgaWYgKHRyZWVOb2RlLnByb3BzLnBvcyA9PT0gcG9zIHx8IHRQQXJyLmxlbmd0aCA8IHBBcnIubGVuZ3RoICYmICgwLCBfdXRpbC5pc0luY2x1ZGUpKHRQQXJyLCBwQXJyKSkge1xuICAgICAgICAgIGRyYWdOb2Rlc0tleXMucHVzaChuZXdLZXkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkcmFnTm9kZXNLZXlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldEV4cGFuZGVkS2V5cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEV4cGFuZGVkS2V5cyh0cmVlTm9kZSwgZXhwYW5kKSB7XG4gICAgICB2YXIga2V5ID0gdHJlZU5vZGUucHJvcHMuZXZlbnRLZXk7XG4gICAgICB2YXIgZXhwYW5kZWRLZXlzID0gdGhpcy5zdGF0ZS5leHBhbmRlZEtleXM7XG4gICAgICB2YXIgZXhwYW5kZWRJbmRleCA9IGV4cGFuZGVkS2V5cy5pbmRleE9mKGtleSk7XG4gICAgICB2YXIgZXhLZXlzID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKGV4cGFuZGVkSW5kZXggPiAtMSAmJiAhZXhwYW5kKSB7XG4gICAgICAgIGV4S2V5cyA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoZXhwYW5kZWRLZXlzKSk7XG4gICAgICAgIGV4S2V5cy5zcGxpY2UoZXhwYW5kZWRJbmRleCwgMSk7XG4gICAgICAgIHJldHVybiBleEtleXM7XG4gICAgICB9XG4gICAgICBpZiAoZXhwYW5kICYmIGV4cGFuZGVkS2V5cy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBleHBhbmRlZEtleXMuY29uY2F0KFtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmaWx0ZXJUcmVlTm9kZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbHRlclRyZWVOb2RlKHRyZWVOb2RlKSB7XG4gICAgICB2YXIgZmlsdGVyVHJlZU5vZGUgPSB0aGlzLnByb3BzLmZpbHRlclRyZWVOb2RlO1xuICAgICAgaWYgKHR5cGVvZiBmaWx0ZXJUcmVlTm9kZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0cmVlTm9kZS5wcm9wcy5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmlsdGVyVHJlZU5vZGUuY2FsbCh0aGlzLCB0cmVlTm9kZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVuZGVyVHJlZU5vZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJUcmVlTm9kZShjaGlsZCwgaW5kZXgpIHtcbiAgICAgIHZhciBsZXZlbCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IDAgOiBhcmd1bWVudHNbMl07XG5cbiAgICAgIHZhciBwb3MgPSBsZXZlbCArICctJyArIGluZGV4O1xuICAgICAgdmFyIGtleSA9IGNoaWxkLmtleSB8fCBwb3M7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciBjbG9uZVByb3BzID0ge1xuICAgICAgICByZWY6ICd0cmVlTm9kZS0nICsga2V5LFxuICAgICAgICByb290OiB0aGlzLFxuICAgICAgICBldmVudEtleToga2V5LFxuICAgICAgICBwb3M6IHBvcyxcbiAgICAgICAgc2VsZWN0YWJsZTogcHJvcHMuc2VsZWN0YWJsZSxcbiAgICAgICAgbG9hZERhdGE6IHByb3BzLmxvYWREYXRhLFxuICAgICAgICBvbk1vdXNlRW50ZXI6IHByb3BzLm9uTW91c2VFbnRlcixcbiAgICAgICAgb25Nb3VzZUxlYXZlOiBwcm9wcy5vbk1vdXNlTGVhdmUsXG4gICAgICAgIG9uUmlnaHRDbGljazogcHJvcHMub25SaWdodENsaWNrLFxuICAgICAgICBwcmVmaXhDbHM6IHByb3BzLnByZWZpeENscyxcbiAgICAgICAgc2hvd0xpbmU6IHByb3BzLnNob3dMaW5lLFxuICAgICAgICBzaG93SWNvbjogcHJvcHMuc2hvd0ljb24sXG4gICAgICAgIGNoZWNrYWJsZTogcHJvcHMuY2hlY2thYmxlLFxuICAgICAgICBkcmFnZ2FibGU6IHByb3BzLmRyYWdnYWJsZSxcbiAgICAgICAgZHJhZ092ZXI6IHN0YXRlLmRyYWdPdmVyTm9kZUtleSA9PT0ga2V5ICYmIHRoaXMuZHJvcFBvc2l0aW9uID09PSAwLFxuICAgICAgICBkcmFnT3ZlckdhcFRvcDogc3RhdGUuZHJhZ092ZXJOb2RlS2V5ID09PSBrZXkgJiYgdGhpcy5kcm9wUG9zaXRpb24gPT09IC0xLFxuICAgICAgICBkcmFnT3ZlckdhcEJvdHRvbTogc3RhdGUuZHJhZ092ZXJOb2RlS2V5ID09PSBrZXkgJiYgdGhpcy5kcm9wUG9zaXRpb24gPT09IDEsXG4gICAgICAgIGV4cGFuZGVkOiBzdGF0ZS5leHBhbmRlZEtleXMuaW5kZXhPZihrZXkpICE9PSAtMSxcbiAgICAgICAgc2VsZWN0ZWQ6IHN0YXRlLnNlbGVjdGVkS2V5cy5pbmRleE9mKGtleSkgIT09IC0xLFxuICAgICAgICBjaGVja2VkOiB0aGlzLmNoZWNrZWRLZXlzLmluZGV4T2Yoa2V5KSAhPT0gLTEsXG4gICAgICAgIGNoZWNrUGFydDogdGhpcy5jaGVja1BhcnRLZXlzLmluZGV4T2Yoa2V5KSAhPT0gLTEsXG4gICAgICAgIG9wZW5UcmFuc2l0aW9uTmFtZTogdGhpcy5nZXRPcGVuVHJhbnNpdGlvbk5hbWUoKSxcbiAgICAgICAgb3BlbkFuaW1hdGlvbjogcHJvcHMub3BlbkFuaW1hdGlvbixcbiAgICAgICAgZmlsdGVyVHJlZU5vZGU6IHRoaXMuZmlsdGVyVHJlZU5vZGUuYmluZCh0aGlzKVxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLnRyZWVOb2Rlc1N0YXRlc1twb3NdKSB7XG4gICAgICAgICgwLCBfb2JqZWN0QXNzaWduMlsnZGVmYXVsdCddKShjbG9uZVByb3BzLCB0aGlzLnRyZWVOb2Rlc1N0YXRlc1twb3NdLnNpYmxpbmdQb3NpdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNsb25lRWxlbWVudChjaGlsZCwgY2xvbmVQcm9wcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVuZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciBkb21Qcm9wcyA9IHtcbiAgICAgICAgY2xhc3NOYW1lOiAoMCwgX2NsYXNzbmFtZXMyWydkZWZhdWx0J10pKHByb3BzLmNsYXNzTmFtZSwgcHJvcHMucHJlZml4Q2xzKSxcbiAgICAgICAgcm9sZTogJ3RyZWUtbm9kZSdcbiAgICAgIH07XG4gICAgICBpZiAocHJvcHMuZm9jdXNhYmxlKSB7XG4gICAgICAgIGRvbVByb3BzLnRhYkluZGV4ID0gJzAnO1xuICAgICAgICBkb21Qcm9wcy5vbktleURvd24gPSB0aGlzLm9uS2V5RG93bjtcbiAgICAgIH1cbiAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuc3RhdGUuZXhwYW5kZWRLZXlzLCB0aGlzLl9yYXdFeHBhbmRlZEtleXMsIHByb3BzLmNoaWxkcmVuKTtcbiAgICAgIHZhciBjaGVja0tleXMgPSAoMCwgX3V0aWwuZ2V0VHJlZU5vZGVzU3RhdGVzKShwcm9wcy5jaGlsZHJlbiwgdGhpcy5zdGF0ZS5jaGVja2VkS2V5cywgdHJ1ZSk7XG4gICAgICB0aGlzLmNoZWNrUGFydEtleXMgPSBjaGVja0tleXMuY2hlY2tQYXJ0S2V5cztcbiAgICAgIHRoaXMuY2hlY2tlZEtleXMgPSBjaGVja0tleXMuY2hlY2tlZEtleXM7XG4gICAgICB0aGlzLnRyZWVOb2Rlc1N0YXRlcyA9IGNoZWNrS2V5cy50cmVlTm9kZXNTdGF0ZXM7XG5cbiAgICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ3VsJyxcbiAgICAgICAgX2V4dGVuZHMoe30sIGRvbVByb3BzLCB7IHVuc2VsZWN0YWJsZTogdHJ1ZSwgcmVmOiAndHJlZScgfSksXG4gICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5DaGlsZHJlbi5tYXAocHJvcHMuY2hpbGRyZW4sIHRoaXMucmVuZGVyVHJlZU5vZGUsIHRoaXMpXG4gICAgICApO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUcmVlO1xufSkoX3JlYWN0MlsnZGVmYXVsdCddLkNvbXBvbmVudCk7XG5cblRyZWUucHJvcFR5cGVzID0ge1xuICBwcmVmaXhDbHM6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICBjaGlsZHJlbjogX3JlYWN0LlByb3BUeXBlcy5hbnksXG4gIHNob3dMaW5lOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gIHNob3dJY29uOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gIHNlbGVjdGFibGU6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgbXVsdGlwbGU6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgY2hlY2thYmxlOiBfcmVhY3QuUHJvcFR5cGVzLm9uZU9mVHlwZShbX3JlYWN0LlByb3BUeXBlcy5ib29sLCBfcmVhY3QuUHJvcFR5cGVzLm5vZGVdKSxcbiAgZHJhZ2dhYmxlOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gIGF1dG9FeHBhbmRQYXJlbnQ6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgZGVmYXVsdEV4cGFuZEFsbDogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICBleHBhbmRlZEtleXM6IF9yZWFjdC5Qcm9wVHlwZXMuYXJyYXlPZihfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyksXG4gIGRlZmF1bHRFeHBhbmRlZEtleXM6IF9yZWFjdC5Qcm9wVHlwZXMuYXJyYXlPZihfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyksXG4gIGNoZWNrZWRLZXlzOiBfcmVhY3QuUHJvcFR5cGVzLmFycmF5T2YoX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcpLFxuICBkZWZhdWx0Q2hlY2tlZEtleXM6IF9yZWFjdC5Qcm9wVHlwZXMuYXJyYXlPZihfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyksXG4gIHNlbGVjdGVkS2V5czogX3JlYWN0LlByb3BUeXBlcy5hcnJheU9mKF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nKSxcbiAgZGVmYXVsdFNlbGVjdGVkS2V5czogX3JlYWN0LlByb3BUeXBlcy5hcnJheU9mKF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nKSxcbiAgb25FeHBhbmQ6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgb25DaGVjazogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICBvblNlbGVjdDogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICBsb2FkRGF0YTogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICBvbk1vdXNlRW50ZXI6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgb25Nb3VzZUxlYXZlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gIG9uUmlnaHRDbGljazogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICBvbkRyYWdTdGFydDogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICBvbkRyYWdFbnRlcjogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICBvbkRyYWdPdmVyOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gIG9uRHJhZ0xlYXZlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gIG9uRHJvcDogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICBmaWx0ZXJUcmVlTm9kZTogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICBvcGVuVHJhbnNpdGlvbk5hbWU6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICBvcGVuQW5pbWF0aW9uOiBfcmVhY3QuUHJvcFR5cGVzLm9uZU9mVHlwZShbX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsIF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0XSlcbn07XG5cblRyZWUuZGVmYXVsdFByb3BzID0ge1xuICBwcmVmaXhDbHM6ICdyYy10cmVlJyxcbiAgc2hvd0xpbmU6IGZhbHNlLFxuICBzaG93SWNvbjogdHJ1ZSxcbiAgc2VsZWN0YWJsZTogdHJ1ZSxcbiAgbXVsdGlwbGU6IGZhbHNlLFxuICBjaGVja2FibGU6IGZhbHNlLFxuICBkcmFnZ2FibGU6IGZhbHNlLFxuICBhdXRvRXhwYW5kUGFyZW50OiB0cnVlLFxuICBkZWZhdWx0RXhwYW5kQWxsOiBmYWxzZSxcbiAgZGVmYXVsdEV4cGFuZGVkS2V5czogW10sXG4gIGRlZmF1bHRDaGVja2VkS2V5czogW10sXG4gIGRlZmF1bHRTZWxlY3RlZEtleXM6IFtdLFxuICBvbkV4cGFuZDogbm9vcCxcbiAgb25DaGVjazogbm9vcCxcbiAgb25TZWxlY3Q6IG5vb3AsXG4gIG9uRHJhZ1N0YXJ0OiBub29wLFxuICBvbkRyYWdFbnRlcjogbm9vcCxcbiAgb25EcmFnT3Zlcjogbm9vcCxcbiAgb25EcmFnTGVhdmU6IG5vb3AsXG4gIG9uRHJvcDogbm9vcFxufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gVHJlZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtdHJlZS9+L3JjLXRyZWUvbGliL1RyZWUuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5icm93c2VyID0gYnJvd3NlcjtcbmV4cG9ydHMuZ2V0T2Zmc2V0ID0gZ2V0T2Zmc2V0O1xuZXhwb3J0cy5sb29wQWxsQ2hpbGRyZW4gPSBsb29wQWxsQ2hpbGRyZW47XG5leHBvcnRzLmlzSW5jbHVkZSA9IGlzSW5jbHVkZTtcbmV4cG9ydHMuZmlsdGVyUGFyZW50UG9zaXRpb24gPSBmaWx0ZXJQYXJlbnRQb3NpdGlvbjtcbmV4cG9ydHMuZ2V0VHJlZU5vZGVzU3RhdGVzID0gZ2V0VHJlZU5vZGVzU3RhdGVzO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxuZnVuY3Rpb24gYnJvd3NlcihuYXZpZ2F0b3IpIHtcbiAgdmFyIHRlbSA9IHVuZGVmaW5lZDtcbiAgdmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgdmFyIE0gPSB1YS5tYXRjaCgvKG9wZXJhfGNocm9tZXxzYWZhcml8ZmlyZWZveHxtc2llfHRyaWRlbnQoPz1cXC8pKVxcLz9cXHMqKFxcZCspL2kpIHx8IFtdO1xuICBpZiAoL3RyaWRlbnQvaS50ZXN0KE1bMV0pKSB7XG4gICAgdGVtID0gL1xcYnJ2WyA6XSsoXFxkKykvZy5leGVjKHVhKSB8fCBbXTtcbiAgICByZXR1cm4gJ0lFICcgKyAodGVtWzFdIHx8ICcnKTtcbiAgfVxuICBpZiAoTVsxXSA9PT0gJ0Nocm9tZScpIHtcbiAgICB0ZW0gPSB1YS5tYXRjaCgvXFxiKE9QUnxFZGdlKVxcLyhcXGQrKS8pO1xuICAgIGlmICh0ZW0pIHJldHVybiB0ZW0uc2xpY2UoMSkuam9pbignICcpLnJlcGxhY2UoJ09QUicsICdPcGVyYScpO1xuICB9XG4gIE0gPSBNWzJdID8gW01bMV0sIE1bMl1dIDogW25hdmlnYXRvci5hcHBOYW1lLCBuYXZpZ2F0b3IuYXBwVmVyc2lvbiwgJy0/J107XG4gIHRlbSA9IHVhLm1hdGNoKC92ZXJzaW9uXFwvKFxcZCspL2kpO1xuICBpZiAodGVtKSB7XG4gICAgTS5zcGxpY2UoMSwgMSwgdGVtWzFdKTtcbiAgfVxuICByZXR1cm4gTS5qb2luKCcgJyk7XG59XG5cbi8vIGV4cG9ydCBmdW5jdGlvbiBnZXRPZmZzZXQoZWwpIHtcbi8vICAgY29uc3Qgb2JqID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4vLyAgIHJldHVybiB7XG4vLyAgICAgbGVmdDogb2JqLmxlZnQgKyBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQsXG4vLyAgICAgdG9wOiBvYmoudG9wICsgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AsXG4vLyAgICAgd2lkdGg6IG9iai53aWR0aCxcbi8vICAgICBoZWlnaHQ6IG9iai5oZWlnaHRcbi8vICAgfTtcbi8vIH1cblxuLy8gLy8gaXNjcm9sbCBvZmZzZXRcbi8vIG9mZnNldCA9IGZ1bmN0aW9uIChlbCkge1xuLy8gICB2YXIgbGVmdCA9IC1lbC5vZmZzZXRMZWZ0LFxuLy8gICAgIHRvcCA9IC1lbC5vZmZzZXRUb3A7XG5cbi8vICAgLy8ganNoaW50IC1XMDg0XG4vLyAgIHdoaWxlIChlbCA9IGVsLm9mZnNldFBhcmVudCkge1xuLy8gICAgIGxlZnQgLT0gZWwub2Zmc2V0TGVmdDtcbi8vICAgICB0b3AgLT0gZWwub2Zmc2V0VG9wO1xuLy8gICB9XG4vLyAgIC8vIGpzaGludCArVzA4NFxuXG4vLyAgIHJldHVybiB7XG4vLyAgICAgbGVmdDogbGVmdCxcbi8vICAgICB0b3A6IHRvcFxuLy8gICB9O1xuLy8gfVxuXG5mdW5jdGlvbiBnZXRPZmZzZXQoZWxlKSB7XG4gIHZhciBlbCA9IGVsZTtcbiAgdmFyIF94ID0gMDtcbiAgdmFyIF95ID0gMDtcbiAgd2hpbGUgKGVsICYmICFpc05hTihlbC5vZmZzZXRMZWZ0KSAmJiAhaXNOYU4oZWwub2Zmc2V0VG9wKSkge1xuICAgIF94ICs9IGVsLm9mZnNldExlZnQgLSBlbC5zY3JvbGxMZWZ0O1xuICAgIF95ICs9IGVsLm9mZnNldFRvcCAtIGVsLnNjcm9sbFRvcDtcbiAgICBlbCA9IGVsLm9mZnNldFBhcmVudDtcbiAgfVxuICByZXR1cm4geyB0b3A6IF95LCBsZWZ0OiBfeCB9O1xufVxuXG5mdW5jdGlvbiBnZXRDaGlsZHJlbmxlbmd0aChjaGlsZHJlbikge1xuICB2YXIgbGVuID0gMTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgbGVuID0gY2hpbGRyZW4ubGVuZ3RoO1xuICB9XG4gIHJldHVybiBsZW47XG59XG5cbmZ1bmN0aW9uIGdldFNpYmxpbmdQb3NpdGlvbihpbmRleCwgbGVuLCBzaWJsaW5nUG9zaXRpb24pIHtcbiAgaWYgKGxlbiA9PT0gMSkge1xuICAgIHNpYmxpbmdQb3NpdGlvbi5maXJzdCA9IHRydWU7XG4gICAgc2libGluZ1Bvc2l0aW9uLmxhc3QgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHNpYmxpbmdQb3NpdGlvbi5maXJzdCA9IGluZGV4ID09PSAwO1xuICAgIHNpYmxpbmdQb3NpdGlvbi5sYXN0ID0gaW5kZXggPT09IGxlbiAtIDE7XG4gIH1cbiAgcmV0dXJuIHNpYmxpbmdQb3NpdGlvbjtcbn1cblxuZnVuY3Rpb24gbG9vcEFsbENoaWxkcmVuKGNoaWxkcywgY2FsbGJhY2spIHtcbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiBsb29wKGNoaWxkcmVuLCBsZXZlbCkge1xuICAgIHZhciBsZW4gPSBnZXRDaGlsZHJlbmxlbmd0aChjaGlsZHJlbik7XG4gICAgX3JlYWN0MlsnZGVmYXVsdCddLkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgdmFyIHBvcyA9IGxldmVsICsgJy0nICsgaW5kZXg7XG4gICAgICBpZiAoaXRlbS5wcm9wcy5jaGlsZHJlbiAmJiBpdGVtLnR5cGUgJiYgaXRlbS50eXBlLmlzVHJlZU5vZGUpIHtcbiAgICAgICAgbG9vcChpdGVtLnByb3BzLmNoaWxkcmVuLCBwb3MpO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2soaXRlbSwgaW5kZXgsIHBvcywgaXRlbS5rZXkgfHwgcG9zLCBnZXRTaWJsaW5nUG9zaXRpb24oaW5kZXgsIGxlbiwge30pKTtcbiAgICB9KTtcbiAgfTtcbiAgbG9vcChjaGlsZHMsIDApO1xufVxuXG5mdW5jdGlvbiBpc0luY2x1ZGUoc21hbGxBcnJheSwgYmlnQXJyYXkpIHtcbiAgcmV0dXJuIHNtYWxsQXJyYXkuZXZlcnkoZnVuY3Rpb24gKGlpLCBpKSB7XG4gICAgcmV0dXJuIGlpID09PSBiaWdBcnJheVtpXTtcbiAgfSk7XG59XG5cbi8vIGNvbnNvbGUubG9nKGlzSW5jbHVkZShbJzAnLCAnMSddLCBbJzAnLCAnMTAnLCAnMSddKSk7XG5cbmZ1bmN0aW9uIHVuaXF1ZUFycmF5KGFycikge1xuICB2YXIgb2JqID0ge307XG4gIGFyci5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKCFvYmpbaXRlbV0pIHtcbiAgICAgIG9ialtpdGVtXSA9IHRydWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7XG59XG4vLyBjb25zb2xlLmxvZyh1bmlxdWVBcnJheShbJzExJywgJzInLCAnMiddKSk7XG5cbmZ1bmN0aW9uIGZpbHRlclBhcmVudFBvc2l0aW9uKGFycikge1xuICB2YXIgYSA9IFtdLmNvbmNhdChhcnIpO1xuICBhcnIuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgIHZhciBpdGVtQXJyID0gaXRlbS5zcGxpdCgnLScpO1xuICAgIGEuZm9yRWFjaChmdW5jdGlvbiAoaWksIGluZGV4KSB7XG4gICAgICB2YXIgaWlBcnIgPSBpaS5zcGxpdCgnLScpO1xuICAgICAgaWYgKGl0ZW1BcnIubGVuZ3RoIDw9IGlpQXJyLmxlbmd0aCAmJiBpc0luY2x1ZGUoaXRlbUFyciwgaWlBcnIpKSB7XG4gICAgICAgIGFbaW5kZXhdID0gaXRlbTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtQXJyLmxlbmd0aCA+IGlpQXJyLmxlbmd0aCAmJiBpc0luY2x1ZGUoaWlBcnIsIGl0ZW1BcnIpKSB7XG4gICAgICAgIGFbaW5kZXhdID0gaWk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gdW5pcXVlQXJyYXkoYSk7XG59XG5cbi8vIGNvbnNvbGUubG9nKGZpbHRlclBhcmVudFBvc2l0aW9uKFsnMC0yJywgJzAtMTAnLCAnMC0wLTEnLCAnMC0xLTEnLCAnMC0wJywnMC0xJywgJzAtMTAtMCddKSk7XG5cbi8vIFRPRE8g5pWI546H5beuLCDpnIDopoHnvJPlrZjkvJjljJZcbmZ1bmN0aW9uIGhhbmRsZUNoZWNrU3RhdGUob2JqLCBjaGVja2VkUG9zaXRpb25BcnIsIGNoZWNrSXQpIHtcbiAgdmFyIHN0cmlwVGFpbCA9IGZ1bmN0aW9uIHN0cmlwVGFpbChzdHIpIHtcbiAgICB2YXIgYXJyID0gc3RyLm1hdGNoKC8oLispKC1bXi1dKykkLyk7XG4gICAgdmFyIHN0ID0gJyc7XG4gICAgaWYgKGFyciAmJiBhcnIubGVuZ3RoID09PSAzKSB7XG4gICAgICBzdCA9IGFyclsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHN0O1xuICB9O1xuICAvLyBjb25zb2xlLmxvZyhzdHJpcFRhaWwoJzAtMTAxLTAwMCcpKTtcbiAgdmFyIHNwbGl0UG9zaXRpb24gPSBmdW5jdGlvbiBzcGxpdFBvc2l0aW9uKHBvcykge1xuICAgIHJldHVybiBwb3Muc3BsaXQoJy0nKTtcbiAgfTtcbiAgY2hlY2tlZFBvc2l0aW9uQXJyLmZvckVhY2goZnVuY3Rpb24gKF9wb3MpIHtcbiAgICAvLyDorr7nva7lrZDoioLngrnvvIzlhajpgInmiJblhajkuI3pgIlcbiAgICB2YXIgX3Bvc0FyciA9IHNwbGl0UG9zaXRpb24oX3Bvcyk7XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgICB2YXIgaUFyciA9IHNwbGl0UG9zaXRpb24oaSk7XG4gICAgICBpZiAoaUFyci5sZW5ndGggPiBfcG9zQXJyLmxlbmd0aCAmJiBpc0luY2x1ZGUoX3Bvc0FyciwgaUFycikpIHtcbiAgICAgICAgb2JqW2ldLmNoZWNrUGFydCA9IGZhbHNlO1xuICAgICAgICBvYmpbaV0uY2hlY2tlZCA9IGNoZWNrSXQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8g5b6q546v6K6+572u54i26IqC54K555qEIOmAieS4rSDmiJYg5Y2K6YCJ54q25oCBXG4gICAgdmFyIGxvb3AgPSBmdW5jdGlvbiBsb29wKF9fcG9zKSB7XG4gICAgICB2YXIgX3Bvc0xlbiA9IHNwbGl0UG9zaXRpb24oX19wb3MpLmxlbmd0aDtcbiAgICAgIGlmIChfcG9zTGVuIDw9IDIpIHtcbiAgICAgICAgLy8gZS5nLiAnMC0wJywgJzAtMSdcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHNpYmxpbmcgPSAwO1xuICAgICAgdmFyIHNpYmxpbmdDaGVja2VkID0gMDtcbiAgICAgIHZhciBwYXJlbnRQb3NpdGlvbiA9IHN0cmlwVGFpbChfX3Bvcyk7XG4gICAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgdmFyIGlBcnIgPSBzcGxpdFBvc2l0aW9uKGkpO1xuICAgICAgICBpZiAoaUFyci5sZW5ndGggPT09IF9wb3NMZW4gJiYgaXNJbmNsdWRlKHNwbGl0UG9zaXRpb24ocGFyZW50UG9zaXRpb24pLCBpQXJyKSkge1xuICAgICAgICAgIHNpYmxpbmcrKztcbiAgICAgICAgICBpZiAob2JqW2ldLmNoZWNrZWQpIHtcbiAgICAgICAgICAgIHNpYmxpbmdDaGVja2VkKys7XG4gICAgICAgICAgfSBlbHNlIGlmIChvYmpbaV0uY2hlY2tQYXJ0KSB7XG4gICAgICAgICAgICBzaWJsaW5nQ2hlY2tlZCArPSAwLjU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZhciBwYXJlbnQgPSBvYmpbcGFyZW50UG9zaXRpb25dO1xuICAgICAgLy8gc2libGluZyDkuI3kvJrnrYnkuo4wXG4gICAgICAvLyDlhajkuI3pgIkgLSDlhajpgIkgLSDljYrpgIlcbiAgICAgIGlmIChzaWJsaW5nQ2hlY2tlZCA9PT0gMCkge1xuICAgICAgICBwYXJlbnQuY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICBwYXJlbnQuY2hlY2tQYXJ0ID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHNpYmxpbmdDaGVja2VkID09PSBzaWJsaW5nKSB7XG4gICAgICAgIHBhcmVudC5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgcGFyZW50LmNoZWNrUGFydCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50LmNoZWNrUGFydCA9IHRydWU7XG4gICAgICAgIHBhcmVudC5jaGVja2VkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBsb29wKHBhcmVudFBvc2l0aW9uKTtcbiAgICB9O1xuICAgIGxvb3AoX3Bvcyk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRDaGVja0tleXModHJlZU5vZGVzU3RhdGVzKSB7XG4gIHZhciBjaGVja1BhcnRLZXlzID0gW107XG4gIHZhciBjaGVja2VkS2V5cyA9IFtdO1xuICB2YXIgY2hlY2tlZE5vZGVzID0gW107XG4gIHZhciBjaGVja2VkTm9kZXNQb3NpdGlvbnMgPSBbXTtcbiAgT2JqZWN0LmtleXModHJlZU5vZGVzU3RhdGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgdmFyIGl0ZW1PYmogPSB0cmVlTm9kZXNTdGF0ZXNbaXRlbV07XG4gICAgaWYgKGl0ZW1PYmouY2hlY2tlZCkge1xuICAgICAgY2hlY2tlZEtleXMucHVzaChpdGVtT2JqLmtleSk7XG4gICAgICBjaGVja2VkTm9kZXMucHVzaChpdGVtT2JqLm5vZGUpO1xuICAgICAgY2hlY2tlZE5vZGVzUG9zaXRpb25zLnB1c2goeyBub2RlOiBpdGVtT2JqLm5vZGUsIHBvczogaXRlbSB9KTtcbiAgICB9IGVsc2UgaWYgKGl0ZW1PYmouY2hlY2tQYXJ0KSB7XG4gICAgICBjaGVja1BhcnRLZXlzLnB1c2goaXRlbU9iai5rZXkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgY2hlY2tQYXJ0S2V5czogY2hlY2tQYXJ0S2V5cywgY2hlY2tlZEtleXM6IGNoZWNrZWRLZXlzLCBjaGVja2VkTm9kZXM6IGNoZWNrZWROb2RlcywgY2hlY2tlZE5vZGVzUG9zaXRpb25zOiBjaGVja2VkTm9kZXNQb3NpdGlvbnMsIHRyZWVOb2Rlc1N0YXRlczogdHJlZU5vZGVzU3RhdGVzXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFRyZWVOb2Rlc1N0YXRlcyhjaGlsZHJlbiwgY2hlY2tlZEtleXMsIGNoZWNrSXQsIHVuQ2hlY2tLZXkpIHtcbiAgdmFyIGNoZWNrZWRQb3NpdGlvbiA9IFtdO1xuICB2YXIgdHJlZU5vZGVzU3RhdGVzID0ge307XG4gIGxvb3BBbGxDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKGl0ZW0sIGluZGV4LCBwb3MsIGtleU9yUG9zLCBzaWJsaW5nUG9zaXRpb24pIHtcbiAgICB2YXIgY2hlY2tlZCA9IGZhbHNlO1xuICAgIGlmIChjaGVja2VkS2V5cy5pbmRleE9mKGtleU9yUG9zKSAhPT0gLTEpIHtcbiAgICAgIGNoZWNrZWQgPSB0cnVlO1xuICAgICAgY2hlY2tlZFBvc2l0aW9uLnB1c2gocG9zKTtcbiAgICB9XG4gICAgdHJlZU5vZGVzU3RhdGVzW3Bvc10gPSB7XG4gICAgICBub2RlOiBpdGVtLFxuICAgICAga2V5OiBrZXlPclBvcyxcbiAgICAgIGNoZWNrZWQ6IGNoZWNrZWQsXG4gICAgICBjaGVja1BhcnQ6IGZhbHNlLFxuICAgICAgc2libGluZ1Bvc2l0aW9uOiBzaWJsaW5nUG9zaXRpb25cbiAgICB9O1xuICB9KTtcblxuICAvLyBkZWJ1Z2dlclxuICBoYW5kbGVDaGVja1N0YXRlKHRyZWVOb2Rlc1N0YXRlcywgZmlsdGVyUGFyZW50UG9zaXRpb24oY2hlY2tlZFBvc2l0aW9uLnNvcnQoKSksIHRydWUpO1xuXG4gIGlmICghY2hlY2tJdCAmJiB1bkNoZWNrS2V5KSB7XG4gICAgdmFyIHBvcyA9IHVuZGVmaW5lZDtcbiAgICBPYmplY3Qua2V5cyh0cmVlTm9kZXNTdGF0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBpdGVtT2JqID0gdHJlZU5vZGVzU3RhdGVzW2l0ZW1dO1xuICAgICAgaWYgKGl0ZW1PYmoua2V5ID09PSB1bkNoZWNrS2V5KSB7XG4gICAgICAgIHBvcyA9IGl0ZW07XG4gICAgICAgIGl0ZW1PYmouY2hlY2tlZCA9IGNoZWNrSXQ7XG4gICAgICAgIGl0ZW1PYmouY2hlY2tQYXJ0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaGFuZGxlQ2hlY2tTdGF0ZSh0cmVlTm9kZXNTdGF0ZXMsIFtwb3NdLCBjaGVja0l0KTtcbiAgfVxuXG4gIHJldHVybiBnZXRDaGVja0tleXModHJlZU5vZGVzU3RhdGVzKTtcbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLXRyZWUvfi9yYy10cmVlL2xpYi91dGlsLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfb2JqZWN0QXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgX29iamVjdEFzc2lnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vYmplY3RBc3NpZ24pO1xuXG52YXIgX2NsYXNzbmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG5cbnZhciBfY2xhc3NuYW1lczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc25hbWVzKTtcblxudmFyIF9yY0FuaW1hdGUgPSByZXF1aXJlKCdyYy1hbmltYXRlJyk7XG5cbnZhciBfcmNBbmltYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JjQW5pbWF0ZSk7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgYnJvd3NlclVhID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyAoMCwgX3V0aWwuYnJvd3Nlcikod2luZG93Lm5hdmlnYXRvcikgOiAnJztcbnZhciBpZU9yRWRnZSA9IC8uKihJRXxFZGdlKS4rLy50ZXN0KGJyb3dzZXJVYSk7XG4vLyBjb25zdCB1YUFycmF5ID0gYnJvd3NlclVhLnNwbGl0KCcgJyk7XG4vLyBjb25zdCBndElFOCA9IHVhQXJyYXkubGVuZ3RoICE9PSAyIHx8IHVhQXJyYXlbMF0uaW5kZXhPZignSUUnKSA9PT0gLTEgfHwgTnVtYmVyKHVhQXJyYXlbMV0pID4gODtcblxudmFyIGRlZmF1bHRUaXRsZSA9ICctLS0nO1xuXG52YXIgVHJlZU5vZGUgPSAoZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFRyZWVOb2RlLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBUcmVlTm9kZShwcm9wcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJlZU5vZGUpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoVHJlZU5vZGUucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuY2FsbCh0aGlzLCBwcm9wcyk7XG4gICAgWydvbkV4cGFuZCcsICdvbkNoZWNrJywgJ29uQ29udGV4dE1lbnUnLCAnb25Nb3VzZUVudGVyJywgJ29uTW91c2VMZWF2ZScsICdvbkRyYWdTdGFydCcsICdvbkRyYWdFbnRlcicsICdvbkRyYWdPdmVyJywgJ29uRHJhZ0xlYXZlJywgJ29uRHJvcCddLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICAgIF90aGlzW21dID0gX3RoaXNbbV0uYmluZChfdGhpcyk7XG4gICAgfSk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGRhdGFMb2FkaW5nOiBmYWxzZSxcbiAgICAgIGRyYWdOb2RlSGlnaGxpZ2h0OiBmYWxzZVxuICAgIH07XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVHJlZU5vZGUsIFt7XG4gICAga2V5OiAnb25DaGVjaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ2hlY2soKSB7XG4gICAgICB0aGlzLnByb3BzLnJvb3Qub25DaGVjayh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvblNlbGVjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uU2VsZWN0KCkge1xuICAgICAgdGhpcy5wcm9wcy5yb290Lm9uU2VsZWN0KHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uTW91c2VFbnRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTW91c2VFbnRlcihlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLnByb3BzLnJvb3Qub25Nb3VzZUVudGVyKGUsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uTW91c2VMZWF2ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTW91c2VMZWF2ZShlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLnByb3BzLnJvb3Qub25Nb3VzZUxlYXZlKGUsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uQ29udGV4dE1lbnUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNvbnRleHRNZW51KGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMucHJvcHMucm9vdC5vbkNvbnRleHRNZW51KGUsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uRHJhZ1N0YXJ0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25EcmFnU3RhcnQoZSkge1xuICAgICAgLy8gY29uc29sZS5sb2coJ2RyYWdzdGFydCcsIHRoaXMucHJvcHMuZXZlbnRLZXksIGUpO1xuICAgICAgLy8gZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBkcmFnTm9kZUhpZ2hsaWdodDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB0aGlzLnByb3BzLnJvb3Qub25EcmFnU3RhcnQoZSwgdGhpcyk7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBpZSB0aHJvdyBlcnJvclxuICAgICAgICBlLmRhdGFUcmFuc2Zlci5zZXREYXRhKCd0ZXh0L3BsYWluJywgJ2ZpcmVmb3gtbmVlZC1pdCcpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgLy8gZW1wdHlcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkRyYWdFbnRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRHJhZ0VudGVyKGUpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdkcmFnZW50ZXInLCB0aGlzLnByb3BzLmV2ZW50S2V5LCBlKTtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB0aGlzLnByb3BzLnJvb3Qub25EcmFnRW50ZXIoZSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25EcmFnT3ZlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRHJhZ092ZXIoZSkge1xuICAgICAgLy8gY29uc29sZS5sb2codGhpcy5wcm9wcy5ldmVudEtleSwgZSk7XG4gICAgICAvLyB0b2RvIGRpc2FibGVkXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgdGhpcy5wcm9wcy5yb290Lm9uRHJhZ092ZXIoZSwgdGhpcyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25EcmFnTGVhdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkRyYWdMZWF2ZShlKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLnByb3BzLmV2ZW50S2V5LCBlKTtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB0aGlzLnByb3BzLnJvb3Qub25EcmFnTGVhdmUoZSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25Ecm9wJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Ecm9wKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgZHJhZ05vZGVIaWdobGlnaHQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHRoaXMucHJvcHMucm9vdC5vbkRyb3AoZSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25FeHBhbmQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkV4cGFuZCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgY2FsbGJhY2tQcm9taXNlID0gdGhpcy5wcm9wcy5yb290Lm9uRXhwYW5kKHRoaXMpO1xuICAgICAgaWYgKGNhbGxiYWNrUHJvbWlzZSAmJiB0eXBlb2YgY2FsbGJhY2tQcm9taXNlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzZXRMb2FkaW5nID0gZnVuY3Rpb24gc2V0TG9hZGluZyhkYXRhTG9hZGluZykge1xuICAgICAgICAgICAgX3RoaXMyLnNldFN0YXRlKHsgZGF0YUxvYWRpbmc6IGRhdGFMb2FkaW5nIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgICAgICBjYWxsYmFja1Byb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBrZXlib2FyZCBldmVudCBzdXBwb3J0XG4gIH0sIHtcbiAgICBrZXk6ICdvbktleURvd24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbktleURvd24oZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbmRlclN3aXRjaGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyU3dpdGNoZXIocHJvcHMsIGV4cGFuZGVkU3RhdGUpIHtcbiAgICAgIHZhciBwcmVmaXhDbHMgPSBwcm9wcy5wcmVmaXhDbHM7XG4gICAgICB2YXIgc3dpdGNoZXJDbHMgPSBfZGVmaW5lUHJvcGVydHkoe30sIHByZWZpeENscyArICctc3dpdGNoZXInLCB0cnVlKTtcbiAgICAgIGlmICghcHJvcHMuc2hvd0xpbmUpIHtcbiAgICAgICAgc3dpdGNoZXJDbHNbcHJlZml4Q2xzICsgJy1ub2xpbmVfJyArIGV4cGFuZGVkU3RhdGVdID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcHMucG9zID09PSAnMC0wJykge1xuICAgICAgICBzd2l0Y2hlckNsc1twcmVmaXhDbHMgKyAnLXJvb3RzXycgKyBleHBhbmRlZFN0YXRlXSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2hlckNsc1twcmVmaXhDbHMgKyAnLWNlbnRlcl8nICsgZXhwYW5kZWRTdGF0ZV0gPSAhcHJvcHMubGFzdDtcbiAgICAgICAgc3dpdGNoZXJDbHNbcHJlZml4Q2xzICsgJy1ib3R0b21fJyArIGV4cGFuZGVkU3RhdGVdID0gcHJvcHMubGFzdDtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgICBzd2l0Y2hlckNsc1twcmVmaXhDbHMgKyAnLXN3aXRjaGVyLWRpc2FibGVkJ10gPSB0cnVlO1xuICAgICAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nLCB7IGNsYXNzTmFtZTogKDAsIF9jbGFzc25hbWVzMlsnZGVmYXVsdCddKShzd2l0Y2hlckNscykgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nLCB7IGNsYXNzTmFtZTogKDAsIF9jbGFzc25hbWVzMlsnZGVmYXVsdCddKShzd2l0Y2hlckNscyksIG9uQ2xpY2s6IHRoaXMub25FeHBhbmQgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVuZGVyQ2hlY2tib3gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJDaGVja2JveChwcm9wcykge1xuICAgICAgdmFyIHByZWZpeENscyA9IHByb3BzLnByZWZpeENscztcbiAgICAgIHZhciBjaGVja2JveENscyA9IF9kZWZpbmVQcm9wZXJ0eSh7fSwgcHJlZml4Q2xzICsgJy1jaGVja2JveCcsIHRydWUpO1xuICAgICAgaWYgKHByb3BzLmNoZWNrUGFydCkge1xuICAgICAgICBjaGVja2JveENsc1twcmVmaXhDbHMgKyAnLWNoZWNrYm94LWluZGV0ZXJtaW5hdGUnXSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHByb3BzLmNoZWNrZWQpIHtcbiAgICAgICAgY2hlY2tib3hDbHNbcHJlZml4Q2xzICsgJy1jaGVja2JveC1jaGVja2VkJ10gPSB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIGN1c3RvbUVsZSA9IG51bGw7XG4gICAgICBpZiAodHlwZW9mIHByb3BzLmNoZWNrYWJsZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGN1c3RvbUVsZSA9IHByb3BzLmNoZWNrYWJsZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy5kaXNhYmxlZCB8fCBwcm9wcy5kaXNhYmxlQ2hlY2tib3gpIHtcbiAgICAgICAgY2hlY2tib3hDbHNbcHJlZml4Q2xzICsgJy1jaGVja2JveC1kaXNhYmxlZCddID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICB7IHJlZjogJ2NoZWNrYm94JywgY2xhc3NOYW1lOiAoMCwgX2NsYXNzbmFtZXMyWydkZWZhdWx0J10pKGNoZWNrYm94Q2xzKSB9LFxuICAgICAgICAgIGN1c3RvbUVsZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnc3BhbicsXG4gICAgICAgIHsgcmVmOiAnY2hlY2tib3gnLCBjbGFzc05hbWU6ICgwLCBfY2xhc3NuYW1lczJbJ2RlZmF1bHQnXSkoY2hlY2tib3hDbHMpLCBvbkNsaWNrOiB0aGlzLm9uQ2hlY2sgfSxcbiAgICAgICAgY3VzdG9tRWxlXG4gICAgICApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbmRlckNoaWxkcmVuJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyQ2hpbGRyZW4ocHJvcHMpIHtcbiAgICAgIHZhciByZW5kZXJGaXJzdCA9IHRoaXMucmVuZGVyRmlyc3Q7XG4gICAgICB0aGlzLnJlbmRlckZpcnN0ID0gMTtcbiAgICAgIHZhciB0cmFuc2l0aW9uQXBwZWFyID0gdHJ1ZTtcbiAgICAgIGlmICghcmVuZGVyRmlyc3QgJiYgcHJvcHMuZXhwYW5kZWQpIHtcbiAgICAgICAgdHJhbnNpdGlvbkFwcGVhciA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gICAgICB2YXIgbmV3Q2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgIHZhciBhbGxUcmVlTm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICBhbGxUcmVlTm9kZSA9IGNoaWxkcmVuLmV2ZXJ5KGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW0udHlwZSA9PT0gVHJlZU5vZGU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkcmVuICYmIChjaGlsZHJlbi50eXBlID09PSBUcmVlTm9kZSB8fCBhbGxUcmVlTm9kZSkpIHtcbiAgICAgICAgdmFyIF9jbHM7XG5cbiAgICAgICAgdmFyIGNscyA9IChfY2xzID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfY2xzLCBwcm9wcy5wcmVmaXhDbHMgKyAnLWNoaWxkLXRyZWUnLCB0cnVlKSwgX2RlZmluZVByb3BlcnR5KF9jbHMsIHByb3BzLnByZWZpeENscyArICctY2hpbGQtdHJlZS1vcGVuJywgcHJvcHMuZXhwYW5kZWQpLCBfY2xzKTtcbiAgICAgICAgaWYgKHByb3BzLnNob3dMaW5lKSB7XG4gICAgICAgICAgY2xzW3Byb3BzLnByZWZpeENscyArICctbGluZSddID0gIXByb3BzLmxhc3Q7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFuaW1Qcm9wcyA9IHt9O1xuICAgICAgICBpZiAocHJvcHMub3BlblRyYW5zaXRpb25OYW1lKSB7XG4gICAgICAgICAgYW5pbVByb3BzLnRyYW5zaXRpb25OYW1lID0gcHJvcHMub3BlblRyYW5zaXRpb25OYW1lO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9wcy5vcGVuQW5pbWF0aW9uID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGFuaW1Qcm9wcy5hbmltYXRpb24gPSAoMCwgX29iamVjdEFzc2lnbjJbJ2RlZmF1bHQnXSkoe30sIHByb3BzLm9wZW5BbmltYXRpb24pO1xuICAgICAgICAgIGlmICghdHJhbnNpdGlvbkFwcGVhcikge1xuICAgICAgICAgICAgZGVsZXRlIGFuaW1Qcm9wcy5hbmltYXRpb24uYXBwZWFyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXdDaGlsZHJlbiA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIF9yY0FuaW1hdGUyWydkZWZhdWx0J10sXG4gICAgICAgICAgX2V4dGVuZHMoe30sIGFuaW1Qcm9wcywge1xuICAgICAgICAgICAgc2hvd1Byb3A6ICdleHBhbmRlZCcsXG4gICAgICAgICAgICB0cmFuc2l0aW9uQXBwZWFyOiB0cmFuc2l0aW9uQXBwZWFyLFxuICAgICAgICAgICAgY29tcG9uZW50OiAnJyB9KSxcbiAgICAgICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICd1bCcsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogKDAsIF9jbGFzc25hbWVzMlsnZGVmYXVsdCddKShjbHMpLCBleHBhbmRlZDogcHJvcHMuZXhwYW5kZWQgfSxcbiAgICAgICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5DaGlsZHJlbi5tYXAoY2hpbGRyZW4sIGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcHMucm9vdC5yZW5kZXJUcmVlTm9kZShpdGVtLCBpbmRleCwgcHJvcHMucG9zKTtcbiAgICAgICAgICAgIH0sIHByb3BzLnJvb3QpXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0NoaWxkcmVuO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfaWNvbkVsZUNscyxcbiAgICAgICAgICBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgdmFyIHByZWZpeENscyA9IHByb3BzLnByZWZpeENscztcbiAgICAgIHZhciBleHBhbmRlZFN0YXRlID0gcHJvcHMuZXhwYW5kZWQgPyAnb3BlbicgOiAnY2xvc2UnO1xuXG4gICAgICB2YXIgaWNvbkVsZUNscyA9IChfaWNvbkVsZUNscyA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX2ljb25FbGVDbHMsIHByZWZpeENscyArICctaWNvbkVsZScsIHRydWUpLCBfZGVmaW5lUHJvcGVydHkoX2ljb25FbGVDbHMsIHByZWZpeENscyArICctaWNvbl9sb2FkaW5nJywgdGhpcy5zdGF0ZS5kYXRhTG9hZGluZyksIF9kZWZpbmVQcm9wZXJ0eShfaWNvbkVsZUNscywgcHJlZml4Q2xzICsgJy1pY29uX18nICsgZXhwYW5kZWRTdGF0ZSwgdHJ1ZSksIF9pY29uRWxlQ2xzKTtcblxuICAgICAgdmFyIGNhblJlbmRlclN3aXRjaGVyID0gdHJ1ZTtcbiAgICAgIHZhciBjb250ZW50ID0gcHJvcHMudGl0bGU7XG4gICAgICB2YXIgbmV3Q2hpbGRyZW4gPSB0aGlzLnJlbmRlckNoaWxkcmVuKHByb3BzKTtcbiAgICAgIGlmICghbmV3Q2hpbGRyZW4gfHwgbmV3Q2hpbGRyZW4gPT09IHByb3BzLmNoaWxkcmVuKSB7XG4gICAgICAgIC8vIGNvbnRlbnQgPSBuZXdDaGlsZHJlbjtcbiAgICAgICAgbmV3Q2hpbGRyZW4gPSBudWxsO1xuICAgICAgICBpZiAoIXByb3BzLmxvYWREYXRhIHx8IHByb3BzLmlzTGVhZikge1xuICAgICAgICAgIGNhblJlbmRlclN3aXRjaGVyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIOWmguaenOm7mOiupOS4jeWxleW8gO+8jOS4jea4suafk+i/m2Rvbe+8jOWcqOWkp+mHj+aVsOaNruS4i++8jOiDveS9v+aAp+iDveacieW+iOWkp+aPkOWNh++8gVxuICAgICAgaWYgKCFwcm9wcy5leHBhbmRlZCkge1xuICAgICAgICBuZXdDaGlsZHJlbiA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWxlY3RIYW5kbGUgPSBmdW5jdGlvbiBzZWxlY3RIYW5kbGUoKSB7XG4gICAgICAgIHZhciBpY29uID0gcHJvcHMuc2hvd0ljb24gfHwgcHJvcHMubG9hZERhdGEgJiYgX3RoaXMzLnN0YXRlLmRhdGFMb2FkaW5nID8gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nLCB7IGNsYXNzTmFtZTogKDAsIF9jbGFzc25hbWVzMlsnZGVmYXVsdCddKShpY29uRWxlQ2xzKSB9KSA6IG51bGw7XG4gICAgICAgIHZhciB0aXRsZSA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy10aXRsZScgfSxcbiAgICAgICAgICBjb250ZW50XG4gICAgICAgICk7XG4gICAgICAgIHZhciBkb21Qcm9wcyA9IHt9O1xuICAgICAgICBpZiAoIXByb3BzLmRpc2FibGVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzLnNlbGVjdGVkIHx8IF90aGlzMy5zdGF0ZS5kcmFnTm9kZUhpZ2hsaWdodCkge1xuICAgICAgICAgICAgZG9tUHJvcHMuY2xhc3NOYW1lID0gcHJlZml4Q2xzICsgJy1ub2RlLXNlbGVjdGVkJztcbiAgICAgICAgICB9XG4gICAgICAgICAgZG9tUHJvcHMub25DbGljayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBpZiAocHJvcHMuc2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgICBfdGhpczMub25TZWxlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG5vdCBmaXJlIGNoZWNrIGV2ZW50XG4gICAgICAgICAgICAvLyBpZiAocHJvcHMuY2hlY2thYmxlKSB7XG4gICAgICAgICAgICAvLyAgIHRoaXMub25DaGVjaygpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKHByb3BzLm9uUmlnaHRDbGljaykge1xuICAgICAgICAgICAgZG9tUHJvcHMub25Db250ZXh0TWVudSA9IF90aGlzMy5vbkNvbnRleHRNZW51O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJvcHMub25Nb3VzZUVudGVyKSB7XG4gICAgICAgICAgICBkb21Qcm9wcy5vbk1vdXNlRW50ZXIgPSBfdGhpczMub25Nb3VzZUVudGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJvcHMub25Nb3VzZUxlYXZlKSB7XG4gICAgICAgICAgICBkb21Qcm9wcy5vbk1vdXNlTGVhdmUgPSBfdGhpczMub25Nb3VzZUxlYXZlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJvcHMuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICBpZiAoaWVPckVkZ2UpIHtcbiAgICAgICAgICAgICAgLy8gaWUgYnVnIVxuICAgICAgICAgICAgICBkb21Qcm9wcy5ocmVmID0gJyMnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tUHJvcHMuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIGRvbVByb3BzWydhcmlhLWdyYWJiZWQnXSA9IHRydWU7XG4gICAgICAgICAgICBkb21Qcm9wcy5vbkRyYWdTdGFydCA9IF90aGlzMy5vbkRyYWdTdGFydDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICdhJyxcbiAgICAgICAgICBfZXh0ZW5kcyh7IHJlZjogJ3NlbGVjdEhhbmRsZScsIHRpdGxlOiB0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycgPyBjb250ZW50IDogJycgfSwgZG9tUHJvcHMpLFxuICAgICAgICAgIGljb24sXG4gICAgICAgICAgdGl0bGVcbiAgICAgICAgKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBsaVByb3BzID0ge307XG4gICAgICBpZiAocHJvcHMuZHJhZ2dhYmxlKSB7XG4gICAgICAgIGxpUHJvcHMub25EcmFnRW50ZXIgPSB0aGlzLm9uRHJhZ0VudGVyO1xuICAgICAgICBsaVByb3BzLm9uRHJhZ092ZXIgPSB0aGlzLm9uRHJhZ092ZXI7XG4gICAgICAgIGxpUHJvcHMub25EcmFnTGVhdmUgPSB0aGlzLm9uRHJhZ0xlYXZlO1xuICAgICAgICBsaVByb3BzLm9uRHJvcCA9IHRoaXMub25Ecm9wO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGlzYWJsZWRDbHMgPSAnJztcbiAgICAgIHZhciBkcmFnT3ZlckNscyA9ICcnO1xuICAgICAgaWYgKHByb3BzLmRpc2FibGVkKSB7XG4gICAgICAgIGRpc2FibGVkQ2xzID0gcHJlZml4Q2xzICsgJy10cmVlbm9kZS1kaXNhYmxlZCc7XG4gICAgICB9IGVsc2UgaWYgKHByb3BzLmRyYWdPdmVyKSB7XG4gICAgICAgIGRyYWdPdmVyQ2xzID0gJ2RyYWctb3Zlcic7XG4gICAgICB9IGVsc2UgaWYgKHByb3BzLmRyYWdPdmVyR2FwVG9wKSB7XG4gICAgICAgIGRyYWdPdmVyQ2xzID0gJ2RyYWctb3Zlci1nYXAtdG9wJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcHMuZHJhZ092ZXJHYXBCb3R0b20pIHtcbiAgICAgICAgZHJhZ092ZXJDbHMgPSAnZHJhZy1vdmVyLWdhcC1ib3R0b20nO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmlsdGVyQ2xzID0gcHJvcHMuZmlsdGVyVHJlZU5vZGUodGhpcykgPyAnZmlsdGVyLW5vZGUnIDogJyc7XG5cbiAgICAgIHZhciBub29wU3dpdGNoZXIgPSBmdW5jdGlvbiBub29wU3dpdGNoZXIoKSB7XG4gICAgICAgIHZhciBfY2xzMjtcblxuICAgICAgICB2YXIgY2xzID0gKF9jbHMyID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfY2xzMiwgcHJlZml4Q2xzICsgJy1zd2l0Y2hlcicsIHRydWUpLCBfZGVmaW5lUHJvcGVydHkoX2NsczIsIHByZWZpeENscyArICctc3dpdGNoZXItbm9vcCcsIHRydWUpLCBfY2xzMik7XG4gICAgICAgIGlmIChwcm9wcy5zaG93TGluZSkge1xuICAgICAgICAgIGNsc1twcmVmaXhDbHMgKyAnLWNlbnRlcl9kb2N1J10gPSAhcHJvcHMubGFzdDtcbiAgICAgICAgICBjbHNbcHJlZml4Q2xzICsgJy1ib3R0b21fZG9jdSddID0gcHJvcHMubGFzdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbHNbcHJlZml4Q2xzICsgJy1ub2xpbmVfZG9jdSddID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nLCB7IGNsYXNzTmFtZTogKDAsIF9jbGFzc25hbWVzMlsnZGVmYXVsdCddKShjbHMpIH0pO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnbGknLFxuICAgICAgICBfZXh0ZW5kcyh7fSwgbGlQcm9wcywgeyByZWY6ICdsaScsIGNsYXNzTmFtZTogKDAsIF9jbGFzc25hbWVzMlsnZGVmYXVsdCddKShwcm9wcy5jbGFzc05hbWUsIGRpc2FibGVkQ2xzLCBkcmFnT3ZlckNscywgZmlsdGVyQ2xzKSB9KSxcbiAgICAgICAgY2FuUmVuZGVyU3dpdGNoZXIgPyB0aGlzLnJlbmRlclN3aXRjaGVyKHByb3BzLCBleHBhbmRlZFN0YXRlKSA6IG5vb3BTd2l0Y2hlcigpLFxuICAgICAgICBwcm9wcy5jaGVja2FibGUgPyB0aGlzLnJlbmRlckNoZWNrYm94KHByb3BzKSA6IG51bGwsXG4gICAgICAgIHNlbGVjdEhhbmRsZSgpLFxuICAgICAgICBuZXdDaGlsZHJlblxuICAgICAgKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVHJlZU5vZGU7XG59KShfcmVhY3QyWydkZWZhdWx0J10uQ29tcG9uZW50KTtcblxuVHJlZU5vZGUuaXNUcmVlTm9kZSA9IDE7XG5cblRyZWVOb2RlLnByb3BUeXBlcyA9IHtcbiAgcHJlZml4Q2xzOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgZGlzYWJsZWQ6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgZGlzYWJsZUNoZWNrYm94OiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gIGV4cGFuZGVkOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gIGlzTGVhZjogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICByb290OiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgb25TZWxlY3Q6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuY1xufTtcblxuVHJlZU5vZGUuZGVmYXVsdFByb3BzID0ge1xuICB0aXRsZTogZGVmYXVsdFRpdGxlXG59O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBUcmVlTm9kZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtdHJlZS9+L3JjLXRyZWUvbGliL1RyZWVOb2RlLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBDcmVhdGVkIGJ5IHh5IG9uIDE1LzQvMTMuXG4gKi9cblxudmFyIFJvdyA9IHJlcXVpcmUoXCIuL1Jvd1wiKTtcbnZhciBNYXNrID0gcmVxdWlyZShcIi4vTWFza1wiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBkZWVwY29weSA9IHJlcXVpcmUoJ2RlZXBjb3B5Jyk7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIFRib2R5ID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoVGJvZHksIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gVGJvZHkocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRib2R5KTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgICAgICBfdGhpcy5zdGF0ZSA9IHt9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgVGJvZHkucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIG1lLnJvb3RFbCA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKG1lLnJlZnMucm9vdCk7XG4gICAgICAgIG1lLnNjcm9sbEhhbmRsZXIgPSBtZS5vblNjcm9sbC5iaW5kKG1lKTtcbiAgICAgICAgJChtZS5yb290RWwpLm9uKFwic2Nyb2xsXCIsIG1lLnNjcm9sbEhhbmRsZXIpO1xuICAgIH07XG5cbiAgICBUYm9keS5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgbWUucmVzaXplVGltZXIgPSBudWxsO1xuICAgICAgICAkKG1lLnJvb3RFbCkub2ZmKFwic2Nyb2xsXCIsIG1lLnNjcm9sbEhhbmRsZXIpO1xuICAgIH07XG5cbiAgICBUYm9keS5wcm90b3R5cGUucmVuZGVyRW1wdHlEYXRhID0gZnVuY3Rpb24gcmVuZGVyRW1wdHlEYXRhKCkge1xuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLmRhdGEubGVuZ3RoID09IDAgJiYgIXRoaXMucHJvcHMubWFzaykge1xuICAgICAgICAgICAgdmFyIF9zdHlsZSA9IHtcbiAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiB0aGlzLnByb3BzLmhlaWdodCAtIDEwICsgXCJweFwiXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogXCJrdW1hLXV4dGFibGUtYm9keS1lbXB0eXdvcmRcIiwgc3R5bGU6IF9zdHlsZSB9LFxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMucm9vdC5wcm9wcy5lbXB0eVRleHRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgVGJvZHkucHJvdG90eXBlLm9uU2Nyb2xsID0gZnVuY3Rpb24gb25TY3JvbGwoZSkge1xuICAgICAgICAvLyBUT0RPOiByZW1vdmUganF1ZXJ5IGFuaW1hdGlvblxuICAgICAgICAvLyAgICAgICBtZXJnZSBjbGFzc25hbWUgc2Nyb2xsL25vL2ZpeGVkXG5cbiAgICAgICAgdGhpcy5lbCA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpO1xuICAgICAgICB2YXIgJHRhYmxlRWwgPSAkKHRoaXMuZWwpLnBhcmVudHMoXCIua3VtYS11eHRhYmxlXCIpO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5maXhlZENvbHVtbiA9PSAnbm8nKSB7XG4gICAgICAgICAgICAkdGFibGVFbC5maW5kKCcua3VtYS11eHRhYmxlLWhlYWRlci1ubycpLmFuaW1hdGUoe1xuICAgICAgICAgICAgICAgIHNjcm9sbExlZnQ6ICR0YWJsZUVsLmZpbmQoJy5rdW1hLXV4dGFibGUtYm9keS1ubycpLnNjcm9sbExlZnQoKVxuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGFyZ2V0ID0gJChlLnRhcmdldCk7XG4gICAgICAgIGlmICh0YXJnZXQuaGFzQ2xhc3MoJ2t1bWEtdXh0YWJsZS1ib2R5LXNjcm9sbCcpKSB7XG5cbiAgICAgICAgICAgICR0YWJsZUVsLmZpbmQoJy5rdW1hLXV4dGFibGUtYm9keS1maXhlZCcpLmFuaW1hdGUoe1xuICAgICAgICAgICAgICAgIHNjcm9sbFRvcDogJHRhYmxlRWwuZmluZCgnLmt1bWEtdXh0YWJsZS1ib2R5LXNjcm9sbCcpLnNjcm9sbFRvcCgpXG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICR0YWJsZUVsLmZpbmQoJy5rdW1hLXV4dGFibGUtaGVhZGVyLXNjcm9sbCcpLmFuaW1hdGUoe1xuICAgICAgICAgICAgICAgIHNjcm9sbExlZnQ6ICR0YWJsZUVsLmZpbmQoJy5rdW1hLXV4dGFibGUtYm9keS1zY3JvbGwnKS5zY3JvbGxMZWZ0KClcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHRhYmxlRWwuZmluZCgnLmt1bWEtdXh0YWJsZS1ib2R5LXNjcm9sbCcpLmFuaW1hdGUoe1xuICAgICAgICAgICAgICAgIHNjcm9sbFRvcDogJHRhYmxlRWwuZmluZCgnLmt1bWEtdXh0YWJsZS1ib2R5LWZpeGVkJykuc2Nyb2xsVG9wKClcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFRib2R5LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG5cbiAgICAgICAgdmFyIG1lID0gdGhpcyxcbiAgICAgICAgICAgIF9wcm9wcyA9IG1lLnByb3BzLFxuICAgICAgICAgICAgX2NvbHVtbnMgPSBfcHJvcHMuY29sdW1ucyxcbiAgICAgICAgICAgIF9kYXRhID0gX3Byb3BzLmRhdGEubGVuZ3RoID4gMCA/IF9wcm9wcy5kYXRhIDogW10sXG4gICAgICAgICAgICBfc3R5bGUgPSB7fSxcbiAgICAgICAgICAgIF93aWR0aCA9IDAsXG4gICAgICAgICAgICBib2R5V3JhcENsYXNzTmFtZSA9IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoX3Byb3BzLmZpeGVkQ29sdW1uID09ICdmaXhlZCcpIHtcbiAgICAgICAgICAgIF9jb2x1bW5zID0gX3Byb3BzLmNvbHVtbnMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uZml4ZWQgJiYgIWl0ZW0uaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXRlbS53aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS53aWR0aCA9IDEwMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfd2lkdGggPSBpdGVtLndpZHRoICogMSArIF93aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfc3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IF93aWR0aCxcbiAgICAgICAgICAgICAgICBtaW5XaWR0aDogX3dpZHRoXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYm9keVdyYXBDbGFzc05hbWUgPSBcImt1bWEtdXh0YWJsZS1ib2R5LWZpeGVkXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoX3Byb3BzLmZpeGVkQ29sdW1uID09ICdzY3JvbGwnKSB7XG4gICAgICAgICAgICB2YXIgZml4ZWRXaWR0aCA9IDA7XG4gICAgICAgICAgICBfY29sdW1ucyA9IF9wcm9wcy5jb2x1bW5zLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIGlmICghaXRlbS5maXhlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpdGVtLmhpZGRlbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW0ud2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ud2lkdGggPSAxMDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3dpZHRoID0gaXRlbS53aWR0aCAqIDEgKyBfd2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIGNvbnRlbnQtYm94OiBib3JkZXItYm94XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSAyO1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNJRSg4KSkge1xuICAgICAgICAgICAgICAgIGRlbHRhID0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9zdHlsZSA9IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogX3Byb3BzLndpZHRoIC0gX3dpZHRoIC0gZGVsdGEsIC8vY2hhbmdlIDIgdG8gMywgZml4IGllOCBpc3N1ZVxuICAgICAgICAgICAgICAgIG1pbldpZHRoOiBfcHJvcHMud2lkdGggLSBfd2lkdGggLSBkZWx0YVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJvZHlXcmFwQ2xhc3NOYW1lID0gXCJrdW1hLXV4dGFibGUtYm9keS1zY3JvbGxcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJvZHlXcmFwQ2xhc3NOYW1lID0gXCJrdW1hLXV4dGFibGUtYm9keS1ub1wiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBib2R5V3JhcENsYXNzTmFtZSwgcmVmOiBcInJvb3RcIiwgc3R5bGU6IF9zdHlsZSB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICBcInVsXCIsXG4gICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6IHRoaXMucHJvcHMuanN4cHJlZml4Q2xzIH0sXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJFbXB0eURhdGEoKSxcbiAgICAgICAgICAgICAgICBfZGF0YS5tYXAoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZW5kZXJQcm9wcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbnM6IF9jb2x1bW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93SW5kZXg6IGl0ZW0uanN4aWQsIC8vdHJlZSBtb2RlLCByb3dJbmRleCBuZWVkIHRoaW5rIG1vcmUsIHNvIHVzZSBqc3hpZFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93RGF0YTogZGVlcGNvcHkoX2RhdGFbaW5kZXhdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IF9kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdDogX3Byb3BzLnJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRSb3dDbGFzc05hbWU6IF9wcm9wcy5hZGRSb3dDbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dTZWxlY3Rpb246IF9wcm9wcy5yb3dTZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VTZWxlY3RlZDogbWUucHJvcHMuY2hhbmdlU2VsZWN0ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJDb21wOiBfcHJvcHMuc3ViQ29tcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlclN1YkNvbXA6IF9wcm9wcy5yZW5kZXJTdWJDb21wLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uczogX3Byb3BzLmFjdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdyb3cnICsgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlOiBfcHJvcHMubW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlck1vZGVsOiBfcHJvcHMucmVuZGVyTW9kZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXhlZENvbHVtbjogX3Byb3BzLmZpeGVkQ29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWw6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbHM6IF9wcm9wcy5sZXZlbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVEYXRhQ2hhbmdlOiBfcHJvcHMuaGFuZGxlRGF0YUNoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaENlbGxGaWVsZDogX3Byb3BzLmF0dGFjaENlbGxGaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFjaENlbGxGaWVsZDogX3Byb3BzLmRldGFjaENlbGxGaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2libGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm93LCByZW5kZXJQcm9wcyk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChNYXNrLCB7IHZpc2libGU6IF9wcm9wcy5tYXNrIH0pXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHJldHVybiBUYm9keTtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuO1xuXG5UYm9keS5wcm9wVHlwZXMgPSB7fTtcblxuVGJvZHkuZGVmYXVsdFByb3BzID0ge1xuICAgIGpzeHByZWZpeENsczogXCJrdW1hLXV4dGFibGUtYm9keVwiXG59O1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFRib2R5O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS10YWJsZS9idWlsZC9UYm9keS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIENyZWF0ZWQgYnkgeHkgb24gMTUvNC8xMy5cbiAqL1xudmFyIENlbGwgPSByZXF1aXJlKCcuL0NlbGwnKTtcbnZhciBjbGFzc25hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcbnZhciBDb25zdCA9IHJlcXVpcmUoJ3V4Y29yZS1jb25zdCcpO1xudmFyIGRlZXBFcXVhbCA9IHJlcXVpcmUoJ2RlZXAtZXF1YWwnKTtcbnZhciBkZWVwY29weSA9IHJlcXVpcmUoJ2RlZXBjb3B5Jyk7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIFJvdyA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzKFJvdywgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBSb3cocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJvdyk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBleHBhbmRlZDogX3RoaXMucHJvcHMubGV2ZWwgPCBfdGhpcy5wcm9wcy5sZXZlbHMgPyB0cnVlIDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIFJvdy5wcm90b3R5cGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24gc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlKSB7XG4gICAgICAgIC8vIOmcgOimgeiAg+iZkeeahCBwcm9wIOWMheaLrFxuICAgICAgICAvLyBjb2x1bW5zLCByb3dJbmRleChzKSwgcm93RGF0YSwgaW5kZXgocyksIGFkZFJvd0NsYXNzTmFtZShmKSwgcm93U2VsZWN0aW9uLCBzdWJDb21wKGYpLCBhY3Rpb25zXG4gICAgICAgIC8vIG1vZGUocyksIHJlbmRlck1vZGVsKHMpLCBmaXhlZENvbHVtbihzKSwgbGV2ZWxzKHMpXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBzaG91bGRVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgWydyb3dJbmRleCcsICdpbmRleCcsICdtb2RlJywgJ3JlbmRlck1vZGVsJywgJ2ZpeGVkQ29sdW1uJywgJ2xldmVscycsICdhZGRSb3dDbGFzc05hbWUnLCAnc3ViQ29tcCddLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChtZS5wcm9wc1tpdGVtXSAhPT0gbmV4dFByb3BzW2l0ZW1dKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghc2hvdWxkVXBkYXRlKSB7XG4gICAgICAgICAgICBbJ2NvbHVtbnMnLCAncm93RGF0YScsICdyb3dTZWxlY3Rpb24nLCAnYWN0aW9ucyddLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkZWVwRXF1YWwobWUucHJvcHNbaXRlbV0sIG5leHRQcm9wc1tpdGVtXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFzaG91bGRVcGRhdGUpIHtcbiAgICAgICAgICAgIHNob3VsZFVwZGF0ZSA9IG1lLnN0YXRlLmV4cGFuZGVkICE9PSBuZXh0U3RhdGUuZXhwYW5kZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbiAgICB9O1xuXG4gICAgUm93LnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKHJvd0RhdGEpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICB9O1xuXG4gICAgUm93LnByb3RvdHlwZS5oYW5kbGVEb3VibGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZURvdWJsZUNsaWNrKHJvd0RhdGEpIHtcbiAgICAgICAgdmFyIHRhYmxlID0gdGhpcy5wcm9wcy5yb290O1xuICAgICAgICBpZiAodGFibGUucHJvcHMuZG91YmxlQ2xpY2tUb0VkaXQpIHtcbiAgICAgICAgICAgIHRhYmxlLmVkaXRSb3coZGVlcGNvcHkocm93RGF0YSkpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFJvdy5wcm90b3R5cGUuc2hvd1N1YkNvbXBGdW5jID0gZnVuY3Rpb24gc2hvd1N1YkNvbXBGdW5jKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBtZS5wcm9wcy5yb290LnRvZ2dsZVN1YkNvbXAobWUucHJvcHMucm93RGF0YSk7XG4gICAgfTtcblxuICAgIFJvdy5wcm90b3R5cGUucmVuZGVyU3ViQ29tcCA9IGZ1bmN0aW9uIHJlbmRlclN1YkNvbXAoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgaWYgKHByb3BzLnJlbmRlck1vZGVsID09ICd0cmVlJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHByb3BzLnN1YkNvbXApIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMucm93RGF0YS5zaG93U3ViQ29tcCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ViQ29tcCA9IFJlYWN0LmNsb25lRWxlbWVudChwcm9wcy5zdWJDb21wLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXNzZWREYXRhOiB0aGlzLnByb3BzLnJvd0RhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRIYXNDaGVja2JveDogISF0aGlzLnByb3BzLnJvd1NlbGVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEhhc0NoZWNrOiAhIXRoaXMucHJvcHMucm93U2VsZWN0aW9uIC8vLy8vXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdrdW1hLXV4dGFibGUtc3Vicm93JywgcmVmOiAnc3ViUm93JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViQ29tcFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BzLnJlbmRlclN1YkNvbXApIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ViQ29tcCA9IHByb3BzLnJlbmRlclN1YkNvbXAoZGVlcGNvcHkocHJvcHMucm93RGF0YSkpO1xuICAgICAgICAgICAgICAgIGlmIChzdWJDb21wICYmIHByb3BzLnJvd0RhdGEuc2hvd1N1YkNvbXApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAna3VtYS11eHRhYmxlLXN1YnJvdycsIHJlZjogJ3N1YlJvdycgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YkNvbXBcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgUm93LnByb3RvdHlwZS5yZW5kZXJDaGlsZCA9IGZ1bmN0aW9uIHJlbmRlckNoaWxkKCkge1xuXG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICBtZSA9IHRoaXMsXG4gICAgICAgICAgICBjaGlsZHJlbiA9IFtdO1xuXG4gICAgICAgIGlmIChwcm9wcy5yZW5kZXJNb2RlbCAhPT0gJ3RyZWUnKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BzLnJvd0RhdGEuZGF0YXMpIHtcbiAgICAgICAgICAgIHByb3BzLnJvd0RhdGEuZGF0YXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciByZW5kZXJQcm9wcyA9IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWw6IG1lLnByb3BzLmxldmVsICsgMSxcbiAgICAgICAgICAgICAgICAgICAgcm93RGF0YTogbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgcm93SW5kZXg6IG5vZGUuanN4aWQsXG4gICAgICAgICAgICAgICAgICAgIGtleTogbm9kZS5qc3hpZCxcbiAgICAgICAgICAgICAgICAgICAgc2hvd1N1YkNvbXA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlOiBtZS5zdGF0ZS5leHBhbmRlZCAmJiBtZS5wcm9wcy52aXNpYmxlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KFJvdywgcmVuZGVyUHJvcHMpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgcmVuZGVyUHJvcHMgPSB7XG4gICAgICAgICAgICAgICAga2V5OiBcInRyZWVSb3dcIiArIHRoaXMucHJvcHMucm93RGF0YS5qc3hpZCxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwia3VtYS11eHRhYmxlLXRyZWUtcm93XCJcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNoaWxkcmVuID0gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAndWwnLFxuICAgICAgICAgICAgICAgIHJlbmRlclByb3BzLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH07XG5cbiAgICBSb3cucHJvdG90eXBlLnJlbmRlckV4cGVuZEljb24gPSBmdW5jdGlvbiByZW5kZXJFeHBlbmRJY29uKHJvd0luZGV4KSB7XG5cbiAgICAgICAgdmFyIGV4cGFuZENvbGxhcHNlSWNvbiA9IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIF9leHBhbmRJY29uQ2xhc3MgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKHByb3BzLnJlbmRlck1vZGVsICE9PSAndHJlZScpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wcy5yb3dEYXRhLmRhdGFzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RhdGUuZXhwYW5kZWQpIHtcblxuICAgICAgICAgICAgICAgIF9leHBhbmRJY29uQ2xhc3MgPSB7XG4gICAgICAgICAgICAgICAgICAgIFwia3VtYS1pY29uXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIFwia3VtYS1pY29uLXRyZWUtb3Blbi0yXCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBcImt1bWEtaWNvbi10cmVlLWNsb3NlLTJcIjogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgX2V4cGFuZEljb25DbGFzc1tcImt1bWEtdXh0YWJsZS1leHBhbmRJY29uLVwiICsgcHJvcHMuZml4ZWRDb2x1bW4gKyBcIi1cIiArIHJvd0luZGV4XSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBleHBhbmRDb2xsYXBzZUljb24gPSBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAna3VtYS11eHRhYmxlLXRyZWUtaWNvbicsICdkYXRhLXR5cGUnOiBwcm9wcy5maXhlZENvbHVtbiwgJ2RhdGEtaW5kZXgnOiByb3dJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IHRoaXMudG9nZ2xlRXhwYW5kZWQuYmluZCh0aGlzKSB9LFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdpJywgeyBjbGFzc05hbWU6IGNsYXNzbmFtZXMoX2V4cGFuZEljb25DbGFzcykgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIF9leHBhbmRJY29uQ2xhc3MgPSB7XG4gICAgICAgICAgICAgICAgICAgIFwia3VtYS1pY29uXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIFwia3VtYS1pY29uLXRyZWUtb3Blbi0yXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIFwia3VtYS1pY29uLXRyZWUtY2xvc2UtMlwiOiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgX2V4cGFuZEljb25DbGFzc1tcImt1bWEtdXh0YWJsZS1leHBhbmRJY29uLVwiICsgcHJvcHMuZml4ZWRDb2x1bW4gKyBcIi1cIiArIHJvd0luZGV4XSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBleHBhbmRDb2xsYXBzZUljb24gPSBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAna3VtYS11eHRhYmxlLXRyZWUtaWNvbicsICdkYXRhLXR5cGUnOiBwcm9wcy5maXhlZENvbHVtbiwgJ2RhdGEtaW5kZXgnOiByb3dJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IHRoaXMudG9nZ2xlRXhwYW5kZWQuYmluZCh0aGlzKSB9LFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdpJywgeyBjbGFzc05hbWU6IGNsYXNzbmFtZXMoX2V4cGFuZEljb25DbGFzcykgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhwYW5kQ29sbGFwc2VJY29uID0gUmVhY3QuY3JlYXRlRWxlbWVudCgnc3BhbicsIHsgY2xhc3NOYW1lOiAna3VtYS11eHRhYmxlLWVtcHR5aWNvbicgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cGFuZENvbGxhcHNlSWNvbjtcbiAgICB9O1xuXG4gICAgUm93LnByb3RvdHlwZS5yZW5kZXJJbmRlbnQgPSBmdW5jdGlvbiByZW5kZXJJbmRlbnQoKSB7XG4gICAgICAgIHZhciBpbmRlbnRzID0gW107XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnJlbmRlck1vZGVsID09ICd0cmVlJykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnByb3BzLmxldmVsIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlbmRlclByb3BzID0ge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiaW5kZW50XCIsXG4gICAgICAgICAgICAgICAgICAgIGtleTogJ2luZGVudCcgKyBpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpbmRlbnRzLnB1c2goUmVhY3QuY3JlYXRlRWxlbWVudCgnc3BhbicsIHJlbmRlclByb3BzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5kZW50cztcbiAgICB9O1xuXG4gICAgUm93LnByb3RvdHlwZS50b2dnbGVFeHBhbmRlZCA9IGZ1bmN0aW9uIHRvZ2dsZUV4cGFuZGVkKGUpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBleHBhbmRlZDogIXRoaXMuc3RhdGUuZXhwYW5kZWRcbiAgICAgICAgfSk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHZhciB0ID0gJChlLnRhcmdldCk7XG4gICAgICAgIGlmICghdC5oYXNDbGFzcygna3VtYS11eHRhYmxlLXRyZWUtaWNvbicpKSB7XG4gICAgICAgICAgICB0ID0gdC5wYXJlbnRzKCcua3VtYS11eHRhYmxlLXRyZWUtaWNvbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0LmRhdGEoJ3R5cGUnKSA9PSAnZml4ZWQnKSB7XG4gICAgICAgICAgICAkKFwiLmt1bWEtdXh0YWJsZS1leHBhbmRJY29uLXNjcm9sbFwiICsgXCItXCIgKyB0LmRhdGEoJ2luZGV4JykpLnRyaWdnZXIoJ2NsaWNrJyk7XG4gICAgICAgIH0gZWxzZSBpZiAodC5kYXRhKCd0eXBlJykgPT0gJ3Njcm9sbCcpIHtcbiAgICAgICAgICAgICQoXCIua3VtYS11eHRhYmxlLWV4cGFuZEljb24tZml4ZWRcIiArIFwiLVwiICsgdC5kYXRhKCdpbmRleCcpKS50cmlnZ2VyKCdjbGljaycpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFJvdy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICB2YXIgX2NsYXNzbmFtZXM7XG5cbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIF9jb2x1bW5zID0gW10sXG4gICAgICAgICAgICBfc3R5bGUgPSB7fSxcbiAgICAgICAgICAgIF9kYXRhID0gcHJvcHMuZGF0YSxcbiAgICAgICAgICAgIG1lID0gdGhpcyxcbiAgICAgICAgICAgIG90aGVyQ2xzID0gcHJvcHMuYWRkUm93Q2xhc3NOYW1lKF9kYXRhW3Byb3BzLnJvd0luZGV4XSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLnByb3BzLnZpc2libGUpIHtcbiAgICAgICAgICAgIF9zdHlsZSA9IHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiAnbm9uZSdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBwcm9wcy5jb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbiwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChcImdyb3VwXCIgaW4gY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgX2NvbHVtbnMgPSBfY29sdW1ucy5jb25jYXQoY29sdW1uLmNvbHVtbnMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfY29sdW1ucy5wdXNoKGNvbHVtbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBmaXJzdFZpc2FibGVDb2x1bW4gPSAwO1xuXG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2xpJyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBjbGFzc25hbWVzKChfY2xhc3NuYW1lcyA9IHt9LCBfY2xhc3NuYW1lc1t0aGlzLnByb3BzLnByZWZpeENsc10gPSB0cnVlLCBfY2xhc3NuYW1lc1tvdGhlckNsc10gPSAhIW90aGVyQ2xzLCBfY2xhc3NuYW1lc1snZXZlbiddID0gcHJvcHMucm93SW5kZXggJSAyID09IDEgPyB0cnVlIDogZmFsc2UsIF9jbGFzc25hbWVzKSksIHN0eWxlOiBfc3R5bGUsXG4gICAgICAgICAgICAgICAgb25DbGljazogdGhpcy5oYW5kbGVDbGljay5iaW5kKHRoaXMsIHByb3BzLnJvd0RhdGEpLFxuICAgICAgICAgICAgICAgIG9uRG91YmxlQ2xpY2s6IHRoaXMuaGFuZGxlRG91YmxlQ2xpY2suYmluZCh0aGlzLCBwcm9wcy5yb3dEYXRhKSB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogdGhpcy5wcm9wcy5wcmVmaXhDbHMgKyAnLWNlbGxzJyB9LFxuICAgICAgICAgICAgICAgIF9jb2x1bW5zLm1hcChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uaGlkZGVuKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0VmlzYWJsZUNvbHVtbisrO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVuZGVyUHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICByb290OiBwcm9wcy5yb290LFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ246IGl0ZW0uYWxpZ24sXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dEYXRhOiBwcm9wcy5yb3dEYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93SW5kZXg6IHByb3BzLnJvd0luZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHByb3BzLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbEluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc1N1YkNvbXA6IHByb3BzLnN1YkNvbXAgPyB0cnVlIDogcHJvcHMucmVuZGVyU3ViQ29tcCA/IHByb3BzLnJlbmRlclN1YkNvbXAoZGVlcGNvcHkocHJvcHMucm93RGF0YSkpIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBfZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVNlbGVjdGVkOiBtZS5wcm9wcy5jaGFuZ2VTZWxlY3RlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dTdWJDb21wQ2FsbGJhY2s6IG1lLnNob3dTdWJDb21wRnVuYy5iaW5kKG1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd1NlbGVjdGlvbjogcHJvcHMucm93U2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uczogcHJvcHMuYWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6IHByb3BzLm1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVEYXRhQ2hhbmdlOiBwcm9wcy5oYW5kbGVEYXRhQ2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNoQ2VsbEZpZWxkOiBwcm9wcy5hdHRhY2hDZWxsRmllbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhY2hDZWxsRmllbGQ6IHByb3BzLmRldGFjaENlbGxGaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogXCJjZWxsXCIgKyBpbmRleFxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdFZpc2FibGVDb2x1bW4gPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2VsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5yZW5kZXJJbmRlbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5yZW5kZXJFeHBlbmRJY29uKHByb3BzLnJvd0luZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL2lmIGhhdmUgdmVydGljYWwgZGF0YSBzdHJ1Y3R1cmUsIGhvdyB0byBwcm9jZXNzIGl0XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KENlbGwsIHJlbmRlclByb3BzKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG1lLnJlbmRlckNoaWxkKCksXG4gICAgICAgICAgICB0aGlzLnJlbmRlclN1YkNvbXAoKVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gUm93O1xufShSZWFjdC5Db21wb25lbnQpO1xuXG47XG5cblJvdy5wcm9wVHlwZXMgPSB7XG4gICAgcHJlZml4Q2xzOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHNob3dTdWJDb21wOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbFxufTtcblxuUm93LmRlZmF1bHRQcm9wcyA9IHtcbiAgICBwcmVmaXhDbHM6IFwia3VtYS11eHRhYmxlLXJvd1wiLFxuICAgIHNob3dTdWJDb21wOiBmYWxzZVxufTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBSb3c7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLXRhYmxlL2J1aWxkL1Jvdy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBDcmVhdGVkIGJ5IHh5IG9uIDE1LzQvMTMuXG4gKi9cblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xudmFyIENvbnN0ID0gcmVxdWlyZSgndXhjb3JlLWNvbnN0Jyk7XG52YXIgRHJvcGRvd24gPSByZXF1aXJlKCd1eGNvcmUtZHJvcGRvd24nKTtcbnZhciBNZW51ID0gcmVxdWlyZSgndXhjb3JlLW1lbnUnKTtcblxudmFyIENoZWNrQm94ID0gcmVxdWlyZSgnLi9DaGVja0JveCcpO1xudmFyIFJhZGlvID0gcmVxdWlyZSgnLi9SYWRpbycpO1xudmFyIFRleHRGaWVsZCA9IHJlcXVpcmUoJy4vVGV4dEZpZWxkJyk7XG52YXIgU2VsZWN0RmllbGQgPSByZXF1aXJlKFwiLi9TZWxlY3RGaWVsZFwiKTtcbnZhciBSYWRpb0ZpZWxkID0gcmVxdWlyZShcIi4vUmFkaW9GaWVsZFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi9VdGlsJyk7XG52YXIgY2xhc3NuYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG52YXIgZGVlcGNvcHkgPSByZXF1aXJlKCdkZWVwY29weScpO1xudmFyIGZpZWxkc01hcCA9IHtcbiAgICBcInNlbGVjdFwiOiBTZWxlY3RGaWVsZCxcbiAgICBcInRleHRcIjogVGV4dEZpZWxkLFxuICAgIFwicmFkaW9cIjogUmFkaW9GaWVsZFxufTtcblxudmFyIENlbGwgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhDZWxsLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIENlbGwocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENlbGwpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgJ2ZvbGQnOiAxLCAvLyAxLSBmb2xkICAwLXVuZm9sZFxuICAgICAgICAgICAgJ2NoZWNrZWQnOiAhIV90aGlzLmdldENlbGxEYXRhKClcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIENlbGwucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBpZiAobWUucHJvcHMuY29sdW1uLnR5cGUgPT0gXCJjaGVja2JveFwiIHx8IG1lLnByb3BzLmNvbHVtbi50eXBlID09IFwiY2hlY2tib3hTZWxlY3RvclwiIHx8IG1lLnByb3BzLmNvbHVtbi50eXBlID09IFwicmFkaW9TZWxlY3RvclwiKSB7XG4gICAgICAgICAgICBtZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgY2hlY2tlZDogISFtZS5nZXRDZWxsRGF0YShuZXh0UHJvcHMpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBDZWxsLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBpZiAobWUucHJvcHMuY29sdW1uLnR5cGUgPT0gXCJjaGVja2JveFwiIHx8IG1lLnByb3BzLmNvbHVtbi50eXBlID09IFwiY2hlY2tib3hTZWxlY3RvclwiIHx8IG1lLnByb3BzLmNvbHVtbi50eXBlID09IFwicmFkaW9TZWxlY3RvclwiKSB7XG4gICAgICAgICAgICBtZS5wcm9wcy5jaGFuZ2VTZWxlY3RlZChtZS5zdGF0ZS5jaGVja2VkLCBtZS5wcm9wcy5yb3dJbmRleCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2VsbC5wcm90b3R5cGUuaGFuZGxlQ2hlY2tDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVDaGVja0NoYW5nZShlKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXMsXG4gICAgICAgICAgICBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgICAgdiA9IF9wcm9wcy5yb3dEYXRhO1xuICAgICAgICBtZS5wcm9wcy5jaGFuZ2VTZWxlY3RlZChlLnRhcmdldC5jaGVja2VkLCBfcHJvcHMucm93SW5kZXgsIGZhbHNlKTtcbiAgICB9O1xuXG4gICAgQ2VsbC5wcm90b3R5cGUuaGFuZGxlRHJvcGRvd25WaXNpYmxlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlRHJvcGRvd25WaXNpYmxlQ2hhbmdlKHZpc2libGUpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgbWUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZHJvcGRvd25WaXNpYmxlOiB2aXNpYmxlXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBDZWxsLnByb3RvdHlwZS5zaG93U3ViQ29tcCA9IGZ1bmN0aW9uIHNob3dTdWJDb21wKCkge1xuICAgICAgICB0aGlzLnByb3BzLnNob3dTdWJDb21wQ2FsbGJhY2suYXBwbHkoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGFjdGlvbnMge0FycmF5IG9yIE9iamVjdH1cbiAgICAgKi9cblxuXG4gICAgQ2VsbC5wcm90b3R5cGUuZ2V0QWN0aW9uSXRlbXMgPSBmdW5jdGlvbiBnZXRBY3Rpb25JdGVtcyhhY3Rpb25zKSB7XG4gICAgICAgIGlmICgodHlwZW9mIGFjdGlvbnMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGFjdGlvbnMpKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlRhYmxlOiBBY3Rpb25zIHNob3VsZCBiZSBhbiBvYmplY3Qgb3IgYXJyYXlcIik7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICAgICAgbWUuaXRlbXMgPSBbXTtcbiAgICAgICAgICAgIGlmIChhY3Rpb25zIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBtZS5pdGVtcyA9IGFjdGlvbnM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gYWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9ucy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUuaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGFjdGlvbnNbaV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWUuaXRlbXM7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2VsbC5wcm90b3R5cGUuZ2V0RWRpdERhdGEgPSBmdW5jdGlvbiBnZXRFZGl0RGF0YSgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIGNvbHVtbiA9IG1lLnByb3BzLmNvbHVtbjtcbiAgICAgICAgdmFyIGVkaXRLZXkgPSBjb2x1bW4uZWRpdEtleSB8fCBjb2x1bW4uZGF0YUtleTtcbiAgICAgICAgcmV0dXJuIG1lLnByb3BzLnJvd0RhdGFbZWRpdEtleV07XG4gICAgfTtcblxuICAgIENlbGwucHJvdG90eXBlLmdldENlbGxEYXRhID0gZnVuY3Rpb24gZ2V0Q2VsbERhdGEobmV4dFByb3BzKSB7XG5cbiAgICAgICAgdmFyIHByb3BzID0gbmV4dFByb3BzIHx8IHRoaXMucHJvcHMsXG4gICAgICAgICAgICBfY29sdW1uID0gcHJvcHMuY29sdW1uLFxuICAgICAgICAgICAgY2VsbERhdGEgPSBwcm9wcy5yb3dEYXRhW19jb2x1bW4uZGF0YUtleV07XG5cbiAgICAgICAgcmV0dXJuIGNlbGxEYXRhO1xuICAgIH07XG5cbiAgICBDZWxsLnByb3RvdHlwZS5oYW5kbGVBY3Rpb25DbGljayA9IGZ1bmN0aW9uIGhhbmRsZUFjdGlvbkNsaWNrKGNiLCBlKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIG1lLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGRyb3Bkb3duVmlzaWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIGNiICYmIGNiKCk7XG4gICAgfTtcblxuICAgIENlbGwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcblxuICAgICAgICB2YXIgbWUgPSB0aGlzLFxuICAgICAgICAgICAgcHJvcHMgPSBtZS5wcm9wcyxcbiAgICAgICAgICAgIF9jb2x1bW4gPSBwcm9wcy5jb2x1bW4sXG4gICAgICAgICAgICBfd2lkdGggPSBfY29sdW1uLndpZHRoLFxuICAgICAgICAgICAgX21vZGUgPSBwcm9wcy5yb3dEYXRhWydfX21vZGVfXyddLFxuICAgICAgICAgICAgX3N0eWxlID0ge1xuICAgICAgICAgICAgd2lkdGg6IF93aWR0aCA/IF93aWR0aCA6IDEwMCxcbiAgICAgICAgICAgIHRleHRBbGlnbjogcHJvcHMuYWxpZ24gPyBwcm9wcy5hbGlnbiA6IFwibGVmdFwiXG4gICAgICAgIH0sXG4gICAgICAgICAgICBfdiA9IGRlZXBjb3B5KHByb3BzLnJvd0RhdGEpLFxuICAgICAgICAgICAgcmVuZGVyUHJvcHMgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKF9jb2x1bW4udHlwZSA9PSAnYWN0aW9uJykge1xuICAgICAgICAgICAgX3YgPSBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnYWN0aW9uLWNvbnRhaW5lcicgfSxcbiAgICAgICAgICAgICAgICBtZS5yZW5kZXJBY3Rpb25JdGVtcyhfY29sdW1uLCBfdiwgX21vZGUpXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKF9jb2x1bW4udHlwZSA9PSAnY2hlY2tib3gnIHx8IF9jb2x1bW4udHlwZSA9PSAnY2hlY2tib3hTZWxlY3RvcicpIHtcblxuICAgICAgICAgICAgX3N0eWxlLnBhZGRpbmdSaWdodCA9IDQ7XG4gICAgICAgICAgICBfc3R5bGUucGFkZGluZ0xlZnQgPSAxMjtcblxuICAgICAgICAgICAgdmFyIGNoZWNrZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAobWUuc3RhdGUuY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgIGNoZWNrZWQgPSAnY2hlY2tlZCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoZWNrZWQgPSBcIlwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGlzYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCdkaXNhYmxlJyBpbiBfY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgZGlzYWJsZSA9IF9jb2x1bW4uZGlzYWJsZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJ2lzRGlzYWJsZScgaW4gX2NvbHVtbikge1xuICAgICAgICAgICAgICAgIGRpc2FibGUgPSAhIV9jb2x1bW4uaXNEaXNhYmxlKHByb3BzLnJvd0RhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3YgPSBSZWFjdC5jcmVhdGVFbGVtZW50KENoZWNrQm94LCB7IGRpc2FibGU6IGRpc2FibGUsIG1vZGU6IHByb3BzLm1vZGUsIGFsaWduOiBwcm9wcy5hbGlnbiwganN4Y2hlY2tlZDogY2hlY2tlZCwgcmVmOiAnY2hlY2tib3gnLCBvbmNoYW5nZTogbWUuaGFuZGxlQ2hlY2tDaGFuZ2UuYmluZChtZSkgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoX2NvbHVtbi50eXBlID09ICdyYWRpb1NlbGVjdG9yJykge1xuICAgICAgICAgICAgX3N0eWxlLnBhZGRpbmdSaWdodCA9IDQ7XG4gICAgICAgICAgICBfc3R5bGUucGFkZGluZ0xlZnQgPSAxMjtcblxuICAgICAgICAgICAgdmFyIGNoZWNrZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAobWUuc3RhdGUuY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgIGNoZWNrZWQgPSAnY2hlY2tlZCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoZWNrZWQgPSBcIlwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGlzYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCdkaXNhYmxlJyBpbiBfY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgZGlzYWJsZSA9IF9jb2x1bW4uZGlzYWJsZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJ2lzRGlzYWJsZScgaW4gX2NvbHVtbikge1xuICAgICAgICAgICAgICAgIGRpc2FibGUgPSAhIV9jb2x1bW4uaXNEaXNhYmxlKHByb3BzLnJvd0RhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3YgPSBSZWFjdC5jcmVhdGVFbGVtZW50KFJhZGlvLCB7IGRpc2FibGU6IGRpc2FibGUsIG1vZGU6IHByb3BzLm1vZGUsIGFsaWduOiBwcm9wcy5hbGlnbiwganN4Y2hlY2tlZDogY2hlY2tlZCwgb25jaGFuZ2U6IG1lLmhhbmRsZUNoZWNrQ2hhbmdlLmJpbmQobWUpIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKF9jb2x1bW4udHlwZSA9PSAndHJlZUljb24nKSB7XG4gICAgICAgICAgICBfdiA9IG1lLnJlbmRlclRyZWVJY29uKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbmxpbmUgZWRpdCBtb2RlXG4gICAgICAgIGVsc2UgaWYgKChfY29sdW1uLnR5cGUgPT0gJ2N1c3RvbScgfHwgX2NvbHVtbi50eXBlIGluIGZpZWxkc01hcCkgJiYgX21vZGUgPT0gQ29uc3QuTU9ERS5FRElUICYmICghKCdjYW5FZGl0JyBpbiBfY29sdW1uKSB8fCBfY29sdW1uLmNhbkVkaXQocHJvcHMucm93RGF0YSkpKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyUHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtZS5nZXRFZGl0RGF0YSgpLFxuICAgICAgICAgICAgICAgICAgICByb3dEYXRhOiBwcm9wcy5yb3dEYXRhLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogcHJvcHMuaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbjogX2NvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRGF0YUNoYW5nZTogcHJvcHMuaGFuZGxlRGF0YUNoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgYXR0YWNoQ2VsbEZpZWxkOiBwcm9wcy5hdHRhY2hDZWxsRmllbGQsXG4gICAgICAgICAgICAgICAgICAgIGRldGFjaENlbGxGaWVsZDogcHJvcHMuZGV0YWNoQ2VsbEZpZWxkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgRmllbGQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoX2NvbHVtbi50eXBlID09ICdjdXN0b20nKSB7XG4gICAgICAgICAgICAgICAgICAgIEZpZWxkID0gcHJvcHMuY29sdW1uLmN1c3RvbUZpZWxkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIEZpZWxkID0gZmllbGRzTWFwW19jb2x1bW4udHlwZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF92ID0gUmVhY3QuY3JlYXRlRWxlbWVudChGaWVsZCwgcmVuZGVyUHJvcHMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChfY29sdW1uLnR5cGUgPT0gJ21vbmV5JyB8fCBfY29sdW1uLnR5cGUgPT0gXCJjYXJkXCIgfHwgX2NvbHVtbi50eXBlID09IFwiY25tb2JpbGVcIikge1xuICAgICAgICAgICAgICAgIF92ID0gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgICAgIHsgdGl0bGU6IG1lLmdldENlbGxEYXRhKCkgfSxcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5mb3JtYXRWYWx1ZShtZS5nZXRDZWxsRGF0YSgpLCBfY29sdW1uLnR5cGUsIF9jb2x1bW4uZGVsaW1pdGVyKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF9jb2x1bW4ucmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgX3YgPSBfY29sdW1uLnJlbmRlci5hcHBseShudWxsLCBbbWUuZ2V0Q2VsbERhdGEoKSwgX3ZdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX3YgPSBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICAgICAgeyB0aXRsZTogbWUuZ2V0Q2VsbERhdGEoKSB9LFxuICAgICAgICAgICAgICAgICAgICBtZS5nZXRDZWxsRGF0YSgpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB2YXIgY2hpbGQgPSBtZS5wcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcm9wcy5qc3hwcmVmaXhDbHMsIHN0eWxlOiBfc3R5bGUgfSxcbiAgICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgICAgX3ZcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbHVtbiBjdXJyZW50IGNvbHVtbiBjb25maWdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcm93RGF0YSBjdXJyZW50IHJvdyBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1vZGUgY3VycmVudCByb3cgbW9kZTogZWRpdCBvciB2aWV3LCBzYW1lIGFzIHJvd0RhdGFbJ19fbW9kZV9fJ10gXG4gICAgICovXG5cbiAgICBDZWxsLnByb3RvdHlwZS5yZW5kZXJBY3Rpb25JdGVtcyA9IGZ1bmN0aW9uIHJlbmRlckFjdGlvbkl0ZW1zKGNvbHVtbiwgcm93RGF0YSwgbW9kZSkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgYWN0aW9ucyA9IG1lLmdldEFjdGlvbkl0ZW1zKGNvbHVtbi5hY3Rpb25zKS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiAhKCdtb2RlJyBpbiBpdGVtKSB8fCBpdGVtLm1vZGUgPT0gbW9kZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhY3Rpb25zLmxlbmd0aCA8PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9ucy5tYXAoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgICAgICAgICAgeyBocmVmOiAnamF2YXNjcmlwdDp2b2lkKDApOycsIGtleTogaW5kZXgsIGNsYXNzTmFtZTogJ2FjdGlvbicsIG9uQ2xpY2s6IG1lLmhhbmRsZUFjdGlvbkNsaWNrLmJpbmQobWUsIGl0ZW0uY2FsbGJhY2suYmluZChtZSwgcm93RGF0YSwgbWUucHJvcHMucm9vdCkpIH0sXG4gICAgICAgICAgICAgICAgICAgICEhaXRlbS5yZW5kZXIgPyBpdGVtLnJlbmRlcihpdGVtLnRpdGxlLCBtZS5wcm9wcy5yb3dEYXRhKSA6IGl0ZW0udGl0bGVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgYXJyID0gW107XG4gICAgICAgICAgICBhcnIucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgICAgICB7IGhyZWY6ICdqYXZhc2NyaXB0OnZvaWQoMCk7JywgY2xhc3NOYW1lOiAnYWN0aW9uJywga2V5OiAnYWN0aW9uJywgb25DbGljazogbWUuaGFuZGxlQWN0aW9uQ2xpY2suYmluZChtZSwgYWN0aW9uc1swXS5jYWxsYmFjay5iaW5kKG1lLCByb3dEYXRhLCBtZS5wcm9wcy5yb290KSkgfSxcbiAgICAgICAgICAgICAgICAhIWFjdGlvbnNbMF0ucmVuZGVyID8gYWN0aW9uc1swXS5yZW5kZXIoYWN0aW9uc1swXS50aXRsZSwgbWUucHJvcHMucm93RGF0YSkgOiBhY3Rpb25zWzBdLnRpdGxlXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICAgIHZhciBtZW51ID0gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICBNZW51LFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgYWN0aW9ucy5zbGljZSgxKS5tYXAoZnVuY3Rpb24gKGFjdGlvbiwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICBNZW51Lkl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGtleTogaW5kZXggfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgaHJlZjogJ2phdmFzY3JpcHQ6dm9pZCgwKTsnLCBjbGFzc05hbWU6ICdhY3Rpb24nLCBrZXk6ICdhY3Rpb24nLCBvbkNsaWNrOiBtZS5oYW5kbGVBY3Rpb25DbGljay5iaW5kKG1lLCBhY3Rpb24uY2FsbGJhY2suYmluZChtZSwgcm93RGF0YSwgbWUucHJvcHMucm9vdCkpIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgISFhY3Rpb24ucmVuZGVyID8gYWN0aW9uLnJlbmRlcihhY3Rpb24udGl0bGUsIG1lLnByb3BzLnJvd0RhdGEpIDogYWN0aW9uLnRpdGxlXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBhcnIucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KCdpJywgeyBjbGFzc05hbWU6ICdrdW1hLWljb24ga3VtYS1pY29uLXRyaWFuZ2xlLWRvd24nLCBrZXk6ICdpY29uJyB9KSk7XG4gICAgICAgICAgICB2YXIgZHJvcGRvd25PcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGtleTogJ2ljb24nLFxuICAgICAgICAgICAgICAgIG92ZXJsYXk6IG1lbnUsXG4gICAgICAgICAgICAgICAgdHJpZ2dlcjogWydjbGljayddLFxuICAgICAgICAgICAgICAgIHZpc2libGU6IG1lLnN0YXRlLmRyb3Bkb3duVmlzaWJsZSxcbiAgICAgICAgICAgICAgICBvblZpc2libGVDaGFuZ2U6IG1lLmhhbmRsZURyb3Bkb3duVmlzaWJsZUNoYW5nZS5iaW5kKG1lKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgIERyb3Bkb3duLFxuICAgICAgICAgICAgICAgIGRyb3Bkb3duT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGFyclxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2VsbC5wcm90b3R5cGUucmVuZGVyVHJlZUljb24gPSBmdW5jdGlvbiByZW5kZXJUcmVlSWNvbigpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuY2VsbEluZGV4ID09IDAgJiYgdGhpcy5wcm9wcy5oYXNTdWJDb21wKSB7XG4gICAgICAgICAgICB2YXIgb3BlbiA9IHRoaXMucHJvcHMucm93RGF0YS5zaG93U3ViQ29tcDtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2t1bWEtdXh0YWJsZS10cmVlLWljb24nLCBvbkNsaWNrOiB0aGlzLnNob3dTdWJDb21wLmJpbmQodGhpcykgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdpJywgeyBjbGFzc05hbWU6IGNsYXNzbmFtZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJrdW1hLWljb25cIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwia3VtYS1pY29uLXRyZWUtb3BlblwiOiBvcGVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJrdW1hLWljb24tdHJlZS1jbG9zZVwiOiAhb3BlblxuICAgICAgICAgICAgICAgICAgICB9KSB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gQ2VsbDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuO1xuXG5DZWxsLnByb3BUeXBlcyA9IHt9O1xuXG5DZWxsLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBqc3hwcmVmaXhDbHM6IFwia3VtYS11eHRhYmxlLWNlbGxcIlxufTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBDZWxsO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS10YWJsZS9idWlsZC9DZWxsL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogQSByYWRpbyBmaWVsZFxuICovXG5cbnZhciBDb25zdCA9IHJlcXVpcmUoJ3V4Y29yZS1jb25zdCcpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgUmFkaW8gPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhSYWRpbywgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBSYWRpbyhwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmFkaW8pO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgY2hlY2tlZDogISFfdGhpcy5wcm9wcy5jaGVja2VkXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBSYWRpby5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAgIHRoaXMuc3RhdGUuY2hlY2tlZCA9ICEhbmV4dFByb3BzLmpzeGNoZWNrZWQ7XG4gICAgfTtcblxuICAgIFJhZGlvLnByb3RvdHlwZS5oYW5kbGVDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVDaGFuZ2UoZSkge1xuICAgICAgICBpZiAoZS50YXJnZXQuY2hlY2tlZCAhPSB0aGlzLnN0YXRlLmNoZWNrZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuY2hlY2tlZCA9ICF0aGlzLnN0YXRlLmNoZWNrZWQ7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uY2hhbmdlLmFwcGx5KG51bGwsIFtlXSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgUmFkaW8ucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZnMucmFkaW8uY2hlY2tlZDtcbiAgICB9O1xuXG4gICAgUmFkaW8ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcblxuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIGlmIChwcm9wcy5tb2RlICE9PSBDb25zdC5NT0RFLlZJRVcpIHtcbiAgICAgICAgICAgIHZhciByZW5kZXJQcm9wcyA9IHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwia3VtYS1jaGVja2JveFwiLFxuICAgICAgICAgICAgICAgIGNoZWNrZWQ6IHRoaXMucHJvcHMuanN4Y2hlY2tlZCxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogdGhpcy5oYW5kbGVDaGFuZ2UuYmluZCh0aGlzKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghIXByb3BzLmRpc2FibGUpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJQcm9wcy5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAnbGFiZWwnLFxuICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAna3VtYS11eHRhYmxlLXJvdy1zZWxlY3RvcicgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdpbnB1dCcsIF9leHRlbmRzKHsgdHlwZTogJ3JhZGlvJywgcmVmOiAncmFkaW8nIH0sIHJlbmRlclByb3BzKSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgncycsIG51bGwpXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICB2YXIgcmVuZGVyUHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImt1bWEtY2hlY2tib3hcIixcbiAgICAgICAgICAgICAgICBjaGVja2VkOiB0aGlzLnByb3BzLmpzeGNoZWNrZWQsXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAnbGFiZWwnLFxuICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAna3VtYS11eHRhYmxlLXJvdy1zZWxlY3RvcicgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdpbnB1dCcsIF9leHRlbmRzKHsgdHlwZTogJ3JhZGlvJywgcmVmOiAncmFkaW8nIH0sIHJlbmRlclByb3BzKSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgncycsIG51bGwpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBSYWRpbztcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuO1xuXG5SYWRpby5wcm9wVHlwZXMgPSB7fTtcblxuUmFkaW8uZGVmYXVsdFByb3BzID0ge307XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUmFkaW87XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLXRhYmxlL2J1aWxkL0NlbGwvUmFkaW8uanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIEEgZWRpdGFibGUgcGxhaW4gdGV4dCBmaWVsZFxuICovXG5cbnZhciBDZWxsRmllbGQgPSByZXF1aXJlKCcuL0NlbGxGaWVsZCcpO1xudmFyIGNsYXNzbmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgVGV4dEZpZWxkID0gZnVuY3Rpb24gKF9DZWxsRmllbGQpIHtcbiAgICBfaW5oZXJpdHMoVGV4dEZpZWxkLCBfQ2VsbEZpZWxkKTtcblxuICAgIGZ1bmN0aW9uIFRleHRGaWVsZChwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dEZpZWxkKTtcblxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NlbGxGaWVsZC5jYWxsKHRoaXMsIHByb3BzKSk7XG4gICAgfVxuXG4gICAgVGV4dEZpZWxkLnByb3RvdHlwZS5yZW5kZXJDb250ZW50ID0gZnVuY3Rpb24gcmVuZGVyQ29udGVudCgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIGRhdGFLZXkgPSBtZS5wcm9wcy5jb2x1bW4uZGF0YUtleTtcbiAgICAgICAgdmFyIGZpZWxkUHJvcHMgPSB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzbmFtZXMoe1xuICAgICAgICAgICAgICAgIFwia3VtYS1pbnB1dFwiOiB0cnVlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShlKSB7XG4gICAgICAgICAgICAgICAgbWUuaGFuZGxlRGF0YUNoYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgIGpzeGlkOiBtZS5wcm9wcy5yb3dEYXRhWydqc3hpZCddLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IG1lLnByb3BzLmNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGUudGFyZ2V0LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBlLnRhcmdldC52YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbHVlOiBtZS5wcm9wcy52YWx1ZVxuICAgICAgICB9O1xuICAgICAgICBpZiAobWUucHJvcHMuY29sdW1uLmNvbmZpZykge1xuICAgICAgICAgICAgdmFyIF9tZSRwcm9wcyRjb2x1bW4kY29uZiA9IG1lLnByb3BzLmNvbHVtbi5jb25maWc7XG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gX21lJHByb3BzJGNvbHVtbiRjb25mLmNsYXNzTmFtZTtcbiAgICAgICAgICAgIHZhciBvbkNoYW5nZSA9IF9tZSRwcm9wcyRjb2x1bW4kY29uZi5vbkNoYW5nZTtcblxuICAgICAgICAgICAgdmFyIGN1c3RvbVByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9tZSRwcm9wcyRjb2x1bW4kY29uZiwgWydjbGFzc05hbWUnLCAnb25DaGFuZ2UnXSk7XG5cbiAgICAgICAgICAgIGFzc2lnbihmaWVsZFByb3BzLCBjdXN0b21Qcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JywgZmllbGRQcm9wcyk7XG4gICAgfTtcblxuICAgIHJldHVybiBUZXh0RmllbGQ7XG59KENlbGxGaWVsZCk7XG5cbjtcblxuVGV4dEZpZWxkLnByb3BUeXBlcyA9IGFzc2lnbih7fSwgQ2VsbEZpZWxkLnByb3BUeXBlcyk7XG5cblRleHRGaWVsZC5kZWZhdWx0UHJvcHMgPSBhc3NpZ24oe30sIENlbGxGaWVsZC5kZWZhdWx0UHJvcHMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRleHRGaWVsZDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLXRhYmxlL2J1aWxkL0NlbGwvVGV4dEZpZWxkLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgY2xhc3NuYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcbnZhciBhc3NnaW4gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIENlbGxGaWVsZCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzKENlbGxGaWVsZCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBDZWxsRmllbGQocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENlbGxGaWVsZCk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBwYXNzOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIENlbGxGaWVsZC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgbWUucHJvcHMuYXR0YWNoQ2VsbEZpZWxkKG1lLnZhbGlkYXRlLmJpbmQodGhpcyksIG1lLmdldE5hbWUoKSk7XG4gICAgfTtcblxuICAgIENlbGxGaWVsZC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgbWUucHJvcHMuZGV0YWNoQ2VsbEZpZWxkKG1lLmdldE5hbWUoKSk7XG4gICAgfTtcblxuICAgIENlbGxGaWVsZC5wcm90b3R5cGUuaGFuZGxlRGF0YUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZURhdGFDaGFuZ2Uob2JqKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBqc3hpZCA9IG9iai5qc3hpZDtcbiAgICAgICAgdmFyIGNvbHVtbiA9IG9iai5jb2x1bW47XG4gICAgICAgIHZhciB2YWx1ZSA9IG9iai52YWx1ZTtcbiAgICAgICAgdmFyIHRleHQgPSBvYmoudGV4dDtcblxuICAgICAgICBtZS52YWxpZGF0ZSh2YWx1ZSwgZnVuY3Rpb24gKHBhc3MpIHtcbiAgICAgICAgICAgIG1lLnByb3BzLmhhbmRsZURhdGFDaGFuZ2UoYXNzZ2luKHt9LCBvYmosIHtcbiAgICAgICAgICAgICAgICBwYXNzOiBwYXNzXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBtZS5wcm9wcy5oYW5kbGVEYXRhQ2hhbmdlKGFzc2dpbih7fSwgb2JqLCB7XG4gICAgICAgIC8vICAgICBwYXNzOiBtZS5zdGF0ZS5wYXNzXG4gICAgICAgIC8vIH0pKTtcbiAgICB9O1xuXG4gICAgQ2VsbEZpZWxkLnByb3RvdHlwZS5nZXROYW1lID0gZnVuY3Rpb24gZ2V0TmFtZSgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG1lLnByb3BzLmNvbHVtbi5kYXRhS2V5ICsgXCIuXCIgKyBtZS5wcm9wcy5pbmRleDtcbiAgICB9O1xuXG4gICAgQ2VsbEZpZWxkLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKHZhbHVlLCBjYikge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlIHx8IG1lLnByb3BzLnZhbHVlO1xuICAgICAgICB2YXIgcm93RGF0YSA9IG1lLnByb3BzLnJvd0RhdGE7XG4gICAgICAgIHZhciBydWxlcyA9IG1lLnByb3BzLmNvbHVtbi5ydWxlcztcblxuICAgICAgICB2YXIgcGFzcyA9IHRydWU7XG4gICAgICAgIHZhciBlcnJNc2cgPSBcIlwiO1xuICAgICAgICBpZiAoKHR5cGVvZiBydWxlcyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocnVsZXMpKSA9PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHJ1bGVzKSkge1xuICAgICAgICAgICAgcGFzcyA9ICEhcnVsZXMudmFsaWRhdG9yKHZhbHVlLCByb3dEYXRhKTtcbiAgICAgICAgICAgIGVyck1zZyA9IHJ1bGVzLmVyck1zZztcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJ1bGVzKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHBhc3MgPSBydWxlc1tpXS52YWxpZGF0b3IodmFsdWUsIHJvd0RhdGEpO1xuICAgICAgICAgICAgICAgIGlmICghcGFzcykge1xuICAgICAgICAgICAgICAgICAgICBlcnJNc2cgPSBydWxlc1tpXS5lcnJNc2c7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAhIWNiICYmIGNiKHBhc3MpO1xuICAgICAgICBtZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBwYXNzOiBwYXNzLFxuICAgICAgICAgICAgZXJyTXNnOiBlcnJNc2dcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXNzO1xuICAgIH07XG5cbiAgICBDZWxsRmllbGQucHJvdG90eXBlLnJlbmRlckNvbnRlbnQgPSBmdW5jdGlvbiByZW5kZXJDb250ZW50KCkge307XG5cbiAgICBDZWxsRmllbGQucHJvdG90eXBlLmFkZFNwZWNpZmljQ2xhc3MgPSBmdW5jdGlvbiBhZGRTcGVjaWZpY0NsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5wcmVmaXhDbHM7XG4gICAgfTtcblxuICAgIENlbGxGaWVsZC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICB2YXIgX2NsYXNzbmFtZXM7XG5cbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIHNwZWNpZmljQ2xzID0gbWUuYWRkU3BlY2lmaWNDbGFzcygpO1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6IGNsYXNzbmFtZXMoKF9jbGFzc25hbWVzID0ge1xuICAgICAgICAgICAgICAgICAgICBcImhhc0Vycm9yXCI6ICFtZS5zdGF0ZS5wYXNzXG4gICAgICAgICAgICAgICAgfSwgX2NsYXNzbmFtZXNbc3BlY2lmaWNDbHNdID0gdHJ1ZSwgX2NsYXNzbmFtZXNbbWUucHJvcHMuY2xhc3NOYW1lXSA9ICEhbWUucHJvcHMuY2xhc3NOYW1lLCBfY2xhc3NuYW1lcykpIH0sXG4gICAgICAgICAgICBtZS5yZW5kZXJDb250ZW50KClcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENlbGxGaWVsZDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuQ2VsbEZpZWxkLmRpc3BsYXlOYW1lID0gXCJDZWxsRmllbGRcIjtcbkNlbGxGaWVsZC5wcm9wVHlwZXMgPSB7XG4gICAgcHJlZml4Q2xzOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nXG59O1xuXG5DZWxsRmllbGQuZGVmYXVsdFByb3BzID0ge1xuICAgIHByZWZpeENsczogJ2t1bWEtdXh0YWJsZS1jZWxsLWZpZWxkJ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDZWxsRmllbGQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS10YWJsZS9idWlsZC9DZWxsL0NlbGxGaWVsZC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBDZWxsRmllbGQgPSByZXF1aXJlKCcuL0NlbGxGaWVsZCcpO1xudmFyIGNsYXNzbmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xudmFyIFNlbGVjdCA9IHJlcXVpcmUoJ3V4Y29yZS1zZWxlY3QyJyk7XG52YXIgT3B0aW9uID0gU2VsZWN0Lk9wdGlvbjtcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgU2VsZWN0RmllbGQgPSBmdW5jdGlvbiAoX0NlbGxGaWVsZCkge1xuICAgIF9pbmhlcml0cyhTZWxlY3RGaWVsZCwgX0NlbGxGaWVsZCk7XG5cbiAgICBmdW5jdGlvbiBTZWxlY3RGaWVsZChwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2VsZWN0RmllbGQpO1xuXG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ2VsbEZpZWxkLmNhbGwodGhpcywgcHJvcHMpKTtcbiAgICB9XG5cbiAgICBTZWxlY3RGaWVsZC5wcm90b3R5cGUucmVuZGVyQ29udGVudCA9IGZ1bmN0aW9uIHJlbmRlckNvbnRlbnQoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBmaWVsZFByb3BzID0ge1xuICAgICAgICAgICAgb25TZWxlY3Q6IGZ1bmN0aW9uIG9uU2VsZWN0KHZhbHVlLCBPcHRpb24pIHtcbiAgICAgICAgICAgICAgICBtZS5oYW5kbGVEYXRhQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICAgICAganN4aWQ6IG1lLnByb3BzLnJvd0RhdGFbJ2pzeGlkJ10sXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbjogbWUucHJvcHMuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBPcHRpb24ucHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbHVlOiBtZS5wcm9wcy52YWx1ZVxuICAgICAgICB9O1xuICAgICAgICBpZiAobWUucHJvcHMuY29sdW1uLmNvbmZpZykge1xuICAgICAgICAgICAgdmFyIF9tZSRwcm9wcyRjb2x1bW4kY29uZiA9IG1lLnByb3BzLmNvbHVtbi5jb25maWc7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfbWUkcHJvcHMkY29sdW1uJGNvbmYudmFsdWU7XG4gICAgICAgICAgICB2YXIgb25TZWxlY3QgPSBfbWUkcHJvcHMkY29sdW1uJGNvbmYub25TZWxlY3Q7XG5cbiAgICAgICAgICAgIHZhciBjdXN0b21Qcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfbWUkcHJvcHMkY29sdW1uJGNvbmYsIFsndmFsdWUnLCAnb25TZWxlY3QnXSk7XG5cbiAgICAgICAgICAgIGFzc2lnbihmaWVsZFByb3BzLCBjdXN0b21Qcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBTZWxlY3QsXG4gICAgICAgICAgICBmaWVsZFByb3BzLFxuICAgICAgICAgICAgbWUucHJvcHMuY29sdW1uLmNoaWxkcmVuXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHJldHVybiBTZWxlY3RGaWVsZDtcbn0oQ2VsbEZpZWxkKTtcblxuO1xuXG5TZWxlY3RGaWVsZC5wcm9wVHlwZXMgPSBhc3NpZ24oe30sIENlbGxGaWVsZC5wcm9wVHlwZXMpO1xuXG5TZWxlY3RGaWVsZC5kZWZhdWx0UHJvcHMgPSBhc3NpZ24oe30sIENlbGxGaWVsZC5kZWZhdWx0UHJvcHMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbGVjdEZpZWxkO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtdGFibGUvYnVpbGQvQ2VsbC9TZWxlY3RGaWVsZC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBDZWxsRmllbGQgPSByZXF1aXJlKCcuL0NlbGxGaWVsZCcpO1xudmFyIGNsYXNzbmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xudmFyIFJhZGlvR3JvdXAgPSByZXF1aXJlKCd1eGNvcmUtcmFkaW9ncm91cCcpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgUmFkaW9GaWVsZCA9IGZ1bmN0aW9uIChfQ2VsbEZpZWxkKSB7XG4gICAgX2luaGVyaXRzKFJhZGlvRmllbGQsIF9DZWxsRmllbGQpO1xuXG4gICAgZnVuY3Rpb24gUmFkaW9GaWVsZChwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmFkaW9GaWVsZCk7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9DZWxsRmllbGQuY2FsbCh0aGlzLCBwcm9wcykpO1xuICAgIH1cblxuICAgIFJhZGlvRmllbGQucHJvdG90eXBlLnByb2Nlc3NDaGlsZHJlbiA9IGZ1bmN0aW9uIHByb2Nlc3NDaGlsZHJlbigpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICBtZS5wcm9wcy5jb2x1bW4uY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgb2JqW2l0ZW0ucHJvcHMudmFsdWVdID0gaXRlbS5wcm9wcy50ZXh0O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuXG4gICAgUmFkaW9GaWVsZC5wcm90b3R5cGUucmVuZGVyQ29udGVudCA9IGZ1bmN0aW9uIHJlbmRlckNvbnRlbnQoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBkYXRhS2V5ID0gbWUucHJvcHMuY29sdW1uLmRhdGFLZXk7XG4gICAgICAgIHZhciB0ZXh0TWFwID0gbWUucHJvY2Vzc0NoaWxkcmVuKCk7XG4gICAgICAgIHZhciBmaWVsZFByb3BzID0ge1xuICAgICAgICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbWUuaGFuZGxlRGF0YUNoYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgIGpzeGlkOiBtZS5wcm9wcy5yb3dEYXRhWydqc3hpZCddLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IG1lLnByb3BzLmNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dE1hcFt2YWx1ZV0sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbHVlOiBtZS5wcm9wcy52YWx1ZVxuICAgICAgICB9O1xuICAgICAgICBpZiAobWUucHJvcHMuY29sdW1uLmNvbmZpZykge1xuICAgICAgICAgICAgdmFyIF9tZSRwcm9wcyRjb2x1bW4kY29uZiA9IG1lLnByb3BzLmNvbHVtbi5jb25maWc7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfbWUkcHJvcHMkY29sdW1uJGNvbmYudmFsdWU7XG4gICAgICAgICAgICB2YXIgb25DaGFuZ2UgPSBfbWUkcHJvcHMkY29sdW1uJGNvbmYub25DaGFuZ2U7XG5cbiAgICAgICAgICAgIHZhciBjdXN0b21Qcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfbWUkcHJvcHMkY29sdW1uJGNvbmYsIFsndmFsdWUnLCAnb25DaGFuZ2UnXSk7XG5cbiAgICAgICAgICAgIGFzc2lnbihmaWVsZFByb3BzLCBjdXN0b21Qcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBSYWRpb0dyb3VwLFxuICAgICAgICAgICAgZmllbGRQcm9wcyxcbiAgICAgICAgICAgIG1lLnByb3BzLmNvbHVtbi5jaGlsZHJlblxuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gUmFkaW9GaWVsZDtcbn0oQ2VsbEZpZWxkKTtcblxuO1xuXG5SYWRpb0ZpZWxkLnByb3BUeXBlcyA9IGFzc2lnbih7fSwgQ2VsbEZpZWxkLnByb3BUeXBlcyk7XG5cblJhZGlvRmllbGQuZGVmYXVsdFByb3BzID0gYXNzaWduKHt9LCBDZWxsRmllbGQuZGVmYXVsdFByb3BzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYWRpb0ZpZWxkO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtdGFibGUvYnVpbGQvQ2VsbC9SYWRpb0ZpZWxkLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBGb3JtYXR0ZXIgPSByZXF1aXJlKCd1eGNvcmUtZm9ybWF0dGVyJyk7XG52YXIgdXRpbCA9IHtcbiAgICBmb3JtYXRWYWx1ZTogZnVuY3Rpb24gZm9ybWF0VmFsdWUodmFsdWUsIHR5cGUsIGRlbGltaXRlcikge1xuICAgICAgICBkZWxpbWl0ZXIgPSBkZWxpbWl0ZXIgfHwgXCIgXCI7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB2YWx1ZSArIFwiXCI7XG4gICAgICAgIGlmICh0eXBlID09IFwibW9uZXlcIikge1xuICAgICAgICAgICAgcmV0dXJuIEZvcm1hdHRlci5tb25leSh2YWx1ZSwgZGVsaW1pdGVyKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09IFwiY2FyZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gRm9ybWF0dGVyLmNhcmQodmFsdWUsIGRlbGltaXRlcik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcImNubW9iaWxlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBGb3JtYXR0ZXIuY25tb2JpbGUodmFsdWUsIGRlbGltaXRlcik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHV0aWw7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS10YWJsZS9idWlsZC9DZWxsL1V0aWwuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBAYXV0aG9yOiB6aG91cXVhbi55ZXpxXG4gKiBAdGltZSA6IDgvMTIgMjAxNVxuICovXG5cbnZhciBjbGFzc25hbWVzID0gcmVxdWlyZShcImNsYXNzbmFtZXNcIik7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIE1hc2sgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhNYXNrLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIE1hc2socHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hc2spO1xuXG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpKTtcbiAgICB9XG5cbiAgICBNYXNrLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBfY2xhc3NuYW1lcztcblxuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgICAgdmlzaWJsZSA9IHByb3BzLnZpc2libGUsXG4gICAgICAgICAgICBsb2FkVGlwcyA9IHByb3BzLnRpcHMgPyBwcm9wcy50aXBzIDogXCJMb2FkaW5nLi4uXCI7XG4gICAgICAgIHZhciBfY2xhc3NOYW1lID0gY2xhc3NuYW1lcygoX2NsYXNzbmFtZXMgPSB7fSwgX2NsYXNzbmFtZXNbcHJvcHMuanN4cHJlZml4Q2xzXSA9IHRydWUsIF9jbGFzc25hbWVzW3Byb3BzLmpzeHByZWZpeENscyArIFwiLWhpZGVcIl0gPSAhdmlzaWJsZSwgX2NsYXNzbmFtZXMpKTtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBfY2xhc3NOYW1lIH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcm9wcy5qc3hwcmVmaXhDbHMgKyAnLWNlbnRlcmJsaycgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGxvYWRUaXBzXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gTWFzaztcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuO1xuXG5NYXNrLnByb3BUeXBlcyA9IHt9O1xuXG5NYXNrLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBqc3hwcmVmaXhDbHM6IFwia3VtYS11eG1hc2tcIlxufTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBNYXNrO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS10YWJsZS9idWlsZC9NYXNrLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGlzSUU6IGZ1bmN0aW9uIGlzSUUodmVyc2lvbikge1xuICAgICAgICBpZiAobmF2aWdhdG9yLmFwcE5hbWUgPT0gXCJNaWNyb3NvZnQgSW50ZXJuZXQgRXhwbG9yZXJcIikge1xuICAgICAgICAgICAgaWYgKCF2ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYXZpZ2F0b3IuYXBwVmVyc2lvbi5zcGxpdChcIjtcIilbMV0ucmVwbGFjZSgvWyBdL2csIFwiXCIpID09IFwiTVNJRVwiICsgdmVyc2lvbiArIFwiLjBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS10YWJsZS9idWlsZC91dGlsLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogR3JpZCBDb21wb25lbnQgZm9yIHV4Y29yZVxuICogQGF1dGhvciB6aG91cXVhbi55ZXpxXG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgVVhDb3JlIFRlYW0sIEFsaW53LlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG52YXIgU2VhcmNoQmFyID0gcmVxdWlyZShcIi4vU2VhcmNoQmFyXCIpO1xudmFyIGNsYXNzbmFtZXMgPSByZXF1aXJlKFwiY2xhc3NuYW1lc1wiKTtcbnZhciBCdXR0b24gPSByZXF1aXJlKFwidXhjb3JlLWJ1dHRvblwiKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIEFjdGlvbkJhciA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzKEFjdGlvbkJhciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBBY3Rpb25CYXIocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFjdGlvbkJhcik7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuICAgIH1cblxuICAgIEFjdGlvbkJhci5wcm90b3R5cGUuaGFuZGxlU2VhcmNoID0gZnVuY3Rpb24gaGFuZGxlU2VhcmNoKHZhbHVlKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25TZWFyY2godmFsdWUpO1xuICAgIH07XG5cbiAgICBBY3Rpb25CYXIucHJvdG90eXBlLnJlbmRlckFjdGlvbkJ0biA9IGZ1bmN0aW9uIHJlbmRlckFjdGlvbkJ0bihpdGVtLCBpbmRleCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgaXRlbVByb3BzID0ge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBtZS5wcm9wcy5qc3hwcmVmaXhDbHMgKyBcIi1pdGVtXCIsXG4gICAgICAgICAgICBvbkNsaWNrOiBpdGVtLmNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICAgICAga2V5OiBpbmRleFxuICAgICAgICB9O1xuICAgICAgICBpZiAoISFpdGVtLnJlbmRlciAmJiB0eXBlb2YgaXRlbS5yZW5kZXIgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICAgIGl0ZW1Qcm9wcyxcbiAgICAgICAgICAgICAgICBpdGVtLnJlbmRlcihpdGVtLnRpdGxlKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgIEJ1dHRvbixcbiAgICAgICAgICAgICAgICBfZXh0ZW5kcyh7IHR5cGU6IFwib3V0bGluZVwiLCBzaXplOiBcIm1lZGl1bVwiIH0sIGl0ZW1Qcm9wcyksXG4gICAgICAgICAgICAgICAgaXRlbS50aXRsZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBBY3Rpb25CYXIucHJvdG90eXBlLnJlbmRlclNlYXJjaEJhciA9IGZ1bmN0aW9uIHJlbmRlclNlYXJjaEJhcigpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuc2hvd1NlYXJjaCkge1xuICAgICAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgICAgIHZhciBzZWFyY2hCYXJQcm9wcyA9IHtcbiAgICAgICAgICAgICAgICBvblNlYXJjaDogbWUuaGFuZGxlU2VhcmNoLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgIGtleTogJ3NlYXJjaGJhcicsXG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IG1lLnByb3BzLnNlYXJjaEJhclBsYWNlaG9sZGVyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2VhcmNoQmFyLCBzZWFyY2hCYXJQcm9wcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogIGNvbnZlcnQgQWN0aW9uQmFyIGNvbmZpZyBmcm9tIGhhc2ggdG8gYXJyYXlcbiAgICAgKi9cblxuXG4gICAgQWN0aW9uQmFyLnByb3RvdHlwZS5nZXRBY3Rpb25JdGVtID0gZnVuY3Rpb24gZ2V0QWN0aW9uSXRlbShjb25maWcpIHtcbiAgICAgICAgdmFyIGl0ZW1zID0gW107XG4gICAgICAgIGlmIChjb25maWcgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgaXRlbXMgPSBjb25maWc7XG4gICAgICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBjb25maWcgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihjb25maWcpKSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpdGVtIGluIGNvbmZpZykge1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjb25maWdbaXRlbV1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtcztcbiAgICB9O1xuXG4gICAgQWN0aW9uQmFyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBfY2xhc3NuYW1lcztcblxuICAgICAgICB2YXIgbWUgPSB0aGlzLFxuICAgICAgICAgICAgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIF9iYXJDb25maWcgPSBfcHJvcHMuYWN0aW9uQmFyQ29uZmlnO1xuXG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBjbGFzc25hbWVzKChfY2xhc3NuYW1lcyA9IHt9LCBfY2xhc3NuYW1lc1tfcHJvcHMuanN4cHJlZml4Q2xzXSA9IF9wcm9wcy5qc3hwcmVmaXhDbHMsIF9jbGFzc25hbWVzW1wiZm4tY2xlYXJcIl0gPSB0cnVlLCBfY2xhc3NuYW1lcykpIH0sXG4gICAgICAgICAgICBtZS5nZXRBY3Rpb25JdGVtKF9iYXJDb25maWcpLm1hcChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWUucmVuZGVyQWN0aW9uQnRuKGl0ZW0sIGluZGV4KTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbWUucmVuZGVyU2VhcmNoQmFyKClcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEFjdGlvbkJhcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuO1xuXG5BY3Rpb25CYXIucHJvcFR5cGVzID0ge307XG5cbkFjdGlvbkJhci5kZWZhdWx0UHJvcHMgPSB7XG4gICAganN4cHJlZml4Q2xzOiBcImt1bWEtdXh0YWJsZS1hY3Rpb25iYXJcIlxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBY3Rpb25CYXI7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS10YWJsZS9idWlsZC9BY3Rpb25CYXIuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBHcmlkIENvbXBvbmVudCBmb3IgdXhjb3JlXG4gKiBAYXV0aG9yIHpob3VxdWFuLnllenFcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBVWENvcmUgVGVhbSwgQWxpbncuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIFNlYXJjaEJhciA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzKFNlYXJjaEJhciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBTZWFyY2hCYXIocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNlYXJjaEJhcik7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBzZWFyY2hUeHQ6IFwiXCJcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIFNlYXJjaEJhci5wcm90b3R5cGUuZG9TZWFyY2ggPSBmdW5jdGlvbiBkb1NlYXJjaCgpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vblNlYXJjaCh0aGlzLnN0YXRlLnNlYXJjaFR4dCk7XG4gICAgfTtcblxuICAgIFNlYXJjaEJhci5wcm90b3R5cGUub25LZXlEb3duID0gZnVuY3Rpb24gb25LZXlEb3duKGUpIHtcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PSAxMykge1xuICAgICAgICAgICAgdGhpcy5kb1NlYXJjaCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFNlYXJjaEJhci5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKGUpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBzZWFyY2hUeHQ6IGUudGFyZ2V0LnZhbHVlXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBTZWFyY2hCYXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gbWUucHJvcHMucGxhY2Vob2xkZXI7XG5cbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiB0aGlzLnByb3BzLmpzeHByZWZpeENscyB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnaW5wdXQnLCB7IHR5cGU6ICd0ZXh0JywgY2xhc3NOYW1lOiAna3VtYS1pbnB1dCcsIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlciwgdmFsdWU6IHRoaXMuc3RhdGUudmFsdWUsIG9uS2V5RG93bjogdGhpcy5vbktleURvd24uYmluZCh0aGlzKSwgb25DaGFuZ2U6IHRoaXMuaGFuZGxlQ2hhbmdlLmJpbmQodGhpcykgfSksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdpJywgeyBjbGFzc05hbWU6ICdrdW1hLWljb24ga3VtYS1pY29uLXNlYXJjaCcsIG9uQ2xpY2s6IHRoaXMuZG9TZWFyY2guYmluZCh0aGlzKSB9KVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2VhcmNoQmFyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG47XG5cblNlYXJjaEJhci5wcm9wVHlwZXMgPSB7fTtcblxuU2VhcmNoQmFyLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBqc3hwcmVmaXhDbHM6IFwia3VtYS11eHRhYmxlLXNlYXJjaGJhclwiLFxuICAgIG9uU2VhcmNoOiBmdW5jdGlvbiBvblNlYXJjaCgpIHt9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlYXJjaEJhcjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLXRhYmxlL2J1aWxkL1NlYXJjaEJhci5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUYWJzIENvbXBvbmVudCBmb3IgdXhjb3JlXG4gKiBAYXV0aG9yIFxuICpcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIFV4Y29yZSBUZWFtLCBBbGludy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL1RhYnMnKTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLXRhYnMvYnVpbGQvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yZWFjdERvbSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgX3JlYWN0RG9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0RG9tKTtcblxudmFyIF9yY1RhYnMgPSByZXF1aXJlKCdyYy10YWJzJyk7XG5cbnZhciBfcmNUYWJzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JjVGFicyk7XG5cbnZhciBfb2JqZWN0QXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgX29iamVjdEFzc2lnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vYmplY3RBc3NpZ24pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgcHJlZml4Q2xzID0gJ2t1bWEtdGFiJztcbnZhciBUWVBFU1VGRklYID0ge1xuXHRsYXJnZTogJ2xnJyxcblx0c21hbGw6ICdzbScsXG5cdGZpbHRlcjogJ2ZpbHRlcicsXG5cdGJyaWNrOiAnYnJpY2snXG59O1xuXG52YXIgVGFicyA9IGZ1bmN0aW9uIChfUmNUYWJzKSB7XG5cdF9pbmhlcml0cyhUYWJzLCBfUmNUYWJzKTtcblxuXHRmdW5jdGlvbiBUYWJzKCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUYWJzKTtcblxuXHRcdHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmNUYWJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXHR9XG5cblx0VGFicy5wcm90b3R5cGUuYWFhID0gZnVuY3Rpb24gYWFhKCkge307XG5cblx0VGFicy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuXHRcdHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG5cdFx0dmFyIGNscyA9IFtdO1xuXHRcdGlmIChUWVBFU1VGRklYW3Byb3BzLnR5cGVdKSB7XG5cdFx0XHRjbHMucHVzaChbcHJlZml4Q2xzLCBUWVBFU1VGRklYW3Byb3BzLnR5cGVdXS5qb2luKCctJykpO1xuXHRcdH1cblx0XHRjbHMgPSBjbHMuam9pbignICcpO1xuXHRcdHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9yY1RhYnMyW1wiZGVmYXVsdFwiXSwgX2V4dGVuZHMoe30sIHByb3BzLCB7IGNsYXNzTmFtZTogY2xzIH0pKTtcblx0fTtcblxuXHRyZXR1cm4gVGFicztcbn0oX3JjVGFiczJbXCJkZWZhdWx0XCJdKTtcblxuVGFicy5kaXNwbGF5TmFtZSA9ICd1eGNvcmUtdGFicyc7XG5UYWJzLmRlZmF1bHRQcm9wcyA9ICgwLCBfb2JqZWN0QXNzaWduMltcImRlZmF1bHRcIl0pKF9yY1RhYnMyW1wiZGVmYXVsdFwiXS5kZWZhdWx0UHJvcHMsIHtcblx0cHJlZml4Q2xzOiBwcmVmaXhDbHMsXG5cdHR5cGU6ICdsYXJnZSdcbn0pO1xuVGFicy5UYWJQYW5lID0gX3JjVGFiczJbXCJkZWZhdWx0XCJdLlRhYlBhbmU7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gVGFicztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtdGFicy9idWlsZC9UYWJzLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5UYWJQYW5lID0gZXhwb3J0cy5kZWZhdWx0ID0gdW5kZWZpbmVkO1xuXG52YXIgX1RhYnMgPSByZXF1aXJlKCcuL1RhYnMnKTtcblxudmFyIF9UYWJzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1RhYnMpO1xuXG52YXIgX1RhYlBhbmUyID0gcmVxdWlyZSgnLi9UYWJQYW5lJyk7XG5cbnZhciBfVGFiUGFuZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9UYWJQYW5lMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IF9UYWJzMi5kZWZhdWx0O1xuZXhwb3J0cy5UYWJQYW5lID0gX1RhYlBhbmUzLmRlZmF1bHQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS10YWJzL34vcmMtdGFicy9saWIvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9LZXlDb2RlID0gcmVxdWlyZSgnLi9LZXlDb2RlJyk7XG5cbnZhciBfS2V5Q29kZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9LZXlDb2RlKTtcblxudmFyIF9UYWJQYW5lID0gcmVxdWlyZSgnLi9UYWJQYW5lJyk7XG5cbnZhciBfVGFiUGFuZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9UYWJQYW5lKTtcblxudmFyIF9OYXYgPSByZXF1aXJlKCcuL05hdicpO1xuXG52YXIgX05hdjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9OYXYpO1xuXG52YXIgX3JjQW5pbWF0ZSA9IHJlcXVpcmUoJ3JjLWFuaW1hdGUnKTtcblxudmFyIF9yY0FuaW1hdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmNBbmltYXRlKTtcblxudmFyIF9jbGFzc25hbWVzMiA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcblxudmFyIF9jbGFzc25hbWVzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzbmFtZXMyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRBY3RpdmVLZXkocHJvcHMpIHtcbiAgdmFyIGFjdGl2ZUtleSA9IHZvaWQgMDtcbiAgX3JlYWN0Mi5kZWZhdWx0LkNoaWxkcmVuLmZvckVhY2gocHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmICghYWN0aXZlS2V5ICYmICFjaGlsZC5wcm9wcy5kaXNhYmxlZCkge1xuICAgICAgYWN0aXZlS2V5ID0gY2hpbGQua2V5O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhY3RpdmVLZXk7XG59XG5cbnZhciBUYWJzID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdUYWJzJyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBkZXN0cm95SW5hY3RpdmVUYWJQYW5lOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgb25UYWJDbGljazogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uQ2hhbmdlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgY2hpbGRyZW46IF9yZWFjdC5Qcm9wVHlwZXMuYW55LFxuICAgIHRhYkJhckV4dHJhQ29udGVudDogX3JlYWN0LlByb3BUeXBlcy5hbnksXG4gICAgYW5pbWF0aW9uOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBwcmVmaXhDbHM6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGNsYXNzTmFtZTogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgdGFiUG9zaXRpb246IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nXG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiBnZXREZWZhdWx0UHJvcHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByZWZpeENsczogJ3JjLXRhYnMnLFxuICAgICAgZGVzdHJveUluYWN0aXZlVGFiUGFuZTogZmFsc2UsXG4gICAgICB0YWJCYXJFeHRyYUNvbnRlbnQ6IG51bGwsXG4gICAgICBvbkNoYW5nZTogbm9vcCxcbiAgICAgIHRhYlBvc2l0aW9uOiAndG9wJyxcbiAgICAgIHN0eWxlOiB7fSxcbiAgICAgIGNvbnRlbnRTdHlsZToge30sXG4gICAgICBuYXZTdHlsZToge30sXG4gICAgICBvblRhYkNsaWNrOiBub29wXG4gICAgfTtcbiAgfSxcbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgYWN0aXZlS2V5ID0gdm9pZCAwO1xuICAgIGlmICgnYWN0aXZlS2V5JyBpbiBwcm9wcykge1xuICAgICAgYWN0aXZlS2V5ID0gcHJvcHMuYWN0aXZlS2V5O1xuICAgIH0gZWxzZSBpZiAoJ2RlZmF1bHRBY3RpdmVLZXknIGluIHByb3BzKSB7XG4gICAgICBhY3RpdmVLZXkgPSBwcm9wcy5kZWZhdWx0QWN0aXZlS2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICBhY3RpdmVLZXkgPSBnZXREZWZhdWx0QWN0aXZlS2V5KHByb3BzKTtcbiAgICB9XG4gICAgLy8gY2FjaGUgcGFuZWxzXG4gICAgdGhpcy5yZW5kZXJQYW5lbHMgPSB7fTtcbiAgICByZXR1cm4ge1xuICAgICAgYWN0aXZlS2V5OiBhY3RpdmVLZXlcbiAgICB9O1xuICB9LFxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIHZhciBuZXdBY3RpdmVLZXkgPSB0aGlzLnN0YXRlLmFjdGl2ZUtleTtcbiAgICBpZiAoJ2FjdGl2ZUtleScgaW4gbmV4dFByb3BzKSB7XG4gICAgICBuZXdBY3RpdmVLZXkgPSBuZXh0UHJvcHMuYWN0aXZlS2V5O1xuICAgICAgaWYgKCFuZXdBY3RpdmVLZXkpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgYWN0aXZlS2V5OiBuZXdBY3RpdmVLZXlcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGZvdW5kID0gdm9pZCAwO1xuICAgIF9yZWFjdDIuZGVmYXVsdC5DaGlsZHJlbi5mb3JFYWNoKG5leHRQcm9wcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQua2V5ID09PSBuZXdBY3RpdmVLZXkpIHtcbiAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChmb3VuZCkge1xuICAgICAgdGhpcy5zZXRBY3RpdmVLZXkobmV3QWN0aXZlS2V5LCBuZXh0UHJvcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldEFjdGl2ZUtleShnZXREZWZhdWx0QWN0aXZlS2V5KG5leHRQcm9wcyksIG5leHRQcm9wcyk7XG4gICAgfVxuICB9LFxuICBvblRhYkRlc3Ryb3k6IGZ1bmN0aW9uIG9uVGFiRGVzdHJveShrZXkpIHtcbiAgICBkZWxldGUgdGhpcy5yZW5kZXJQYW5lbHNba2V5XTtcbiAgfSxcbiAgb25UYWJDbGljazogZnVuY3Rpb24gb25UYWJDbGljayhrZXkpIHtcbiAgICB0aGlzLnNldEFjdGl2ZUtleShrZXkpO1xuICAgIHRoaXMucHJvcHMub25UYWJDbGljayhrZXkpO1xuICAgIGlmICh0aGlzLnN0YXRlLmFjdGl2ZUtleSAhPT0ga2V5KSB7XG4gICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKGtleSk7XG4gICAgfVxuICB9LFxuICBvbk5hdktleURvd246IGZ1bmN0aW9uIG9uTmF2S2V5RG93bihlKSB7XG4gICAgdmFyIGV2ZW50S2V5Q29kZSA9IGUua2V5Q29kZTtcbiAgICBpZiAoZXZlbnRLZXlDb2RlID09PSBfS2V5Q29kZTIuZGVmYXVsdC5SSUdIVCB8fCBldmVudEtleUNvZGUgPT09IF9LZXlDb2RlMi5kZWZhdWx0LkRPV04pIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHZhciBuZXh0S2V5ID0gdGhpcy5nZXROZXh0QWN0aXZlS2V5KHRydWUpO1xuICAgICAgdGhpcy5vblRhYkNsaWNrKG5leHRLZXkpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnRLZXlDb2RlID09PSBfS2V5Q29kZTIuZGVmYXVsdC5MRUZUIHx8IGV2ZW50S2V5Q29kZSA9PT0gX0tleUNvZGUyLmRlZmF1bHQuVVApIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHZhciBwcmV2aW91c0tleSA9IHRoaXMuZ2V0TmV4dEFjdGl2ZUtleShmYWxzZSk7XG4gICAgICB0aGlzLm9uVGFiQ2xpY2socHJldmlvdXNLZXkpO1xuICAgIH1cbiAgfSxcbiAgZ2V0TmV4dEFjdGl2ZUtleTogZnVuY3Rpb24gZ2V0TmV4dEFjdGl2ZUtleShuZXh0KSB7XG4gICAgdmFyIGFjdGl2ZUtleSA9IHRoaXMuc3RhdGUuYWN0aXZlS2V5O1xuICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuICAgIF9yZWFjdDIuZGVmYXVsdC5DaGlsZHJlbi5mb3JFYWNoKHRoaXMucHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAoIWMucHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoaWxkcmVuLnVuc2hpZnQoYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgbGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgIHZhciByZXQgPSBsZW5ndGggJiYgY2hpbGRyZW5bMF0ua2V5O1xuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkLCBpKSB7XG4gICAgICBpZiAoY2hpbGQua2V5ID09PSBhY3RpdmVLZXkpIHtcbiAgICAgICAgaWYgKGkgPT09IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgICByZXQgPSBjaGlsZHJlblswXS5rZXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0ID0gY2hpbGRyZW5baSArIDFdLmtleTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXQ7XG4gIH0sXG4gIGdldFRhYlBhbmVzOiBmdW5jdGlvbiBnZXRUYWJQYW5lcygpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBhY3RpdmVLZXkgPSBzdGF0ZS5hY3RpdmVLZXk7XG4gICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gICAgdmFyIG5ld0NoaWxkcmVuID0gW107XG4gICAgdmFyIHJlbmRlclBhbmVscyA9IHRoaXMucmVuZGVyUGFuZWxzO1xuXG4gICAgX3JlYWN0Mi5kZWZhdWx0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjKSB7XG4gICAgICB2YXIgY2hpbGQgPSBjO1xuICAgICAgdmFyIGtleSA9IGNoaWxkLmtleTtcbiAgICAgIHZhciBhY3RpdmUgPSBhY3RpdmVLZXkgPT09IGtleTtcbiAgICAgIGlmIChhY3RpdmUgfHwgcmVuZGVyUGFuZWxzW2tleV0pIHtcbiAgICAgICAgY2hpbGQgPSBhY3RpdmUgPyBjaGlsZCA6IHJlbmRlclBhbmVsc1trZXldO1xuICAgICAgICByZW5kZXJQYW5lbHNba2V5XSA9IF9yZWFjdDIuZGVmYXVsdC5jbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgICAgICBhY3RpdmU6IGFjdGl2ZSxcbiAgICAgICAgICBvbkRlc3Ryb3k6IF90aGlzLm9uVGFiRGVzdHJveS5iaW5kKF90aGlzLCBrZXkpLFxuICAgICAgICAgIC8vIGV2ZW50S2V5OiBrZXksXG4gICAgICAgICAgcm9vdFByZWZpeENsczogcHJvcHMucHJlZml4Q2xzXG4gICAgICAgIH0pO1xuICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKHJlbmRlclBhbmVsc1trZXldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRvIG5vdCBjaGFuZ2Ugb3duZXIgLi4uXG4gICAgICAgIC8vIG9yIGVsc2Ugd2lsbCBkZXN0cm95IGFuZCByZWluaXRcbiAgICAgICAgLy8gbmV3Q2hpbGRyZW4ucHVzaCg8VGFiUGFuZSBhY3RpdmU9e2ZhbHNlfVxuICAgICAgICAvLyAga2V5PXtrZXl9XG4gICAgICAgIC8vICBldmVudEtleT17a2V5fVxuICAgICAgICAvLyAgcm9vdFByZWZpeENscz17dGhpcy5wcm9wcy5wcmVmaXhDbHN9PjwvVGFiUGFuZT4pO1xuICAgICAgICAvLyByZXR1cm5cbiAgICAgICAgLy8gbGF6eSBsb2FkXG4gICAgICAgIG5ld0NoaWxkcmVuLnB1c2goX3JlYWN0Mi5kZWZhdWx0LmNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICAgICAgLy8gZXZlbnRLZXk6IGtleSxcbiAgICAgICAgICByb290UHJlZml4Q2xzOiBwcm9wcy5wcmVmaXhDbHNcbiAgICAgICAgfSwgW10pKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBuZXdDaGlsZHJlbjtcbiAgfSxcbiAgZ2V0SW5kZXhQYWlyOiBmdW5jdGlvbiBnZXRJbmRleFBhaXIocHJvcHMsIGN1cnJlbnRBY3RpdmVLZXksIGFjdGl2ZUtleSkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgX3JlYWN0Mi5kZWZhdWx0LkNoaWxkcmVuLmZvckVhY2gocHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjKSB7XG4gICAgICBrZXlzLnB1c2goYy5rZXkpO1xuICAgIH0pO1xuICAgIHZhciBjdXJyZW50SW5kZXggPSBrZXlzLmluZGV4T2YoY3VycmVudEFjdGl2ZUtleSk7XG4gICAgdmFyIG5leHRJbmRleCA9IGtleXMuaW5kZXhPZihhY3RpdmVLZXkpO1xuICAgIHJldHVybiB7XG4gICAgICBjdXJyZW50SW5kZXg6IGN1cnJlbnRJbmRleCwgbmV4dEluZGV4OiBuZXh0SW5kZXhcbiAgICB9O1xuICB9LFxuICBzZXRBY3RpdmVLZXk6IGZ1bmN0aW9uIHNldEFjdGl2ZUtleShhY3RpdmVLZXksIHBzKSB7XG4gICAgdmFyIHByb3BzID0gcHMgfHwgdGhpcy5wcm9wcztcbiAgICB2YXIgY3VycmVudEFjdGl2ZUtleSA9IHRoaXMuc3RhdGUuYWN0aXZlS2V5O1xuICAgIGlmIChjdXJyZW50QWN0aXZlS2V5ID09PSBhY3RpdmVLZXkgfHwgJ2FjdGl2ZUtleScgaW4gcHJvcHMgJiYgcHJvcHMgPT09IHRoaXMucHJvcHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFjdXJyZW50QWN0aXZlS2V5KSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgYWN0aXZlS2V5OiBhY3RpdmVLZXlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2dldEluZGV4UGFpciA9IHRoaXMuZ2V0SW5kZXhQYWlyKHByb3BzLCBjdXJyZW50QWN0aXZlS2V5LCBhY3RpdmVLZXkpO1xuXG4gICAgICB2YXIgY3VycmVudEluZGV4ID0gX2dldEluZGV4UGFpci5jdXJyZW50SW5kZXg7XG4gICAgICB2YXIgbmV4dEluZGV4ID0gX2dldEluZGV4UGFpci5uZXh0SW5kZXg7XG4gICAgICAvLyByZW1vdmVkXG5cbiAgICAgIGlmIChjdXJyZW50SW5kZXggPT09IC0xKSB7XG4gICAgICAgIHZhciBuZXdQYWlyID0gdGhpcy5nZXRJbmRleFBhaXIodGhpcy5wcm9wcywgY3VycmVudEFjdGl2ZUtleSwgYWN0aXZlS2V5KTtcbiAgICAgICAgY3VycmVudEluZGV4ID0gbmV3UGFpci5jdXJyZW50SW5kZXg7XG4gICAgICAgIG5leHRJbmRleCA9IG5ld1BhaXIubmV4dEluZGV4O1xuICAgICAgfVxuICAgICAgdmFyIHRhYk1vdmluZ0RpcmVjdGlvbiA9IGN1cnJlbnRJbmRleCA+IG5leHRJbmRleCA/ICdiYWNrd2FyZCcgOiAnZm9yd2FyZCc7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgYWN0aXZlS2V5OiBhY3RpdmVLZXksXG4gICAgICAgIHRhYk1vdmluZ0RpcmVjdGlvbjogdGFiTW92aW5nRGlyZWN0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfY2xhc3NuYW1lcztcblxuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGRlc3Ryb3lJbmFjdGl2ZVRhYlBhbmUgPSBwcm9wcy5kZXN0cm95SW5hY3RpdmVUYWJQYW5lO1xuICAgIHZhciBwcmVmaXhDbHMgPSBwcm9wcy5wcmVmaXhDbHM7XG4gICAgdmFyIHRhYlBvc2l0aW9uID0gcHJvcHMudGFiUG9zaXRpb247XG4gICAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZTtcbiAgICB2YXIgYW5pbWF0aW9uID0gcHJvcHMuYW5pbWF0aW9uO1xuXG4gICAgdmFyIGNscyA9ICgwLCBfY2xhc3NuYW1lczMuZGVmYXVsdCkoKF9jbGFzc25hbWVzID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lcywgcHJlZml4Q2xzLCAxKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc25hbWVzLCBwcmVmaXhDbHMgKyAnLScgKyB0YWJQb3NpdGlvbiwgMSksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lcywgY2xhc3NOYW1lLCAhIWNsYXNzTmFtZSksIF9jbGFzc25hbWVzKSk7XG4gICAgdmFyIHRhYk1vdmluZ0RpcmVjdGlvbiA9IHRoaXMuc3RhdGUudGFiTW92aW5nRGlyZWN0aW9uO1xuICAgIHZhciB0YWJQYW5lcyA9IHRoaXMuZ2V0VGFiUGFuZXMoKTtcbiAgICB2YXIgdHJhbnNpdGlvbk5hbWUgPSB2b2lkIDA7XG4gICAgdHJhbnNpdGlvbk5hbWUgPSBwcm9wcy50cmFuc2l0aW9uTmFtZSAmJiBwcm9wcy50cmFuc2l0aW9uTmFtZVt0YWJNb3ZpbmdEaXJlY3Rpb24gfHwgJ2JhY2t3YXJkJ107XG4gICAgaWYgKCF0cmFuc2l0aW9uTmFtZSAmJiBhbmltYXRpb24pIHtcbiAgICAgIHRyYW5zaXRpb25OYW1lID0gcHJlZml4Q2xzICsgJy0nICsgYW5pbWF0aW9uICsgJy0nICsgKHRhYk1vdmluZ0RpcmVjdGlvbiB8fCAnYmFja3dhcmQnKTtcbiAgICB9XG4gICAgaWYgKGRlc3Ryb3lJbmFjdGl2ZVRhYlBhbmUpIHtcbiAgICAgIHRhYlBhbmVzID0gdGFiUGFuZXMuZmlsdGVyKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgICByZXR1cm4gcGFuZWwucHJvcHMuYWN0aXZlO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0cmFuc2l0aW9uTmFtZSkge1xuICAgICAgaWYgKGRlc3Ryb3lJbmFjdGl2ZVRhYlBhbmUpIHtcbiAgICAgICAgdGFiUGFuZXMgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICBfcmNBbmltYXRlMi5kZWZhdWx0LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIHRyYW5zaXRpb25OYW1lOiB0cmFuc2l0aW9uTmFtZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGFiUGFuZXNcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhYlBhbmVzID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgX3JjQW5pbWF0ZTIuZGVmYXVsdCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzaG93UHJvcDogJ2FjdGl2ZScsXG4gICAgICAgICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICB0cmFuc2l0aW9uTmFtZTogdHJhbnNpdGlvbk5hbWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRhYlBhbmVzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjb250ZW50cyA9IFtfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChfTmF2Mi5kZWZhdWx0LCB7XG4gICAgICBwcmVmaXhDbHM6IHByZWZpeENscyxcbiAgICAgIGtleTogJ25hdicsXG4gICAgICBvbktleURvd246IHRoaXMub25OYXZLZXlEb3duLFxuICAgICAgdGFiQmFyRXh0cmFDb250ZW50OiB0aGlzLnByb3BzLnRhYkJhckV4dHJhQ29udGVudCxcbiAgICAgIHRhYlBvc2l0aW9uOiB0YWJQb3NpdGlvbixcbiAgICAgIHN0eWxlOiBwcm9wcy5uYXZTdHlsZSxcbiAgICAgIG9uVGFiQ2xpY2s6IHRoaXMub25UYWJDbGljayxcbiAgICAgIHRhYk1vdmluZ0RpcmVjdGlvbjogdGFiTW92aW5nRGlyZWN0aW9uLFxuICAgICAgcGFuZWxzOiB0aGlzLnByb3BzLmNoaWxkcmVuLFxuICAgICAgYWN0aXZlS2V5OiB0aGlzLnN0YXRlLmFjdGl2ZUtleVxuICAgIH0pLCBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICdkaXYnLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6IHByZWZpeENscyArICctY29udGVudCcsXG4gICAgICAgIHN0eWxlOiBwcm9wcy5jb250ZW50U3R5bGUsXG4gICAgICAgIGtleTogJ2NvbnRlbnQnXG4gICAgICB9LFxuICAgICAgdGFiUGFuZXNcbiAgICApXTtcbiAgICBpZiAodGFiUG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICBjb250ZW50cy5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICdkaXYnLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6IGNscyxcbiAgICAgICAgc3R5bGU6IHByb3BzLnN0eWxlXG4gICAgICB9LFxuICAgICAgY29udGVudHNcbiAgICApO1xuICB9XG59KTtcblxuVGFicy5UYWJQYW5lID0gX1RhYlBhbmUyLmRlZmF1bHQ7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFRhYnM7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLXRhYnMvfi9yYy10YWJzL2xpYi9UYWJzLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIC8qKlxuICAgKiBMRUZUXG4gICAqL1xuICBMRUZUOiAzNywgLy8gYWxzbyBOVU1fV0VTVFxuICAvKipcbiAgICogVVBcbiAgICovXG4gIFVQOiAzOCwgLy8gYWxzbyBOVU1fTk9SVEhcbiAgLyoqXG4gICAqIFJJR0hUXG4gICAqL1xuICBSSUdIVDogMzksIC8vIGFsc28gTlVNX0VBU1RcbiAgLyoqXG4gICAqIERPV05cbiAgICovXG4gIERPV046IDQwIH07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLXRhYnMvfi9yYy10YWJzL2xpYi9LZXlDb2RlLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfY2xhc3NuYW1lczIgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG5cbnZhciBfY2xhc3NuYW1lczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc25hbWVzMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbnZhciBUYWJQYW5lID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdUYWJQYW5lJyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBvbkRlc3Ryb3k6IF9yZWFjdDIuZGVmYXVsdC5Qcm9wVHlwZXMuZnVuY1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5vbkRlc3Ryb3kpIHtcbiAgICAgIHRoaXMucHJvcHMub25EZXN0cm95KCk7XG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX2NsYXNzbmFtZXM7XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBwcmVmaXhDbHMgPSBwcm9wcy5yb290UHJlZml4Q2xzICsgJy10YWJwYW5lJztcbiAgICB2YXIgY2xzID0gKDAsIF9jbGFzc25hbWVzMy5kZWZhdWx0KSgoX2NsYXNzbmFtZXMgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc25hbWVzLCBwcmVmaXhDbHMgKyAnLWhpZGRlbicsICFwcm9wcy5hY3RpdmUpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMsIHByZWZpeENscywgMSksIF9jbGFzc25hbWVzKSk7XG4gICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgJ2RpdicsXG4gICAgICB7IGNsYXNzTmFtZTogY2xzIH0sXG4gICAgICBwcm9wcy5jaGlsZHJlblxuICAgICk7XG4gIH1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBUYWJQYW5lO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS10YWJzL34vcmMtdGFicy9saWIvVGFiUGFuZS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX2NsYXNzbmFtZXMzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xuXG52YXIgX2NsYXNzbmFtZXM0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NuYW1lczMpO1xuXG52YXIgX0lua0Jhck1peGluID0gcmVxdWlyZSgnLi9JbmtCYXJNaXhpbicpO1xuXG52YXIgX0lua0Jhck1peGluMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0lua0Jhck1peGluKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIHRhYkJhckV4dHJhQ29udGVudFN0eWxlID0ge1xuICBmbG9hdDogJ3JpZ2h0J1xufTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBOYXYgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ05hdicsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgdGFiUG9zaXRpb246IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHRhYkJhckV4dHJhQ29udGVudDogX3JlYWN0LlByb3BUeXBlcy5hbnksXG4gICAgb25UYWJDbGljazogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uS2V5RG93bjogX3JlYWN0LlByb3BUeXBlcy5mdW5jXG4gIH0sXG5cbiAgbWl4aW5zOiBbX0lua0Jhck1peGluMi5kZWZhdWx0XSxcblxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogZmFsc2UsXG4gICAgICBvZmZzZXQ6IDAsXG4gICAgICBwcmV2OiBmYWxzZVxuICAgIH07XG4gIH0sXG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLmNvbXBvbmVudERpZFVwZGF0ZSgpO1xuICB9LFxuICBjb21wb25lbnREaWRVcGRhdGU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIGlmIChwcmV2UHJvcHMgJiYgcHJldlByb3BzLnRhYlBvc2l0aW9uICE9PSBwcm9wcy50YWJQb3NpdGlvbikge1xuICAgICAgdGhpcy5zZXRPZmZzZXQoMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBuYXZOb2RlID0gdGhpcy5yZWZzLm5hdjtcbiAgICB2YXIgbmF2Tm9kZVdIID0gdGhpcy5nZXRPZmZzZXRXSChuYXZOb2RlKTtcbiAgICB2YXIgbmF2V3JhcE5vZGUgPSB0aGlzLnJlZnMubmF2V3JhcDtcbiAgICB2YXIgbmF2V3JhcE5vZGVXSCA9IHRoaXMuZ2V0T2Zmc2V0V0gobmF2V3JhcE5vZGUpO1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdmFyIG9mZnNldCA9IHN0YXRlLm9mZnNldDtcbiAgICB2YXIgbWluT2Zmc2V0ID0gbmF2V3JhcE5vZGVXSCAtIG5hdk5vZGVXSDtcbiAgICB2YXIgX3N0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgbmV4dCA9IF9zdGF0ZS5uZXh0O1xuICAgIHZhciBwcmV2ID0gX3N0YXRlLnByZXY7XG5cbiAgICBpZiAobWluT2Zmc2V0ID49IDApIHtcbiAgICAgIG5leHQgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2V0T2Zmc2V0KDApO1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9IGVsc2UgaWYgKG1pbk9mZnNldCA8IG9mZnNldCkge1xuICAgICAgbmV4dCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHQgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2V0T2Zmc2V0KG1pbk9mZnNldCk7XG4gICAgICBvZmZzZXQgPSBtaW5PZmZzZXQ7XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgIHByZXYgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmV2ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5zZXROZXh0KG5leHQpO1xuICAgIHRoaXMuc2V0UHJldihwcmV2KTtcblxuICAgIHZhciBuZXh0UHJldiA9IHtcbiAgICAgIG5leHQ6IG5leHQsXG4gICAgICBwcmV2OiBwcmV2XG4gICAgfTtcbiAgICAvLyB3YWl0IG5leHQscHJldiBzaG93IGhpZGVcbiAgICBpZiAodGhpcy5pc05leHRQcmV2U2hvd24oc3RhdGUpICE9PSB0aGlzLmlzTmV4dFByZXZTaG93bihuZXh0UHJldikpIHtcbiAgICAgIHRoaXMuc2V0TmV4dFByZXYoe30sIHRoaXMuc2Nyb2xsVG9BY3RpdmVUYWIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjYW4gbm90IHVzZSBwcm9wcy5hY3RpdmVLZXlcbiAgICAgIGlmICghcHJldlByb3BzIHx8IHByb3BzLmFjdGl2ZUtleSAhPT0gcHJldlByb3BzLmFjdGl2ZUtleSkge1xuICAgICAgICB0aGlzLnNjcm9sbFRvQWN0aXZlVGFiKCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBvblRhYkNsaWNrOiBmdW5jdGlvbiBvblRhYkNsaWNrKGtleSkge1xuICAgIHRoaXMucHJvcHMub25UYWJDbGljayhrZXkpO1xuICB9LFxuXG5cbiAgLy8gd29yayBhcm91bmQgZXNsaW50IHdhcm5pbmdcbiAgc2V0TmV4dFByZXY6IGZ1bmN0aW9uIHNldE5leHRQcmV2KG5leHRQcmV2LCBjYWxsYmFjaykge1xuICAgIHRoaXMuc2V0U3RhdGUobmV4dFByZXYsIGNhbGxiYWNrKTtcbiAgfSxcbiAgZ2V0VGFiczogZnVuY3Rpb24gZ2V0VGFicygpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5wYW5lbHM7XG4gICAgdmFyIGFjdGl2ZUtleSA9IHByb3BzLmFjdGl2ZUtleTtcbiAgICB2YXIgcnN0ID0gW107XG4gICAgdmFyIHByZWZpeENscyA9IHByb3BzLnByZWZpeENscztcblxuICAgIF9yZWFjdDIuZGVmYXVsdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHZhciBrZXkgPSBjaGlsZC5rZXk7XG4gICAgICB2YXIgY2xzID0gYWN0aXZlS2V5ID09PSBrZXkgPyBwcmVmaXhDbHMgKyAnLXRhYi1hY3RpdmUnIDogJyc7XG4gICAgICBjbHMgKz0gJyAnICsgcHJlZml4Q2xzICsgJy10YWInO1xuICAgICAgdmFyIGV2ZW50cyA9IHt9O1xuICAgICAgaWYgKGNoaWxkLnByb3BzLmRpc2FibGVkKSB7XG4gICAgICAgIGNscyArPSAnICcgKyBwcmVmaXhDbHMgKyAnLXRhYi1kaXNhYmxlZCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBldmVudHMgPSB7XG4gICAgICAgICAgb25DbGljazogX3RoaXMub25UYWJDbGljay5iaW5kKF90aGlzLCBrZXkpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgcmVmID0ge307XG4gICAgICBpZiAoYWN0aXZlS2V5ID09PSBrZXkpIHtcbiAgICAgICAgcmVmLnJlZiA9ICdhY3RpdmVUYWInO1xuICAgICAgfVxuICAgICAgcnN0LnB1c2goX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdkaXYnLFxuICAgICAgICBfZXh0ZW5kcyh7fSwgZXZlbnRzLCB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBjbHMsXG4gICAgICAgICAga2V5OiBrZXlcbiAgICAgICAgfSwgcmVmKSxcbiAgICAgICAgX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctdGFiLWlubmVyJyB9LFxuICAgICAgICAgIGNoaWxkLnByb3BzLnRhYlxuICAgICAgICApXG4gICAgICApKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByc3Q7XG4gIH0sXG4gIGdldE9mZnNldFdIOiBmdW5jdGlvbiBnZXRPZmZzZXRXSChub2RlKSB7XG4gICAgdmFyIHRhYlBvc2l0aW9uID0gdGhpcy5wcm9wcy50YWJQb3NpdGlvbjtcbiAgICB2YXIgcHJvcCA9ICdvZmZzZXRXaWR0aCc7XG4gICAgaWYgKHRhYlBvc2l0aW9uID09PSAnbGVmdCcgfHwgdGFiUG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIHByb3AgPSAnb2Zmc2V0SGVpZ2h0JztcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVbcHJvcF07XG4gIH0sXG4gIGdldE9mZnNldExUOiBmdW5jdGlvbiBnZXRPZmZzZXRMVChub2RlKSB7XG4gICAgdmFyIHRhYlBvc2l0aW9uID0gdGhpcy5wcm9wcy50YWJQb3NpdGlvbjtcbiAgICB2YXIgcHJvcCA9ICdsZWZ0JztcbiAgICBpZiAodGFiUG9zaXRpb24gPT09ICdsZWZ0JyB8fCB0YWJQb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgcHJvcCA9ICd0b3AnO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtwcm9wXTtcbiAgfSxcbiAgc2V0T2Zmc2V0OiBmdW5jdGlvbiBzZXRPZmZzZXQob2Zmc2V0KSB7XG4gICAgdmFyIHRhcmdldCA9IE1hdGgubWluKDAsIG9mZnNldCk7XG4gICAgaWYgKHRoaXMuc3RhdGUub2Zmc2V0ICE9PSB0YXJnZXQpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBvZmZzZXQ6IHRhcmdldFxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBzZXRQcmV2OiBmdW5jdGlvbiBzZXRQcmV2KHYpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5wcmV2ICE9PSB2KSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgcHJldjogdlxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBzZXROZXh0OiBmdW5jdGlvbiBzZXROZXh0KHYpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5uZXh0ICE9PSB2KSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgbmV4dDogdlxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBpc05leHRQcmV2U2hvd246IGZ1bmN0aW9uIGlzTmV4dFByZXZTaG93bihzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5uZXh0IHx8IHN0YXRlLnByZXY7XG4gIH0sXG4gIHNjcm9sbFRvQWN0aXZlVGFiOiBmdW5jdGlvbiBzY3JvbGxUb0FjdGl2ZVRhYigpIHtcbiAgICB2YXIgX3JlZnMgPSB0aGlzLnJlZnM7XG4gICAgdmFyIGFjdGl2ZVRhYiA9IF9yZWZzLmFjdGl2ZVRhYjtcbiAgICB2YXIgbmF2V3JhcCA9IF9yZWZzLm5hdldyYXA7XG5cbiAgICBpZiAoYWN0aXZlVGFiKSB7XG4gICAgICB2YXIgYWN0aXZlVGFiV0ggPSB0aGlzLmdldE9mZnNldFdIKGFjdGl2ZVRhYik7XG4gICAgICB2YXIgbmF2V3JhcE5vZGVXSCA9IHRoaXMuZ2V0T2Zmc2V0V0gobmF2V3JhcCk7XG4gICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5zdGF0ZS5vZmZzZXQ7XG5cbiAgICAgIHZhciB3cmFwT2Zmc2V0ID0gdGhpcy5nZXRPZmZzZXRMVChuYXZXcmFwKTtcbiAgICAgIHZhciBhY3RpdmVUYWJPZmZzZXQgPSB0aGlzLmdldE9mZnNldExUKGFjdGl2ZVRhYik7XG4gICAgICBpZiAod3JhcE9mZnNldCA+IGFjdGl2ZVRhYk9mZnNldCkge1xuICAgICAgICBvZmZzZXQgKz0gd3JhcE9mZnNldCAtIGFjdGl2ZVRhYk9mZnNldDtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgb2Zmc2V0OiBvZmZzZXRcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHdyYXBPZmZzZXQgKyBuYXZXcmFwTm9kZVdIIDwgYWN0aXZlVGFiT2Zmc2V0ICsgYWN0aXZlVGFiV0gpIHtcbiAgICAgICAgb2Zmc2V0IC09IGFjdGl2ZVRhYk9mZnNldCArIGFjdGl2ZVRhYldIIC0gKHdyYXBPZmZzZXQgKyBuYXZXcmFwTm9kZVdIKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgb2Zmc2V0OiBvZmZzZXRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwcmV2OiBmdW5jdGlvbiBwcmV2KCkge1xuICAgIHZhciBuYXZXcmFwTm9kZSA9IHRoaXMucmVmcy5uYXZXcmFwO1xuICAgIHZhciBuYXZXcmFwTm9kZVdIID0gdGhpcy5nZXRPZmZzZXRXSChuYXZXcmFwTm9kZSk7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgb2Zmc2V0ID0gc3RhdGUub2Zmc2V0O1xuICAgIHRoaXMuc2V0T2Zmc2V0KG9mZnNldCArIG5hdldyYXBOb2RlV0gpO1xuICB9LFxuICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgIHZhciBuYXZXcmFwTm9kZSA9IHRoaXMucmVmcy5uYXZXcmFwO1xuICAgIHZhciBuYXZXcmFwTm9kZVdIID0gdGhpcy5nZXRPZmZzZXRXSChuYXZXcmFwTm9kZSk7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgb2Zmc2V0ID0gc3RhdGUub2Zmc2V0O1xuICAgIHRoaXMuc2V0T2Zmc2V0KG9mZnNldCAtIG5hdldyYXBOb2RlV0gpO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdmFyIHByZWZpeENscyA9IHByb3BzLnByZWZpeENscztcbiAgICB2YXIgdGFicyA9IHRoaXMuZ2V0VGFicygpO1xuICAgIHZhciB0YWJNb3ZpbmdEaXJlY3Rpb24gPSBwcm9wcy50YWJNb3ZpbmdEaXJlY3Rpb247XG4gICAgdmFyIHRhYlBvc2l0aW9uID0gcHJvcHMudGFiUG9zaXRpb247XG4gICAgdmFyIGlua0JhckNsYXNzID0gcHJlZml4Q2xzICsgJy1pbmstYmFyJztcbiAgICBpZiAodGFiTW92aW5nRGlyZWN0aW9uKSB7XG4gICAgICBpbmtCYXJDbGFzcyArPSAnICcgKyBwcmVmaXhDbHMgKyAnLWluay1iYXItdHJhbnNpdGlvbi0nICsgdGFiTW92aW5nRGlyZWN0aW9uO1xuICAgIH1cbiAgICB2YXIgbmV4dEJ1dHRvbiA9IHZvaWQgMDtcbiAgICB2YXIgcHJldkJ1dHRvbiA9IHZvaWQgMDtcblxuICAgIHZhciBzaG93TmV4dFByZXYgPSBzdGF0ZS5wcmV2IHx8IHN0YXRlLm5leHQ7XG5cbiAgICBpZiAoc2hvd05leHRQcmV2KSB7XG4gICAgICB2YXIgX2NsYXNzbmFtZXMsIF9jbGFzc25hbWVzMjtcblxuICAgICAgcHJldkJ1dHRvbiA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnc3BhbicsXG4gICAgICAgIHtcbiAgICAgICAgICBvbkNsaWNrOiBzdGF0ZS5wcmV2ID8gdGhpcy5wcmV2IDogbm9vcCxcbiAgICAgICAgICB1bnNlbGVjdGFibGU6ICd1bnNlbGVjdGFibGUnLFxuICAgICAgICAgIGNsYXNzTmFtZTogKDAsIF9jbGFzc25hbWVzNC5kZWZhdWx0KSgoX2NsYXNzbmFtZXMgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc25hbWVzLCBwcmVmaXhDbHMgKyAnLXRhYi1wcmV2JywgMSksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lcywgcHJlZml4Q2xzICsgJy10YWItYnRuLWRpc2FibGVkJywgIXN0YXRlLnByZXYpLCBfY2xhc3NuYW1lcykpXG4gICAgICAgIH0sXG4gICAgICAgIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KCdzcGFuJywgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctdGFiLXByZXYtaWNvbicgfSlcbiAgICAgICk7XG5cbiAgICAgIG5leHRCdXR0b24gPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ3NwYW4nLFxuICAgICAgICB7XG4gICAgICAgICAgb25DbGljazogc3RhdGUubmV4dCA/IHRoaXMubmV4dCA6IG5vb3AsXG4gICAgICAgICAgdW5zZWxlY3RhYmxlOiAndW5zZWxlY3RhYmxlJyxcbiAgICAgICAgICBjbGFzc05hbWU6ICgwLCBfY2xhc3NuYW1lczQuZGVmYXVsdCkoKF9jbGFzc25hbWVzMiA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMyLCBwcmVmaXhDbHMgKyAnLXRhYi1uZXh0JywgMSksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lczIsIHByZWZpeENscyArICctdGFiLWJ0bi1kaXNhYmxlZCcsICFzdGF0ZS5uZXh0KSwgX2NsYXNzbmFtZXMyKSlcbiAgICAgICAgfSxcbiAgICAgICAgX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nLCB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy10YWItbmV4dC1pY29uJyB9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgbmF2T2Zmc2V0ID0ge307XG4gICAgaWYgKHRhYlBvc2l0aW9uID09PSAnbGVmdCcgfHwgdGFiUG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIG5hdk9mZnNldCA9IHtcbiAgICAgICAgdG9wOiBzdGF0ZS5vZmZzZXRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hdk9mZnNldCA9IHtcbiAgICAgICAgbGVmdDogc3RhdGUub2Zmc2V0XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciB0YWJCYXJFeHRyYUNvbnRlbnQgPSB0aGlzLnByb3BzLnRhYkJhckV4dHJhQ29udGVudDtcblxuICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICdkaXYnLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6IHByZWZpeENscyArICctYmFyJyxcbiAgICAgICAgdGFiSW5kZXg6ICcwJyxcbiAgICAgICAgb25LZXlEb3duOiB0aGlzLnByb3BzLm9uS2V5RG93blxuICAgICAgfSxcbiAgICAgIHRhYkJhckV4dHJhQ29udGVudCA/IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgeyBzdHlsZTogdGFiQmFyRXh0cmFDb250ZW50U3R5bGUgfSxcbiAgICAgICAgdGFiQmFyRXh0cmFDb250ZW50XG4gICAgICApIDogbnVsbCxcbiAgICAgIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1uYXYtY29udGFpbmVyICcgKyAoc2hvd05leHRQcmV2ID8gcHJlZml4Q2xzICsgJy1uYXYtY29udGFpbmVyLXNjcm9sbGluZycgOiAnJyksXG4gICAgICAgICAgc3R5bGU6IHByb3BzLnN0eWxlLFxuICAgICAgICAgIHJlZjogJ2NvbnRhaW5lcidcbiAgICAgICAgfSxcbiAgICAgICAgcHJldkJ1dHRvbixcbiAgICAgICAgbmV4dEJ1dHRvbixcbiAgICAgICAgX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctbmF2LXdyYXAnLCByZWY6ICduYXZXcmFwJyB9LFxuICAgICAgICAgIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1uYXYtc2Nyb2xsJyB9LFxuICAgICAgICAgICAgX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogcHJlZml4Q2xzICsgJy1uYXYnLCByZWY6ICduYXYnLCBzdHlsZTogbmF2T2Zmc2V0IH0sXG4gICAgICAgICAgICAgIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KCdkaXYnLCB7IGNsYXNzTmFtZTogaW5rQmFyQ2xhc3MsIHJlZjogJ2lua0JhcicgfSksXG4gICAgICAgICAgICAgIHRhYnNcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICB9XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gTmF2O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS10YWJzL34vcmMtdGFicy9saWIvTmF2LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5mdW5jdGlvbiBfY29tcG9uZW50RGlkVXBkYXRlKGNvbXBvbmVudCkge1xuICB2YXIgcmVmcyA9IGNvbXBvbmVudC5yZWZzO1xuICB2YXIgY29udGFpbmVyTm9kZSA9IHJlZnMubmF2O1xuICB2YXIgY29udGFpbmVyT2Zmc2V0ID0gKDAsIF91dGlscy5vZmZzZXQpKGNvbnRhaW5lck5vZGUpO1xuICB2YXIgaW5rQmFyTm9kZSA9IHJlZnMuaW5rQmFyO1xuICB2YXIgYWN0aXZlVGFiID0gcmVmcy5hY3RpdmVUYWI7XG4gIHZhciB0YWJQb3NpdGlvbiA9IGNvbXBvbmVudC5wcm9wcy50YWJQb3NpdGlvbjtcbiAgaWYgKGFjdGl2ZVRhYikge1xuICAgIHZhciB0YWJOb2RlID0gYWN0aXZlVGFiO1xuICAgIHZhciB0YWJPZmZzZXQgPSAoMCwgX3V0aWxzLm9mZnNldCkodGFiTm9kZSk7XG4gICAgaWYgKHRhYlBvc2l0aW9uID09PSAndG9wJyB8fCB0YWJQb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHZhciBsZWZ0ID0gdGFiT2Zmc2V0LmxlZnQgLSBjb250YWluZXJPZmZzZXQubGVmdDtcbiAgICAgIGlua0Jhck5vZGUuc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnO1xuICAgICAgaW5rQmFyTm9kZS5zdHlsZS50b3AgPSAnJztcbiAgICAgIGlua0Jhck5vZGUuc3R5bGUuYm90dG9tID0gJyc7XG4gICAgICBpbmtCYXJOb2RlLnN0eWxlLnJpZ2h0ID0gY29udGFpbmVyTm9kZS5vZmZzZXRXaWR0aCAtIGxlZnQgLSB0YWJOb2RlLm9mZnNldFdpZHRoICsgJ3B4JztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHRvcCA9IHRhYk9mZnNldC50b3AgLSBjb250YWluZXJPZmZzZXQudG9wO1xuICAgICAgaW5rQmFyTm9kZS5zdHlsZS5sZWZ0ID0gJyc7XG4gICAgICBpbmtCYXJOb2RlLnN0eWxlLnJpZ2h0ID0gJyc7XG4gICAgICBpbmtCYXJOb2RlLnN0eWxlLnRvcCA9IHRvcCArICdweCc7XG4gICAgICBpbmtCYXJOb2RlLnN0eWxlLmJvdHRvbSA9IGNvbnRhaW5lck5vZGUub2Zmc2V0SGVpZ2h0IC0gdG9wIC0gdGFiTm9kZS5vZmZzZXRIZWlnaHQgKyAncHgnO1xuICAgIH1cbiAgfVxuICBpbmtCYXJOb2RlLnN0eWxlLmRpc3BsYXkgPSBhY3RpdmVUYWIgPyAnYmxvY2snIDogJ25vbmUnO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIF9jb21wb25lbnREaWRVcGRhdGUodGhpcyk7XG4gIH0sXG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBfY29tcG9uZW50RGlkVXBkYXRlKHRoaXMpO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS10YWJzL34vcmMtdGFicy9saWIvSW5rQmFyTWl4aW4uanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldFNjcm9sbCA9IGdldFNjcm9sbDtcbmV4cG9ydHMub2Zmc2V0ID0gb2Zmc2V0O1xuZnVuY3Rpb24gZ2V0U2Nyb2xsKHcsIHRvcCkge1xuICB2YXIgcmV0ID0gd1sncGFnZScgKyAodG9wID8gJ1knIDogJ1gnKSArICdPZmZzZXQnXTtcbiAgdmFyIG1ldGhvZCA9ICdzY3JvbGwnICsgKHRvcCA/ICdUb3AnIDogJ0xlZnQnKTtcbiAgaWYgKHR5cGVvZiByZXQgIT09ICdudW1iZXInKSB7XG4gICAgdmFyIGQgPSB3LmRvY3VtZW50O1xuICAgIC8vIGllNiw3LDggc3RhbmRhcmQgbW9kZVxuICAgIHJldCA9IGQuZG9jdW1lbnRFbGVtZW50W21ldGhvZF07XG4gICAgaWYgKHR5cGVvZiByZXQgIT09ICdudW1iZXInKSB7XG4gICAgICAvLyBxdWlya3MgbW9kZVxuICAgICAgcmV0ID0gZC5ib2R5W21ldGhvZF07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9mZnNldChlbGVtKSB7XG4gIHZhciBib3ggPSB2b2lkIDA7XG4gIHZhciB4ID0gdm9pZCAwO1xuICB2YXIgeSA9IHZvaWQgMDtcbiAgdmFyIGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcbiAgdmFyIGJvZHkgPSBkb2MuYm9keTtcbiAgdmFyIGRvY0VsZW0gPSBkb2MgJiYgZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgYm94ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgeCA9IGJveC5sZWZ0O1xuICB5ID0gYm94LnRvcDtcbiAgeCAtPSBkb2NFbGVtLmNsaWVudExlZnQgfHwgYm9keS5jbGllbnRMZWZ0IHx8IDA7XG4gIHkgLT0gZG9jRWxlbS5jbGllbnRUb3AgfHwgYm9keS5jbGllbnRUb3AgfHwgMDtcbiAgdmFyIHcgPSBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgeCArPSBnZXRTY3JvbGwodyk7XG4gIHkgKz0gZ2V0U2Nyb2xsKHcsIHRydWUpO1xuICByZXR1cm4ge1xuICAgIGxlZnQ6IHgsIHRvcDogeVxuICB9O1xufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtdGFicy9+L3JjLXRhYnMvbGliL3V0aWxzLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRvdG9wIENvbXBvbmVudCBmb3IgdXhjb3JlXG4gKiBAYXV0aG9yIGV0ZXJuYXNsa3lcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBVeGNvcmUgVGVhbSwgQWxpbncuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9Ub3RvcCcpO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtdG90b3AvYnVpbGQvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBUb3RvcCBDb21wb25lbnQgZm9yIHV4Y29yZVxuICogQGF1dGhvciBldGVybmFzbGt5XG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgVXhjb3JlIFRlYW0sIEFsaW53LlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG52YXIgY2xhc3NuYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIFRvdG9wID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoVG90b3AsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gVG90b3AocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRvdG9wKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHNob3dUb3RvcDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIFRvdG9wLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICAkKHdpbmRvdykub24oXCJzY3JvbGwudG90b3BcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciB5ID0gd2luZG93LnBhZ2VZT2Zmc2V0ICE9PSB1bmRlZmluZWQgPyB3aW5kb3cucGFnZVlPZmZzZXQgOiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IGRvY3VtZW50LmJvZHkucGFyZW50Tm9kZSB8fCBkb2N1bWVudC5ib2R5KS5zY3JvbGxUb3A7XG4gICAgICAgICAgICBpZiAoeSA+IG1lLnByb3BzLmRpc3RhbmNlICYmICFtZS5zdGF0ZS5zaG93VG90b3ApIHtcbiAgICAgICAgICAgICAgICBtZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHNob3dUb3RvcDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh5IDw9IG1lLnByb3BzLmRpc3RhbmNlICYmIG1lLnN0YXRlLnNob3dUb3RvcCkge1xuICAgICAgICAgICAgICAgIG1lLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgc2hvd1RvdG9wOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgVG90b3AucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIGNsZWFyVGltZW91dChtZS50aW1lcik7XG4gICAgICAgICQod2luZG93KS5vZmYoXCJzY3JvbGwudG90b3BcIik7XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogc2Nyb2xsIG1ldGhvZCB0byBhY3Rpb24gbGlrZSBqUXVlcnkgYW5pbWF0aW9uLlxuICAgICAqIEBwYXJhbSBlbGVtZW50IHtET019IHNjcm9sbCBlbGVtZW50XG4gICAgICogQHBhcmFtIHRvIHtudW1iZXJ9IHRoZSBmaW5hbCBzY3JvbGxUb3AgeW91IHdhbnRcbiAgICAgKiBAcGFyYW0gZHVyYXRpb24ge251bWJlcn0gc2Nyb2xsIGFuaW1hdGlvbiB0aW1lIChtcylcbiAgICAgKi9cblxuICAgIFRvdG9wLnByb3RvdHlwZS5zY3JvbGxUbyA9IGZ1bmN0aW9uIHNjcm9sbFRvKGVsZW1lbnQsIHRvLCBkdXJhdGlvbikge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBpZiAoZHVyYXRpb24gPD0gMCkgcmV0dXJuO1xuICAgICAgICB2YXIgZGlmZmVyZW5jZSA9IHRvIC0gZWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICAgIHZhciBwZXJUaWNrID0gZGlmZmVyZW5jZSAvIGR1cmF0aW9uICogMTA7XG5cbiAgICAgICAgbWUudGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gZWxlbWVudC5zY3JvbGxUb3AgKyBwZXJUaWNrO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQuc2Nyb2xsVG9wID09PSB0bykgcmV0dXJuO1xuICAgICAgICAgICAgbWUuc2Nyb2xsVG8oZWxlbWVudCwgdG8sIGR1cmF0aW9uIC0gMTApO1xuICAgICAgICB9LCAxMCk7XG4gICAgfTtcblxuICAgIFRvdG9wLnByb3RvdHlwZS5oYW5kbGVHb3RvcENsaWNrID0gZnVuY3Rpb24gaGFuZGxlR290b3BDbGljaygpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgbWUuc2Nyb2xsVG8oZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgIT0gMCA/IGRvY3VtZW50LmJvZHkgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIG1lLnByb3BzLnRvLCBtZS5wcm9wcy5kdXJhdGlvbik7XG4gICAgfTtcblxuICAgIFRvdG9wLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBfY2xhc3NuYW1lcywgX2NsYXNzbmFtZXMyO1xuXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBzaG93Q2xzID0gbWUucHJvcHMucHJlZml4Q2xzO1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6IGNsYXNzbmFtZXMoKF9jbGFzc25hbWVzID0ge30sIF9jbGFzc25hbWVzW21lLnByb3BzLnByZWZpeENsc10gPSB0cnVlLCBfY2xhc3NuYW1lc1ttZS5wcm9wcy5jbGFzc05hbWVdID0gISFtZS5wcm9wcy5jbGFzc05hbWUsIF9jbGFzc25hbWVzW21lLnByb3BzLnRoZW1lXSA9ICEhbWUucHJvcHMudGhlbWUsIF9jbGFzc25hbWVzW1wiZm4tY2xlYXJcIl0gPSB0cnVlLCBfY2xhc3NuYW1lcykpIH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdhJywgeyBjbGFzc05hbWU6IGNsYXNzbmFtZXMoe1xuICAgICAgICAgICAgICAgICAgICBcImJ0biBnb3RvcFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBcInNob3dcIjogbWUuc3RhdGUuc2hvd1RvdG9wXG4gICAgICAgICAgICAgICAgfSksIG9uQ2xpY2s6IG1lLmhhbmRsZUdvdG9wQ2xpY2suYmluZChtZSkgfSksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBjbGFzc25hbWVzKChfY2xhc3NuYW1lczIgPSB7fSwgX2NsYXNzbmFtZXMyW21lLnByb3BzLnByZWZpeENscyArIFwiLW90aGVyXCJdID0gdHJ1ZSwgX2NsYXNzbmFtZXMyKSkgfSxcbiAgICAgICAgICAgICAgICBtZS5wcm9wcy5jaGlsZHJlblxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gVG90b3A7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblRvdG9wLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBwcmVmaXhDbHM6ICdrdW1hLXRvdG9wJyxcbiAgICB0bzogMTAsXG4gICAgZHVyYXRpb246IDYwMCxcbiAgICBkaXN0YW5jZTogMzBcbn07XG5cbi8vIGh0dHA6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy9yZXVzYWJsZS1jb21wb25lbnRzLmh0bWxcblRvdG9wLnByb3BUeXBlcyA9IHtcbiAgICBwcmVmaXhDbHM6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgY2xhc3NOYW1lOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHRvOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgIGRpc3RhbmNlOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgIGR1cmF0aW9uOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgIHRoZW1lOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nXG59O1xuXG5Ub3RvcC5kaXNwbGF5TmFtZSA9IFwiVG90b3BcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBUb3RvcDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLXRvdG9wL2J1aWxkL1RvdG9wLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogQGF1dGhvcjpcbiogQHRpbWU6XG4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vVHJhbnNmZXInKTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLXRyYW5zZmVyL2J1aWxkL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBjbGFzc25hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xudmFyIGRlZXBjb3B5ID0gcmVxdWlyZSgnZGVlcGNvcHknKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIFRyYW5zZmVyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoVHJhbnNmZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gVHJhbnNmZXIocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYW5zZmVyKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGNob3NlbjogcHJvcHMuZGF0YS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFpdGVtLmNob3NlbjtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdW5DaG9zZW46IHByb3BzLmRhdGEuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFpdGVtLmNob3NlbjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBUcmFuc2Zlci5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICB9O1xuXG4gICAgVHJhbnNmZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBpZiAoIW1lLl9pc0VxdWFsKG5leHRQcm9wcy5kYXRhLCBtZS5wcm9wcy5kYXRhKSkge1xuICAgICAgICAgICAgbWUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGNob3NlbjogbmV4dFByb3BzLmRhdGEuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIWl0ZW0uY2hvc2VuO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHVuQ2hvc2VuOiBuZXh0UHJvcHMuZGF0YS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFpdGVtLmNob3NlbjtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgVHJhbnNmZXIucHJvdG90eXBlLl9pc0VxdWFsID0gZnVuY3Rpb24gX2lzRXF1YWwoYSwgYikge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYSkgPT0gSlNPTi5zdHJpbmdpZnkoYik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIOaKveWPliBhcnIxIOeahOS4gOmDqOWIhue7mSBhcnIy77yM6L+U5Zue5Y+Y5o2i5ZCO55qE5Lik5Liq5pWw57uEXG4gICAgICogQHBhcmFtIHthcnJheX0gYXJyMVxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGFycjJcbiAgICAgKi9cblxuICAgIFRyYW5zZmVyLnByb3RvdHlwZS5zZWxlY3RJdGVtcyA9IGZ1bmN0aW9uIHNlbGVjdEl0ZW1zKGFycikge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgZGF0YSA9IGRlZXBjb3B5KHRoaXMuc3RhdGUpO1xuICAgICAgICBkYXRhLmNob3Nlbi5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKGFyci5pbmRleE9mKGl0ZW0udmFsdWUpICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBkYXRhLnVuQ2hvc2VuLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoYXJyLmluZGV4T2YoaXRlbS52YWx1ZSkgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpdGVtLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG1lLnNldFN0YXRlKGRhdGEpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiDph43nva7vvIzlj5bmtojmiYDmnInnmoTnlKjmiLfmk43kvZxcbiAgICAgKi9cblxuICAgIFRyYW5zZmVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBtZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBjaG9zZW46IG1lLnByb3BzLmRhdGEuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhaXRlbS5jaG9zZW47XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHVuQ2hvc2VuOiBtZS5wcm9wcy5kYXRhLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhaXRlbS5jaG9zZW47XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgVHJhbnNmZXIucHJvdG90eXBlLmxvY2F0ZUl0ZW0gPSBmdW5jdGlvbiBsb2NhdGVJdGVtKHZhbHVlLCBwb3NpdGlvbikge1xuICAgICAgICB2YXIgZGF0YSA9IG1lLnN0YXRlW3Bvc2l0aW9uXTtcbiAgICAgICAgdmFyIGxlZnRCbG9jayA9IG1lLnJlZnMubGVmdEJsb2NrO1xuICAgICAgICB2YXIgbGVmdEJsb2NrRWwgPSBSZWFjdERPTS5maW5kRE9NTm9kZShsZWZ0QmxvY2spO1xuICAgICAgICB2YXIgcmlnaHRCbG9jayA9IG1lLnJlZnMucmlnaHRCbG9jaztcbiAgICAgICAgdmFyIHJpZ2h0QmxvY2tFbCA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHJpZ2h0QmxvY2spO1xuICAgICAgICB2YXIgaW5kZXggPSB2b2lkIDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGRhdGFbaV0ubmFtZS5pbmRleE9mKHZhbHVlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YVtpXS5rZXl3b3JkcyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleXdvcmRzID0gZGF0YVtpXS5rZXl3b3JkcztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGtleXdvcmRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXl3b3Jkc1tqXS5pbmRleE9mKHZhbHVlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPSB1bmRlZmluZWQpIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSAndW5DaG9zZW4nKSB7XG4gICAgICAgICAgICAgICAgbGVmdEJsb2NrRWwuc2Nyb2xsVG9wID0gMzAgKiBpbmRleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmlnaHRCbG9jay5zY3JvbGxUb3AgPSAzMCAqIGluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIFRyYW5zZmVyLnByb3RvdHlwZS5faGFuZGxlU2VhcmNoSWNvbkNsaWNrID0gZnVuY3Rpb24gX2hhbmRsZVNlYXJjaEljb25DbGljayhwb3NpdGlvbikge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgbGVmdFNlYXJjaCA9IG1lLnJlZnMubGVmdFNlYXJjaDtcbiAgICAgICAgdmFyIHJpZ2h0U2VhcmNoID0gbWUucmVmcy5yaWdodFNlYXJjaDtcbiAgICAgICAgdmFyIHZhbHVlID0gJyc7XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PSBcInVuQ2hvc2VuXCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbGVmdFNlYXJjaC52YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gcmlnaHRTZWFyY2gudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgbWUubG9jYXRlSXRlbSh2YWx1ZSwgcG9zaXRpb24pO1xuICAgIH07XG5cbiAgICBUcmFuc2Zlci5wcm90b3R5cGUuX2hhbmRsZVNlYXJjaCA9IGZ1bmN0aW9uIF9oYW5kbGVTZWFyY2gocG9zaXRpb24sIGUpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIGxlZnRTZWFyY2ggPSBtZS5yZWZzLmxlZnRTZWFyY2g7XG4gICAgICAgIHZhciByaWdodFNlYXJjaCA9IG1lLnJlZnMucmlnaHRTZWFyY2g7XG4gICAgICAgIHZhciB2YWx1ZSA9ICcnO1xuICAgICAgICBpZiAoZS5rZXlDb2RlID09IDEzKSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gXCJ1bkNob3NlblwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsZWZ0U2VhcmNoLnZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHJpZ2h0U2VhcmNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWUubG9jYXRlSXRlbSh2YWx1ZSwgcG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFRyYW5zZmVyLnByb3RvdHlwZS5fY2hhbmdlQ2hvc2VuRGF0YSA9IGZ1bmN0aW9uIF9jaGFuZ2VDaG9zZW5EYXRhKGFycjEsIGFycjIpIHtcbiAgICAgICAgdmFyIG5ld0FycjEgPSBhcnIxLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuICFpdGVtLnNlbGVjdGVkO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG5ld0FycjIgPSBhcnIxLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uc2VsZWN0ZWQ7XG4gICAgICAgIH0pLm1hcChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgIGl0ZW0uY2hvc2VuID0gIWl0ZW0uY2hvc2VuO1xuICAgICAgICAgICAgaXRlbS5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaXRlbS5qdXN0TW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH0pLmNvbmNhdChhcnIyKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXJyMTogbmV3QXJyMSxcbiAgICAgICAgICAgIGFycjI6IG5ld0FycjJcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgVHJhbnNmZXIucHJvdG90eXBlLl9oYW5kbGVJdGVtQ2xpY2sgPSBmdW5jdGlvbiBfaGFuZGxlSXRlbUNsaWNrKGUpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgaWYgKG1lLnByb3BzLmRpc2FibGVkKSByZXR1cm47XG4gICAgICAgIHZhciB0YXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgIG1lLl9yZW1vdmVKdXN0TW92ZWQoZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgdmFyIGtleSA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEta2V5Jyk7XG4gICAgICAgICAgICB2YXIgaXNDaG9zZW4gPSBKU09OLnBhcnNlKHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtY2hvc2VuJykpO1xuICAgICAgICAgICAgdmFyIG5ld0RhdGEgPSBkZWVwY29weShtZS5zdGF0ZVtpc0Nob3NlbiA/ICdjaG9zZW4nIDogJ3VuQ2hvc2VuJ10pO1xuICAgICAgICAgICAgbmV3RGF0YVtrZXldLnNlbGVjdGVkID0gIW5ld0RhdGFba2V5XS5zZWxlY3RlZDtcbiAgICAgICAgICAgIHZhciBuZXdTdGF0ZSA9IHt9O1xuICAgICAgICAgICAgbmV3U3RhdGVbaXNDaG9zZW4gPyAnY2hvc2VuJyA6ICd1bkNob3NlbiddID0gbmV3RGF0YTtcbiAgICAgICAgICAgIG1lLnNldFN0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgfS5iaW5kKG1lLCB0YXJnZXQpKTtcbiAgICB9O1xuXG4gICAgVHJhbnNmZXIucHJvdG90eXBlLl9yZW1vdmVKdXN0TW92ZWQgPSBmdW5jdGlvbiBfcmVtb3ZlSnVzdE1vdmVkKGNiKSB7XG4gICAgICAgIHZhciBkYXRhID0gZGVlcGNvcHkodGhpcy5zdGF0ZSk7XG4gICAgICAgIGRhdGEuY2hvc2VuLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICBpdGVtLmp1c3RNb3ZlZCA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgZGF0YS51bkNob3Nlbi5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgaXRlbS5qdXN0TW92ZWQgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1lLnNldFN0YXRlKGRhdGEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICEhY2IgJiYgY2IoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIFRyYW5zZmVyLnByb3RvdHlwZS5faGFuZGxlQnV0dG9uQ2xpY2sgPSBmdW5jdGlvbiBfaGFuZGxlQnV0dG9uQ2xpY2soZSkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBpZiAobWUucHJvcHMuZGlzYWJsZWQpIHJldHVybjtcbiAgICAgICAgdmFyIHRhcmdldCA9IGUuY3VycmVudFRhcmdldDtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGlyZWN0aW9uJyk7XG4gICAgICAgIGlmICh0YXJnZXQuY2xhc3NOYW1lLmluZGV4T2YoJ2VuYWJsZScpID09IC0xKSByZXR1cm47XG4gICAgICAgIHZhciBvbGRDaG9zZW4gPSBkZWVwY29weShtZS5zdGF0ZVsnY2hvc2VuJ10pO1xuICAgICAgICB2YXIgb2xkVW5DaG9zZW4gPSBkZWVwY29weShtZS5zdGF0ZVsndW5DaG9zZW4nXSk7XG4gICAgICAgIHZhciBuZXdDaG9zZW4gPSBbXTtcbiAgICAgICAgdmFyIG5ld1VuQ2hvc2VuID0gW107XG4gICAgICAgIHZhciBuZXdEYXRhID0ge307XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICBuZXdEYXRhID0gbWUuX2NoYW5nZUNob3NlbkRhdGEob2xkQ2hvc2VuLCBvbGRVbkNob3Nlbik7XG4gICAgICAgICAgICBuZXdDaG9zZW4gPSBuZXdEYXRhLmFycjE7XG4gICAgICAgICAgICBuZXdVbkNob3NlbiA9IG5ld0RhdGEuYXJyMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0RhdGEgPSBtZS5fY2hhbmdlQ2hvc2VuRGF0YShvbGRVbkNob3Nlbiwgb2xkQ2hvc2VuKTtcbiAgICAgICAgICAgIG5ld1VuQ2hvc2VuID0gbmV3RGF0YS5hcnIxO1xuICAgICAgICAgICAgbmV3Q2hvc2VuID0gbmV3RGF0YS5hcnIyO1xuICAgICAgICB9XG5cbiAgICAgICAgbWUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgY2hvc2VuOiBuZXdDaG9zZW4sXG4gICAgICAgICAgICB1bkNob3NlbjogbmV3VW5DaG9zZW5cbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbWUucHJvcHMub25DaGFuZ2UobWUuc3RhdGUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgVHJhbnNmZXIucHJvdG90eXBlLl9yZW5kZXJJdGVtID0gZnVuY3Rpb24gX3JlbmRlckl0ZW0oaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgd2luZG93Lm1lID0gbWU7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2xpJyxcbiAgICAgICAgICAgIHsga2V5OiBpbmRleCwgJ2RhdGEta2V5JzogaW5kZXgsICdkYXRhLXZhbHVlJzogaXRlbS52YWx1ZSwgJ2RhdGEtY2hvc2VuJzogaXRlbS5jaG9zZW4sIG9uQ2xpY2s6IG1lLl9oYW5kbGVJdGVtQ2xpY2suYmluZChtZSkgfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBjbGFzc25hbWVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic2VsZWN0ZWRcIjogISFpdGVtLnNlbGVjdGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJqdXN0TW92ZWRcIjogISFpdGVtLmp1c3RNb3ZlZFxuICAgICAgICAgICAgICAgICAgICB9KSwgaHJlZjogJ2phdmFzY3JpcHQ6OycsIHRpdGxlOiBpdGVtLmRlc2NyaXB0aW9uIH0sXG4gICAgICAgICAgICAgICAgaXRlbS5uYW1lXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIFRyYW5zZmVyLnByb3RvdHlwZS5fcmVuZGVyVW5jaG9zZW4gPSBmdW5jdGlvbiBfcmVuZGVyVW5jaG9zZW4oKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBhcnIgPSBtZS5zdGF0ZS51bkNob3Nlbi5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiAhaXRlbS5jaG9zZW47XG4gICAgICAgIH0pLm1hcChtZS5fcmVuZGVySXRlbS5iaW5kKG1lKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfTtcblxuICAgIFRyYW5zZmVyLnByb3RvdHlwZS5fcmVuZGVyQ2hvc2VuID0gZnVuY3Rpb24gX3JlbmRlckNob3NlbigpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIGFyciA9IG1lLnN0YXRlLmNob3Nlbi5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmNob3NlbjtcbiAgICAgICAgfSkubWFwKG1lLl9yZW5kZXJJdGVtLmJpbmQobWUpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9O1xuXG4gICAgVHJhbnNmZXIucHJvdG90eXBlLl9yZW5kZXJTZWFyY2ggPSBmdW5jdGlvbiBfcmVuZGVyU2VhcmNoKHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIGlmICghbWUucHJvcHMuc2hvd1NlYXJjaCkgcmV0dXJuO1xuICAgICAgICB2YXIgbWFwID0ge1xuICAgICAgICAgICAgXCJ1bkNob3NlblwiOiBcImxlZnRTZWFyY2hcIixcbiAgICAgICAgICAgIFwiY2hvc2VuXCI6IFwicmlnaHRTZWFyY2hcIlxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdzZWFyY2hCYXInIH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdpbnB1dCcsIHsgdHlwZTogJ3RleHQnLCByZWY6IG1hcFtwb3NpdGlvbl0sIGNsYXNzTmFtZTogJ2t1bWEtaW5wdXQnLCBwbGFjZWhvbGRlcjogbWUucHJvcHMuc2VhcmNoUGxhY2Vob2xkZXIsIG9uS2V5RG93bjogbWUuX2hhbmRsZVNlYXJjaC5iaW5kKG1lLCBwb3NpdGlvbikgfSksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdpJywgeyBjbGFzc05hbWU6ICdrdW1hLWljb24ga3VtYS1pY29uLXNlYXJjaCcsIG9uQ2xpY2s6IG1lLl9oYW5kbGVTZWFyY2hJY29uQ2xpY2suYmluZChtZSwgcG9zaXRpb24pIH0pXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIFRyYW5zZmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogY2xhc3NuYW1lcyh7XG4gICAgICAgICAgICAgICAgICAgIFwidXhUcmFuc2ZlclwiOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBcImRpc2FibGVkXCI6IG1lLnByb3BzLmRpc2FibGVkXG4gICAgICAgICAgICAgICAgfSkgfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ3RhYmxlJyxcbiAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2t1bWEtdXh0cmFuc2Zlci1jb250YWluZXInIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgJ3RoZWFkJyxcbiAgICAgICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdrdW1hLXV4dHJhbnNmZXItaGVhZCcgfSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cicsXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnZm4tY2xlYXIgbGVmdC1oZWFkJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICd0aXRsZScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUucHJvcHMubGVmdFRpdGxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5fcmVuZGVyU2VhcmNoKFwidW5DaG9zZW5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0aCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnwqAnXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnZm4tY2xlYXIgcmlnaHQtaGVhZCcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAndGl0bGUnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLnByb3BzLnJpZ2h0VGl0bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLl9yZW5kZXJTZWFyY2goXCJjaG9zZW5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgJ3Rib2R5JyxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cicsXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnbGVmdC1ibG9jaycgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHJlZjogJ2xlZnRCbG9jaycsIGNsYXNzTmFtZTogY2xhc3NuYW1lcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJrdW1hLXV4dHJhbnNmZXItYmxvY2tcIjogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUuX3JlbmRlclVuY2hvc2VuKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAna3VtYS11eHRyYW5zZmVyLWJ1dHRvbnMnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnYScsIHsgaHJlZjogJ2phdmFzY3JpcHQ6OycsICdkYXRhLWRpcmVjdGlvbic6ICdsZWZ0JywgY2xhc3NOYW1lOiBjbGFzc25hbWVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZTogbWUuc3RhdGUuY2hvc2VuLnNvbWUoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gISFpdGVtLnNlbGVjdGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgJiYgIW1lLnByb3BzLmRpc2FibGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBvbkNsaWNrOiBtZS5faGFuZGxlQnV0dG9uQ2xpY2suYmluZChtZSkgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnYnInLCBudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdhJywgeyBocmVmOiAnamF2YXNjcmlwdDo7JywgJ2RhdGEtZGlyZWN0aW9uJzogJ3JpZ2h0JywgY2xhc3NOYW1lOiBjbGFzc25hbWVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZTogbWUuc3RhdGUudW5DaG9zZW4uc29tZShmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhIWl0ZW0uc2VsZWN0ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSAmJiAhbWUucHJvcHMuZGlzYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIG9uQ2xpY2s6IG1lLl9oYW5kbGVCdXR0b25DbGljay5iaW5kKG1lKSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ3JpZ2h0LWJsb2NrJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd1bCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgcmVmOiAncmlnaHRCbG9jaycsIGNsYXNzTmFtZTogY2xhc3NuYW1lcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJrdW1hLXV4dHJhbnNmZXItYmxvY2tcIjogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUuX3JlbmRlckNob3NlbigpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gVHJhbnNmZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblRyYW5zZmVyLmRpc3BsYXlOYW1lID0gXCJUcmFuc2ZlclwiO1xuVHJhbnNmZXIuZGVmYXVsdFByb3BzID0ge1xuICAgIHNlYXJjaFBsYWNlaG9sZGVyOiAn5a6a5L2N6L6T5YWl5YaF5a65JyxcbiAgICBkYXRhOiBbXSxcbiAgICBsZWZ0VGl0bGU6ICfmnKrpgInkuK0nLFxuICAgIHJpZ2h0VGl0bGU6ICflt7LpgInkuK0nLFxuICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICBzaG93U2VhcmNoOiB0cnVlLFxuICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZSgpIHt9XG59O1xuVHJhbnNmZXIucHJvcFR5cGVzID0ge1xuICAgIHNlYXJjaFBsYWNlaG9sZGVyOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIGRhdGE6IFJlYWN0LlByb3BUeXBlcy5hcnJheSxcbiAgICBkaXNhYmxlZDogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgc2hvd1NlYXJjaDogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgbGVmdFRpdGxlOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHJpZ2h0VGl0bGU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgb25DaGFuZ2U6IFJlYWN0LlByb3BUeXBlcy5mdW5jXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZmVyO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtdHJhbnNmZXIvYnVpbGQvVHJhbnNmZXIuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9VcGxvYWRlcicpO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtdXBsb2FkZXIvYnVpbGQvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCd1cGxvYWRjb3JlJyk7XG5cbnZhciBVcGxvYWRDb3JlID0gX3JlcXVpcmUuVXBsb2FkQ29yZTtcbnZhciBFdmVudHMgPSBfcmVxdWlyZS5FdmVudHM7XG52YXIgU3RhdHVzID0gX3JlcXVpcmUuU3RhdHVzO1xuXG52YXIgUHJvZ3Jlc3MgPSByZXF1aXJlKCcuL1Byb2dyZXNzJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgRmlsZUxpc3QgPSByZXF1aXJlKFwiLi9GaWxlTGlzdFwiKTtcbnZhciBQaWNrZXIgPSByZXF1aXJlKFwiLi9QaWNrZXJcIik7XG52YXIgaTE4biA9IHJlcXVpcmUoXCIuL2xvY2FsZVwiKTtcblxuVXBsb2FkQ29yZS5zZXRTV0YoJ2h0dHBzOi8vYWxpbncuYWxpY2RuLmNvbS9hbGludy91eHVwbG9hZGVyLzIuMC4xL2ZsYXNocGlja2VyLnN3ZicpO1xuXG52YXIgQ09SRV9JTlNUQU5DRSA9IHt9O1xuZnVuY3Rpb24gZ2V0Q29yZUluc3RhbmNlKHByb3BzLCBhdXRvUGVuZGluZykge1xuICAgIHZhciBjb3JlID0gcHJvcHMuY29yZTtcbiAgICBpZiAoY29yZSBpbnN0YW5jZW9mIFVwbG9hZENvcmUpIHtcbiAgICAgICAgcmV0dXJuIGNvcmU7XG4gICAgfVxuXG4gICAgdmFyIGlkID0gY29yZTtcbiAgICBpZiAoaWQgJiYgdHlwZW9mIGlkID09PSAnc3RyaW5nJyAmJiBDT1JFX0lOU1RBTkNFLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICByZXR1cm4gQ09SRV9JTlNUQU5DRVtpZF07XG4gICAgfVxuXG4gICAgdmFyIG9wdGlvbnMgPSBwcm9wcy5vcHRpb25zIHx8IHt9O1xuICAgIFsnbmFtZScsICd1cmwnLCAncGFyYW1zJywgJ2FjdGlvbicsICdkYXRhJywgJ2hlYWRlcnMnLCAnd2l0aENyZWRlbnRpYWxzJywgJ3RpbWVvdXQnLCAnY2h1bmtFbmFibGUnLCAnY2h1bmtTaXplJywgJ2NodW5rUmV0cmllcycsICdjaHVua1Byb2Nlc3NUaHJlYWRzJywgJ3Byb2Nlc3NUaHJlYWRzJywgJ3F1ZXVlQ2FwY2l0eScsICdhdXRvUGVuZGluZycsICdtdWx0aXBsZScsICdhY2NlcHQnLCAnc2l6ZUxpbWl0JywgJ3ByZXZlbnREdXBsaWNhdGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIG9wdGlvbnNba2V5XSA9IHByb3BzW2tleV07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoYXV0b1BlbmRpbmcgIT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zLmF1dG9QZW5kaW5nID0gYXV0b1BlbmRpbmc7XG4gICAgfVxuXG4gICAgY29yZSA9IG5ldyBVcGxvYWRDb3JlKG9wdGlvbnMpO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICB2YXIgbSA9IC9eb24oXFx3KykkL2kuZXhlYyhrZXkpO1xuICAgICAgICAgICAgaWYgKCFtKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcHNba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvcmUub24obVsxXSwgcHJvcHNba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaWQpIHtcbiAgICAgICAgQ09SRV9JTlNUQU5DRVtpZF0gPSBjb3JlO1xuICAgIH1cblxuICAgIHJldHVybiBjb3JlO1xufVxuXG52YXIgVXBsb2FkZXIgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhVcGxvYWRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBVcGxvYWRlcihwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVXBsb2FkZXIpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgICAgIF90aGlzLmNvcmUgPSBnZXRDb3JlSW5zdGFuY2UoX3RoaXMucHJvcHMsIHRydWUpO1xuXG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgdG90YWw6IF90aGlzLmNvcmUuZ2V0VG90YWwoKVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBzdGF0Y2hhbmdlID0gZnVuY3Rpb24gc3RhdGNoYW5nZShzdGF0KSB7XG4gICAgICAgICAgICB2YXIgdG90YWwgPSBzdGF0LmdldFRvdGFsKCk7XG4gICAgICAgICAgICBpZiAodG90YWwgIT09IF90aGlzLnN0YXRlLnRvdGFsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyB0b3RhbDogdG90YWwgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmNvcmUub24oRXZlbnRzLlFVRVVFX1NUQVRfQ0hBTkdFLCBzdGF0Y2hhbmdlKTtcbiAgICAgICAgX3RoaXMuc3RvcExpc3RlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmNvcmUub2ZmKEV2ZW50cy5RVUVVRV9TVEFUX0NIQU5HRSwgc3RhdGNoYW5nZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBVcGxvYWRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy5zdG9wTGlzdGVuICYmIHRoaXMuc3RvcExpc3RlbigpO1xuICAgIH07XG5cbiAgICBVcGxvYWRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgdGhpcy5jb3JlLmdldEZpbGVzKCkuZm9yRWFjaChmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICAgICAgZmlsZS5jYW5jZWwoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIFVwbG9hZGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBfcHJvcHMuY2hpbGRyZW47XG4gICAgICAgIHZhciBsb2NhbGUgPSBfcHJvcHMubG9jYWxlO1xuXG4gICAgICAgIGlmICghY2hpbGRyZW4gfHwgY2hpbGRyZW4ubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgY2hpbGRyZW4gPSBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICdidXR0b24nLFxuICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAna3VtYS11cGxvYWQtYnV0dG9uJyB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2knLCB7IGNsYXNzTmFtZTogJ2t1bWEtaWNvbiBrdW1hLWljb24tdXBsb2FkaW5nJyB9KSxcbiAgICAgICAgICAgICAgICBpMThuW2xvY2FsZV1bJ3VwbG9hZF9maWxlcyddXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogXCJrdW1hLXVwbG9hZGVyIFwiICsgKHRoaXMucHJvcHMuY2xhc3NOYW1lIHx8ICcnKSB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICBQaWNrZXIsXG4gICAgICAgICAgICAgICAgeyBjb3JlOiB0aGlzLmNvcmUgfSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHRoaXMucHJvcHMudGlwcyxcbiAgICAgICAgICAgIHRoaXMuc3RhdGUudG90YWwgPiAwID8gUmVhY3QuY3JlYXRlRWxlbWVudChGaWxlTGlzdCwgeyBsb2NhbGU6IHRoaXMucHJvcHMubG9jYWxlLCBjb3JlOiB0aGlzLmNvcmUsIG1vZGU6ICdudycgfSkgOiBudWxsXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHJldHVybiBVcGxvYWRlcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxudmFyIERyb3B6b29tID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQyKSB7XG4gICAgX2luaGVyaXRzKERyb3B6b29tLCBfUmVhY3QkQ29tcG9uZW50Mik7XG5cbiAgICBmdW5jdGlvbiBEcm9wem9vbShwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHJvcHpvb20pO1xuXG4gICAgICAgIHZhciBfdGhpczIgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50Mi5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICAgICAgX3RoaXMyLmNvcmUgPSBnZXRDb3JlSW5zdGFuY2UoX3RoaXMyLnByb3BzKTtcblxuICAgICAgICBfdGhpczIuc3RhdGUgPSB7XG4gICAgICAgICAgICBibGluazogMCxcbiAgICAgICAgICAgIGhpZ2hsaWdodDogMCxcbiAgICAgICAgICAgIHRvdGFsOiBfdGhpczIuY29yZS5nZXRUb3RhbCgpXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHN0YXRjaGFuZ2UgPSBmdW5jdGlvbiBzdGF0Y2hhbmdlKHN0YXQpIHtcbiAgICAgICAgICAgIHZhciB0b3RhbCA9IHN0YXQuZ2V0VG90YWwoKTtcbiAgICAgICAgICAgIGlmICh0b3RhbCAhPT0gX3RoaXMyLnN0YXRlLnRvdGFsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMyLnNldFN0YXRlKHsgdG90YWw6IHRvdGFsIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpczIuY29yZS5vbihFdmVudHMuUVVFVUVfU1RBVF9DSEFOR0UsIHN0YXRjaGFuZ2UpO1xuICAgICAgICBfdGhpczIuc3RvcExpc3RlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMi5jb3JlLm9mZihFdmVudHMuUVVFVUVfU1RBVF9DSEFOR0UsIHN0YXRjaGFuZ2UpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXMyO1xuICAgIH1cblxuICAgIERyb3B6b29tLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICB0aGlzLmNvcmUuZ2V0RmlsZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgICAgICBmaWxlLmNhbmNlbCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgRHJvcHpvb20ucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBhcmVhTm9kZSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpO1xuXG4gICAgICAgIHZhciBkbmRBcmVhID0gdGhpcy5jb3JlLmdldERuZENvbGxlY3RvcigpLmFkZEFyZWEoYXJlYU5vZGUpO1xuICAgICAgICBkbmRBcmVhLm9uKCdzdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5zZXRTdGF0ZSh7IGJsaW5rOiAxIH0pO1xuICAgICAgICB9KS5vbigncmVzcG9uc2UnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGFyZWFOb2RlLmNvbnRhaW5zKGUudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIF90aGlzMy5zZXRTdGF0ZSh7IGhpZ2hsaWdodDogMSB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMzLnNldFN0YXRlKHsgaGlnaGxpZ2h0OiAwIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnNldFN0YXRlKHsgYmxpbms6IDAsIGhpZ2hsaWdodDogMCB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZG5kQXJlYSA9IGRuZEFyZWE7XG4gICAgfTtcblxuICAgIERyb3B6b29tLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB0aGlzLmRuZEFyZWEgJiYgdGhpcy5kbmRBcmVhLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5zdG9wTGlzdGVuICYmIHRoaXMuc3RvcExpc3RlbigpO1xuICAgIH07XG5cbiAgICBEcm9wem9vbS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gXCJrdW1hLXVwbG9hZGVyIGt1bWEtdXBsb2FkLWRyb3B6b29tXCI7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmNsYXNzTmFtZSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lICs9ICcgJyArIHRoaXMucHJvcHMuY2xhc3NOYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmJsaW5rKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgKz0gJyBibGluayc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuaGlnaGxpZ2h0KSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgKz0gJyBlbnRlcic7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgaWYgKCFjaGlsZHJlbiB8fCBjaGlsZHJlbi5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICBjaGlsZHJlbiA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2knLCB7IGNsYXNzTmFtZTogJ2t1bWEtaWNvbiBrdW1hLWljb24tYWRkJyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6IGNsYXNzTmFtZSB9LFxuICAgICAgICAgICAgdGhpcy5zdGF0ZS50b3RhbCA+IDAgPyBSZWFjdC5jcmVhdGVFbGVtZW50KEZpbGVMaXN0LCB7IGxvY2FsZTogdGhpcy5wcm9wcy5sb2NhbGUsIGNvcmU6IHRoaXMuY29yZSwgbW9kZTogJ2ljb24nIH0pIDogUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICBQaWNrZXIsXG4gICAgICAgICAgICAgICAgeyBjb3JlOiB0aGlzLmNvcmUgfSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2RpdicsIHsgY2xhc3NOYW1lOiAna3VtYS11cGxvYWQtcmVzcG9uc2VyJyB9KVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gRHJvcHpvb207XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblVwbG9hZGVyLkRyb3B6b29tID0gRHJvcHpvb207XG5cblVwbG9hZGVyLkV2ZW50cyA9IEV2ZW50cztcblVwbG9hZGVyLlN0YXR1cyA9IFN0YXR1cztcblVwbG9hZGVyLnNldFNXRiA9IGZ1bmN0aW9uIChzd2YpIHtcbiAgICBVcGxvYWRDb3JlLnNldFNXRihzd2YpO1xufTtcblxuVXBsb2FkZXIuZGlzcGxheU5hbWUgPSBcIlVwbG9hZGVyXCI7XG5cblVwbG9hZGVyLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBsb2NhbGU6ICd6aC1jbidcbn07XG5cblVwbG9hZGVyLnByb3BUeXBlcyA9IHtcbiAgICBsb2NhbGU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmdcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVXBsb2FkZXI7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS11cGxvYWRlci9idWlsZC9VcGxvYWRlci5qc1xuICoqLyIsIiFmdW5jdGlvbihlLHQpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXQoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtdLHQpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2V4cG9ydHMuVXBsb2FkQ29yZT10KCk6ZS5VcGxvYWRDb3JlPXQoKX0odGhpcyxmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlKXtmdW5jdGlvbiB0KHIpe2lmKG5bcl0pcmV0dXJuIG5bcl0uZXhwb3J0czt2YXIgaT1uW3JdPXtleHBvcnRzOnt9LGlkOnIsbG9hZGVkOiExfTtyZXR1cm4gZVtyXS5jYWxsKGkuZXhwb3J0cyxpLGkuZXhwb3J0cyx0KSxpLmxvYWRlZD0hMCxpLmV4cG9ydHN9dmFyIG49e307cmV0dXJuIHQubT1lLHQuYz1uLHQucD1cIlwiLHQoMCl9KFtmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigxKSxpPW4oNCksbz1uKDUpLHM9by5TdGF0dXM7ci5FdmVudHM9aSxyLlN0YXR1cz1zLHIuVXBsb2FkQ29yZT1yLHIuVkVSU0lPTj1cIjIuMi4zXCIsci5Db3JlPXIsZS5leHBvcnRzPXJ9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBpKGUsdCl7aWYoIWUpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiF0fHxcIm9iamVjdFwiIT10eXBlb2YgdCYmXCJmdW5jdGlvblwiIT10eXBlb2YgdD9lOnR9ZnVuY3Rpb24gbyhlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJm51bGwhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiB0KTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx0JiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihlLHQpOmUuX19wcm90b19fPXQpfXZhciBzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcj10W25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLmtleSxyKX19cmV0dXJuIGZ1bmN0aW9uKHQsbixyKXtyZXR1cm4gbiYmZSh0LnByb3RvdHlwZSxuKSxyJiZlKHQsciksdH19KCksdT1uKDIpLGE9big0KSxjPW4oNSksbD1jLlN0YXR1cyxmPW4oNiksaD1mLlF1ZXVlTGltaXRFcnJvcixwPWYuRmlsdGVyRXJyb3Isdj1mLkR1cGxpY2F0ZUVycm9yLGQ9Zi5GaWxlRXh0ZW5zaW9uRXJyb3IseT1mLkZpbGVTaXplRXJyb3IsbT1uKDMpLGc9bS5mb3JtYXRTaXplLGs9bS5wYXJzZVNpemUsYj1tLm5vcm1hbGl6ZUFjY2VwdCxFPW4oNyksdz1uKDgpLF89bigxMyksUD1uKDE0KSxPPVtcIm5hbWVcIixcInVybFwiLFwicGFyYW1zXCIsXCJhY3Rpb25cIixcImRhdGFcIixcImhlYWRlcnNcIixcIndpdGhDcmVkZW50aWFsc1wiLFwidGltZW91dFwiLFwiY2h1bmtFbmFibGVcIixcImNodW5rU2l6ZVwiLFwiY2h1bmtSZXRyaWVzXCIsXCJjaHVua1Byb2Nlc3NUaHJlYWRzXCJdLFI9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg8PTB8fHZvaWQgMD09PWFyZ3VtZW50c1swXT97fTphcmd1bWVudHNbMF07cih0aGlzLHQpO3ZhciBuPWkodGhpcyxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCkuY2FsbCh0aGlzKSk7bi5hdXRvUGVuZGluZz1lLmF1dG9QZW5kaW5nfHxlLmF1dG8sbi5jYXBjaXR5PWUuY2FwY2l0eXx8ZS5xdWV1ZUNhcGNpdHl8fDAsbi5tdWx0aXBsZT1udWxsPT1lLm11bHRpcGxlPyEwOmUubXVsdGlwbGUsbi5hY2NlcHQ9YihlLmFjY2VwdCksbi5zaXplTGltaXQ9ayhlLnNpemVMaW1pdHx8ZS5maWxlU2l6ZUxpbWl0fHwwKSxuLnBlbmRpbmc9bmV3IEEoZS5wcm9jZXNzVGhyZWFkcyksbi5zdGF0PW5ldyBMLG4uY29uc3RyYWludHM9bmV3IFMsbi5maWx0ZXJzPW5ldyBULG4ubXVsdGlwbGV8fChuLmNhcGNpdHk9MSksbi5jYXBjaXR5PjAmJm4uYWRkQ29uc3RyYWludChmdW5jdGlvbigpe3JldHVybiBuLnN0YXQuZ2V0VG90YWwoKT49bi5jYXBjaXR5fSksbi5hY2NlcHQmJm4uYWNjZXB0Lmxlbmd0aD4wJiZuLmFkZEZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gbi5hY2NlcHQuc29tZShmdW5jdGlvbih0KXtyZXR1cm4gdC5leHRlbnNpb25zJiZ0LmV4dGVuc2lvbnMuaW5kZXhPZihlLmV4dCk+LTF9KT92b2lkIDA6bmV3IGQoZSwnZXh0ZW5zaW9uIFwiJytlLmV4dCsnXCIgaXMgbm90IGFsbG93ZWQnKX0pLG4uc2l6ZUxpbWl0PjAmJm4uYWRkRmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBlLnNpemU+bi5zaXplTGltaXQ/bmV3IHkoZSxcImZpbGVzaXplOlwiK2coZS5zaXplKStcIiBpcyBncmVhdGVyIHRoYW4gbGltaXQ6XCIrZyhuLnNpemVMaW1pdCkpOnZvaWQgMH0pLGUucHJldmVudER1cGxpY2F0ZSYmbi5hZGRGaWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIG4uc3RhdC5nZXRGaWxlcygpLnNvbWUoZnVuY3Rpb24odCl7cmV0dXJuIHQubmFtZT09PWUubmFtZSYmdC5zaXplPT09ZS5zaXplfSk/bmV3IHYoZSwnZmlsZSBcIicrZS5uYW1lKydcIiBhbHJlYWR5IGluIHF1ZXVlJyk6dm9pZCAwfSksQXJyYXkuaXNBcnJheShlLmZpbHRlcnMpJiZlLmZpdGxlcnMuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gbi5hZGRGaWx0ZXIoZSl9KTt2YXIgbz1lLnJlcXVlc3R8fHt9O3JldHVybiBPLmZvckVhY2goZnVuY3Rpb24odCl7ZS5oYXNPd25Qcm9wZXJ0eSh0KSYmKG9bdF09ZVt0XSl9KSxuLnJlcXVlc3RPcHRpb25zPW8sbn1yZXR1cm4gbyh0LGUpLHModCxbe2tleTpcImNyZWF0ZUZpbGVSZXF1ZXN0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBFKGUsdGhpcy5yZXF1ZXN0T3B0aW9ucyl9fSx7a2V5OlwiaXNMaW1pdFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RyYWludHMuc29tZSgpfX0se2tleTpcImFkZENvbnN0cmFpbnRcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5jb25zdHJhaW50cy5hZGQoZSl9fSx7a2V5OlwiYWRkRmlsdGVyXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZmlsdGVycy5hZGQoZSl9fSx7a2V5OlwiYWRkXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztpZih0aGlzLmlzTGltaXQoKSlyZXR1cm4gdGhpcy5lbWl0KGEuUVVFVUVfRVJST1IsbmV3IGgpLC0xO3ZhciBuPXRoaXMuZmlsdGVycy5maWx0ZXIoZSk7cmV0dXJuIG58fHRoaXMuc3RhdC5hZGQoZSl8fChuPW5ldyB2KGUsJ2ZpbGUgXCInK2UubmFtZSsnXCIgYWxyZWFkeSBpbiBxdWV1ZScpKSxuPyh0aGlzLmVtaXQoYS5RVUVVRV9GSUxFX0ZJTFRFUkVELGUsbiksdGhpcy5lbWl0KGEuUVVFVUVfRVJST1IsbiksMCk6KGUuc2V0U3RhdHVzKGwuUVVFVUVEKSxlLm9uKGEuRklMRV9TVEFUVVNfQ0hBTkdFLGZ1bmN0aW9uKG4pe249PT1sLkNBTkNFTExFRD90LnN0YXQucmVtb3ZlKGUpOm49PT1sLlBFTkRJTkcmJnNldFRpbWVvdXQoZnVuY3Rpb24oKXt0LnBlbmRpbmcuYWRkKGUpJiYxPT09dC5wZW5kaW5nLnNpemUoKSYmdC5lbWl0KGEuUVVFVUVfVVBMT0FEX1NUQVJUKX0sMSksdC5lbWl0KGEuUVVFVUVfU1RBVF9DSEFOR0UsdC5zdGF0KSx0LnN0YXQuZ2V0RmlsZXMobC5QUk9DRVNTKS5sZW5ndGg8MSYmdC5lbWl0KGEuUVVFVUVfVVBMT0FEX0VORCl9KSxlLnNldENvcmUodGhpcyksdGhpcy5lbWl0KGEuUVVFVUVfRklMRV9BRERFRCxlKSx0aGlzLmVtaXQoYS5RVUVVRV9TVEFUX0NIQU5HRSx0aGlzLnN0YXQpLHRoaXMuYXV0b1BlbmRpbmcmJmUucGVuZGluZygpLDEpfX0se2tleTpcImlzTXVsdGlwbGVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm11bHRpcGxlfX0se2tleTpcImlzRnVsbFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2FwY2l0eT4wJiZ0aGlzLmdldFRvdGFsKCk+PXRoaXMuY2FwY2l0eX19LHtrZXk6XCJpc0VtcHR5XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRUb3RhbCgpPDF9fSx7a2V5OlwiZ2V0QWNjZXB0XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hY2NlcHR9fSx7a2V5OlwiZ2V0U3RhdFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RhdH19LHtrZXk6XCJnZXRUb3RhbFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0U3RhdCgpLmdldFRvdGFsKCl9fSx7a2V5OlwiZ2V0RmlsZXNcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5nZXRTdGF0KCkuZ2V0RmlsZXMoZSl9fSx7a2V5Olwic3RhdFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmdldFN0YXQoKS5zdGF0KGUpfX0se2tleTpcImdldFBpY2tlckNvbGxlY3RvclwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGlja2VyfHwodGhpcy5waWNrZXI9bmV3IFAodGhpcykpLHRoaXMucGlja2VyfX0se2tleTpcImdldERuZENvbGxlY3RvclwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZG5kfHwodGhpcy5kbmQ9bmV3IHcodGhpcykpLHRoaXMuZG5kfX0se2tleTpcImdldFBhc3RlQ29sbGVjdG9yXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXN0ZXJ8fCh0aGlzLnBhc3Rlcj1uZXcgXyh0aGlzKSksdGhpcy5wYXN0ZXJ9fV0sW3trZXk6XCJzZXRTV0ZcIix2YWx1ZTpmdW5jdGlvbihlKXtQLnNldFNXRihlKX19XSksdH0odSk7ZS5leHBvcnRzPVI7dmFyIEM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7cih0aGlzLGUpLHRoaXMuX3NldD1bXX1yZXR1cm4gcyhlLFt7a2V5Olwic2l6ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NldC5sZW5ndGh9fSx7a2V5Olwic2hpZnRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zZXQuc2hpZnQoKX19LHtrZXk6XCJwb3BcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zZXQucG9wKCl9fSx7a2V5OlwidG9BcnJheVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NldC5zbGljZSgwKX19LHtrZXk6XCJhZGRcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5oYXMoZSk/ITE6KHRoaXMuX3NldC5wdXNoKGUpLCEwKX19LHtrZXk6XCJoYXNcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fc2V0LmluZGV4T2YoZSk+LTF9fSx7a2V5OlwicmVtb3ZlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5fc2V0LmluZGV4T2YoZSk7cmV0dXJuIHQ+LTE/KHRoaXMuX3NldC5zcGxpY2UodCwxKSwhMCk6ITF9fSx7a2V5OlwiY2xlYXJcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX3NldD1bXX19XSksZX0oKSxMPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe3IodGhpcyxlKSx0aGlzLmZpbGVzPW5ldyBDfXJldHVybiBzKGUsW3trZXk6XCJhZGRcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5maWxlcy5hZGQoZSl9fSx7a2V5OlwicmVtb3ZlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5maWxlcy5yZW1vdmUoZSl9fSx7a2V5OlwiZ2V0VG90YWxcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmZpbGVzLnNpemUoKX19LHtrZXk6XCJnZXRGaWxlc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuZmlsZXMudG9BcnJheSgpO3JldHVybiBlP3QuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiEhKHQuZ2V0U3RhdHVzKCkmZSl9KTp0fX0se2tleTpcInN0YXRcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD17fSxuPXRoaXMuZ2V0RmlsZXMoZSk7cmV0dXJuIG4uZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgbj1lLmdldFN0YXR1cygpO3Rbbl09biBpbiB0P3Rbbl0rMToxfSksdC5zdW09bi5sZW5ndGgsdH19XSksZX0oKSxTPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe3IodGhpcyxlKSx0aGlzLmNvbnN0cmFpbnRzPW5ldyBDfXJldHVybiBzKGUsW3trZXk6XCJhZGRcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5jb25zdHJhaW50cy5hZGQoZSksdGhpc319LHtrZXk6XCJyZW1vdmVcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5jb25zdHJhaW50cy5yZW1vdmUoZSksdGhpc319LHtrZXk6XCJzb21lXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3JldHVybiB0aGlzLmNvbnN0cmFpbnRzLnRvQXJyYXkoKS5zb21lKGZ1bmN0aW9uKHQpe3JldHVybiB0LmNhbGwoZSl9KX19XSksZX0oKSxUPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe3IodGhpcyxlKSx0aGlzLmZpbHRlcnM9bmV3IEN9cmV0dXJuIHMoZSxbe2tleTpcImFkZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmZpbHRlcnMuYWRkKGUpLHRoaXN9fSx7a2V5OlwicmVtb3ZlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZmlsdGVycy5yZW1vdmUoZSksdGhpc319LHtrZXk6XCJmaWx0ZXJcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1udWxsO3JldHVybiB0aGlzLmZpbHRlcnMudG9BcnJheSgpLmV2ZXJ5KGZ1bmN0aW9uKG4pe3ZhciByPXZvaWQgMDt0cnl7cj1uKGUpfWNhdGNoKGkpe3I9aX1yZXR1cm5cInN0cmluZ1wiPT10eXBlb2Ygcj8odD1uZXcgcChlLHIpLCExKTpyIGluc3RhbmNlb2YgRXJyb3I/KHQ9ciBpbnN0YW5jZW9mIHA/cjpuZXcgcChlLHIudG9TdHJpbmcoKSksITEpOiEwfSksdH19XSksZX0oKSxBPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0KXtyKHRoaXMsZSksdGhpcy50aHJlYWRzPXR8fDIsdGhpcy5oZWFkaW5nPW5ldyBDLHRoaXMucGVuZGluZz1uZXcgQ31yZXR1cm4gcyhlLFt7a2V5OlwiYWRkXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztyZXR1cm4gdGhpcy5wZW5kaW5nLmFkZChlKT8oZS5zZXNzaW9uKCkuYWx3YXlzKGZ1bmN0aW9uKCl7cmV0dXJuIHQucGVuZGluZy5yZW1vdmUoZSl9KSx0aGlzLmxvYWQoKSwhMCk6ITF9fSx7a2V5Olwic2l6ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGVuZGluZy5zaXplKCkrdGhpcy5oZWFkaW5nLnNpemUoKX19LHtrZXk6XCJwcm9jZXNzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpczt0aGlzLmhlYWRpbmcuYWRkKGUpJiZlLnNlc3Npb24oKS5hbHdheXMoZnVuY3Rpb24oKXt0LmhlYWRpbmcucmVtb3ZlKGUpLHQubG9hZCgpfSl9fSx7a2V5OlwibG9hZFwiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciBlO3RoaXMuaGVhZGluZy5zaXplKCk8dGhpcy50aHJlYWRzJiYoZT10aGlzLnBlbmRpbmcuc2hpZnQoKSk7KWUucHJlcGFyZSgpJiZ0aGlzLnByb2Nlc3MoZSl9fV0pLGV9KCl9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBpKGUsdCxuKXt2YXIgcj10LGk9bnVsbCxvPXZvaWQgMCxzPXUoKSxhPXMucHJvbWlzZSgpO2EuYWJvcnQ9ZnVuY3Rpb24oKXtvPSEwfTt2YXIgYz1mdW5jdGlvbihlKXtvfHwoZSYmKGk9ZSBpbnN0YW5jZW9mIEVycm9yP2U6bmV3IEVycm9yKGUpKSxzLnJlamVjdChpfHxuZXcgRXJyb3IoXCJVbmtub3duXCIpKSl9LGw9ZnVuY3Rpb24oKXtvfHwobnVsbCE9aT9jKCk6cy5yZXNvbHZlKHIpKX0sZj1mdW5jdGlvbihlKXtudWxsPT1lfHxudWxsIT1yJiZlLmNvbnN0cnVjdG9yIT09ci5jb25zdHJ1Y3Rvcnx8KHI9ZSl9LGg9ZnVuY3Rpb24gcCh0KXtpZighbyl7aWYodCBpbnN0YW5jZW9mIEVycm9yJiYoaT10KSxudWxsIT1pKXJldHVybiBjKCk7Zih0KTt2YXIgcz1lLnNoaWZ0KCk7aWYoIXMpcmV0dXJuIGwoKTt2YXIgdT12b2lkIDA7dHJ5e3U9cy5jYWxsKG4scil9Y2F0Y2goYSl7cmV0dXJuIGMoYSl9dSYmdS50aGVuP3UudGhlbihwLGMpOnAodSl9fTtyZXR1cm4gc2V0VGltZW91dChoLDEpLGF9dmFyIG89ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIua2V5LHIpfX1yZXR1cm4gZnVuY3Rpb24odCxuLHIpe3JldHVybiBuJiZlKHQucHJvdG90eXBlLG4pLHImJmUodCxyKSx0fX0oKSxzPW4oMyksdT1zLkRlZmVycmVkLGE9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7cih0aGlzLGUpfXJldHVybiBvKGUsW3trZXk6XCJvblwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU9ZS50b0xvd2VyQ2FzZSgpLHRoaXMuX2V2ZW50c3x8KHRoaXMuX2V2ZW50cz17fSksdGhpcy5fZXZlbnRzW2VdfHwodGhpcy5fZXZlbnRzW2VdPVtdKSx0aGlzLl9ldmVudHNbZV0ucHVzaCh0KSx0aGlzfX0se2tleTpcIm9uY2VcIix2YWx1ZTpmdW5jdGlvbihlLHQpe2Z1bmN0aW9uIG4oKXtyLm9mZihlLG4pLHQuYXBwbHkodGhpcyxhcmd1bWVudHMpfWU9ZS50b0xvd2VyQ2FzZSgpO3ZhciByPXRoaXM7cmV0dXJuIG4ubGlzdGVuZXI9dCx0aGlzLm9uKGUsbiksdGhpc319LHtrZXk6XCJvZmZcIix2YWx1ZTpmdW5jdGlvbihlLHQpe2U9ZS50b0xvd2VyQ2FzZSgpO3ZhciBuPXZvaWQgMDtpZighdGhpcy5fZXZlbnRzfHwhKG49dGhpcy5fZXZlbnRzW2VdKSlyZXR1cm4gdGhpcztmb3IodmFyIHI9bi5sZW5ndGg7ci0tID4wOylpZihuW3JdPT09dHx8bltyXS5saXN0ZW5lcj09PXQpe24uc3BsaWNlKHIsMSk7YnJlYWt9cmV0dXJuIDA9PT1uLmxlbmd0aCYmZGVsZXRlIHRoaXMuX2V2ZW50c1tlXSx0aGlzfX0se2tleTpcInJlbW92ZUFsbExpc3RlbmVyc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBlP2RlbGV0ZSB0aGlzLl9ldmVudHNbZS50b0xvd2VyQ2FzZSgpXTp0aGlzLl9ldmVudHM9W10sdGhpc319LHtrZXk6XCJzZXRQcm9wYWdhdGlvblRhcmdldFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3QgaW5zdGFuY2VvZiBlJiYodGhpcy5wcm9wYWdhdGlvblRhcmdldD10KX19LHtrZXk6XCJlbWl0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PWFyZ3VtZW50cy5sZW5ndGgsbj1BcnJheSh0PjE/dC0xOjApLHI9MTt0PnI7cisrKW5bci0xXT1hcmd1bWVudHNbcl07dGhpcy5hcHBseUVtaXQoZSxuKX19LHtrZXk6XCJhcHBseUVtaXRcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7ZT1lLnRvTG93ZXJDYXNlKCk7dmFyIHI9dm9pZCAwO2lmKHRoaXMuX2V2ZW50cyYmKHI9dGhpcy5fZXZlbnRzW2VdKSYmci5zbGljZSgwKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmFwcGx5KG4sdCl9KSx0aGlzLnByb3BhZ2F0aW9uVGFyZ2V0KXt2YXIgaT10LnNsaWNlKDApO2kudW5zaGlmdCh0aGlzKSx0aGlzLnByb3BhZ2F0aW9uVGFyZ2V0LmFwcGx5RW1pdChlLGkpfXJldHVybiB0aGlzfX0se2tleTpcImludm9rZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7ZT1lLnRvTG93ZXJDYXNlKCk7dmFyIG49dm9pZCAwO3JldHVybiB0aGlzLl9ldmVudHMmJihuPXRoaXMuX2V2ZW50c1tlXSl8fChuPVtdKSxpKG4uc2xpY2UoMCksdCx0aGlzKX19XSksZX0oKTtlLmV4cG9ydHM9YX0sZnVuY3Rpb24oZSx0KXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBuKGUpe3JldHVyblwic3RyaW5nXCIhPXR5cGVvZiBlP1wiXCI6ZS50b0xvd2VyQ2FzZSgpLnNwbGl0KC8gKlsgLDt8K10gKi8pLm1hcChmdW5jdGlvbihlKXt2YXIgdD0vXlxcKj9cXC4/KFxcdyspJC8uZXhlYyhlKTtyZXR1cm4gdD90WzFdOm51bGx9KS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIG51bGwhPT1lfSl9ZnVuY3Rpb24gcihlKXtyZXR1cm4gZT8oQXJyYXkuaXNBcnJheShlKXx8KGU9W2VdKSxlLm1hcChmdW5jdGlvbihlKXtpZihcInN0cmluZ1wiPT10eXBlb2YgZSYmKGU9ZS50b0xvd2VyQ2FzZSgpKSYmYy5oYXNPd25Qcm9wZXJ0eShlKSlyZXR1cm4gY1tlXTt2YXIgdD1uKGUuZXh0ZW5zaW9uc3x8ZSk7cmV0dXJuIHQubGVuZ3RoP3t0aXRsZTplLnRpdGxlfHxcIlwiLGV4dGVuc2lvbnM6dCxtaW1lVHlwZXM6ZS5taW1lVHlwZXN8fFwiXCJ9Om51bGx9KS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIG51bGwhPT1lfSkpOm51bGx9ZnVuY3Rpb24gaShlKXt2YXIgdD17fTtyZXR1cm4oZS5tYXRjaCgvXFxTKy9nKXx8W10pLmZvckVhY2goZnVuY3Rpb24oZSl7dFtlXT0hMH0pLHR9ZnVuY3Rpb24gbyhlLHQpe2Zvcih2YXIgbiBpbiB0KWVbbl09dFtuXTtyZXR1cm4gZX1mdW5jdGlvbiBzKGUpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIGV9ZnVuY3Rpb24gdShlKXtlPVwic3RyaW5nXCI9PXR5cGVvZiBlP2koZSk6byh7fSxlKTt2YXIgdD12b2lkIDAsbj12b2lkIDAscj12b2lkIDAsdT12b2lkIDAsYT12b2lkIDAsYz12b2lkIDAsZj1bXSxoPXZvaWQgMCxwPSFlLm9uY2UmJltdLHY9ZnVuY3Rpb24gZChpKXtmb3Iobj1lLm1lbW9yeSYmaSxyPSEwLGE9Y3x8MCxjPTAsdT1mLmxlbmd0aCx0PSEwO2YmJnU+YTthKyspaWYoZlthXS5hcHBseShpWzBdLGlbMV0pPT09ITEmJmUuc3RvcE9uRmFsc2Upe249ITE7YnJlYWt9dD0hMSxmJiYocD9wLmxlbmd0aCYmZChwLnNoaWZ0KCkpOm4/Zj1bXTpoLmRpc2FibGUoKSl9O3JldHVybiBoPXthZGQ6ZnVuY3Rpb24oKXtpZihmKXt2YXIgcj1mLmxlbmd0aDshZnVuY3Rpb24gaSh0KXt0LmZvckVhY2goZnVuY3Rpb24odCl7cyh0KT9lLnVuaXF1ZSYmaC5oYXModCl8fGYucHVzaCh0KTpBcnJheS5pc0FycmF5KHQpJiZpKHQpfSl9KGwoYXJndW1lbnRzKSksdD91PWYubGVuZ3RoOm4mJihjPXIsdihuKSl9cmV0dXJuIHRoaXN9LHJlbW92ZTpmdW5jdGlvbigpe3JldHVybiBmJiZsKGFyZ3VtZW50cykuZm9yRWFjaChmdW5jdGlvbihlKXtmb3IodmFyIG49Zi5sZW5ndGg7LS1uPj0wOylmW25dPT09ZSYmKGYuc3BsaWNlKG4sMSksdCYmKHU+PW4mJnUtLSxhPj1uJiZhLS0pKX0pLHRoaXN9LGhhczpmdW5jdGlvbihlKXtyZXR1cm4gZT9mLmluZGV4T2YoZSk+LTE6ISghZnx8IWYubGVuZ3RoKX0sZW1wdHk6ZnVuY3Rpb24oKXtyZXR1cm4gZj1bXSx1PTAsdGhpc30sZGlzYWJsZTpmdW5jdGlvbigpe3JldHVybiBmPXA9bj1udWxsLHRoaXN9LGRpc2FibGVkOmZ1bmN0aW9uKCl7cmV0dXJuIWZ9LGxvY2s6ZnVuY3Rpb24oKXtyZXR1cm4gcD1udWxsLG58fGguZGlzYWJsZSgpLHRoaXN9LGxvY2tlZDpmdW5jdGlvbigpe3JldHVybiFwfSxmaXJlV2l0aDpmdW5jdGlvbihlLG4pe3JldHVybiFmfHxyJiYhcHx8KG49bnx8W10sbj1bZSxuLnNsaWNlP24uc2xpY2UoKTpuXSx0P3AucHVzaChuKTp2KG4pKSx0aGlzfSxmaXJlOmZ1bmN0aW9uKCl7cmV0dXJuIGguZmlyZVdpdGgodGhpcyxhcmd1bWVudHMpLHRoaXN9LGZpcmVkOmZ1bmN0aW9uKCl7cmV0dXJuISFyfX19ZnVuY3Rpb24gYShlKXt2YXIgdD1bW1wicmVzb2x2ZVwiLFwiZG9uZVwiLHUoXCJvbmNlIG1lbW9yeVwiKSxcInJlc29sdmVkXCJdLFtcInJlamVjdFwiLFwiZmFpbFwiLHUoXCJvbmNlIG1lbW9yeVwiKSxcInJlamVjdGVkXCJdLFtcIm5vdGlmeVwiLFwicHJvZ3Jlc3NcIix1KFwibWVtb3J5XCIpXV0sbj1cInBlbmRpbmdcIixyPXtzdGF0ZTpmdW5jdGlvbigpe3JldHVybiBufSxhbHdheXM6ZnVuY3Rpb24oKXt2YXIgZT1sKGFyZ3VtZW50cyk7cmV0dXJuIGkuZG9uZShlKS5mYWlsKGUpLHRoaXN9LHRoZW46ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHM7cmV0dXJuIGEoZnVuY3Rpb24obil7dC5mb3JFYWNoKGZ1bmN0aW9uKHQsbyl7dmFyIHU9cyhlW29dKSYmZVtvXTtpW3RbMV1dKGZ1bmN0aW9uKCl7dmFyIGU9dSYmdS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7ZSYmcyhlLnByb21pc2UpP2UucHJvbWlzZSgpLmRvbmUobi5yZXNvbHZlKS5mYWlsKG4ucmVqZWN0KS5wcm9ncmVzcyhuLm5vdGlmeSk6blt0WzBdK1wiV2l0aFwiXSh0aGlzPT09cj9uLnByb21pc2UoKTp0aGlzLHU/W2VdOmFyZ3VtZW50cyl9KX0pLGU9bnVsbH0pLnByb21pc2UoKX0scHJvbWlzZTpmdW5jdGlvbihlKXtyZXR1cm4gbnVsbCE9ZT9vKGUscik6cn19LGk9e307cmV0dXJuIHIucGlwZT1yLnRoZW4sdC5mb3JFYWNoKGZ1bmN0aW9uKGUsbyl7dmFyIHM9ZVsyXSx1PWVbM107cltlWzFdXT1zLmFkZCx1JiZzLmFkZChmdW5jdGlvbigpe249dX0sdFsxXm9dWzJdLmRpc2FibGUsdFsyXVsyXS5sb2NrKSxpW2VbMF1dPWZ1bmN0aW9uKCl7cmV0dXJuIGlbZVswXStcIldpdGhcIl0odGhpcz09PWk/cjp0aGlzLGFyZ3VtZW50cyksdGhpc30saVtlWzBdK1wiV2l0aFwiXT1zLmZpcmVXaXRofSksci5wcm9taXNlKGkpLGUmJmUuY2FsbChpLGkpLGl9dC5mb3JtYXRTaXplPWZ1bmN0aW9uKGUpe2U9cGFyc2VGbG9hdChlKTt2YXIgdD1bXCJcIixcIktcIixcIk1cIixcIkdcIixcIlRcIixcIlBcIixcIkVcIixcIlpcIixcIllcIl0sbj0xMDI0LHI9ZT9NYXRoLmZsb29yKE1hdGgubG9nKGUpL01hdGgubG9nKG4pKTowO3I9TWF0aC5taW4ocix0Lmxlbmd0aC0xKTt2YXIgaT1NYXRoLnBvdygxMCwyPnI/MDpyPjI/MjoxKTtyZXR1cm4gZS89TWF0aC5wb3cobixyKSxlPU1hdGgucm91bmQoZSppKS9pLGUrdFtyXStcIkJcIn0sdC5wYXJzZVNpemU9ZnVuY3Rpb24oZSl7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIGUpcmV0dXJuIGU7dmFyIHQ9e3Q6MTA5OTUxMTYyNzc3NixnOjEwNzM3NDE4MjQsbToxMDQ4NTc2LGs6MTAyNH07ZT0vXihbMC05XFwuXSspKFt0Z21rXT8pYj8kL2kuZXhlYyhlKTt2YXIgbj1lWzJdO3JldHVybiBlPStlWzFdLHQuaGFzT3duUHJvcGVydHkobikmJihlKj10W25dKSxlfTt2YXIgYz17aW1hZ2VzOnt0aXRsZTpcIkltYWdlc1wiLGV4dGVuc2lvbnM6W1wianBnXCIsXCJqcGVnXCIsXCJnaWZcIixcInBuZ1wiLFwiYm1wXCIsXCJzdmdcIixcInRpZmZcIixcInRpZlwiLFwiaWNvXCIsXCJqcGVcIixcInN2Z3pcIixcInBjdFwiLFwicHNwXCIsXCJhaVwiLFwicHNkXCIsXCJyYXdcIixcIndlYnBcIl19LGF1ZGlvczp7dGl0bGU6XCJBdWRpb3NcIixleHRlbnNpb25zOltcImFhY1wiLFwiYWlmXCIsXCJmbGFjXCIsXCJpZmZcIixcIm00YVwiLFwibTRiXCIsXCJtaWRcIixcIm1pZGlcIixcIm1wM1wiLFwibXBhXCIsXCJtcGNcIixcIm9nYVwiLFwib2dnXCIsXCJyYVwiLFwicmFtXCIsXCJzbmRcIixcIndhdlwiLFwid21hXCJdfSx2aWRlb3M6e3RpdGxlOlwiVmlkZW9zXCIsZXh0ZW5zaW9uczpbXCJhdmlcIixcImRpdnhcIixcImZsdlwiLFwibTR2XCIsXCJta3ZcIixcIm1vdlwiLFwibXA0XCIsXCJtcGVnXCIsXCJtcGdcIixcIm9nbVwiLFwib2d2XCIsXCJvZ3hcIixcInJtXCIsXCJybXZiXCIsXCJzbWlsXCIsXCJ3ZWJtXCIsXCJ3bXZcIixcInh2aWRcIl19fTt0Lm5vcm1hbGl6ZUFjY2VwdD1yLHQuZXh0ZW5kPW87dmFyIGw9QXJyYXkuZnJvbXx8ZnVuY3Rpb24oZSl7cmV0dXJuW10uc2xpY2UuY2FsbChlKX07dC5EZWZlcnJlZD1hfSxmdW5jdGlvbihlLHQpe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz17UVVFVUVfVVBMT0FEX1NUQVJUOlwicXVldWV1cGxvYWRzdGFydFwiLFFVRVVFX1VQTE9BRF9FTkQ6XCJxdWV1ZXVwbG9hZGVuZFwiLFFVRVVFX0ZJTEVfQURERUQ6XCJxdWV1ZWZpbGVhZGRlZFwiLFFVRVVFX0ZJTEVfRklMVEVSRUQ6XCJxdWV1ZWZpbGVmaWx0ZXJlZFwiLFFVRVVFX0VSUk9SOlwicXVldWVlcnJvclwiLFFVRVVFX1NUQVRfQ0hBTkdFOlwic3RhdGNoYW5nZVwiLEZJTEVfVVBMT0FEX1NUQVJUOlwiZmlsZXVwbG9hZHN0YXJ0XCIsRklMRV9VUExPQURfUFJFUEFSSU5HOlwiZmlsZXVwbG9hZHByZXBhcmluZ1wiLEZJTEVfVVBMT0FEX1BSRVBBUkVEOlwiZmlsZXVwbG9hZHByZXBhcmVkXCIsQ0hVTktfVVBMT0FEX1BSRVBBUklORzpcImNodW5rdXBsb2FkcHJlcGFyaW5nXCIsQ0hVTktfVVBMT0FEX0NPTVBMRVRJTkc6XCJjaHVua3VwbG9hZGNvbXBsZXRpbmdcIixGSUxFX1VQTE9BRF9QUk9HUkVTUzpcImZpbGV1cGxvYWRwcm9ncmVzc1wiLEZJTEVfVVBMT0FEX0VORDpcImZpbGV1cGxvYWRlbmRcIixGSUxFX1VQTE9BRF9DT01QTEVUSU5HOlwiZmlsZXVwbG9hZGNvbXBsZXRpbmdcIixGSUxFX1VQTE9BRF9TVUNDRVNTOlwiZmlsZXVwbG9hZHN1Y2Nlc3NcIixGSUxFX1VQTE9BRF9FUlJPUjpcImZpbGV1cGxvYWRlcnJvclwiLEZJTEVfVVBMT0FEX0NPTVBMRVRFRDpcImZpbGV1cGxvYWRjb21wbGV0ZWRcIixGSUxFX0NBTkNFTDpcImZpbGVjYW5jZWxcIixGSUxFX1NUQVRVU19DSEFOR0U6XCJmaWxlc3RhdHVzY2hhbmdlXCJ9fSxmdW5jdGlvbihlLHQpe1widXNlIHN0cmljdFwiO3QuU3RhdHVzPXtBTEw6MjU1LFBST0NFU1M6MzEsSU5JVEVEOjEsUVVFVUVEOjIsUEVORElORzo0LFBST0dSRVNTOjgsRU5EOjE2LFNVQ0NFU1M6MzIsRVJST1I6NjQsQ0FOQ0VMTEVEOjEyOH0sdC5TdGF0dXNOYW1lPXsxOlwiaW5pdGVkXCIsMjpcInF1ZXVlZFwiLDQ6XCJwZW5kaW5nXCIsODpcInByb2dyZXNzXCIsMTY6XCJlbmRcIiwzMjpcInN1Y2Nlc3NcIiw2NDpcImVycm9yXCIsMTI4OlwiY2FuY2VsbGVkXCJ9fSxmdW5jdGlvbihlLHQpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG4oZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIHIoZSx0KXtpZighZSl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIXR8fFwib2JqZWN0XCIhPXR5cGVvZiB0JiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0P2U6dH1mdW5jdGlvbiBpKGUsdCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCYmbnVsbCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIHQpO2UucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodCYmdC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTplLGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLHQmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKGUsdCk6ZS5fX3Byb3RvX189dCl9dmFyIG89ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChlKXtuKHRoaXMsdCk7dmFyIGk9cih0aGlzLE9iamVjdC5nZXRQcm90b3R5cGVPZih0KS5jYWxsKHRoaXMsZSkpO3JldHVybiBpLm1lc3NhZ2U9ZSxpfXJldHVybiBpKHQsZSksdH0oRXJyb3IpLHM9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChlKXtuKHRoaXMsdCk7dmFyIGk9cih0aGlzLE9iamVjdC5nZXRQcm90b3R5cGVPZih0KS5jYWxsKHRoaXMsZSkpO3JldHVybiBpLm5hbWU9XCJBYm9ydEVycm9yXCIsaX1yZXR1cm4gaSh0LGUpLHR9KG8pLHU9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChlKXtuKHRoaXMsdCk7dmFyIGk9cih0aGlzLE9iamVjdC5nZXRQcm90b3R5cGVPZih0KS5jYWxsKHRoaXMsZSkpO3JldHVybiBpLm5hbWU9XCJUaW1lb3V0RXJyb3JcIixpfXJldHVybiBpKHQsZSksdH0obyksYT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KGUsaSl7bih0aGlzLHQpO3ZhciBvPXIodGhpcyxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCkuY2FsbCh0aGlzLGkpKTtyZXR1cm4gby5uYW1lPVwiTmV0d29ya0Vycm9yXCIsby5zdGF0dXM9ZSxvfXJldHVybiBpKHQsZSksdH0obyksYz1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7bih0aGlzLHQpO3ZhciBlPXIodGhpcyxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCkuY2FsbCh0aGlzLFwicXVldWUgbGltaXRcIikpO3JldHVybiBlLm5hbWU9XCJRdWV1ZUxpbWl0RXJyb3JcIixlfXJldHVybiBpKHQsZSksdH0obyksbD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KGUsaSl7bih0aGlzLHQpO3ZhciBvPXIodGhpcyxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCkuY2FsbCh0aGlzLGkpKTtyZXR1cm4gby5uYW1lPVwiRmlsdGVyRXJyb3JcIixvLmZpbGU9ZSxvfXJldHVybiBpKHQsZSksdH0obyksZj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KGUsaSl7bih0aGlzLHQpO3ZhciBvPXIodGhpcyxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCkuY2FsbCh0aGlzLGUsaSkpO3JldHVybiBvLm5hbWU9XCJEdXBsaWNhdGVFcnJvclwiLG99cmV0dXJuIGkodCxlKSx0fShsKSxoPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoZSxpKXtuKHRoaXMsdCk7dmFyIG89cih0aGlzLE9iamVjdC5nZXRQcm90b3R5cGVPZih0KS5jYWxsKHRoaXMsZSxpKSk7cmV0dXJuIG8ubmFtZT1cIkZpbGVFeHRlbnNpb25FcnJvclwiLG99cmV0dXJuIGkodCxlKSx0fShsKSxwPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoZSxpKXtuKHRoaXMsdCk7dmFyIG89cih0aGlzLE9iamVjdC5nZXRQcm90b3R5cGVPZih0KS5jYWxsKHRoaXMsZSxpKSk7cmV0dXJuIG8ubmFtZT1cIkZpbGVTaXplRXJyb3JcIixvfXJldHVybiBpKHQsZSksdH0obCk7ZS5leHBvcnRzPXtBYm9ydEVycm9yOnMsVGltZW91dEVycm9yOnUsTmV0d29ya0Vycm9yOmEsUXVldWVMaW1pdEVycm9yOmMsRmlsdGVyRXJyb3I6bCxEdXBsaWNhdGVFcnJvcjpmLEZpbGVFeHRlbnNpb25FcnJvcjpoLEZpbGVTaXplRXJyb3I6cH19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUpe3JldHVybiBlJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sP1wic3ltYm9sXCI6dHlwZW9mIGV9ZnVuY3Rpb24gaShlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9dmFyIG89ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIua2V5LHIpfX1yZXR1cm4gZnVuY3Rpb24odCxuLHIpe3JldHVybiBuJiZlKHQucHJvdG90eXBlLG4pLHImJmUodCxyKSx0fX0oKSxzPW4oMyksdT1zLnBhcnNlU2l6ZSxhPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LG4pe2kodGhpcyxlKSx0aGlzLnJhd1Jlc3BvbnNlPXQsdGhpcy5jaHVua1JlcXVlc3Q9bn1yZXR1cm4gbyhlLFt7a2V5OlwiZ2V0Q2h1bmtSZXF1ZXN0XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jaHVua1JlcXVlc3R9fSx7a2V5OlwiZ2V0UmF3UmVzcG9uc2VcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnJhd1Jlc3BvbnNlfX0se2tleTpcImdldFJlc3BvbnNlXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZXNwb25zZXx8dGhpcy5yYXdSZXNwb25zZX19LHtrZXk6XCJnZXRKc29uXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmdldFJlc3BvbnNlKCk7cmV0dXJuIG51bGw9PWU/bnVsbDpcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmdldEpzb24/ZS5nZXRKc29uKCk6XCJzdHJpbmdcIj09dHlwZW9mIGU/XCJcIj09PWU/bnVsbDpKU09OLnBhcnNlKGUpOmV9fSx7a2V5Olwic2V0UmVzcG9uc2VcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXNwb25zZT1lLHRoaXN9fV0pLGV9KCksYz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuLHIpe2kodGhpcyxlKSx0aGlzLmluZGV4PXQsdGhpcy5ibG9iPW4sdGhpcy5maWxlUmVxdWVzdD1yfXJldHVybiBvKGUsW3trZXk6XCJnZXROYW1lXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5maWxlUmVxdWVzdC5nZXROYW1lKCl9fSx7a2V5OlwiZ2V0RmlsZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmlsZVJlcXVlc3QuZ2V0RmlsZSgpfX0se2tleTpcImdldEJsb2JcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmJsb2J9fSx7a2V5OlwiZ2V0SW5kZXhcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmluZGV4fX0se2tleTpcImlzTXVsdGlDaHVua1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0RmlsZSgpLnNvdXJjZSE9PXRoaXMuYmxvYn19LHtrZXk6XCJnZXRQYXJhbXNcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcmFtc3x8KHRoaXMucGFyYW1zPXRoaXMuZmlsZVJlcXVlc3QuZ2V0UGFyYW1zKCkuY2xvbmUoKSksdGhpcy5wYXJhbXN9fSx7a2V5OlwiZ2V0UGFyYW1cIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5nZXRQYXJhbXMoKS5nZXRQYXJhbShlKX19LHtrZXk6XCJzZXRQYXJhbVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuZ2V0UGFyYW1zKCkuc2V0UGFyYW0oZSx0KSx0aGlzfX0se2tleTpcImdldEZpbGVSZXF1ZXN0XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5maWxlUmVxdWVzdH19LHtrZXk6XCJnZXRVcmxcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnVybHx8dGhpcy5maWxlUmVxdWVzdC5nZXRVcmwoKX19LHtrZXk6XCJzZXRVcmxcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy51cmw9ZSx0aGlzfX0se2tleTpcImdldEhlYWRlcnNcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhlYWRlcnN8fCh0aGlzLmhlYWRlcnM9dGhpcy5maWxlUmVxdWVzdC5nZXRIZWFkZXJzKCkuc2xpY2UoMCkpLHRoaXMuaGVhZGVyc319LHtrZXk6XCJzZXRIZWFkZXJcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPXRoaXMuZ2V0SGVhZGVycygpO3JldHVybiBuLnB1c2goe25hbWU6ZSx2YWx1ZTp0fSksdGhpc319LHtrZXk6XCJpc1dpdGhDcmVkZW50aWFsc1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmlsZVJlcXVlc3QuaXNXaXRoQ3JlZGVudGlhbHMoKX19LHtrZXk6XCJnZXRUaW1lb3V0XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5maWxlUmVxdWVzdC5nZXRUaW1lb3V0KCl9fSx7a2V5OlwiY3JlYXRlQ2h1bmtSZXNwb25zZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBuZXcgYShlLHRoaXMpfX1dKSxlfSgpLGw9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQsbil7aSh0aGlzLGUpLHRoaXMucmF3UmVzcG9uc2U9dCx0aGlzLmZpbGVSZXF1ZXN0PW59cmV0dXJuIG8oZSxbe2tleTpcImlzRnJvbU11bHRpQ2h1bmtSZXNwb25zZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmF3UmVzcG9uc2UgaW5zdGFuY2VvZiBhP3RoaXMucmF3UmVzcG9uc2UuZ2V0Q2h1bmtSZXF1ZXN0KCkuaXNNdWx0aUNodW5rKCk6ITF9fSx7a2V5OlwiZ2V0RmlsZVJlcXVlc3RcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmZpbGVSZXF1ZXN0fX0se2tleTpcImdldFJhd1Jlc3BvbnNlXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yYXdSZXNwb25zZX19LHtrZXk6XCJnZXRSZXNwb25zZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPXRoaXMucmVzcG9uc2U/dGhpcy5yZXNwb25zZTp0aGlzLnJhd1Jlc3BvbnNlIGluc3RhbmNlb2YgYT90aGlzLnJhd1Jlc3BvbnNlLmdldFJlc3BvbnNlKCk6dGhpcy5yYXdSZXNwb25zZX19LHtrZXk6XCJnZXRKc29uXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmdldFJlc3BvbnNlKCk7cmV0dXJuIG51bGw9PWU/bnVsbDpcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmdldEpzb24/ZS5nZXRKc29uKCk6XCJzdHJpbmdcIj09dHlwZW9mIGU/XCJcIj09PWU/bnVsbDpKU09OLnBhcnNlKGUpOmV9fSx7a2V5Olwic2V0UmVzcG9uc2VcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZXNwb25zZT1lLHRoaXN9fV0pLGV9KCksZj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCl7aWYoaSh0aGlzLGUpLEFycmF5LmlzQXJyYXkodCkpdGhpcy5wYXJhbXM9dC5zbGljZSgwKTtlbHNlIGlmKFwib2JqZWN0XCI9PT0oXCJ1bmRlZmluZWRcIj09dHlwZW9mIHQ/XCJ1bmRlZmluZWRcIjpyKHQpKSl7dGhpcy5wYXJhbXM9W107Zm9yKHZhciBuIGluIHQpdC5oYXNPd25Qcm9wZXJ0eShuKSYmdGhpcy5wYXJhbXMucHVzaCh7bmFtZTpuLHZhbHVlOnRbbl19KX1lbHNlIHRoaXMucGFyYW1zPVtdfXJldHVybiBvKGUsW3trZXk6XCJzZXRQYXJhbVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dGhpcy5yZW1vdmVQYXJhbShlKSx0aGlzLmFkZFBhcmFtKGUsdCl9fSx7a2V5OlwiYWRkUGFyYW1cIix2YWx1ZTpmdW5jdGlvbihlLHQpe3RoaXMucGFyYW1zLnB1c2goe25hbWU6ZSx2YWx1ZTp0fSl9fSx7a2V5OlwicmVtb3ZlUGFyYW1cIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLnBhcmFtcz10aGlzLnBhcmFtcy5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIHQubmFtZSE9PWV9KX19LHtrZXk6XCJnZXRQYXJhbVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcy5wYXJhbXMuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5hbWU9PT1lfSkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLnZhbHVlfSk7cmV0dXJuIHQ/bi5zaGlmdCgpOm59fSx7a2V5OlwiY2xvbmVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBuZXcgZSh0aGlzLnBhcmFtcyl9fSx7a2V5OlwidG9BcnJheVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyYW1zfX0se2tleTpcInRvU3RyaW5nXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnBhcmFtcy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChlLm5hbWUpK1wiPVwiKyhudWxsPT1lLnZhbHVlP1wiXCI6ZW5jb2RlVVJJQ29tcG9uZW50KGUudmFsdWUpKX0pO3JldHVybiBlLmpvaW4oXCImXCIpfX1dKSxlfSgpLGg9MjYyMTQ0LHA9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg8PTF8fHZvaWQgMD09PWFyZ3VtZW50c1sxXT97fTphcmd1bWVudHNbMV07aSh0aGlzLGUpLHRoaXMuZmlsZT10LHRoaXMubmFtZT1uLm5hbWV8fFwiZmlsZVwiLHRoaXMudXJsPW4udXJsfHxuLmFjdGlvbix0aGlzLnBhcmFtcz1uZXcgZihuLnBhcmFtc3x8bi5kYXRhKSx0aGlzLmhlYWRlcnM9bi5oZWFkZXJzfHxbXSx0aGlzLndpdGhDcmVkZW50aWFscz1uLndpdGhDcmVkZW50aWFscyx0aGlzLnRpbWVvdXQ9bi50aW1lb3V0fHwwLHRoaXMuY2h1bmtTaXplPW4uY2h1bmtTaXplfHwwLHRoaXMuY2h1bmtSZXRyaWVzPW4uY2h1bmtSZXRyaWVzfHwwLHRoaXMuY2h1bmtFbmFibGU9bi5jaHVua0VuYWJsZXx8ITEsdGhpcy5jaHVua1Byb2Nlc3NUaHJlYWRzPW4uY2h1bmtQcm9jZXNzVGhyZWFkc3x8Mn1yZXR1cm4gbyhlLFt7a2V5OlwiZ2V0RmlsZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmlsZX19LHtrZXk6XCJnZXRVcmxcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnVybHx8XCJcIn19LHtrZXk6XCJnZXROYW1lXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uYW1lfX0se2tleTpcInNldE5hbWVcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5uYW1lPWUsdGhpc319LHtrZXk6XCJzZXRVcmxcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy51cmw9ZSx0aGlzfX0se2tleTpcImdldFBhcmFtc1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyYW1zfX0se2tleTpcImdldFBhcmFtXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZ2V0UGFyYW1zKCkuZ2V0UGFyYW0oZSl9fSx7a2V5Olwic2V0UGFyYW1cIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLnBhcmFtcy5zZXRQYXJhbShlLHQpLHRoaXN9fSx7a2V5OlwiZ2V0SGVhZGVyc1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGVhZGVyc319LHtrZXk6XCJzZXRIZWFkZXJcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3RoaXMuaGVhZGVycy5wdXNoKHtuYW1lOmUsdmFsdWU6dH0pfX0se2tleTpcImlzV2l0aENyZWRlbnRpYWxzXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy53aXRoQ3JlZGVudGlhbHN9fSx7a2V5Olwic2V0V2l0aENyZWRlbnRpYWxzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMud2l0aENyZWRlbnRpYWxzPWUsdGhpc319LHtrZXk6XCJnZXRUaW1lb3V0XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aW1lb3V0fX0se2tleTpcInNldFRpbWVvdXRcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aW1lb3V0PWUsdGhpc319LHtrZXk6XCJnZXRDaHVua1NpemVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB1KHRoaXMuY2h1bmtTaXplKX19LHtrZXk6XCJzZXRDaHVua1NpemVcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5jaHVua1NpemU9ZSx0aGlzfX0se2tleTpcImdldENodW5rUmV0cmllc1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2h1bmtSZXRyaWVzfX0se2tleTpcInNldENodW5rUmV0cmllc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmNodW5rUmV0cmllcz1lLDB9fSx7a2V5OlwiaXNDaHVua0VuYWJsZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5nZXRDaHVua1NpemUoKTtyZXR1cm4gdGhpcy5jaHVua0VuYWJsZSYmZT5oJiZ0aGlzLmZpbGUuZ2V0UnVudGltZSgpLmNhblNsaWNlKCkmJnRoaXMuZmlsZS5zaXplPmV9fSx7a2V5Olwic2V0Q2h1bmtFbmFibGVcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5jaHVua0VuYWJsZT1lLHRoaXN9fSx7a2V5OlwiZ2V0Q2h1bmtQcm9jZXNzVGhyZWFkc1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2h1bmtQcm9jZXNzVGhyZWFkc319LHtrZXk6XCJzZXRDaHVua1Byb2Nlc3NUaHJlYWRzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuY2h1bmtQcm9jZXNzVGhyZWFkcz1lLHRoaXN9fSx7a2V5OlwiY3JlYXRlQ2h1bmtSZXF1ZXN0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbmV3IGMoZSx0LHRoaXMpfX0se2tleTpcImNyZWF0ZUZpbGVSZXNwb25zZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBuZXcgbChlLHRoaXMpfX1dKSxlfSgpO2UuZXhwb3J0cz1wfSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gaShlLHQpe2lmKCFlKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hdHx8XCJvYmplY3RcIiE9dHlwZW9mIHQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/ZTp0fWZ1bmN0aW9uIG8oZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgdCk7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YoZSx0KTplLl9fcHJvdG9fXz10KX1mdW5jdGlvbiBzKGUpe3JldHVybiBmdW5jdGlvbih0LG4pe2Z1bmN0aW9uIHIodCl7cmV0dXJuLS1hPDB8fCFlKHQsbik/KGM9ITAsITEpOiEwfWZ1bmN0aW9uIGkoZSl7Y3x8KGUuaXNGaWxlP2UuZmlsZShmdW5jdGlvbihlKXtjfHxyKGUpfSk6ZS5pc0RpcmVjdG9yeSYmZS5jcmVhdGVSZWFkZXIoKS5yZWFkRW50cmllcyhmdW5jdGlvbihlKXtpZighYylmb3IodmFyIHQ9MCxuPWUubGVuZ3RoO24+dCYmIWM7dCsrKWkoZVt0XSl9KSl9Zm9yKHZhciBvPXQuaXRlbXMscz10LmZpbGVzLHU9dm9pZCAwLGE9aCxjPSExLGw9MCxmPXMubGVuZ3RoO2Y+bCYmIWM7bCsrKXt1PW8mJm9bbF07dmFyIHA9dSYmdS53ZWJraXRHZXRBc0VudHJ5JiZ1LndlYmtpdEdldEFzRW50cnkoKTtpZihwJiZwLmlzRGlyZWN0b3J5KWkocCk7ZWxzZSBpZighcihzW2xdKSlicmVha319fWZ1bmN0aW9uIHUoKXtpZihcIkRhdGFUcmFuc2ZlclwiaW4gd2luZG93JiZcIkZpbGVMaXN0XCJpbiB3aW5kb3cmJmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIpe3ZhciBlPWwuZ2V0SW5zdGFuY2UoKSx0PTAsbj0wLHI9dm9pZCAwLGk9cyhmdW5jdGlvbih0LG4pe2lmKCFufHxuLmxlbmd0aDwxKXJldHVybiExO3Q9bmV3IGYoZSx0KTt2YXIgcj1uLmxlbmd0aDtyZXR1cm4gbi5zb21lKGZ1bmN0aW9uKGUpe3ZhciBuPWUucmVjaWV2ZSh0KTtyZXR1cm4gbj4wPyEwOigwPm4mJihyLT0xKSwhMSl9KXx8cj4wfSksbz1mdW5jdGlvbihlKXt0PTEsdi5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnN0YXJ0KGUpfSl9LHU9ZnVuY3Rpb24oZSl7dmFyIHQ9di5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIHQucmVzcG9uc2UoZSl9KS5sZW5ndGg+MCxuPWUuZGF0YVRyYW5zZmVyO24mJihuLmRyb3BFZmZlY3Q9dD9cImNvcHlcIjpcIm5vbmVcIiksZS5wcmV2ZW50RGVmYXVsdCgpfSxhPWZ1bmN0aW9uKGUpe3Q9MCxuPTAsdi5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmVuZChlKX0pfSxjPWZ1bmN0aW9uKGUpe2NsZWFyVGltZW91dChyKTt2YXIgbj1cImRyYWdsZWF2ZVwiPT09ZS50eXBlO258fHR8fG8oZSksdShlKSxuJiYocj1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7cmV0dXJuIGEoZSl9LDEwMCkpfSxoPWZ1bmN0aW9uKGUpe2UucHJldmVudERlZmF1bHQoKSxjbGVhclRpbWVvdXQociksYShlKTt2YXIgdD12LmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gdC5jb250YWlucyhlLnRhcmdldCl9KTtpZighKHQubGVuZ3RoPDEpKXt2YXIgbj1lLmRhdGFUcmFuc2Zlcjt0cnl7aWYobi5nZXREYXRhKFwidGV4dC9odG1sXCIpKXJldHVybn1jYXRjaChvKXt9aShuLHQpfX07ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdlbnRlclwiLGMsITEpLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnb3ZlclwiLGMsITEpLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnbGVhdmVcIixjLCExKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiZHJvcFwiLGgsITEpfX12YXIgYT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsci5rZXkscil9fXJldHVybiBmdW5jdGlvbih0LG4scil7cmV0dXJuIG4mJmUodC5wcm90b3R5cGUsbiksciYmZSh0LHIpLHR9fSgpLGM9bigyKSxsPW4oOSksZj1uKDEyKSxoPTEwMCxwPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoZSl7cih0aGlzLHQpO3ZhciBuPWkodGhpcyxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCkuY2FsbCh0aGlzKSk7cmV0dXJuIG4uYXJlYUVsZW1lbnQ9ZSxufXJldHVybiBvKHQsZSksYSh0LFt7a2V5OlwiY29udGFpbnNcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5hcmVhRWxlbWVudC5jb250YWlucyhlKX19LHtrZXk6XCJzdGFydFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dGhpcy5lbWl0KFwic3RhcnRcIixlLHQpfX0se2tleTpcInJlc3BvbnNlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdD10JiZ0aGlzLmNvbnRhaW5zKGUudGFyZ2V0KSx0aGlzLmVtaXQoXCJyZXNwb25zZVwiLGUsdCksdH19LHtrZXk6XCJlbmRcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLmVtaXQoXCJlbmRcIixlKX19XSksdH0oYyksdj1bXSxkPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0KXtyKHRoaXMsZSksdi5sZW5ndGg8MSYmdSgpLHYucHVzaCh0aGlzKSx0aGlzLmNvcmU9dCx0aGlzLmFyZWFzPVtdfXJldHVybiBhKGUsW3trZXk6XCJhZGRBcmVhXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztyZXR1cm4gZT1uZXcgcChlKSx0aGlzLmFyZWFzLnB1c2goZSksZS5kZXN0cm95PWZ1bmN0aW9uKCl7ZS5yZW1vdmVBbGxMaXN0ZW5lcnMoKTt2YXIgbj10LmFyZWFzLmluZGV4T2YoZSk7bj4tMSYmdC5hcmVhcy5zcGxpY2UobiwxKX0sZX19LHtrZXk6XCJjb250YWluc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmFyZWFzLnNvbWUoZnVuY3Rpb24odCl7cmV0dXJuIHQuY29udGFpbnMoZSl9KX19LHtrZXk6XCJzdGFydFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuYXJlYXMuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gdC5zdGFydChlKX0pfX0se2tleTpcInJlc3BvbnNlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuYXJlYXMubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnJlc3BvbnNlKGUpfSkuc29tZShmdW5jdGlvbihlKXtyZXR1cm4gZSE9PSExfSl9fSx7a2V5OlwicmVjaWV2ZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuY29yZS5hZGQoZSk7cmV0dXJuIHQ+MCYmIXRoaXMuY29yZS5pc011bHRpcGxlKCk/LTE6dH19LHtrZXk6XCJlbmRcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLmFyZWFzLmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIHQuZW5kKGUpfSl9fV0pLGV9KCk7ZS5leHBvcnRzPWR9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBpKGUsdCl7aWYoIWUpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiF0fHxcIm9iamVjdFwiIT10eXBlb2YgdCYmXCJmdW5jdGlvblwiIT10eXBlb2YgdD9lOnR9ZnVuY3Rpb24gbyhlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJm51bGwhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiB0KTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx0JiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihlLHQpOmUuX19wcm90b19fPXQpfXZhciBzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcj10W25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLmtleSxyKX19cmV0dXJuIGZ1bmN0aW9uKHQsbixyKXtyZXR1cm4gbiYmZSh0LnByb3RvdHlwZSxuKSxyJiZlKHQsciksdH19KCksdT1uKDEwKSxhPW4oMyksYz1hLkRlZmVycmVkLGw9bigxMSksZj12b2lkIDAsaD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cmV0dXJuIHIodGhpcyx0KSxpKHRoaXMsT2JqZWN0LmdldFByb3RvdHlwZU9mKHQpLmFwcGx5KHRoaXMsYXJndW1lbnRzKSl9cmV0dXJuIG8odCxlKSxzKHQsW3trZXk6XCJnZXRBc0RhdGFVcmxcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPWMoKSxyPW5ldyBGaWxlUmVhZGVyLGk9dm9pZCAwO3Iub25sb2FkZW5kPWZ1bmN0aW9uKCl7ci5yZWFkeVN0YXRlPT1GaWxlUmVhZGVyLkRPTkU/bi5yZXNvbHZlKHIucmVzdWx0KTpuLnJlamVjdCgpLGNsZWFyVGltZW91dChpKSxyLm9ubG9hZGVuZD1udWxsfSxyLnJlYWRBc0RhdGFVUkwoZSk7dmFyIG89ZnVuY3Rpb24oKXtyJiZyLmFib3J0KCkscj1udWxsfTt0JiYoaT1zZXRUaW1lb3V0KG8sdCkpO3ZhciBzPW4ucHJvbWlzZSgpO3JldHVybiBzLmFib3J0PW8sc319LHtrZXk6XCJnZXRUcmFuc3BvcnRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRyYW5zcG9ydHx8KHRoaXMudHJhbnNwb3J0PW5ldyBsKHRoaXMpKSx0aGlzLnRyYW5zcG9ydH19LHtrZXk6XCJjYW5TbGljZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuISEoQmxvYi5wcm90b3R5cGUuc2xpY2V8fEJsb2IucHJvdG90eXBlLm1velNsaWNlfHxCbG9iLnByb3RvdHlwZS53ZWJraXRTbGljZSl9fSx7a2V5Olwic2xpY2VcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7dmFyIHI9ZS5zbGljZXx8ZS5tb3pTbGljZXx8ZS53ZWJraXRTbGljZTtyZXR1cm4gci5jYWxsKGUsdCxuKX19LHtrZXk6XCJtZDVcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1jKCk7aWYoIXdpbmRvdy5TcGFya01ENSlyZXR1cm4gdC5yZWplY3QoKSx0LnByb21pc2UoKTt2YXIgbj0yMDk3MTUyLHI9TWF0aC5jZWlsKGUuc2l6ZS9uKSxpPTAsbz1uZXcgU3BhcmtNRDUuQXJyYXlCdWZmZXIscz1lLm1velNsaWNlfHxlLndlYmtpdFNsaWNlfHxlLnNsaWNlLHU9bmV3IEZpbGVSZWFkZXIsYT1mdW5jdGlvbigpe2lmKHUpe3ZhciBjPXZvaWQgMCxsPXZvaWQgMDtjPWkqbixsPU1hdGgubWluKGMrbixlLnNpemUpLHUub25sb2FkPWZ1bmN0aW9uKCl7byYmby5hcHBlbmQodS5yZXN1bHQpfSx1Lm9ubG9hZGVuZD1mdW5jdGlvbigpe3UmJih1LnJlYWR5U3RhdGU9PUZpbGVSZWFkZXIuRE9ORT8rK2k8cj9zZXRUaW1lb3V0KGEsMSk6c2V0VGltZW91dChmdW5jdGlvbigpe28mJnQucmVzb2x2ZShvLmVuZCgpKSxhPWU9bz1udWxsfSw1MCk6dC5yZWplY3QoKSx1Lm9ubG9hZGVuZD11Lm9ubG9hZD1udWxsKX0sdS5yZWFkQXNBcnJheUJ1ZmZlcihzLmNhbGwoZSxjLGwpKX19O2EoKTt2YXIgbD10LnByb21pc2UoKTtyZXR1cm4gbC5hYm9ydD1mdW5jdGlvbigpe3UmJnUuYWJvcnQoKSxvPW51bGwsdT1udWxsfSxsfX1dLFt7a2V5OlwiZ2V0SW5zdGFuY2VcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBmfHwoZj1uZXcgdCksZn19XSksdH0odSk7ZS5leHBvcnRzPWh9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBpKGUsdCl7aWYoIWUpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiF0fHxcIm9iamVjdFwiIT10eXBlb2YgdCYmXCJmdW5jdGlvblwiIT10eXBlb2YgdD9lOnR9ZnVuY3Rpb24gbyhlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJm51bGwhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiB0KTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx0JiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihlLHQpOmUuX19wcm90b19fPXQpfXZhciBzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcj10W25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLmtleSxyKX19cmV0dXJuIGZ1bmN0aW9uKHQsbixyKXtyZXR1cm4gbiYmZSh0LnByb3RvdHlwZSxuKSxyJiZlKHQsciksdH19KCksdT1uKDIpLGE9big0KSxjPW4oMyksbD1jLkRlZmVycmVkLGY9big2KSxoPWYuTmV0d29ya0Vycm9yLHA9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiByKHRoaXMsdCksaSh0aGlzLE9iamVjdC5nZXRQcm90b3R5cGVPZih0KS5hcHBseSh0aGlzLGFyZ3VtZW50cykpfXJldHVybiBvKHQsZSkscyh0LFt7a2V5OlwibWQ1XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9bCgpO3JldHVybiB0LnJlamVjdCgpLHQucHJvbWlzZSgpfX0se2tleTpcImdldEFzRGF0YVVybFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49bCgpO3JldHVybiBuLnJlamVjdCgpLG4ucHJvbWlzZSgpfX0se2tleTpcImdldFRyYW5zcG9ydFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9fSx7a2V5OlwiZ2V0VXBsb2FkaW5nXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51cGxvYWRpbmd8fCh0aGlzLnVwbG9hZGluZz1uZXcgdih0aGlzKSksdGhpcy51cGxvYWRpbmd9fSx7a2V5OlwiY2FuU2xpY2VcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiExfX0se2tleTpcInNsaWNlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwidGhpcyBydW50aW1lIGN1cnJlbnQgbm90IHN1cHBvcnQgc2xpY2VcIil9fSx7a2V5OlwiY2FuY2VsXCIsdmFsdWU6ZnVuY3Rpb24oZSl7fX1dKSx0fSh1KTtlLmV4cG9ydHM9cDt2YXIgdj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCl7cih0aGlzLGUpLHRoaXMucnVudGltZT10fXJldHVybiBzKGUsW3trZXk6XCJnZW5lcmF0ZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMsbj1sKCkscj1lLmdldEZpbGUoKSxpPXRoaXMucnVudGltZSxvPXIuZ2V0U291cmNlKCkscz1yLnNpemUsdT1lLmdldENodW5rU2l6ZSgpLGE9ZS5pc0NodW5rRW5hYmxlKCksYz1NYXRoLm1heChlLmdldENodW5rUHJvY2Vzc1RocmVhZHMoKSwxKSxmPTAsaD0wLHA9W10sdj1mdW5jdGlvbigpe3JldHVybiBwLnJlZHVjZShmdW5jdGlvbihlLHQpe3JldHVybiBlKyhcInBlbmRpbmdcIj09PXQuc3RhdGUoKT8xOjApfSwwKX0sZD1mdW5jdGlvbigpe2Zvcih2YXIgbj12b2lkIDAscj12b2lkIDAsYT12b2lkIDA7cz5oJiZ2KCk8YzspZj1oLGg9TWF0aC5taW4oaCt1LHMpLGE9aS5zbGljZShvLGYsaCkscj1lLmNyZWF0ZUNodW5rUmVxdWVzdChwLmxlbmd0aCxhKSxyLnNldEhlYWRlcihcIkNvbnRlbnQtUmFuZ2VcIixcImJ5dGVzIFwiK2YrXCItXCIrKGgtMSkrXCIvXCIrcyksbj10LnNsb3QocixlLmdldENodW5rUmV0cmllcygpKSxuLnByb2dyZXNzKHkpLmRvbmUobSkuZmFpbChrKSxwLnB1c2gobil9LHk9ZnVuY3Rpb24oKXt2YXIgZT1zLWgsdD0wO3AuZm9yRWFjaChmdW5jdGlvbihuKXtlKz1uLnRvdGFsLHQrPW4ubG9hZGVkfSksbi5ub3RpZnkoe3RvdGFsOmUsbG9hZGVkOnR9KX0sbT1mdW5jdGlvbihlKXthJiZkKCksaD49cyYmcC5ldmVyeShmdW5jdGlvbihlKXtyZXR1cm5cInJlc29sdmVkXCI9PT1lLnN0YXRlKCl9KSYmbi5yZXNvbHZlKGUpfSxnPWZ1bmN0aW9uKCl7cC5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmFib3J0KCl9KX0saz1mdW5jdGlvbihlKXtuLnJlamVjdChlKSxnKCl9O2lmKGEpZCgpO2Vsc2V7aD1zO3ZhciBiPXRoaXMuc2xvdChlLmNyZWF0ZUNodW5rUmVxdWVzdCgwLG8pLDApO2IucHJvZ3Jlc3MoeSkuZG9uZShtKS5mYWlsKGspLHAucHVzaChiKX12YXIgRT1uLnByb21pc2UoKTtyZXR1cm4gRS5hYm9ydD1nLEV9fSx7a2V5Olwic2xvdFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49bCgpLHI9dGhpcy5ydW50aW1lLGk9ZS5nZXRGaWxlKCkuZ2V0Q29yZSgpLG89bi5wcm9taXNlKCkscz1mdW5jdGlvbihlKXtlLnRvdGFsJiYoby50b3RhbD1lLnRvdGFsKSxlLmxvYWRlZCYmKG8ubG9hZGVkPWUubG9hZGVkKSxuLm5vdGlmeShlKX0sdT1mdW5jdGlvbigpe3ZhciB0LHUsbDtvLmFib3J0PWZ1bmN0aW9uKCl7dCYmdC5hYm9ydCgpLHUmJnUuYWJvcnQoKSxsJiZsLmFib3J0KCl9LG8udG90YWw9ZS5nZXRCbG9iKCkuc2l6ZSxvLmxvYWRlZD0wLHQ9aS5pbnZva2UoYS5DSFVOS19VUExPQURfUFJFUEFSSU5HLGUpLHQudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gdT1yLmdldFRyYW5zcG9ydCgpLmdlbmVyYXRlKGUpLHUucHJvZ3Jlc3MocyksdX0pLnRoZW4oZnVuY3Rpb24odCl7cmV0dXJuIGw9aS5pbnZva2UoYS5DSFVOS19VUExPQURfQ09NUExFVElORyxlLmNyZWF0ZUNodW5rUmVzcG9uc2UodCkpfSkuZG9uZShuLnJlc29sdmUpLmZhaWwoYyl9LGM9ZnVuY3Rpb24oZSl7ZSBpbnN0YW5jZW9mIGgmJnQtLSA+MD9zZXRUaW1lb3V0KHUsNTAwKTpuLnJlamVjdChlKSxvLmFib3J0KCl9O3JldHVybiB1KCksb319XSksZX0oKX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfXZhciBpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcj10W25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIua2V5LHIpfX1yZXR1cm4gZnVuY3Rpb24odCxuLHIpe3JldHVybiBuJiZlKHQucHJvdG90eXBlLG4pLHImJmUodCxyKSx0fX0oKSxvPW4oMykscz1vLkRlZmVycmVkLHU9big2KSxhPXUuVGltZW91dEVycm9yLGM9dS5BYm9ydEVycm9yLGw9dS5OZXR3b3JrRXJyb3IsZj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXtyKHRoaXMsZSl9cmV0dXJuIGkoZSxbe2tleTpcImdlbmVyYXRlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9cygpLG49bmV3IFhNTEh0dHBSZXF1ZXN0LHI9dm9pZCAwLGk9ZnVuY3Rpb24oKXtuLm9ubG9hZD1uLm9uZXJyb3I9bnVsbCxuLnVwbG9hZCYmKG4udXBsb2FkLm9ucHJvZ3Jlc3M9bnVsbCksciYmY2xlYXJUaW1lb3V0KHIpfSxvPWZ1bmN0aW9uKCl7aSgpO3RyeXtuLmFib3J0KCl9Y2F0Y2goZSl7fX0sdT1mdW5jdGlvbihlKXtyZXR1cm4gaSgpLG4uc3RhdHVzfHxcImVycm9yXCIhPT1lLnR5cGU/MD09PW4uc3RhdHVzfHwzMDQ9PT1uLnN0YXR1c3x8bi5zdGF0dXM+PTIwMCYmbi5zdGF0dXM8MzAwP3QucmVzb2x2ZShuLnJlc3BvbnNlVGV4dCk6dC5yZWplY3QobmV3IGwobi5zdGF0dXMsbi5zdGF0dXNUZXh0KSk6dC5yZWplY3QobmV3IGMoZS5tZXNzYWdlKSl9O24udXBsb2FkJiYobi51cGxvYWQub25wcm9ncmVzcz1mdW5jdGlvbihlKXtyZXR1cm4gdC5ub3RpZnkoZSl9KSxuLm9uZXJyb3I9dSxuLm9ubG9hZD11O3ZhciBmPWUuZ2V0VGltZW91dCgpO2Y+MCYmKHI9c2V0VGltZW91dChmdW5jdGlvbigpe28oKSx0LnJlamVjdChuZXcgYShcInRpbWVvdXQ6XCIrZikpfSxmKSk7dHJ5eyFmdW5jdGlvbigpe24ub3BlbihcIlBPU1RcIixlLmdldFVybCgpLCEwKSxlLmlzV2l0aENyZWRlbnRpYWxzKCkmJihuLndpdGhDcmVkZW50aWFscz0hMCksZS5nZXRIZWFkZXJzKCkuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gbi5zZXRSZXF1ZXN0SGVhZGVyKGUubmFtZSxlLnZhbHVlKX0pO3ZhciB0PW5ldyBGb3JtRGF0YSxyPWUuZ2V0QmxvYigpO2UuZ2V0UGFyYW1zKCkudG9BcnJheSgpLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIHQuYXBwZW5kKGUubmFtZSxlLnZhbHVlKX0pLHQuYXBwZW5kKGUuZ2V0TmFtZSgpLHIsci5uYW1lfHxcImJsb2JcIiksbi5zZW5kKHQpfSgpfWNhdGNoKGgpe28oKSx0LnJlamVjdChuZXcgYyhoLm1lc3NhZ2UpKX12YXIgcD10LnByb21pc2UoKTtyZXR1cm4gcC5hYm9ydD1vLHB9fV0pLGV9KCk7ZS5leHBvcnRzPWZ9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUsdCl7aWYoIWUpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiF0fHxcIm9iamVjdFwiIT10eXBlb2YgdCYmXCJmdW5jdGlvblwiIT10eXBlb2YgdD9lOnR9ZnVuY3Rpb24gaShlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJm51bGwhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiB0KTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx0JiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihlLHQpOmUuX19wcm90b19fPXQpfWZ1bmN0aW9uIG8oZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIHMoKXtyZXR1cm5cIkZJTEUtXCIrKG0rKykudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCl9ZnVuY3Rpb24gdShlKXt2YXIgdD1lLm5hbWUmJmcuZXhlYyhlLm5hbWUpO3JldHVybiB0P3RbMV06KHQ9ZS50eXBlJiZrLmV4ZWMoZS50eXBlKSx0P3RbMV06XCJcIil9ZnVuY3Rpb24gYShlKXtyZXR1cm5bXCJqcGdcIixcImpwZWdcIixcInBuZ1wiLFwiZ2lmXCIsXCJibXBcIixcIndlYnBcIl0uaW5kZXhPZihlLnRvTG93ZXJDYXNlKCkpPi0xP1wiaW1hZ2UvXCIrKFwianBnXCI9PT1lP1wianBlZ1wiOmUpOm51bGx9dmFyIGM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIua2V5LHIpfX1yZXR1cm4gZnVuY3Rpb24odCxuLHIpe3JldHVybiBuJiZlKHQucHJvdG90eXBlLG4pLHImJmUodCxyKSx0fX0oKSxsPW4oMiksZj1uKDQpLGg9bigzKSxwPWguRGVmZXJyZWQsdj1uKDUpLGQ9di5TdGF0dXMseT12LlN0YXR1c05hbWUsbT0wLGc9L1xcLihbXi5dKykkLyxrPS9eaW1hZ2VcXC8oanBnfGpwZWd8cG5nfGdpZnxibXB8d2VicCkkL2ksYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuKXtvKHRoaXMsZSksdGhpcy5jaGFuZ2UodCxuKX1yZXR1cm4gYyhlLFt7a2V5OlwiY2hhbmdlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt0aGlzLnRvdGFsPWUsdGhpcy5sb2FkZWQ9dHx8MCx0aGlzLnBlcmNlbnRhZ2U9dGhpcy5sb2FkZWQ9PT10aGlzLnRvdGFsPzEwMDpNYXRoLmNlaWwodGhpcy5sb2FkZWQvdGhpcy50b3RhbCoxMDApfX0se2tleTpcImRvbmVcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuY2hhbmdlKHRoaXMudG90YWwsdGhpcy50b3RhbCl9fV0pLGV9KCksRT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KGUsbixpKXtvKHRoaXMsdCk7dmFyIGM9cih0aGlzLE9iamVjdC5nZXRQcm90b3R5cGVPZih0KS5jYWxsKHRoaXMpKTtjLmlkPXMoKSxjLm5hbWU9bi5uYW1lfHxpfHxjLmlkO3ZhciBsPXUobikudG9Mb3dlckNhc2UoKTtyZXR1cm4gbCYmIWcudGVzdChjLm5hbWUpJiYoYy5uYW1lKz1cIi5cIitsKSxjLmV4dD1sLGMudHlwZT1uLnR5cGV8fGEoYy5leHQpfHxcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLGMubGFzdE1vZGlmaWVkPW4ubGFzdE1vZGlmaWVkfHwrbmV3IERhdGUsYy5zaXplPW4uc2l6ZXx8MCxjLnJ1bnRpbWU9ZSxjLnNvdXJjZT1uLGMuc3RhdHVzPWQuSU5JVEVELGMucHJvZ3Jlc3M9bmV3IGIoYy5zaXplLDApLGN9cmV0dXJuIGkodCxlKSxjKHQsW3trZXk6XCJnZXRDb3JlXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb3JlfX0se2tleTpcInNldENvcmVcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLmNvcmU9ZSx0aGlzLnNldFByb3BhZ2F0aW9uVGFyZ2V0KGUpfX0se2tleTpcImdldFJ1bnRpbWVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnJ1bnRpbWV9fSx7a2V5OlwiaXNJbWFnZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIGsudGVzdCh0aGlzLnR5cGUpfX0se2tleTpcInNldFN0YXR1c1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuc3RhdHVzO3QhPT1kLkNBTkNFTExFRCYmZSE9PXQmJih0aGlzLnN0YXR1cz1lLHRoaXMuZW1pdChmLkZJTEVfU1RBVFVTX0NIQU5HRSxlLHQpKX19LHtrZXk6XCJnZXRTdGF0dXNcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXR1c319LHtrZXk6XCJnZXRTdGF0dXNOYW1lXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGF0dXMgaW4geT95W3RoaXMuc3RhdHVzXTpcInVua25vd1wifX0se2tleTpcImdldFNvdXJjZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc291cmNlfX0se2tleTpcImdldEFzRGF0YVVybFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9kYXRhVXJsUHJvbWlzZXx8KHRoaXMuX2RhdGFVcmxQcm9taXNlPXRoaXMucnVudGltZS5nZXRBc0RhdGFVcmwodGhpcy5zb3VyY2UsZSkpLHRoaXMuX2RhdGFVcmxQcm9taXNlfX0se2tleTpcIm1kNVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX21kNVByb21pc2V8fCh0aGlzLl9tZDVQcm9taXNlPXRoaXMucnVudGltZS5tZDUodGhpcy5zb3VyY2UpKSx0aGlzLl9tZDVQcm9taXNlfX0se2tleTpcInNlc3Npb25cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXM7aWYodGhpcy5fc2Vzc2lvblByb21pc2UpcmV0dXJuIHRoaXMuX3Nlc3Npb25Qcm9taXNlO3ZhciB0PXAoKTtyZXR1cm4gdC5wcm9ncmVzcyhmdW5jdGlvbih0KXtlLnNldFN0YXR1cyhkLlBST0dSRVNTKSxlLmVtaXQoZi5GSUxFX1VQTE9BRF9QUk9HUkVTUyx0KX0pLmRvbmUoZnVuY3Rpb24odCl7ZS5yZXNwb25zZT10LGUuX3Nlc3Npb249bnVsbCxlLl9zZXNzaW9uUHJvbWlzZT1udWxsLGUuX2Zsb3dzPVtdLGUuc2V0U3RhdHVzKGQuU1VDQ0VTUyksZS5lbWl0KGYuRklMRV9VUExPQURfU1VDQ0VTUyx0KX0pLmZhaWwoZnVuY3Rpb24odCl7ZS5fc2Vzc2lvbj1udWxsLGUuX3Nlc3Npb25Qcm9taXNlPW51bGw7Zm9yKHZhciBuPXZvaWQgMDtuPWUuX2Zsb3dzLnNoaWZ0KCk7KW4uYWJvcnQoKTt0IGluc3RhbmNlb2YgRXJyb3ImJihlLnNldFN0YXR1cyhkLkVSUk9SKSxlLmVtaXQoZi5GSUxFX1VQTE9BRF9FUlJPUix0KSl9KS5hbHdheXMoZnVuY3Rpb24oKXtlLmVtaXQoZi5GSUxFX1VQTE9BRF9DT01QTEVURUQsZS5nZXRTdGF0dXMoKSl9KSx0aGlzLl9mbG93cz1bXSx0aGlzLl9zZXNzaW9uPXQsdGhpcy5fc2Vzc2lvblByb21pc2U9dC5wcm9taXNlKCksdGhpcy5fc2Vzc2lvblByb21pc2V9fSx7a2V5OlwicHJlcGFyZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcztpZih0aGlzLnN0YXR1cyE9PWQuUEVORElOR3x8IXRoaXMuY29yZSlyZXR1cm4hMTt0aGlzLnNlc3Npb24oKSx0aGlzLnNldFN0YXR1cyhkLlBST0dSRVNTKSx0aGlzLmVtaXQoZi5GSUxFX1VQTE9BRF9TVEFSVCksdGhpcy5yZXF1ZXN0PXRoaXMuY29yZS5jcmVhdGVGaWxlUmVxdWVzdCh0aGlzKTt2YXIgdD10aGlzLmNvcmUuaW52b2tlKGYuRklMRV9VUExPQURfUFJFUEFSSU5HLHRoaXMucmVxdWVzdCk7cmV0dXJuIHRoaXMuX2Zsb3dzLnB1c2godCksdC50aGVuKGZ1bmN0aW9uKHQpe2UuZW1pdChmLkZJTEVfVVBMT0FEX1BSRVBBUkVELHQpO3ZhciBuPWUucnVudGltZS5nZXRVcGxvYWRpbmcoKS5nZW5lcmF0ZSh0KTtyZXR1cm4gZS5fZmxvd3MucHVzaChuKSxuLnByb2dyZXNzKGZ1bmN0aW9uKHQpe2UucHJvZ3Jlc3MuY2hhbmdlKHQudG90YWwsdC5sb2FkZWQpLGUuX3Nlc3Npb24ubm90aWZ5KGUucHJvZ3Jlc3MpfSksbn0pLnRoZW4oZnVuY3Rpb24odCl7cmV0dXJuIGUuY29tcGxldGUodCl9LHRoaXMuX3Nlc3Npb24ucmVqZWN0KSwhMH19LHtrZXk6XCJjb21wbGV0ZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKHRoaXMuc3RhdHVzPT09ZC5QUk9HUkVTUyl7Zm9yKHZhciB0PXZvaWQgMDt0PXRoaXMuX2Zsb3dzLnNoaWZ0KCk7KXQuYWJvcnQoKTt0aGlzLnByb2dyZXNzLmRvbmUoKSx0aGlzLl9zZXNzaW9uLm5vdGlmeSh0aGlzLnByb2dyZXNzKSxlPXRoaXMucmVxdWVzdC5jcmVhdGVGaWxlUmVzcG9uc2UoZSksdGhpcy5zZXRTdGF0dXMoZC5FTkQpLHRoaXMuZW1pdChmLkZJTEVfVVBMT0FEX0VORCk7dmFyIG49dGhpcy5jb3JlLmludm9rZShmLkZJTEVfVVBMT0FEX0NPTVBMRVRJTkcsZSk7dGhpcy5fZmxvd3MucHVzaChuKSxuLnRoZW4odGhpcy5fc2Vzc2lvbi5yZXNvbHZlLHRoaXMuX3Nlc3Npb24ucmVqZWN0KX19fSx7a2V5OlwicGVuZGluZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7KHRoaXMuc3RhdHVzPT09ZC5FUlJPUnx8dGhpcy5zdGF0dXM9PT1kLlFVRVVFRCkmJih0aGlzLnByb2dyZXNzLmNoYW5nZSh0aGlzLnNpemUsMCksdGhpcy5zZXRTdGF0dXMoZC5QRU5ESU5HKSl9fSx7a2V5OlwiYWJvcnRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX3Nlc3Npb24mJnRoaXMuX3Nlc3Npb24ucmVqZWN0KCksdGhpcy5fc2Vzc2lvbj1udWxsLHRoaXMuX3Nlc3Npb25Qcm9taXNlPW51bGx9fSx7a2V5OlwiY2FuY2VsXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnNldFN0YXR1cyhkLkNBTkNFTExFRCksdGhpcy5lbWl0KGYuRklMRV9DQU5DRUwpLHRoaXMuYWJvcnQoKSx0aGlzLnJ1bnRpbWUuY2FuY2VsKHRoaXMuc291cmNlKSx0aGlzLl9kYXRhVXJsUHJvbWlzZSYmdGhpcy5fZGF0YVVybFByb21pc2UuYWJvcnQoKSx0aGlzLl9tZDVQcm9taXNlJiZ0aGlzLl9tZDVQcm9taXNlLmFib3J0JiZ0aGlzLl9tZDVQcm9taXNlLmFib3J0KCksdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKX19LHtrZXk6XCJkZXN0cm95XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmNhbmNlbCgpfX1dKSx0fShsKTtlLmV4cG9ydHM9RX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfXZhciBpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcj10W25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLmtleSxyKX19cmV0dXJuIGZ1bmN0aW9uKHQsbixyKXtyZXR1cm4gbiYmZSh0LnByb3RvdHlwZSxuKSxyJiZlKHQsciksdH19KCksbz1uKDIpLHM9big5KSx1PW4oMTIpLGE9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQpe3IodGhpcyxlKSx0aGlzLmNvcmU9dCx0aGlzLnJ1bnRpbWU9cy5nZXRJbnN0YW5jZSgpfXJldHVybiBpKGUsW3trZXk6XCJhZGRBcmVhXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5jb3JlLG49dGhpcy5ydW50aW1lLHI9bmV3IG8saT1mdW5jdGlvbihlKXt2YXIgaT1lLmNsaXBib2FyZERhdGF8fHdpbmRvdy5jbGlwYm9hcmREYXRhLG89aS5pdGVtcyxzPWkuZmlsZXM7aWYoc3x8byl7dmFyIGE9dm9pZCAwLGM9dm9pZCAwLGw9dm9pZCAwLGY9dm9pZCAwLGg9dm9pZCAwLHA9dm9pZCAwO2lmKHMmJnMubGVuZ3RoKWZvcihhPXMubGVuZ3RoPjAsYz0wLGw9cy5sZW5ndGg7bD5jJiYoZj1uZXcgdShuLHNbY10pLGE9MSxwPXQuYWRkKGYpLCEoMD5wfHxwPjAmJiF0LmlzTXVsdGlwbGUoKSkpO2MrKyk7ZWxzZSBpZihvJiZvLmxlbmd0aCl7dmFyIHY9aS5nZXREYXRhKFwidGV4dC9wbGFpblwiKTtmb3IoYz0wLGw9by5sZW5ndGg7bD5jJiYhdC5pc0xpbWl0KCkmJihoPW9bY10sIShcImZpbGVcIj09PWgua2luZCYmKGY9aC5nZXRBc0ZpbGUoKSkmJihmPW5ldyB1KG4sZix2KSx2PW51bGwsYT0xLHA9dC5hZGQoZiksMD5wfHxwPjAmJiF0LmlzTXVsdGlwbGUoKSkpKTtjKyspO31hJiYoZS5wcmV2ZW50RGVmYXVsdCgpLGUuc3RvcFByb3BhZ2F0aW9uKCksci5lbWl0KFwicGFzdGVcIixpKSl9fTtyZXR1cm5cIkRhdGFUcmFuc2ZlclwiaW4gd2luZG93JiZcIkZpbGVMaXN0XCJpbiB3aW5kb3cmJmUuYWRkRXZlbnRMaXN0ZW5lciYmZS5hZGRFdmVudExpc3RlbmVyKFwicGFzdGVcIixpLCExKSxyLmRlc3Ryb3k9ZnVuY3Rpb24oKXtyLnJlbW92ZUFsbExpc3RlbmVycygpLGUucmVtb3ZlRXZlbnRMaXN0ZW5lciYmZS5yZW1vdmVFdmVudExpc3RlbmVyKFwicGFzdGVcIixpLCExKX0scn19XSksZX0oKTtlLmV4cG9ydHM9YX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSx0KXtpZighZSl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIXR8fFwib2JqZWN0XCIhPXR5cGVvZiB0JiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0P2U6dH1mdW5jdGlvbiBpKGUsdCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCYmbnVsbCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIHQpO2UucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodCYmdC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTplLGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLHQmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKGUsdCk6ZS5fX3Byb3RvX189dCl9ZnVuY3Rpb24gbyhlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9dmFyIHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIua2V5LHIpfX1yZXR1cm4gZnVuY3Rpb24odCxuLHIpe3JldHVybiBuJiZlKHQucHJvdG90eXBlLG4pLHImJmUodCxyKSx0fX0oKSx1PW4oMiksYT1uKDkpLGM9bigxNSksbD1uKDEyKSxmPW4oMyksaD1mLmV4dGVuZCxwPVwiXCIsdj1mdW5jdGlvbigpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiBlLmlubmVySFRNTD10LHQ9ZS5maXJzdENoaWxkLGUucmVtb3ZlQ2hpbGQodCksdH19KCksZD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuKXt2YXIgcj10aGlzO28odGhpcyxlKTt2YXIgaT12KCc8bGFiZWwgc3R5bGU9XCJwb3NpdGlvbjpmaXhlZDtsZWZ0Oi0xMDBweDt0b3A6LTEwMHB4O3dpZHRoOjUwcHg7aGVpZ2h0OjUwcHg7ZGlzcGxheTpibG9jaztjdXJzb3I6cG9pbnRlcjtvdmVyZmxvdzpoaWRkZW47ei1pbmRleDo5OTk5OTtvcGFjaXR5OjA7ZmlsdGVyOmFscGhhKG9wYWNpdHk9MClcIj48L2xhYmVsPicpLHM9bmV3IGMoaSxwLGZ1bmN0aW9uKCl7cmV0dXJue2FjY2VwdDp0LmdldEFjY2VwdCgpLG11bHRpcGxlOnQuaXNNdWx0aXBsZSgpfX0pO3Mub24oXCJzZWxlY3RcIixmdW5jdGlvbihlKXtuKGUuZmlsZXMscyksci5jdXJyZW50JiZyLmN1cnJlbnQuZW1pdChcImZpbGVzXCIsZS5maWxlcyxzKX0pLHMub24oXCJyb2xsT3V0XCIsZnVuY3Rpb24oKXtyZXR1cm4gci5oaWRlT3ZlcmxheSgpfSksZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpKSx0aGlzLm92ZXJsYXk9aX1yZXR1cm4gcyhlLFt7a2V5OlwiaGlkZU92ZXJsYXlcIix2YWx1ZTpmdW5jdGlvbigpe2godGhpcy5vdmVybGF5LnN0eWxlLHtsZWZ0OlwiLTEwMHB4XCIsdG9wOlwiLTEwMHB4XCIsd2lkdGg6XCI1MHB4XCIsaGVpZ2h0OlwiNTBweFwifSksdGhpcy5jdXJyZW50JiYodGhpcy5jdXJyZW50LmVtaXQoXCJyb2xsT3V0XCIpLHRoaXMuY3VycmVudD1udWxsKX19LHtrZXk6XCJhZGRcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLG49dGhpcy5vdmVybGF5LHI9bmV3IHUsaT1mdW5jdGlvbigpe3ZhciBpPWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7aChuLnN0eWxlLHtsZWZ0OmkubGVmdCtcInB4XCIsdG9wOmkudG9wK1wicHhcIix3aWR0aDppLnJpZ2h0LWkubGVmdCtcInB4XCIsaGVpZ2h0OmkuYm90dG9tLWkudG9wK1wicHhcIn0pLHIuZW1pdChcInJvbGxPdmVyXCIpLHQuY3VycmVudCYmdC5jdXJyZW50IT09ciYmdC5jdXJyZW50LmVtaXQoXCJyb2xsT3V0XCIpLHQuY3VycmVudD1yfTtyZXR1cm4gZS5hZGRFdmVudExpc3RlbmVyP2UuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLGksITEpOmUuYXR0YWNoRXZlbnQmJmUuYXR0YWNoRXZlbnQoXCJvbm1vdXNlb3ZlclwiLGkpLHIuZGVzdHJveT1mdW5jdGlvbigpe3QuY3VycmVudD09PXImJnQuaGlkZU92ZXJsYXkoKSxyLnJlbW92ZUFsbExpc3RlbmVycygpLGUucmVtb3ZlRXZlbnRMaXN0ZW5lcj9lLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW92ZXJcIixpLCExKTplLmRldGFjaEV2ZW50JiZlLmRldGFjaEV2ZW50KFwib25tb3VzZW92ZXJcIixpKX0scn19XSksZX0oKSx5PWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoZSxuLGkpe28odGhpcyx0KTt2YXIgcz1yKHRoaXMsT2JqZWN0LmdldFByb3RvdHlwZU9mKHQpLmNhbGwodGhpcykpO3JldHVybiBzLnRyaWdnZXI9ZSxzLmNvcmU9bixzLmxhYmVsPXYoJzxsYWJlbCBzdHlsZT1cInBvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDt3aWR0aDoxMDAlO2hlaWdodDoxMDAlO2Rpc3BsYXk6aW5saW5lLWJsb2NrO2N1cnNvcjpwb2ludGVyO2JhY2tncm91bmQ6I2ZmZjtvdmVyZmxvdzpoaWRkZW47b3BhY2l0eTowXCI+PC9sYWJlbD4nKSxzLm9uQ2hhbmdlPWZ1bmN0aW9uKGUpe2koZS50YXJnZXQuZmlsZXMpLHMuZGVzdHJveUlucHV0KCkscy5jcmVhdGVJbnB1dCgpfSxlLmFwcGVuZENoaWxkKHMubGFiZWwpLHMuY3JlYXRlSW5wdXQoKSxzfXJldHVybiBpKHQsZSkscyh0LFt7a2V5OlwiY3JlYXRlSW5wdXRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXYoJzxpbnB1dCB0eXBlPVwiZmlsZVwiIHN0eWxlPVwicG9zaXRpb246YWJzb2x1dGU7Y2xpcDpyZWN0KDFweCAxcHggMXB4IDFweCk7XCIgLz4nKSx0PXRoaXMuY29yZS5nZXRBY2NlcHQoKTt0JiZ0Lmxlbmd0aD4wJiYodD10Lm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5taW1lVHlwZXN8fFwiLlwiK2UuZXh0ZW5zaW9ucy5qb2luKFwiLC5cIil9KSxlLnNldEF0dHJpYnV0ZShcImFjY2VwdFwiLHQuam9pbihcIixcIikpKSx0aGlzLmNvcmUuaXNNdWx0aXBsZSgpJiZlLnNldEF0dHJpYnV0ZShcIm11bHRpcGxlXCIsXCJtdWx0aXBsZVwiKSxlLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIix0aGlzLm9uQ2hhbmdlLCExKSx0aGlzLmxhYmVsLmFwcGVuZENoaWxkKGUpLHRoaXMuaW5wdXQ9ZX19LHtrZXk6XCJkZXN0cm95SW5wdXRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuaW5wdXQmJih0aGlzLmlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIix0aGlzLm9uQ2hhbmdlLCExKSx0aGlzLmxhYmVsLnJlbW92ZUNoaWxkKHRoaXMuaW5wdXQpLHRoaXMuaW5wdXQ9bnVsbCl9fSx7a2V5OlwiZGVzdHJveVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5kZXN0cm95SW5wdXQoKSx0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpLHRoaXMudHJpZ2dlci5yZW1vdmVDaGlsZCh0aGlzLmxhYmVsKX19XSksdH0odSksbT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuKXtvKHRoaXMsZSk7dmFyIHI9YS5nZXRJbnN0YW5jZSgpO3RoaXMuY29yZT10LHRoaXMub25GaWxlcz1mdW5jdGlvbihlKXtuKGUscil9fXJldHVybiBzKGUsW3trZXk6XCJhZGRcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gbmV3IHkoZSx0aGlzLmNvcmUsdGhpcy5vbkZpbGVzKX19XSksZX0oKSxnPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0KXtvKHRoaXMsZSk7dmFyIG49ZnVuY3Rpb24oZSxuKXtmb3IodmFyIHI9MCxpPWUubGVuZ3RoO2k+ciYmISh0LmFkZChuZXcgbChuLGVbcl0pKTwwKTtyKyspO307XCJEYXRhVHJhbnNmZXJcImluIHdpbmRvdyYmXCJGaWxlTGlzdFwiaW4gd2luZG93P3RoaXMudHJpZ2dlckNvbGxlY3Rpb249bmV3IG0odCxuKTp0aGlzLnRyaWdnZXJDb2xsZWN0aW9uPW5ldyBkKHQsbil9cmV0dXJuIHMoZSxudWxsLFt7a2V5Olwic2V0U1dGXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cD1lfX1dKSxzKGUsW3trZXk6XCJhZGRBcmVhXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudHJpZ2dlckNvbGxlY3Rpb24uYWRkKGUpfX1dKSxlfSgpO2UuZXhwb3J0cz1nfSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gaShlLHQpe2lmKCFlKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hdHx8XCJvYmplY3RcIiE9dHlwZW9mIHQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/ZTp0fWZ1bmN0aW9uIG8oZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgdCk7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YoZSx0KTplLl9fcHJvdG9fXz10KX1mdW5jdGlvbiBzKCl7dmFyIGU9dm9pZCAwO3RyeXtlPW5hdmlnYXRvci5wbHVnaW5zW1wiU2hvY2t3YXZlIEZsYXNoXCJdLGU9ZS5kZXNjcmlwdGlvbn1jYXRjaCh0KXt0cnl7ZT1uZXcgQWN0aXZlWE9iamVjdChcIlNob2Nrd2F2ZUZsYXNoLlNob2Nrd2F2ZUZsYXNoXCIpLkdldFZhcmlhYmxlKFwiJHZlcnNpb25cIil9Y2F0Y2gobil7ZT1cIjAuMFwifX1yZXR1cm4gZT1lLm1hdGNoKC9cXGQrL2cpLHBhcnNlRmxvYXQoZVswXStcIi5cIitlWzFdKX1mdW5jdGlvbiB1KGUsdCxuKXt0cnl7ZS5DYWxsRnVuY3Rpb24oJzxpbnZva2UgbmFtZT1cIicrdCsnXCIgcmV0dXJudHlwZT1cImphdmFzY3JpcHRcIj4nK19fZmxhc2hfX2FyZ3VtZW50c1RvWE1MKG58fFtdLDApK1wiPC9pbnZva2U+XCIpfWNhdGNoKHIpe3Rocm93XCJDYWxsIHRvIFwiK3QrXCIgZmFpbGVkXCJ9fWZ1bmN0aW9uIGEoZSx0KXtpZihzKCk8MTEuNCl0aHJvd1wiZmxhc2ggcGxheWVyIGlzIG5vdCBhdmFpbGFibGVcIjt2YXIgbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHI9ZSsoZS5pbmRleE9mKFwiP1wiKT4wP1wiJlwiOlwiP1wiKStcImNhbGxJbnRlcmZhY2U9XCIrZW5jb2RlVVJJQ29tcG9uZW50KHQpLGk9WydpZD1cIicrdCsnLVBpY2tlclwiJywndHlwZT1cImFwcGxpY2F0aW9uL3gtc2hvY2t3YXZlLWZsYXNoXCInLCdkYXRhPVwiJytyKydcIicsJ3dpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIicsJ3N0eWxlPVwicG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3RvcDowO2Rpc3BsYXk6YmxvY2s7ei1pbmRleDoxO291dGxpbmU6MFwiJ107cmV0dXJuIHdpbmRvdy5BY3RpdmVYT2JqZWN0JiZpLnB1c2goJ2NsYXNzaWQ9XCJjbHNpZDpkMjdjZGI2ZS1hZTZkLTExY2YtOTZiOC00NDQ1NTM1NDAwMDBcIicpLG4uaW5uZXJIVE1MPVwiPG9iamVjdCBcIitpLmpvaW4oXCIgXCIpKyc+PHBhcmFtIG5hbWU9XCJtb3ZpZVwiIHZhbHVlPVwiJytyKydcIiAvPjxwYXJhbSBuYW1lPVwid21vZGVcIiB2YWx1ZT1cInRyYW5zcGFyZW50XCIgLz48cGFyYW0gbmFtZT1cImFsbG93c2NyaXB0YWNjZXNzXCIgdmFsdWU9XCJhbHdheXNcIiAvPjwvb2JqZWN0Picsbi5maXJzdENoaWxkfWZ1bmN0aW9uIGMoZSl7dmFyIHQ9ZSsocCsrKS50b1N0cmluZygxNik7cmV0dXJuIHQgaW4gd2luZG93P2MoZSk6dH12YXIgbD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsci5rZXkscil9fXJldHVybiBmdW5jdGlvbih0LG4scil7cmV0dXJuIG4mJmUodC5wcm90b3R5cGUsbiksciYmZSh0LHIpLHR9fSgpLGY9bigxMCksaD1uKDE2KSxwPStuZXcgRGF0ZSx2PWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoZSxuLG8pe2Z1bmN0aW9uIHMoKXt2YXIgdD1lLm9mZnNldFdpZHRoLHI9ZS5vZmZzZXRIZWlnaHQsaT12b2lkIDA7cmV0dXJuIHQmJnImJihpPWEobixsKSk/dm9pZCBlLmFwcGVuZENoaWxkKGYuZmxhc2g9aSk6dm9pZCBzZXRUaW1lb3V0KHMsMWUzKX1yKHRoaXMsdCk7dmFyIHU9aSh0aGlzLE9iamVjdC5nZXRQcm90b3R5cGVPZih0KS5jYWxsKHRoaXMpKSxsPWMoXCJGbGFzaFJ1bnRpbWVcIik7dS5jYWxsSW50ZXJmYWNlPWwsd2luZG93W2xdPXUsdS5vcHRpb25zPW87dmFyIGY9dTtyZXR1cm4gcygpLHV9cmV0dXJuIG8odCxlKSxsKHQsW3trZXk6XCJnZXRPcHRpb25zXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLm9wdGlvbnM7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgZSYmKGU9ZSgpKSxlfX0se2tleTpcImdldFRyYW5zcG9ydFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gbmV3IGgodGhpcyxlLHQsbil9fSx7a2V5Olwic2VuZFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuLHIpe3UodGhpcy5mbGFzaCxcImV4ZWNcIixbXCJzZW5kXCIsZSx0LmlkLG4scl0pfX0se2tleTpcImFib3J0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dHJ5e3UodGhpcy5mbGFzaCxcImV4ZWNcIixbXCJhYm9ydFwiLGUuaWRdKX1jYXRjaCh0KXt9fX0se2tleTpcImNhbmNlbFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3UodGhpcy5mbGFzaCxcImV4ZWNcIixbXCJjYW5jZWxcIixlLmlkXSl9fSx7a2V5OlwicGluZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7dSh0aGlzLmZsYXNoLFwiZXhlY1wiLFtcInBhbmdcIl0pfX0se2tleTpcImRlc3Ryb3lcIix2YWx1ZTpmdW5jdGlvbigpe2RlbGV0ZSB3aW5kb3dbdGhpcy5jYWxsSW50ZXJmYWNlXX19XSksdH0oZik7ZS5leHBvcnRzPXZ9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX12YXIgaT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsci5rZXkscil9fXJldHVybiBmdW5jdGlvbih0LG4scil7cmV0dXJuIG4mJmUodC5wcm90b3R5cGUsbiksciYmZSh0LHIpLHR9fSgpLG89bigzKSxzPW8uRGVmZXJyZWQsdT1uKDYpLGE9dS5UaW1lb3V0RXJyb3IsYz11LkFib3J0RXJyb3IsbD11Lk5ldHdvcmtFcnJvcixmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0KXtyKHRoaXMsZSksdGhpcy5mbGFzaFJ1bnRpbWU9dH1yZXR1cm4gaShlLFt7a2V5OlwiZ2VuZXJhdGVcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1zKCksbj10aGlzLmZsYXNoUnVudGltZSxyPWUuZ2V0QmxvYigpLGk9dm9pZCAwLG89ZnVuY3Rpb24oKXtuLm9mZihcInVwbG9hZHByb2dyZXNzXCIsZiksbi5vZmYoXCJ1cGxvYWRjb21wbGV0ZVwiLGgpLG4ub2ZmKFwidXBsb2FkZXJyb3JcIixwKSxpJiZjbGVhclRpbWVvdXQoaSl9LHU9ZnVuY3Rpb24oKXtvKCksbi5hYm9ydChyLmlkKX0sZj1mdW5jdGlvbihlKXtlLmlkPT09ci5pZCYmdC5ub3RpZnkoZSl9LGg9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuaWQ9PT1yLmlkPyhvKCksMzA0PT09ZS5zdGF0dXN8fGUuc3RhdHVzPj0yMDAmJmUuc3RhdHVzPDMwMD8obi5jYW5jZWwociksdC5yZXNvbHZlKGUucmVzcG9uc2UpKTp0LnJlamVjdChuZXcgbChlLnN0YXR1cyxlLnJlc3BvbnNlKSkpOnZvaWQgMH0scD1mdW5jdGlvbihlKXtlLmlkPT09ci5pZCYmKG8oKSx0LnJlamVjdChuZXcgYyhlLm1lc3NhZ2UpKSl9O24ub24oXCJ1cGxvYWRwcm9ncmVzc1wiLGYpLG4ub24oXCJ1cGxvYWRjb21wbGV0ZVwiLGgpLG4ub24oXCJ1cGxvYWRlcnJvclwiLHApO3ZhciB2PWUuZ2V0VGltZW91dCgpO3Y+MCYmKGk9c2V0VGltZW91dChmdW5jdGlvbigpe3UoKSx0LnJlamVjdChuZXcgYShcInRpbWVvdXQ6XCIrdikpfSx2KSk7dHJ5e24uc2VuZChlLmdldE5hbWUoKSxyLGUuZ2V0VXJsKCksZS5nZXRQYXJhbXMoKS50b1N0cmluZygpKX1jYXRjaChkKXt1KCksdC5yZWplY3QobmV3IGMoZC5tZXNzYWdlKSl9dmFyIHk9dC5wcm9taXNlKCk7cmV0dXJuIHkuYWJvcnQ9dSx5fX1dKSxlfSgpO2UuZXhwb3J0cz1mfV0pfSk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS11cGxvYWRlci9+L3VwbG9hZGNvcmUvZGlzdC91cGxvYWRjb3JlLm1pbi5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn1cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanNcbiAqKiBtb2R1bGUgaWQgPSA3MDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhQcm9ncmVzcywgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBQcm9ncmVzcyhwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUHJvZ3Jlc3MpO1xuXG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpKTtcbiAgICB9XG5cbiAgICBQcm9ncmVzcy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICB2YXIgcGVyY2VudGFnZSA9IHRoaXMucHJvcHMucGVyY2VudGFnZSB8fCAwO1xuICAgICAgICBpZiAodXRpbC5UUkFOU0ZPUk1fUFJPUEVSVFkgJiYgdGhpcy5wcm9wcy5tb2RlICE9PSAnYmFyJykge1xuICAgICAgICAgICAgdmFyIGl0ZW1zID0gWzAsIDFdO1xuICAgICAgICAgICAgdmFyIHJldCA9IGl0ZW1zLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgubWluKE1hdGgubWF4KDAsIChwZXJjZW50YWdlIC0gaSAqIDUwKSAqIDMuNiksIDE4MCkpO1xuICAgICAgICAgICAgfSkubWFwKGZ1bmN0aW9uIChyb3RhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3JlZjtcblxuICAgICAgICAgICAgICAgIHJldHVybiBfcmVmID0ge30sIF9yZWZbdXRpbC5UUkFOU0ZPUk1fUFJPUEVSVFldID0gJ3JvdGF0ZSgnICsgcm90YXRlICsgJ2RlZyknLCBfcmVmO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAna3VtYS11cGxvYWQtcHJvZ3Jlc3NwaW4nIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnc3BpbiBzcGluMi0xJyB9LFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdkaXYnLCB7IGNsYXNzTmFtZTogJ2lubmVyJywgc3R5bGU6IHJldFswXSB9KVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnc3BpbiBzcGluMi0yJyB9LFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdkaXYnLCB7IGNsYXNzTmFtZTogJ2lubmVyJywgc3R5bGU6IHJldFsxXSB9KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgnZGl2JywgeyBjbGFzc05hbWU6ICdrdW1hLXVwbG9hZC1wcm9ncmVzc2JhcicsIHN0eWxlOiB7IHdpZHRoOiBwZXJjZW50YWdlICsgJyUnIH0gfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFByb2dyZXNzO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5Qcm9ncmVzcy5pc1N1cHBvcnQgPSB1dGlsLlRSQU5TRk9STV9QUk9QRVJUWSAhPT0gZmFsc2U7XG5cblByb2dyZXNzLnByb3BUeXBlcyA9IHtcbiAgICBwZXJjZW50YWdlOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyXG59O1xuUHJvZ3Jlc3MuZGVmYXVsdFByb3BzID0ge1xuICAgIHBlcmNlbnRhZ2U6IDBcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvZ3Jlc3M7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS11cGxvYWRlci9idWlsZC9Qcm9ncmVzcy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgaHVtYW5TaXplRm9ybWF0OiBmdW5jdGlvbiBodW1hblNpemVGb3JtYXQoc2l6ZSkge1xuICAgICAgICBzaXplID0gcGFyc2VGbG9hdChzaXplKTtcbiAgICAgICAgdmFyIHByZWZpeGVzU0kgPSBbJycsICdrJywgJ20nLCAnZycsICd0JywgJ3AnLCAnZScsICd6JywgJ3knXTtcbiAgICAgICAgdmFyIGJhc2UgPSAxMDAwLFxuICAgICAgICAgICAgaW5kZXggPSBzaXplID8gTWF0aC5mbG9vcihNYXRoLmxvZyhzaXplKSAvIE1hdGgubG9nKGJhc2UpKSA6IDA7XG4gICAgICAgIGluZGV4ID0gTWF0aC5taW4oaW5kZXgsIHByZWZpeGVzU0kubGVuZ3RoIC0gMSk7XG4gICAgICAgIHZhciBwb3dlZFByZWNpc2lvbiA9IE1hdGgucG93KDEwLCBpbmRleCA8IDIgPyAwIDogaW5kZXggPiAyID8gMiA6IDEpO1xuICAgICAgICBzaXplID0gc2l6ZSAvIE1hdGgucG93KGJhc2UsIGluZGV4KTtcbiAgICAgICAgc2l6ZSA9IE1hdGgucm91bmQoc2l6ZSAqIHBvd2VkUHJlY2lzaW9uKSAvIHBvd2VkUHJlY2lzaW9uO1xuICAgICAgICBpZiAoc2l6ZSA+IDUwMCkge1xuICAgICAgICAgICAgc2l6ZSA9IE1hdGgucm91bmQoc2l6ZSAvIDEwMCkgLyAxMDtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpemUgKyBwcmVmaXhlc1NJW2luZGV4XTtcbiAgICB9LFxuICAgIG5hdGN1dDogZnVuY3Rpb24gbmF0Y3V0KHRpdGxlLCBsZW4pIHtcbiAgICAgICAgdmFyIG1heCA9IGxlbiAqIDIsXG4gICAgICAgICAgICBsZW5ndGggPSB0aXRsZS5sZW5ndGgsXG4gICAgICAgICAgICBsID0gMCxcbiAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgcGFydCA9IHZvaWQgMCxcbiAgICAgICAgICAgIHMgPSB2b2lkIDA7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGggJiYgbCA8PSBtYXg7IGkrKykge1xuICAgICAgICAgICAgbCArPSB0aXRsZS5jaGFyQ29kZUF0KGkpID4gMjU1ID8gMiA6IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGwgPD0gbWF4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGl0bGU7XG4gICAgICAgIH1cbiAgICAgICAgaSA9IDA7XG4gICAgICAgIGwgPSAwO1xuICAgICAgICBsZW4gLT0gMjtcbiAgICAgICAgd2hpbGUgKGwgPCBsZW4pIHtcbiAgICAgICAgICAgIHMgPSB0aXRsZS5jaGFyQ29kZUF0KGkpID4gMjU1ID8gMiA6IDE7XG4gICAgICAgICAgICBpZiAobCArIHMgPiBsZW4pIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGwgKz0gcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYXJ0ID0gdGl0bGUuc3Vic3RyKDAsIGkpO1xuICAgICAgICBsICs9IDM7XG5cbiAgICAgICAgaSA9IGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGwgPCBtYXgpIHtcbiAgICAgICAgICAgIHMgPSB0aXRsZS5jaGFyQ29kZUF0KGkgLSAxKSA+IDI1NSA/IDIgOiAxO1xuICAgICAgICAgICAgaWYgKGwgKyBzID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICBsICs9IHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnQgKyAnLi4uJyArIHRpdGxlLnN1YnN0cmluZyhNYXRoLm1pbihpLCBsZW5ndGggLSAxKSwgbGVuZ3RoKTtcbiAgICB9LFxuICAgIFRSQU5TRk9STV9QUk9QRVJUWTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlO1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IFtcInRyYW5zZm9ybVwiLCBcIldlYmtpdFRyYW5zZm9ybVwiLCBcIk1velRyYW5zZm9ybVwiLCBcIm1zVHJhbnNmb3JtXCJdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllc1tpXSBpbiBzdHlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KClcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS11cGxvYWRlci9idWlsZC91dGlsLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBGaWxlSXRlbSA9IHJlcXVpcmUoJy4vRmlsZUl0ZW0nKTtcbnZhciBQaWNrZXIgPSByZXF1aXJlKCcuL1BpY2tlcicpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCd1cGxvYWRjb3JlJyk7XG5cbnZhciBFdmVudHMgPSBfcmVxdWlyZS5FdmVudHM7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIEZpbGVMaXN0ID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoRmlsZUxpc3QsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gRmlsZUxpc3QocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZpbGVMaXN0KTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgICAgICBfdGhpcy5jb3JlID0gX3RoaXMucHJvcHMuY29yZTtcblxuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGl0ZW1zOiBfdGhpcy5jb3JlLmdldFN0YXQoKS5nZXRGaWxlcygpXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBGaWxlTGlzdC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHN0YXRjaGFuZ2UgPSBmdW5jdGlvbiBzdGF0Y2hhbmdlKHN0YXQpIHtcbiAgICAgICAgICAgIF90aGlzMi5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgaXRlbXM6IHN0YXQuZ2V0RmlsZXMoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29yZS5vbihFdmVudHMuUVVFVUVfU1RBVF9DSEFOR0UsIHN0YXRjaGFuZ2UpO1xuICAgICAgICB0aGlzLnN0b3BMaXN0ZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczIuY29yZS5vZmYoRXZlbnRzLlFVRVVFX1NUQVRfQ0hBTkdFLCBzdGF0Y2hhbmdlKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgRmlsZUxpc3QucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHRoaXMuc3RvcExpc3RlbiAmJiB0aGlzLnN0b3BMaXN0ZW4oKTtcbiAgICB9O1xuXG4gICAgRmlsZUxpc3QucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBcImt1bWEtdXBsb2FkLWZpbGVsaXN0IFwiICsgKHRoaXMucHJvcHMubW9kZSA9PT0gJ253JyA/ICdud21vZGUnIDogdGhpcy5wcm9wcy5tb2RlID09PSAnbWluaScgPyAnbWluaW1vZGUnIDogJ2ljb25tb2RlJykgfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdpbm5lcicgfSxcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLml0ZW1zLm1hcChmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChGaWxlSXRlbSwgeyBsb2NhbGU6IF90aGlzMy5wcm9wcy5sb2NhbGUsIGtleTogZmlsZS5pZCwgZmlsZTogZmlsZSwgbW9kZTogX3RoaXMzLnByb3BzLm1vZGUgfSk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgIXRoaXMuY29yZS5pc0Z1bGwoKSAmJiB0aGlzLnByb3BzLm1vZGUgPT09ICdpY29uJyA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgIFBpY2tlcixcbiAgICAgICAgICAgICAgICAgICAgeyBjb3JlOiB0aGlzLmNvcmUgfSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnaScsIHsgY2xhc3NOYW1lOiAna3VtYS1pY29uIGt1bWEtaWNvbi1hZGQnIH0pXG4gICAgICAgICAgICAgICAgKSA6IG51bGxcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEZpbGVMaXN0O1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5GaWxlTGlzdC5kZWZhdWx0UHJvcHMgPSB7XG4gICAgbW9kZTogJ21pbmknXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZpbGVMaXN0O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtdXBsb2FkZXIvYnVpbGQvRmlsZUxpc3QuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFByZXZpZXcgPSByZXF1aXJlKCcuL1ByZXZpZXcnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJ3VwbG9hZGNvcmUnKTtcblxudmFyIEV2ZW50cyA9IF9yZXF1aXJlLkV2ZW50cztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xudmFyIGkxOG4gPSByZXF1aXJlKCcuL2xvY2FsZScpO1xuXG52YXIgRmlsZUl0ZW0gPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhGaWxlSXRlbSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBGaWxlSXRlbShwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmlsZUl0ZW0pO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgICAgIHZhciBmaWxlID0gX3RoaXMucHJvcHMuZmlsZTtcbiAgICAgICAgX3RoaXMuZmlsZSA9IGZpbGU7XG5cbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBwZXJjZW50YWdlOiBmaWxlLnByb2dyZXNzID8gZmlsZS5wcm9ncmVzcy5wZXJjZW50YWdlIDogMCxcbiAgICAgICAgICAgIHN0YXR1czogZmlsZS5nZXRTdGF0dXNOYW1lKClcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIEZpbGVJdGVtLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICB2YXIgZmlsZSA9IHRoaXMuZmlsZTtcbiAgICAgICAgdmFyIHN0YXR1c2NoYW5nZSA9IGZ1bmN0aW9uIHN0YXR1c2NoYW5nZSgpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IGZpbGUuZ2V0U3RhdHVzTmFtZSgpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHN0YXRlLnN0YXR1cyA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgICAgIHN0YXRlLnBlcmNlbnRhZ2UgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMyLnNldFN0YXRlKHN0YXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHByb2dyZXNzID0gZnVuY3Rpb24gcHJvZ3Jlc3MoX3Byb2dyZXNzKSB7XG4gICAgICAgICAgICBfdGhpczIuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIHBlcmNlbnRhZ2U6IF9wcm9ncmVzcy5wZXJjZW50YWdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgZmlsZS5vbihFdmVudHMuRklMRV9TVEFUVVNfQ0hBTkdFLCBzdGF0dXNjaGFuZ2UpO1xuICAgICAgICBmaWxlLm9uKEV2ZW50cy5GSUxFX1VQTE9BRF9QUk9HUkVTUywgcHJvZ3Jlc3MpO1xuXG4gICAgICAgIHRoaXMuc3RvcExpc3RlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZpbGUub2ZmKEV2ZW50cy5GSUxFX1NUQVRVU19DSEFOR0UsIHN0YXR1c2NoYW5nZSk7XG4gICAgICAgICAgICBmaWxlLm9mZihFdmVudHMuRklMRV9VUExPQURfUFJPR1JFU1MsIHByb2dyZXNzKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgRmlsZUl0ZW0ucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHRoaXMuc3RvcExpc3RlbiAmJiB0aGlzLnN0b3BMaXN0ZW4oKTtcbiAgICB9O1xuXG4gICAgRmlsZUl0ZW0ucHJvdG90eXBlLm9uUGVuZGluZyA9IGZ1bmN0aW9uIG9uUGVuZGluZygpIHtcbiAgICAgICAgdGhpcy5maWxlLnBlbmRpbmcoKTtcbiAgICB9O1xuXG4gICAgRmlsZUl0ZW0ucHJvdG90eXBlLm9uQ2FuY2VsID0gZnVuY3Rpb24gb25DYW5jZWwoKSB7XG4gICAgICAgIHRoaXMuZmlsZS5jYW5jZWwoKTtcbiAgICB9O1xuXG4gICAgRmlsZUl0ZW0ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIGxvY2FsZSA9IG1lLnByb3BzLmxvY2FsZTtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5tb2RlID09PSAnaWNvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBcImt1bWEtdXBsb2FkLWZpbGVpdGVtIHN0YXR1cy1cIiArIHRoaXMuc3RhdGUuc3RhdHVzIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2t1bWEtdXBsb2FkLWFjdGlvbiBhY3Rpb24tcmVtb3ZlJywgb25DbGljazogdGhpcy5vbkNhbmNlbC5iaW5kKHRoaXMpLCB0aXRsZTogaTE4bltsb2NhbGVdWydyZW1vdmUnXSB9LFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdpJywgeyBjbGFzc05hbWU6ICdrdW1hLWljb24ga3VtYS1pY29uLWNsb3NlJyB9KVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnZmlsZXByZXZpZXcnIH0sXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUHJldmlldywgeyBmaWxlOiB0aGlzLnByb3BzLmZpbGUgfSksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc3RhdHVzID09PSAnZXJyb3InID8gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAna3VtYS11cGxvYWQtYWN0aW9uIGFjdGlvbi1yZXRyeScsIG9uQ2xpY2s6IHRoaXMub25QZW5kaW5nLmJpbmQodGhpcyksIHRpdGxlOiBpMThuW2xvY2FsZV1bJ3JldHJ5J10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2knLCB7IGNsYXNzTmFtZTogJ2t1bWEtaWNvbiBrdW1hLWljb24tcmVmcmVzaCcgfSlcbiAgICAgICAgICAgICAgICAgICAgKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc3RhdHVzID09PSAncXVldWVkJyA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAnYScsXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2t1bWEtdXBsb2FkLWFjdGlvbiBhY3Rpb24tdXBsb2FkJywgb25DbGljazogdGhpcy5vblBlbmRpbmcuYmluZCh0aGlzKSwgdGl0bGU6IGkxOG5bbG9jYWxlXVsndXBsb2FkJ10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2knLCB7IGNsYXNzTmFtZTogJ2t1bWEtaWNvbiBrdW1hLWljb24tdHJpYW5nbGUtcmlnaHQnIH0pXG4gICAgICAgICAgICAgICAgICAgICkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnN0YXR1cyA9PT0gJ3Byb2dyZXNzJyB8fCB0aGlzLnN0YXRlLnN0YXR1cyA9PT0gJ3BlbmRpbmcnID8gUmVhY3QuY3JlYXRlRWxlbWVudChQcm9ncmVzcywgeyBwZXJjZW50YWdlOiB0aGlzLnN0YXRlLnBlcmNlbnRhZ2UgfSkgOiBudWxsXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnN0YXR1cyA9PT0gJ2Vycm9yJyA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdrdW1hLXVwbG9hZC1zdGF0dXMgc3RhdHVzLWVycm9yJywgdGl0bGU6IGkxOG5bbG9jYWxlXVsndXBsb2FkX2ZhaWxlZCddIH0sXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2knLCB7IGNsYXNzTmFtZTogJ2t1bWEtaWNvbiBrdW1hLWljb24tY2F1dGlvbicgfSlcbiAgICAgICAgICAgICAgICApIDogbnVsbCxcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnN0YXR1cyA9PT0gJ3N1Y2Nlc3MnID8gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2t1bWEtdXBsb2FkLXN0YXR1cyBzdGF0dXMtc3VjY2VzcycgfSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnaScsIHsgY2xhc3NOYW1lOiAna3VtYS1pY29uIGt1bWEtaWNvbi1jaG9vc2UnIH0pXG4gICAgICAgICAgICAgICAgKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnZmlsZW5hbWUnLCB0aXRsZTogdGhpcy5maWxlLm5hbWUgfSxcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5uYXRjdXQodGhpcy5maWxlLm5hbWUsIDEwKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcm9wcy5tb2RlID09PSAnbncnKSB7XG4gICAgICAgICAgICB2YXIgZG93bmxvYWRVcmwgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgcHJldmlld1VybCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLnN0YXR1cyA9PT0gJ3N1Y2Nlc3MnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGpzb24gPSB0aGlzLmZpbGUucmVzcG9uc2UuZ2V0SnNvbigpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRvd25sb2FkVXJsID0ganNvbi5kYXRhLmRvd25sb2FkVXJsIHx8IGpzb24uZGF0YS5maWxlIHx8IGpzb24uZGF0YS51cmw7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpZXdVcmwgPSBqc29uLmRhdGEucHJldmlld1VybCB8fCBkb3dubG9hZFVybDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6IFwia3VtYS11cGxvYWQtZmlsZWl0ZW0gc3RhdHVzLVwiICsgdGhpcy5zdGF0ZS5zdGF0dXMgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAnbGFiZWwnLFxuICAgICAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2ZpZWxkLWluZm8nIH0sXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc3RhdHVzID09PSAnZXJyb3InID8gUmVhY3QuY3JlYXRlRWxlbWVudCgnaScsIHsgY2xhc3NOYW1lOiAna3VtYS1pY29uIGt1bWEtaWNvbi1jYXV0aW9uJyB9KSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc3RhdHVzICE9PSAnZXJyb3InICYmIHRoaXMuc3RhdGUuc3RhdHVzICE9PSAnc3VjY2VzcycgPyBSZWFjdC5jcmVhdGVFbGVtZW50KCdpJywgeyBjbGFzc05hbWU6ICdrdW1hLWxvYWRpbmcnIH0pIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zdGF0dXMgPT09ICdzdWNjZXNzJyA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2knLCB7IGNsYXNzTmFtZTogJ2t1bWEtdXBsb2FkLWZpbGVpY29uJywgJ2RhdGEtZXh0JzogdGhpcy5maWxlLmV4dCwgJ2RhdGEtdHlwZSc6IHRoaXMuZmlsZS50eXBlIH0pIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnZmlsZW5hbWUnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbGUubmFtZVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAnbGFiZWwnLFxuICAgICAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2ZpZWxkLXN0YXR1cycgfSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zdGF0dXMgPT09ICdlcnJvcicgPyBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdrdW1hLXVwbG9hZC1zdGF0dXMgc3RhdHVzLWVycm9yJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaTE4bltsb2NhbGVdWyd1cGxvYWRfZmFpbGVkJ11cbiAgICAgICAgICAgICAgICAgICAgKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc3RhdHVzICE9PSAnZXJyb3InICYmIHRoaXMuc3RhdGUuc3RhdHVzICE9PSAnc3VjY2VzcycgPyBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdrdW1hLXVwbG9hZC1zdGF0dXMgc3RhdHVzLXByb2dyZXNzJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaTE4bltsb2NhbGVdWyd1cGxvYWRpbmcnXSArICcuLi4nXG4gICAgICAgICAgICAgICAgICAgICkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnN0YXR1cyA9PT0gJ3N1Y2Nlc3MnICYmIHByZXZpZXdVcmwgPyBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdrdW1hLXVwbG9hZC1hY3Rpb24nLCB0YXJnZXQ6ICdfYmxhbmsnLCBocmVmOiBwcmV2aWV3VXJsIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpMThuW2xvY2FsZV1bJ3ByZXZpZXcnXVxuICAgICAgICAgICAgICAgICAgICApIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zdGF0dXMgPT09ICdzdWNjZXNzJyAmJiBkb3dubG9hZFVybCA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAnYScsXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2t1bWEtdXBsb2FkLWFjdGlvbicsIHRhcmdldDogJ19ibGFuaycsIGhyZWY6IGRvd25sb2FkVXJsIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpMThuW2xvY2FsZV1bJ2Rvd25sb2FkJ11cbiAgICAgICAgICAgICAgICAgICAgKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAnYScsXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2t1bWEtdXBsb2FkLWFjdGlvbicsIG9uQ2xpY2s6IHRoaXMub25DYW5jZWwuYmluZCh0aGlzKSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaTE4bltsb2NhbGVdWydyZW1vdmUnXVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzaXplID0gdXRpbC5odW1hblNpemVGb3JtYXQodGhpcy5maWxlLnNpemUpO1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6IFwia3VtYS11cGxvYWQtZmlsZWl0ZW0gc3RhdHVzLVwiICsgdGhpcy5zdGF0ZS5zdGF0dXMgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAnbGFiZWwnLFxuICAgICAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2ZpZWxkLWluZm8nIH0sXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2knLCB7IGNsYXNzTmFtZTogJ2t1bWEtdXBsb2FkLWZpbGVpY29uJywgJ2RhdGEtZXh0JzogdGhpcy5maWxlLmV4dCwgJ2RhdGEtdHlwZSc6IHRoaXMuZmlsZS50eXBlIH0pLFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdmaWxlbmFtZScsIHRpdGxlOiB0aGlzLmZpbGUubmFtZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5uYXRjdXQodGhpcy5maWxlLm5hbWUsIDEyKVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdmaWxlc2l6ZScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICcvJyArIHNpemVcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgJ2xhYmVsJyxcbiAgICAgICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdmaWVsZC1zdGF0dXMnIH0sXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc3RhdHVzID09PSAnZXJyb3InID8gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAna3VtYS11cGxvYWQtc3RhdHVzIHN0YXR1cy1lcnJvcicsIHRpdGxlOiBpMThuW2xvY2FsZV1bJ3VwbG9hZF9mYWlsZWQnXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnaScsIHsgY2xhc3NOYW1lOiAna3VtYS1pY29uIGt1bWEtaWNvbi1jYXV0aW9uJyB9KVxuICAgICAgICAgICAgICAgICAgICApIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zdGF0dXMgPT09ICdzdWNjZXNzJyA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAnYScsXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2t1bWEtdXBsb2FkLXN0YXR1cyBzdGF0dXMtc3VjY2VzcycgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2knLCB7IGNsYXNzTmFtZTogJ2t1bWEtaWNvbiBrdW1hLWljb24tY2hvb3NlJyB9KVxuICAgICAgICAgICAgICAgICAgICApIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zdGF0dXMgPT09ICdlcnJvcicgPyBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdrdW1hLXVwbG9hZC1hY3Rpb24gYWN0aW9uLXJldHJ5Jywgb25DbGljazogdGhpcy5vblBlbmRpbmcuYmluZCh0aGlzKSwgdGl0bGU6IGkxOG5bbG9jYWxlXVsncmV0cnknXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnaScsIHsgY2xhc3NOYW1lOiAna3VtYS1pY29uIGt1bWEtaWNvbi1yZWZyZXNoJyB9KVxuICAgICAgICAgICAgICAgICAgICApIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zdGF0dXMgPT09ICdxdWV1ZWQnID8gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAna3VtYS11cGxvYWQtYWN0aW9uIGFjdGlvbi11cGxvYWQnLCBvbkNsaWNrOiB0aGlzLm9uUGVuZGluZy5iaW5kKHRoaXMpLCB0aXRsZTogaTE4bltsb2NhbGVdWyd1cGxvYWQnXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnaScsIHsgY2xhc3NOYW1lOiAna3VtYS1pY29uIGt1bWEtaWNvbi10cmlhbmdsZS1yaWdodCcgfSlcbiAgICAgICAgICAgICAgICAgICAgKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAnYScsXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2t1bWEtdXBsb2FkLWFjdGlvbiBhY3Rpb24tcmVtb3ZlJywgb25DbGljazogdGhpcy5vbkNhbmNlbC5iaW5kKHRoaXMpLCB0aXRsZTogaTE4bltsb2NhbGVdWydyZW1vdmUnXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnaScsIHsgY2xhc3NOYW1lOiAna3VtYS1pY29uIGt1bWEtaWNvbi1jbG9zZScgfSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChQcm9ncmVzcywgeyBwZXJjZW50YWdlOiB0aGlzLnN0YXRlLnBlcmNlbnRhZ2UsIG1vZGU6ICdiYXInIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBGaWxlSXRlbTtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuRmlsZUl0ZW0uZGVmYXVsdFByb3BzID0ge1xuICAgIG1vZGU6ICdtaW5pJ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGaWxlSXRlbTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLXVwbG9hZGVyL2J1aWxkL0ZpbGVJdGVtLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIFByZXZpZXcgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhQcmV2aWV3LCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIFByZXZpZXcocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFByZXZpZXcpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgICAgIF90aGlzLnN0YXRlID0ge307XG5cbiAgICAgICAgdmFyIGZpbGUgPSBfdGhpcy5wcm9wcy5maWxlO1xuICAgICAgICBpZiAoZmlsZS5pc0ltYWdlKCkpIHtcbiAgICAgICAgICAgIGZpbGUuZ2V0QXNEYXRhVXJsKDEwMDApLmRvbmUoZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXRTdGF0ZSh7IHVybDogdXJsIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIFByZXZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAncHJldmlld2VyJyB9LFxuICAgICAgICAgICAgdGhpcy5zdGF0ZS51cmwgPyBSZWFjdC5jcmVhdGVFbGVtZW50KCdpbWcnLCB7IHNyYzogdGhpcy5zdGF0ZS51cmwgfSkgOiBSZWFjdC5jcmVhdGVFbGVtZW50KCdpJywgeyBjbGFzc05hbWU6ICdrdW1hLXVwbG9hZC1maWxlaWNvbicsICdkYXRhLWV4dCc6IHRoaXMucHJvcHMuZmlsZS5leHQsICdkYXRhLXR5cGUnOiB0aGlzLnByb3BzLmZpbGUudHlwZSB9KVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gUHJldmlldztcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcmV2aWV3O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtdXBsb2FkZXIvYnVpbGQvUHJldmlldy5qc1xuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgbG9jYWxlID0ge1xuICAgIFwiZW4tdXNcIjoge1xuICAgICAgICBcImRvd25sb2FkXCI6IFwiZG93bmxvYWRcIixcbiAgICAgICAgXCJwcmV2aWV3XCI6IFwicHJldmlld1wiLFxuICAgICAgICBcInJlbW92ZVwiOiBcInJlbW92ZVwiLFxuICAgICAgICBcInJldHJ5XCI6IFwicmV0cnlcIixcbiAgICAgICAgXCJ1cGxvYWRcIjogXCJ1cGxvYWRcIixcbiAgICAgICAgXCJ1cGxvYWRpbmdcIjogXCJ1cGxvYWRpbmdcIixcbiAgICAgICAgXCJ1cGxvYWRfZmFpbGVkXCI6IFwidXBsb2FkIGZhaWxlZFwiLFxuICAgICAgICBcInVwbG9hZF9maWxlc1wiOiBcInVwbG9hZCBmaWxlc1wiXG4gICAgfSxcbiAgICBcInpoLWNuXCI6IHtcbiAgICAgICAgXCJkb3dubG9hZFwiOiBcIuS4i+i9vVwiLFxuICAgICAgICBcInByZXZpZXdcIjogXCLpooTop4hcIixcbiAgICAgICAgXCJyZW1vdmVcIjogXCLnp7vpmaRcIixcbiAgICAgICAgXCJyZXRyeVwiOiBcIumHjeS8oFwiLFxuICAgICAgICBcInVwbG9hZFwiOiBcIuS4iuS8oFwiLFxuICAgICAgICBcInVwbG9hZGluZ1wiOiBcIuS4iuS8oOS4rVwiLFxuICAgICAgICBcInVwbG9hZF9mYWlsZWRcIjogXCLkuIrkvKDlpLHotKVcIixcbiAgICAgICAgXCJ1cGxvYWRfZmlsZXNcIjogXCLmt7vliqDmlofku7ZcIlxuICAgIH1cbn07XG5cbmxvY2FsZVsnZW4nXSA9IGxvY2FsZVsnZW4tdXMnXTtcblxubW9kdWxlLmV4cG9ydHMgPSBsb2NhbGU7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS11cGxvYWRlci9idWlsZC9sb2NhbGUuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgUGlja2VyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoUGlja2VyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIFBpY2tlcigpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBpY2tlcik7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfVxuXG4gICAgUGlja2VyLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLmFyZWEgPSB0aGlzLnByb3BzLmNvcmUuZ2V0UGlja2VyQ29sbGVjdG9yKCkuYWRkQXJlYShSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKSk7XG4gICAgfTtcblxuICAgIFBpY2tlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy5hcmVhICYmIHRoaXMuYXJlYS5kZXN0cm95KCk7XG4gICAgfTtcblxuICAgIFBpY2tlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdrdW1hLXVwbG9hZC1waWNrZXInIH0sXG4gICAgICAgICAgICB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHJldHVybiBQaWNrZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gUGlja2VyO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtdXBsb2FkZXIvYnVpbGQvUGlja2VyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1lc3NhZ2UgQ29tcG9uZW50IGZvciB1eGNvcmVcbiAqIEBhdXRob3IgZXRlcm5hc2xreVxuICpcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIFV4Y29yZSBUZWFtLCBBbGludy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL01lc3NhZ2UnKTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLW1lc3NhZ2UvYnVpbGQvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBOb3RpZmljYXRpb24gPSByZXF1aXJlKCdyYy1ub3RpZmljYXRpb24nKTtcbnZhciBjbGFzc25hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xudmFyIGRlZmF1bHREdXJhdGlvbiA9IDEuNTtcbnZhciBtZXNzYWdlSW5zdGFuY2UgPSB2b2lkIDA7XG52YXIga2V5ID0gMTtcbnZhciBwcmVmaXhDbHMgPSAna3VtYS1tZXNzYWdlJztcbnZhciB0cmFuc2l0aW9uTmFtZSA9ICdtb3ZlVXAnO1xudmFyIGNsYXNzTmFtZSA9IHZvaWQgMDtcblxuZnVuY3Rpb24gZ2V0TWVzc2FnZUluc3RhbmNlKCkge1xuICAgIG1lc3NhZ2VJbnN0YW5jZSA9IG1lc3NhZ2VJbnN0YW5jZSB8fCBOb3RpZmljYXRpb24ubmV3SW5zdGFuY2Uoe1xuICAgICAgICBwcmVmaXhDbHM6IHByZWZpeENscyxcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICAgIHRyYW5zaXRpb25OYW1lOiB0cmFuc2l0aW9uTmFtZSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGxlZnQ6ICc1MCUnXG4gICAgICAgIH0gLy8g6KaG55uW5Y6f5p2l55qE5qC35byPXG4gICAgfSk7XG4gICAgcmV0dXJuIG1lc3NhZ2VJbnN0YW5jZTtcbn1cblxuZnVuY3Rpb24gbm90aWNlKGNvbnRlbnQpIHtcbiAgICB2YXIgZHVyYXRpb24gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBkZWZhdWx0RHVyYXRpb24gOiBhcmd1bWVudHNbMV07XG5cbiAgICB2YXIgX2NsYXNzbmFtZXM7XG5cbiAgICB2YXIgdHlwZSA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgb25DbG9zZSA9IGFyZ3VtZW50c1szXTtcblxuICAgIHZhciBpY29uQ2xhc3MgPSB7XG4gICAgICAgICdpbmZvJzogJ2t1bWEtaWNvbiBrdW1hLWljb24taW5mb3JtYXRpb24nLFxuICAgICAgICAnc3VjY2Vzcyc6ICdrdW1hLWljb24ga3VtYS1pY29uLXN1Y2Nlc3MnLFxuICAgICAgICAnZXJyb3InOiAna3VtYS1pY29uIGt1bWEtaWNvbi1lcnJvcicsXG4gICAgICAgICdsb2FkaW5nJzogJ2t1bWEtbG9hZGluZydcbiAgICB9W3R5cGVdO1xuXG4gICAgdmFyIGluc3RhbmNlID0gZ2V0TWVzc2FnZUluc3RhbmNlKCk7XG4gICAgaW5zdGFuY2Uubm90aWNlKHtcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHJpZ2h0OiAnNTAlJ1xuICAgICAgICB9LFxuICAgICAgICBjb250ZW50OiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogY2xhc3NuYW1lcygoX2NsYXNzbmFtZXMgPSB7fSwgX2NsYXNzbmFtZXNbcHJlZml4Q2xzICsgJy1jb250YWluZXIgJyArIHByZWZpeENscyArICctY29udGFpbmVyLScgKyB0eXBlXSA9IHRydWUsIF9jbGFzc25hbWVzWydmbi1jbGVhciddID0gdHJ1ZSwgX2NsYXNzbmFtZXMpKSB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnaScsIHsgY2xhc3NOYW1lOiBpY29uQ2xhc3MgfSksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWNvbnRlbnQnIH0sXG4gICAgICAgICAgICAgICAgY29udGVudFxuICAgICAgICAgICAgKVxuICAgICAgICApLFxuICAgICAgICBvbkNsb3NlOiBvbkNsb3NlXG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IGtleSsrO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaW5zdGFuY2UucmVtb3ZlTm90aWNlKHRhcmdldCk7XG4gICAgICAgIH07XG4gICAgfSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBpbmZvOiBmdW5jdGlvbiBpbmZvKGNvbnRlbnQsIGR1cmF0aW9uLCBvbkNsb3NlKSB7XG4gICAgICAgIHJldHVybiBub3RpY2UoY29udGVudCwgZHVyYXRpb24sICdpbmZvJywgb25DbG9zZSk7XG4gICAgfSxcbiAgICBzdWNjZXNzOiBmdW5jdGlvbiBzdWNjZXNzKGNvbnRlbnQsIGR1cmF0aW9uLCBvbkNsb3NlKSB7XG4gICAgICAgIHJldHVybiBub3RpY2UoY29udGVudCwgZHVyYXRpb24sICdzdWNjZXNzJywgb25DbG9zZSk7XG4gICAgfSxcbiAgICBlcnJvcjogZnVuY3Rpb24gZXJyb3IoY29udGVudCwgZHVyYXRpb24sIG9uQ2xvc2UpIHtcbiAgICAgICAgcmV0dXJuIG5vdGljZShjb250ZW50LCBkdXJhdGlvbiwgJ2Vycm9yJywgb25DbG9zZSk7XG4gICAgfSxcbiAgICBsb2FkaW5nOiBmdW5jdGlvbiBsb2FkaW5nKGNvbnRlbnQsIGR1cmF0aW9uLCBvbkNsb3NlKSB7XG4gICAgICAgIHJldHVybiBub3RpY2UoY29udGVudCwgZHVyYXRpb24sICdsb2FkaW5nJywgb25DbG9zZSk7XG4gICAgfSxcbiAgICBjb25maWc6IGZ1bmN0aW9uIGNvbmZpZyhvcHRpb25zKSB7XG4gICAgICAgIHByZWZpeENscyA9IG9wdGlvbnMucHJlZml4Q2xzIHx8IHByZWZpeENscztcbiAgICAgICAgdHJhbnNpdGlvbk5hbWUgPSBvcHRpb25zLnRyYW5zaXRpb25OYW1lIHx8IHRyYW5zaXRpb25OYW1lO1xuICAgICAgICBjbGFzc05hbWUgPSBvcHRpb25zLmNsYXNzTmFtZSB8fCBjbGFzc05hbWU7XG4gICAgfVxufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLW1lc3NhZ2UvYnVpbGQvTWVzc2FnZS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9Ob3RpZmljYXRpb24gPSByZXF1aXJlKCcuL05vdGlmaWNhdGlvbicpO1xuXG52YXIgX05vdGlmaWNhdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Ob3RpZmljYXRpb24pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBfTm90aWZpY2F0aW9uMlsnZGVmYXVsdCddO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1tZXNzYWdlL34vcmMtbm90aWZpY2F0aW9uL2xpYi9pbmRleC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JlYWN0RG9tID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBfcmVhY3REb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3REb20pO1xuXG52YXIgX3JjQW5pbWF0ZSA9IHJlcXVpcmUoJ3JjLWFuaW1hdGUnKTtcblxudmFyIF9yY0FuaW1hdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmNBbmltYXRlKTtcblxudmFyIF9yY1V0aWwgPSByZXF1aXJlKCdyYy11dGlsJyk7XG5cbnZhciBfTm90aWNlID0gcmVxdWlyZSgnLi9Ob3RpY2UnKTtcblxudmFyIF9Ob3RpY2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTm90aWNlKTtcblxudmFyIHNlZWQgPSAwO1xudmFyIG5vdyA9IERhdGUubm93KCk7XG5cbmZ1bmN0aW9uIGdldFV1aWQoKSB7XG4gIHJldHVybiAncmNOb3RpZmljYXRpb25fJyArIG5vdyArICdfJyArIHNlZWQrKztcbn1cblxudmFyIE5vdGlmaWNhdGlvbiA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnTm90aWZpY2F0aW9uJyxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHJlZml4Q2xzOiAncmMtbm90aWZpY2F0aW9uJyxcbiAgICAgIGFuaW1hdGlvbjogJ2ZhZGUnLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgJ3RvcCc6IDY1LFxuICAgICAgICBsZWZ0OiAnNTAlJ1xuICAgICAgfVxuICAgIH07XG4gIH0sXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vdGljZXM6IFtdXG4gICAgfTtcbiAgfSxcblxuICBnZXRUcmFuc2l0aW9uTmFtZTogZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbk5hbWUoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgdHJhbnNpdGlvbk5hbWUgPSBwcm9wcy50cmFuc2l0aW9uTmFtZTtcbiAgICBpZiAoIXRyYW5zaXRpb25OYW1lICYmIHByb3BzLmFuaW1hdGlvbikge1xuICAgICAgdHJhbnNpdGlvbk5hbWUgPSBwcm9wcy5wcmVmaXhDbHMgKyAnLScgKyBwcm9wcy5hbmltYXRpb247XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2l0aW9uTmFtZTtcbiAgfSxcblxuICBhZGQ6IGZ1bmN0aW9uIGFkZChub3RpY2UpIHtcbiAgICB2YXIga2V5ID0gbm90aWNlLmtleSA9IG5vdGljZS5rZXkgfHwgZ2V0VXVpZCgpO1xuICAgIHZhciBub3RpY2VzID0gdGhpcy5zdGF0ZS5ub3RpY2VzO1xuICAgIGlmICghbm90aWNlcy5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiB2LmtleSA9PT0ga2V5O1xuICAgIH0pLmxlbmd0aCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIG5vdGljZXM6IG5vdGljZXMuY29uY2F0KG5vdGljZSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShrZXkpIHtcbiAgICB2YXIgbm90aWNlcyA9IHRoaXMuc3RhdGUubm90aWNlcy5maWx0ZXIoZnVuY3Rpb24gKG5vdGljZSkge1xuICAgICAgcmV0dXJuIG5vdGljZS5rZXkgIT09IGtleTtcbiAgICB9KTtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIG5vdGljZXM6IG5vdGljZXNcbiAgICB9KTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX2NsYXNzTmFtZSxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgbm90aWNlTm9kZXMgPSB0aGlzLnN0YXRlLm5vdGljZXMubWFwKGZ1bmN0aW9uIChub3RpY2UpIHtcbiAgICAgIHZhciBvbkNsb3NlID0gKDAsIF9yY1V0aWwuY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKShfdGhpcy5yZW1vdmUuYmluZChfdGhpcywgbm90aWNlLmtleSksIG5vdGljZS5vbkNsb3NlKTtcbiAgICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgX05vdGljZTJbJ2RlZmF1bHQnXSxcbiAgICAgICAgX2V4dGVuZHMoeyBwcmVmaXhDbHM6IHByb3BzLnByZWZpeENscyB9LCBub3RpY2UsIHsgb25DbG9zZTogb25DbG9zZSB9KSxcbiAgICAgICAgbm90aWNlLmNvbnRlbnRcbiAgICAgICk7XG4gICAgfSk7XG4gICAgdmFyIGNsYXNzTmFtZSA9IChfY2xhc3NOYW1lID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NOYW1lLCBwcm9wcy5wcmVmaXhDbHMsIDEpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzTmFtZSwgcHJvcHMuY2xhc3NOYW1lLCAhIXByb3BzLmNsYXNzTmFtZSksIF9jbGFzc05hbWUpO1xuICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICdkaXYnLFxuICAgICAgeyBjbGFzc05hbWU6ICgwLCBfcmNVdGlsLmNsYXNzU2V0KShjbGFzc05hbWUpLCBzdHlsZTogcHJvcHMuc3R5bGUgfSxcbiAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICBfcmNBbmltYXRlMlsnZGVmYXVsdCddLFxuICAgICAgICB7IHRyYW5zaXRpb25OYW1lOiB0aGlzLmdldFRyYW5zaXRpb25OYW1lKCkgfSxcbiAgICAgICAgbm90aWNlTm9kZXNcbiAgICAgIClcbiAgICApO1xuICB9XG59KTtcblxuTm90aWZpY2F0aW9uLm5ld0luc3RhbmNlID0gZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcbiAgdmFyIHByb3BzID0gcHJvcGVydGllcyB8fCB7fTtcbiAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gIHZhciBub3RpZmljYXRpb24gPSBfcmVhY3REb20yWydkZWZhdWx0J10ucmVuZGVyKF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KE5vdGlmaWNhdGlvbiwgcHJvcHMpLCBkaXYpO1xuICByZXR1cm4ge1xuICAgIG5vdGljZTogZnVuY3Rpb24gbm90aWNlKG5vdGljZVByb3BzKSB7XG4gICAgICBub3RpZmljYXRpb24uYWRkKG5vdGljZVByb3BzKTtcbiAgICB9LFxuICAgIHJlbW92ZU5vdGljZTogZnVuY3Rpb24gcmVtb3ZlTm90aWNlKGtleSkge1xuICAgICAgbm90aWZpY2F0aW9uLnJlbW92ZShrZXkpO1xuICAgIH0sXG4gICAgY29tcG9uZW50OiBub3RpZmljYXRpb24sXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIF9yZWFjdERvbTJbJ2RlZmF1bHQnXS51bm1vdW50Q29tcG9uZW50QXROb2RlKGRpdik7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRpdik7XG4gICAgfVxuICB9O1xufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gTm90aWZpY2F0aW9uO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1tZXNzYWdlL34vcmMtbm90aWZpY2F0aW9uL2xpYi9Ob3RpZmljYXRpb24uanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtbWVzc2FnZS9+L3JjLW5vdGlmaWNhdGlvbi9+L3JjLXV0aWwvbGliL2NsYXNzU2V0LmpzXG4gKiovIiwidmFyIGFkZERPTUV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCdhZGQtZG9tLWV2ZW50LWxpc3RlbmVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYWRkRE9NRXZlbnRMaXN0ZW5lclsnZGVmYXVsdCddIHx8IGFkZERPTUV2ZW50TGlzdGVuZXI7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLW1lc3NhZ2Uvfi9yYy1ub3RpZmljYXRpb24vfi9yYy11dGlsL2xpYi9Eb20vYWRkRXZlbnRMaXN0ZW5lci5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JjVXRpbCA9IHJlcXVpcmUoJ3JjLXV0aWwnKTtcblxudmFyIE5vdGljZSA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnTm90aWNlJyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBkdXJhdGlvbjogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5udW1iZXIsXG4gICAgb25DbG9zZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLFxuICAgIGNoaWxkcmVuOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmFueVxuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvbkVuZDogZnVuY3Rpb24gb25FbmQoKSB7fSxcbiAgICAgIGR1cmF0aW9uOiAxLjUsXG4gICAgICBzdHlsZToge1xuICAgICAgICByaWdodDogJzUwJSdcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuXG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5jbGVhckNsb3NlVGltZXIoKTtcbiAgICBpZiAodGhpcy5wcm9wcy5kdXJhdGlvbikge1xuICAgICAgdGhpcy5jbG9zZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmNsb3NlKCk7XG4gICAgICB9LCB0aGlzLnByb3BzLmR1cmF0aW9uICogMTAwMCk7XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIHRoaXMuY29tcG9uZW50RGlkTW91bnQoKTtcbiAgfSxcblxuICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5jbGVhckNsb3NlVGltZXIoKTtcbiAgfSxcblxuICBjbGVhckNsb3NlVGltZXI6IGZ1bmN0aW9uIGNsZWFyQ2xvc2VUaW1lcigpIHtcbiAgICBpZiAodGhpcy5jbG9zZVRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5jbG9zZVRpbWVyKTtcbiAgICAgIHRoaXMuY2xvc2VUaW1lciA9IG51bGw7XG4gICAgfVxuICB9LFxuXG4gIGNsb3NlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICB0aGlzLmNsZWFyQ2xvc2VUaW1lcigpO1xuICAgIHRoaXMucHJvcHMub25DbG9zZSgpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfY2xhc3NOYW1lO1xuXG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgY29tcG9uZW50Q2xhc3MgPSBwcm9wcy5wcmVmaXhDbHMgKyAnLW5vdGljZSc7XG4gICAgdmFyIGNsYXNzTmFtZSA9IChfY2xhc3NOYW1lID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NOYW1lLCAnJyArIGNvbXBvbmVudENsYXNzLCAxKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWUsIGNvbXBvbmVudENsYXNzICsgJy1jbG9zYWJsZScsIHByb3BzLmNsb3NhYmxlKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWUsIHByb3BzLmNsYXNzTmFtZSwgISFwcm9wcy5jbGFzc05hbWUpLCBfY2xhc3NOYW1lKTtcbiAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnZGl2JyxcbiAgICAgIHsgY2xhc3NOYW1lOiAoMCwgX3JjVXRpbC5jbGFzc1NldCkoY2xhc3NOYW1lKSwgc3R5bGU6IHByb3BzLnN0eWxlIH0sXG4gICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIHsgY2xhc3NOYW1lOiBjb21wb25lbnRDbGFzcyArICctY29udGVudCcgfSxcbiAgICAgICAgdGhpcy5wcm9wcy5jaGlsZHJlblxuICAgICAgKSxcbiAgICAgIHByb3BzLmNsb3NhYmxlID8gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdhJyxcbiAgICAgICAgeyB0YWJJbmRleDogJzAnLCBvbkNsaWNrOiB0aGlzLmNsb3NlLCBjbGFzc05hbWU6IGNvbXBvbmVudENsYXNzICsgJy1jbG9zZScgfSxcbiAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nLCB7IGNsYXNzTmFtZTogY29tcG9uZW50Q2xhc3MgKyAnLWNsb3NlLXgnIH0pXG4gICAgICApIDogbnVsbFxuICAgICk7XG4gIH1cbn0pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBOb3RpY2U7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLW1lc3NhZ2Uvfi9yYy1ub3RpZmljYXRpb24vbGliL05vdGljZS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBQaWNrYWJsZSBDb21wb25lbnQgZm9yIHV4Y29yZVxuICogQGF1dGhvciBvbmJpbmdcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBVeGNvcmUgVGVhbSwgQWxpbncuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9QaWNrYWJsZScpO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtcGlja2FibGUvYnVpbGQvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBQaWNrYWJsZSBDb21wb25lbnQgZm9yIHV4Y29yZVxuICogQGF1dGhvciBvbmJpbmdcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBVeGNvcmUgVGVhbSwgQWxpbncuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbnZhciBjbGFzc25hbWVzID0gcmVxdWlyZShcImNsYXNzbmFtZXNcIik7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBJdGVtcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSXRlbXMocHJvcHMsIG9uQ2hhbmdlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEl0ZW1zKTtcblxuICAgIHRoaXMub25DaGFuZ2UgPSBvbkNoYW5nZTtcbiAgICB0aGlzLmluaXRJdGVtcyhwcm9wcy5pdGVtcyB8fCBbXSk7XG4gIH1cblxuICBJdGVtcy5wcm90b3R5cGUuaW5pdEl0ZW1zID0gZnVuY3Rpb24gaW5pdEl0ZW1zKGl0ZW1zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuaXRlbXMgPSBpdGVtcyA/IGl0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIG5ldyBJdGVtKF90aGlzLCBpdGVtKTtcbiAgICB9KSA6IFtdO1xuICB9O1xuXG4gIEl0ZW1zLnByb3RvdHlwZS5nZXRJdGVtcyA9IGZ1bmN0aW9uIGdldEl0ZW1zKCkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zO1xuICB9O1xuXG4gIEl0ZW1zLnByb3RvdHlwZS5yZW1vdmVJdGVtID0gZnVuY3Rpb24gcmVtb3ZlSXRlbShpdGVtKSB7XG4gICAgLy8gdHJpZ2dlclxuICAgIHZhciBpID0gdGhpcy5pdGVtcy5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpIDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLml0ZW1zLnNwbGljZShpLCAxKTtcbiAgICB0aGlzLm9uQ2hhbmdlKHRoaXMuZ2V0VmFsdWVzKCksIHRoaXMuaXRlbXMpO1xuICB9O1xuXG4gIEl0ZW1zLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICB0aGlzLm9uQ2hhbmdlKFtdLCBbXSk7XG4gIH07XG5cbiAgSXRlbXMucHJvdG90eXBlLmNoZWNrQ2hhbmdlID0gZnVuY3Rpb24gY2hlY2tDaGFuZ2UoKSB7XG4gICAgdGhpcy5vbkNoYW5nZSh0aGlzLmdldENoZWNrZWRWYWx1ZXMoKSwgdGhpcy5pdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRleHQ6IGl0ZW0uZ2V0VGV4dCgpLFxuICAgICAgICB2YWx1ZTogaXRlbS5nZXRWYWx1ZSgpLFxuICAgICAgICBjaGVja2VkOiBpdGVtLmlzQ2hlY2tlZCgpXG4gICAgICB9O1xuICAgIH0pKTtcbiAgfTtcblxuICBJdGVtcy5wcm90b3R5cGUuY2xlYXJDaGVjayA9IGZ1bmN0aW9uIGNsZWFyQ2hlY2soKSB7XG4gICAgdGhpcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbS51bkNoZWNrKCk7XG4gICAgfSk7XG4gICAgdGhpcy5jaGVja0NoYW5nZSgpO1xuICB9O1xuXG4gIEl0ZW1zLnByb3RvdHlwZS5nZXRDaGVja2VkVmFsdWVzID0gZnVuY3Rpb24gZ2V0Q2hlY2tlZFZhbHVlcygpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtLmlzQ2hlY2tlZCgpO1xuICAgIH0pLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0uZ2V0VmFsdWUoKTtcbiAgICB9KTtcbiAgfTtcblxuICBJdGVtcy5wcm90b3R5cGUuZ2V0VmFsdWVzID0gZnVuY3Rpb24gZ2V0VmFsdWVzKCkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0uZ2V0VmFsdWUoKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gSXRlbXM7XG59KCk7XG5cbnZhciBJdGVtID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBJdGVtKGl0ZW1zLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEl0ZW0pO1xuXG4gICAgdGhpcy52YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgdGhpcy50ZXh0ID0gb3B0aW9ucy50ZXh0O1xuICAgIHRoaXMuY2hlY2tlZCA9IG9wdGlvbnMuY2hlY2tlZDtcbiAgICB0aGlzLml0ZW1zID0gaXRlbXM7XG4gIH1cblxuICBJdGVtLnByb3RvdHlwZS5nZXRLZXkgPSBmdW5jdGlvbiBnZXRLZXkoKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudmFsdWUpICsgXCItXCIgKyB0aGlzLnRleHQ7XG4gIH07XG5cbiAgSXRlbS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgIHRoaXMuaXRlbXMucmVtb3ZlSXRlbSh0aGlzKTtcbiAgfTtcblxuICBJdGVtLnByb3RvdHlwZS51bkNoZWNrID0gZnVuY3Rpb24gdW5DaGVjaygpIHtcbiAgICB0aGlzLmNoZWNrZWQgPSBmYWxzZTtcbiAgfTtcblxuICBJdGVtLnByb3RvdHlwZS5pc0NoZWNrZWQgPSBmdW5jdGlvbiBpc0NoZWNrZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2tlZDtcbiAgfTtcblxuICBJdGVtLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiB0b2dnbGUoKSB7XG4gICAgaWYgKHRoaXMuY2hlY2tlZCkge1xuICAgICAgdGhpcy5jaGVja2VkID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2hlY2tlZCA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuaXRlbXMuY2hlY2tDaGFuZ2UoKTtcbiAgfTtcblxuICBJdGVtLnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24gZ2V0VGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0O1xuICB9O1xuXG4gIEl0ZW0ucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH07XG5cbiAgcmV0dXJuIEl0ZW07XG59KCk7XG5cbnZhciBQaWNrYWJsZSA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhQaWNrYWJsZSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUGlja2FibGUocHJvcHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGlja2FibGUpO1xuXG4gICAgdmFyIF90aGlzMiA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgX3RoaXMyLml0ZW1zID0gbmV3IEl0ZW1zKF90aGlzMi5wcm9wcywgX3RoaXMyLm9uQ2hhbmdlLmJpbmQoX3RoaXMyKSk7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuXG4gIFBpY2thYmxlLnByb3RvdHlwZS5vbkNoYW5nZSA9IGZ1bmN0aW9uIG9uQ2hhbmdlKHZhbHVlcywgaXRlbXMpIHtcbiAgICB0aGlzLnByb3BzLm9uQ2hhbmdlICYmIHRoaXMucHJvcHMub25DaGFuZ2UodmFsdWVzLCBpdGVtcyk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7fSk7XG4gIH07XG5cbiAgUGlja2FibGUucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtcy5nZXRDaGVja2VkVmFsdWVzKCk7XG4gIH07XG5cbiAgUGlja2FibGUucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIGlmIChuZXh0UHJvcHMuaXRlbXMpIHtcbiAgICAgIHRoaXMuaXRlbXMuaW5pdEl0ZW1zKG5leHRQcm9wcy5pdGVtcyk7XG4gICAgfVxuICB9O1xuXG4gIFBpY2thYmxlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB2YXIgaXRlbXMgPSB0aGlzLml0ZW1zLmdldENoZWNrZWRWYWx1ZXMoKTtcbiAgICB2YXIgaGlkZUNsZWFyID0gdGhpcy5wcm9wcy5hdXRvSGlkZUNsZWFyICYmIGl0ZW1zLmxlbmd0aCA8IDE7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAndWwnLFxuICAgICAgeyBjbGFzc05hbWU6IGNsYXNzbmFtZXMoXCJrdW1hLXBpY2thYmxlXCIsIHRoaXMucHJvcHMuY2xhc3NOYW1lKSB9LFxuICAgICAgdGhpcy5pdGVtcy5nZXRJdGVtcygpLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnbGknLFxuICAgICAgICAgIHsga2V5OiBpdGVtLmdldEtleSgpLCBjbGFzc05hbWU6IGNsYXNzbmFtZXMoXCJrdW1hLXBpY2thYmxlLWl0ZW1cIiwgaXRlbS5pc0NoZWNrZWQoKSAmJiBcImNoZWNrZWRcIiksIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soKSB7XG4gICAgICAgICAgICAgIGl0ZW0udG9nZ2xlKCk7XG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAna3VtYS1waWNrYWJsZS10ZXh0JyB9LFxuICAgICAgICAgICAgaXRlbS5nZXRUZXh0KClcbiAgICAgICAgICApLFxuICAgICAgICAgIGl0ZW0uaXNDaGVja2VkKCkgJiYgUmVhY3QuY3JlYXRlRWxlbWVudCgnaScsIHsgY2xhc3NOYW1lOiAna3VtYS1pY29uIGt1bWEtaWNvbi1jaG9vc2UgYmFkZ2UnIH0pXG4gICAgICAgICk7XG4gICAgICB9KSxcbiAgICAgIHRoaXMucHJvcHMuaGFzQ2xlYXIgJiYgIWhpZGVDbGVhciAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnbGknLFxuICAgICAgICB7IGNsYXNzTmFtZTogJ2t1bWEtcGlja2FibGUtY2xlYXInLCBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKCkge1xuICAgICAgICAgICAgX3RoaXMzLml0ZW1zLmNsZWFyQ2hlY2soKTtcbiAgICAgICAgICB9IH0sXG4gICAgICAgICfmuIXpmaTmiYDpgIknXG4gICAgICApXG4gICAgKTtcbiAgfTtcblxuICByZXR1cm4gUGlja2FibGU7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbnZhciBSZW1vdmVhYmxlID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQyKSB7XG4gIF9pbmhlcml0cyhSZW1vdmVhYmxlLCBfUmVhY3QkQ29tcG9uZW50Mik7XG5cbiAgZnVuY3Rpb24gUmVtb3ZlYWJsZShwcm9wcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZW1vdmVhYmxlKTtcblxuICAgIHZhciBfdGhpczQgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50Mi5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICBfdGhpczQuaXRlbXMgPSBuZXcgSXRlbXMoX3RoaXM0LnByb3BzLCBfdGhpczQub25DaGFuZ2UuYmluZChfdGhpczQpKTtcbiAgICByZXR1cm4gX3RoaXM0O1xuICB9XG5cbiAgUmVtb3ZlYWJsZS5wcm90b3R5cGUub25DaGFuZ2UgPSBmdW5jdGlvbiBvbkNoYW5nZSh2YWx1ZXMsIGl0ZW1zKSB7XG4gICAgdGhpcy5wcm9wcy5vbkNoYW5nZSAmJiB0aGlzLnByb3BzLm9uQ2hhbmdlKHZhbHVlcywgaXRlbXMpO1xuICAgIHRoaXMuc2V0U3RhdGUoe30pO1xuICB9O1xuXG4gIFJlbW92ZWFibGUucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtcy5nZXRWYWx1ZXMoKTtcbiAgfTtcblxuICBSZW1vdmVhYmxlLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICBpZiAobmV4dFByb3BzLml0ZW1zKSB7XG4gICAgICB0aGlzLml0ZW1zLmluaXRJdGVtcyhuZXh0UHJvcHMuaXRlbXMpO1xuICAgIH1cbiAgfTtcblxuICBSZW1vdmVhYmxlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICB2YXIgaXRlbXMgPSB0aGlzLml0ZW1zLmdldEl0ZW1zKCk7XG4gICAgdmFyIGhpZGVDbGVhciA9IHRoaXMucHJvcHMuYXV0b0hpZGVDbGVhciAmJiBpdGVtcy5sZW5ndGggPCAxO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgJ3VsJyxcbiAgICAgIHsgY2xhc3NOYW1lOiBjbGFzc25hbWVzKFwia3VtYS1waWNrYWJsZVwiLCBcImt1bWEtcGlja2FibGUtcmVtb3ZlYWJsZVwiLCB0aGlzLnByb3BzLmNsYXNzTmFtZSkgfSxcbiAgICAgIGl0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnbGknLFxuICAgICAgICAgIHsga2V5OiBpdGVtLmdldEtleSgpLCBjbGFzc05hbWU6ICdrdW1hLXBpY2thYmxlLWl0ZW0nIH0sXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAna3VtYS1waWNrYWJsZS10ZXh0JyB9LFxuICAgICAgICAgICAgaXRlbS5nZXRUZXh0KClcbiAgICAgICAgICApLFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2knLCB7IGNsYXNzTmFtZTogJ2t1bWEtaWNvbiBrdW1hLWljb24tY2xvc2UgcmVtb3ZlcicsIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpdGVtLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSB9KVxuICAgICAgICApO1xuICAgICAgfSksXG4gICAgICB0aGlzLnByb3BzLmhhc0NsZWFyICYmICFoaWRlQ2xlYXIgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2xpJyxcbiAgICAgICAgeyBjbGFzc05hbWU6ICdrdW1hLXBpY2thYmxlLWNsZWFyJywgb25DbGljazogZnVuY3Rpb24gb25DbGljaygpIHtcbiAgICAgICAgICAgIF90aGlzNS5pdGVtcy5jbGVhcigpO1xuICAgICAgICAgIH0gfSxcbiAgICAgICAgJ+a4hemZpOaJgOmAiSdcbiAgICAgIClcbiAgICApO1xuICB9O1xuXG4gIHJldHVybiBSZW1vdmVhYmxlO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5SZW1vdmVhYmxlLmRlZmF1bHRQcm9wcyA9IHtcbiAgaXRlbXM6IG51bGwsXG4gIGhhc0NsZWFyOiB0cnVlLFxuICBhdXRvSGlkZUNsZWFyOiB0cnVlLFxuICBvbkNoYW5nZTogbnVsbFxufTtcblxuLy8gaHR0cDovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3JldXNhYmxlLWNvbXBvbmVudHMuaHRtbFxuUmVtb3ZlYWJsZS5wcm9wVHlwZXMgPSB7XG4gIGhhc0NsZWFyOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgYXV0b0hpZGVDbGVhcjogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gIGl0ZW1zOiBSZWFjdC5Qcm9wVHlwZXMuYXJyYXksXG4gIG9uQ2hhbmdlOiBSZWFjdC5Qcm9wVHlwZXMuZnVuY1xufTtcblxuUmVtb3ZlYWJsZS5kaXNwbGF5TmFtZSA9IFwiUmVtb3ZlYWJsZVwiO1xuXG5QaWNrYWJsZS5SZW1vdmVhYmxlID0gUmVtb3ZlYWJsZTtcblxuUGlja2FibGUuZGVmYXVsdFByb3BzID0ge1xuICBpdGVtczogbnVsbCxcbiAgaGFzQ2xlYXI6IHRydWUsXG4gIGF1dG9IaWRlQ2xlYXI6IHRydWUsXG4gIG9uQ2hhbmdlOiBudWxsXG59O1xuXG4vLyBodHRwOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvcmV1c2FibGUtY29tcG9uZW50cy5odG1sXG5QaWNrYWJsZS5wcm9wVHlwZXMgPSB7XG4gIGhhc0NsZWFyOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgYXV0b0hpZGVDbGVhcjogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gIGl0ZW1zOiBSZWFjdC5Qcm9wVHlwZXMuYXJyYXksXG4gIG9uQ2hhbmdlOiBSZWFjdC5Qcm9wVHlwZXMuZnVuY1xufTtcblxuUGlja2FibGUuZGlzcGxheU5hbWUgPSBcIlBpY2thYmxlXCI7XG5cbm1vZHVsZS5leHBvcnRzID0gUGlja2FibGU7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1waWNrYWJsZS9idWlsZC9QaWNrYWJsZS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBQcmltYXJ5TmF2IENvbXBvbmVudCBmb3IgdXhjb3JlXG4gKiBAYXV0aG9yIGV0ZXJuYXNsa3lcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBVeGNvcmUgVGVhbSwgQWxpbncuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9QcmltYXJ5TmF2Jyk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL0BhbGkvdXhjb3JlLXByaW1hcnktbmF2L2J1aWxkL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfY2xhc3NuYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcblxudmFyIF9jbGFzc25hbWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzbmFtZXMpO1xuXG52YXIgX3V4Y29yZU1lbnUgPSByZXF1aXJlKCd1eGNvcmUtbWVudScpO1xuXG52YXIgX3V4Y29yZU1lbnUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXhjb3JlTWVudSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogUHJpbWFyeU5hdiBDb21wb25lbnQgZm9yIHV4Y29yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGF1dGhvciBldGVybmFzbGt5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgVXhjb3JlIFRlYW0sIEFsaW53LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG52YXIgUHJpbWFyeU5hdiA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzKFByaW1hcnlOYXYsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gUHJpbWFyeU5hdihwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUHJpbWFyeU5hdik7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuICAgIH1cblxuICAgIFByaW1hcnlOYXYucHJvdG90eXBlLm9uU3dpdGNoTGFuZyA9IGZ1bmN0aW9uIG9uU3dpdGNoTGFuZyhlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZUkxOG4odGhpcy5wcm9wcy5sYW5nLCBlKTtcbiAgICB9O1xuXG4gICAgUHJpbWFyeU5hdi5wcm90b3R5cGUuZ2V0UHJpbWFyeU1lbnUgPSBmdW5jdGlvbiBnZXRQcmltYXJ5TWVudSgpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBfdXhjb3JlTWVudTJbXCJkZWZhdWx0XCJdLFxuICAgICAgICAgICAgeyBtb2RlOiAnaG9yaXpvbnRhbCcsIHByZWZpeENsczogJ21haW4tbWVudScsIHNlbGVjdGVkS2V5czogcHJvcHMuc2VsZWN0ZWRLZXlzLCBkZWZhdWx0U2VsZWN0ZWRLZXlzOiBwcm9wcy5kZWZhdWx0U2VsZWN0ZWRLZXlzIH0sXG4gICAgICAgICAgICBwcm9wcy5wcmltYXJ5TmF2SXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtLCBpZHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWVudUl0ZW0gPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uc3ViSXRlbXMgJiYgaXRlbS5zdWJJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lbnVJdGVtID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgIF91eGNvcmVNZW51LlN1Yk1lbnUsXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHRpdGxlOiBpdGVtLnRleHQsIGtleTogJ3ByaW1hcnlfaXRlbV8nICsgaWR4IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnN1Ykl0ZW1zLm1hcChmdW5jdGlvbiAoc3ViSXRlbSwgc3ViSWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF91eGNvcmVNZW51Lkl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsga2V5OiAncHJpbWFyeV9pdGVtXycgKyBpZHggKyAnXycgKyBzdWJJZHggfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViSXRlbS50ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWVudUl0ZW0gPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgX3V4Y29yZU1lbnUuSXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsga2V5OiAncHJpbWFyeV9pdGVtXycgKyBpZHggfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udGV4dFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWVudUl0ZW07XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICBQcmltYXJ5TmF2LnByb3RvdHlwZS5nZXRTZWNvbmRhcnlNZW51ID0gZnVuY3Rpb24gZ2V0U2Vjb25kYXJ5TWVudSgpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBfdXhjb3JlTWVudTJbXCJkZWZhdWx0XCJdLFxuICAgICAgICAgICAgeyBtb2RlOiAnaG9yaXpvbnRhbCcsIHByZWZpeENsczogJ3NlY29uZGFyeS1tZW51JyB9LFxuICAgICAgICAgICAgcHJvcHMuc2Vjb25kYXJ5TmF2SXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtLCBpZHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgX3V4Y29yZU1lbnUuSXRlbSxcbiAgICAgICAgICAgICAgICAgICAgeyBrZXk6ICdzZWNvbmRhcnlfaXRlbV8nICsgaWR4IH0sXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udGV4dFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICBQcmltYXJ5TmF2LnByb3RvdHlwZS5vbkNsaWNrU2VhcmNoQnV0dG9uID0gZnVuY3Rpb24gb25DbGlja1NlYXJjaEJ1dHRvbihlKSB7XG4gICAgICAgIHZhciBzZWFyY2hGaWVsZCA9IHRoaXMucmVmcy5zZWFyY2hGaWVsZDtcbiAgICAgICAgdGhpcy5wcm9wcy5vblNlYXJjaChzZWFyY2hGaWVsZC52YWx1ZSwgc2VhcmNoRmllbGQpO1xuICAgIH07XG5cbiAgICBQcmltYXJ5TmF2LnByb3RvdHlwZS5vblByZXNzRmllbGQgPSBmdW5jdGlvbiBvblByZXNzRmllbGQoZSkge1xuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykge1xuICAgICAgICAgICAgdmFyIHNlYXJjaEZpZWxkID0gdGhpcy5yZWZzLnNlYXJjaEZpZWxkO1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vblNlYXJjaChzZWFyY2hGaWVsZC52YWx1ZSwgc2VhcmNoRmllbGQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFByaW1hcnlOYXYucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIGxhbmdTd2l0Y2ggPSB2b2lkIDAsXG4gICAgICAgICAgICByZXQgPSB2b2lkIDAsXG4gICAgICAgICAgICBuYXZDbGFzcyA9IHZvaWQgMCxcbiAgICAgICAgICAgIHNlYXJjaEZpZWxkID0gdm9pZCAwO1xuICAgICAgICBpZiAocHJvcHMuaGFzR2xvYmFsU2VhcmNoKSB7XG4gICAgICAgICAgICBzZWFyY2hGaWVsZCA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICduYXZpZ2F0aW9uLXNlYXJjaCcgfSxcbiAgICAgICAgICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KCdpbnB1dCcsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmOiAnc2VhcmNoRmllbGQnLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ25hdmlnYXRpb24tc2VhcmNoLWZpZWxkJyxcbiAgICAgICAgICAgICAgICAgICAgb25LZXlVcDogdGhpcy5vblByZXNzRmllbGQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IHByb3BzLnNlYXJjaFBsYWNlaG9sZGVyIH0pLFxuICAgICAgICAgICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICdidXR0b24nLFxuICAgICAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ25hdmlnYXRpb24tc2VhcmNoLWJ1dHRvbicsIG9uQ2xpY2s6IHRoaXMub25DbGlja1NlYXJjaEJ1dHRvbi5iaW5kKHRoaXMpIH0sXG4gICAgICAgICAgICAgICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoJ2knLCB7IGNsYXNzTmFtZTogJ2t1bWEtaWNvbiBrdW1hLWljb24tc2VhcmNoJyB9KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BzLmZ1bGxXaWR0aCkge1xuICAgICAgICAgICAgaWYgKHByb3BzLnNob3dMYW5nU3dpdGNoKSB7XG4gICAgICAgICAgICAgICAgbGFuZ1N3aXRjaCA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgICAgICAgICAgeyBocmVmOiAnIycsIG9uQ2xpY2s6IHRoaXMub25Td2l0Y2hMYW5nLmJpbmQodGhpcyksIGNsYXNzTmFtZTogJ2xhbmctc3dpdGNoJyB9LFxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5sYW5nXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFuZ1N3aXRjaCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuYXZDbGFzcyA9ICgwLCBfY2xhc3NuYW1lczJbXCJkZWZhdWx0XCJdKSh7XG4gICAgICAgICAgICAgICAgJ2t1bWEtY29udGFpbmVyLWZ1bGwnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdrdW1hLXByaW1hcnktbmF2aWdhdGlvbic6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2t1bWEtcHJpbWFyeS1uYXZpZ2F0aW9uLXNlYXJjaCc6IHByb3BzLmhhc0dsb2JhbFNlYXJjaCxcbiAgICAgICAgICAgICAgICAna3VtYS1udy11eGNvcmUnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdsYW5nLWVuJzogcHJvcHMubG9jYWxlID09PSAnZW4nLFxuICAgICAgICAgICAgICAgICdsb2dvX2FsaSc6IHByb3BzLmxvZ29UeXBlID09PSAnYWxpJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXQgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBuYXZDbGFzcyB9LFxuICAgICAgICAgICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2t1bWEtcG4tYnJhbmQnIH0sXG4gICAgICAgICAgICAgICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoJ2EnLCB7IGhyZWY6ICdodHRwczovL3dvcmsuYWxpYmFiYS1pbmMuY29tJywgY2xhc3NOYW1lOiAnc2l0ZS1sb2dvJywgdGFyZ2V0OiAnX2JsYW5rJyB9KSxcbiAgICAgICAgICAgICAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICdoMicsXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ3NpdGUtYnJhbmQnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGhyZWY6IHByb3BzLnN5c3RlbUxpbmsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5zeXN0ZW1OYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2t1bWEtcG4tbWFpbicgfSxcbiAgICAgICAgICAgICAgICAgICAgc2VhcmNoRmllbGQsXG4gICAgICAgICAgICAgICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAna3VtYS1wbi1tZW51JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRQcmltYXJ5TWVudSgpXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAna3VtYS1wbi1sYW5nJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFuZ1N3aXRjaFxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2t1bWEtcG4tc2Vjb25kYXJ5LW1lbnUnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFNlY29uZGFyeU1lbnUoKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwcm9wcy5zaG93TGFuZ1N3aXRjaCkge1xuICAgICAgICAgICAgICAgIGxhbmdTd2l0Y2ggPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAnYScsXG4gICAgICAgICAgICAgICAgICAgIHsgaHJlZjogJyMnLCBvbkNsaWNrOiB0aGlzLm9uU3dpdGNoTGFuZy5iaW5kKHRoaXMpLCBjbGFzc05hbWU6ICdsYW5nLXN3aXRjaCcgfSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMubGFuZ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxhbmdTd2l0Y2ggPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmF2Q2xhc3MgPSAoMCwgX2NsYXNzbmFtZXMyW1wiZGVmYXVsdFwiXSkoe1xuICAgICAgICAgICAgICAgICdmbi1ib3JkZXItYm94JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAna3VtYS1wcmltYXJ5LW5hdmlnYXRpb24nOiB0cnVlLFxuICAgICAgICAgICAgICAgICdrdW1hLXByaW1hcnktbmF2aWdhdGlvbi1zZWFyY2gnOiBwcm9wcy5oYXNHbG9iYWxTZWFyY2gsXG4gICAgICAgICAgICAgICAgJ2t1bWEtbnctdXhjb3JlJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnbGFuZy1lbic6IHByb3BzLmxvY2FsZSA9PT0gJ2VuJyxcbiAgICAgICAgICAgICAgICAnbG9nb19hbGknOiBwcm9wcy5sb2dvVHlwZSA9PT0gJ2FsaSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAocHJvcHMuaGFzR2xvYmFsU2VhcmNoKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBuYXZDbGFzcyB9LFxuICAgICAgICAgICAgICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2t1bWEtY29udGFpbmVyLTExODAnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAna3VtYS1yb3cnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnY29sLXhzLTcnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoJ2EnLCB7IGhyZWY6ICdodHRwczovL3dvcmsuYWxpYmFiYS1pbmMuY29tJywgY2xhc3NOYW1lOiAnc2l0ZS1sb2dvJywgdGFyZ2V0OiAnX2JsYW5rJyB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdoMicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ3NpdGUtYnJhbmQnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGhyZWY6IHByb3BzLnN5c3RlbUxpbmsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5zeXN0ZW1OYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2NvbC14cy03JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hGaWVsZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnY29sLXhzLTgnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0UHJpbWFyeU1lbnUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnY29sLXhzLTInIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnc2l0ZS1yaWdodCcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhbmdTd2l0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldCA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogbmF2Q2xhc3MgfSxcbiAgICAgICAgICAgICAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdrdW1hLWNvbnRhaW5lci0xMTgwJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2t1bWEtcm93JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2NvbC14cy03JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KCdhJywgeyBocmVmOiAnaHR0cHM6Ly93b3JrLmFsaWJhYmEtaW5jLmNvbScsIGNsYXNzTmFtZTogJ3NpdGUtbG9nbycsIHRhcmdldDogJ19ibGFuaycgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaDInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdzaXRlLWJyYW5kJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBocmVmOiBwcm9wcy5zeXN0ZW1MaW5rIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMuc3lzdGVtTmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdjb2wteHMtMTEnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0UHJpbWFyeU1lbnUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnY29sLXhzLTYnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAnc2l0ZS1yaWdodCcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0U2Vjb25kYXJ5TWVudSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFuZ1N3aXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICByZXR1cm4gUHJpbWFyeU5hdjtcbn0oX3JlYWN0MltcImRlZmF1bHRcIl0uQ29tcG9uZW50KTtcblxuUHJpbWFyeU5hdi5kZWZhdWx0UHJvcHMgPSB7XG4gICAgc3lzdGVtTmFtZTogJ+ezu+e7n+WQjeensCcsXG4gICAgcHJpbWFyeU5hdkl0ZW1zOiBbXSxcbiAgICBzZWNvbmRhcnlOYXZJdGVtczogW10sXG4gICAgc2hvd0xhbmdTd2l0Y2g6IHRydWUsXG4gICAgbGFuZzogJ0VOJyxcbiAgICBmdWxsV2lkdGg6IGZhbHNlLFxuICAgIG9uQ2hhbmdlSTE4bjogZnVuY3Rpb24gb25DaGFuZ2VJMThuKGxhbmcsIGUpIHt9LFxuICAgIGxvY2FsZTogJ3poLWNuJyxcbiAgICBzeXN0ZW1MaW5rOiAnIycsXG4gICAgaGFzR2xvYmFsU2VhcmNoOiBmYWxzZSxcbiAgICBzZWFyY2hQbGFjZWhvbGRlcjogJ+aQnOe0oicsXG4gICAgb25TZWFyY2g6IGZ1bmN0aW9uIG9uU2VhcmNoKHZhbHVlLCBpbnB1dCkge30sXG4gICAgc2VsZWN0ZWRLZXlzOiBbXSxcbiAgICBkZWZhdWx0U2VsZWN0ZWRLZXlzOiBbXSxcbiAgICBsb2dvVHlwZTogJ2RlZmF1bHQnXG59O1xuXG4vLyBodHRwOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvcmV1c2FibGUtY29tcG9uZW50cy5odG1sXG5QcmltYXJ5TmF2LnByb3BUeXBlcyA9IHtcbiAgICBzeXN0ZW1OYW1lOiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHByaW1hcnlOYXZJdGVtczogX3JlYWN0MltcImRlZmF1bHRcIl0uUHJvcFR5cGVzLmFycmF5LFxuICAgIHNlY29uZGFyeU5hdkl0ZW1zOiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMuYXJyYXksXG4gICAgc2hvd0xhbmdTd2l0Y2g6IF9yZWFjdDJbXCJkZWZhdWx0XCJdLlByb3BUeXBlcy5ib29sLFxuICAgIGZ1bGxXaWR0aDogX3JlYWN0MltcImRlZmF1bHRcIl0uUHJvcFR5cGVzLmJvb2wsXG4gICAgbGFuZzogX3JlYWN0MltcImRlZmF1bHRcIl0uUHJvcFR5cGVzLnN0cmluZyxcbiAgICBvbkNoYW5nZUkxOG46IF9yZWFjdDJbXCJkZWZhdWx0XCJdLlByb3BUeXBlcy5mdW5jLFxuICAgIGxvY2FsZTogX3JlYWN0MltcImRlZmF1bHRcIl0uUHJvcFR5cGVzLm9uZU9mKFsnemgtY24nLCAnZW4nXSksXG4gICAgc3lzdGVtTGluazogX3JlYWN0MltcImRlZmF1bHRcIl0uUHJvcFR5cGVzLnN0cmluZyxcbiAgICBoYXNHbG9iYWxTZWFyY2g6IF9yZWFjdDJbXCJkZWZhdWx0XCJdLlByb3BUeXBlcy5ib29sLFxuICAgIHNlYXJjaFBsYWNlaG9sZGVyOiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9uU2VhcmNoOiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMuZnVuYyxcbiAgICBzZWxlY3RlZEtleXM6IF9yZWFjdDJbXCJkZWZhdWx0XCJdLlByb3BUeXBlcy5hcnJheSxcbiAgICBkZWZhdWx0U2VsZWN0ZWRLZXlzOiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5Qcm9wVHlwZXMuYXJyYXksXG4gICAgbG9nb1R5cGU6IF9yZWFjdDJbXCJkZWZhdWx0XCJdLlByb3BUeXBlcy5vbmVPZihbJ2RlZmF1bHQnLCAnYWxpJ10pXG59O1xuXG5QcmltYXJ5TmF2LmRpc3BsYXlOYW1lID0gJ1ByaW1hcnlOYXYnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByaW1hcnlOYXY7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL0BhbGkvdXhjb3JlLXByaW1hcnktbmF2L2J1aWxkL1ByaW1hcnlOYXYuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2FsZW5kYXIgQ29tcG9uZW50IGZvciB1eGNvcmVcbiAqIEBhdXRob3IgXG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgVXhjb3JlIFRlYW0sIEFsaW53LlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vQ2FsZW5kYXInKTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL2J1aWxkL2luZGV4LmpzXG4gKiovIiwiLypcbiAqIEdyZWdvcmlhbkNhbGVuZGFyIGNsYXNzXG4gKiBAaWdub3JlXG4gKiBAYXV0aG9yIHlpbWluZ2hlQGdtYWlsLmNvbVxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB0b0ludCA9IHBhcnNlSW50O1xudmFyIFV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGRlZmF1bHRMb2NhbGUgPSByZXF1aXJlKCcuL2xvY2FsZS9lbl9VUycpO1xudmFyIENvbnN0ID0gcmVxdWlyZSgnLi9jb25zdCcpO1xuXG4vKlxuICogR3JlZ29yaWFuQ2FsZW5kYXIgY2xhc3MuXG4gKlxuICogLSBubyBhcmd1bWVudHM6XG4gKiAgIENvbnN0cnVjdHMgYSBkZWZhdWx0IEdyZWdvcmlhbkNhbGVuZGFyIHVzaW5nIHRoZSBjdXJyZW50IHRpbWVcbiAqICAgaW4gdGhlIGRlZmF1bHQgdGltZSB6b25lIHdpdGggdGhlIGRlZmF1bHQgbG9jYWxlLlxuICogLSBvbmUgYXJndW1lbnQgbG9jYWxlOlxuICogICBDb25zdHJ1Y3RzIGEgR3JlZ29yaWFuQ2FsZW5kYXJcbiAqICAgYmFzZWQgb24gdGhlIGN1cnJlbnQgdGltZSBpbiB0aGUgZGVmYXVsdCB0aW1lIHpvbmUgd2l0aCB0aGUgZ2l2ZW4gbG9jYWxlLlxuICpcbiAqIEBjbGFzcyBEYXRlLkdyZWdvcmlhblxuICovXG5mdW5jdGlvbiBHcmVnb3JpYW5DYWxlbmRhcihsb2MpIHtcbiAgdmFyIGxvY2FsZSA9IGxvYyB8fCBkZWZhdWx0TG9jYWxlO1xuXG4gIHRoaXMubG9jYWxlID0gbG9jYWxlO1xuXG4gIHRoaXMuZmllbGRzID0gW107XG5cbiAgLypcbiAgICogVGhlIGN1cnJlbnRseSBzZXQgdGltZSBmb3IgdGhpcyBkYXRlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEB0eXBlIE51bWJlcnx1bmRlZmluZWRcbiAgICovXG4gIHRoaXMudGltZSA9IHVuZGVmaW5lZDtcbiAgLypcbiAgICogVGhlIHRpbWV6b25lT2Zmc2V0IGluIG1pbnV0ZXMgdXNlZCBieSB0aGlzIGRhdGUuXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG4gIHRoaXMudGltZXpvbmVPZmZzZXQgPSBsb2NhbGUudGltZXpvbmVPZmZzZXQ7XG5cbiAgLypcbiAgICogVGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vla1xuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgdGhpcy5maXJzdERheU9mV2VlayA9IGxvY2FsZS5maXJzdERheU9mV2VlaztcblxuICAvKlxuICAgKiBUaGUgbnVtYmVyIG9mIGRheXMgcmVxdWlyZWQgZm9yIHRoZSBmaXJzdCB3ZWVrIGluIGEgbW9udGggb3IgeWVhcixcbiAgICogd2l0aCBwb3NzaWJsZSB2YWx1ZXMgZnJvbSAxIHRvIDcuXG4gICAqIEBAcHJvdGVjdGVkXG4gICAqIEB0eXBlIE51bWJlclxuICAgKi9cbiAgdGhpcy5taW5pbWFsRGF5c0luRmlyc3RXZWVrID0gbG9jYWxlLm1pbmltYWxEYXlzSW5GaXJzdFdlZWs7XG5cbiAgdGhpcy5maWVsZHNDb21wdXRlZCA9IGZhbHNlO1xufVxuXG5VdGlscy5taXgoR3JlZ29yaWFuQ2FsZW5kYXIsIENvbnN0KTtcblxuVXRpbHMubWl4KEdyZWdvcmlhbkNhbGVuZGFyLCB7XG4gIFV0aWxzOiBVdGlscyxcblxuICBkZWZhdWx0TG9jYWxlOiBkZWZhdWx0TG9jYWxlLFxuXG4gIC8qXG4gICAqIERldGVybWluZXMgaWYgdGhlIGdpdmVuIHllYXIgaXMgYSBsZWFwIHllYXIuXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4geWVhciBpcyBhIGxlYXAgeWVhci4gVG8gc3BlY2lmeSBCQyB5ZWFyIG51bWJlcnMsXG4gICAqIDEgLSB5ZWFyIG51bWJlciBtdXN0IGJlIGdpdmVuLiBGb3IgZXhhbXBsZSwgeWVhciBCQyA0IGlzIHNwZWNpZmllZCBhcyAtMy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHllYXIgdGhlIGdpdmVuIHllYXIuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoZSBnaXZlbiB5ZWFyIGlzIGEgbGVhcCB5ZWFyOyBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBzdGF0aWNcbiAgICogQG1ldGhvZFxuICAgKi9cbiAgaXNMZWFwWWVhcjogVXRpbHMuaXNMZWFwWWVhcixcblxuICAvKlxuICAgKiBFbnVtIGluZGljYXRpbmcgeWVhciBmaWVsZCBvZiBkYXRlXG4gICAqIEB0eXBlIE51bWJlclxuICAgKi9cbiAgWUVBUjogMSxcbiAgLypcbiAgICogRW51bSBpbmRpY2F0aW5nIG1vbnRoIGZpZWxkIG9mIGRhdGVcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqL1xuICBNT05USDogMixcbiAgLypcbiAgICogRW51bSBpbmRpY2F0aW5nIHRoZSBkYXkgb2YgdGhlIG1vbnRoXG4gICAqIEB0eXBlIE51bWJlclxuICAgKi9cbiAgREFZX09GX01PTlRIOiAzLFxuICAvKlxuICAgKiBFbnVtIGluZGljYXRpbmcgdGhlIGhvdXIgKDI0KS5cbiAgICogQHR5cGUgTnVtYmVyXG4gICAqL1xuICBIT1VSX09GX0RBWTogNCxcbiAgLypcbiAgICogRW51bSBpbmRpY2F0aW5nIHRoZSBtaW51dGUgb2YgdGhlIGRheVxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICovXG4gIE1JTlVURVM6IDUsXG4gIC8qXG4gICAqIEVudW0gaW5kaWNhdGluZyB0aGUgc2Vjb25kIG9mIHRoZSBkYXlcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqL1xuICBTRUNPTkRTOiA2LFxuICAvKlxuICAgKiBFbnVtIGluZGljYXRpbmcgdGhlIG1pbGxpc2Vjb25kIG9mIHRoZSBkYXlcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqL1xuICBNSUxMSVNFQ09ORFM6IDcsXG4gIC8qXG4gICAqIEVudW0gaW5kaWNhdGluZyB0aGUgd2VlayBudW1iZXIgd2l0aGluIHRoZSBjdXJyZW50IHllYXJcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqL1xuICBXRUVLX09GX1lFQVI6IDgsXG4gIC8qXG4gICAqIEVudW0gaW5kaWNhdGluZyB0aGUgd2VlayBudW1iZXIgd2l0aGluIHRoZSBjdXJyZW50IG1vbnRoXG4gICAqIEB0eXBlIE51bWJlclxuICAgKi9cbiAgV0VFS19PRl9NT05USDogOSxcblxuICAvKlxuICAgKiBFbnVtIGluZGljYXRpbmcgdGhlIGRheSBvZiB0aGUgZGF5IG51bWJlciB3aXRoaW4gdGhlIGN1cnJlbnQgeWVhclxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICovXG4gIERBWV9PRl9ZRUFSOiAxMCxcbiAgLypcbiAgICogRW51bSBpbmRpY2F0aW5nIHRoZSBkYXkgb2YgdGhlIHdlZWtcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqL1xuICBEQVlfT0ZfV0VFSzogMTEsXG4gIC8qXG4gICAqIEVudW0gaW5kaWNhdGluZyB0aGUgZGF5IG9mIHRoZSBvcmRpbmFsIG51bWJlciBvZiB0aGUgZGF5IG9mIHRoZSB3ZWVrXG4gICAqIEB0eXBlIE51bWJlclxuICAgKi9cbiAgREFZX09GX1dFRUtfSU5fTU9OVEg6IDEyLFxuXG4gIC8qXG4gICAqIEVudW0gaW5kaWNhdGluZyBhbVxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICovXG4gIEFNOiAwLFxuICAvKlxuICAgKiBFbnVtIGluZGljYXRpbmcgcG1cbiAgICogQHR5cGUgTnVtYmVyXG4gICAqL1xuICBQTTogMVxufSk7XG5cbnZhciBGSUVMRFMgPSBbJycsICdZZWFyJywgJ01vbnRoJywgJ0RheU9mTW9udGgnLCAnSG91ck9mRGF5JywgJ01pbnV0ZXMnLCAnU2Vjb25kcycsICdNaWxsaXNlY29uZHMnLCAnV2Vla09mWWVhcicsICdXZWVrT2ZNb250aCcsICdEYXlPZlllYXInLCAnRGF5T2ZXZWVrJywgJ0RheU9mV2Vla0luTW9udGgnXTtcblxudmFyIFlFQVIgPSBHcmVnb3JpYW5DYWxlbmRhci5ZRUFSO1xudmFyIE1PTlRIID0gR3JlZ29yaWFuQ2FsZW5kYXIuTU9OVEg7XG52YXIgREFZX09GX01PTlRIID0gR3JlZ29yaWFuQ2FsZW5kYXIuREFZX09GX01PTlRIO1xudmFyIEhPVVJfT0ZfREFZID0gR3JlZ29yaWFuQ2FsZW5kYXIuSE9VUl9PRl9EQVk7XG52YXIgTUlOVVRFID0gR3JlZ29yaWFuQ2FsZW5kYXIuTUlOVVRFUztcbnZhciBTRUNPTkRTID0gR3JlZ29yaWFuQ2FsZW5kYXIuU0VDT05EUztcblxudmFyIE1JTExJU0VDT05EUyA9IEdyZWdvcmlhbkNhbGVuZGFyLk1JTExJU0VDT05EUztcbnZhciBEQVlfT0ZfV0VFS19JTl9NT05USCA9IEdyZWdvcmlhbkNhbGVuZGFyLkRBWV9PRl9XRUVLX0lOX01PTlRIO1xudmFyIERBWV9PRl9ZRUFSID0gR3JlZ29yaWFuQ2FsZW5kYXIuREFZX09GX1lFQVI7XG52YXIgREFZX09GX1dFRUsgPSBHcmVnb3JpYW5DYWxlbmRhci5EQVlfT0ZfV0VFSztcblxudmFyIFdFRUtfT0ZfTU9OVEggPSBHcmVnb3JpYW5DYWxlbmRhci5XRUVLX09GX01PTlRIO1xudmFyIFdFRUtfT0ZfWUVBUiA9IEdyZWdvcmlhbkNhbGVuZGFyLldFRUtfT0ZfWUVBUjtcblxudmFyIE1PTlRIX0xFTkdUSCA9IFszMSwgMjgsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXTsgLy8gMC1iYXNlZFxudmFyIExFQVBfTU9OVEhfTEVOR1RIID0gWzMxLCAyOSwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdOyAvLyAwLWJhc2VkXG5cbnZhciBPTkVfU0VDT05EID0gMTAwMDtcbnZhciBPTkVfTUlOVVRFID0gNjAgKiBPTkVfU0VDT05EO1xudmFyIE9ORV9IT1VSID0gNjAgKiBPTkVfTUlOVVRFO1xudmFyIE9ORV9EQVkgPSAyNCAqIE9ORV9IT1VSO1xudmFyIE9ORV9XRUVLID0gT05FX0RBWSAqIDc7XG5cbnZhciBFUE9DSF9PRkZTRVQgPSA3MTkxNjM7IC8vIEZpeGVkIGRhdGUgb2YgSmFudWFyeSAxLCAxOTcwIChHcmVnb3JpYW4pXG5cbnZhciBtb2QgPSBVdGlscy5tb2Q7XG52YXIgX2lzTGVhcFllYXIgPSBVdGlscy5pc0xlYXBZZWFyO1xudmFyIGZsb29yRGl2aWRlID0gTWF0aC5mbG9vcjtcblxudmFyIE1JTl9WQUxVRVMgPSBbdW5kZWZpbmVkLCAxLCAvLyBZRUFSXG5HcmVnb3JpYW5DYWxlbmRhci5KQU5VQVJZLCAvLyBNT05USFxuMSwgLy8gREFZX09GX01PTlRIXG4wLCAvLyBIT1VSX09GX0RBWVxuMCwgLy8gTUlOVVRFXG4wLCAvLyBTRUNPTkRTXG4wLCAvLyBNSUxMSVNFQ09ORFNcblxuMSwgLy8gV0VFS19PRl9ZRUFSXG51bmRlZmluZWQsIC8vIFdFRUtfT0ZfTU9OVEhcblxuMSwgLy8gREFZX09GX1lFQVJcbkdyZWdvcmlhbkNhbGVuZGFyLlNVTkRBWSwgLy8gREFZX09GX1dFRUtcbjFdO1xuXG4vLyBEQVlfT0ZfV0VFS19JTl9NT05USFxudmFyIE1BWF9WQUxVRVMgPSBbdW5kZWZpbmVkLCAyOTIyNzg5OTQsIC8vIFlFQVJcbkdyZWdvcmlhbkNhbGVuZGFyLkRFQ0VNQkVSLCAvLyBNT05USFxudW5kZWZpbmVkLCAvLyBEQVlfT0ZfTU9OVEhcbjIzLCAvLyBIT1VSX09GX0RBWVxuNTksIC8vIE1JTlVURVxuNTksIC8vIFNFQ09ORFNcbjk5OSwgLy8gTUlMTElTRUNPTkRTXG51bmRlZmluZWQsIC8vIFdFRUtfT0ZfWUVBUlxudW5kZWZpbmVkLCAvLyBXRUVLX09GX01PTlRIXG51bmRlZmluZWQsIC8vIERBWV9PRl9ZRUFSXG5HcmVnb3JpYW5DYWxlbmRhci5TQVRVUkRBWSwgLy8gREFZX09GX1dFRUtcbnVuZGVmaW5lZF07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0gcHJpdmF0ZSBzdGFydFxuXG4vLyBEQVlfT0ZfV0VFS19JTl9NT05USFxuZnVuY3Rpb24gZ2V0TW9udGhMZW5ndGgoeWVhciwgbW9udGgpIHtcbiAgcmV0dXJuIF9pc0xlYXBZZWFyKHllYXIpID8gTEVBUF9NT05USF9MRU5HVEhbbW9udGhdIDogTU9OVEhfTEVOR1RIW21vbnRoXTtcbn1cblxuZnVuY3Rpb24gZ2V0WWVhckxlbmd0aCh5ZWFyKSB7XG4gIHJldHVybiBfaXNMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NTtcbn1cblxuZnVuY3Rpb24gYWRqdXN0RGF5T2ZNb250aChzZWxmKSB7XG4gIHZhciBmaWVsZHMgPSBzZWxmLmZpZWxkcztcbiAgdmFyIHllYXIgPSBmaWVsZHNbWUVBUl07XG4gIHZhciBtb250aCA9IGZpZWxkc1tNT05USF07XG4gIHZhciBtb250aExlbiA9IGdldE1vbnRoTGVuZ3RoKHllYXIsIG1vbnRoKTtcbiAgdmFyIGRheU9mTW9udGggPSBmaWVsZHNbREFZX09GX01PTlRIXTtcbiAgaWYgKGRheU9mTW9udGggPiBtb250aExlbikge1xuICAgIHNlbGYuc2V0KERBWV9PRl9NT05USCwgbW9udGhMZW4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERheU9mV2Vla0RhdGVPbk9yQmVmb3JlKGZpeGVkRGF0ZSwgZGF5T2ZXZWVrKSB7XG4gIC8vIDEuMS4xIGlzIG1vbmRheVxuICAvLyBvbmUgd2VlayBoYXMgNyBkYXlzXG4gIHJldHVybiBmaXhlZERhdGUgLSBtb2QoZml4ZWREYXRlIC0gZGF5T2ZXZWVrLCA3KTtcbn1cblxuZnVuY3Rpb24gZ2V0V2Vla051bWJlcihzZWxmLCBmaXhlZERheTEsIGZpeGVkRGF0ZSkge1xuICB2YXIgZml4ZWREYXkxc3QgPSBnZXREYXlPZldlZWtEYXRlT25PckJlZm9yZShmaXhlZERheTEgKyA2LCBzZWxmLmZpcnN0RGF5T2ZXZWVrKTtcbiAgdmFyIG5EYXlzID0gZml4ZWREYXkxc3QgLSBmaXhlZERheTE7XG4gIGlmIChuRGF5cyA+PSBzZWxmLm1pbmltYWxEYXlzSW5GaXJzdFdlZWspIHtcbiAgICBmaXhlZERheTFzdCAtPSA3O1xuICB9XG4gIHZhciBub3JtYWxpemVkRGF5T2ZQZXJpb2QgPSBmaXhlZERhdGUgLSBmaXhlZERheTFzdDtcbiAgcmV0dXJuIGZsb29yRGl2aWRlKG5vcm1hbGl6ZWREYXlPZlBlcmlvZCAvIDcpICsgMTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLSBwcml2YXRlIGVuZFxuXG5HcmVnb3JpYW5DYWxlbmRhci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBHcmVnb3JpYW5DYWxlbmRhcixcblxuICBpc0dyZWdvcmlhbkNhbGVuZGFyOiAxLFxuXG4gIC8qXG4gICAqIERldGVybWluZXMgaWYgY3VycmVudCB5ZWFyIGlzIGEgbGVhcCB5ZWFyLlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHllYXIgaXMgYSBsZWFwIHllYXIuIFRvIHNwZWNpZnkgQkMgeWVhciBudW1iZXJzLFxuICAgKiAxIC0geWVhciBudW1iZXIgbXVzdCBiZSBnaXZlbi4gRm9yIGV4YW1wbGUsIHllYXIgQkMgNCBpcyBzcGVjaWZpZWQgYXMgLTMuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoZSBnaXZlbiB5ZWFyIGlzIGEgbGVhcCB5ZWFyOyBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlciBEYXRlLkdyZWdvcmlhblxuICAgKi9cbiAgaXNMZWFwWWVhcjogZnVuY3Rpb24gaXNMZWFwWWVhcigpIHtcbiAgICByZXR1cm4gX2lzTGVhcFllYXIodGhpcy5nZXRZZWFyKCkpO1xuICB9LFxuXG4gIC8qXG4gICAqIFJldHVybiBsb2NhbCBpbmZvIGZvciBjdXJyZW50IGRhdGUgaW5zdGFuY2VcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIGdldExvY2FsZTogZnVuY3Rpb24gZ2V0TG9jYWxlKCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsZTtcbiAgfSxcblxuICAvKlxuICAgKiBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlIGZvclxuICAgKiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQgb2YgdGhpcyBHcmVnb3JpYW5DYWxlbmRhciBpbnN0YW5jZS5cbiAgICogVGhlIG1pbmltdW0gdmFsdWUgaXMgZGVmaW5lZCBhcyB0aGUgc21hbGxlc3QgdmFsdWVcbiAgICogcmV0dXJuZWQgYnkgdGhlIGdldCBtZXRob2QgZm9yIGFueSBwb3NzaWJsZSB0aW1lIHZhbHVlLFxuICAgKiB0YWtpbmcgaW50byBjb25zaWRlcmF0aW9uIHRoZSBjdXJyZW50IHZhbHVlcyBvZiB0aGUgZ2V0Rmlyc3REYXlPZldlZWssXG4gICAqIGdldE1pbmltYWxEYXlzSW5GaXJzdFdlZWsuXG4gICAqIEBwYXJhbSBmaWVsZCB0aGUgY2FsZW5kYXIgZmllbGQuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBtaW5pbXVtIHZhbHVlIGZvciB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqL1xuICBnZXRBY3R1YWxNaW5pbXVtOiBmdW5jdGlvbiBnZXRBY3R1YWxNaW5pbXVtKGZpZWxkKSB7XG4gICAgaWYgKE1JTl9WQUxVRVNbZmllbGRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBNSU5fVkFMVUVTW2ZpZWxkXTtcbiAgICB9XG4gICAgaWYgKGZpZWxkID09PSBXRUVLX09GX01PTlRIKSB7XG4gICAgICB2YXIgY2FsID0gdGhpcy5jbG9uZSgpO1xuICAgICAgY2FsLmNsZWFyKCk7XG4gICAgICBjYWwuc2V0KHRoaXMuZmllbGRzW1lFQVJdLCB0aGlzLmZpZWxkc1tNT05USF0sIDEpO1xuICAgICAgcmV0dXJuIGNhbC5nZXQoV0VFS19PRl9NT05USCk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdtaW5pbXVtIHZhbHVlIG5vdCBkZWZpbmVkIScpO1xuICB9LFxuXG4gIC8qXG4gICAqIFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUgZm9yIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZFxuICAgKiBvZiB0aGlzIEdyZWdvcmlhbkNhbGVuZGFyIGluc3RhbmNlLlxuICAgKiBUaGUgbWF4aW11bSB2YWx1ZSBpcyBkZWZpbmVkIGFzIHRoZSBsYXJnZXN0IHZhbHVlIHJldHVybmVkXG4gICAqIGJ5IHRoZSBnZXQgbWV0aG9kIGZvciBhbnkgcG9zc2libGUgdGltZSB2YWx1ZSwgdGFraW5nIGludG8gY29uc2lkZXJhdGlvblxuICAgKiB0aGUgY3VycmVudCB2YWx1ZXMgb2YgdGhlIGdldEZpcnN0RGF5T2ZXZWVrLCBnZXRNaW5pbWFsRGF5c0luRmlyc3RXZWVrIG1ldGhvZHMuXG4gICAqIEBwYXJhbSBmaWVsZCB0aGUgY2FsZW5kYXIgZmllbGQuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBtYXhpbXVtIHZhbHVlIGZvciB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqL1xuICBnZXRBY3R1YWxNYXhpbXVtOiBmdW5jdGlvbiBnZXRBY3R1YWxNYXhpbXVtKGZpZWxkKSB7XG4gICAgaWYgKE1BWF9WQUxVRVNbZmllbGRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBNQVhfVkFMVUVTW2ZpZWxkXTtcbiAgICB9XG4gICAgdmFyIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHZhciBmaWVsZHMgPSB0aGlzLmZpZWxkcztcbiAgICBzd2l0Y2ggKGZpZWxkKSB7XG4gICAgICBjYXNlIERBWV9PRl9NT05USDpcbiAgICAgICAgdmFsdWUgPSBnZXRNb250aExlbmd0aChmaWVsZHNbWUVBUl0sIGZpZWxkc1tNT05USF0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBXRUVLX09GX1lFQVI6XG4gICAgICAgIHZhciBlbmRPZlllYXIgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIGVuZE9mWWVhci5jbGVhcigpO1xuICAgICAgICBlbmRPZlllYXIuc2V0KGZpZWxkc1tZRUFSXSwgR3JlZ29yaWFuQ2FsZW5kYXIuREVDRU1CRVIsIDMxKTtcbiAgICAgICAgdmFsdWUgPSBlbmRPZlllYXIuZ2V0KFdFRUtfT0ZfWUVBUik7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gMSkge1xuICAgICAgICAgIHZhbHVlID0gNTI7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgV0VFS19PRl9NT05USDpcbiAgICAgICAgdmFyIGVuZE9mTW9udGggPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIGVuZE9mTW9udGguY2xlYXIoKTtcbiAgICAgICAgZW5kT2ZNb250aC5zZXQoZmllbGRzW1lFQVJdLCBmaWVsZHNbTU9OVEhdLCBnZXRNb250aExlbmd0aChmaWVsZHNbWUVBUl0sIGZpZWxkc1tNT05USF0pKTtcbiAgICAgICAgdmFsdWUgPSBlbmRPZk1vbnRoLmdldChXRUVLX09GX01PTlRIKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgREFZX09GX1lFQVI6XG4gICAgICAgIHZhbHVlID0gZ2V0WWVhckxlbmd0aChmaWVsZHNbWUVBUl0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBEQVlfT0ZfV0VFS19JTl9NT05USDpcbiAgICAgICAgdmFsdWUgPSB0b0ludCgoZ2V0TW9udGhMZW5ndGgoZmllbGRzW1lFQVJdLCBmaWVsZHNbTU9OVEhdKSAtIDEpIC8gNykgKyAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXhpbXVtIHZhbHVlIG5vdCBkZWZpbmVkIScpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG5cbiAgLypcbiAgICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQgaGFzIGEgdmFsdWUgc2V0LFxuICAgKiBpbmNsdWRpbmcgY2FzZXMgdGhhdCB0aGUgdmFsdWUgaGFzIGJlZW4gc2V0IGJ5IGludGVybmFsIGZpZWxkcyBjYWxjdWxhdGlvbnNcbiAgICogdHJpZ2dlcmVkIGJ5IGEgZ2V0IG1ldGhvZCBjYWxsLlxuICAgKiBAcGFyYW0gZmllbGQgdGhlIGNhbGVuZGFyIGZpZWxkIHRvIGJlIGNsZWFyZWQuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZCBoYXMgYSB2YWx1ZSBzZXQ7IGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzU2V0OiBmdW5jdGlvbiBpc1NldChmaWVsZCkge1xuICAgIHJldHVybiB0aGlzLmZpZWxkc1tmaWVsZF0gIT09IHVuZGVmaW5lZDtcbiAgfSxcblxuICAvKlxuICAgKiBDb252ZXJ0cyB0aGUgdGltZSB2YWx1ZSAobWlsbGlzZWNvbmQgb2Zmc2V0IGZyb20gdGhlIEVwb2NoKVxuICAgKiB0byBjYWxlbmRhciBmaWVsZCB2YWx1ZXMuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGNvbXB1dGVGaWVsZHM6IGZ1bmN0aW9uIGNvbXB1dGVGaWVsZHMoKSB7XG4gICAgdmFyIHRpbWUgPSB0aGlzLnRpbWU7XG4gICAgdmFyIHRpbWV6b25lT2Zmc2V0ID0gdGhpcy50aW1lem9uZU9mZnNldCAqIE9ORV9NSU5VVEU7XG4gICAgdmFyIGZpeGVkRGF0ZSA9IHRvSW50KHRpbWV6b25lT2Zmc2V0IC8gT05FX0RBWSk7XG4gICAgdmFyIHRpbWVPZkRheSA9IHRpbWV6b25lT2Zmc2V0ICUgT05FX0RBWTtcbiAgICBmaXhlZERhdGUgKz0gdG9JbnQodGltZSAvIE9ORV9EQVkpO1xuICAgIHRpbWVPZkRheSArPSB0aW1lICUgT05FX0RBWTtcbiAgICBpZiAodGltZU9mRGF5ID49IE9ORV9EQVkpIHtcbiAgICAgIHRpbWVPZkRheSAtPSBPTkVfREFZO1xuICAgICAgZml4ZWREYXRlKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlICh0aW1lT2ZEYXkgPCAwKSB7XG4gICAgICAgIHRpbWVPZkRheSArPSBPTkVfREFZO1xuICAgICAgICBmaXhlZERhdGUtLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmaXhlZERhdGUgKz0gRVBPQ0hfT0ZGU0VUO1xuXG4gICAgdmFyIGRhdGUgPSBVdGlscy5nZXRHcmVnb3JpYW5EYXRlRnJvbUZpeGVkRGF0ZShmaXhlZERhdGUpO1xuXG4gICAgdmFyIHllYXIgPSBkYXRlLnllYXI7XG5cbiAgICB2YXIgZmllbGRzID0gdGhpcy5maWVsZHM7XG4gICAgZmllbGRzW1lFQVJdID0geWVhcjtcbiAgICBmaWVsZHNbTU9OVEhdID0gZGF0ZS5tb250aDtcbiAgICBmaWVsZHNbREFZX09GX01PTlRIXSA9IGRhdGUuZGF5T2ZNb250aDtcbiAgICBmaWVsZHNbREFZX09GX1dFRUtdID0gZGF0ZS5kYXlPZldlZWs7XG5cbiAgICBpZiAodGltZU9mRGF5ICE9PSAwKSB7XG4gICAgICBmaWVsZHNbSE9VUl9PRl9EQVldID0gdG9JbnQodGltZU9mRGF5IC8gT05FX0hPVVIpO1xuICAgICAgdmFyIHIgPSB0aW1lT2ZEYXkgJSBPTkVfSE9VUjtcbiAgICAgIGZpZWxkc1tNSU5VVEVdID0gdG9JbnQociAvIE9ORV9NSU5VVEUpO1xuICAgICAgciAlPSBPTkVfTUlOVVRFO1xuICAgICAgZmllbGRzW1NFQ09ORFNdID0gdG9JbnQociAvIE9ORV9TRUNPTkQpO1xuICAgICAgZmllbGRzW01JTExJU0VDT05EU10gPSByICUgT05FX1NFQ09ORDtcbiAgICB9IGVsc2Uge1xuICAgICAgZmllbGRzW0hPVVJfT0ZfREFZXSA9IGZpZWxkc1tNSU5VVEVdID0gZmllbGRzW1NFQ09ORFNdID0gZmllbGRzW01JTExJU0VDT05EU10gPSAwO1xuICAgIH1cblxuICAgIHZhciBmaXhlZERhdGVKYW4xID0gVXRpbHMuZ2V0Rml4ZWREYXRlKHllYXIsIEdyZWdvcmlhbkNhbGVuZGFyLkpBTlVBUlksIDEpO1xuICAgIHZhciBkYXlPZlllYXIgPSBmaXhlZERhdGUgLSBmaXhlZERhdGVKYW4xICsgMTtcbiAgICB2YXIgZml4RGF0ZU1vbnRoMSA9IGZpeGVkRGF0ZSAtIGRhdGUuZGF5T2ZNb250aCArIDE7XG5cbiAgICBmaWVsZHNbREFZX09GX1lFQVJdID0gZGF5T2ZZZWFyO1xuICAgIGZpZWxkc1tEQVlfT0ZfV0VFS19JTl9NT05USF0gPSB0b0ludCgoZGF0ZS5kYXlPZk1vbnRoIC0gMSkgLyA3KSArIDE7XG5cbiAgICB2YXIgd2Vla09mWWVhciA9IGdldFdlZWtOdW1iZXIodGhpcywgZml4ZWREYXRlSmFuMSwgZml4ZWREYXRlKTtcblxuICAgIC8vIOacrOWRqOayoeaciei2s+Wkn+eahOaXtumXtOWcqOW9k+WJjeW5tFxuICAgIGlmICh3ZWVrT2ZZZWFyID09PSAwKSB7XG4gICAgICAvLyBJZiB0aGUgZGF0ZSBiZWxvbmdzIHRvIHRoZSBsYXN0IHdlZWsgb2YgdGhlXG4gICAgICAvLyBwcmV2aW91cyB5ZWFyLCB1c2UgdGhlIHdlZWsgbnVtYmVyIG9mIFwiMTIvMzFcIiBvZlxuICAgICAgLy8gdGhlIFwicHJldmlvdXNcIiB5ZWFyLlxuICAgICAgdmFyIGZpeGVkRGVjMzEgPSBmaXhlZERhdGVKYW4xIC0gMTtcbiAgICAgIHZhciBwcmV2SmFuMSA9IGZpeGVkRGF0ZUphbjEgLSBnZXRZZWFyTGVuZ3RoKHllYXIgLSAxKTtcbiAgICAgIHdlZWtPZlllYXIgPSBnZXRXZWVrTnVtYmVyKHRoaXMsIHByZXZKYW4xLCBmaXhlZERlYzMxKTtcbiAgICB9IGVsc2VcbiAgICAgIC8vIOacrOWRqOaYr+W5tOacq+acgOWQjuS4gOWRqO+8jOWPr+iDveaciei2s+Wkn+eahOaXtumXtOWcqOaWsOeahOS4gOW5tFxuICAgICAgaWYgKHdlZWtPZlllYXIgPj0gNTIpIHtcbiAgICAgICAgdmFyIG5leHRKYW4xID0gZml4ZWREYXRlSmFuMSArIGdldFllYXJMZW5ndGgoeWVhcik7XG4gICAgICAgIHZhciBuZXh0SmFuMXN0ID0gZ2V0RGF5T2ZXZWVrRGF0ZU9uT3JCZWZvcmUobmV4dEphbjEgKyA2LCB0aGlzLmZpcnN0RGF5T2ZXZWVrKTtcbiAgICAgICAgdmFyIG5EYXlzID0gbmV4dEphbjFzdCAtIG5leHRKYW4xO1xuICAgICAgICAvLyDmnKzlkajmnInotrPlpJ/lpKnmlbDlnKjmlrDnmoTkuIDlubRcbiAgICAgICAgaWYgKG5EYXlzID49IHRoaXMubWluaW1hbERheXNJbkZpcnN0V2VlayAmJlxuICAgICAgICAvLyDlvZPlpKnnoa7lrp7lnKjmnKzlkajvvIx3ZWVrT2ZZZWFyID09PSA1MyDml7bmmK/kuI3pnIDopoHov5nkuKrliKTmlq1cbiAgICAgICAgZml4ZWREYXRlID49IG5leHRKYW4xc3QgLSA3KSB7XG4gICAgICAgICAgd2Vla09mWWVhciA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIGZpZWxkc1tXRUVLX09GX1lFQVJdID0gd2Vla09mWWVhcjtcbiAgICBmaWVsZHNbV0VFS19PRl9NT05USF0gPSBnZXRXZWVrTnVtYmVyKHRoaXMsIGZpeERhdGVNb250aDEsIGZpeGVkRGF0ZSk7XG5cbiAgICB0aGlzLmZpZWxkc0NvbXB1dGVkID0gdHJ1ZTtcbiAgfSxcblxuICAvKlxuICAgKiBDb252ZXJ0cyBjYWxlbmRhciBmaWVsZCB2YWx1ZXMgdG8gdGhlIHRpbWUgdmFsdWVcbiAgICogKG1pbGxpc2Vjb25kIG9mZnNldCBmcm9tIHRoZSBFcG9jaCkuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGNvbXB1dGVUaW1lOiBmdW5jdGlvbiBjb21wdXRlVGltZSgpIHtcbiAgICB2YXIgeWVhciA9IHVuZGVmaW5lZDtcbiAgICB2YXIgZmllbGRzID0gdGhpcy5maWVsZHM7XG4gICAgaWYgKHRoaXMuaXNTZXQoWUVBUikpIHtcbiAgICAgIHllYXIgPSBmaWVsZHNbWUVBUl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHllYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG4gICAgfVxuICAgIHZhciB0aW1lT2ZEYXkgPSAwO1xuICAgIGlmICh0aGlzLmlzU2V0KEhPVVJfT0ZfREFZKSkge1xuICAgICAgdGltZU9mRGF5ICs9IGZpZWxkc1tIT1VSX09GX0RBWV07XG4gICAgfVxuICAgIHRpbWVPZkRheSAqPSA2MDtcbiAgICB0aW1lT2ZEYXkgKz0gZmllbGRzW01JTlVURV0gfHwgMDtcbiAgICB0aW1lT2ZEYXkgKj0gNjA7XG4gICAgdGltZU9mRGF5ICs9IGZpZWxkc1tTRUNPTkRTXSB8fCAwO1xuICAgIHRpbWVPZkRheSAqPSAxMDAwO1xuICAgIHRpbWVPZkRheSArPSBmaWVsZHNbTUlMTElTRUNPTkRTXSB8fCAwO1xuICAgIHZhciBmaXhlZERhdGUgPSAwO1xuICAgIGZpZWxkc1tZRUFSXSA9IHllYXI7XG4gICAgZml4ZWREYXRlID0gZml4ZWREYXRlICsgdGhpcy5nZXRGaXhlZERhdGUoKTtcbiAgICAvLyBtaWxsaXMgcmVwcmVzZW50cyBsb2NhbCB3YWxsLWNsb2NrIHRpbWUgaW4gbWlsbGlzZWNvbmRzLlxuICAgIHZhciBtaWxsaXMgPSAoZml4ZWREYXRlIC0gRVBPQ0hfT0ZGU0VUKSAqIE9ORV9EQVkgKyB0aW1lT2ZEYXk7XG4gICAgbWlsbGlzIC09IHRoaXMudGltZXpvbmVPZmZzZXQgKiBPTkVfTUlOVVRFO1xuICAgIHRoaXMudGltZSA9IG1pbGxpcztcbiAgICB0aGlzLmNvbXB1dGVGaWVsZHMoKTtcbiAgfSxcblxuICAvKlxuICAgKiBGaWxscyBpbiBhbnkgdW5zZXQgZmllbGRzIGluIHRoZSBjYWxlbmRhciBmaWVsZHMuIEZpcnN0LFxuICAgKiB0aGUgY29tcHV0ZVRpbWUoKSBtZXRob2QgaXMgY2FsbGVkIGlmIHRoZSB0aW1lIHZhbHVlIChtaWxsaXNlY29uZCBvZmZzZXQgZnJvbSB0aGUgRXBvY2gpXG4gICAqIGhhcyBub3QgYmVlbiBjYWxjdWxhdGVkIGZyb20gY2FsZW5kYXIgZmllbGQgdmFsdWVzLlxuICAgKiBUaGVuLCB0aGUgY29tcHV0ZUZpZWxkcygpIG1ldGhvZCBpcyBjYWxsZWQgdG8gY2FsY3VsYXRlIGFsbCBjYWxlbmRhciBmaWVsZCB2YWx1ZXMuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICBpZiAodGhpcy50aW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuY29tcHV0ZVRpbWUoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmZpZWxkc0NvbXB1dGVkKSB7XG4gICAgICB0aGlzLmNvbXB1dGVGaWVsZHMoKTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0Rml4ZWREYXRlOiBmdW5jdGlvbiBnZXRGaXhlZERhdGUoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIGZpZWxkcyA9IHNlbGYuZmllbGRzO1xuXG4gICAgdmFyIGZpcnN0RGF5T2ZXZWVrQ2ZnID0gc2VsZi5maXJzdERheU9mV2VlaztcblxuICAgIHZhciB5ZWFyID0gZmllbGRzW1lFQVJdO1xuXG4gICAgdmFyIG1vbnRoID0gR3JlZ29yaWFuQ2FsZW5kYXIuSkFOVUFSWTtcblxuICAgIGlmIChzZWxmLmlzU2V0KE1PTlRIKSkge1xuICAgICAgbW9udGggPSBmaWVsZHNbTU9OVEhdO1xuICAgICAgaWYgKG1vbnRoID4gR3JlZ29yaWFuQ2FsZW5kYXIuREVDRU1CRVIpIHtcbiAgICAgICAgeWVhciArPSB0b0ludChtb250aCAvIDEyKTtcbiAgICAgICAgbW9udGggJT0gMTI7XG4gICAgICB9IGVsc2UgaWYgKG1vbnRoIDwgR3JlZ29yaWFuQ2FsZW5kYXIuSkFOVUFSWSkge1xuICAgICAgICB5ZWFyICs9IGZsb29yRGl2aWRlKG1vbnRoIC8gMTIpO1xuICAgICAgICBtb250aCA9IG1vZChtb250aCwgMTIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEdldCB0aGUgZml4ZWQgZGF0ZSBzaW5jZSBKYW4gMSwgMSAoR3JlZ29yaWFuKS4gV2UgYXJlIG9uXG4gICAgLy8gdGhlIGZpcnN0IGRheSBvZiBlaXRoZXIgYG1vbnRoJyBvciBKYW51YXJ5IGluICd5ZWFyJy5cbiAgICB2YXIgZml4ZWREYXRlID0gVXRpbHMuZ2V0Rml4ZWREYXRlKHllYXIsIG1vbnRoLCAxKTtcbiAgICB2YXIgZmlyc3REYXlPZldlZWsgPSB1bmRlZmluZWQ7XG4gICAgdmFyIGRheU9mV2VlayA9IHNlbGYuZmlyc3REYXlPZldlZWs7XG5cbiAgICBpZiAoc2VsZi5pc1NldChEQVlfT0ZfV0VFSykpIHtcbiAgICAgIGRheU9mV2VlayA9IGZpZWxkc1tEQVlfT0ZfV0VFS107XG4gICAgfVxuXG4gICAgaWYgKHNlbGYuaXNTZXQoTU9OVEgpKSB7XG4gICAgICBpZiAoc2VsZi5pc1NldChEQVlfT0ZfTU9OVEgpKSB7XG4gICAgICAgIGZpeGVkRGF0ZSArPSBmaWVsZHNbREFZX09GX01PTlRIXSAtIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc2VsZi5pc1NldChXRUVLX09GX01PTlRIKSkge1xuICAgICAgICAgIGZpcnN0RGF5T2ZXZWVrID0gZ2V0RGF5T2ZXZWVrRGF0ZU9uT3JCZWZvcmUoZml4ZWREYXRlICsgNiwgZmlyc3REYXlPZldlZWtDZmcpO1xuXG4gICAgICAgICAgLy8gSWYgd2UgaGF2ZSBlbm91Z2ggZGF5cyBpbiB0aGUgZmlyc3Qgd2VlaywgdGhlblxuICAgICAgICAgIC8vIG1vdmUgdG8gdGhlIHByZXZpb3VzIHdlZWsuXG4gICAgICAgICAgaWYgKGZpcnN0RGF5T2ZXZWVrIC0gZml4ZWREYXRlID49IHNlbGYubWluaW1hbERheXNJbkZpcnN0V2Vlaykge1xuICAgICAgICAgICAgZmlyc3REYXlPZldlZWsgLT0gNztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZGF5T2ZXZWVrICE9PSBmaXJzdERheU9mV2Vla0NmZykge1xuICAgICAgICAgICAgZmlyc3REYXlPZldlZWsgPSBnZXREYXlPZldlZWtEYXRlT25PckJlZm9yZShmaXJzdERheU9mV2VlayArIDYsIGRheU9mV2Vlayk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZml4ZWREYXRlID0gZmlyc3REYXlPZldlZWsgKyA3ICogKGZpZWxkc1tXRUVLX09GX01PTlRIXSAtIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBkb3dpbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAoc2VsZi5pc1NldChEQVlfT0ZfV0VFS19JTl9NT05USCkpIHtcbiAgICAgICAgICAgIGRvd2ltID0gZmllbGRzW0RBWV9PRl9XRUVLX0lOX01PTlRIXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG93aW0gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbGFzdERhdGUgPSA3ICogZG93aW07XG4gICAgICAgICAgaWYgKGRvd2ltIDwgMCkge1xuICAgICAgICAgICAgbGFzdERhdGUgPSBnZXRNb250aExlbmd0aCh5ZWFyLCBtb250aCkgKyA3ICogKGRvd2ltICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpeGVkRGF0ZSA9IGdldERheU9mV2Vla0RhdGVPbk9yQmVmb3JlKGZpeGVkRGF0ZSArIGxhc3REYXRlIC0gMSwgZGF5T2ZXZWVrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBhcmUgb24gdGhlIGZpcnN0IGRheSBvZiB0aGUgeWVhci5cbiAgICAgIGlmIChzZWxmLmlzU2V0KERBWV9PRl9ZRUFSKSkge1xuICAgICAgICBmaXhlZERhdGUgKz0gZmllbGRzW0RBWV9PRl9ZRUFSXSAtIDE7XG4gICAgICB9IGVsc2UgaWYgKHNlbGYuaXNTZXQoV0VFS19PRl9ZRUFSKSkge1xuICAgICAgICBmaXJzdERheU9mV2VlayA9IGdldERheU9mV2Vla0RhdGVPbk9yQmVmb3JlKGZpeGVkRGF0ZSArIDYsIGZpcnN0RGF5T2ZXZWVrQ2ZnKTtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBlbm91Z2ggZGF5cyBpbiB0aGUgZmlyc3Qgd2VlaywgdGhlbiBtb3ZlXG4gICAgICAgIC8vIHRvIHRoZSBwcmV2aW91cyB3ZWVrLlxuICAgICAgICBpZiAoZmlyc3REYXlPZldlZWsgLSBmaXhlZERhdGUgPj0gc2VsZi5taW5pbWFsRGF5c0luRmlyc3RXZWVrKSB7XG4gICAgICAgICAgZmlyc3REYXlPZldlZWsgLT0gNztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF5T2ZXZWVrICE9PSBmaXJzdERheU9mV2Vla0NmZykge1xuICAgICAgICAgIGZpcnN0RGF5T2ZXZWVrID0gZ2V0RGF5T2ZXZWVrRGF0ZU9uT3JCZWZvcmUoZmlyc3REYXlPZldlZWsgKyA2LCBkYXlPZldlZWspO1xuICAgICAgICB9XG4gICAgICAgIGZpeGVkRGF0ZSA9IGZpcnN0RGF5T2ZXZWVrICsgNyAqIChmaWVsZHNbV0VFS19PRl9ZRUFSXSAtIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmaXhlZERhdGU7XG4gIH0sXG5cbiAgLypcbiAgICogUmV0dXJucyB0aGlzIENhbGVuZGFyJ3MgdGltZSB2YWx1ZSBpbiBtaWxsaXNlY29uZHNcbiAgICogQG1lbWJlciBEYXRlLkdyZWdvcmlhblxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgY3VycmVudCB0aW1lIGFzIFVUQyBtaWxsaXNlY29uZHMgZnJvbSB0aGUgZXBvY2guXG4gICAqL1xuICBnZXRUaW1lOiBmdW5jdGlvbiBnZXRUaW1lKCkge1xuICAgIGlmICh0aGlzLnRpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5jb21wdXRlVGltZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50aW1lO1xuICB9LFxuXG4gIC8qXG4gICAqIFNldHMgdGhpcyBDYWxlbmRhcidzIGN1cnJlbnQgdGltZSBmcm9tIHRoZSBnaXZlbiBsb25nIHZhbHVlLlxuICAgKiBAcGFyYW0gdGltZSB0aGUgbmV3IHRpbWUgaW4gVVRDIG1pbGxpc2Vjb25kcyBmcm9tIHRoZSBlcG9jaC5cbiAgICovXG4gIHNldFRpbWU6IGZ1bmN0aW9uIHNldFRpbWUodGltZSkge1xuICAgIHRoaXMudGltZSA9IHRpbWU7XG4gICAgdGhpcy5maWVsZHNDb21wdXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuY29tcGxldGUoKTtcbiAgfSxcblxuICAvKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBwYXJhbSBmaWVsZCB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSB2YWx1ZSBmb3IgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKi9cbiAgZ2V0OiBmdW5jdGlvbiBnZXQoZmllbGQpIHtcbiAgICB0aGlzLmNvbXBsZXRlKCk7XG4gICAgcmV0dXJuIHRoaXMuZmllbGRzW2ZpZWxkXTtcbiAgfSxcblxuICAvKlxuICAgKiBSZXR1cm5zIHRoZSB5ZWFyIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBnZXRZZWFyXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSB5ZWFyIGZvciB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqL1xuXG4gIC8qXG4gICAqIFJldHVybnMgdGhlIG1vbnRoIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBnZXRNb250aFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgbW9udGggZm9yIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogUmV0dXJucyB0aGUgZGF5IG9mIG1vbnRoIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBnZXREYXlPZk1vbnRoXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBkYXkgb2YgbW9udGggZm9yIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogUmV0dXJucyB0aGUgaG91ciBvZiBkYXkgb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIGdldEhvdXJPZkRheVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgaG91ciBvZiBkYXkgZm9yIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogUmV0dXJucyB0aGUgbWludXRlIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBnZXRNaW51dGVcbiAgICogQHJldHVybnMge051bWJlcn0gdGhlIG1pbnV0ZSBmb3IgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKi9cblxuICAvKlxuICAgKiBSZXR1cm5zIHRoZSBzZWNvbmQgb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIGdldFNlY29uZFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgc2Vjb25kIGZvciB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqL1xuXG4gIC8qXG4gICAqIFJldHVybnMgdGhlIG1pbGxpc2Vjb25kIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBnZXRNaWxsaVNlY29uZFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgbWlsbGlzZWNvbmQgZm9yIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogUmV0dXJucyB0aGUgd2VlayBvZiB5ZWFyIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBnZXRXZWVrT2ZZZWFyXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSB3ZWVrIG9mIHllYXIgZm9yIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogUmV0dXJucyB0aGUgd2VlayBvZiBtb250aCBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2QgZ2V0V2Vla09mTW9udGhcbiAgICogQHJldHVybnMge051bWJlcn0gdGhlIHdlZWsgb2YgbW9udGggZm9yIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogUmV0dXJucyB0aGUgZGF5IG9mIHllYXIgb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIGdldERheU9mWWVhclxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgZGF5IG9mIHllYXIgZm9yIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogUmV0dXJucyB0aGUgZGF5IG9mIHdlZWsgb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIGdldERheU9mV2Vla1xuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgZGF5IG9mIHdlZWsgZm9yIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogUmV0dXJucyB0aGUgZGF5IG9mIHdlZWsgaW4gbW9udGggb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIGdldERheU9mV2Vla0luTW9udGhcbiAgICogQHJldHVybnMge051bWJlcn0gdGhlIGRheSBvZiB3ZWVrIGluIG1vbnRoIGZvciB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqL1xuXG4gIC8qXG4gICAqIFNldHMgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkIHRvIHRoZSBnaXZlbiB2YWx1ZS5cbiAgICogQHBhcmFtIGZpZWxkIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQHBhcmFtIHYgdGhlIHZhbHVlIHRvIGJlIHNldCBmb3IgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKi9cbiAgc2V0OiBmdW5jdGlvbiBzZXQoZmllbGQsIHYpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZiAobGVuID09PSAyKSB7XG4gICAgICB0aGlzLmZpZWxkc1tmaWVsZF0gPSB2O1xuICAgIH0gZWxzZSBpZiAobGVuIDwgTUlMTElTRUNPTkRTICsgMSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLmZpZWxkc1tZRUFSICsgaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaWxsZWdhbCBhcmd1bWVudHMgZm9yIEdyZWdvcmlhbkNhbGVuZGFyIHNldCcpO1xuICAgIH1cbiAgICB0aGlzLnRpbWUgPSB1bmRlZmluZWQ7XG4gIH0sXG5cbiAgLypcbiAgICogU2V0IHRoZSB5ZWFyIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBzZXRZZWFyXG4gICAqL1xuXG4gIC8qXG4gICAqIFNldCB0aGUgbW9udGggb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIHNldE1vbnRoXG4gICAqL1xuXG4gIC8qXG4gICAqIFNldCB0aGUgZGF5IG9mIG1vbnRoIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBzZXREYXlPZk1vbnRoXG4gICAqL1xuXG4gIC8qXG4gICAqIFNldCB0aGUgaG91ciBvZiBkYXkgb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIHNldEhvdXJPZkRheVxuICAgKi9cblxuICAvKlxuICAgKiBTZXQgdGhlIG1pbnV0ZSBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2Qgc2V0TWludXRlXG4gICAqL1xuXG4gIC8qXG4gICAqIFNldCB0aGUgc2Vjb25kIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBzZXRTZWNvbmRcbiAgICovXG5cbiAgLypcbiAgICogU2V0IHRoZSBtaWxsaXNlY29uZCBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2Qgc2V0TWlsbGlTZWNvbmRcbiAgICovXG5cbiAgLypcbiAgICogU2V0IHRoZSB3ZWVrIG9mIHllYXIgb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIHNldFdlZWtPZlllYXJcbiAgICovXG5cbiAgLypcbiAgICogU2V0IHRoZSB3ZWVrIG9mIG1vbnRoIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBzZXRXZWVrT2ZNb250aFxuICAgKi9cblxuICAvKlxuICAgKiBTZXQgdGhlIGRheSBvZiB5ZWFyIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBzZXREYXlPZlllYXJcbiAgICovXG5cbiAgLypcbiAgICogU2V0IHRoZSBkYXkgb2Ygd2VlayBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2Qgc2V0RGF5T2ZXZWVrXG4gICAqL1xuXG4gIC8qXG4gICAqIFNldCB0aGUgZGF5IG9mIHdlZWsgaW4gbW9udGggb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIHNldERheU9mV2Vla0luTW9udGhcbiAgICovXG5cbiAgLypcbiAgICogYWRkIGZvciBzcGVjaWZpZWQgZmllbGQgYmFzZWQgb24gdHdvIHJ1bGVzOlxuICAgKlxuICAgKiAgLSBBZGQgcnVsZSAxLiBUaGUgdmFsdWUgb2YgZmllbGQgYWZ0ZXIgdGhlIGNhbGwgbWludXMgdGhlIHZhbHVlIG9mIGZpZWxkIGJlZm9yZSB0aGVcbiAgICogIGNhbGwgaXMgYW1vdW50LCBtb2R1bG8gYW55IG92ZXJmbG93IHRoYXQgaGFzIG9jY3VycmVkIGluIGZpZWxkXG4gICAqICBPdmVyZmxvdyBvY2N1cnMgd2hlbiBhIGZpZWxkIHZhbHVlIGV4Y2VlZHMgaXRzIHJhbmdlIGFuZCxcbiAgICogIGFzIGEgcmVzdWx0LCB0aGUgbmV4dCBsYXJnZXIgZmllbGQgaXMgaW5jcmVtZW50ZWQgb3JcbiAgICogIGRlY3JlbWVudGVkIGFuZCB0aGUgZmllbGQgdmFsdWUgaXMgYWRqdXN0ZWQgYmFjayBpbnRvIGl0cyByYW5nZS5cbiAgICpcbiAgICogIC0gQWRkIHJ1bGUgMi4gSWYgYSBzbWFsbGVyIGZpZWxkIGlzIGV4cGVjdGVkIHRvIGJlIGludmFyaWFudCxcbiAgICogIGJ1dCBpdCBpcyBpbXBvc3NpYmxlIGZvciBpdCB0byBiZSBlcXVhbCB0byBpdHNcbiAgICogIHByaW9yIHZhbHVlIGJlY2F1c2Ugb2YgY2hhbmdlcyBpbiBpdHMgbWluaW11bSBvciBtYXhpbXVtIGFmdGVyXG4gICAqICBmaWVsZCBpcyBjaGFuZ2VkLCB0aGVuIGl0cyB2YWx1ZSBpcyBhZGp1c3RlZCB0byBiZSBhcyBjbG9zZVxuICAgKiAgYXMgcG9zc2libGUgdG8gaXRzIGV4cGVjdGVkIHZhbHVlLiBBIHNtYWxsZXIgZmllbGQgcmVwcmVzZW50cyBhXG4gICAqICBzbWFsbGVyIHVuaXQgb2YgdGltZS4gSE9VUl9PRl9EQVkgaXMgYSBzbWFsbGVyIGZpZWxkIHRoYW5cbiAgICogIERBWV9PRl9NT05USC4gTm8gYWRqdXN0bWVudCBpcyBtYWRlIHRvIHNtYWxsZXIgZmllbGRzXG4gICAqICB0aGF0IGFyZSBub3QgZXhwZWN0ZWQgdG8gYmUgaW52YXJpYW50LiBUaGUgY2FsZW5kYXIgc3lzdGVtXG4gICAqICBkZXRlcm1pbmVzIHdoYXQgZmllbGRzIGFyZSBleHBlY3RlZCB0byBiZSBpbnZhcmlhbnQuXG4gICAqXG4gICAqXG4gICAqICAgICAgQGV4YW1wbGVcbiAgICogICAgICB1c2UoJ2RhdGUvZ3JlZ29yaWFuJyxmdW5jdGlvbihTLCBHcmVnb3JpYW5DYWxlbmRhcil7XG4gICAqICAgICAgICAgIGNvbnN0IGQgPSBuZXcgR3JlZ29yaWFuQ2FsZW5kYXIoKTtcbiAgICogICAgICAgICAgZC5zZXQoMjAxMiwgR3JlZ29yaWFuQ2FsZW5kYXIuSkFOVUFSWSwgMzEpO1xuICAgKiAgICAgICAgICBkLmFkZChHcmVnb3JpYW4uTU9OVEgsMSk7XG4gICAqICAgICAgICAgIC8vIDIwMTItMi0yOVxuICAgKiAgICAgICAgICBkb2N1bWVudC53cml0ZWxuKCc8cD4nK2QuZ2V0WWVhcigpKyctJytkLmdldE1vbnRoKCkrJy0nK2QuZ2V0RGF5T2ZXZWVrKCkpXG4gICAqICAgICAgICAgIGQuYWRkKEdyZWdvcmlhbi5NT05USCwxMik7XG4gICAqICAgICAgICAgIC8vIDIwMTMtMi0yOFxuICAgKiAgICAgICAgICBkb2N1bWVudC53cml0ZWxuKCc8cD4nK2QuZ2V0WWVhcigpKyctJytkLmdldE1vbnRoKCkrJy0nK2QuZ2V0RGF5T2ZXZWVrKCkpXG4gICAqICAgICAgfSk7XG4gICAqXG4gICAqIEBwYXJhbSBmaWVsZCB0aGUgY2FsZW5kYXIgZmllbGQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgaGUgYW1vdW50IG9mIGRhdGUgb3IgdGltZSB0byBiZSBhZGRlZCB0byB0aGUgZmllbGQuXG4gICAqL1xuICBhZGQ6IGZ1bmN0aW9uIGFkZChmaWVsZCwgYSkge1xuICAgIGlmICghYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgYW1vdW50ID0gYTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGZpZWxkcyA9IHNlbGYuZmllbGRzO1xuICAgIC8vIGNvbXB1dGVyIGFuZCByZXRyaWV2ZSBvcmlnaW5hbCB2YWx1ZVxuICAgIHZhciB2YWx1ZSA9IHNlbGYuZ2V0KGZpZWxkKTtcbiAgICBpZiAoZmllbGQgPT09IFlFQVIpIHtcbiAgICAgIHZhbHVlICs9IGFtb3VudDtcbiAgICAgIHNlbGYuc2V0KFlFQVIsIHZhbHVlKTtcbiAgICAgIGFkanVzdERheU9mTW9udGgoc2VsZik7XG4gICAgfSBlbHNlIGlmIChmaWVsZCA9PT0gTU9OVEgpIHtcbiAgICAgIHZhbHVlICs9IGFtb3VudDtcbiAgICAgIHZhciB5ZWFyQW1vdW50ID0gZmxvb3JEaXZpZGUodmFsdWUgLyAxMik7XG4gICAgICB2YWx1ZSA9IG1vZCh2YWx1ZSwgMTIpO1xuICAgICAgaWYgKHllYXJBbW91bnQpIHtcbiAgICAgICAgc2VsZi5zZXQoWUVBUiwgZmllbGRzW1lFQVJdICsgeWVhckFtb3VudCk7XG4gICAgICB9XG4gICAgICBzZWxmLnNldChNT05USCwgdmFsdWUpO1xuICAgICAgYWRqdXN0RGF5T2ZNb250aChzZWxmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgICBjYXNlIEhPVVJfT0ZfREFZOlxuICAgICAgICAgIGFtb3VudCAqPSBPTkVfSE9VUjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBNSU5VVEU6XG4gICAgICAgICAgYW1vdW50ICo9IE9ORV9NSU5VVEU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU0VDT05EUzpcbiAgICAgICAgICBhbW91bnQgKj0gT05FX1NFQ09ORDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBNSUxMSVNFQ09ORFM6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgV0VFS19PRl9NT05USDpcbiAgICAgICAgY2FzZSBXRUVLX09GX1lFQVI6XG4gICAgICAgIGNhc2UgREFZX09GX1dFRUtfSU5fTU9OVEg6XG4gICAgICAgICAgYW1vdW50ICo9IE9ORV9XRUVLO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIERBWV9PRl9XRUVLOlxuICAgICAgICBjYXNlIERBWV9PRl9ZRUFSOlxuICAgICAgICBjYXNlIERBWV9PRl9NT05USDpcbiAgICAgICAgICBhbW91bnQgKj0gT05FX0RBWTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lsbGVnYWwgZmllbGQgZm9yIGFkZCcpO1xuICAgICAgfVxuICAgICAgc2VsZi5zZXRUaW1lKHNlbGYudGltZSArIGFtb3VudCk7XG4gICAgfVxuICB9LFxuXG4gIC8qXG4gICAqIGFkZCB0aGUgeWVhciBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2QgYWRkWWVhclxuICAgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IHRoZSBzaWduZWQgYW1vdW50IHRvIGFkZCB0byBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogYWRkIHRoZSBtb250aCBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2QgYWRkTW9udGhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCB0aGUgc2lnbmVkIGFtb3VudCB0byBhZGQgdG8gZmllbGQuXG4gICAqL1xuXG4gIC8qXG4gICAqIGFkZCB0aGUgZGF5IG9mIG1vbnRoIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBhZGREYXlPZk1vbnRoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgdGhlIHNpZ25lZCBhbW91bnQgdG8gYWRkIHRvIGZpZWxkLlxuICAgKi9cblxuICAvKlxuICAgKiBhZGQgdGhlIGhvdXIgb2YgZGF5IG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBhZGRIb3VyT2ZEYXlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCB0aGUgc2lnbmVkIGFtb3VudCB0byBhZGQgdG8gZmllbGQuXG4gICAqL1xuXG4gIC8qXG4gICAqIGFkZCB0aGUgbWludXRlIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBhZGRNaW51dGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCB0aGUgc2lnbmVkIGFtb3VudCB0byBhZGQgdG8gZmllbGQuXG4gICAqL1xuXG4gIC8qXG4gICAqIGFkZCB0aGUgc2Vjb25kIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBhZGRTZWNvbmRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCB0aGUgc2lnbmVkIGFtb3VudCB0byBhZGQgdG8gZmllbGQuXG4gICAqL1xuXG4gIC8qXG4gICAqIGFkZCB0aGUgbWlsbGlzZWNvbmQgb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIGFkZE1pbGxpU2Vjb25kXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgdGhlIHNpZ25lZCBhbW91bnQgdG8gYWRkIHRvIGZpZWxkLlxuICAgKi9cblxuICAvKlxuICAgKiBhZGQgdGhlIHdlZWsgb2YgeWVhciBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2QgYWRkV2Vla09mWWVhclxuICAgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IHRoZSBzaWduZWQgYW1vdW50IHRvIGFkZCB0byBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogYWRkIHRoZSB3ZWVrIG9mIG1vbnRoIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBhZGRXZWVrT2ZNb250aFxuICAgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IHRoZSBzaWduZWQgYW1vdW50IHRvIGFkZCB0byBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogYWRkIHRoZSBkYXkgb2YgeWVhciBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2QgYWRkRGF5T2ZZZWFyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgdGhlIHNpZ25lZCBhbW91bnQgdG8gYWRkIHRvIGZpZWxkLlxuICAgKi9cblxuICAvKlxuICAgKiBhZGQgdGhlIGRheSBvZiB3ZWVrIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCBhZGREYXlPZldlZWtcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCB0aGUgc2lnbmVkIGFtb3VudCB0byBhZGQgdG8gZmllbGQuXG4gICAqL1xuXG4gIC8qXG4gICAqIGFkZCB0aGUgZGF5IG9mIHdlZWsgaW4gbW9udGggb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIGFkZERheU9mV2Vla0luTW9udGhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCB0aGUgc2lnbmVkIGFtb3VudCB0byBhZGQgdG8gZmllbGQuXG4gICAqL1xuXG4gIC8qXG4gICAqIEdldCByb2xsZWQgdmFsdWUgZm9yIHRoZSBmaWVsZFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBnZXRSb2xsZWRWYWx1ZTogZnVuY3Rpb24gZ2V0Um9sbGVkVmFsdWUodmFsdWUsIGEsIG1pbiwgbWF4KSB7XG4gICAgdmFyIGFtb3VudCA9IGE7XG4gICAgdmFyIGRpZmYgPSB2YWx1ZSAtIG1pbjtcbiAgICB2YXIgcmFuZ2UgPSBtYXggLSBtaW4gKyAxO1xuICAgIGFtb3VudCAlPSByYW5nZTtcbiAgICByZXR1cm4gbWluICsgKGRpZmYgKyBhbW91bnQgKyByYW5nZSkgJSByYW5nZTtcbiAgfSxcblxuICAvKlxuICAgKiBBZGRzIGEgc2lnbmVkIGFtb3VudCB0byB0aGUgc3BlY2lmaWVkIGNhbGVuZGFyIGZpZWxkIHdpdGhvdXQgY2hhbmdpbmcgbGFyZ2VyIGZpZWxkcy5cbiAgICogQSBuZWdhdGl2ZSByb2xsIGFtb3VudCBtZWFucyB0byBzdWJ0cmFjdCBmcm9tIGZpZWxkIHdpdGhvdXQgY2hhbmdpbmdcbiAgICogbGFyZ2VyIGZpZWxkcy4gSWYgdGhlIHNwZWNpZmllZCBhbW91bnQgaXMgMCwgdGhpcyBtZXRob2QgcGVyZm9ybXMgbm90aGluZy5cbiAgICpcbiAgICpcbiAgICpcbiAgICogICAgICBAZXhhbXBsZVxuICAgKiAgICAgIGNvbnN0IGQgPSBuZXcgR3JlZ29yaWFuQ2FsZW5kYXIoKTtcbiAgICogICAgICBkLnNldCgxOTk5LCBHcmVnb3JpYW5DYWxlbmRhci5BVUdVU1QsIDMxKTtcbiAgICogICAgICAvLyAxOTk5LTQtMzBcbiAgICogICAgICAvLyBUdWVzZGF5IEp1bmUgMSwgMTk5OVxuICAgKiAgICAgIGQuc2V0KDE5OTksIEdyZWdvcmlhbkNhbGVuZGFyLkpVTkUsIDEpO1xuICAgKiAgICAgIGQuYWRkKEdyZWdvcmlhbi5XRUVLX09GX01PTlRILC0xKTsgLy8gPT09IGQuYWRkKEdyZWdvcmlhbi5XRUVLX09GX01PTlRILFxuICAgKiAgICAgIGQuZ2V0KEdyZWdvcmlhbi5XRUVLX09GX01PTlRIKSk7XG4gICAqICAgICAgLy8gMTk5OS0wNi0yOVxuICAgKlxuICAgKlxuICAgKiBAcGFyYW0gZmllbGQgdGhlIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IHRoZSBzaWduZWQgYW1vdW50IHRvIGFkZCB0byBmaWVsZC5cbiAgICovXG4gIHJvbGw6IGZ1bmN0aW9uIHJvbGwoZmllbGQsIGFtb3VudCkge1xuICAgIGlmICghYW1vdW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAvLyBjb21wdXRlciBhbmQgcmV0cmlldmUgb3JpZ2luYWwgdmFsdWVcbiAgICB2YXIgdmFsdWUgPSBzZWxmLmdldChmaWVsZCk7XG4gICAgdmFyIG1pbiA9IHNlbGYuZ2V0QWN0dWFsTWluaW11bShmaWVsZCk7XG4gICAgdmFyIG1heCA9IHNlbGYuZ2V0QWN0dWFsTWF4aW11bShmaWVsZCk7XG4gICAgdmFsdWUgPSBzZWxmLmdldFJvbGxlZFZhbHVlKHZhbHVlLCBhbW91bnQsIG1pbiwgbWF4KTtcblxuICAgIHNlbGYuc2V0KGZpZWxkLCB2YWx1ZSk7XG5cbiAgICAvLyBjb25zaWRlciBjb21wdXRlIHRpbWUgcHJpb3JpdHlcbiAgICBzd2l0Y2ggKGZpZWxkKSB7XG4gICAgICBjYXNlIE1PTlRIOlxuICAgICAgICBhZGp1c3REYXlPZk1vbnRoKHNlbGYpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIG90aGVyIGZpZWxkcyBhcmUgc2V0IGFscmVhZHkgd2hlbiBnZXRcbiAgICAgICAgc2VsZi51cGRhdGVGaWVsZHNCeVNldChmaWVsZCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSxcblxuICAvKlxuICAgKiBrZWVwIGZpZWxkIHN0YWJsZS5cbiAgICpcbiAgICogMjAxNS0wOS0yOSBzZXRNb250aCAyIHZzIHJvbGxTZXRNb250aCAyXG4gICAqXG4gICAqL1xuICByb2xsU2V0OiBmdW5jdGlvbiByb2xsU2V0KGZpZWxkLCB2KSB7XG4gICAgdGhpcy5zZXQoZmllbGQsIHYpO1xuICAgIHN3aXRjaCAoZmllbGQpIHtcbiAgICAgIGNhc2UgTU9OVEg6XG4gICAgICAgIGFkanVzdERheU9mTW9udGgodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gb3RoZXIgZmllbGRzIGFyZSBzZXQgYWxyZWFkeSB3aGVuIGdldFxuICAgICAgICB0aGlzLnVwZGF0ZUZpZWxkc0J5U2V0KGZpZWxkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9LFxuXG4gIC8qXG4gICAqIHJvbGwgdGhlIHllYXIgb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIHJvbGxZZWFyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgdGhlIHNpZ25lZCBhbW91bnQgdG8gYWRkIHRvIGZpZWxkLlxuICAgKi9cblxuICAvKlxuICAgKiByb2xsIHRoZSBtb250aCBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgdGhlIHNpZ25lZCBhbW91bnQgdG8gYWRkIHRvIGZpZWxkLlxuICAgKiBAbWV0aG9kIHJvbGxNb250aFxuICAgKi9cblxuICAvKlxuICAgKiByb2xsIHRoZSBkYXkgb2YgbW9udGggb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIHJvbGxEYXlPZk1vbnRoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgdGhlIHNpZ25lZCBhbW91bnQgdG8gYWRkIHRvIGZpZWxkLlxuICAgKi9cblxuICAvKlxuICAgKiByb2xsIHRoZSBob3VyIG9mIGRheSBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2Qgcm9sbEhvdXJPZkRheVxuICAgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IHRoZSBzaWduZWQgYW1vdW50IHRvIGFkZCB0byBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogcm9sbCB0aGUgbWludXRlIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCByb2xsTWludXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgdGhlIHNpZ25lZCBhbW91bnQgdG8gYWRkIHRvIGZpZWxkLlxuICAgKi9cblxuICAvKlxuICAgKiByb2xsIHRoZSBzZWNvbmQgb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIHJvbGxTZWNvbmRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCB0aGUgc2lnbmVkIGFtb3VudCB0byBhZGQgdG8gZmllbGQuXG4gICAqL1xuXG4gIC8qXG4gICAqIHJvbGwgdGhlIG1pbGxpc2Vjb25kIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCByb2xsTWlsbGlTZWNvbmRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCB0aGUgc2lnbmVkIGFtb3VudCB0byBhZGQgdG8gZmllbGQuXG4gICAqL1xuXG4gIC8qXG4gICAqIHJvbGwgdGhlIHdlZWsgb2YgeWVhciBvZiB0aGUgZ2l2ZW4gY2FsZW5kYXIgZmllbGQuXG4gICAqIEBtZXRob2Qgcm9sbFdlZWtPZlllYXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCB0aGUgc2lnbmVkIGFtb3VudCB0byBhZGQgdG8gZmllbGQuXG4gICAqL1xuXG4gIC8qXG4gICAqIHJvbGwgdGhlIHdlZWsgb2YgbW9udGggb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIHJvbGxXZWVrT2ZNb250aFxuICAgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IHRoZSBzaWduZWQgYW1vdW50IHRvIGFkZCB0byBmaWVsZC5cbiAgICovXG5cbiAgLypcbiAgICogcm9sbCB0aGUgZGF5IG9mIHllYXIgb2YgdGhlIGdpdmVuIGNhbGVuZGFyIGZpZWxkLlxuICAgKiBAbWV0aG9kIHJvbGxEYXlPZlllYXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCB0aGUgc2lnbmVkIGFtb3VudCB0byBhZGQgdG8gZmllbGQuXG4gICAqL1xuXG4gIC8qXG4gICAqIHJvbGwgdGhlIGRheSBvZiB3ZWVrIG9mIHRoZSBnaXZlbiBjYWxlbmRhciBmaWVsZC5cbiAgICogQG1ldGhvZCByb2xsRGF5T2ZXZWVrXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgdGhlIHNpZ25lZCBhbW91bnQgdG8gYWRkIHRvIGZpZWxkLlxuICAgKi9cblxuICAvKlxuICAgKiByZW1vdmUgb3RoZXIgcHJpb3JpdHkgZmllbGRzIHdoZW4gY2FsbCBnZXRGaXhlZERhdGVcbiAgICogcHJlY29uZGl0aW9uOiBvdGhlciBmaWVsZHMgYXJlIGFsbCBzZXQgb3IgY29tcHV0ZWRcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgdXBkYXRlRmllbGRzQnlTZXQ6IGZ1bmN0aW9uIHVwZGF0ZUZpZWxkc0J5U2V0KGZpZWxkKSB7XG4gICAgdmFyIGZpZWxkcyA9IHRoaXMuZmllbGRzO1xuICAgIHN3aXRjaCAoZmllbGQpIHtcbiAgICAgIGNhc2UgV0VFS19PRl9NT05USDpcbiAgICAgICAgZmllbGRzW0RBWV9PRl9NT05USF0gPSB1bmRlZmluZWQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBEQVlfT0ZfWUVBUjpcbiAgICAgICAgZmllbGRzW01PTlRIXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERBWV9PRl9XRUVLOlxuICAgICAgICBmaWVsZHNbREFZX09GX01PTlRIXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFdFRUtfT0ZfWUVBUjpcbiAgICAgICAgZmllbGRzW0RBWV9PRl9ZRUFSXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZmllbGRzW01PTlRIXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0sXG5cbiAgLypcbiAgICogZ2V0IGN1cnJlbnQgZGF0ZSBpbnN0YW5jZSdzIHRpbWV6b25lIG9mZnNldFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0VGltZXpvbmVPZmZzZXQ6IGZ1bmN0aW9uIGdldFRpbWV6b25lT2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLnRpbWV6b25lT2Zmc2V0O1xuICB9LFxuXG4gIC8qXG4gICAqIHNldCBjdXJyZW50IGRhdGUgaW5zdGFuY2UncyB0aW1lem9uZSBvZmZzZXRcbiAgICovXG4gIHNldFRpbWV6b25lT2Zmc2V0OiBmdW5jdGlvbiBzZXRUaW1lem9uZU9mZnNldCh0aW1lem9uZU9mZnNldCkge1xuICAgIGlmICh0aGlzLnRpbWV6b25lT2Zmc2V0ICE9PSB0aW1lem9uZU9mZnNldCkge1xuICAgICAgdGhpcy5maWVsZHNDb21wdXRlZCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMudGltZXpvbmVPZmZzZXQgPSB0aW1lem9uZU9mZnNldDtcbiAgICB9XG4gIH0sXG5cbiAgLypcbiAgICogc2V0IGZpcnN0IGRheSBvZiB3ZWVrIGZvciBjdXJyZW50IGRhdGUgaW5zdGFuY2VcbiAgICovXG4gIHNldEZpcnN0RGF5T2ZXZWVrOiBmdW5jdGlvbiBzZXRGaXJzdERheU9mV2VlayhmaXJzdERheU9mV2Vlaykge1xuICAgIGlmICh0aGlzLmZpcnN0RGF5T2ZXZWVrICE9PSBmaXJzdERheU9mV2Vlaykge1xuICAgICAgdGhpcy5maXJzdERheU9mV2VlayA9IGZpcnN0RGF5T2ZXZWVrO1xuICAgICAgdGhpcy5maWVsZHNDb21wdXRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKlxuICAgKiBHZXRzIHdoYXQgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlayBpczsgZS5nLiwgU1VOREFZIGluIHRoZSBVLlMuLCBNT05EQVkgaW4gRnJhbmNlLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgKi9cbiAgZ2V0Rmlyc3REYXlPZldlZWs6IGZ1bmN0aW9uIGdldEZpcnN0RGF5T2ZXZWVrKCkge1xuICAgIHJldHVybiB0aGlzLmZpcnN0RGF5T2ZXZWVrO1xuICB9LFxuXG4gIC8qXG4gICAqIFNldHMgd2hhdCB0aGUgbWluaW1hbCBkYXlzIHJlcXVpcmVkIGluIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyIGFyZTsgRm9yIGV4YW1wbGUsXG4gICAqIGlmIHRoZSBmaXJzdCB3ZWVrIGlzIGRlZmluZWQgYXMgb25lIHRoYXQgY29udGFpbnMgdGhlIGZpcnN0IGRheSBvZiB0aGUgZmlyc3QgbW9udGggb2YgYSB5ZWFyLFxuICAgKiBjYWxsIHRoaXMgbWV0aG9kIHdpdGggdmFsdWUgMS5cbiAgICogSWYgaXQgbXVzdCBiZSBhIGZ1bGwgd2VlaywgdXNlIHZhbHVlIDcuXG4gICAqIEBwYXJhbSBtaW5pbWFsRGF5c0luRmlyc3RXZWVrIHRoZSBnaXZlbiBtaW5pbWFsIGRheXMgcmVxdWlyZWQgaW4gdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAqL1xuICBzZXRNaW5pbWFsRGF5c0luRmlyc3RXZWVrOiBmdW5jdGlvbiBzZXRNaW5pbWFsRGF5c0luRmlyc3RXZWVrKG1pbmltYWxEYXlzSW5GaXJzdFdlZWspIHtcbiAgICBpZiAodGhpcy5taW5pbWFsRGF5c0luRmlyc3RXZWVrICE9PSBtaW5pbWFsRGF5c0luRmlyc3RXZWVrKSB7XG4gICAgICB0aGlzLm1pbmltYWxEYXlzSW5GaXJzdFdlZWsgPSBtaW5pbWFsRGF5c0luRmlyc3RXZWVrO1xuICAgICAgdGhpcy5maWVsZHNDb21wdXRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKlxuICAgKiBHZXRzIHdoYXQgdGhlIG1pbmltYWwgZGF5cyByZXF1aXJlZCBpbiB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhciBhcmU7IGUuZy4sXG4gICAqIGlmIHRoZSBmaXJzdCB3ZWVrIGlzIGRlZmluZWQgYXMgb25lIHRoYXQgY29udGFpbnMgdGhlIGZpcnN0IGRheSBvZiB0aGUgZmlyc3QgbW9udGggb2YgYSB5ZWFyLFxuICAgKiB0aGlzIG1ldGhvZCByZXR1cm5zIDEuXG4gICAqIElmIHRoZSBtaW5pbWFsIGRheXMgcmVxdWlyZWQgbXVzdCBiZSBhIGZ1bGwgd2VlaywgdGhpcyBtZXRob2QgcmV0dXJucyA3LlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgbWluaW1hbCBkYXlzIHJlcXVpcmVkIGluIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgKi9cbiAgZ2V0TWluaW1hbERheXNJbkZpcnN0V2VlazogZnVuY3Rpb24gZ2V0TWluaW1hbERheXNJbkZpcnN0V2VlaygpIHtcbiAgICByZXR1cm4gdGhpcy5taW5pbWFsRGF5c0luRmlyc3RXZWVrO1xuICB9LFxuXG4gIC8qXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiB3ZWVrcyBpbiB0aGUgd2VlayB5ZWFyXG4gICAqIHJlcHJlc2VudGVkIGJ5IHRoaXMgR3JlZ29yaWFuQ2FsZW5kYXIuXG4gICAqXG4gICAqIEZvciBleGFtcGxlLCBpZiB0aGlzIEdyZWdvcmlhbkNhbGVuZGFyJ3MgZGF0ZSBpc1xuICAgKiBEZWNlbWJlciAzMSwgMjAwOCB3aXRoIHRoZSBJU09cbiAgICogODYwMSBjb21wYXRpYmxlIHNldHRpbmcsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIDUzIGZvciB0aGVcbiAgICogcGVyaW9kOiBEZWNlbWJlciAyOSwgMjAwOCB0byBKYW51YXJ5IDMsIDIwMTBcbiAgICogd2hpbGUgZ2V0QWN0dWFsTWF4aW11bShXRUVLX09GX1lFQVIpIHdpbGwgcmV0dXJuXG4gICAqIDUyIGZvciB0aGUgcGVyaW9kOiBEZWNlbWJlciAzMSwgMjAwNyB0byBEZWNlbWJlciAyOCwgMjAwOC5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSB0aGUgbnVtYmVyIG9mIHdlZWtzIGluIHRoZSB3ZWVrIHllYXIuXG4gICAqL1xuICBnZXRXZWVrc0luV2Vla1llYXI6IGZ1bmN0aW9uIGdldFdlZWtzSW5XZWVrWWVhcigpIHtcbiAgICB2YXIgd2Vla1llYXIgPSB0aGlzLmdldFdlZWtZZWFyKCk7XG4gICAgaWYgKHdlZWtZZWFyID09PSB0aGlzLmdldChZRUFSKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0QWN0dWFsTWF4aW11bShXRUVLX09GX1lFQVIpO1xuICAgIH1cbiAgICAvLyBVc2UgdGhlIDJuZCB3ZWVrIGZvciBjYWxjdWxhdGluZyB0aGUgbWF4IG9mIFdFRUtfT0ZfWUVBUlxuICAgIHZhciBnYyA9IHRoaXMuY2xvbmUoKTtcbiAgICBnYy5jbGVhcigpO1xuICAgIGdjLnNldFdlZWtEYXRlKHdlZWtZZWFyLCAyLCB0aGlzLmdldChEQVlfT0ZfV0VFSykpO1xuICAgIHJldHVybiBnYy5nZXRBY3R1YWxNYXhpbXVtKFdFRUtfT0ZfWUVBUik7XG4gIH0sXG5cbiAgLypcbiAgICogUmV0dXJucyB0aGUgd2VlayB5ZWFyIHJlcHJlc2VudGVkIGJ5IHRoaXMgR3JlZ29yaWFuQ2FsZW5kYXIuXG4gICAqIFRoZSBkYXRlcyBpbiB0aGUgd2Vla3MgYmV0d2VlbiAxIGFuZCB0aGVcbiAgICogbWF4aW11bSB3ZWVrIG51bWJlciBvZiB0aGUgd2VlayB5ZWFyIGhhdmUgdGhlIHNhbWUgd2VlayB5ZWFyIHZhbHVlXG4gICAqIHRoYXQgbWF5IGJlIG9uZSB5ZWFyIGJlZm9yZSBvciBhZnRlciB0aGUgY2FsZW5kYXIgeWVhciB2YWx1ZS5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSB0aGUgd2VlayB5ZWFyIHJlcHJlc2VudGVkIGJ5IHRoaXMgR3JlZ29yaWFuQ2FsZW5kYXIuXG4gICAqL1xuICBnZXRXZWVrWWVhcjogZnVuY3Rpb24gZ2V0V2Vla1llYXIoKSB7XG4gICAgdmFyIHllYXIgPSB0aGlzLmdldChZRUFSKTsgLy8gaW1wbGljaXRseSAgY29tcGxldGVcbiAgICB2YXIgd2Vla09mWWVhciA9IHRoaXMuZ2V0KFdFRUtfT0ZfWUVBUik7XG4gICAgdmFyIG1vbnRoID0gdGhpcy5nZXQoTU9OVEgpO1xuICAgIGlmIChtb250aCA9PT0gR3JlZ29yaWFuQ2FsZW5kYXIuSkFOVUFSWSkge1xuICAgICAgaWYgKHdlZWtPZlllYXIgPj0gNTIpIHtcbiAgICAgICAgLS15ZWFyO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobW9udGggPT09IEdyZWdvcmlhbkNhbGVuZGFyLkRFQ0VNQkVSKSB7XG4gICAgICBpZiAod2Vla09mWWVhciA9PT0gMSkge1xuICAgICAgICArK3llYXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB5ZWFyO1xuICB9LFxuICAvKlxuICAgKiBTZXRzIHRoaXMgR3JlZ29yaWFuQ2FsZW5kYXIgdG8gdGhlIGRhdGUgZ2l2ZW4gYnkgdGhlIGRhdGUgc3BlY2lmaWVycyAtIHdlZWtZZWFyLFxuICAgKiB3ZWVrT2ZZZWFyLCBhbmQgZGF5T2ZXZWVrLiB3ZWVrT2ZZZWFyIGZvbGxvd3MgdGhlIFdFRUtfT0ZfWUVBUiBudW1iZXJpbmcuXG4gICAqIFRoZSBkYXlPZldlZWsgdmFsdWUgbXVzdCBiZSBvbmUgb2YgdGhlIERBWV9PRl9XRUVLIHZhbHVlczogU1VOREFZIHRvIFNBVFVSREFZLlxuICAgKlxuICAgKiBAcGFyYW0gd2Vla1llYXIgICAgdGhlIHdlZWsgeWVhclxuICAgKiBAcGFyYW0gd2Vla09mWWVhciAgdGhlIHdlZWsgbnVtYmVyIGJhc2VkIG9uIHdlZWtZZWFyXG4gICAqIEBwYXJhbSBkYXlPZldlZWsgICB0aGUgZGF5IG9mIHdlZWsgdmFsdWVcbiAgICovXG4gIHNldFdlZWtEYXRlOiBmdW5jdGlvbiBzZXRXZWVrRGF0ZSh3ZWVrWWVhciwgd2Vla09mWWVhciwgZGF5T2ZXZWVrKSB7XG4gICAgaWYgKGRheU9mV2VlayA8IEdyZWdvcmlhbkNhbGVuZGFyLlNVTkRBWSB8fCBkYXlPZldlZWsgPiBHcmVnb3JpYW5DYWxlbmRhci5TQVRVUkRBWSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGRheU9mV2VlazogJyArIGRheU9mV2Vlayk7XG4gICAgfVxuICAgIHZhciBmaWVsZHMgPSB0aGlzLmZpZWxkcztcbiAgICAvLyBUbyBhdm9pZCBjaGFuZ2luZyB0aGUgdGltZSBvZiBkYXkgZmllbGRzIGJ5IGRhdGVcbiAgICAvLyBjYWxjdWxhdGlvbnMsIHVzZSBhIGNsb25lIHdpdGggdGhlIEdNVCB0aW1lIHpvbmUuXG4gICAgdmFyIGdjID0gdGhpcy5jbG9uZSgpO1xuICAgIGdjLmNsZWFyKCk7XG4gICAgZ2Muc2V0VGltZXpvbmVPZmZzZXQoMCk7XG4gICAgZ2Muc2V0KFlFQVIsIHdlZWtZZWFyKTtcbiAgICBnYy5zZXQoV0VFS19PRl9ZRUFSLCAxKTtcbiAgICBnYy5zZXQoREFZX09GX1dFRUssIHRoaXMuZ2V0Rmlyc3REYXlPZldlZWsoKSk7XG4gICAgdmFyIGRheXMgPSBkYXlPZldlZWsgLSB0aGlzLmdldEZpcnN0RGF5T2ZXZWVrKCk7XG4gICAgaWYgKGRheXMgPCAwKSB7XG4gICAgICBkYXlzICs9IDc7XG4gICAgfVxuICAgIGRheXMgKz0gNyAqICh3ZWVrT2ZZZWFyIC0gMSk7XG4gICAgaWYgKGRheXMgIT09IDApIHtcbiAgICAgIGdjLmFkZChEQVlfT0ZfWUVBUiwgZGF5cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdjLmNvbXBsZXRlKCk7XG4gICAgfVxuICAgIGZpZWxkc1tZRUFSXSA9IGdjLmdldChZRUFSKTtcbiAgICBmaWVsZHNbTU9OVEhdID0gZ2MuZ2V0KE1PTlRIKTtcbiAgICBmaWVsZHNbREFZX09GX01PTlRIXSA9IGdjLmdldChEQVlfT0ZfTU9OVEgpO1xuICAgIHRoaXMuY29tcGxldGUoKTtcbiAgfSxcbiAgLypcbiAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGNvcHkgb2YgdGhpcyBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtEYXRlLkdyZWdvcmlhbn1cbiAgICovXG4gIGNsb25lOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICBpZiAodGhpcy50aW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuY29tcHV0ZVRpbWUoKTtcbiAgICB9XG4gICAgdmFyIGNhbCA9IG5ldyBHcmVnb3JpYW5DYWxlbmRhcih0aGlzLmxvY2FsZSk7XG4gICAgY2FsLnNldFRpbWV6b25lT2Zmc2V0KGNhbC5nZXRUaW1lem9uZU9mZnNldCgpKTtcbiAgICBjYWwuc2V0Rmlyc3REYXlPZldlZWsoY2FsLmdldEZpcnN0RGF5T2ZXZWVrKCkpO1xuICAgIGNhbC5zZXRNaW5pbWFsRGF5c0luRmlyc3RXZWVrKGNhbC5nZXRNaW5pbWFsRGF5c0luRmlyc3RXZWVrKCkpO1xuICAgIGNhbC5zZXRUaW1lKHRoaXMudGltZSk7XG4gICAgcmV0dXJuIGNhbDtcbiAgfSxcblxuICAvKlxuICAgKiBDb21wYXJlcyB0aGlzIEdyZWdvcmlhbkNhbGVuZGFyIHRvIHRoZSBzcGVjaWZpZWQgT2JqZWN0LlxuICAgKiBUaGUgcmVzdWx0IGlzIHRydWUgaWYgYW5kIG9ubHkgaWYgdGhlIGFyZ3VtZW50IGlzIGEgR3JlZ29yaWFuQ2FsZW5kYXIgb2JqZWN0XG4gICAqIHRoYXQgcmVwcmVzZW50cyB0aGUgc2FtZSB0aW1lIHZhbHVlIChtaWxsaXNlY29uZCBvZmZzZXQgZnJvbSB0aGUgRXBvY2gpXG4gICAqIHVuZGVyIHRoZSBzYW1lIENhbGVuZGFyIHBhcmFtZXRlcnMgYW5kIEdyZWdvcmlhbiBjaGFuZ2UgZGF0ZSBhcyB0aGlzIG9iamVjdC5cbiAgICogQHBhcmFtIHtEYXRlLkdyZWdvcmlhbn0gb2JqIHRoZSBvYmplY3QgdG8gY29tcGFyZSB3aXRoLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGlzIG9iamVjdCBpcyBlcXVhbCB0byBvYmo7IGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGVxdWFsczogZnVuY3Rpb24gZXF1YWxzKG9iaikge1xuICAgIHJldHVybiB0aGlzLmdldFRpbWUoKSA9PT0gb2JqLmdldFRpbWUoKSAmJiB0aGlzLmZpcnN0RGF5T2ZXZWVrID09PSBvYmouZmlyc3REYXlPZldlZWsgJiYgdGhpcy50aW1lem9uZU9mZnNldCA9PT0gb2JqLnRpbWV6b25lT2Zmc2V0ICYmIHRoaXMubWluaW1hbERheXNJbkZpcnN0V2VlayA9PT0gb2JqLm1pbmltYWxEYXlzSW5GaXJzdFdlZWs7XG4gIH0sXG5cbiAgY29tcGFyZVRvRGF5OiBmdW5jdGlvbiBjb21wYXJlVG9EYXkoZDIpIHtcbiAgICB2YXIgZDFZZWFyID0gdGhpcy5nZXRZZWFyKCk7XG4gICAgdmFyIGQyWWVhciA9IGQyLmdldFllYXIoKTtcbiAgICB2YXIgZDFNb250aCA9IHRoaXMuZ2V0TW9udGgoKTtcbiAgICB2YXIgZDJNb250aCA9IGQyLmdldE1vbnRoKCk7XG4gICAgdmFyIGQxRGF5ID0gdGhpcy5nZXREYXlPZk1vbnRoKCk7XG4gICAgdmFyIGQyRGF5ID0gZDIuZ2V0RGF5T2ZNb250aCgpO1xuICAgIGlmIChkMVllYXIgIT09IGQyWWVhcikge1xuICAgICAgcmV0dXJuIGQxWWVhciAtIGQyWWVhcjtcbiAgICB9XG4gICAgaWYgKGQxTW9udGggIT09IGQyTW9udGgpIHtcbiAgICAgIHJldHVybiBkMU1vbnRoIC0gZDJNb250aDtcbiAgICB9XG4gICAgcmV0dXJuIGQxRGF5IC0gZDJEYXk7XG4gIH0sXG5cbiAgLypcbiAgICogU2V0cyBhbGwgdGhlIGNhbGVuZGFyIGZpZWxkIHZhbHVlcyBvciBzcGVjaWZpZWQgZmllbGQgYW5kIHRoZSB0aW1lIHZhbHVlXG4gICAqIChtaWxsaXNlY29uZCBvZmZzZXQgZnJvbSB0aGUgRXBvY2gpIG9mIHRoaXMgQ2FsZW5kYXIgdW5kZWZpbmVkLlxuICAgKiBUaGlzIG1lYW5zIHRoYXQgaXNTZXQoKSB3aWxsIHJldHVybiBmYWxzZSBmb3IgYWxsIHRoZSBjYWxlbmRhciBmaWVsZHMsXG4gICAqIGFuZCB0aGUgZGF0ZSBhbmQgdGltZSBjYWxjdWxhdGlvbnMgd2lsbCB0cmVhdCB0aGUgZmllbGRzIGFzIGlmIHRoZXkgaGFkIG5ldmVyIGJlZW4gc2V0LlxuICAgKiBAcGFyYW0gW2ZpZWxkXSB0aGUgY2FsZW5kYXIgZmllbGQgdG8gYmUgY2xlYXJlZC5cbiAgICovXG4gIGNsZWFyOiBmdW5jdGlvbiBjbGVhcihmaWVsZCkge1xuICAgIGlmIChmaWVsZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmZpZWxkID0gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmllbGRzW2ZpZWxkXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdGhpcy50aW1lID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZmllbGRzQ29tcHV0ZWQgPSBmYWxzZTtcbiAgfSxcblxuICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgLy8gZm9yIGRlYnVnXG4gICAgdmFyIHYgPSB0aGlzO1xuICAgIHJldHVybiAnW0dyZWdvcmlhbkNhbGVuZGFyXTogJyArIHYuZ2V0WWVhcigpICsgJy8nICsgdi5nZXRNb250aCgpICsgJy8nICsgdi5nZXREYXlPZk1vbnRoKCkgKyAnICcgKyB2LmdldEhvdXJPZkRheSgpICsgJzonICsgdi5nZXRNaW51dGVzKCkgKyAnOicgKyB2LmdldFNlY29uZHMoKTtcbiAgfVxufTtcblxudmFyIEdyZWdvcmlhbkNhbGVuZGFyUHJvdG8gPSBHcmVnb3JpYW5DYWxlbmRhci5wcm90b3R5cGU7XG5cblV0aWxzLmVhY2goRklFTERTLCBmdW5jdGlvbiAoZiwgaW5kZXgpIHtcbiAgaWYgKGYpIHtcbiAgICBHcmVnb3JpYW5DYWxlbmRhclByb3RvWydnZXQnICsgZl0gPSBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoaW5kZXgpO1xuICAgIH07XG5cbiAgICBHcmVnb3JpYW5DYWxlbmRhclByb3RvWydpc1NldCcgKyBmXSA9IGZ1bmN0aW9uIGlzU2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNTZXQoaW5kZXgpO1xuICAgIH07XG5cbiAgICBHcmVnb3JpYW5DYWxlbmRhclByb3RvWydzZXQnICsgZl0gPSBmdW5jdGlvbiBzZXQodikge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KGluZGV4LCB2KTtcbiAgICB9O1xuXG4gICAgR3JlZ29yaWFuQ2FsZW5kYXJQcm90b1snYWRkJyArIGZdID0gZnVuY3Rpb24gYWRkKHYpIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZChpbmRleCwgdik7XG4gICAgfTtcblxuICAgIEdyZWdvcmlhbkNhbGVuZGFyUHJvdG9bJ3JvbGwnICsgZl0gPSBmdW5jdGlvbiByb2xsKHYpIHtcbiAgICAgIHJldHVybiB0aGlzLnJvbGwoaW5kZXgsIHYpO1xuICAgIH07XG5cbiAgICBHcmVnb3JpYW5DYWxlbmRhclByb3RvWydyb2xsU2V0JyArIGZdID0gZnVuY3Rpb24gcm9sbFNldCh2KSB7XG4gICAgICByZXR1cm4gdGhpcy5yb2xsU2V0KGluZGV4LCB2KTtcbiAgICB9O1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcmVnb3JpYW5DYWxlbmRhcjtcbi8qXG4gaHR0cDovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2UvNy9kb2NzL2FwaS9qYXZhL3V0aWwvR3JlZ29yaWFuQ2FsZW5kYXIuaHRtbFxuXG4gVE9ET1xuIC0gZGF5IHNhdmluZyB0aW1lXG4gLSBpMThuXG4gLSBqdWxpYW4gY2FsZW5kYXJcbiAqL1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9ncmVnb3JpYW4tY2FsZW5kYXIvbGliL2dyZWdvcmlhbi1jYWxlbmRhci5qc1xuICoqLyIsIi8qXG4gKiB1dGlscyBmb3IgZ3JlZ29yaWFuIGRhdGVcbiAqIEBpZ25vcmVcbiAqIEBhdXRob3IgeWltaW5naGVAZ21haWwuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ29uc3QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIEFDQ1VNVUxBVEVEX0RBWVNfSU5fTU9OVEhcbi8vICAgMS8xIDIvMSAzLzEgNC8xIDUvMSA2LzEgNy8xIDgvMSA5LzEgMTAvMSAxMS8xIDEyLzFcbj0gWzAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0XTtcblxudmFyIEFDQ1VNVUxBVEVEX0RBWVNfSU5fTU9OVEhfTEVBUFxuLy8gICAxLzEgMi8xICAgMy8xICAgNC8xICAgNS8xICAgNi8xICAgNy8xICAgOC8xICAgOS8xXG4vLyAxMC8xICAgMTEvMSAgIDEyLzFcbj0gWzAsIDMxLCA1OSArIDEsIDkwICsgMSwgMTIwICsgMSwgMTUxICsgMSwgMTgxICsgMSwgMjEyICsgMSwgMjQzICsgMSwgMjczICsgMSwgMzA0ICsgMSwgMzM0ICsgMV07XG5cbnZhciBEQVlTX09GX1lFQVIgPSAzNjU7XG52YXIgREFZU19PRl80WUVBUiA9IDM2NSAqIDQgKyAxO1xudmFyIERBWVNfT0ZfMTAwWUVBUiA9IERBWVNfT0ZfNFlFQVIgKiAyNSAtIDE7XG52YXIgREFZU19PRl80MDBZRUFSID0gREFZU19PRl8xMDBZRUFSICogNCArIDE7XG52YXIgX2V4cG9ydHMgPSB7fTtcblxuZnVuY3Rpb24gZ2V0RGF5T2ZZZWFyKHllYXIsIG1vbnRoLCBkYXlPZk1vbnRoKSB7XG4gIHJldHVybiBkYXlPZk1vbnRoICsgKF9leHBvcnRzLmlzTGVhcFllYXIoeWVhcikgPyBBQ0NVTVVMQVRFRF9EQVlTX0lOX01PTlRIX0xFQVBbbW9udGhdIDogQUNDVU1VTEFURURfREFZU19JTl9NT05USFttb250aF0pO1xufVxuXG5mdW5jdGlvbiBnZXREYXlPZldlZWtGcm9tRml4ZWREYXRlKGZpeGVkRGF0ZSkge1xuICAvLyBUaGUgZml4ZWQgZGF5IDEgKEphbnVhcnkgMSwgMSBHcmVnb3JpYW4pIGlzIE1vbmRheS5cbiAgaWYgKGZpeGVkRGF0ZSA+PSAwKSB7XG4gICAgcmV0dXJuIGZpeGVkRGF0ZSAlIDc7XG4gIH1cbiAgcmV0dXJuIF9leHBvcnRzLm1vZChmaXhlZERhdGUsIDcpO1xufVxuXG5mdW5jdGlvbiBnZXRHcmVnb3JpYW5ZZWFyRnJvbUZpeGVkRGF0ZShmaXhlZERhdGUpIHtcbiAgdmFyIGQwID0gdW5kZWZpbmVkO1xuICB2YXIgZDEgPSB1bmRlZmluZWQ7XG4gIHZhciBkMiA9IHVuZGVmaW5lZDtcbiAgdmFyIGQzID0gdW5kZWZpbmVkO1xuICB2YXIgbjQwMCA9IHVuZGVmaW5lZDtcbiAgdmFyIG4xMDAgPSB1bmRlZmluZWQ7XG4gIHZhciBuNCA9IHVuZGVmaW5lZDtcbiAgdmFyIG4xID0gdW5kZWZpbmVkO1xuICB2YXIgeWVhciA9IHVuZGVmaW5lZDtcbiAgZDAgPSBmaXhlZERhdGUgLSAxO1xuXG4gIG40MDAgPSBmbG9vcihkMCAvIERBWVNfT0ZfNDAwWUVBUik7XG4gIGQxID0gX2V4cG9ydHMubW9kKGQwLCBEQVlTX09GXzQwMFlFQVIpO1xuICBuMTAwID0gZmxvb3IoZDEgLyBEQVlTX09GXzEwMFlFQVIpO1xuICBkMiA9IF9leHBvcnRzLm1vZChkMSwgREFZU19PRl8xMDBZRUFSKTtcbiAgbjQgPSBmbG9vcihkMiAvIERBWVNfT0ZfNFlFQVIpO1xuICBkMyA9IF9leHBvcnRzLm1vZChkMiwgREFZU19PRl80WUVBUik7XG4gIG4xID0gZmxvb3IoZDMgLyBEQVlTX09GX1lFQVIpO1xuXG4gIHllYXIgPSA0MDAgKiBuNDAwICsgMTAwICogbjEwMCArIDQgKiBuNCArIG4xO1xuXG4gIC8vID9cbiAgaWYgKCEobjEwMCA9PT0gNCB8fCBuMSA9PT0gNCkpIHtcbiAgICArK3llYXI7XG4gIH1cblxuICByZXR1cm4geWVhcjtcbn1cblxuX2V4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgZWFjaDogZnVuY3Rpb24gZWFjaChhcnIsIGZuKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGZuKGFycltpXSwgaSwgYXJyKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIG1peDogZnVuY3Rpb24gbWl4KHQsIHMpIHtcbiAgICBmb3IgKHZhciBwIGluIHMpIHtcbiAgICAgIGlmIChzLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBpc0xlYXBZZWFyOiBmdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICBpZiAoKHllYXIgJiAzKSAhPT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4geWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwO1xuICB9LFxuXG4gIG1vZDogZnVuY3Rpb24gbW9kKHgsIHkpIHtcbiAgICAvLyDotJ/mlbDml7bkuI3mmK/plZzlg4/lhbPns7tcbiAgICByZXR1cm4geCAtIHkgKiBmbG9vcih4IC8geSk7XG4gIH0sXG5cbiAgLy8gbW9udGg6IDAgYmFzZWRcbiAgZ2V0Rml4ZWREYXRlOiBmdW5jdGlvbiBnZXRGaXhlZERhdGUoeWVhciwgbW9udGgsIGRheU9mTW9udGgpIHtcbiAgICB2YXIgcHJldlllYXIgPSB5ZWFyIC0gMTtcbiAgICAvLyDogIPomZHlhazlhYPliY1cbiAgICByZXR1cm4gREFZU19PRl9ZRUFSICogcHJldlllYXIgKyBmbG9vcihwcmV2WWVhciAvIDQpIC0gZmxvb3IocHJldlllYXIgLyAxMDApICsgZmxvb3IocHJldlllYXIgLyA0MDApICsgZ2V0RGF5T2ZZZWFyKHllYXIsIG1vbnRoLCBkYXlPZk1vbnRoKTtcbiAgfSxcblxuICBnZXRHcmVnb3JpYW5EYXRlRnJvbUZpeGVkRGF0ZTogZnVuY3Rpb24gZ2V0R3JlZ29yaWFuRGF0ZUZyb21GaXhlZERhdGUoZml4ZWREYXRlKSB7XG4gICAgdmFyIHllYXIgPSBnZXRHcmVnb3JpYW5ZZWFyRnJvbUZpeGVkRGF0ZShmaXhlZERhdGUpO1xuICAgIHZhciBqYW4xID0gX2V4cG9ydHMuZ2V0Rml4ZWREYXRlKHllYXIsIENvbnN0LkpBTlVBUlksIDEpO1xuICAgIHZhciBpc0xlYXAgPSBfZXhwb3J0cy5pc0xlYXBZZWFyKHllYXIpO1xuICAgIHZhciBBQ0NVTVVMQVRFRF9EQVlTID0gaXNMZWFwID8gQUNDVU1VTEFURURfREFZU19JTl9NT05USF9MRUFQIDogQUNDVU1VTEFURURfREFZU19JTl9NT05USDtcbiAgICB2YXIgZGF5c0RpZmYgPSBmaXhlZERhdGUgLSBqYW4xO1xuICAgIHZhciBtb250aCA9IHVuZGVmaW5lZDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgQUNDVU1VTEFURURfREFZUy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKEFDQ1VNVUxBVEVEX0RBWVNbaV0gPD0gZGF5c0RpZmYpIHtcbiAgICAgICAgbW9udGggPSBpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRheU9mTW9udGggPSBmaXhlZERhdGUgLSBqYW4xIC0gQUNDVU1VTEFURURfREFZU1ttb250aF0gKyAxO1xuICAgIHZhciBkYXlPZldlZWsgPSBnZXREYXlPZldlZWtGcm9tRml4ZWREYXRlKGZpeGVkRGF0ZSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeWVhcjogeWVhcixcbiAgICAgIG1vbnRoOiBtb250aCxcbiAgICAgIGRheU9mTW9udGg6IGRheU9mTW9udGgsXG4gICAgICBkYXlPZldlZWs6IGRheU9mV2VlayxcbiAgICAgIGlzTGVhcDogaXNMZWFwXG4gICAgfTtcbiAgfVxufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vZ3JlZ29yaWFuLWNhbGVuZGFyL2xpYi91dGlscy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGd1aWQ6IHJlcXVpcmUoJy4vZ3VpZCcpLFxuICBjbGFzc1NldDogcmVxdWlyZSgnLi9jbGFzc1NldCcpLFxuICBqb2luQ2xhc3NlczogcmVxdWlyZSgnLi9qb2luQ2xhc3NlcycpLFxuICBLZXlDb2RlOiByZXF1aXJlKCcuL0tleUNvZGUnKSxcbiAgUHVyZVJlbmRlck1peGluOiByZXF1aXJlKCcuL1B1cmVSZW5kZXJNaXhpbicpLFxuICBzaGFsbG93RXF1YWw6IHJlcXVpcmUoJ3NoYWxsb3dlcXVhbCcpLFxuICBjcmVhdGVDaGFpbmVkRnVuY3Rpb246IHJlcXVpcmUoJy4vY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uJyksXG4gIERvbToge1xuICAgIGFkZEV2ZW50TGlzdGVuZXI6IHJlcXVpcmUoJy4vRG9tL2FkZEV2ZW50TGlzdGVuZXInKSxcbiAgICBjb250YWluczogcmVxdWlyZSgnLi9Eb20vY29udGFpbnMnKVxuICB9LFxuICBDaGlsZHJlbjoge1xuICAgIHRvQXJyYXk6IHJlcXVpcmUoJy4vQ2hpbGRyZW4vdG9BcnJheScpLFxuICAgIG1hcFNlbGY6IHJlcXVpcmUoJy4vQ2hpbGRyZW4vbWFwU2VsZicpXG4gIH1cbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLXV0aWwvbGliL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVwcmVjYXRlID0gcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKTtcbnZhciBjbGFzc05hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZShjbGFzc05hbWVzLCAnYHJjVXRpbC5jbGFzc1NldCgpYCBpcyBkZXByZWNhdGVkLCB1c2UgYGNsYXNzTmFtZXMoKWAgYnkgYHJlcXVpcmUoXFwnY2xhc3NuYW1lc1xcJylgIGluc3RlYWQnKTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtdXRpbC9saWIvY2xhc3NTZXQuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZXByZWNhdGUgPSByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpO1xudmFyIGNsYXNzTmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlKGNsYXNzTmFtZXMsICdgcmNVdGlsLmpvaW5DbGFzc2VzKClgIGlzIGRlcHJlY2F0ZWQsIHVzZSBgY2xhc3NOYW1lcygpYCBieSBgcmVxdWlyZShcXCdjbGFzc25hbWVzXFwnKWAgaW5zdGVhZCcpO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy11dGlsL2xpYi9qb2luQ2xhc3Nlcy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ3NoYWxsb3dlcXVhbCcpO1xuXG4vKipcbiAqIElmIHlvdXIgUmVhY3QgY29tcG9uZW50J3MgcmVuZGVyIGZ1bmN0aW9uIGlzIFwicHVyZVwiLCBlLmcuIGl0IHdpbGwgcmVuZGVyIHRoZVxuICogc2FtZSByZXN1bHQgZ2l2ZW4gdGhlIHNhbWUgcHJvcHMgYW5kIHN0YXRlLCBwcm92aWRlIHRoaXMgTWl4aW4gZm9yIGFcbiAqIGNvbnNpZGVyYWJsZSBwZXJmb3JtYW5jZSBib29zdC5cbiAqXG4gKiBNb3N0IFJlYWN0IGNvbXBvbmVudHMgaGF2ZSBwdXJlIHJlbmRlciBmdW5jdGlvbnMuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgIGNvbnN0IFJlYWN0Q29tcG9uZW50V2l0aFB1cmVSZW5kZXJNaXhpbiA9XG4gKiAgICAgcmVxdWlyZSgnUmVhY3RDb21wb25lbnRXaXRoUHVyZVJlbmRlck1peGluJyk7XG4gKiAgIFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgICBtaXhpbnM6IFtSZWFjdENvbXBvbmVudFdpdGhQdXJlUmVuZGVyTWl4aW5dLFxuICpcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICogICAgICAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPXt0aGlzLnByb3BzLmNsYXNzTmFtZX0+Zm9vPC9kaXY+O1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogTm90ZTogVGhpcyBvbmx5IGNoZWNrcyBzaGFsbG93IGVxdWFsaXR5IGZvciBwcm9wcyBhbmQgc3RhdGUuIElmIHRoZXNlIGNvbnRhaW5cbiAqIGNvbXBsZXggZGF0YSBzdHJ1Y3R1cmVzIHRoaXMgbWl4aW4gbWF5IGhhdmUgZmFsc2UtbmVnYXRpdmVzIGZvciBkZWVwZXJcbiAqIGRpZmZlcmVuY2VzLiBPbmx5IG1peGluIHRvIGNvbXBvbmVudHMgd2hpY2ggaGF2ZSBzaW1wbGUgcHJvcHMgYW5kIHN0YXRlLCBvclxuICogdXNlIGBmb3JjZVVwZGF0ZSgpYCB3aGVuIHlvdSBrbm93IGRlZXAgZGF0YSBzdHJ1Y3R1cmVzIGhhdmUgY2hhbmdlZC5cbiAqL1xudmFyIFJlYWN0Q29tcG9uZW50V2l0aFB1cmVSZW5kZXJNaXhpbiA9IHtcbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiBmdW5jdGlvbiBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcbiAgICByZXR1cm4gIXNoYWxsb3dFcXVhbCh0aGlzLnByb3BzLCBuZXh0UHJvcHMpIHx8ICFzaGFsbG93RXF1YWwodGhpcy5zdGF0ZSwgbmV4dFN0YXRlKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudFdpdGhQdXJlUmVuZGVyTWl4aW47XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLXV0aWwvbGliL1B1cmVSZW5kZXJNaXhpbi5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZldGNoS2V5cyA9IHJlcXVpcmUoJ2xvZGFzaC5rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIsIGNvbXBhcmUsIGNvbXBhcmVDb250ZXh0KSB7XG5cbiAgICB2YXIgcmV0ID0gY29tcGFyZSA/IGNvbXBhcmUuY2FsbChjb21wYXJlQ29udGV4dCwgb2JqQSwgb2JqQikgOiB2b2lkIDA7XG5cbiAgICBpZiAocmV0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuICEhcmV0O1xuICAgIH1cblxuICAgIGlmIChvYmpBID09PSBvYmpCKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb2JqQSAhPT0gJ29iamVjdCcgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gJ29iamVjdCcgfHwgb2JqQiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGtleXNBID0gZmV0Y2hLZXlzKG9iakEpO1xuICAgIHZhciBrZXlzQiA9IGZldGNoS2V5cyhvYmpCKTtcblxuICAgIHZhciBsZW4gPSBrZXlzQS5sZW5ndGg7XG4gICAgaWYgKGxlbiAhPT0ga2V5c0IubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb21wYXJlQ29udGV4dCA9IGNvbXBhcmVDb250ZXh0IHx8IG51bGw7XG5cbiAgICAvLyBUZXN0IGZvciBBJ3Mga2V5cyBkaWZmZXJlbnQgZnJvbSBCLlxuICAgIHZhciBiSGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmJpbmQob2JqQik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c0FbaV07XG4gICAgICAgIGlmICghYkhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWVBID0gb2JqQVtrZXldO1xuICAgICAgICB2YXIgdmFsdWVCID0gb2JqQltrZXldO1xuXG4gICAgICAgIHZhciBfcmV0ID0gY29tcGFyZSA/IGNvbXBhcmUuY2FsbChjb21wYXJlQ29udGV4dCwgdmFsdWVBLCB2YWx1ZUIsIGtleSkgOiB2b2lkIDA7XG4gICAgICAgIGlmIChfcmV0ID09PSBmYWxzZSB8fCBfcmV0ID09PSB2b2lkIDAgJiYgdmFsdWVBICE9PSB2YWx1ZUIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtdXRpbC9+L3NoYWxsb3dlcXVhbC9tb2R1bGVzL2luZGV4LmpzXG4gKiovIiwiLyoqXG4gKiBsb2Rhc2ggMy4xLjIgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cbnZhciBnZXROYXRpdmUgPSByZXF1aXJlKCdsb2Rhc2guX2dldG5hdGl2ZScpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnbG9kYXNoLmlzYXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJ2xvZGFzaC5pc2FycmF5Jyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eXFxkKyQvO1xuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2tleXMnKTtcblxuLyoqXG4gKiBVc2VkIGFzIHRoZSBbbWF4aW11bSBsZW5ndGhdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5tYXhfc2FmZV9pbnRlZ2VyKVxuICogb2YgYW4gYXJyYXktbGlrZSB2YWx1ZS5cbiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgdmFsdWUgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBhdm9pZCBhIFtKSVQgYnVnXShodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQyNzkyKVxuICogdGhhdCBhZmZlY3RzIFNhZmFyaSBvbiBhdCBsZWFzdCBpT1MgOC4xLTguMyBBUk02NC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIFwibGVuZ3RoXCIgdmFsdWUuXG4gKi9cbnZhciBnZXRMZW5ndGggPSBiYXNlUHJvcGVydHkoJ2xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aChnZXRMZW5ndGgodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFsdWUgPSAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSA/ICt2YWx1ZSA6IC0xO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG4gIHJldHVybiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgYmFzZWQgb24gW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBBIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uIG9mIGBPYmplY3Qua2V5c2Agd2hpY2ggY3JlYXRlcyBhbiBhcnJheSBvZiB0aGVcbiAqIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBzaGltS2V5cyhvYmplY3QpIHtcbiAgdmFyIHByb3BzID0ga2V5c0luKG9iamVjdCksXG4gICAgICBwcm9wc0xlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgIGxlbmd0aCA9IHByb3BzTGVuZ3RoICYmIG9iamVjdC5sZW5ndGg7XG5cbiAgdmFyIGFsbG93SW5kZXhlcyA9ICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBwcm9wc0xlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgaWYgKChhbGxvd0luZGV4ZXMgJiYgaXNJbmRleChrZXksIGxlbmd0aCkpIHx8IGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBbbGFuZ3VhZ2UgdHlwZV0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4OCkgb2YgYE9iamVjdGAuXG4gKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG52YXIga2V5cyA9ICFuYXRpdmVLZXlzID8gc2hpbUtleXMgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgdmFyIEN0b3IgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgaWYgKCh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlID09PSBvYmplY3QpIHx8XG4gICAgICAodHlwZW9mIG9iamVjdCAhPSAnZnVuY3Rpb24nICYmIGlzQXJyYXlMaWtlKG9iamVjdCkpKSB7XG4gICAgcmV0dXJuIHNoaW1LZXlzKG9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0KG9iamVjdCkgPyBuYXRpdmVLZXlzKG9iamVjdCkgOiBbXTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7XG4gIGxlbmd0aCA9IChsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSkgJiYgbGVuZ3RoKSB8fCAwO1xuXG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgaW5kZXggPSAtMSxcbiAgICAgIGlzUHJvdG8gPSB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlID09PSBvYmplY3QsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBsZW5ndGggPiAwO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IChpbmRleCArICcnKTtcbiAgfVxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoc2tpcEluZGV4ZXMgJiYgaXNJbmRleChrZXksIGxlbmd0aCkpICYmXG4gICAgICAgICEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5cztcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy11dGlsL34vc2hhbGxvd2VxdWFsL34vbG9kYXNoLmtleXMvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1snZGVmYXVsdCddID0gYWRkRXZlbnRMaXN0ZW5lcldyYXA7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9hZGREb21FdmVudExpc3RlbmVyID0gcmVxdWlyZSgnYWRkLWRvbS1ldmVudC1saXN0ZW5lcicpO1xuXG52YXIgX2FkZERvbUV2ZW50TGlzdGVuZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYWRkRG9tRXZlbnRMaXN0ZW5lcik7XG5cbnZhciBfcmVhY3REb20gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIF9yZWFjdERvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdERvbSk7XG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXJXcmFwKHRhcmdldCwgZXZlbnRUeXBlLCBjYikge1xuICAvKiBlc2xpbnQgY2FtZWxjYXNlOiAyICovXG4gIHZhciBjYWxsYmFjayA9IF9yZWFjdERvbTJbJ2RlZmF1bHQnXS51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyA/IGZ1bmN0aW9uIHJ1bihlKSB7XG4gICAgX3JlYWN0RG9tMlsnZGVmYXVsdCddLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzKGNiLCBlKTtcbiAgfSA6IGNiO1xuICByZXR1cm4gKDAsIF9hZGREb21FdmVudExpc3RlbmVyMlsnZGVmYXVsdCddKSh0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtdXRpbC9saWIvRG9tL2FkZEV2ZW50TGlzdGVuZXIuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1snZGVmYXVsdCddID0gYWRkRXZlbnRMaXN0ZW5lcjtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX0V2ZW50T2JqZWN0ID0gcmVxdWlyZSgnLi9FdmVudE9iamVjdCcpO1xuXG52YXIgX0V2ZW50T2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0V2ZW50T2JqZWN0KTtcblxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcih0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gd3JhcENhbGxiYWNrKGUpIHtcbiAgICB2YXIgbmUgPSBuZXcgX0V2ZW50T2JqZWN0MlsnZGVmYXVsdCddKGUpO1xuICAgIGNhbGxiYWNrLmNhbGwodGFyZ2V0LCBuZSk7XG4gIH1cblxuICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIHdyYXBDYWxsYmFjaywgZmFsc2UpO1xuICAgIHJldHVybiB7XG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCB3cmFwQ2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2UgaWYgKHRhcmdldC5hdHRhY2hFdmVudCkge1xuICAgIHRhcmdldC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCB3cmFwQ2FsbGJhY2spO1xuICAgIHJldHVybiB7XG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgdGFyZ2V0LmRldGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIHdyYXBDYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtdXRpbC9+L2FkZC1kb20tZXZlbnQtbGlzdGVuZXIvbGliL2luZGV4LmpzXG4gKiovIiwiLyoqXG4gKiBAaWdub3JlXG4gKiBldmVudCBvYmplY3QgZm9yIGRvbVxuICogQGF1dGhvciB5aW1pbmdoZUBnbWFpbC5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfRXZlbnRCYXNlT2JqZWN0ID0gcmVxdWlyZSgnLi9FdmVudEJhc2VPYmplY3QnKTtcblxudmFyIF9FdmVudEJhc2VPYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRXZlbnRCYXNlT2JqZWN0KTtcblxudmFyIF9vYmplY3RBc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBfb2JqZWN0QXNzaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29iamVjdEFzc2lnbik7XG5cbnZhciBUUlVFID0gdHJ1ZTtcbnZhciBGQUxTRSA9IGZhbHNlO1xudmFyIGNvbW1vblByb3BzID0gWydhbHRLZXknLCAnYnViYmxlcycsICdjYW5jZWxhYmxlJywgJ2N0cmxLZXknLCAnY3VycmVudFRhcmdldCcsICdldmVudFBoYXNlJywgJ21ldGFLZXknLCAnc2hpZnRLZXknLCAndGFyZ2V0JywgJ3RpbWVTdGFtcCcsICd2aWV3JywgJ3R5cGUnXTtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQodykge1xuICByZXR1cm4gdyA9PT0gbnVsbCB8fCB3ID09PSB1bmRlZmluZWQ7XG59XG5cbnZhciBldmVudE5vcm1hbGl6ZXJzID0gW3tcbiAgcmVnOiAvXmtleS8sXG4gIHByb3BzOiBbJ2NoYXInLCAnY2hhckNvZGUnLCAna2V5JywgJ2tleUNvZGUnLCAnd2hpY2gnXSxcbiAgZml4OiBmdW5jdGlvbiBmaXgoZXZlbnQsIG5hdGl2ZUV2ZW50KSB7XG4gICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKGV2ZW50LndoaWNoKSkge1xuICAgICAgZXZlbnQud2hpY2ggPSAhaXNOdWxsT3JVbmRlZmluZWQobmF0aXZlRXZlbnQuY2hhckNvZGUpID8gbmF0aXZlRXZlbnQuY2hhckNvZGUgOiBuYXRpdmVFdmVudC5rZXlDb2RlO1xuICAgIH1cblxuICAgIC8vIGFkZCBtZXRhS2V5IHRvIG5vbi1NYWMgYnJvd3NlcnMgKHVzZSBjdHJsIGZvciBQQyAncyBhbmQgTWV0YSBmb3IgTWFjcylcbiAgICBpZiAoZXZlbnQubWV0YUtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBldmVudC5tZXRhS2V5ID0gZXZlbnQuY3RybEtleTtcbiAgICB9XG4gIH1cbn0sIHtcbiAgcmVnOiAvXnRvdWNoLyxcbiAgcHJvcHM6IFsndG91Y2hlcycsICdjaGFuZ2VkVG91Y2hlcycsICd0YXJnZXRUb3VjaGVzJ11cbn0sIHtcbiAgcmVnOiAvXmhhc2hjaGFuZ2UkLyxcbiAgcHJvcHM6IFsnbmV3VVJMJywgJ29sZFVSTCddXG59LCB7XG4gIHJlZzogL15nZXN0dXJlY2hhbmdlJC9pLFxuICBwcm9wczogWydyb3RhdGlvbicsICdzY2FsZSddXG59LCB7XG4gIHJlZzogL14obW91c2V3aGVlbHxET01Nb3VzZVNjcm9sbCkkLyxcbiAgcHJvcHM6IFtdLFxuICBmaXg6IGZ1bmN0aW9uIGZpeChldmVudCwgbmF0aXZlRXZlbnQpIHtcbiAgICB2YXIgZGVsdGFYID0gdW5kZWZpbmVkO1xuICAgIHZhciBkZWx0YVkgPSB1bmRlZmluZWQ7XG4gICAgdmFyIGRlbHRhID0gdW5kZWZpbmVkO1xuICAgIHZhciB3aGVlbERlbHRhID0gbmF0aXZlRXZlbnQud2hlZWxEZWx0YTtcbiAgICB2YXIgYXhpcyA9IG5hdGl2ZUV2ZW50LmF4aXM7XG4gICAgdmFyIHdoZWVsRGVsdGFZID0gbmF0aXZlRXZlbnQud2hlZWxEZWx0YVk7XG4gICAgdmFyIHdoZWVsRGVsdGFYID0gbmF0aXZlRXZlbnQud2hlZWxEZWx0YVg7XG4gICAgdmFyIGRldGFpbCA9IG5hdGl2ZUV2ZW50LmRldGFpbDtcblxuICAgIC8vIGllL3dlYmtpdFxuICAgIGlmICh3aGVlbERlbHRhKSB7XG4gICAgICBkZWx0YSA9IHdoZWVsRGVsdGEgLyAxMjA7XG4gICAgfVxuXG4gICAgLy8gZ2Vja29cbiAgICBpZiAoZGV0YWlsKSB7XG4gICAgICAvLyBwcmVzcyBjb250cm9sIGUuZGV0YWlsID09IDEgZWxzZSBlLmRldGFpbCA9PSAzXG4gICAgICBkZWx0YSA9IDAgLSAoZGV0YWlsICUgMyA9PT0gMCA/IGRldGFpbCAvIDMgOiBkZXRhaWwpO1xuICAgIH1cblxuICAgIC8vIEdlY2tvXG4gICAgaWYgKGF4aXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGF4aXMgPT09IGV2ZW50LkhPUklaT05UQUxfQVhJUykge1xuICAgICAgICBkZWx0YVkgPSAwO1xuICAgICAgICBkZWx0YVggPSAwIC0gZGVsdGE7XG4gICAgICB9IGVsc2UgaWYgKGF4aXMgPT09IGV2ZW50LlZFUlRJQ0FMX0FYSVMpIHtcbiAgICAgICAgZGVsdGFYID0gMDtcbiAgICAgICAgZGVsdGFZID0gZGVsdGE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2Via2l0XG4gICAgaWYgKHdoZWVsRGVsdGFZICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlbHRhWSA9IHdoZWVsRGVsdGFZIC8gMTIwO1xuICAgIH1cbiAgICBpZiAod2hlZWxEZWx0YVggIT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVsdGFYID0gLTEgKiB3aGVlbERlbHRhWCAvIDEyMDtcbiAgICB9XG5cbiAgICAvLyDpu5jorqQgZGVsdGFZIChpZSlcbiAgICBpZiAoIWRlbHRhWCAmJiAhZGVsdGFZKSB7XG4gICAgICBkZWx0YVkgPSBkZWx0YTtcbiAgICB9XG5cbiAgICBpZiAoZGVsdGFYICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8qKlxuICAgICAgICogZGVsdGFYIG9mIG1vdXNld2hlZWwgZXZlbnRcbiAgICAgICAqIEBwcm9wZXJ0eSBkZWx0YVhcbiAgICAgICAqIEBtZW1iZXIgRXZlbnQuRG9tRXZlbnQuT2JqZWN0XG4gICAgICAgKi9cbiAgICAgIGV2ZW50LmRlbHRhWCA9IGRlbHRhWDtcbiAgICB9XG5cbiAgICBpZiAoZGVsdGFZICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8qKlxuICAgICAgICogZGVsdGFZIG9mIG1vdXNld2hlZWwgZXZlbnRcbiAgICAgICAqIEBwcm9wZXJ0eSBkZWx0YVlcbiAgICAgICAqIEBtZW1iZXIgRXZlbnQuRG9tRXZlbnQuT2JqZWN0XG4gICAgICAgKi9cbiAgICAgIGV2ZW50LmRlbHRhWSA9IGRlbHRhWTtcbiAgICB9XG5cbiAgICBpZiAoZGVsdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLyoqXG4gICAgICAgKiBkZWx0YSBvZiBtb3VzZXdoZWVsIGV2ZW50XG4gICAgICAgKiBAcHJvcGVydHkgZGVsdGFcbiAgICAgICAqIEBtZW1iZXIgRXZlbnQuRG9tRXZlbnQuT2JqZWN0XG4gICAgICAgKi9cbiAgICAgIGV2ZW50LmRlbHRhID0gZGVsdGE7XG4gICAgfVxuICB9XG59LCB7XG4gIHJlZzogL15tb3VzZXxjb250ZXh0bWVudXxjbGlja3xtc3BvaW50ZXJ8KF5ET01Nb3VzZVNjcm9sbCQpL2ksXG4gIHByb3BzOiBbJ2J1dHRvbnMnLCAnY2xpZW50WCcsICdjbGllbnRZJywgJ2J1dHRvbicsICdvZmZzZXRYJywgJ3JlbGF0ZWRUYXJnZXQnLCAnd2hpY2gnLCAnZnJvbUVsZW1lbnQnLCAndG9FbGVtZW50JywgJ29mZnNldFknLCAncGFnZVgnLCAncGFnZVknLCAnc2NyZWVuWCcsICdzY3JlZW5ZJ10sXG4gIGZpeDogZnVuY3Rpb24gZml4KGV2ZW50LCBuYXRpdmVFdmVudCkge1xuICAgIHZhciBldmVudERvYyA9IHVuZGVmaW5lZDtcbiAgICB2YXIgZG9jID0gdW5kZWZpbmVkO1xuICAgIHZhciBib2R5ID0gdW5kZWZpbmVkO1xuICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgdmFyIGJ1dHRvbiA9IG5hdGl2ZUV2ZW50LmJ1dHRvbjtcblxuICAgIC8vIENhbGN1bGF0ZSBwYWdlWC9ZIGlmIG1pc3NpbmcgYW5kIGNsaWVudFgvWSBhdmFpbGFibGVcbiAgICBpZiAodGFyZ2V0ICYmIGlzTnVsbE9yVW5kZWZpbmVkKGV2ZW50LnBhZ2VYKSAmJiAhaXNOdWxsT3JVbmRlZmluZWQobmF0aXZlRXZlbnQuY2xpZW50WCkpIHtcbiAgICAgIGV2ZW50RG9jID0gdGFyZ2V0Lm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG4gICAgICBkb2MgPSBldmVudERvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICBib2R5ID0gZXZlbnREb2MuYm9keTtcbiAgICAgIGV2ZW50LnBhZ2VYID0gbmF0aXZlRXZlbnQuY2xpZW50WCArIChkb2MgJiYgZG9jLnNjcm9sbExlZnQgfHwgYm9keSAmJiBib2R5LnNjcm9sbExlZnQgfHwgMCkgLSAoZG9jICYmIGRvYy5jbGllbnRMZWZ0IHx8IGJvZHkgJiYgYm9keS5jbGllbnRMZWZ0IHx8IDApO1xuICAgICAgZXZlbnQucGFnZVkgPSBuYXRpdmVFdmVudC5jbGllbnRZICsgKGRvYyAmJiBkb2Muc2Nyb2xsVG9wIHx8IGJvZHkgJiYgYm9keS5zY3JvbGxUb3AgfHwgMCkgLSAoZG9jICYmIGRvYy5jbGllbnRUb3AgfHwgYm9keSAmJiBib2R5LmNsaWVudFRvcCB8fCAwKTtcbiAgICB9XG5cbiAgICAvLyB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcbiAgICAvLyBkbyBub3QgdXNlIGJ1dHRvblxuICAgIGlmICghZXZlbnQud2hpY2ggJiYgYnV0dG9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChidXR0b24gJiAxKSB7XG4gICAgICAgIGV2ZW50LndoaWNoID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoYnV0dG9uICYgMikge1xuICAgICAgICBldmVudC53aGljaCA9IDM7XG4gICAgICB9IGVsc2UgaWYgKGJ1dHRvbiAmIDQpIHtcbiAgICAgICAgZXZlbnQud2hpY2ggPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXZlbnQud2hpY2ggPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkZCByZWxhdGVkVGFyZ2V0LCBpZiBuZWNlc3NhcnlcbiAgICBpZiAoIWV2ZW50LnJlbGF0ZWRUYXJnZXQgJiYgZXZlbnQuZnJvbUVsZW1lbnQpIHtcbiAgICAgIGV2ZW50LnJlbGF0ZWRUYXJnZXQgPSBldmVudC5mcm9tRWxlbWVudCA9PT0gdGFyZ2V0ID8gZXZlbnQudG9FbGVtZW50IDogZXZlbnQuZnJvbUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG59XTtcblxuZnVuY3Rpb24gcmV0VHJ1ZSgpIHtcbiAgcmV0dXJuIFRSVUU7XG59XG5cbmZ1bmN0aW9uIHJldEZhbHNlKCkge1xuICByZXR1cm4gRkFMU0U7XG59XG5cbmZ1bmN0aW9uIERvbUV2ZW50T2JqZWN0KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciB0eXBlID0gbmF0aXZlRXZlbnQudHlwZTtcblxuICB2YXIgaXNOYXRpdmUgPSB0eXBlb2YgbmF0aXZlRXZlbnQuc3RvcFByb3BhZ2F0aW9uID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBuYXRpdmVFdmVudC5jYW5jZWxCdWJibGUgPT09ICdib29sZWFuJztcblxuICBfRXZlbnRCYXNlT2JqZWN0MlsnZGVmYXVsdCddLmNhbGwodGhpcyk7XG5cbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuXG4gIC8vIGluIGNhc2UgZG9tIGV2ZW50IGhhcyBiZWVuIG1hcmsgYXMgZGVmYXVsdCBwcmV2ZW50ZWQgYnkgbG93ZXIgZG9tIG5vZGVcbiAgdmFyIGlzRGVmYXVsdFByZXZlbnRlZCA9IHJldEZhbHNlO1xuICBpZiAoJ2RlZmF1bHRQcmV2ZW50ZWQnIGluIG5hdGl2ZUV2ZW50KSB7XG4gICAgaXNEZWZhdWx0UHJldmVudGVkID0gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCA/IHJldFRydWUgOiByZXRGYWxzZTtcbiAgfSBlbHNlIGlmICgnZ2V0UHJldmVudERlZmF1bHQnIGluIG5hdGl2ZUV2ZW50KSB7XG4gICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjkxMTUxXG4gICAgaXNEZWZhdWx0UHJldmVudGVkID0gbmF0aXZlRXZlbnQuZ2V0UHJldmVudERlZmF1bHQoKSA/IHJldFRydWUgOiByZXRGYWxzZTtcbiAgfSBlbHNlIGlmICgncmV0dXJuVmFsdWUnIGluIG5hdGl2ZUV2ZW50KSB7XG4gICAgaXNEZWZhdWx0UHJldmVudGVkID0gbmF0aXZlRXZlbnQucmV0dXJuVmFsdWUgPT09IEZBTFNFID8gcmV0VHJ1ZSA6IHJldEZhbHNlO1xuICB9XG5cbiAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBpc0RlZmF1bHRQcmV2ZW50ZWQ7XG5cbiAgdmFyIGZpeEZucyA9IFtdO1xuICB2YXIgZml4Rm4gPSB1bmRlZmluZWQ7XG4gIHZhciBsID0gdW5kZWZpbmVkO1xuICB2YXIgcHJvcCA9IHVuZGVmaW5lZDtcbiAgdmFyIHByb3BzID0gY29tbW9uUHJvcHMuY29uY2F0KCk7XG5cbiAgZXZlbnROb3JtYWxpemVycy5mb3JFYWNoKGZ1bmN0aW9uIChub3JtYWxpemVyKSB7XG4gICAgaWYgKHR5cGUubWF0Y2gobm9ybWFsaXplci5yZWcpKSB7XG4gICAgICBwcm9wcyA9IHByb3BzLmNvbmNhdChub3JtYWxpemVyLnByb3BzKTtcbiAgICAgIGlmIChub3JtYWxpemVyLmZpeCkge1xuICAgICAgICBmaXhGbnMucHVzaChub3JtYWxpemVyLmZpeCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBsID0gcHJvcHMubGVuZ3RoO1xuXG4gIC8vIGNsb25lIHByb3BlcnRpZXMgb2YgdGhlIG9yaWdpbmFsIGV2ZW50IG9iamVjdFxuICB3aGlsZSAobCkge1xuICAgIHByb3AgPSBwcm9wc1stLWxdO1xuICAgIHRoaXNbcHJvcF0gPSBuYXRpdmVFdmVudFtwcm9wXTtcbiAgfVxuXG4gIC8vIGZpeCB0YXJnZXQgcHJvcGVydHksIGlmIG5lY2Vzc2FyeVxuICBpZiAoIXRoaXMudGFyZ2V0ICYmIGlzTmF0aXZlKSB7XG4gICAgdGhpcy50YXJnZXQgPSBuYXRpdmVFdmVudC5zcmNFbGVtZW50IHx8IGRvY3VtZW50OyAvLyBzcmNFbGVtZW50IG1pZ2h0IG5vdCBiZSBkZWZpbmVkIGVpdGhlclxuICB9XG5cbiAgLy8gY2hlY2sgaWYgdGFyZ2V0IGlzIGEgdGV4dCBub2RlIChzYWZhcmkpXG4gIGlmICh0aGlzLnRhcmdldCAmJiB0aGlzLnRhcmdldC5ub2RlVHlwZSA9PT0gMykge1xuICAgIHRoaXMudGFyZ2V0ID0gdGhpcy50YXJnZXQucGFyZW50Tm9kZTtcbiAgfVxuXG4gIGwgPSBmaXhGbnMubGVuZ3RoO1xuXG4gIHdoaWxlIChsKSB7XG4gICAgZml4Rm4gPSBmaXhGbnNbLS1sXTtcbiAgICBmaXhGbih0aGlzLCBuYXRpdmVFdmVudCk7XG4gIH1cblxuICB0aGlzLnRpbWVTdGFtcCA9IG5hdGl2ZUV2ZW50LnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xufVxuXG52YXIgRXZlbnRCYXNlT2JqZWN0UHJvdG8gPSBfRXZlbnRCYXNlT2JqZWN0MlsnZGVmYXVsdCddLnByb3RvdHlwZTtcblxuKDAsIF9vYmplY3RBc3NpZ24yWydkZWZhdWx0J10pKERvbUV2ZW50T2JqZWN0LnByb3RvdHlwZSwgRXZlbnRCYXNlT2JqZWN0UHJvdG8sIHtcbiAgY29uc3RydWN0b3I6IERvbUV2ZW50T2JqZWN0LFxuXG4gIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICB2YXIgZSA9IHRoaXMubmF0aXZlRXZlbnQ7XG5cbiAgICAvLyBpZiBwcmV2ZW50RGVmYXVsdCBleGlzdHMgcnVuIGl0IG9uIHRoZSBvcmlnaW5hbCBldmVudFxuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG90aGVyd2lzZSBzZXQgdGhlIHJldHVyblZhbHVlIHByb3BlcnR5IG9mIHRoZSBvcmlnaW5hbCBldmVudCB0byBGQUxTRSAoSUUpXG4gICAgICBlLnJldHVyblZhbHVlID0gRkFMU0U7XG4gICAgfVxuXG4gICAgRXZlbnRCYXNlT2JqZWN0UHJvdG8ucHJldmVudERlZmF1bHQuY2FsbCh0aGlzKTtcbiAgfSxcblxuICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbigpIHtcbiAgICB2YXIgZSA9IHRoaXMubmF0aXZlRXZlbnQ7XG5cbiAgICAvLyBpZiBzdG9wUHJvcGFnYXRpb24gZXhpc3RzIHJ1biBpdCBvbiB0aGUgb3JpZ2luYWwgZXZlbnRcbiAgICBpZiAoZS5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG90aGVyd2lzZSBzZXQgdGhlIGNhbmNlbEJ1YmJsZSBwcm9wZXJ0eSBvZiB0aGUgb3JpZ2luYWwgZXZlbnQgdG8gVFJVRSAoSUUpXG4gICAgICBlLmNhbmNlbEJ1YmJsZSA9IFRSVUU7XG4gICAgfVxuXG4gICAgRXZlbnRCYXNlT2JqZWN0UHJvdG8uc3RvcFByb3BhZ2F0aW9uLmNhbGwodGhpcyk7XG4gIH1cbn0pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBEb21FdmVudE9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy11dGlsL34vYWRkLWRvbS1ldmVudC1saXN0ZW5lci9saWIvRXZlbnRPYmplY3QuanNcbiAqKi8iLCIvKipcbiAqIEBpZ25vcmVcbiAqIERhdGVUaW1lRm9ybWF0IGZvclxuICogSW5zcGlyZWQgYnkgRGF0ZVRpbWVGb3JtYXQgZnJvbSBKREsuXG4gKiBAYXV0aG9yIHlpbWluZ2hlQGdtYWlsLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEdyZWdvcmlhbkNhbGVuZGFyID0gcmVxdWlyZSgnZ3JlZ29yaWFuLWNhbGVuZGFyJyk7XG52YXIgZW5Vc0xvY2FsZSA9IHJlcXVpcmUoJy4vbG9jYWxlL2VuX1VTJyk7XG52YXIgTUFYX1ZBTFVFID0gTnVtYmVyLk1BWF9WQUxVRTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG4vKipcbiAqIGRhdGUgb3IgdGltZSBzdHlsZSBlbnVtXG4gKiBAZW51bSB7TnVtYmVyfSBEYXRlLkZvcm1hdHRlci5TdHlsZVxuICovXG52YXIgRGF0ZVRpbWVTdHlsZSA9IHtcbiAgLyoqXG4gICAqIGZ1bGwgc3R5bGVcbiAgICovXG4gIEZVTEw6IDAsXG4gIC8qKlxuICAgKiBsb25nIHN0eWxlXG4gICAqL1xuICBMT05HOiAxLFxuICAvKipcbiAgICogbWVkaXVtIHN0eWxlXG4gICAqL1xuICBNRURJVU06IDIsXG4gIC8qKlxuICAgKiBzaG9ydCBzdHlsZVxuICAgKi9cbiAgU0hPUlQ6IDNcbn07XG5cbi8qXG4gTGV0dGVyICAgIERhdGUgb3IgVGltZSBDb21wb25lbnQgICAgUHJlc2VudGF0aW9uICAgIEV4YW1wbGVzXG4gRyAgICBFcmEgZGVzaWduYXRvciAgICBUZXh0ICAgIEFEXG4geSAgICBZZWFyICAgIFllYXIgICAgMTk5NjsgOTZcbiBZICAgIFdlZWtZZWFyICAgIFdlZWtZZWFyICAgIDE5OTY7IDk2XG4gTSAgICBNb250aCBpbiB5ZWFyICAgIE1vbnRoICAgIEp1bHk7IEp1bDsgMDdcbiB3ICAgIFdlZWsgaW4geWVhciAgICBOdW1iZXIgICAgMjdcbiBXICAgIFdlZWsgaW4gbW9udGggICAgTnVtYmVyICAgIDJcbiBEICAgIERheSBpbiB5ZWFyICAgIE51bWJlciAgICAxODlcbiBkICAgIERheSBpbiBtb250aCAgICBOdW1iZXIgICAgMTBcbiBGICAgIERheSBvZiB3ZWVrIGluIG1vbnRoICAgIE51bWJlciAgICAyXG4gRSAgICBEYXkgaW4gd2VlayAgICBUZXh0ICAgIFR1ZXNkYXk7IFR1ZVxuIGEgICAgQW0vcG0gbWFya2VyICAgIFRleHQgICAgUE1cbiBIICAgIEhvdXIgaW4gZGF5ICgwLTIzKSAgICBOdW1iZXIgICAgMFxuIGsgICAgSG91ciBpbiBkYXkgKDEtMjQpICAgIE51bWJlciAgICAyNFxuIEsgICAgSG91ciBpbiBhbS9wbSAoMC0xMSkgICAgTnVtYmVyICAgIDBcbiBoICAgIEhvdXIgaW4gYW0vcG0gKDEtMTIpICAgIE51bWJlciAgICAxMlxuIG0gICAgTWludXRlIGluIGhvdXIgICAgTnVtYmVyICAgIDMwXG4gcyAgICBTZWNvbmQgaW4gbWludXRlICAgIE51bWJlciAgICA1NVxuIFMgICAgTWlsbGlzZWNvbmQgICAgTnVtYmVyICAgIDk3OFxuIHggeiAgICBUaW1lIHpvbmUgICAgR2VuZXJhbCB0aW1lIHpvbmUgICAgUGFjaWZpYyBTdGFuZGFyZCBUaW1lOyBQU1Q7IEdNVC0wODowMFxuIFogICAgVGltZSB6b25lICAgIFJGQyA4MjIgdGltZSB6b25lICAgIC0wODAwXG4gKi9cblxudmFyIHBhdHRlcm5DaGFycyA9IG5ldyBBcnJheShHcmVnb3JpYW5DYWxlbmRhci5EQVlfT0ZfV0VFS19JTl9NT05USCArIDIpLmpvaW4oJzEnKTtcbnZhciBFUkEgPSAwO1xudmFyIGNhbGVuZGFySW5kZXhNYXAgPSB7fTtcblxucGF0dGVybkNoYXJzID0gcGF0dGVybkNoYXJzLnNwbGl0KCcnKTtcbnBhdHRlcm5DaGFyc1tFUkFdID0gJ0cnO1xucGF0dGVybkNoYXJzW0dyZWdvcmlhbkNhbGVuZGFyLllFQVJdID0gJ3knO1xucGF0dGVybkNoYXJzW0dyZWdvcmlhbkNhbGVuZGFyLk1PTlRIXSA9ICdNJztcbnBhdHRlcm5DaGFyc1tHcmVnb3JpYW5DYWxlbmRhci5EQVlfT0ZfTU9OVEhdID0gJ2QnO1xucGF0dGVybkNoYXJzW0dyZWdvcmlhbkNhbGVuZGFyLkhPVVJfT0ZfREFZXSA9ICdIJztcbnBhdHRlcm5DaGFyc1tHcmVnb3JpYW5DYWxlbmRhci5NSU5VVEVTXSA9ICdtJztcbnBhdHRlcm5DaGFyc1tHcmVnb3JpYW5DYWxlbmRhci5TRUNPTkRTXSA9ICdzJztcbnBhdHRlcm5DaGFyc1tHcmVnb3JpYW5DYWxlbmRhci5NSUxMSVNFQ09ORFNdID0gJ1MnO1xucGF0dGVybkNoYXJzW0dyZWdvcmlhbkNhbGVuZGFyLldFRUtfT0ZfWUVBUl0gPSAndyc7XG5wYXR0ZXJuQ2hhcnNbR3JlZ29yaWFuQ2FsZW5kYXIuV0VFS19PRl9NT05USF0gPSAnVyc7XG5wYXR0ZXJuQ2hhcnNbR3JlZ29yaWFuQ2FsZW5kYXIuREFZX09GX1lFQVJdID0gJ0QnO1xucGF0dGVybkNoYXJzW0dyZWdvcmlhbkNhbGVuZGFyLkRBWV9PRl9XRUVLX0lOX01PTlRIXSA9ICdGJztcbnBhdHRlcm5DaGFycy5wdXNoKCdZJyk7XG5cbnBhdHRlcm5DaGFycy5mb3JFYWNoKGZ1bmN0aW9uICh2LCBrZXkpIHtcbiAgdmFyIGsgPSBrZXk7XG4gIGlmICh2ID09PSAnWScpIHtcbiAgICBrID0gR3JlZ29yaWFuQ2FsZW5kYXIuWUVBUjtcbiAgfVxuICBpZiAodikge1xuICAgIGNhbGVuZGFySW5kZXhNYXBbdl0gPSBrO1xuICB9XG59KTtcblxuZnVuY3Rpb24gbWl4KHQsIHMpIHtcbiAgZm9yICh2YXIgcCBpbiBzKSB7XG4gICAgaWYgKHMuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgIHRbcF0gPSBzW3BdO1xuICAgIH1cbiAgfVxufVxuXG52YXIgU1VCU1RJVFVURV9SRUcgPSAvXFxcXD9cXHsoW157fV0rKVxcfS9nO1xudmFyIEVNUFRZID0gJyc7XG5cbmZ1bmN0aW9uIHN1YnN0aXR1dGUoc3RyLCBvLCByZWdleHApIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnIHx8ICFvKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHJldHVybiBzdHIucmVwbGFjZShyZWdleHAgfHwgU1VCU1RJVFVURV9SRUcsIGZ1bmN0aW9uIChtYXRjaCwgbmFtZSkge1xuICAgIGlmIChtYXRjaC5jaGFyQXQoMCkgPT09ICdcXFxcJykge1xuICAgICAgcmV0dXJuIG1hdGNoLnNsaWNlKDEpO1xuICAgIH1cbiAgICByZXR1cm4gb1tuYW1lXSA9PT0gdW5kZWZpbmVkID8gRU1QVFkgOiBvW25hbWVdO1xuICB9KTtcbn1cblxucGF0dGVybkNoYXJzID0gcGF0dGVybkNoYXJzLmpvaW4oJycpICsgJ2Foa0taRSc7XG5cbmZ1bmN0aW9uIGVuY29kZShsYXN0RmllbGQsIGNvdW50LCBjb21waWxlZFBhdHRlcm4pIHtcbiAgY29tcGlsZWRQYXR0ZXJuLnB1c2goe1xuICAgIGZpZWxkOiBsYXN0RmllbGQsXG4gICAgY291bnQ6IGNvdW50XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjb21waWxlKHBhdHRlcm4pIHtcbiAgdmFyIGxlbmd0aCA9IHBhdHRlcm4ubGVuZ3RoO1xuICB2YXIgaW5RdW90ZSA9IGZhbHNlO1xuICB2YXIgY29tcGlsZWRQYXR0ZXJuID0gW107XG4gIHZhciB0bXBCdWZmZXIgPSBudWxsO1xuICB2YXIgY291bnQgPSAwO1xuICB2YXIgbGFzdEZpZWxkID0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBjID0gcGF0dGVybi5jaGFyQXQoaSk7XG5cbiAgICBpZiAoYyA9PT0gJ1xcJycpIHtcbiAgICAgIC8vICcnIGlzIHRyZWF0ZWQgYXMgYSBzaW5nbGUgcXVvdGUgcmVnYXJkbGVzcyBvZiBiZWluZ1xuICAgICAgLy8gaW4gYSBxdW90ZWQgc2VjdGlvbi5cbiAgICAgIGlmIChpICsgMSA8IGxlbmd0aCkge1xuICAgICAgICBjID0gcGF0dGVybi5jaGFyQXQoaSArIDEpO1xuICAgICAgICBpZiAoYyA9PT0gJ1xcJycpIHtcbiAgICAgICAgICBpKys7XG4gICAgICAgICAgaWYgKGNvdW50ICE9PSAwKSB7XG4gICAgICAgICAgICBlbmNvZGUobGFzdEZpZWxkLCBjb3VudCwgY29tcGlsZWRQYXR0ZXJuKTtcbiAgICAgICAgICAgIGxhc3RGaWVsZCA9IC0xO1xuICAgICAgICAgICAgY291bnQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5RdW90ZSkge1xuICAgICAgICAgICAgdG1wQnVmZmVyICs9IGM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWluUXVvdGUpIHtcbiAgICAgICAgaWYgKGNvdW50ICE9PSAwKSB7XG4gICAgICAgICAgZW5jb2RlKGxhc3RGaWVsZCwgY291bnQsIGNvbXBpbGVkUGF0dGVybik7XG4gICAgICAgICAgbGFzdEZpZWxkID0gLTE7XG4gICAgICAgICAgY291bnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRtcEJ1ZmZlciA9ICcnO1xuICAgICAgICBpblF1b3RlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBpbGVkUGF0dGVybi5wdXNoKHtcbiAgICAgICAgICB0ZXh0OiB0bXBCdWZmZXJcbiAgICAgICAgfSk7XG4gICAgICAgIGluUXVvdGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaW5RdW90ZSkge1xuICAgICAgdG1wQnVmZmVyICs9IGM7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCEoYyA+PSAnYScgJiYgYyA8PSAneicgfHwgYyA+PSAnQScgJiYgYyA8PSAnWicpKSB7XG4gICAgICBpZiAoY291bnQgIT09IDApIHtcbiAgICAgICAgZW5jb2RlKGxhc3RGaWVsZCwgY291bnQsIGNvbXBpbGVkUGF0dGVybik7XG4gICAgICAgIGxhc3RGaWVsZCA9IC0xO1xuICAgICAgICBjb3VudCA9IDA7XG4gICAgICB9XG4gICAgICBjb21waWxlZFBhdHRlcm4ucHVzaCh7XG4gICAgICAgIHRleHQ6IGNcbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHBhdHRlcm5DaGFycy5pbmRleE9mKGMpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIHBhdHRlcm4gY2hhcmFjdGVyIFwiJyArIGMgKyAnXCInKTtcbiAgICB9XG5cbiAgICBpZiAobGFzdEZpZWxkID09PSAtMSB8fCBsYXN0RmllbGQgPT09IGMpIHtcbiAgICAgIGxhc3RGaWVsZCA9IGM7XG4gICAgICBjb3VudCsrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGVuY29kZShsYXN0RmllbGQsIGNvdW50LCBjb21waWxlZFBhdHRlcm4pO1xuICAgIGxhc3RGaWVsZCA9IGM7XG4gICAgY291bnQgPSAxO1xuICB9XG5cbiAgaWYgKGluUXVvdGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VudGVybWluYXRlZCBxdW90ZScpO1xuICB9XG5cbiAgaWYgKGNvdW50ICE9PSAwKSB7XG4gICAgZW5jb2RlKGxhc3RGaWVsZCwgY291bnQsIGNvbXBpbGVkUGF0dGVybik7XG4gIH1cblxuICByZXR1cm4gY29tcGlsZWRQYXR0ZXJuO1xufVxuXG52YXIgemVyb0RpZ2l0ID0gJzAnO1xuXG4vLyBUT0RPIHplcm9EaWdpdCBsb2NhbGl6YXRpb24/P1xuZnVuY3Rpb24gemVyb1BhZGRpbmdOdW1iZXIoX3gsIF94MiwgX3gzLCBfeDQpIHtcbiAgdmFyIF9hZ2FpbiA9IHRydWU7XG5cbiAgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7XG4gICAgdmFyIHZhbHVlID0gX3gsXG4gICAgICAgIG1pbkRpZ2l0cyA9IF94MixcbiAgICAgICAgbWF4RGlnaXRzXyA9IF94MyxcbiAgICAgICAgYiA9IF94NDtcbiAgICBfYWdhaW4gPSBmYWxzZTtcblxuICAgIC8vIE9wdGltaXphdGlvbiBmb3IgMSwgMiBhbmQgNCBkaWdpdCBudW1iZXJzLiBUaGlzIHNob3VsZFxuICAgIC8vIGNvdmVyIG1vc3QgY2FzZXMgb2YgZm9ybWF0dGluZyBkYXRlL3RpbWUgcmVsYXRlZCBpdGVtcy5cbiAgICAvLyBOb3RlOiBUaGlzIG9wdGltaXphdGlvbiBjb2RlIGFzc3VtZXMgdGhhdCBtYXhEaWdpdHMgaXNcbiAgICAvLyBlaXRoZXIgMiBvciBJbnRlZ2VyLk1BWF9WQUxVRSAobWF4SW50Q291bnQgaW4gZm9ybWF0KCkpLlxuICAgIHZhciBidWZmZXIgPSBiIHx8IFtdO1xuICAgIHZhciBtYXhEaWdpdHMgPSBtYXhEaWdpdHNfIHx8IE1BWF9WQUxVRTtcbiAgICBpZiAodmFsdWUgPj0gMCkge1xuICAgICAgaWYgKHZhbHVlIDwgMTAwICYmIG1pbkRpZ2l0cyA+PSAxICYmIG1pbkRpZ2l0cyA8PSAyKSB7XG4gICAgICAgIGlmICh2YWx1ZSA8IDEwICYmIG1pbkRpZ2l0cyA9PT0gMikge1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKHplcm9EaWdpdCk7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyLnB1c2godmFsdWUpO1xuICAgICAgICByZXR1cm4gYnVmZmVyLmpvaW4oJycpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA+PSAxMDAwICYmIHZhbHVlIDwgMTAwMDApIHtcbiAgICAgICAgaWYgKG1pbkRpZ2l0cyA9PT0gNCkge1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKHZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gYnVmZmVyLmpvaW4oJycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaW5EaWdpdHMgPT09IDIgJiYgbWF4RGlnaXRzID09PSAyKSB7XG4gICAgICAgICAgX3ggPSB2YWx1ZSAlIDEwMDtcbiAgICAgICAgICBfeDIgPSAyO1xuICAgICAgICAgIF94MyA9IDI7XG4gICAgICAgICAgX3g0ID0gYnVmZmVyO1xuICAgICAgICAgIF9hZ2FpbiA9IHRydWU7XG4gICAgICAgICAgYnVmZmVyID0gbWF4RGlnaXRzID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGNvbnRpbnVlIF9mdW5jdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBidWZmZXIucHVzaCh2YWx1ZSArICcnKTtcbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oJycpO1xuICB9XG59XG5cbi8qKlxuICpcbiAqIGRhdGUgdGltZSBmb3JtYXR0ZXIgZm9yIEdyZWdvcmlhbkNhbGVuZGFyXG4gKlxuICogICAgICBAZXhhbXBsZVxuICpcbiAqICAgICAgICAgIGNvbnN0IGNhbGVuZGFyID0gbmV3IEdyZWdvcmlhbkNhbGVuZGFyKDIwMTMsOSwyNCk7XG4gKiAgICAgICAgICAvLyAnIHRvIGVzY2FwZVxuICogICAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gbmV3IEdyZWdvcmlhbkNhbGVuZGFyRm9ybWF0KFwiJ3RvZGF5IGlzJyAnJ3l5eXkvTU0vZGQgYScnXCIpO1xuICogICAgICAgICAgZG9jdW1lbnQud3JpdGUoZm9ybWF0dGVyLmZvcm1hdChjYWxlbmRhcikpO1xuICpcbiAqIEBjbGFzcyBHcmVnb3JpYW5DYWxlbmRhckZvcm1hdFxuICogQHBhcmFtIHtTdHJpbmd9IHBhdHRlcm4gcGF0dGVyIHN0cmluZyBvZiBkYXRlIGZvcm1hdHRlclxuICpcbiAqIDx0YWJsZSBib3JkZXI9XCIxXCI+XG4gKiA8dGhlYWQgdmFsaWduPVwiYm90dG9tXCI+XG4gKiA8dHI+PHRoIGNsYXNzPVwiaGVhZFwiPkxldHRlcjwvdGg+XG4gKiA8dGggY2xhc3M9XCJoZWFkXCI+RGF0ZSBvciBUaW1lIENvbXBvbmVudDwvdGg+XG4gKiA8dGggY2xhc3M9XCJoZWFkXCI+UHJlc2VudGF0aW9uPC90aD5cbiAqIDx0aCBjbGFzcz1cImhlYWRcIj5FeGFtcGxlczwvdGg+XG4gKiA8L3RyPlxuICogPC90aGVhZD5cbiAqIDx0Ym9keSB2YWxpZ249XCJ0b3BcIj5cbiAqIDx0cj48dGQ+RzwvdGQ+XG4gKiA8dGQ+RXJhIGRlc2lnbmF0b3I8L3RkPlxuICogPHRkPlRleHQ8L3RkPlxuICogPHRkPkFEPC90ZD5cbiAqIDwvdHI+XG4gKiA8dHI+PHRkPnk8L3RkPlxuICogPHRkPlllYXI8L3RkPlxuICogPHRkPlllYXI8L3RkPlxuICogPHRkPjE5OTY7IDk2PC90ZD5cbiAqIDwvdHI+XG4gKiA8dHI+PHRkPk08L3RkPlxuICogPHRkPk1vbnRoIGluIHllYXI8L3RkPlxuICogPHRkPk1vbnRoPC90ZD5cbiAqIDx0ZD5KdWx5OyBKdWw7IDA3PC90ZD5cbiAqIDwvdHI+XG4gKiA8dHI+PHRkPnc8L3RkPlxuICogPHRkPldlZWsgaW4geWVhcjwvdGQ+XG4gKiA8dGQ+TnVtYmVyPC90ZD5cbiAqIDx0ZD4yNzwvdGQ+XG4gKiA8L3RyPlxuICogPHRyPjx0ZD5XPC90ZD5cbiAqIDx0ZD5XZWVrIGluIG1vbnRoPC90ZD5cbiAqIDx0ZD5OdW1iZXI8L3RkPlxuICogPHRkPjI8L3RkPlxuICogPC90cj5cbiAqIDx0cj48dGQ+RDwvdGQ+XG4gKiA8dGQ+RGF5IGluIHllYXI8L3RkPlxuICogPHRkPk51bWJlcjwvdGQ+XG4gKiA8dGQ+MTg5PC90ZD5cbiAqIDwvdHI+XG4gKiA8dHI+PHRkPmQ8L3RkPlxuICogPHRkPkRheSBpbiBtb250aDwvdGQ+XG4gKiA8dGQ+TnVtYmVyPC90ZD5cbiAqIDx0ZD4xMDwvdGQ+XG4gKiA8L3RyPlxuICogPHRyPjx0ZD5GPC90ZD5cbiAqIDx0ZD5EYXkgb2Ygd2VlayBpbiBtb250aDwvdGQ+XG4gKiA8dGQ+TnVtYmVyPC90ZD5cbiAqIDx0ZD4yPC90ZD5cbiAqIDwvdHI+XG4gKiA8dHI+PHRkPkU8L3RkPlxuICogPHRkPkRheSBpbiB3ZWVrPC90ZD5cbiAqIDx0ZD5UZXh0PC90ZD5cbiAqIDx0ZD5UdWVzZGF5OyBUdWU8L3RkPlxuICogPC90cj5cbiAqIDx0cj48dGQ+YTwvdGQ+XG4gKiA8dGQ+QW0vcG0gbWFya2VyPC90ZD5cbiAqIDx0ZD5UZXh0PC90ZD5cbiAqIDx0ZD5QTTwvdGQ+XG4gKiA8L3RyPlxuICogPHRyPjx0ZD5IPC90ZD5cbiAqICAgICAgIDx0ZD5Ib3VyIGluIGRheSAoMC0yMyk8L3RkPlxuICogPHRkPk51bWJlcjwvdGQ+XG4gKiA8dGQ+MDwvdGQ+XG4gKiA8L3RyPlxuICogPHRyPjx0ZD5rPC90ZD5cbiAqICAgICAgIDx0ZD5Ib3VyIGluIGRheSAoMS0yNCk8L3RkPlxuICogPHRkPk51bWJlcjwvdGQ+XG4gKiA8dGQ+MjQ8L3RkPlxuICogPC90cj5cbiAqIDx0cj48dGQ+SzwvdGQ+XG4gKiA8dGQ+SG91ciBpbiBhbS9wbSAoMC0xMSk8L3RkPlxuICogPHRkPk51bWJlcjwvdGQ+XG4gKiA8dGQ+MDwvdGQ+XG4gKiA8L3RyPlxuICogPHRyPjx0ZD5oPC90ZD5cbiAqIDx0ZD5Ib3VyIGluIGFtL3BtICgxLTEyKTwvdGQ+XG4gKiA8dGQ+TnVtYmVyPC90ZD5cbiAqIDx0ZD4xMjwvdGQ+XG4gKiA8L3RyPlxuICogPHRyPjx0ZD5tPC90ZD5cbiAqIDx0ZD5NaW51dGUgaW4gaG91cjwvdGQ+XG4gKiA8dGQ+TnVtYmVyPC90ZD5cbiAqIDx0ZD4zMDwvdGQ+XG4gKiA8L3RyPlxuICogPHRyPjx0ZD5zPC90ZD5cbiAqIDx0ZD5TZWNvbmQgaW4gbWludXRlPC90ZD5cbiAqIDx0ZD5OdW1iZXI8L3RkPlxuICogPHRkPjU1PC90ZD5cbiAqIDwvdHI+XG4gKiA8dHI+PHRkPlM8L3RkPlxuICogPHRkPk1pbGxpc2Vjb25kPC90ZD5cbiAqIDx0ZD5OdW1iZXI8L3RkPlxuICogPHRkPjk3ODwvdGQ+XG4gKiA8L3RyPlxuICogPHRyPjx0ZD54L3o8L3RkPlxuICogPHRkPlRpbWUgem9uZTwvdGQ+XG4gKiA8dGQ+R2VuZXJhbCB0aW1lIHpvbmU8L3RkPlxuICogPHRkPlBhY2lmaWMgU3RhbmRhcmQgVGltZTsgUFNUOyBHTVQtMDg6MDA8L3RkPlxuICogPC90cj5cbiAqIDx0cj48dGQ+WjwvdGQ+XG4gKiA8dGQ+VGltZSB6b25lPC90ZD5cbiAqIDx0ZD5SRkMgODIyIHRpbWUgem9uZTwvdGQ+XG4gKiA8dGQ+LTA4MDA8L3RkPlxuICogPC90cj5cbiAqIDwvdGJvZHk+XG4gKiA8L3RhYmxlPlxuXG4gKiBAcGFyYW0ge09iamVjdH0gbG9jYWxlIGZvcm1hdCBsb2NhbGVcbiAqL1xuZnVuY3Rpb24gRGF0ZVRpbWVGb3JtYXQocGF0dGVybiwgbG9jYWxlKSB7XG4gIHRoaXMubG9jYWxlID0gbG9jYWxlIHx8IGVuVXNMb2NhbGU7XG4gIHRoaXMub3JpZ2luYWxQYXR0ZXJuID0gcGF0dGVybjtcbiAgdGhpcy5wYXR0ZXJuID0gY29tcGlsZShwYXR0ZXJuKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0RmllbGQoZmllbGQsIGNvdW50LCBsb2NhbGUsIGNhbGVuZGFyKSB7XG4gIHZhciBjdXJyZW50ID0gdW5kZWZpbmVkO1xuICB2YXIgdmFsdWUgPSB1bmRlZmluZWQ7XG4gIHN3aXRjaCAoZmllbGQpIHtcbiAgICBjYXNlICdHJzpcbiAgICAgIHZhbHVlID0gY2FsZW5kYXIuZ2V0WWVhcigpID4gMCA/IDEgOiAwO1xuICAgICAgY3VycmVudCA9IGxvY2FsZS5lcmFzW3ZhbHVlXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1knOlxuICAgICAgdmFsdWUgPSBjYWxlbmRhci5nZXRXZWVrWWVhcigpO1xuICAgICAgaWYgKHZhbHVlIDw9IDApIHtcbiAgICAgICAgdmFsdWUgPSAxIC0gdmFsdWU7XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gemVyb1BhZGRpbmdOdW1iZXIodmFsdWUsIDIsIGNvdW50ICE9PSAyID8gTUFYX1ZBTFVFIDogMik7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd5JzpcbiAgICAgIHZhbHVlID0gY2FsZW5kYXIuZ2V0WWVhcigpO1xuICAgICAgaWYgKHZhbHVlIDw9IDApIHtcbiAgICAgICAgdmFsdWUgPSAxIC0gdmFsdWU7XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gemVyb1BhZGRpbmdOdW1iZXIodmFsdWUsIDIsIGNvdW50ICE9PSAyID8gTUFYX1ZBTFVFIDogMik7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdNJzpcbiAgICAgIHZhbHVlID0gY2FsZW5kYXIuZ2V0TW9udGgoKTtcbiAgICAgIGlmIChjb3VudCA+PSA0KSB7XG4gICAgICAgIGN1cnJlbnQgPSBsb2NhbGUubW9udGhzW3ZhbHVlXTtcbiAgICAgIH0gZWxzZSBpZiAoY291bnQgPT09IDMpIHtcbiAgICAgICAgY3VycmVudCA9IGxvY2FsZS5zaG9ydE1vbnRoc1t2YWx1ZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50ID0gemVyb1BhZGRpbmdOdW1iZXIodmFsdWUgKyAxLCBjb3VudCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdrJzpcbiAgICAgIGN1cnJlbnQgPSB6ZXJvUGFkZGluZ051bWJlcihjYWxlbmRhci5nZXRIb3VyT2ZEYXkoKSB8fCAyNCwgY291bnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnRSc6XG4gICAgICB2YWx1ZSA9IGNhbGVuZGFyLmdldERheU9mV2VlaygpO1xuICAgICAgY3VycmVudCA9IGNvdW50ID49IDQgPyBsb2NhbGUud2Vla2RheXNbdmFsdWVdIDogbG9jYWxlLnNob3J0V2Vla2RheXNbdmFsdWVdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYSc6XG4gICAgICBjdXJyZW50ID0gbG9jYWxlLmFtcG1zW2NhbGVuZGFyLmdldEhvdXJPZkRheSgpID49IDEyID8gMSA6IDBdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaCc6XG4gICAgICBjdXJyZW50ID0gemVyb1BhZGRpbmdOdW1iZXIoY2FsZW5kYXIuZ2V0SG91ck9mRGF5KCkgJSAxMiB8fCAxMiwgY291bnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnSyc6XG4gICAgICBjdXJyZW50ID0gemVyb1BhZGRpbmdOdW1iZXIoY2FsZW5kYXIuZ2V0SG91ck9mRGF5KCkgJSAxMiwgY291bnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnWic6XG4gICAgICB2YXIgb2Zmc2V0ID0gY2FsZW5kYXIuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgIHZhciBwYXJ0cyA9IFtvZmZzZXQgPCAwID8gJy0nIDogJysnXTtcbiAgICAgIG9mZnNldCA9IE1hdGguYWJzKG9mZnNldCk7XG4gICAgICBwYXJ0cy5wdXNoKHplcm9QYWRkaW5nTnVtYmVyKE1hdGguZmxvb3Iob2Zmc2V0IC8gNjApICUgMTAwLCAyKSwgemVyb1BhZGRpbmdOdW1iZXIob2Zmc2V0ICUgNjAsIDIpKTtcbiAgICAgIGN1cnJlbnQgPSBwYXJ0cy5qb2luKCcnKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBjYXNlICdkJzpcbiAgICAgIC8vIGNhc2UgJ0gnOlxuICAgICAgLy8gY2FzZSAnbSc6XG4gICAgICAvLyBjYXNlICdzJzpcbiAgICAgIC8vIGNhc2UgJ1MnOlxuICAgICAgLy8gY2FzZSAnRCc6XG4gICAgICAvLyBjYXNlICdGJzpcbiAgICAgIC8vIGNhc2UgJ3cnOlxuICAgICAgLy8gY2FzZSAnVyc6XG4gICAgICB2YXIgaW5kZXggPSBjYWxlbmRhckluZGV4TWFwW2ZpZWxkXTtcbiAgICAgIHZhbHVlID0gY2FsZW5kYXIuZ2V0KGluZGV4KTtcbiAgICAgIGN1cnJlbnQgPSB6ZXJvUGFkZGluZ051bWJlcih2YWx1ZSwgY291bnQpO1xuICB9XG4gIHJldHVybiBjdXJyZW50O1xufVxuXG5mdW5jdGlvbiBtYXRjaFBhcnRTdHJpbmcoZGF0ZVN0ciwgc3RhcnRJbmRleCwgbWF0Y2gsIG1MZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtTGVuOyBpKyspIHtcbiAgICBpZiAoZGF0ZVN0ci5jaGFyQXQoc3RhcnRJbmRleCArIGkpICE9PSBtYXRjaC5jaGFyQXQoaSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG1hdGNoRmllbGQoZGF0ZVN0ciwgc3RhcnRJbmRleCwgbWF0Y2hlcykge1xuICB2YXIgbWF0Y2hlZExlbiA9IC0xO1xuICB2YXIgaW5kZXggPSAtMTtcbiAgdmFyIGkgPSB1bmRlZmluZWQ7XG4gIHZhciBsZW4gPSBtYXRjaGVzLmxlbmd0aDtcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIG0gPSBtYXRjaGVzW2ldO1xuICAgIHZhciBtTGVuID0gbS5sZW5ndGg7XG4gICAgaWYgKG1MZW4gPiBtYXRjaGVkTGVuICYmIG1hdGNoUGFydFN0cmluZyhkYXRlU3RyLCBzdGFydEluZGV4LCBtLCBtTGVuKSkge1xuICAgICAgbWF0Y2hlZExlbiA9IG1MZW47XG4gICAgICBpbmRleCA9IGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmRleCA+PSAwID8ge1xuICAgIHZhbHVlOiBpbmRleCxcbiAgICBzdGFydEluZGV4OiBzdGFydEluZGV4ICsgbWF0Y2hlZExlblxuICB9IDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0TGVhZGluZ051bWJlckxlbihzdHIpIHtcbiAgdmFyIGkgPSB1bmRlZmluZWQ7XG4gIHZhciBjID0gdW5kZWZpbmVkO1xuICB2YXIgbGVuID0gc3RyLmxlbmd0aDtcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgaWYgKGMgPCAnMCcgfHwgYyA+ICc5Jykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBpO1xufVxuXG5mdW5jdGlvbiBtYXRjaE51bWJlcihkYXRlU3RyLCBzdGFydEluZGV4LCBjb3VudCwgb2JleUNvdW50KSB7XG4gIHZhciBzdHIgPSBkYXRlU3RyO1xuICB2YXIgbiA9IHVuZGVmaW5lZDtcbiAgaWYgKG9iZXlDb3VudCkge1xuICAgIGlmIChkYXRlU3RyLmxlbmd0aCA8IHN0YXJ0SW5kZXggKyBjb3VudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHN0ciA9IGRhdGVTdHIuc2xpY2Uoc3RhcnRJbmRleCwgc3RhcnRJbmRleCArIGNvdW50KTtcbiAgICBpZiAoIXN0ci5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignR3JlZ29yaWFuQ2FsZW5kYXJGb3JtYXQgcGFyc2UgZXJyb3IsIGRhdGVTdHI6ICcgKyBkYXRlU3RyICsgJywgcGF0dGVyOiAnICsgdGhpcy5vcmlnaW5hbFBhdHRlcm4pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdHIgPSBzdHIuc2xpY2Uoc3RhcnRJbmRleCk7XG4gIH1cbiAgbiA9IHBhcnNlSW50KHN0ciwgMTApO1xuICBpZiAoaXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0dyZWdvcmlhbkNhbGVuZGFyRm9ybWF0IHBhcnNlIGVycm9yLCBkYXRlU3RyOiAnICsgZGF0ZVN0ciArICcsIHBhdHRlcjogJyArIHRoaXMub3JpZ2luYWxQYXR0ZXJuKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbHVlOiBuLFxuICAgIHN0YXJ0SW5kZXg6IHN0YXJ0SW5kZXggKyBnZXRMZWFkaW5nTnVtYmVyTGVuKHN0cilcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VGaWVsZChjYWxlbmRhciwgZGF0ZVN0ciwgc3RhcnRJbmRleF8sIGZpZWxkLCBjb3VudCwgb2JleUNvdW50LCB0bXApIHtcbiAgdmFyIG1hdGNoID0gdW5kZWZpbmVkO1xuICB2YXIgeWVhciA9IHVuZGVmaW5lZDtcbiAgdmFyIGhvdXIgPSB1bmRlZmluZWQ7XG4gIHZhciBzdGFydEluZGV4ID0gc3RhcnRJbmRleF87XG4gIGlmIChkYXRlU3RyLmxlbmd0aCA8PSBzdGFydEluZGV4KSB7XG4gICAgcmV0dXJuIHN0YXJ0SW5kZXg7XG4gIH1cbiAgdmFyIGxvY2FsZSA9IHRoaXMubG9jYWxlO1xuICBzd2l0Y2ggKGZpZWxkKSB7XG4gICAgY2FzZSAnRyc6XG4gICAgICBtYXRjaCA9IG1hdGNoRmllbGQoZGF0ZVN0ciwgc3RhcnRJbmRleCwgbG9jYWxlLmVyYXMpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGlmIChjYWxlbmRhci5pc1NldFllYXIoKSkge1xuICAgICAgICAgIGlmIChtYXRjaC52YWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgeWVhciA9IGNhbGVuZGFyLmdldFllYXIoKTtcbiAgICAgICAgICAgIGNhbGVuZGFyLnNldFllYXIoMSAtIHllYXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0bXAuZXJhID0gbWF0Y2gudmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3knOlxuICAgICAgbWF0Y2ggPSBtYXRjaE51bWJlci5jYWxsKHRoaXMsIGRhdGVTdHIsIHN0YXJ0SW5kZXgsIGNvdW50LCBvYmV5Q291bnQpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHllYXIgPSBtYXRjaC52YWx1ZTtcbiAgICAgICAgaWYgKCdlcmEnIGluIHRtcCkge1xuICAgICAgICAgIGlmICh0bXAuZXJhID09PSAwKSB7XG4gICAgICAgICAgICB5ZWFyID0gMSAtIHllYXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhbGVuZGFyLnNldFllYXIoeWVhcik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdNJzpcbiAgICAgIHZhciBtb250aCA9IHVuZGVmaW5lZDtcbiAgICAgIGlmIChjb3VudCA+PSAzKSB7XG4gICAgICAgIG1hdGNoID0gbWF0Y2hGaWVsZChkYXRlU3RyLCBzdGFydEluZGV4LCBsb2NhbGVbY291bnQgPT09IDMgPyAnc2hvcnRNb250aHMnIDogJ21vbnRocyddKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgbW9udGggPSBtYXRjaC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0Y2ggPSBtYXRjaE51bWJlci5jYWxsKHRoaXMsIGRhdGVTdHIsIHN0YXJ0SW5kZXgsIGNvdW50LCBvYmV5Q291bnQpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICBtb250aCA9IG1hdGNoLnZhbHVlIC0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGNhbGVuZGFyLnNldE1vbnRoKG1vbnRoKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2snOlxuICAgICAgbWF0Y2ggPSBtYXRjaE51bWJlci5jYWxsKHRoaXMsIGRhdGVTdHIsIHN0YXJ0SW5kZXgsIGNvdW50LCBvYmV5Q291bnQpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGNhbGVuZGFyLnNldEhvdXJPZkRheShtYXRjaC52YWx1ZSAlIDI0KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0UnOlxuICAgICAgbWF0Y2ggPSBtYXRjaEZpZWxkKGRhdGVTdHIsIHN0YXJ0SW5kZXgsIGxvY2FsZVtjb3VudCA+IDMgPyAnd2Vla2RheXMnIDogJ3Nob3J0V2Vla2RheXMnXSk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgY2FsZW5kYXIuc2V0RGF5T2ZXZWVrKG1hdGNoLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2EnOlxuICAgICAgbWF0Y2ggPSBtYXRjaEZpZWxkKGRhdGVTdHIsIHN0YXJ0SW5kZXgsIGxvY2FsZS5hbXBtcyk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgaWYgKGNhbGVuZGFyLmlzU2V0SG91ck9mRGF5KCkpIHtcbiAgICAgICAgICBpZiAobWF0Y2gudmFsdWUpIHtcbiAgICAgICAgICAgIGhvdXIgPSBjYWxlbmRhci5nZXRIb3VyT2ZEYXkoKTtcbiAgICAgICAgICAgIGlmIChob3VyIDwgMTIpIHtcbiAgICAgICAgICAgICAgY2FsZW5kYXIuc2V0SG91ck9mRGF5KChob3VyICsgMTIpICUgMjQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0bXAuYW1wbSA9IG1hdGNoLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdoJzpcbiAgICAgIG1hdGNoID0gbWF0Y2hOdW1iZXIuY2FsbCh0aGlzLCBkYXRlU3RyLCBzdGFydEluZGV4LCBjb3VudCwgb2JleUNvdW50KTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBob3VyID0gbWF0Y2gudmFsdWUgJT0gMTI7XG4gICAgICAgIGlmICh0bXAuYW1wbSkge1xuICAgICAgICAgIGhvdXIgKz0gMTI7XG4gICAgICAgIH1cbiAgICAgICAgY2FsZW5kYXIuc2V0SG91ck9mRGF5KGhvdXIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnSyc6XG4gICAgICBtYXRjaCA9IG1hdGNoTnVtYmVyLmNhbGwodGhpcywgZGF0ZVN0ciwgc3RhcnRJbmRleCwgY291bnQsIG9iZXlDb3VudCk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgaG91ciA9IG1hdGNoLnZhbHVlO1xuICAgICAgICBpZiAodG1wLmFtcG0pIHtcbiAgICAgICAgICBob3VyICs9IDEyO1xuICAgICAgICB9XG4gICAgICAgIGNhbGVuZGFyLnNldEhvdXJPZkRheShob3VyKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1onOlxuICAgICAgLy8gbGV0IHNpZ24gPSAxO1xuICAgICAgdmFyIHpvbmVDaGFyID0gZGF0ZVN0ci5jaGFyQXQoc3RhcnRJbmRleCk7XG4gICAgICBpZiAoem9uZUNoYXIgPT09ICctJykge1xuICAgICAgICAvLyBzaWduID0gLTE7XG4gICAgICAgIHN0YXJ0SW5kZXgrKztcbiAgICAgIH0gZWxzZSBpZiAoem9uZUNoYXIgPT09ICcrJykge1xuICAgICAgICBzdGFydEluZGV4Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG1hdGNoID0gbWF0Y2hOdW1iZXIuY2FsbCh0aGlzLCBkYXRlU3RyLCBzdGFydEluZGV4LCAyLCB0cnVlKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICB2YXIgem9uZU9mZnNldCA9IG1hdGNoLnZhbHVlICogNjA7XG4gICAgICAgIHN0YXJ0SW5kZXggPSBtYXRjaC5zdGFydEluZGV4O1xuICAgICAgICBtYXRjaCA9IG1hdGNoTnVtYmVyLmNhbGwodGhpcywgZGF0ZVN0ciwgc3RhcnRJbmRleCwgMiwgdHJ1ZSk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIHpvbmVPZmZzZXQgKz0gbWF0Y2gudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY2FsZW5kYXIuc2V0VGltZXpvbmVPZmZzZXQoem9uZU9mZnNldCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gY2FzZSAnZCc6XG4gICAgICAvLyBjYXNlICdIJzpcbiAgICAgIC8vIGNhc2UgJ20nOlxuICAgICAgLy8gY2FzZSAncyc6XG4gICAgICAvLyBjYXNlICdTJzpcbiAgICAgIC8vIGNhc2UgJ0QnOlxuICAgICAgLy8gY2FzZSAnRic6XG4gICAgICAvLyBjYXNlICd3JzpcbiAgICAgIC8vIGNhc2UgJ1cnXG4gICAgICBtYXRjaCA9IG1hdGNoTnVtYmVyLmNhbGwodGhpcywgZGF0ZVN0ciwgc3RhcnRJbmRleCwgY291bnQsIG9iZXlDb3VudCk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gY2FsZW5kYXJJbmRleE1hcFtmaWVsZF07XG4gICAgICAgIGNhbGVuZGFyLnNldChpbmRleCwgbWF0Y2gudmFsdWUpO1xuICAgICAgfVxuICB9XG4gIGlmIChtYXRjaCkge1xuICAgIHN0YXJ0SW5kZXggPSBtYXRjaC5zdGFydEluZGV4O1xuICB9XG4gIHJldHVybiBzdGFydEluZGV4O1xufVxuXG5taXgoRGF0ZVRpbWVGb3JtYXQucHJvdG90eXBlLCB7XG4gIC8qXG4gICAqIGZvcm1hdCBhIEdyZWdvcmlhbkRhdGUgaW5zdGFuY2UgYWNjb3JkaW5nIHRvIHNwZWNpZmllZCBwYXR0ZXJuXG4gICAqIEBwYXJhbSB7R3JlZ29yaWFuQ2FsZW5kYXJ9IGNhbGVuZGFyIEdyZWdvcmlhbkRhdGUgaW5zdGFuY2VcbiAgICogQHJldHVybnMge3N0cmluZ30gZm9ybWF0dGVkIHN0cmluZyBvZiBHcmVnb3JpYW5EYXRlIGluc3RhbmNlXG4gICAqL1xuICBmb3JtYXQ6IGZ1bmN0aW9uIGZvcm1hdChjYWxlbmRhcikge1xuICAgIGlmICghY2FsZW5kYXIuaXNHcmVnb3JpYW5DYWxlbmRhcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYWxlbmRhciBtdXN0IGJlIHR5cGUgb2YgR3JlZ29yaWFuQ2FsZW5kYXInKTtcbiAgICB9XG4gICAgdmFyIGkgPSB1bmRlZmluZWQ7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIHZhciBwYXR0ZXJuID0gdGhpcy5wYXR0ZXJuO1xuICAgIHZhciBsZW4gPSBwYXR0ZXJuLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBjb21wID0gcGF0dGVybltpXTtcbiAgICAgIGlmIChjb21wLnRleHQpIHtcbiAgICAgICAgcmV0LnB1c2goY29tcC50ZXh0KTtcbiAgICAgIH0gZWxzZSBpZiAoJ2ZpZWxkJyBpbiBjb21wKSB7XG4gICAgICAgIHJldC5wdXNoKGZvcm1hdEZpZWxkKGNvbXAuZmllbGQsIGNvbXAuY291bnQsIHRoaXMubG9jYWxlLCBjYWxlbmRhcikpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0LmpvaW4oJycpO1xuICB9LFxuXG4gIC8qXG4gICAqIHBhcnNlIGEgZm9ybWF0dGVkIHN0cmluZyBvZiBHcmVnb3JpYW5EYXRlIGluc3RhbmNlIGFjY29yZGluZyB0byBzcGVjaWZpZWQgcGF0dGVyblxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0ZVN0ciBmb3JtYXR0ZWQgc3RyaW5nIG9mIEdyZWdvcmlhbkRhdGVcbiAgICogQHJldHVybnMge0dyZWdvcmlhbkNhbGVuZGFyfVxuICAgKi9cbiAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKGRhdGVTdHIsIG9wdGlvbl8pIHtcbiAgICB2YXIgb3B0aW9uID0gb3B0aW9uXyB8fCB7fTtcbiAgICB2YXIgY2FsZW5kYXJMb2NhbGUgPSBvcHRpb24ubG9jYWxlO1xuICAgIHZhciBjYWxlbmRhciA9IG5ldyBHcmVnb3JpYW5DYWxlbmRhcihjYWxlbmRhckxvY2FsZSk7XG4gICAgdmFyIGkgPSB1bmRlZmluZWQ7XG4gICAgdmFyIGogPSB1bmRlZmluZWQ7XG4gICAgdmFyIHRtcCA9IHt9O1xuICAgIHZhciBvYmV5Q291bnQgPSBvcHRpb24ub2JleUNvdW50IHx8IGZhbHNlO1xuICAgIHZhciBkYXRlU3RyTGVuID0gZGF0ZVN0ci5sZW5ndGg7XG4gICAgdmFyIGVycm9ySW5kZXggPSAtMTtcbiAgICB2YXIgc3RhcnRJbmRleCA9IDA7XG4gICAgdmFyIG9sZFN0YXJ0SW5kZXggPSAwO1xuICAgIHZhciBwYXR0ZXJuID0gdGhpcy5wYXR0ZXJuO1xuICAgIHZhciBsZW4gPSBwYXR0ZXJuLmxlbmd0aDtcbiAgICAvKiBlc2xpbnQgbm8tbGFiZWxzOiAwIG5vLWVtcHR5LWxhYmVsOjAgKi9cbiAgICBsb29wUGF0dGVybjoge1xuICAgICAgZm9yIChpID0gMDsgZXJyb3JJbmRleCA8IDAgJiYgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBjb21wID0gcGF0dGVybltpXTtcbiAgICAgICAgdmFyIHRleHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciB0ZXh0TGVuID0gdW5kZWZpbmVkO1xuICAgICAgICBvbGRTdGFydEluZGV4ID0gc3RhcnRJbmRleDtcbiAgICAgICAgdGV4dCA9IGNvbXAudGV4dDtcbiAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICB0ZXh0TGVuID0gdGV4dC5sZW5ndGg7XG4gICAgICAgICAgaWYgKHRleHRMZW4gKyBzdGFydEluZGV4ID4gZGF0ZVN0ckxlbikge1xuICAgICAgICAgICAgZXJyb3JJbmRleCA9IHN0YXJ0SW5kZXg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB0ZXh0TGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgaWYgKHRleHQuY2hhckF0KGopICE9PSBkYXRlU3RyLmNoYXJBdChqICsgc3RhcnRJbmRleCkpIHtcbiAgICAgICAgICAgICAgICBlcnJvckluZGV4ID0gc3RhcnRJbmRleDtcbiAgICAgICAgICAgICAgICBicmVhayBsb29wUGF0dGVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnRJbmRleCArPSB0ZXh0TGVuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICgnZmllbGQnIGluIGNvbXApIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbi5vYmV5Q291bnQpIHtcbiAgICAgICAgICAgIHZhciBuZXh0Q29tcCA9IHBhdHRlcm5baSArIDFdO1xuICAgICAgICAgICAgb2JleUNvdW50ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAobmV4dENvbXApIHtcbiAgICAgICAgICAgICAgaWYgKCdmaWVsZCcgaW4gbmV4dENvbXApIHtcbiAgICAgICAgICAgICAgICBvYmV5Q291bnQgPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjID0gbmV4dENvbXAudGV4dC5jaGFyQXQoMCk7XG4gICAgICAgICAgICAgICAgaWYgKGMgPj0gJzAnICYmIGMgPD0gJzknKSB7XG4gICAgICAgICAgICAgICAgICBvYmV5Q291bnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzdGFydEluZGV4ID0gcGFyc2VGaWVsZC5jYWxsKHRoaXMsIGNhbGVuZGFyLCBkYXRlU3RyLCBzdGFydEluZGV4LCBjb21wLmZpZWxkLCBjb21wLmNvdW50LCBvYmV5Q291bnQsIHRtcCk7XG4gICAgICAgICAgaWYgKHN0YXJ0SW5kZXggPT09IG9sZFN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgIGVycm9ySW5kZXggPSBzdGFydEluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlcnJvckluZGV4ID49IDApIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdlcnJvciB3aGVuIHBhcnNpbmcgZGF0ZTogJyArIGRhdGVTdHIgKyAnLCBwb3NpdGlvbjogJyArIGRhdGVTdHIuc2xpY2UoMCwgZXJyb3JJbmRleCkgKyAnXicpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGVuZGFyO1xuICB9XG59KTtcblxubWl4KERhdGVUaW1lRm9ybWF0LCB7XG4gIFN0eWxlOiBEYXRlVGltZVN0eWxlLFxuXG4gIC8qXG4gICAqIGdldCBhIGZvcm1hdHRlciBpbnN0YW5jZSBvZiBzaG9ydCBzdHlsZSBwYXR0ZXJuLlxuICAgKiBlbi11czogTS9kL3l5IGg6bW0gYVxuICAgKiB6aC1jbjogeXktTS1kIGFoOm1tXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsb2NhbGUgbG9jYWxlIG9iamVjdFxuICAgKiBAcmV0dXJucyB7R3JlZ29yaWFuQ2FsZW5kYXJ9XG4gICAqIEBzdGF0aWNcbiAgICovXG4gIGdldEluc3RhbmNlOiBmdW5jdGlvbiBnZXRJbnN0YW5jZShsb2NhbGUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXREYXRlVGltZUluc3RhbmNlKERhdGVUaW1lU3R5bGUuU0hPUlQsIERhdGVUaW1lU3R5bGUuU0hPUlQsIGxvY2FsZSk7XG4gIH0sXG5cbiAgLypcbiAgICogZ2V0IGEgZm9ybWF0dGVyIGluc3RhbmNlIG9mIHNwZWNpZmllZCBkYXRlIHN0eWxlLlxuICAgKiBAcGFyYW0ge0RhdGUuRm9ybWF0dGVyLlN0eWxlfSBkYXRlU3R5bGUgZGF0ZSBmb3JtYXQgc3R5bGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGxvY2FsZVxuICAgKiBAcmV0dXJucyB7R3JlZ29yaWFuQ2FsZW5kYXJ9XG4gICAqIEBzdGF0aWNcbiAgICovXG4gIGdldERhdGVJbnN0YW5jZTogZnVuY3Rpb24gZ2V0RGF0ZUluc3RhbmNlKGRhdGVTdHlsZSwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGF0ZVRpbWVJbnN0YW5jZShkYXRlU3R5bGUsIHVuZGVmaW5lZCwgbG9jYWxlKTtcbiAgfSxcblxuICAvKlxuICAgKiBnZXQgYSBmb3JtYXR0ZXIgaW5zdGFuY2Ugb2Ygc3BlY2lmaWVkIGRhdGUgc3R5bGUgYW5kIHRpbWUgc3R5bGUuXG4gICAqIEBwYXJhbSB7RGF0ZS5Gb3JtYXR0ZXIuU3R5bGV9IGRhdGVTdHlsZSBkYXRlIGZvcm1hdCBzdHlsZVxuICAgKiBAcGFyYW0ge0RhdGUuRm9ybWF0dGVyLlN0eWxlfSB0aW1lU3R5bGUgdGltZSBmb3JtYXQgc3R5bGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGxvY2FsZVxuICAgKiBAcmV0dXJucyB7R3JlZ29yaWFuQ2FsZW5kYXJ9XG4gICAqIEBzdGF0aWNcbiAgICovXG4gIGdldERhdGVUaW1lSW5zdGFuY2U6IGZ1bmN0aW9uIGdldERhdGVUaW1lSW5zdGFuY2UoZGF0ZVN0eWxlLCB0aW1lU3R5bGUsIGxvY2FsZV8pIHtcbiAgICB2YXIgbG9jYWxlID0gbG9jYWxlXyB8fCBlblVzTG9jYWxlO1xuICAgIHZhciBkYXRlUGF0dGVybiA9ICcnO1xuICAgIGlmIChkYXRlU3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZGF0ZVBhdHRlcm4gPSBsb2NhbGUuZGF0ZVBhdHRlcm5zW2RhdGVTdHlsZV07XG4gICAgfVxuICAgIHZhciB0aW1lUGF0dGVybiA9ICcnO1xuICAgIGlmICh0aW1lU3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZVBhdHRlcm4gPSBsb2NhbGUudGltZVBhdHRlcm5zW3RpbWVTdHlsZV07XG4gICAgfVxuICAgIHZhciBwYXR0ZXJuID0gZGF0ZVBhdHRlcm47XG4gICAgaWYgKHRpbWVQYXR0ZXJuKSB7XG4gICAgICBpZiAoZGF0ZVBhdHRlcm4pIHtcbiAgICAgICAgcGF0dGVybiA9IHN1YnN0aXR1dGUobG9jYWxlLmRhdGVUaW1lUGF0dGVybiwge1xuICAgICAgICAgIGRhdGU6IGRhdGVQYXR0ZXJuLFxuICAgICAgICAgIHRpbWU6IHRpbWVQYXR0ZXJuXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0dGVybiA9IHRpbWVQYXR0ZXJuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGVUaW1lRm9ybWF0KHBhdHRlcm4sIGxvY2FsZSk7XG4gIH0sXG5cbiAgLypcbiAgICogZ2V0IGEgZm9ybWF0dGVyIGluc3RhbmNlIG9mIHNwZWNpZmllZCB0aW1lIHN0eWxlLlxuICAgKiBAcGFyYW0ge0RhdGUuRm9ybWF0dGVyLlN0eWxlfSB0aW1lU3R5bGUgdGltZSBmb3JtYXQgc3R5bGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGxvY2FsZVxuICAgKiBAcmV0dXJucyB7R3JlZ29yaWFuQ2FsZW5kYXJ9XG4gICAqIEBzdGF0aWNcbiAgICovXG4gIGdldFRpbWVJbnN0YW5jZTogZnVuY3Rpb24gZ2V0VGltZUluc3RhbmNlKHRpbWVTdHlsZSwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGF0ZVRpbWVJbnN0YW5jZSh1bmRlZmluZWQsIHRpbWVTdHlsZSwgbG9jYWxlKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0ZVRpbWVGb3JtYXQ7XG5cbkRhdGVUaW1lRm9ybWF0LnZlcnNpb24gPSAnQFZFUlNJT05AJztcblxuLy8gZ2NfZm9ybWF0QDE2My5jb21cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vZ3JlZ29yaWFuLWNhbGVuZGFyLWZvcm1hdC9saWIvZ3JlZ29yaWFuLWNhbGVuZGFyLWZvcm1hdC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL1RyaWdnZXInKTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvfi9yYy10cmlnZ2VyL2xpYi9pbmRleC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yZWFjdERvbSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgX3JlYWN0RG9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0RG9tKTtcblxudmFyIF9yY1V0aWwgPSByZXF1aXJlKCdyYy11dGlsJyk7XG5cbnZhciBfUG9wdXAgPSByZXF1aXJlKCcuL1BvcHVwJyk7XG5cbnZhciBfUG9wdXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUG9wdXApO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIHJldHVybkVtcHR5U3RyaW5nKCkge1xuICByZXR1cm4gJyc7XG59XG5cbnZhciBBTExfSEFORExFUlMgPSBbJ29uQ2xpY2snLCAnb25Nb3VzZURvd24nLCAnb25Ub3VjaFN0YXJ0JywgJ29uTW91c2VFbnRlcicsICdvbk1vdXNlTGVhdmUnLCAnb25Gb2N1cycsICdvbkJsdXInXTtcblxudmFyIFRyaWdnZXIgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnVHJpZ2dlcicsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgYWN0aW9uOiBfcmVhY3QuUHJvcFR5cGVzLmFueSxcbiAgICBzaG93QWN0aW9uOiBfcmVhY3QuUHJvcFR5cGVzLmFueSxcbiAgICBoaWRlQWN0aW9uOiBfcmVhY3QuUHJvcFR5cGVzLmFueSxcbiAgICBnZXRQb3B1cENsYXNzTmFtZUZyb21BbGlnbjogX3JlYWN0LlByb3BUeXBlcy5hbnksXG4gICAgb25Qb3B1cFZpc2libGVDaGFuZ2U6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBhZnRlclBvcHVwVmlzaWJsZUNoYW5nZTogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIHBvcHVwOiBfcmVhY3QuUHJvcFR5cGVzLm5vZGUuaXNSZXF1aXJlZCxcbiAgICBwb3B1cFN0eWxlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBwcmVmaXhDbHM6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHBvcHVwQ2xhc3NOYW1lOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBwb3B1cFBsYWNlbWVudDogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgYnVpbHRpblBsYWNlbWVudHM6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIHBvcHVwVHJhbnNpdGlvbk5hbWU6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHBvcHVwQW5pbWF0aW9uOiBfcmVhY3QuUHJvcFR5cGVzLmFueSxcbiAgICBtb3VzZUVudGVyRGVsYXk6IF9yZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgIG1vdXNlTGVhdmVEZWxheTogX3JlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgekluZGV4OiBfcmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICBmb2N1c0RlbGF5OiBfcmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICBibHVyRGVsYXk6IF9yZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgIGdldFBvcHVwQ29udGFpbmVyOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgZGVzdHJveVBvcHVwT25IaWRlOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgbWFzazogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIG9uUG9wdXBBbGlnbjogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIHBvcHVwQWxpZ246IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIHBvcHVwVmlzaWJsZTogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIG1hc2tUcmFuc2l0aW9uTmFtZTogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgbWFza0FuaW1hdGlvbjogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmdcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHJlZml4Q2xzOiAncmMtdHJpZ2dlci1wb3B1cCcsXG4gICAgICBnZXRQb3B1cENsYXNzTmFtZUZyb21BbGlnbjogcmV0dXJuRW1wdHlTdHJpbmcsXG4gICAgICBvblBvcHVwVmlzaWJsZUNoYW5nZTogbm9vcCxcbiAgICAgIGFmdGVyUG9wdXBWaXNpYmxlQ2hhbmdlOiBub29wLFxuICAgICAgb25Qb3B1cEFsaWduOiBub29wLFxuICAgICAgcG9wdXBDbGFzc05hbWU6ICcnLFxuICAgICAgbW91c2VFbnRlckRlbGF5OiAwLFxuICAgICAgbW91c2VMZWF2ZURlbGF5OiAwLjEsXG4gICAgICBmb2N1c0RlbGF5OiAwLFxuICAgICAgYmx1ckRlbGF5OiAwLjE1LFxuICAgICAgcG9wdXBTdHlsZToge30sXG4gICAgICBkZXN0cm95UG9wdXBPbkhpZGU6IGZhbHNlLFxuICAgICAgcG9wdXBBbGlnbjoge30sXG4gICAgICBkZWZhdWx0UG9wdXBWaXNpYmxlOiBmYWxzZSxcbiAgICAgIG1hc2s6IGZhbHNlLFxuICAgICAgYWN0aW9uOiBbXSxcbiAgICAgIHNob3dBY3Rpb246IFtdLFxuICAgICAgaGlkZUFjdGlvbjogW11cbiAgICB9O1xuICB9LFxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBwb3B1cFZpc2libGUgPSB2b2lkIDA7XG4gICAgaWYgKCdwb3B1cFZpc2libGUnIGluIHByb3BzKSB7XG4gICAgICBwb3B1cFZpc2libGUgPSAhIXByb3BzLnBvcHVwVmlzaWJsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9wdXBWaXNpYmxlID0gISFwcm9wcy5kZWZhdWx0UG9wdXBWaXNpYmxlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcG9wdXBWaXNpYmxlOiBwb3B1cFZpc2libGVcbiAgICB9O1xuICB9LFxuICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5jb21wb25lbnREaWRVcGRhdGUoe30sIHtcbiAgICAgIHBvcHVwVmlzaWJsZTogdGhpcy5zdGF0ZS5wb3B1cFZpc2libGVcbiAgICB9KTtcbiAgfSxcbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICBpZiAoJ3BvcHVwVmlzaWJsZScgaW4gbmV4dFByb3BzKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgcG9wdXBWaXNpYmxlOiAhIW5leHRQcm9wcy5wb3B1cFZpc2libGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgY29tcG9uZW50RGlkVXBkYXRlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGlmICh0aGlzLnBvcHVwUmVuZGVyZWQpIHtcbiAgICAgIHZhciBfcmV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VsZiA9IF90aGlzO1xuICAgICAgICBfcmVhY3REb20yW1wiZGVmYXVsdFwiXS51bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihfdGhpcywgX3RoaXMuZ2V0UG9wdXBFbGVtZW50KCksIF90aGlzLmdldFBvcHVwQ29udGFpbmVyKCksIGZ1bmN0aW9uIHJlbmRlclBvcHVwKCkge1xuICAgICAgICAgIC8qIGVzbGludCByZWFjdC9uby1pcy1tb3VudGVkOjAgKi9cbiAgICAgICAgICBpZiAodGhpcy5pc01vdW50ZWQoKSkge1xuICAgICAgICAgICAgc2VsZi5wb3B1cERvbU5vZGUgPSB0aGlzLmdldFBvcHVwRG9tTm9kZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLnBvcHVwRG9tTm9kZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmV2U3RhdGUucG9wdXBWaXNpYmxlICE9PSBzdGF0ZS5wb3B1cFZpc2libGUpIHtcbiAgICAgICAgICAgIHByb3BzLmFmdGVyUG9wdXBWaXNpYmxlQ2hhbmdlKHN0YXRlLnBvcHVwVmlzaWJsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByb3BzLmFjdGlvbi5pbmRleE9mKCdjbGljaycpICE9PSAtMSkge1xuICAgICAgICAgIGlmIChzdGF0ZS5wb3B1cFZpc2libGUpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuY2xpY2tPdXRzaWRlSGFuZGxlcikge1xuICAgICAgICAgICAgICBfdGhpcy5jbGlja091dHNpZGVIYW5kbGVyID0gX3JjVXRpbC5Eb20uYWRkRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgJ21vdXNlZG93bicsIF90aGlzLm9uRG9jdW1lbnRDbGljayk7XG4gICAgICAgICAgICAgIF90aGlzLnRvdWNoT3V0c2lkZUhhbmRsZXIgPSBfcmNVdGlsLkRvbS5hZGRFdmVudExpc3RlbmVyKGRvY3VtZW50LCAndG91Y2hzdGFydCcsIF90aGlzLm9uRG9jdW1lbnRDbGljayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB2OiB2b2lkIDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChfdGhpcy5jbGlja091dHNpZGVIYW5kbGVyKSB7XG4gICAgICAgICAgX3RoaXMuY2xpY2tPdXRzaWRlSGFuZGxlci5yZW1vdmUoKTtcbiAgICAgICAgICBfdGhpcy50b3VjaE91dHNpZGVIYW5kbGVyLnJlbW92ZSgpO1xuICAgICAgICAgIF90aGlzLmNsaWNrT3V0c2lkZUhhbmRsZXIgPSBudWxsO1xuICAgICAgICAgIF90aGlzLnRvdWNoT3V0c2lkZUhhbmRsZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9KCk7XG5cbiAgICAgIGlmICgodHlwZW9mIF9yZXQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKF9yZXQpKSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQudjtcbiAgICB9XG4gIH0sXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB2YXIgcG9wdXBDb250YWluZXIgPSB0aGlzLnBvcHVwQ29udGFpbmVyO1xuICAgIGlmIChwb3B1cENvbnRhaW5lcikge1xuICAgICAgX3JlYWN0RG9tMltcImRlZmF1bHRcIl0udW5tb3VudENvbXBvbmVudEF0Tm9kZShwb3B1cENvbnRhaW5lcik7XG4gICAgICBwb3B1cENvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHBvcHVwQ29udGFpbmVyKTtcbiAgICAgIHRoaXMucG9wdXBDb250YWluZXIgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmNsZWFyRGVsYXlUaW1lcigpO1xuICAgIGlmICh0aGlzLmNsaWNrT3V0c2lkZUhhbmRsZXIpIHtcbiAgICAgIHRoaXMuY2xpY2tPdXRzaWRlSGFuZGxlci5yZW1vdmUoKTtcbiAgICAgIHRoaXMudG91Y2hPdXRzaWRlSGFuZGxlci5yZW1vdmUoKTtcbiAgICAgIHRoaXMuY2xpY2tPdXRzaWRlSGFuZGxlciA9IG51bGw7XG4gICAgICB0aGlzLnRvdWNoT3V0c2lkZUhhbmRsZXIgPSBudWxsO1xuICAgIH1cbiAgfSxcbiAgb25Nb3VzZUVudGVyOiBmdW5jdGlvbiBvbk1vdXNlRW50ZXIoKSB7XG4gICAgdGhpcy5kZWxheVNldFBvcHVwVmlzaWJsZSh0cnVlLCB0aGlzLnByb3BzLm1vdXNlRW50ZXJEZWxheSk7XG4gIH0sXG4gIG9uTW91c2VMZWF2ZTogZnVuY3Rpb24gb25Nb3VzZUxlYXZlKCkge1xuICAgIHRoaXMuZGVsYXlTZXRQb3B1cFZpc2libGUoZmFsc2UsIHRoaXMucHJvcHMubW91c2VMZWF2ZURlbGF5KTtcbiAgfSxcbiAgb25Gb2N1czogZnVuY3Rpb24gb25Gb2N1cygpIHtcbiAgICB0aGlzLmZvY3VzVGltZSA9IERhdGUubm93KCk7XG4gICAgdGhpcy5kZWxheVNldFBvcHVwVmlzaWJsZSh0cnVlLCB0aGlzLnByb3BzLmZvY3VzRGVsYXkpO1xuICB9LFxuICBvbk1vdXNlRG93bjogZnVuY3Rpb24gb25Nb3VzZURvd24oKSB7XG4gICAgdGhpcy5wcmVDbGlja1RpbWUgPSBEYXRlLm5vdygpO1xuICB9LFxuICBvblRvdWNoU3RhcnQ6IGZ1bmN0aW9uIG9uVG91Y2hTdGFydCgpIHtcbiAgICB0aGlzLnByZVRvdWNoVGltZSA9IERhdGUubm93KCk7XG4gIH0sXG4gIG9uQmx1cjogZnVuY3Rpb24gb25CbHVyKCkge1xuICAgIHRoaXMuZGVsYXlTZXRQb3B1cFZpc2libGUoZmFsc2UsIHRoaXMucHJvcHMuYmx1ckRlbGF5KTtcbiAgfSxcbiAgb25DbGljazogZnVuY3Rpb24gb25DbGljayhldmVudCkge1xuICAgIC8vIGZvY3VzIHdpbGwgdHJpZ2dlciBjbGlja1xuICAgIGlmICh0aGlzLmZvY3VzVGltZSkge1xuICAgICAgdmFyIHByZVRpbWUgPSB2b2lkIDA7XG4gICAgICBpZiAodGhpcy5wcmVDbGlja1RpbWUgJiYgdGhpcy5wcmVUb3VjaFRpbWUpIHtcbiAgICAgICAgcHJlVGltZSA9IE1hdGgubWluKHRoaXMucHJlQ2xpY2tUaW1lLCB0aGlzLnByZVRvdWNoVGltZSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucHJlQ2xpY2tUaW1lKSB7XG4gICAgICAgIHByZVRpbWUgPSB0aGlzLnByZUNsaWNrVGltZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmVUb3VjaFRpbWUpIHtcbiAgICAgICAgcHJlVGltZSA9IHRoaXMucHJlVG91Y2hUaW1lO1xuICAgICAgfVxuICAgICAgaWYgKE1hdGguYWJzKHByZVRpbWUgLSB0aGlzLmZvY3VzVGltZSkgPCAyMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmZvY3VzVGltZSA9IDA7XG4gICAgfVxuICAgIHRoaXMucHJlQ2xpY2tUaW1lID0gMDtcbiAgICB0aGlzLnByZVRvdWNoVGltZSA9IDA7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB2YXIgbmV4dFZpc2libGUgPSAhdGhpcy5zdGF0ZS5wb3B1cFZpc2libGU7XG4gICAgaWYgKHRoaXMuaXNDbGlja1RvSGlkZSgpICYmICFuZXh0VmlzaWJsZSB8fCBuZXh0VmlzaWJsZSAmJiB0aGlzLmlzQ2xpY2tUb1Nob3coKSkge1xuICAgICAgdGhpcy5zZXRQb3B1cFZpc2libGUoIXRoaXMuc3RhdGUucG9wdXBWaXNpYmxlKTtcbiAgICB9XG4gIH0sXG4gIG9uRG9jdW1lbnRDbGljazogZnVuY3Rpb24gb25Eb2N1bWVudENsaWNrKGV2ZW50KSB7XG4gICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICB2YXIgcm9vdCA9ICgwLCBfcmVhY3REb20uZmluZERPTU5vZGUpKHRoaXMpO1xuICAgIHZhciBwb3B1cE5vZGUgPSB0aGlzLmdldFBvcHVwRG9tTm9kZSgpO1xuICAgIGlmICghX3JjVXRpbC5Eb20uY29udGFpbnMocm9vdCwgdGFyZ2V0KSAmJiAhX3JjVXRpbC5Eb20uY29udGFpbnMocG9wdXBOb2RlLCB0YXJnZXQpKSB7XG4gICAgICB0aGlzLnNldFBvcHVwVmlzaWJsZShmYWxzZSk7XG4gICAgfVxuICB9LFxuICBnZXRQb3B1cERvbU5vZGU6IGZ1bmN0aW9uIGdldFBvcHVwRG9tTm9kZSgpIHtcbiAgICAvLyBmb3IgdGVzdFxuICAgIHJldHVybiB0aGlzLnBvcHVwRG9tTm9kZTtcbiAgfSxcbiAgZ2V0Um9vdERvbU5vZGU6IGZ1bmN0aW9uIGdldFJvb3REb21Ob2RlKCkge1xuICAgIHJldHVybiBfcmVhY3REb20yW1wiZGVmYXVsdFwiXS5maW5kRE9NTm9kZSh0aGlzKTtcbiAgfSxcbiAgZ2V0UG9wdXBDb250YWluZXI6IGZ1bmN0aW9uIGdldFBvcHVwQ29udGFpbmVyKCkge1xuICAgIGlmICghdGhpcy5wb3B1cENvbnRhaW5lcikge1xuICAgICAgdGhpcy5wb3B1cENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdmFyIG1vdW50Tm9kZSA9IHRoaXMucHJvcHMuZ2V0UG9wdXBDb250YWluZXIgPyB0aGlzLnByb3BzLmdldFBvcHVwQ29udGFpbmVyKCgwLCBfcmVhY3REb20uZmluZERPTU5vZGUpKHRoaXMpKSA6IGRvY3VtZW50LmJvZHk7XG4gICAgICBtb3VudE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5wb3B1cENvbnRhaW5lcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBvcHVwQ29udGFpbmVyO1xuICB9LFxuICBnZXRQb3B1cENsYXNzTmFtZUZyb21BbGlnbjogZnVuY3Rpb24gZ2V0UG9wdXBDbGFzc05hbWVGcm9tQWxpZ24oYWxpZ24pIHtcbiAgICB2YXIgY2xhc3NOYW1lID0gW107XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcG9wdXBQbGFjZW1lbnQgPSBwcm9wcy5wb3B1cFBsYWNlbWVudDtcbiAgICB2YXIgYnVpbHRpblBsYWNlbWVudHMgPSBwcm9wcy5idWlsdGluUGxhY2VtZW50cztcbiAgICB2YXIgcHJlZml4Q2xzID0gcHJvcHMucHJlZml4Q2xzO1xuXG4gICAgaWYgKHBvcHVwUGxhY2VtZW50ICYmIGJ1aWx0aW5QbGFjZW1lbnRzKSB7XG4gICAgICBjbGFzc05hbWUucHVzaCgoMCwgX3V0aWxzLmdldFBvcHVwQ2xhc3NOYW1lRnJvbUFsaWduKShidWlsdGluUGxhY2VtZW50cywgcHJlZml4Q2xzLCBhbGlnbikpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZ2V0UG9wdXBDbGFzc05hbWVGcm9tQWxpZ24pIHtcbiAgICAgIGNsYXNzTmFtZS5wdXNoKHByb3BzLmdldFBvcHVwQ2xhc3NOYW1lRnJvbUFsaWduKGFsaWduKSk7XG4gICAgfVxuICAgIHJldHVybiBjbGFzc05hbWUuam9pbignICcpO1xuICB9LFxuICBnZXRQb3B1cEFsaWduOiBmdW5jdGlvbiBnZXRQb3B1cEFsaWduKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHBvcHVwUGxhY2VtZW50ID0gcHJvcHMucG9wdXBQbGFjZW1lbnQ7XG4gICAgdmFyIHBvcHVwQWxpZ24gPSBwcm9wcy5wb3B1cEFsaWduO1xuICAgIHZhciBidWlsdGluUGxhY2VtZW50cyA9IHByb3BzLmJ1aWx0aW5QbGFjZW1lbnRzO1xuXG4gICAgaWYgKHBvcHVwUGxhY2VtZW50ICYmIGJ1aWx0aW5QbGFjZW1lbnRzKSB7XG4gICAgICByZXR1cm4gKDAsIF91dGlscy5nZXRBbGlnbkZyb21QbGFjZW1lbnQpKGJ1aWx0aW5QbGFjZW1lbnRzLCBwb3B1cFBsYWNlbWVudCwgcG9wdXBBbGlnbik7XG4gICAgfVxuICAgIHJldHVybiBwb3B1cEFsaWduO1xuICB9LFxuICBnZXRQb3B1cEVsZW1lbnQ6IGZ1bmN0aW9uIGdldFBvcHVwRWxlbWVudCgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdmFyIG1vdXNlUHJvcHMgPSB7fTtcbiAgICBpZiAocHJvcHMuYWN0aW9uLmluZGV4T2YoJ2hvdmVyJykgIT09IC0xKSB7XG4gICAgICBtb3VzZVByb3BzLm9uTW91c2VFbnRlciA9IHRoaXMub25Nb3VzZUVudGVyO1xuICAgICAgbW91c2VQcm9wcy5vbk1vdXNlTGVhdmUgPSB0aGlzLm9uTW91c2VMZWF2ZTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBfUG9wdXAyW1wiZGVmYXVsdFwiXSxcbiAgICAgIF9leHRlbmRzKHtcbiAgICAgICAgcHJlZml4Q2xzOiBwcm9wcy5wcmVmaXhDbHMsXG4gICAgICAgIGRlc3Ryb3lQb3B1cE9uSGlkZTogcHJvcHMuZGVzdHJveVBvcHVwT25IaWRlLFxuICAgICAgICB2aXNpYmxlOiBzdGF0ZS5wb3B1cFZpc2libGUsXG4gICAgICAgIGNsYXNzTmFtZTogcHJvcHMucG9wdXBDbGFzc05hbWUsXG4gICAgICAgIGFjdGlvbjogcHJvcHMuYWN0aW9uLFxuICAgICAgICBhbGlnbjogdGhpcy5nZXRQb3B1cEFsaWduKCksXG4gICAgICAgIG9uQWxpZ246IHByb3BzLm9uUG9wdXBBbGlnbixcbiAgICAgICAgYW5pbWF0aW9uOiBwcm9wcy5wb3B1cEFuaW1hdGlvbixcbiAgICAgICAgZ2V0Q2xhc3NOYW1lRnJvbUFsaWduOiB0aGlzLmdldFBvcHVwQ2xhc3NOYW1lRnJvbUFsaWduXG4gICAgICB9LCBtb3VzZVByb3BzLCB7XG4gICAgICAgIGdldFJvb3REb21Ob2RlOiB0aGlzLmdldFJvb3REb21Ob2RlLFxuICAgICAgICBzdHlsZTogcHJvcHMucG9wdXBTdHlsZSxcbiAgICAgICAgbWFzazogcHJvcHMubWFzayxcbiAgICAgICAgekluZGV4OiBwcm9wcy56SW5kZXgsXG4gICAgICAgIHRyYW5zaXRpb25OYW1lOiBwcm9wcy5wb3B1cFRyYW5zaXRpb25OYW1lLFxuICAgICAgICBtYXNrQW5pbWF0aW9uOiBwcm9wcy5tYXNrQW5pbWF0aW9uLFxuICAgICAgICBtYXNrVHJhbnNpdGlvbk5hbWU6IHByb3BzLm1hc2tUcmFuc2l0aW9uTmFtZVxuICAgICAgfSksXG4gICAgICBwcm9wcy5wb3B1cFxuICAgICk7XG4gIH0sXG4gIHNldFBvcHVwVmlzaWJsZTogZnVuY3Rpb24gc2V0UG9wdXBWaXNpYmxlKHBvcHVwVmlzaWJsZSkge1xuICAgIHRoaXMuY2xlYXJEZWxheVRpbWVyKCk7XG4gICAgaWYgKHRoaXMuc3RhdGUucG9wdXBWaXNpYmxlICE9PSBwb3B1cFZpc2libGUpIHtcbiAgICAgIGlmICghKCdwb3B1cFZpc2libGUnIGluIHRoaXMucHJvcHMpKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIHBvcHVwVmlzaWJsZTogcG9wdXBWaXNpYmxlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5wcm9wcy5vblBvcHVwVmlzaWJsZUNoYW5nZShwb3B1cFZpc2libGUpO1xuICAgIH1cbiAgfSxcbiAgZGVsYXlTZXRQb3B1cFZpc2libGU6IGZ1bmN0aW9uIGRlbGF5U2V0UG9wdXBWaXNpYmxlKHZpc2libGUsIGRlbGF5Uykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIGRlbGF5ID0gZGVsYXlTICogMTAwMDtcbiAgICB0aGlzLmNsZWFyRGVsYXlUaW1lcigpO1xuICAgIGlmIChkZWxheSkge1xuICAgICAgdGhpcy5kZWxheVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5zZXRQb3B1cFZpc2libGUodmlzaWJsZSk7XG4gICAgICAgIF90aGlzMi5jbGVhckRlbGF5VGltZXIoKTtcbiAgICAgIH0sIGRlbGF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRQb3B1cFZpc2libGUodmlzaWJsZSk7XG4gICAgfVxuICB9LFxuICBjbGVhckRlbGF5VGltZXI6IGZ1bmN0aW9uIGNsZWFyRGVsYXlUaW1lcigpIHtcbiAgICBpZiAodGhpcy5kZWxheVRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWxheVRpbWVyKTtcbiAgICAgIHRoaXMuZGVsYXlUaW1lciA9IG51bGw7XG4gICAgfVxuICB9LFxuICBpc0NsaWNrVG9TaG93OiBmdW5jdGlvbiBpc0NsaWNrVG9TaG93KCkge1xuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBhY3Rpb24gPSBfcHJvcHMuYWN0aW9uO1xuICAgIHZhciBzaG93QWN0aW9uID0gX3Byb3BzLnNob3dBY3Rpb247XG5cbiAgICByZXR1cm4gYWN0aW9uLmluZGV4T2YoJ2NsaWNrJykgIT09IC0xIHx8IHNob3dBY3Rpb24uaW5kZXhPZignY2xpY2snKSAhPT0gLTE7XG4gIH0sXG4gIGlzQ2xpY2tUb0hpZGU6IGZ1bmN0aW9uIGlzQ2xpY2tUb0hpZGUoKSB7XG4gICAgdmFyIF9wcm9wczIgPSB0aGlzLnByb3BzO1xuICAgIHZhciBhY3Rpb24gPSBfcHJvcHMyLmFjdGlvbjtcbiAgICB2YXIgaGlkZUFjdGlvbiA9IF9wcm9wczIuaGlkZUFjdGlvbjtcblxuICAgIHJldHVybiBhY3Rpb24uaW5kZXhPZignY2xpY2snKSAhPT0gLTEgfHwgaGlkZUFjdGlvbi5pbmRleE9mKCdjbGljaycpICE9PSAtMTtcbiAgfSxcbiAgaXNNb3VzZUVudGVyVG9TaG93OiBmdW5jdGlvbiBpc01vdXNlRW50ZXJUb1Nob3coKSB7XG4gICAgdmFyIF9wcm9wczMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBhY3Rpb24gPSBfcHJvcHMzLmFjdGlvbjtcbiAgICB2YXIgc2hvd0FjdGlvbiA9IF9wcm9wczMuc2hvd0FjdGlvbjtcblxuICAgIHJldHVybiBhY3Rpb24uaW5kZXhPZignaG92ZXInKSAhPT0gLTEgfHwgc2hvd0FjdGlvbi5pbmRleE9mKCdtb3VzZUVudGVyJykgIT09IC0xO1xuICB9LFxuICBpc01vdXNlTGVhdmVUb0hpZGU6IGZ1bmN0aW9uIGlzTW91c2VMZWF2ZVRvSGlkZSgpIHtcbiAgICB2YXIgX3Byb3BzNCA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGFjdGlvbiA9IF9wcm9wczQuYWN0aW9uO1xuICAgIHZhciBoaWRlQWN0aW9uID0gX3Byb3BzNC5oaWRlQWN0aW9uO1xuXG4gICAgcmV0dXJuIGFjdGlvbi5pbmRleE9mKCdob3ZlcicpICE9PSAtMSB8fCBoaWRlQWN0aW9uLmluZGV4T2YoJ21vdXNlTGVhdmUnKSAhPT0gLTE7XG4gIH0sXG4gIGlzRm9jdXNUb1Nob3c6IGZ1bmN0aW9uIGlzRm9jdXNUb1Nob3coKSB7XG4gICAgdmFyIF9wcm9wczUgPSB0aGlzLnByb3BzO1xuICAgIHZhciBhY3Rpb24gPSBfcHJvcHM1LmFjdGlvbjtcbiAgICB2YXIgc2hvd0FjdGlvbiA9IF9wcm9wczUuc2hvd0FjdGlvbjtcblxuICAgIHJldHVybiBhY3Rpb24uaW5kZXhPZignZm9jdXMnKSAhPT0gLTEgfHwgc2hvd0FjdGlvbi5pbmRleE9mKCdmb2N1cycpICE9PSAtMTtcbiAgfSxcbiAgaXNCbHVyVG9IaWRlOiBmdW5jdGlvbiBpc0JsdXJUb0hpZGUoKSB7XG4gICAgdmFyIF9wcm9wczYgPSB0aGlzLnByb3BzO1xuICAgIHZhciBhY3Rpb24gPSBfcHJvcHM2LmFjdGlvbjtcbiAgICB2YXIgaGlkZUFjdGlvbiA9IF9wcm9wczYuaGlkZUFjdGlvbjtcblxuICAgIHJldHVybiBhY3Rpb24uaW5kZXhPZignZm9jdXMnKSAhPT0gLTEgfHwgaGlkZUFjdGlvbi5pbmRleE9mKCdibHVyJykgIT09IC0xO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB0aGlzLnBvcHVwUmVuZGVyZWQgPSB0aGlzLnBvcHVwUmVuZGVyZWQgfHwgdGhpcy5zdGF0ZS5wb3B1cFZpc2libGU7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgY2hpbGQgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKTtcbiAgICB2YXIgY2hpbGRQcm9wcyA9IGNoaWxkLnByb3BzIHx8IHt9O1xuICAgIHZhciBuZXdDaGlsZFByb3BzID0ge307XG5cbiAgICBpZiAodGhpcy5pc0NsaWNrVG9IaWRlKCkgfHwgdGhpcy5pc0NsaWNrVG9TaG93KCkpIHtcbiAgICAgIG5ld0NoaWxkUHJvcHMub25DbGljayA9ICgwLCBfcmNVdGlsLmNyZWF0ZUNoYWluZWRGdW5jdGlvbikodGhpcy5vbkNsaWNrLCBjaGlsZFByb3BzLm9uQ2xpY2spO1xuICAgICAgbmV3Q2hpbGRQcm9wcy5vbk1vdXNlRG93biA9ICgwLCBfcmNVdGlsLmNyZWF0ZUNoYWluZWRGdW5jdGlvbikodGhpcy5vbk1vdXNlRG93biwgY2hpbGRQcm9wcy5vbk1vdXNlRG93bik7XG4gICAgICBuZXdDaGlsZFByb3BzLm9uVG91Y2hTdGFydCA9ICgwLCBfcmNVdGlsLmNyZWF0ZUNoYWluZWRGdW5jdGlvbikodGhpcy5vblRvdWNoU3RhcnQsIGNoaWxkUHJvcHMub25Ub3VjaFN0YXJ0KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNNb3VzZUVudGVyVG9TaG93KCkpIHtcbiAgICAgIG5ld0NoaWxkUHJvcHMub25Nb3VzZUVudGVyID0gKDAsIF9yY1V0aWwuY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKSh0aGlzLm9uTW91c2VFbnRlciwgY2hpbGRQcm9wcy5vbk1vdXNlRW50ZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc01vdXNlTGVhdmVUb0hpZGUoKSkge1xuICAgICAgbmV3Q2hpbGRQcm9wcy5vbk1vdXNlTGVhdmUgPSAoMCwgX3JjVXRpbC5jcmVhdGVDaGFpbmVkRnVuY3Rpb24pKHRoaXMub25Nb3VzZUxlYXZlLCBjaGlsZFByb3BzLm9uTW91c2VMZWF2ZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzRm9jdXNUb1Nob3coKSkge1xuICAgICAgbmV3Q2hpbGRQcm9wcy5vbkZvY3VzID0gKDAsIF9yY1V0aWwuY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKSh0aGlzLm9uRm9jdXMsIGNoaWxkUHJvcHMub25Gb2N1cyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzQmx1clRvSGlkZSgpKSB7XG4gICAgICBuZXdDaGlsZFByb3BzLm9uQmx1ciA9ICgwLCBfcmNVdGlsLmNyZWF0ZUNoYWluZWRGdW5jdGlvbikodGhpcy5vbkJsdXIsIGNoaWxkUHJvcHMub25CbHVyKTtcbiAgICB9XG5cbiAgICBBTExfSEFORExFUlMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgdmFyIG5ld0ZuID0gdm9pZCAwO1xuICAgICAgaWYgKHByb3BzW2hhbmRsZXJdICYmIG5ld0NoaWxkUHJvcHNbaGFuZGxlcl0pIHtcbiAgICAgICAgbmV3Rm4gPSAoMCwgX3JjVXRpbC5jcmVhdGVDaGFpbmVkRnVuY3Rpb24pKHByb3BzW2hhbmRsZXJdLCBuZXdDaGlsZFByb3BzW2hhbmRsZXJdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0ZuID0gcHJvcHNbaGFuZGxlcl0gfHwgbmV3Q2hpbGRQcm9wc1toYW5kbGVyXTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdGbikge1xuICAgICAgICBuZXdDaGlsZFByb3BzW2hhbmRsZXJdID0gbmV3Rm47XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gX3JlYWN0MltcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KGNoaWxkLCBuZXdDaGlsZFByb3BzKTtcbiAgfVxufSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gVHJpZ2dlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9+L3JjLXRyaWdnZXIvbGliL1RyaWdnZXIuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yZWFjdERvbSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgX3JlYWN0RG9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0RG9tKTtcblxudmFyIF9yY0FsaWduID0gcmVxdWlyZSgncmMtYWxpZ24nKTtcblxudmFyIF9yY0FsaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JjQWxpZ24pO1xuXG52YXIgX3JjQW5pbWF0ZSA9IHJlcXVpcmUoJ3JjLWFuaW1hdGUnKTtcblxudmFyIF9yY0FuaW1hdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmNBbmltYXRlKTtcblxudmFyIF9Qb3B1cElubmVyID0gcmVxdWlyZSgnLi9Qb3B1cElubmVyJyk7XG5cbnZhciBfUG9wdXBJbm5lcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Qb3B1cElubmVyKTtcblxudmFyIF9MYXp5UmVuZGVyQm94ID0gcmVxdWlyZSgnLi9MYXp5UmVuZGVyQm94Jyk7XG5cbnZhciBfTGF6eVJlbmRlckJveDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9MYXp5UmVuZGVyQm94KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbnZhciBQb3B1cCA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdQb3B1cCcsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgdmlzaWJsZTogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIHN0eWxlOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBnZXRDbGFzc05hbWVGcm9tQWxpZ246IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkFsaWduOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgZ2V0Um9vdERvbU5vZGU6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbk1vdXNlRW50ZXI6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBhbGlnbjogX3JlYWN0LlByb3BUeXBlcy5hbnksXG4gICAgZGVzdHJveVBvcHVwT25IaWRlOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgY2xhc3NOYW1lOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBwcmVmaXhDbHM6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9uTW91c2VMZWF2ZTogX3JlYWN0LlByb3BUeXBlcy5mdW5jXG4gIH0sXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMucm9vdE5vZGUgPSB0aGlzLmdldFBvcHVwRG9tTm9kZSgpO1xuICB9LFxuICBvbkFsaWduOiBmdW5jdGlvbiBvbkFsaWduKHBvcHVwRG9tTm9kZSwgYWxpZ24pIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBhbGlnbkNsYXNzTmFtZSA9IHByb3BzLmdldENsYXNzTmFtZUZyb21BbGlnbihwcm9wcy5hbGlnbik7XG4gICAgdmFyIGN1cnJlbnRBbGlnbkNsYXNzTmFtZSA9IHByb3BzLmdldENsYXNzTmFtZUZyb21BbGlnbihhbGlnbik7XG4gICAgaWYgKGFsaWduQ2xhc3NOYW1lICE9PSBjdXJyZW50QWxpZ25DbGFzc05hbWUpIHtcbiAgICAgIHRoaXMuY3VycmVudEFsaWduQ2xhc3NOYW1lID0gY3VycmVudEFsaWduQ2xhc3NOYW1lO1xuICAgICAgcG9wdXBEb21Ob2RlLmNsYXNzTmFtZSA9IHRoaXMuZ2V0Q2xhc3NOYW1lKGN1cnJlbnRBbGlnbkNsYXNzTmFtZSk7XG4gICAgfVxuICAgIHByb3BzLm9uQWxpZ24ocG9wdXBEb21Ob2RlLCBhbGlnbik7XG4gIH0sXG4gIGdldFBvcHVwRG9tTm9kZTogZnVuY3Rpb24gZ2V0UG9wdXBEb21Ob2RlKCkge1xuICAgIHJldHVybiBfcmVhY3REb20yW1wiZGVmYXVsdFwiXS5maW5kRE9NTm9kZSh0aGlzLnJlZnMucG9wdXApO1xuICB9LFxuICBnZXRUYXJnZXQ6IGZ1bmN0aW9uIGdldFRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5nZXRSb290RG9tTm9kZSgpO1xuICB9LFxuICBnZXRNYXNrVHJhbnNpdGlvbk5hbWU6IGZ1bmN0aW9uIGdldE1hc2tUcmFuc2l0aW9uTmFtZSgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciB0cmFuc2l0aW9uTmFtZSA9IHByb3BzLm1hc2tUcmFuc2l0aW9uTmFtZTtcbiAgICB2YXIgYW5pbWF0aW9uID0gcHJvcHMubWFza0FuaW1hdGlvbjtcbiAgICBpZiAoIXRyYW5zaXRpb25OYW1lICYmIGFuaW1hdGlvbikge1xuICAgICAgdHJhbnNpdGlvbk5hbWUgPSBwcm9wcy5wcmVmaXhDbHMgKyAnLScgKyBhbmltYXRpb247XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2l0aW9uTmFtZTtcbiAgfSxcbiAgZ2V0VHJhbnNpdGlvbk5hbWU6IGZ1bmN0aW9uIGdldFRyYW5zaXRpb25OYW1lKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHRyYW5zaXRpb25OYW1lID0gcHJvcHMudHJhbnNpdGlvbk5hbWU7XG4gICAgaWYgKCF0cmFuc2l0aW9uTmFtZSAmJiBwcm9wcy5hbmltYXRpb24pIHtcbiAgICAgIHRyYW5zaXRpb25OYW1lID0gcHJvcHMucHJlZml4Q2xzICsgJy0nICsgcHJvcHMuYW5pbWF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNpdGlvbk5hbWU7XG4gIH0sXG4gIGdldENsYXNzTmFtZTogZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKGN1cnJlbnRBbGlnbkNsYXNzTmFtZSkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLnByZWZpeENscyArICcgJyArIHRoaXMucHJvcHMuY2xhc3NOYW1lICsgJyAnICsgY3VycmVudEFsaWduQ2xhc3NOYW1lO1xuICB9LFxuICBnZXRQb3B1cEVsZW1lbnQ6IGZ1bmN0aW9uIGdldFBvcHVwRWxlbWVudCgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBhbGlnbiA9IHByb3BzLmFsaWduO1xuICAgIHZhciBzdHlsZSA9IHByb3BzLnN0eWxlO1xuICAgIHZhciB2aXNpYmxlID0gcHJvcHMudmlzaWJsZTtcbiAgICB2YXIgcHJlZml4Q2xzID0gcHJvcHMucHJlZml4Q2xzO1xuICAgIHZhciBkZXN0cm95UG9wdXBPbkhpZGUgPSBwcm9wcy5kZXN0cm95UG9wdXBPbkhpZGU7XG5cbiAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy5nZXRDbGFzc05hbWUodGhpcy5jdXJyZW50QWxpZ25DbGFzc05hbWUgfHwgcHJvcHMuZ2V0Q2xhc3NOYW1lRnJvbUFsaWduKGFsaWduKSk7XG4gICAgdmFyIGhpZGRlbkNsYXNzTmFtZSA9IHByZWZpeENscyArICctaGlkZGVuJztcbiAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgIHRoaXMuY3VycmVudEFsaWduQ2xhc3NOYW1lID0gbnVsbDtcbiAgICB9XG4gICAgdmFyIG5ld1N0eWxlID0gX2V4dGVuZHMoe30sIHN0eWxlLCB0aGlzLmdldFpJbmRleFN0eWxlKCkpO1xuICAgIHZhciBwb3B1cElubmVyUHJvcHMgPSB7XG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgIHByZWZpeENsczogcHJlZml4Q2xzLFxuICAgICAgcmVmOiAncG9wdXAnLFxuICAgICAgb25Nb3VzZUVudGVyOiBwcm9wcy5vbk1vdXNlRW50ZXIsXG4gICAgICBvbk1vdXNlTGVhdmU6IHByb3BzLm9uTW91c2VMZWF2ZSxcbiAgICAgIHN0eWxlOiBuZXdTdHlsZVxuICAgIH07XG4gICAgaWYgKGRlc3Ryb3lQb3B1cE9uSGlkZSkge1xuICAgICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIF9yY0FuaW1hdGUyW1wiZGVmYXVsdFwiXSxcbiAgICAgICAge1xuICAgICAgICAgIGNvbXBvbmVudDogJycsXG4gICAgICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgICAgIHRyYW5zaXRpb25BcHBlYXI6IHRydWUsXG4gICAgICAgICAgdHJhbnNpdGlvbk5hbWU6IHRoaXMuZ2V0VHJhbnNpdGlvbk5hbWUoKVxuICAgICAgICB9LFxuICAgICAgICB2aXNpYmxlID8gX3JlYWN0MltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICBfcmNBbGlnbjJbXCJkZWZhdWx0XCJdLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRhcmdldDogdGhpcy5nZXRUYXJnZXQsXG4gICAgICAgICAgICBrZXk6ICdwb3B1cCcsXG4gICAgICAgICAgICBtb25pdG9yV2luZG93UmVzaXplOiB0cnVlLFxuICAgICAgICAgICAgYWxpZ246IGFsaWduLFxuICAgICAgICAgICAgb25BbGlnbjogdGhpcy5vbkFsaWduXG4gICAgICAgICAgfSxcbiAgICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgX1BvcHVwSW5uZXIyW1wiZGVmYXVsdFwiXSxcbiAgICAgICAgICAgIF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSwgcG9wdXBJbm5lclByb3BzKSxcbiAgICAgICAgICAgIHByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgKVxuICAgICAgICApIDogbnVsbFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBfcmNBbmltYXRlMltcImRlZmF1bHRcIl0sXG4gICAgICB7XG4gICAgICAgIGNvbXBvbmVudDogJycsXG4gICAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgdHJhbnNpdGlvbkFwcGVhcjogdHJ1ZSxcbiAgICAgICAgdHJhbnNpdGlvbk5hbWU6IHRoaXMuZ2V0VHJhbnNpdGlvbk5hbWUoKSxcbiAgICAgICAgc2hvd1Byb3A6ICd4VmlzaWJsZSdcbiAgICAgIH0sXG4gICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICBfcmNBbGlnbjJbXCJkZWZhdWx0XCJdLFxuICAgICAgICB7XG4gICAgICAgICAgdGFyZ2V0OiB0aGlzLmdldFRhcmdldCxcbiAgICAgICAgICBrZXk6ICdwb3B1cCcsXG4gICAgICAgICAgbW9uaXRvcldpbmRvd1Jlc2l6ZTogdHJ1ZSxcbiAgICAgICAgICB4VmlzaWJsZTogdmlzaWJsZSxcbiAgICAgICAgICBjaGlsZHJlblByb3BzOiB7IHZpc2libGU6ICd4VmlzaWJsZScgfSxcbiAgICAgICAgICBkaXNhYmxlZDogIXZpc2libGUsXG4gICAgICAgICAgYWxpZ246IGFsaWduLFxuICAgICAgICAgIG9uQWxpZ246IHRoaXMub25BbGlnblxuICAgICAgICB9LFxuICAgICAgICBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIF9Qb3B1cElubmVyMltcImRlZmF1bHRcIl0sXG4gICAgICAgICAgX2V4dGVuZHMoe1xuICAgICAgICAgICAgaGlkZGVuQ2xhc3NOYW1lOiBoaWRkZW5DbGFzc05hbWVcbiAgICAgICAgICB9LCBwb3B1cElubmVyUHJvcHMpLFxuICAgICAgICAgIHByb3BzLmNoaWxkcmVuXG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICB9LFxuICBnZXRaSW5kZXhTdHlsZTogZnVuY3Rpb24gZ2V0WkluZGV4U3R5bGUoKSB7XG4gICAgdmFyIHN0eWxlID0ge307XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICBpZiAocHJvcHMuekluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0eWxlLnpJbmRleCA9IHByb3BzLnpJbmRleDtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9LFxuICBnZXRNYXNrRWxlbWVudDogZnVuY3Rpb24gZ2V0TWFza0VsZW1lbnQoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgbWFza0VsZW1lbnQgPSB2b2lkIDA7XG4gICAgaWYgKHByb3BzLm1hc2spIHtcbiAgICAgIHZhciBtYXNrVHJhbnNpdGlvbiA9IHRoaXMuZ2V0TWFza1RyYW5zaXRpb25OYW1lKCk7XG4gICAgICBtYXNrRWxlbWVudCA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX0xhenlSZW5kZXJCb3gyW1wiZGVmYXVsdFwiXSwge1xuICAgICAgICBzdHlsZTogdGhpcy5nZXRaSW5kZXhTdHlsZSgpLFxuICAgICAgICBrZXk6ICdtYXNrJyxcbiAgICAgICAgY2xhc3NOYW1lOiBwcm9wcy5wcmVmaXhDbHMgKyAnLW1hc2snLFxuICAgICAgICBoaWRkZW5DbGFzc05hbWU6IHByb3BzLnByZWZpeENscyArICctbWFzay1oaWRkZW4nLFxuICAgICAgICB2aXNpYmxlOiBwcm9wcy52aXNpYmxlXG4gICAgICB9KTtcbiAgICAgIGlmIChtYXNrVHJhbnNpdGlvbikge1xuICAgICAgICBtYXNrRWxlbWVudCA9IF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgX3JjQW5pbWF0ZTJbXCJkZWZhdWx0XCJdLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGtleTogJ21hc2snLFxuICAgICAgICAgICAgc2hvd1Byb3A6ICd2aXNpYmxlJyxcbiAgICAgICAgICAgIHRyYW5zaXRpb25BcHBlYXI6IHRydWUsXG4gICAgICAgICAgICBjb21wb25lbnQ6ICcnLFxuICAgICAgICAgICAgdHJhbnNpdGlvbk5hbWU6IG1hc2tUcmFuc2l0aW9uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtYXNrRWxlbWVudFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFza0VsZW1lbnQ7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgJ2RpdicsXG4gICAgICBudWxsLFxuICAgICAgdGhpcy5nZXRNYXNrRWxlbWVudCgpLFxuICAgICAgdGhpcy5nZXRQb3B1cEVsZW1lbnQoKVxuICAgICk7XG4gIH1cbn0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFBvcHVwO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL34vcmMtdHJpZ2dlci9saWIvUG9wdXAuanNcbiAqKi8iLCIvLyBleHBvcnQgdGhpcyBwYWNrYWdlJ3MgYXBpXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfQWxpZ24gPSByZXF1aXJlKCcuL0FsaWduJyk7XG5cbnZhciBfQWxpZ24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWxpZ24pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBfQWxpZ24yWydkZWZhdWx0J107XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvfi9yYy10cmlnZ2VyL34vcmMtYWxpZ24vbGliL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcmVhY3REb20gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIF9yZWFjdERvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdERvbSk7XG5cbnZhciBfZG9tQWxpZ24gPSByZXF1aXJlKCdkb20tYWxpZ24nKTtcblxudmFyIF9kb21BbGlnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kb21BbGlnbik7XG5cbnZhciBfcmNVdGlsID0gcmVxdWlyZSgncmMtdXRpbCcpO1xuXG52YXIgX2lzV2luZG93ID0gcmVxdWlyZSgnLi9pc1dpbmRvdycpO1xuXG52YXIgX2lzV2luZG93MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzV2luZG93KTtcblxuZnVuY3Rpb24gYnVmZmVyKGZuLCBtcykge1xuICB2YXIgdGltZXIgPSB1bmRlZmluZWQ7XG4gIHJldHVybiBmdW5jdGlvbiBidWZmZXJGbigpIHtcbiAgICBpZiAodGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgfVxuICAgIHRpbWVyID0gc2V0VGltZW91dChmbiwgbXMpO1xuICB9O1xufVxuXG52YXIgQWxpZ24gPSBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ0FsaWduJyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBjaGlsZHJlblByb3BzOiBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBhbGlnbjogX3JlYWN0LlByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgICB0YXJnZXQ6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkFsaWduOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgbW9uaXRvckJ1ZmZlclRpbWU6IF9yZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgIG1vbml0b3JXaW5kb3dSZXNpemU6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBkaXNhYmxlZDogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGNoaWxkcmVuOiBfcmVhY3QuUHJvcFR5cGVzLmFueVxuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0YXJnZXQ6IGZ1bmN0aW9uIHRhcmdldCgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICAgIH0sXG4gICAgICBvbkFsaWduOiBmdW5jdGlvbiBvbkFsaWduKCkge30sXG4gICAgICBtb25pdG9yQnVmZmVyVGltZTogNTAsXG4gICAgICBtb25pdG9yV2luZG93UmVzaXplOiBmYWxzZSxcbiAgICAgIGRpc2FibGVkOiBmYWxzZVxuICAgIH07XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgLy8gaWYgcGFyZW50IHJlZiBub3QgYXR0YWNoZWQgLi4uLiB1c2UgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWRcbiAgICBpZiAoIXByb3BzLmRpc2FibGVkKSB7XG4gICAgICB2YXIgc291cmNlID0gX3JlYWN0RG9tMlsnZGVmYXVsdCddLmZpbmRET01Ob2RlKHRoaXMpO1xuICAgICAgcHJvcHMub25BbGlnbihzb3VyY2UsICgwLCBfZG9tQWxpZ24yWydkZWZhdWx0J10pKHNvdXJjZSwgcHJvcHMudGFyZ2V0KCksIHByb3BzLmFsaWduKSk7XG4gICAgICBpZiAocHJvcHMubW9uaXRvcldpbmRvd1Jlc2l6ZSkge1xuICAgICAgICB0aGlzLnN0YXJ0TW9uaXRvcldpbmRvd1Jlc2l6ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnREaWRVcGRhdGU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICB2YXIgcmVBbGlnbiA9IGZhbHNlO1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGN1cnJlbnRUYXJnZXQgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoIXByb3BzLmRpc2FibGVkKSB7XG4gICAgICBpZiAocHJldlByb3BzLmRpc2FibGVkIHx8IHByZXZQcm9wcy5hbGlnbiAhPT0gcHJvcHMuYWxpZ24pIHtcbiAgICAgICAgcmVBbGlnbiA9IHRydWU7XG4gICAgICAgIGN1cnJlbnRUYXJnZXQgPSBwcm9wcy50YXJnZXQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBsYXN0VGFyZ2V0ID0gcHJldlByb3BzLnRhcmdldCgpO1xuICAgICAgICBjdXJyZW50VGFyZ2V0ID0gcHJvcHMudGFyZ2V0KCk7XG4gICAgICAgIGlmICgoMCwgX2lzV2luZG93MlsnZGVmYXVsdCddKShsYXN0VGFyZ2V0KSAmJiAoMCwgX2lzV2luZG93MlsnZGVmYXVsdCddKShjdXJyZW50VGFyZ2V0KSkge1xuICAgICAgICAgIHJlQWxpZ24gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0VGFyZ2V0ICE9PSBjdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgICAgcmVBbGlnbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVBbGlnbikge1xuICAgICAgdmFyIHNvdXJjZSA9IF9yZWFjdERvbTJbJ2RlZmF1bHQnXS5maW5kRE9NTm9kZSh0aGlzKTtcbiAgICAgIHByb3BzLm9uQWxpZ24oc291cmNlLCAoMCwgX2RvbUFsaWduMlsnZGVmYXVsdCddKShzb3VyY2UsIGN1cnJlbnRUYXJnZXQsIHByb3BzLmFsaWduKSk7XG4gICAgfVxuXG4gICAgaWYgKHByb3BzLm1vbml0b3JXaW5kb3dSZXNpemUgJiYgIXByb3BzLmRpc2FibGVkKSB7XG4gICAgICB0aGlzLnN0YXJ0TW9uaXRvcldpbmRvd1Jlc2l6ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0b3BNb25pdG9yV2luZG93UmVzaXplKCk7XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLnN0b3BNb25pdG9yV2luZG93UmVzaXplKCk7XG4gIH0sXG5cbiAgb25XaW5kb3dSZXNpemU6IGZ1bmN0aW9uIG9uV2luZG93UmVzaXplKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgaWYgKCFwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgdmFyIHNvdXJjZSA9IF9yZWFjdERvbTJbJ2RlZmF1bHQnXS5maW5kRE9NTm9kZSh0aGlzKTtcbiAgICAgIHByb3BzLm9uQWxpZ24oc291cmNlLCAoMCwgX2RvbUFsaWduMlsnZGVmYXVsdCddKShzb3VyY2UsIHByb3BzLnRhcmdldCgpLCBwcm9wcy5hbGlnbikpO1xuICAgIH1cbiAgfSxcblxuICBzdGFydE1vbml0b3JXaW5kb3dSZXNpemU6IGZ1bmN0aW9uIHN0YXJ0TW9uaXRvcldpbmRvd1Jlc2l6ZSgpIHtcbiAgICBpZiAoIXRoaXMucmVzaXplSGFuZGxlcikge1xuICAgICAgdGhpcy5yZXNpemVIYW5kbGVyID0gX3JjVXRpbC5Eb20uYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csICdyZXNpemUnLCBidWZmZXIodGhpcy5vbldpbmRvd1Jlc2l6ZSwgdGhpcy5wcm9wcy5tb25pdG9yQnVmZmVyVGltZSkpO1xuICAgIH1cbiAgfSxcblxuICBzdG9wTW9uaXRvcldpbmRvd1Jlc2l6ZTogZnVuY3Rpb24gc3RvcE1vbml0b3JXaW5kb3dSZXNpemUoKSB7XG4gICAgaWYgKHRoaXMucmVzaXplSGFuZGxlcikge1xuICAgICAgdGhpcy5yZXNpemVIYW5kbGVyLnJlbW92ZSgpO1xuICAgICAgdGhpcy5yZXNpemVIYW5kbGVyID0gbnVsbDtcbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGNoaWxkcmVuUHJvcHMgPSBfcHJvcHMuY2hpbGRyZW5Qcm9wcztcbiAgICB2YXIgY2hpbGRyZW4gPSBfcHJvcHMuY2hpbGRyZW47XG5cbiAgICB2YXIgY2hpbGQgPSBfcmVhY3QyWydkZWZhdWx0J10uQ2hpbGRyZW4ub25seShjaGlsZHJlbik7XG4gICAgaWYgKGNoaWxkcmVuUHJvcHMpIHtcbiAgICAgIHZhciBuZXdQcm9wcyA9IHt9O1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBjaGlsZHJlblByb3BzKSB7XG4gICAgICAgIGlmIChjaGlsZHJlblByb3BzLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgbmV3UHJvcHNbcHJvcF0gPSB0aGlzLnByb3BzW2NoaWxkcmVuUHJvcHNbcHJvcF1dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNsb25lRWxlbWVudChjaGlsZCwgbmV3UHJvcHMpO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGQ7XG4gIH1cbn0pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBBbGlnbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9+L3JjLXRyaWdnZXIvfi9yYy1hbGlnbi9saWIvQWxpZ24uanNcbiAqKi8iLCIvKipcbiAqIGFsaWduIGRvbSBub2RlIGZsZXhpYmx5XG4gKiBAYXV0aG9yIHlpbWluZ2hlQGdtYWlsLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIF91dGlsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlscyk7XG5cbnZhciBfZ2V0T2Zmc2V0UGFyZW50ID0gcmVxdWlyZSgnLi9nZXRPZmZzZXRQYXJlbnQnKTtcblxudmFyIF9nZXRPZmZzZXRQYXJlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0T2Zmc2V0UGFyZW50KTtcblxudmFyIF9nZXRWaXNpYmxlUmVjdEZvckVsZW1lbnQgPSByZXF1aXJlKCcuL2dldFZpc2libGVSZWN0Rm9yRWxlbWVudCcpO1xuXG52YXIgX2dldFZpc2libGVSZWN0Rm9yRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRWaXNpYmxlUmVjdEZvckVsZW1lbnQpO1xuXG52YXIgX2FkanVzdEZvclZpZXdwb3J0ID0gcmVxdWlyZSgnLi9hZGp1c3RGb3JWaWV3cG9ydCcpO1xuXG52YXIgX2FkanVzdEZvclZpZXdwb3J0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FkanVzdEZvclZpZXdwb3J0KTtcblxudmFyIF9nZXRSZWdpb24gPSByZXF1aXJlKCcuL2dldFJlZ2lvbicpO1xuXG52YXIgX2dldFJlZ2lvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRSZWdpb24pO1xuXG52YXIgX2dldEVsRnV0dXJlUG9zID0gcmVxdWlyZSgnLi9nZXRFbEZ1dHVyZVBvcycpO1xuXG52YXIgX2dldEVsRnV0dXJlUG9zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEVsRnV0dXJlUG9zKTtcblxuLy8gaHR0cDovL3lpbWluZ2hlLml0ZXllLmNvbS9ibG9nLzExMjQ3MjBcblxuZnVuY3Rpb24gaXNGYWlsWChlbEZ1dHVyZVBvcywgZWxSZWdpb24sIHZpc2libGVSZWN0KSB7XG4gIHJldHVybiBlbEZ1dHVyZVBvcy5sZWZ0IDwgdmlzaWJsZVJlY3QubGVmdCB8fCBlbEZ1dHVyZVBvcy5sZWZ0ICsgZWxSZWdpb24ud2lkdGggPiB2aXNpYmxlUmVjdC5yaWdodDtcbn1cblxuZnVuY3Rpb24gaXNGYWlsWShlbEZ1dHVyZVBvcywgZWxSZWdpb24sIHZpc2libGVSZWN0KSB7XG4gIHJldHVybiBlbEZ1dHVyZVBvcy50b3AgPCB2aXNpYmxlUmVjdC50b3AgfHwgZWxGdXR1cmVQb3MudG9wICsgZWxSZWdpb24uaGVpZ2h0ID4gdmlzaWJsZVJlY3QuYm90dG9tO1xufVxuXG5mdW5jdGlvbiBpc0NvbXBsZXRlRmFpbFgoZWxGdXR1cmVQb3MsIGVsUmVnaW9uLCB2aXNpYmxlUmVjdCkge1xuICByZXR1cm4gZWxGdXR1cmVQb3MubGVmdCA+IHZpc2libGVSZWN0LnJpZ2h0IHx8IGVsRnV0dXJlUG9zLmxlZnQgKyBlbFJlZ2lvbi53aWR0aCA8IHZpc2libGVSZWN0LmxlZnQ7XG59XG5cbmZ1bmN0aW9uIGlzQ29tcGxldGVGYWlsWShlbEZ1dHVyZVBvcywgZWxSZWdpb24sIHZpc2libGVSZWN0KSB7XG4gIHJldHVybiBlbEZ1dHVyZVBvcy50b3AgPiB2aXNpYmxlUmVjdC5ib3R0b20gfHwgZWxGdXR1cmVQb3MudG9wICsgZWxSZWdpb24uaGVpZ2h0IDwgdmlzaWJsZVJlY3QudG9wO1xufVxuXG5mdW5jdGlvbiBmbGlwKHBvaW50cywgcmVnLCBtYXApIHtcbiAgdmFyIHJldCA9IFtdO1xuICBfdXRpbHMyWydkZWZhdWx0J10uZWFjaChwb2ludHMsIGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0LnB1c2gocC5yZXBsYWNlKHJlZywgZnVuY3Rpb24gKG0pIHtcbiAgICAgIHJldHVybiBtYXBbbV07XG4gICAgfSkpO1xuICB9KTtcbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZmxpcE9mZnNldChvZmZzZXQsIGluZGV4KSB7XG4gIG9mZnNldFtpbmRleF0gPSAtb2Zmc2V0W2luZGV4XTtcbiAgcmV0dXJuIG9mZnNldDtcbn1cblxuZnVuY3Rpb24gY29udmVydE9mZnNldChzdHIsIG9mZnNldExlbikge1xuICB2YXIgbiA9IHVuZGVmaW5lZDtcbiAgaWYgKC8lJC8udGVzdChzdHIpKSB7XG4gICAgbiA9IHBhcnNlSW50KHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDEpLCAxMCkgLyAxMDAgKiBvZmZzZXRMZW47XG4gIH0gZWxzZSB7XG4gICAgbiA9IHBhcnNlSW50KHN0ciwgMTApO1xuICB9XG4gIHJldHVybiBuIHx8IDA7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU9mZnNldChvZmZzZXQsIGVsKSB7XG4gIG9mZnNldFswXSA9IGNvbnZlcnRPZmZzZXQob2Zmc2V0WzBdLCBlbC53aWR0aCk7XG4gIG9mZnNldFsxXSA9IGNvbnZlcnRPZmZzZXQob2Zmc2V0WzFdLCBlbC5oZWlnaHQpO1xufVxuXG5mdW5jdGlvbiBkb21BbGlnbihlbCwgcmVmTm9kZSwgYWxpZ24pIHtcbiAgdmFyIHBvaW50cyA9IGFsaWduLnBvaW50cztcbiAgdmFyIG9mZnNldCA9IGFsaWduLm9mZnNldCB8fCBbMCwgMF07XG4gIHZhciB0YXJnZXRPZmZzZXQgPSBhbGlnbi50YXJnZXRPZmZzZXQgfHwgWzAsIDBdO1xuICB2YXIgb3ZlcmZsb3cgPSBhbGlnbi5vdmVyZmxvdztcbiAgdmFyIHRhcmdldCA9IGFsaWduLnRhcmdldCB8fCByZWZOb2RlO1xuICB2YXIgc291cmNlID0gYWxpZ24uc291cmNlIHx8IGVsO1xuICBvZmZzZXQgPSBbXS5jb25jYXQob2Zmc2V0KTtcbiAgdGFyZ2V0T2Zmc2V0ID0gW10uY29uY2F0KHRhcmdldE9mZnNldCk7XG4gIG92ZXJmbG93ID0gb3ZlcmZsb3cgfHwge307XG4gIHZhciBuZXdPdmVyZmxvd0NmZyA9IHt9O1xuXG4gIHZhciBmYWlsID0gMDtcbiAgLy8g5b2T5YmN6IqC54K55Y+v5Lul6KKr5pS+572u55qE5pi+56S65Yy65Z+fXG4gIHZhciB2aXNpYmxlUmVjdCA9ICgwLCBfZ2V0VmlzaWJsZVJlY3RGb3JFbGVtZW50MlsnZGVmYXVsdCddKShzb3VyY2UpO1xuICAvLyDlvZPliY3oioLngrnmiYDljaDnmoTljLrln58sIGxlZnQvdG9wL3dpZHRoL2hlaWdodFxuICB2YXIgZWxSZWdpb24gPSAoMCwgX2dldFJlZ2lvbjJbJ2RlZmF1bHQnXSkoc291cmNlKTtcbiAgLy8g5Y+C54Wn6IqC54K55omA5Y2g55qE5Yy65Z+fLCBsZWZ0L3RvcC93aWR0aC9oZWlnaHRcbiAgdmFyIHJlZk5vZGVSZWdpb24gPSAoMCwgX2dldFJlZ2lvbjJbJ2RlZmF1bHQnXSkodGFyZ2V0KTtcbiAgLy8g5bCGIG9mZnNldCDovazmjaLmiJDmlbDlgLzvvIzmlK/mjIHnmb7liIbmr5RcbiAgbm9ybWFsaXplT2Zmc2V0KG9mZnNldCwgZWxSZWdpb24pO1xuICBub3JtYWxpemVPZmZzZXQodGFyZ2V0T2Zmc2V0LCByZWZOb2RlUmVnaW9uKTtcbiAgLy8g5b2T5YmN6IqC54K55bCG6KaB6KKr5pS+572u55qE5L2N572uXG4gIHZhciBlbEZ1dHVyZVBvcyA9ICgwLCBfZ2V0RWxGdXR1cmVQb3MyWydkZWZhdWx0J10pKGVsUmVnaW9uLCByZWZOb2RlUmVnaW9uLCBwb2ludHMsIG9mZnNldCwgdGFyZ2V0T2Zmc2V0KTtcbiAgLy8g5b2T5YmN6IqC54K55bCG6KaB5omA5aSE55qE5Yy65Z+fXG4gIHZhciBuZXdFbFJlZ2lvbiA9IF91dGlsczJbJ2RlZmF1bHQnXS5tZXJnZShlbFJlZ2lvbiwgZWxGdXR1cmVQb3MpO1xuXG4gIC8vIOWmguaenOWPr+inhuWMuuWfn+S4jeiDveWujOWFqOaUvue9ruW9k+WJjeiKgueCueaXtuWFgeiuuOiwg+aVtFxuICBpZiAodmlzaWJsZVJlY3QgJiYgKG92ZXJmbG93LmFkanVzdFggfHwgb3ZlcmZsb3cuYWRqdXN0WSkpIHtcbiAgICBpZiAob3ZlcmZsb3cuYWRqdXN0WCkge1xuICAgICAgLy8g5aaC5p6c5qiq5ZCR5LiN6IO95pS+5LiLXG4gICAgICBpZiAoaXNGYWlsWChlbEZ1dHVyZVBvcywgZWxSZWdpb24sIHZpc2libGVSZWN0KSkge1xuICAgICAgICAvLyDlr7npvZDkvY3nva7lj43kuItcbiAgICAgICAgdmFyIG5ld1BvaW50cyA9IGZsaXAocG9pbnRzLCAvW2xyXS9pZywge1xuICAgICAgICAgIGw6ICdyJyxcbiAgICAgICAgICByOiAnbCdcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIOWBj+enu+mHj+S5n+WPjeS4i1xuICAgICAgICB2YXIgbmV3T2Zmc2V0ID0gZmxpcE9mZnNldChvZmZzZXQsIDApO1xuICAgICAgICB2YXIgbmV3VGFyZ2V0T2Zmc2V0ID0gZmxpcE9mZnNldCh0YXJnZXRPZmZzZXQsIDApO1xuICAgICAgICB2YXIgbmV3RWxGdXR1cmVQb3MgPSAoMCwgX2dldEVsRnV0dXJlUG9zMlsnZGVmYXVsdCddKShlbFJlZ2lvbiwgcmVmTm9kZVJlZ2lvbiwgbmV3UG9pbnRzLCBuZXdPZmZzZXQsIG5ld1RhcmdldE9mZnNldCk7XG4gICAgICAgIGlmICghaXNDb21wbGV0ZUZhaWxYKG5ld0VsRnV0dXJlUG9zLCBlbFJlZ2lvbiwgdmlzaWJsZVJlY3QpKSB7XG4gICAgICAgICAgZmFpbCA9IDE7XG4gICAgICAgICAgcG9pbnRzID0gbmV3UG9pbnRzO1xuICAgICAgICAgIG9mZnNldCA9IG5ld09mZnNldDtcbiAgICAgICAgICB0YXJnZXRPZmZzZXQgPSBuZXdUYXJnZXRPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3ZlcmZsb3cuYWRqdXN0WSkge1xuICAgICAgLy8g5aaC5p6c57q15ZCR5LiN6IO95pS+5LiLXG4gICAgICBpZiAoaXNGYWlsWShlbEZ1dHVyZVBvcywgZWxSZWdpb24sIHZpc2libGVSZWN0KSkge1xuICAgICAgICAvLyDlr7npvZDkvY3nva7lj43kuItcbiAgICAgICAgdmFyIG5ld1BvaW50cyA9IGZsaXAocG9pbnRzLCAvW3RiXS9pZywge1xuICAgICAgICAgIHQ6ICdiJyxcbiAgICAgICAgICBiOiAndCdcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIOWBj+enu+mHj+S5n+WPjeS4i1xuICAgICAgICB2YXIgbmV3T2Zmc2V0ID0gZmxpcE9mZnNldChvZmZzZXQsIDEpO1xuICAgICAgICB2YXIgbmV3VGFyZ2V0T2Zmc2V0ID0gZmxpcE9mZnNldCh0YXJnZXRPZmZzZXQsIDEpO1xuICAgICAgICB2YXIgbmV3RWxGdXR1cmVQb3MgPSAoMCwgX2dldEVsRnV0dXJlUG9zMlsnZGVmYXVsdCddKShlbFJlZ2lvbiwgcmVmTm9kZVJlZ2lvbiwgbmV3UG9pbnRzLCBuZXdPZmZzZXQsIG5ld1RhcmdldE9mZnNldCk7XG4gICAgICAgIGlmICghaXNDb21wbGV0ZUZhaWxZKG5ld0VsRnV0dXJlUG9zLCBlbFJlZ2lvbiwgdmlzaWJsZVJlY3QpKSB7XG4gICAgICAgICAgZmFpbCA9IDE7XG4gICAgICAgICAgcG9pbnRzID0gbmV3UG9pbnRzO1xuICAgICAgICAgIG9mZnNldCA9IG5ld09mZnNldDtcbiAgICAgICAgICB0YXJnZXRPZmZzZXQgPSBuZXdUYXJnZXRPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDlpoLmnpzlpLHotKXvvIzph43mlrDorqHnrpflvZPliY3oioLngrnlsIbopoHooqvmlL7nva7nmoTkvY3nva5cbiAgICBpZiAoZmFpbCkge1xuICAgICAgZWxGdXR1cmVQb3MgPSAoMCwgX2dldEVsRnV0dXJlUG9zMlsnZGVmYXVsdCddKShlbFJlZ2lvbiwgcmVmTm9kZVJlZ2lvbiwgcG9pbnRzLCBvZmZzZXQsIHRhcmdldE9mZnNldCk7XG4gICAgICBfdXRpbHMyWydkZWZhdWx0J10ubWl4KG5ld0VsUmVnaW9uLCBlbEZ1dHVyZVBvcyk7XG4gICAgfVxuXG4gICAgLy8g5qOA5p+l5Y+N5LiL5ZCO55qE5L2N572u5piv5ZCm5Y+v5Lul5pS+5LiL5LqGXG4gICAgLy8g5aaC5p6c5LuN54S25pS+5LiN5LiL5Y+q5pyJ5oyH5a6a5LqG5Y+v5Lul6LCD5pW05b2T5YmN5pa55ZCR5omN6LCD5pW0XG4gICAgbmV3T3ZlcmZsb3dDZmcuYWRqdXN0WCA9IG92ZXJmbG93LmFkanVzdFggJiYgaXNGYWlsWChlbEZ1dHVyZVBvcywgZWxSZWdpb24sIHZpc2libGVSZWN0KTtcblxuICAgIG5ld092ZXJmbG93Q2ZnLmFkanVzdFkgPSBvdmVyZmxvdy5hZGp1c3RZICYmIGlzRmFpbFkoZWxGdXR1cmVQb3MsIGVsUmVnaW9uLCB2aXNpYmxlUmVjdCk7XG5cbiAgICAvLyDnoa7lrp7opoHosIPmlbTvvIznlJroh7Plj6/og73kvJrosIPmlbTpq5jluqblrr3luqZcbiAgICBpZiAobmV3T3ZlcmZsb3dDZmcuYWRqdXN0WCB8fCBuZXdPdmVyZmxvd0NmZy5hZGp1c3RZKSB7XG4gICAgICBuZXdFbFJlZ2lvbiA9ICgwLCBfYWRqdXN0Rm9yVmlld3BvcnQyWydkZWZhdWx0J10pKGVsRnV0dXJlUG9zLCBlbFJlZ2lvbiwgdmlzaWJsZVJlY3QsIG5ld092ZXJmbG93Q2ZnKTtcbiAgICB9XG4gIH1cblxuICAvLyBuZWVkIGp1ZGdlIHRvIGluIGNhc2Ugc2V0IGZpeGVkIHdpdGggaW4gY3NzIG9uIGhlaWdodCBhdXRvIGVsZW1lbnRcbiAgaWYgKG5ld0VsUmVnaW9uLndpZHRoICE9PSBlbFJlZ2lvbi53aWR0aCkge1xuICAgIF91dGlsczJbJ2RlZmF1bHQnXS5jc3Moc291cmNlLCAnd2lkdGgnLCBzb3VyY2Uud2lkdGgoKSArIG5ld0VsUmVnaW9uLndpZHRoIC0gZWxSZWdpb24ud2lkdGgpO1xuICB9XG5cbiAgaWYgKG5ld0VsUmVnaW9uLmhlaWdodCAhPT0gZWxSZWdpb24uaGVpZ2h0KSB7XG4gICAgX3V0aWxzMlsnZGVmYXVsdCddLmNzcyhzb3VyY2UsICdoZWlnaHQnLCBzb3VyY2UuaGVpZ2h0KCkgKyBuZXdFbFJlZ2lvbi5oZWlnaHQgLSBlbFJlZ2lvbi5oZWlnaHQpO1xuICB9XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2tpc3N5dGVhbS9raXNzeS9pc3N1ZXMvMTkwXG4gIC8vIGh0dHA6Ly9sb2NhbGhvc3Q6ODg4OC9raXNzeS9zcmMvb3ZlcmxheS9kZW1vL290aGVyL3JlbGF0aXZlX2FsaWduL2FsaWduLmh0bWxcbiAgLy8g55u45a+55LqO5bGP5bmV5L2N572u5rKh5Y+Y77yM6ICMIGxlZnQvdG9wIOWPmOS6hlxuICAvLyDkvovlpoIgPGRpdiAncmVsYXRpdmUnPjxlbCBhYnNvbHV0ZT48L2Rpdj5cbiAgX3V0aWxzMlsnZGVmYXVsdCddLm9mZnNldChzb3VyY2UsIHtcbiAgICBsZWZ0OiBuZXdFbFJlZ2lvbi5sZWZ0LFxuICAgIHRvcDogbmV3RWxSZWdpb24udG9wXG4gIH0sIHtcbiAgICB1c2VDc3NSaWdodDogYWxpZ24udXNlQ3NzUmlnaHQsXG4gICAgdXNlQ3NzQm90dG9tOiBhbGlnbi51c2VDc3NCb3R0b21cbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBwb2ludHM6IHBvaW50cyxcbiAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICB0YXJnZXRPZmZzZXQ6IHRhcmdldE9mZnNldCxcbiAgICBvdmVyZmxvdzogbmV3T3ZlcmZsb3dDZmdcbiAgfTtcbn1cblxuZG9tQWxpZ24uX19nZXRPZmZzZXRQYXJlbnQgPSBfZ2V0T2Zmc2V0UGFyZW50MlsnZGVmYXVsdCddO1xuXG5kb21BbGlnbi5fX2dldFZpc2libGVSZWN0Rm9yRWxlbWVudCA9IF9nZXRWaXNpYmxlUmVjdEZvckVsZW1lbnQyWydkZWZhdWx0J107XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGRvbUFsaWduO1xuXG4vKipcbiAqICAyMDEyLTA0LTI2IHlpbWluZ2hlQGdtYWlsLmNvbVxuICogICAtIOS8mOWMluaZuuiDveWvuem9kOeul+azlVxuICogICAtIOaFjueUqCByZXNpemVYWFxuICpcbiAqICAyMDExLTA3LTEzIHlpbWluZ2hlQGdtYWlsLmNvbSBub3RlOlxuICogICAtIOWinuWKoOaZuuiDveWvuem9kO+8jOS7peWPiuWkp+Wwj+iwg+aVtOmAiemhuVxuICoqL1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL34vcmMtdHJpZ2dlci9+L3JjLWFsaWduL34vZG9tLWFsaWduL2xpYi9pbmRleC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIF91dGlsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlscyk7XG5cbi8qKlxuICog5b6X5Yiw5Lya5a+86Ie05YWD57Sg5pi+56S65LiN5YWo55qE56WW5YWI5YWD57SgXG4gKi9cblxuZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gaWUg6L+Z5Liq5Lmf5LiN5piv5a6M5YWo5Y+v6KGMXG4gIC8qXG4gICA8ZGl2IHN0eWxlPVwid2lkdGg6IDUwcHg7aGVpZ2h0OiAxMDBweDtvdmVyZmxvdzogaGlkZGVuXCI+XG4gICA8ZGl2IHN0eWxlPVwid2lkdGg6IDUwcHg7aGVpZ2h0OiAxMDBweDtwb3NpdGlvbjogcmVsYXRpdmU7XCIgaWQ9XCJkNlwiPlxuICAg5YWD57SgIDYg6auYIDEwMHB4IOWuvSA1MHB4PGJyLz5cbiAgIDwvZGl2PlxuICAgPC9kaXY+XG4gICAqL1xuICAvLyBlbGVtZW50Lm9mZnNldFBhcmVudCBkb2VzIHRoZSByaWdodCB0aGluZyBpbiBpZTcgYW5kIGJlbG93LiBSZXR1cm4gcGFyZW50IHdpdGggbGF5b3V0IVxuICAvLyAgSW4gb3RoZXIgYnJvd3NlcnMgaXQgb25seSBpbmNsdWRlcyBlbGVtZW50cyB3aXRoIHBvc2l0aW9uIGFic29sdXRlLCByZWxhdGl2ZSBvclxuICAvLyBmaXhlZCwgbm90IGVsZW1lbnRzIHdpdGggb3ZlcmZsb3cgc2V0IHRvIGF1dG8gb3Igc2Nyb2xsLlxuICAvLyAgICAgICAgaWYgKFVBLmllICYmIGllTW9kZSA8IDgpIHtcbiAgLy8gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG4gIC8vICAgICAgICB9XG4gIC8vIOe7n+S4gOeahCBvZmZzZXRQYXJlbnQg5pa55rOVXG4gIHZhciBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIHZhciBib2R5ID0gZG9jLmJvZHk7XG4gIHZhciBwYXJlbnQgPSB1bmRlZmluZWQ7XG4gIHZhciBwb3NpdGlvblN0eWxlID0gX3V0aWxzMlsnZGVmYXVsdCddLmNzcyhlbGVtZW50LCAncG9zaXRpb24nKTtcbiAgdmFyIHNraXBTdGF0aWMgPSBwb3NpdGlvblN0eWxlID09PSAnZml4ZWQnIHx8IHBvc2l0aW9uU3R5bGUgPT09ICdhYnNvbHV0ZSc7XG5cbiAgaWYgKCFza2lwU3RhdGljKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2h0bWwnID8gbnVsbCA6IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgfVxuXG4gIGZvciAocGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlOyBwYXJlbnQgJiYgcGFyZW50ICE9PSBib2R5OyBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZSkge1xuICAgIHBvc2l0aW9uU3R5bGUgPSBfdXRpbHMyWydkZWZhdWx0J10uY3NzKHBhcmVudCwgJ3Bvc2l0aW9uJyk7XG4gICAgaWYgKHBvc2l0aW9uU3R5bGUgIT09ICdzdGF0aWMnKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gZ2V0T2Zmc2V0UGFyZW50O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL34vcmMtdHJpZ2dlci9+L3JjLWFsaWduL34vZG9tLWFsaWduL2xpYi9nZXRPZmZzZXRQYXJlbnQuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciBfdXRpbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbHMpO1xuXG52YXIgX2dldE9mZnNldFBhcmVudCA9IHJlcXVpcmUoJy4vZ2V0T2Zmc2V0UGFyZW50Jyk7XG5cbnZhciBfZ2V0T2Zmc2V0UGFyZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldE9mZnNldFBhcmVudCk7XG5cbi8qKlxuICog6I635b6X5YWD57Sg55qE5pi+56S66YOo5YiG55qE5Yy65Z+fXG4gKi9cbmZ1bmN0aW9uIGdldFZpc2libGVSZWN0Rm9yRWxlbWVudChlbGVtZW50KSB7XG4gIHZhciB2aXNpYmxlUmVjdCA9IHtcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiBJbmZpbml0eSxcbiAgICB0b3A6IDAsXG4gICAgYm90dG9tOiBJbmZpbml0eVxuICB9O1xuICB2YXIgZWwgPSAoMCwgX2dldE9mZnNldFBhcmVudDJbJ2RlZmF1bHQnXSkoZWxlbWVudCk7XG4gIHZhciBzY3JvbGxYID0gdW5kZWZpbmVkO1xuICB2YXIgc2Nyb2xsWSA9IHVuZGVmaW5lZDtcbiAgdmFyIHdpblNpemUgPSB1bmRlZmluZWQ7XG4gIHZhciBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIHZhciB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgdmFyIGJvZHkgPSBkb2MuYm9keTtcbiAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgLy8gRGV0ZXJtaW5lIHRoZSBzaXplIG9mIHRoZSB2aXNpYmxlIHJlY3QgYnkgY2xpbWJpbmcgdGhlIGRvbSBhY2NvdW50aW5nIGZvclxuICAvLyBhbGwgc2Nyb2xsYWJsZSBjb250YWluZXJzLlxuICB3aGlsZSAoZWwpIHtcbiAgICAvLyBjbGllbnRXaWR0aCBpcyB6ZXJvIGZvciBpbmxpbmUgYmxvY2sgZWxlbWVudHMgaW4gaWUuXG4gICAgaWYgKChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ01TSUUnKSA9PT0gLTEgfHwgZWwuY2xpZW50V2lkdGggIT09IDApICYmXG4gICAgLy8gYm9keSBtYXkgaGF2ZSBvdmVyZmxvdyBzZXQgb24gaXQsIHlldCB3ZSBzdGlsbCBnZXQgdGhlIGVudGlyZVxuICAgIC8vIHZpZXdwb3J0LiBJbiBzb21lIGJyb3dzZXJzLCBlbC5vZmZzZXRQYXJlbnQgbWF5IGJlXG4gICAgLy8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBzbyBjaGVjayBmb3IgdGhhdCB0b28uXG4gICAgZWwgIT09IGJvZHkgJiYgZWwgIT09IGRvY3VtZW50RWxlbWVudCAmJiBfdXRpbHMyWydkZWZhdWx0J10uY3NzKGVsLCAnb3ZlcmZsb3cnKSAhPT0gJ3Zpc2libGUnKSB7XG4gICAgICB2YXIgcG9zID0gX3V0aWxzMlsnZGVmYXVsdCddLm9mZnNldChlbCk7XG4gICAgICAvLyBhZGQgYm9yZGVyXG4gICAgICBwb3MubGVmdCArPSBlbC5jbGllbnRMZWZ0O1xuICAgICAgcG9zLnRvcCArPSBlbC5jbGllbnRUb3A7XG4gICAgICB2aXNpYmxlUmVjdC50b3AgPSBNYXRoLm1heCh2aXNpYmxlUmVjdC50b3AsIHBvcy50b3ApO1xuICAgICAgdmlzaWJsZVJlY3QucmlnaHQgPSBNYXRoLm1pbih2aXNpYmxlUmVjdC5yaWdodCxcbiAgICAgIC8vIGNvbnNpZGVyIGFyZWEgd2l0aG91dCBzY3JvbGxCYXJcbiAgICAgIHBvcy5sZWZ0ICsgZWwuY2xpZW50V2lkdGgpO1xuICAgICAgdmlzaWJsZVJlY3QuYm90dG9tID0gTWF0aC5taW4odmlzaWJsZVJlY3QuYm90dG9tLCBwb3MudG9wICsgZWwuY2xpZW50SGVpZ2h0KTtcbiAgICAgIHZpc2libGVSZWN0LmxlZnQgPSBNYXRoLm1heCh2aXNpYmxlUmVjdC5sZWZ0LCBwb3MubGVmdCk7XG4gICAgfSBlbHNlIGlmIChlbCA9PT0gYm9keSB8fCBlbCA9PT0gZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZWwgPSAoMCwgX2dldE9mZnNldFBhcmVudDJbJ2RlZmF1bHQnXSkoZWwpO1xuICB9XG5cbiAgLy8gQ2xpcCBieSB3aW5kb3cncyB2aWV3cG9ydC5cbiAgc2Nyb2xsWCA9IF91dGlsczJbJ2RlZmF1bHQnXS5nZXRXaW5kb3dTY3JvbGxMZWZ0KHdpbik7XG4gIHNjcm9sbFkgPSBfdXRpbHMyWydkZWZhdWx0J10uZ2V0V2luZG93U2Nyb2xsVG9wKHdpbik7XG4gIHZpc2libGVSZWN0LmxlZnQgPSBNYXRoLm1heCh2aXNpYmxlUmVjdC5sZWZ0LCBzY3JvbGxYKTtcbiAgdmlzaWJsZVJlY3QudG9wID0gTWF0aC5tYXgodmlzaWJsZVJlY3QudG9wLCBzY3JvbGxZKTtcbiAgd2luU2l6ZSA9IHtcbiAgICB3aWR0aDogX3V0aWxzMlsnZGVmYXVsdCddLnZpZXdwb3J0V2lkdGgod2luKSxcbiAgICBoZWlnaHQ6IF91dGlsczJbJ2RlZmF1bHQnXS52aWV3cG9ydEhlaWdodCh3aW4pXG4gIH07XG4gIHZpc2libGVSZWN0LnJpZ2h0ID0gTWF0aC5taW4odmlzaWJsZVJlY3QucmlnaHQsIHNjcm9sbFggKyB3aW5TaXplLndpZHRoKTtcbiAgdmlzaWJsZVJlY3QuYm90dG9tID0gTWF0aC5taW4odmlzaWJsZVJlY3QuYm90dG9tLCBzY3JvbGxZICsgd2luU2l6ZS5oZWlnaHQpO1xuICByZXR1cm4gdmlzaWJsZVJlY3QudG9wID49IDAgJiYgdmlzaWJsZVJlY3QubGVmdCA+PSAwICYmIHZpc2libGVSZWN0LmJvdHRvbSA+IHZpc2libGVSZWN0LnRvcCAmJiB2aXNpYmxlUmVjdC5yaWdodCA+IHZpc2libGVSZWN0LmxlZnQgPyB2aXNpYmxlUmVjdCA6IG51bGw7XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGdldFZpc2libGVSZWN0Rm9yRWxlbWVudDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9+L3JjLXRyaWdnZXIvfi9yYy1hbGlnbi9+L2RvbS1hbGlnbi9saWIvZ2V0VmlzaWJsZVJlY3RGb3JFbGVtZW50LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXIgX3V0aWxzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWxzKTtcblxuZnVuY3Rpb24gYWRqdXN0Rm9yVmlld3BvcnQoZWxGdXR1cmVQb3MsIGVsUmVnaW9uLCB2aXNpYmxlUmVjdCwgb3ZlcmZsb3cpIHtcbiAgdmFyIHBvcyA9IF91dGlsczJbJ2RlZmF1bHQnXS5jbG9uZShlbEZ1dHVyZVBvcyk7XG4gIHZhciBzaXplID0ge1xuICAgIHdpZHRoOiBlbFJlZ2lvbi53aWR0aCxcbiAgICBoZWlnaHQ6IGVsUmVnaW9uLmhlaWdodFxuICB9O1xuXG4gIGlmIChvdmVyZmxvdy5hZGp1c3RYICYmIHBvcy5sZWZ0IDwgdmlzaWJsZVJlY3QubGVmdCkge1xuICAgIHBvcy5sZWZ0ID0gdmlzaWJsZVJlY3QubGVmdDtcbiAgfVxuXG4gIC8vIExlZnQgZWRnZSBpbnNpZGUgYW5kIHJpZ2h0IGVkZ2Ugb3V0c2lkZSB2aWV3cG9ydCwgdHJ5IHRvIHJlc2l6ZSBpdC5cbiAgaWYgKG92ZXJmbG93LnJlc2l6ZVdpZHRoICYmIHBvcy5sZWZ0ID49IHZpc2libGVSZWN0LmxlZnQgJiYgcG9zLmxlZnQgKyBzaXplLndpZHRoID4gdmlzaWJsZVJlY3QucmlnaHQpIHtcbiAgICBzaXplLndpZHRoIC09IHBvcy5sZWZ0ICsgc2l6ZS53aWR0aCAtIHZpc2libGVSZWN0LnJpZ2h0O1xuICB9XG5cbiAgLy8gUmlnaHQgZWRnZSBvdXRzaWRlIHZpZXdwb3J0LCB0cnkgdG8gbW92ZSBpdC5cbiAgaWYgKG92ZXJmbG93LmFkanVzdFggJiYgcG9zLmxlZnQgKyBzaXplLndpZHRoID4gdmlzaWJsZVJlY3QucmlnaHQpIHtcbiAgICAvLyDkv53or4Hlt6bovrnnlYzlkozlj6/op4bljLrln5/lt6bovrnnlYzlr7npvZBcbiAgICBwb3MubGVmdCA9IE1hdGgubWF4KHZpc2libGVSZWN0LnJpZ2h0IC0gc2l6ZS53aWR0aCwgdmlzaWJsZVJlY3QubGVmdCk7XG4gIH1cblxuICAvLyBUb3AgZWRnZSBvdXRzaWRlIHZpZXdwb3J0LCB0cnkgdG8gbW92ZSBpdC5cbiAgaWYgKG92ZXJmbG93LmFkanVzdFkgJiYgcG9zLnRvcCA8IHZpc2libGVSZWN0LnRvcCkge1xuICAgIHBvcy50b3AgPSB2aXNpYmxlUmVjdC50b3A7XG4gIH1cblxuICAvLyBUb3AgZWRnZSBpbnNpZGUgYW5kIGJvdHRvbSBlZGdlIG91dHNpZGUgdmlld3BvcnQsIHRyeSB0byByZXNpemUgaXQuXG4gIGlmIChvdmVyZmxvdy5yZXNpemVIZWlnaHQgJiYgcG9zLnRvcCA+PSB2aXNpYmxlUmVjdC50b3AgJiYgcG9zLnRvcCArIHNpemUuaGVpZ2h0ID4gdmlzaWJsZVJlY3QuYm90dG9tKSB7XG4gICAgc2l6ZS5oZWlnaHQgLT0gcG9zLnRvcCArIHNpemUuaGVpZ2h0IC0gdmlzaWJsZVJlY3QuYm90dG9tO1xuICB9XG5cbiAgLy8gQm90dG9tIGVkZ2Ugb3V0c2lkZSB2aWV3cG9ydCwgdHJ5IHRvIG1vdmUgaXQuXG4gIGlmIChvdmVyZmxvdy5hZGp1c3RZICYmIHBvcy50b3AgKyBzaXplLmhlaWdodCA+IHZpc2libGVSZWN0LmJvdHRvbSkge1xuICAgIC8vIOS/neivgeS4iui+ueeVjOWSjOWPr+inhuWMuuWfn+S4iui+ueeVjOWvuem9kFxuICAgIHBvcy50b3AgPSBNYXRoLm1heCh2aXNpYmxlUmVjdC5ib3R0b20gLSBzaXplLmhlaWdodCwgdmlzaWJsZVJlY3QudG9wKTtcbiAgfVxuXG4gIHJldHVybiBfdXRpbHMyWydkZWZhdWx0J10ubWl4KHBvcywgc2l6ZSk7XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGFkanVzdEZvclZpZXdwb3J0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL34vcmMtdHJpZ2dlci9+L3JjLWFsaWduL34vZG9tLWFsaWduL2xpYi9hZGp1c3RGb3JWaWV3cG9ydC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIF91dGlsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlscyk7XG5cbmZ1bmN0aW9uIGdldFJlZ2lvbihub2RlKSB7XG4gIHZhciBvZmZzZXQgPSB1bmRlZmluZWQ7XG4gIHZhciB3ID0gdW5kZWZpbmVkO1xuICB2YXIgaCA9IHVuZGVmaW5lZDtcbiAgaWYgKCFfdXRpbHMyWydkZWZhdWx0J10uaXNXaW5kb3cobm9kZSkgJiYgbm9kZS5ub2RlVHlwZSAhPT0gOSkge1xuICAgIG9mZnNldCA9IF91dGlsczJbJ2RlZmF1bHQnXS5vZmZzZXQobm9kZSk7XG4gICAgdyA9IF91dGlsczJbJ2RlZmF1bHQnXS5vdXRlcldpZHRoKG5vZGUpO1xuICAgIGggPSBfdXRpbHMyWydkZWZhdWx0J10ub3V0ZXJIZWlnaHQobm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHdpbiA9IF91dGlsczJbJ2RlZmF1bHQnXS5nZXRXaW5kb3cobm9kZSk7XG4gICAgb2Zmc2V0ID0ge1xuICAgICAgbGVmdDogX3V0aWxzMlsnZGVmYXVsdCddLmdldFdpbmRvd1Njcm9sbExlZnQod2luKSxcbiAgICAgIHRvcDogX3V0aWxzMlsnZGVmYXVsdCddLmdldFdpbmRvd1Njcm9sbFRvcCh3aW4pXG4gICAgfTtcbiAgICB3ID0gX3V0aWxzMlsnZGVmYXVsdCddLnZpZXdwb3J0V2lkdGgod2luKTtcbiAgICBoID0gX3V0aWxzMlsnZGVmYXVsdCddLnZpZXdwb3J0SGVpZ2h0KHdpbik7XG4gIH1cbiAgb2Zmc2V0LndpZHRoID0gdztcbiAgb2Zmc2V0LmhlaWdodCA9IGg7XG4gIHJldHVybiBvZmZzZXQ7XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGdldFJlZ2lvbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9+L3JjLXRyaWdnZXIvfi9yYy1hbGlnbi9+L2RvbS1hbGlnbi9saWIvZ2V0UmVnaW9uLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX2dldEFsaWduT2Zmc2V0ID0gcmVxdWlyZSgnLi9nZXRBbGlnbk9mZnNldCcpO1xuXG52YXIgX2dldEFsaWduT2Zmc2V0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEFsaWduT2Zmc2V0KTtcblxuZnVuY3Rpb24gZ2V0RWxGdXR1cmVQb3MoZWxSZWdpb24sIHJlZk5vZGVSZWdpb24sIHBvaW50cywgb2Zmc2V0LCB0YXJnZXRPZmZzZXQpIHtcbiAgdmFyIHh5ID0gdW5kZWZpbmVkO1xuICB2YXIgZGlmZiA9IHVuZGVmaW5lZDtcbiAgdmFyIHAxID0gdW5kZWZpbmVkO1xuICB2YXIgcDIgPSB1bmRlZmluZWQ7XG5cbiAgeHkgPSB7XG4gICAgbGVmdDogZWxSZWdpb24ubGVmdCxcbiAgICB0b3A6IGVsUmVnaW9uLnRvcFxuICB9O1xuXG4gIHAxID0gKDAsIF9nZXRBbGlnbk9mZnNldDJbJ2RlZmF1bHQnXSkocmVmTm9kZVJlZ2lvbiwgcG9pbnRzWzFdKTtcbiAgcDIgPSAoMCwgX2dldEFsaWduT2Zmc2V0MlsnZGVmYXVsdCddKShlbFJlZ2lvbiwgcG9pbnRzWzBdKTtcblxuICBkaWZmID0gW3AyLmxlZnQgLSBwMS5sZWZ0LCBwMi50b3AgLSBwMS50b3BdO1xuXG4gIHJldHVybiB7XG4gICAgbGVmdDogeHkubGVmdCAtIGRpZmZbMF0gKyBvZmZzZXRbMF0gLSB0YXJnZXRPZmZzZXRbMF0sXG4gICAgdG9wOiB4eS50b3AgLSBkaWZmWzFdICsgb2Zmc2V0WzFdIC0gdGFyZ2V0T2Zmc2V0WzFdXG4gIH07XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGdldEVsRnV0dXJlUG9zO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1jYWxlbmRhci9+L3JjLWNhbGVuZGFyL34vcmMtdHJpZ2dlci9+L3JjLWFsaWduL34vZG9tLWFsaWduL2xpYi9nZXRFbEZ1dHVyZVBvcy5qc1xuICoqLyIsIi8vIGV4cG9ydCB0aGlzIHBhY2thZ2UncyBhcGlcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL0FuaW1hdGUnKTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvfi9yYy10cmlnZ2VyL34vcmMtYW5pbWF0ZS9saWIvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9DaGlsZHJlblV0aWxzID0gcmVxdWlyZSgnLi9DaGlsZHJlblV0aWxzJyk7XG5cbnZhciBfQW5pbWF0ZUNoaWxkID0gcmVxdWlyZSgnLi9BbmltYXRlQ2hpbGQnKTtcblxudmFyIF9BbmltYXRlQ2hpbGQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQW5pbWF0ZUNoaWxkKTtcblxudmFyIF91dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbnZhciBfdXRpbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlsKTtcblxudmFyIGRlZmF1bHRLZXkgPSAncmNfYW5pbWF0ZV8nICsgRGF0ZS5ub3coKTtcblxuZnVuY3Rpb24gZ2V0Q2hpbGRyZW5Gcm9tUHJvcHMocHJvcHMpIHtcbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gIGlmIChfcmVhY3QyWydkZWZhdWx0J10uaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKSB7XG4gICAgaWYgKCFjaGlsZHJlbi5rZXkpIHtcbiAgICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY2xvbmVFbGVtZW50KGNoaWxkcmVuLCB7XG4gICAgICAgIGtleTogZGVmYXVsdEtleVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBBbmltYXRlID0gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdBbmltYXRlJyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBjb21wb25lbnQ6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYW55LFxuICAgIGFuaW1hdGlvbjogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5vYmplY3QsXG4gICAgdHJhbnNpdGlvbk5hbWU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHRyYW5zaXRpb25FbnRlcjogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLFxuICAgIHRyYW5zaXRpb25BcHBlYXI6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCxcbiAgICBleGNsdXNpdmU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCxcbiAgICB0cmFuc2l0aW9uTGVhdmU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCxcbiAgICBvbkVuZDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLFxuICAgIG9uRW50ZXI6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkxlYXZlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25BcHBlYXI6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYyxcbiAgICBzaG93UHJvcDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmdcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYW5pbWF0aW9uOiB7fSxcbiAgICAgIGNvbXBvbmVudDogJ3NwYW4nLFxuICAgICAgdHJhbnNpdGlvbkVudGVyOiB0cnVlLFxuICAgICAgdHJhbnNpdGlvbkxlYXZlOiB0cnVlLFxuICAgICAgdHJhbnNpdGlvbkFwcGVhcjogZmFsc2UsXG4gICAgICBvbkVuZDogbm9vcCxcbiAgICAgIG9uRW50ZXI6IG5vb3AsXG4gICAgICBvbkxlYXZlOiBub29wLFxuICAgICAgb25BcHBlYXI6IG5vb3BcbiAgICB9O1xuICB9LFxuXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgIHRoaXMuY3VycmVudGx5QW5pbWF0aW5nS2V5cyA9IHt9O1xuICAgIHRoaXMua2V5c1RvRW50ZXIgPSBbXTtcbiAgICB0aGlzLmtleXNUb0xlYXZlID0gW107XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoaWxkcmVuOiAoMCwgX0NoaWxkcmVuVXRpbHMudG9BcnJheUNoaWxkcmVuKShnZXRDaGlsZHJlbkZyb21Qcm9wcyh0aGlzLnByb3BzKSlcbiAgICB9O1xuICB9LFxuXG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHNob3dQcm9wID0gdGhpcy5wcm9wcy5zaG93UHJvcDtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnN0YXRlLmNoaWxkcmVuO1xuICAgIGlmIChzaG93UHJvcCkge1xuICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiAhIWNoaWxkLnByb3BzW3Nob3dQcm9wXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgX3RoaXMucGVyZm9ybUFwcGVhcihjaGlsZC5rZXkpO1xuICAgIH0pO1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB0aGlzLm5leHRQcm9wcyA9IG5leHRQcm9wcztcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gKDAsIF9DaGlsZHJlblV0aWxzLnRvQXJyYXlDaGlsZHJlbikoZ2V0Q2hpbGRyZW5Gcm9tUHJvcHMobmV4dFByb3BzKSk7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAvLyBleGNsdXNpdmUgbmVlZHMgaW1tZWRpYXRlIHJlc3BvbnNlXG4gICAgaWYgKHByb3BzLmV4Y2x1c2l2ZSkge1xuICAgICAgT2JqZWN0LmtleXModGhpcy5jdXJyZW50bHlBbmltYXRpbmdLZXlzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX3RoaXMyLnN0b3Aoa2V5KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgc2hvd1Byb3AgPSBwcm9wcy5zaG93UHJvcDtcbiAgICB2YXIgY3VycmVudGx5QW5pbWF0aW5nS2V5cyA9IHRoaXMuY3VycmVudGx5QW5pbWF0aW5nS2V5cztcbiAgICAvLyBsYXN0IHByb3BzIGNoaWxkcmVuIGlmIGV4Y2x1c2l2ZVxuICAgIHZhciBjdXJyZW50Q2hpbGRyZW4gPSBwcm9wcy5leGNsdXNpdmUgPyAoMCwgX0NoaWxkcmVuVXRpbHMudG9BcnJheUNoaWxkcmVuKShnZXRDaGlsZHJlbkZyb21Qcm9wcyhwcm9wcykpIDogdGhpcy5zdGF0ZS5jaGlsZHJlbjtcbiAgICAvLyBpbiBjYXNlIGRlc3Ryb3kgaW4gc2hvd1Byb3AgbW9kZVxuICAgIHZhciBuZXdDaGlsZHJlbiA9IFtdO1xuICAgIGlmIChzaG93UHJvcCkge1xuICAgICAgY3VycmVudENoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGN1cnJlbnRDaGlsZCkge1xuICAgICAgICB2YXIgbmV4dENoaWxkID0gKDAsIF9DaGlsZHJlblV0aWxzLmZpbmRDaGlsZEluQ2hpbGRyZW5CeUtleSkobmV4dENoaWxkcmVuLCBjdXJyZW50Q2hpbGQua2V5KTtcbiAgICAgICAgdmFyIG5ld0NoaWxkID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoKCFuZXh0Q2hpbGQgfHwgIW5leHRDaGlsZC5wcm9wc1tzaG93UHJvcF0pICYmIGN1cnJlbnRDaGlsZC5wcm9wc1tzaG93UHJvcF0pIHtcbiAgICAgICAgICBuZXdDaGlsZCA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jbG9uZUVsZW1lbnQobmV4dENoaWxkIHx8IGN1cnJlbnRDaGlsZCwgX2RlZmluZVByb3BlcnR5KHt9LCBzaG93UHJvcCwgdHJ1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0NoaWxkID0gbmV4dENoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdDaGlsZCkge1xuICAgICAgICAgIG5ld0NoaWxkcmVuLnB1c2gobmV3Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG5leHRDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChuZXh0Q2hpbGQpIHtcbiAgICAgICAgaWYgKCEoMCwgX0NoaWxkcmVuVXRpbHMuZmluZENoaWxkSW5DaGlsZHJlbkJ5S2V5KShjdXJyZW50Q2hpbGRyZW4sIG5leHRDaGlsZC5rZXkpKSB7XG4gICAgICAgICAgbmV3Q2hpbGRyZW4ucHVzaChuZXh0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3Q2hpbGRyZW4gPSAoMCwgX0NoaWxkcmVuVXRpbHMubWVyZ2VDaGlsZHJlbikoY3VycmVudENoaWxkcmVuLCBuZXh0Q2hpbGRyZW4pO1xuICAgIH1cblxuICAgIC8vIG5lZWQgcmVuZGVyIHRvIGF2b2lkIHVwZGF0ZVxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgY2hpbGRyZW46IG5ld0NoaWxkcmVuXG4gICAgfSk7XG5cbiAgICBuZXh0Q2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHZhciBrZXkgPSBjaGlsZC5rZXk7XG4gICAgICBpZiAoY3VycmVudGx5QW5pbWF0aW5nS2V5c1trZXldKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBoYXNQcmV2ID0gKDAsIF9DaGlsZHJlblV0aWxzLmZpbmRDaGlsZEluQ2hpbGRyZW5CeUtleSkoY3VycmVudENoaWxkcmVuLCBrZXkpO1xuICAgICAgaWYgKHNob3dQcm9wKSB7XG4gICAgICAgIHZhciBzaG93SW5OZXh0ID0gY2hpbGQucHJvcHNbc2hvd1Byb3BdO1xuICAgICAgICBpZiAoaGFzUHJldikge1xuICAgICAgICAgIHZhciBzaG93SW5Ob3cgPSAoMCwgX0NoaWxkcmVuVXRpbHMuZmluZFNob3duQ2hpbGRJbkNoaWxkcmVuQnlLZXkpKGN1cnJlbnRDaGlsZHJlbiwga2V5LCBzaG93UHJvcCk7XG4gICAgICAgICAgaWYgKCFzaG93SW5Ob3cgJiYgc2hvd0luTmV4dCkge1xuICAgICAgICAgICAgX3RoaXMyLmtleXNUb0VudGVyLnB1c2goa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2hvd0luTmV4dCkge1xuICAgICAgICAgIF90aGlzMi5rZXlzVG9FbnRlci5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWhhc1ByZXYpIHtcbiAgICAgICAgX3RoaXMyLmtleXNUb0VudGVyLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGN1cnJlbnRDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgdmFyIGtleSA9IGNoaWxkLmtleTtcbiAgICAgIGlmIChjdXJyZW50bHlBbmltYXRpbmdLZXlzW2tleV0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGhhc05leHQgPSAoMCwgX0NoaWxkcmVuVXRpbHMuZmluZENoaWxkSW5DaGlsZHJlbkJ5S2V5KShuZXh0Q2hpbGRyZW4sIGtleSk7XG4gICAgICBpZiAoc2hvd1Byb3ApIHtcbiAgICAgICAgdmFyIHNob3dJbk5vdyA9IGNoaWxkLnByb3BzW3Nob3dQcm9wXTtcbiAgICAgICAgaWYgKGhhc05leHQpIHtcbiAgICAgICAgICB2YXIgc2hvd0luTmV4dCA9ICgwLCBfQ2hpbGRyZW5VdGlscy5maW5kU2hvd25DaGlsZEluQ2hpbGRyZW5CeUtleSkobmV4dENoaWxkcmVuLCBrZXksIHNob3dQcm9wKTtcbiAgICAgICAgICBpZiAoIXNob3dJbk5leHQgJiYgc2hvd0luTm93KSB7XG4gICAgICAgICAgICBfdGhpczIua2V5c1RvTGVhdmUucHVzaChrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzaG93SW5Ob3cpIHtcbiAgICAgICAgICBfdGhpczIua2V5c1RvTGVhdmUucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFoYXNOZXh0KSB7XG4gICAgICAgIF90aGlzMi5rZXlzVG9MZWF2ZS5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkVXBkYXRlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgaWYgKHRoaXMuaXNNb3VudGVkKCkpIHtcbiAgICAgIHZhciBrZXlzVG9FbnRlciA9IHRoaXMua2V5c1RvRW50ZXI7XG4gICAgICB0aGlzLmtleXNUb0VudGVyID0gW107XG4gICAgICBrZXlzVG9FbnRlci5mb3JFYWNoKHRoaXMucGVyZm9ybUVudGVyKTtcbiAgICAgIHZhciBrZXlzVG9MZWF2ZSA9IHRoaXMua2V5c1RvTGVhdmU7XG4gICAgICB0aGlzLmtleXNUb0xlYXZlID0gW107XG4gICAgICBrZXlzVG9MZWF2ZS5mb3JFYWNoKHRoaXMucGVyZm9ybUxlYXZlKTtcbiAgICB9XG4gIH0sXG5cbiAgcGVyZm9ybUVudGVyOiBmdW5jdGlvbiBwZXJmb3JtRW50ZXIoa2V5KSB7XG4gICAgLy8gbWF5IGFscmVhZHkgcmVtb3ZlIGJ5IGV4Y2x1c2l2ZVxuICAgIGlmICh0aGlzLnJlZnNba2V5XSkge1xuICAgICAgdGhpcy5jdXJyZW50bHlBbmltYXRpbmdLZXlzW2tleV0gPSB0cnVlO1xuICAgICAgdGhpcy5yZWZzW2tleV0uY29tcG9uZW50V2lsbEVudGVyKHRoaXMuaGFuZGxlRG9uZUFkZGluZy5iaW5kKHRoaXMsIGtleSwgJ2VudGVyJykpO1xuICAgIH1cbiAgfSxcblxuICBwZXJmb3JtQXBwZWFyOiBmdW5jdGlvbiBwZXJmb3JtQXBwZWFyKGtleSkge1xuICAgIGlmICh0aGlzLnJlZnNba2V5XSkge1xuICAgICAgdGhpcy5jdXJyZW50bHlBbmltYXRpbmdLZXlzW2tleV0gPSB0cnVlO1xuICAgICAgdGhpcy5yZWZzW2tleV0uY29tcG9uZW50V2lsbEFwcGVhcih0aGlzLmhhbmRsZURvbmVBZGRpbmcuYmluZCh0aGlzLCBrZXksICdhcHBlYXInKSk7XG4gICAgfVxuICB9LFxuXG4gIGhhbmRsZURvbmVBZGRpbmc6IGZ1bmN0aW9uIGhhbmRsZURvbmVBZGRpbmcoa2V5LCB0eXBlKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICBkZWxldGUgdGhpcy5jdXJyZW50bHlBbmltYXRpbmdLZXlzW2tleV07XG4gICAgLy8gaWYgdXBkYXRlIG9uIGV4Y2x1c2l2ZSBtb2RlLCBza2lwIGNoZWNrXG4gICAgaWYgKHByb3BzLmV4Y2x1c2l2ZSAmJiBwcm9wcyAhPT0gdGhpcy5uZXh0UHJvcHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGN1cnJlbnRDaGlsZHJlbiA9ICgwLCBfQ2hpbGRyZW5VdGlscy50b0FycmF5Q2hpbGRyZW4pKGdldENoaWxkcmVuRnJvbVByb3BzKHByb3BzKSk7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWRDaGlsZEJ5S2V5KGN1cnJlbnRDaGlsZHJlbiwga2V5KSkge1xuICAgICAgLy8gZXhjbHVzaXZlIHdpbGwgbm90IG5lZWQgdGhpc1xuICAgICAgdGhpcy5wZXJmb3JtTGVhdmUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgPT09ICdhcHBlYXInKSB7XG4gICAgICAgIGlmIChfdXRpbDJbJ2RlZmF1bHQnXS5hbGxvd0FwcGVhckNhbGxiYWNrKHByb3BzKSkge1xuICAgICAgICAgIHByb3BzLm9uQXBwZWFyKGtleSk7XG4gICAgICAgICAgcHJvcHMub25FbmQoa2V5LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKF91dGlsMlsnZGVmYXVsdCddLmFsbG93RW50ZXJDYWxsYmFjayhwcm9wcykpIHtcbiAgICAgICAgICBwcm9wcy5vbkVudGVyKGtleSk7XG4gICAgICAgICAgcHJvcHMub25FbmQoa2V5LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBwZXJmb3JtTGVhdmU6IGZ1bmN0aW9uIHBlcmZvcm1MZWF2ZShrZXkpIHtcbiAgICAvLyBtYXkgYWxyZWFkeSByZW1vdmUgYnkgZXhjbHVzaXZlXG4gICAgaWYgKHRoaXMucmVmc1trZXldKSB7XG4gICAgICB0aGlzLmN1cnJlbnRseUFuaW1hdGluZ0tleXNba2V5XSA9IHRydWU7XG4gICAgICB0aGlzLnJlZnNba2V5XS5jb21wb25lbnRXaWxsTGVhdmUodGhpcy5oYW5kbGVEb25lTGVhdmluZy5iaW5kKHRoaXMsIGtleSkpO1xuICAgIH1cbiAgfSxcblxuICBoYW5kbGVEb25lTGVhdmluZzogZnVuY3Rpb24gaGFuZGxlRG9uZUxlYXZpbmcoa2V5KSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICBkZWxldGUgdGhpcy5jdXJyZW50bHlBbmltYXRpbmdLZXlzW2tleV07XG4gICAgLy8gaWYgdXBkYXRlIG9uIGV4Y2x1c2l2ZSBtb2RlLCBza2lwIGNoZWNrXG4gICAgaWYgKHByb3BzLmV4Y2x1c2l2ZSAmJiBwcm9wcyAhPT0gdGhpcy5uZXh0UHJvcHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGN1cnJlbnRDaGlsZHJlbiA9ICgwLCBfQ2hpbGRyZW5VdGlscy50b0FycmF5Q2hpbGRyZW4pKGdldENoaWxkcmVuRnJvbVByb3BzKHByb3BzKSk7XG4gICAgLy8gaW4gY2FzZSBzdGF0ZSBjaGFuZ2UgaXMgdG9vIGZhc3RcbiAgICBpZiAodGhpcy5pc1ZhbGlkQ2hpbGRCeUtleShjdXJyZW50Q2hpbGRyZW4sIGtleSkpIHtcbiAgICAgIHRoaXMucGVyZm9ybUVudGVyKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChfdXRpbDJbJ2RlZmF1bHQnXS5hbGxvd0xlYXZlQ2FsbGJhY2socHJvcHMpKSB7XG4gICAgICAgIHByb3BzLm9uTGVhdmUoa2V5KTtcbiAgICAgICAgcHJvcHMub25FbmQoa2V5LCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc01vdW50ZWQoKSAmJiAhKDAsIF9DaGlsZHJlblV0aWxzLmlzU2FtZUNoaWxkcmVuKSh0aGlzLnN0YXRlLmNoaWxkcmVuLCBjdXJyZW50Q2hpbGRyZW4sIHByb3BzLnNob3dQcm9wKSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBjaGlsZHJlbjogY3VycmVudENoaWxkcmVuXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBpc1ZhbGlkQ2hpbGRCeUtleTogZnVuY3Rpb24gaXNWYWxpZENoaWxkQnlLZXkoY3VycmVudENoaWxkcmVuLCBrZXkpIHtcbiAgICB2YXIgc2hvd1Byb3AgPSB0aGlzLnByb3BzLnNob3dQcm9wO1xuICAgIGlmIChzaG93UHJvcCkge1xuICAgICAgcmV0dXJuICgwLCBfQ2hpbGRyZW5VdGlscy5maW5kU2hvd25DaGlsZEluQ2hpbGRyZW5CeUtleSkoY3VycmVudENoaWxkcmVuLCBrZXksIHNob3dQcm9wKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBfQ2hpbGRyZW5VdGlscy5maW5kQ2hpbGRJbkNoaWxkcmVuQnlLZXkpKGN1cnJlbnRDaGlsZHJlbiwga2V5KTtcbiAgfSxcblxuICBzdG9wOiBmdW5jdGlvbiBzdG9wKGtleSkge1xuICAgIGRlbGV0ZSB0aGlzLmN1cnJlbnRseUFuaW1hdGluZ0tleXNba2V5XTtcbiAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5yZWZzW2tleV07XG4gICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgY29tcG9uZW50LnN0b3AoKTtcbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB0aGlzLm5leHRQcm9wcyA9IHByb3BzO1xuICAgIHZhciBzdGF0ZUNoaWxkcmVuID0gdGhpcy5zdGF0ZS5jaGlsZHJlbjtcbiAgICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuICAgIGlmIChzdGF0ZUNoaWxkcmVuKSB7XG4gICAgICBjaGlsZHJlbiA9IHN0YXRlQ2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGlsZC5rZXkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3Qgc2V0IGtleSBmb3IgPHJjLWFuaW1hdGU+IGNoaWxkcmVuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIF9BbmltYXRlQ2hpbGQyWydkZWZhdWx0J10sXG4gICAgICAgICAge1xuICAgICAgICAgICAga2V5OiBjaGlsZC5rZXksXG4gICAgICAgICAgICByZWY6IGNoaWxkLmtleSxcbiAgICAgICAgICAgIGFuaW1hdGlvbjogcHJvcHMuYW5pbWF0aW9uLFxuICAgICAgICAgICAgdHJhbnNpdGlvbk5hbWU6IHByb3BzLnRyYW5zaXRpb25OYW1lLFxuICAgICAgICAgICAgdHJhbnNpdGlvbkVudGVyOiBwcm9wcy50cmFuc2l0aW9uRW50ZXIsXG4gICAgICAgICAgICB0cmFuc2l0aW9uQXBwZWFyOiBwcm9wcy50cmFuc2l0aW9uQXBwZWFyLFxuICAgICAgICAgICAgdHJhbnNpdGlvbkxlYXZlOiBwcm9wcy50cmFuc2l0aW9uTGVhdmUgfSxcbiAgICAgICAgICBjaGlsZFxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBDb21wb25lbnQgPSBwcm9wcy5jb21wb25lbnQ7XG4gICAgaWYgKENvbXBvbmVudCkge1xuICAgICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIHRoaXMucHJvcHMsXG4gICAgICAgIGNoaWxkcmVuXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW5bMF0gfHwgbnVsbDtcbiAgfVxufSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEFuaW1hdGU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvfi9yYy10cmlnZ2VyL34vcmMtYW5pbWF0ZS9saWIvQW5pbWF0ZS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JlYWN0RG9tID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBfcmVhY3REb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3REb20pO1xuXG52YXIgX2Nzc0FuaW1hdGlvbiA9IHJlcXVpcmUoJ2Nzcy1hbmltYXRpb24nKTtcblxudmFyIF9jc3NBbmltYXRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3NzQW5pbWF0aW9uKTtcblxudmFyIF91dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbnZhciBfdXRpbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlsKTtcblxudmFyIHRyYW5zaXRpb25NYXAgPSB7XG4gIGVudGVyOiAndHJhbnNpdGlvbkVudGVyJyxcbiAgYXBwZWFyOiAndHJhbnNpdGlvbkFwcGVhcicsXG4gIGxlYXZlOiAndHJhbnNpdGlvbkxlYXZlJ1xufTtcblxudmFyIEFuaW1hdGVDaGlsZCA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnQW5pbWF0ZUNoaWxkJyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBjaGlsZHJlbjogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5hbnlcbiAgfSxcblxuICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5zdG9wKCk7XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbEVudGVyOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsRW50ZXIoZG9uZSkge1xuICAgIGlmIChfdXRpbDJbJ2RlZmF1bHQnXS5pc0VudGVyU3VwcG9ydGVkKHRoaXMucHJvcHMpKSB7XG4gICAgICB0aGlzLnRyYW5zaXRpb24oJ2VudGVyJywgZG9uZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvbmUoKTtcbiAgICB9XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbEFwcGVhcjogZnVuY3Rpb24gY29tcG9uZW50V2lsbEFwcGVhcihkb25lKSB7XG4gICAgaWYgKF91dGlsMlsnZGVmYXVsdCddLmlzQXBwZWFyU3VwcG9ydGVkKHRoaXMucHJvcHMpKSB7XG4gICAgICB0aGlzLnRyYW5zaXRpb24oJ2FwcGVhcicsIGRvbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb25lKCk7XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxMZWF2ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbExlYXZlKGRvbmUpIHtcbiAgICBpZiAoX3V0aWwyWydkZWZhdWx0J10uaXNMZWF2ZVN1cHBvcnRlZCh0aGlzLnByb3BzKSkge1xuICAgICAgdGhpcy50cmFuc2l0aW9uKCdsZWF2ZScsIGRvbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb25lKCk7XG4gICAgfVxuICB9LFxuXG4gIHRyYW5zaXRpb246IGZ1bmN0aW9uIHRyYW5zaXRpb24oYW5pbWF0aW9uVHlwZSwgZmluaXNoQ2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIG5vZGUgPSBfcmVhY3REb20yWydkZWZhdWx0J10uZmluZERPTU5vZGUodGhpcyk7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgdHJhbnNpdGlvbk5hbWUgPSBwcm9wcy50cmFuc2l0aW9uTmFtZTtcbiAgICB0aGlzLnN0b3AoKTtcbiAgICB2YXIgZW5kID0gZnVuY3Rpb24gZW5kKCkge1xuICAgICAgX3RoaXMuc3RvcHBlciA9IG51bGw7XG4gICAgICBmaW5pc2hDYWxsYmFjaygpO1xuICAgIH07XG4gICAgaWYgKChfY3NzQW5pbWF0aW9uLmlzQ3NzQW5pbWF0aW9uU3VwcG9ydGVkIHx8ICFwcm9wcy5hbmltYXRpb25bYW5pbWF0aW9uVHlwZV0pICYmIHRyYW5zaXRpb25OYW1lICYmIHByb3BzW3RyYW5zaXRpb25NYXBbYW5pbWF0aW9uVHlwZV1dKSB7XG4gICAgICB0aGlzLnN0b3BwZXIgPSAoMCwgX2Nzc0FuaW1hdGlvbjJbJ2RlZmF1bHQnXSkobm9kZSwgdHJhbnNpdGlvbk5hbWUgKyAnLScgKyBhbmltYXRpb25UeXBlLCBlbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0b3BwZXIgPSBwcm9wcy5hbmltYXRpb25bYW5pbWF0aW9uVHlwZV0obm9kZSwgZW5kKTtcbiAgICB9XG4gIH0sXG5cbiAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICB2YXIgc3RvcHBlciA9IHRoaXMuc3RvcHBlcjtcbiAgICBpZiAoc3RvcHBlcikge1xuICAgICAgdGhpcy5zdG9wcGVyID0gbnVsbDtcbiAgICAgIHN0b3BwZXIuc3RvcCgpO1xuICAgIH1cbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgfVxufSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEFuaW1hdGVDaGlsZDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9+L3JjLXRyaWdnZXIvfi9yYy1hbmltYXRlL2xpYi9BbmltYXRlQ2hpbGQuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfRXZlbnQgPSByZXF1aXJlKCcuL0V2ZW50Jyk7XG5cbnZhciBfRXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRXZlbnQpO1xuXG52YXIgX2NvbXBvbmVudENsYXNzZXMgPSByZXF1aXJlKCdjb21wb25lbnQtY2xhc3NlcycpO1xuXG52YXIgX2NvbXBvbmVudENsYXNzZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9uZW50Q2xhc3Nlcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG52YXIgaXNDc3NBbmltYXRpb25TdXBwb3J0ZWQgPSBfRXZlbnQyW1wiZGVmYXVsdFwiXS5lbmRFdmVudHMubGVuZ3RoICE9PSAwO1xuXG5cbnZhciBjYXBpdGFsUHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnTycsXG4vLyBtcyBpcyBzcGVjaWFsIC4uLi4gIVxuJ21zJ107XG52YXIgcHJlZml4ZXMgPSBbJy13ZWJraXQtJywgJy1tb3otJywgJy1vLScsICdtcy0nLCAnJ107XG5cbmZ1bmN0aW9uIGdldER1cmF0aW9uKG5vZGUsIG5hbWUpIHtcbiAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cbiAgdmFyIHJldCA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmV0ID0gc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcmVmaXhlc1tpXSArIG5hbWUpO1xuICAgIGlmIChyZXQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBmaXhCcm93c2VyQnlUaW1lb3V0KG5vZGUpIHtcbiAgaWYgKGlzQ3NzQW5pbWF0aW9uU3VwcG9ydGVkKSB7XG4gICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IHBhcnNlRmxvYXQoZ2V0RHVyYXRpb24obm9kZSwgJ3RyYW5zaXRpb24tZHVyYXRpb24nKSkgfHwgMDtcbiAgICB2YXIgYW5pbWF0aW9uRHVyYXRpb24gPSBwYXJzZUZsb2F0KGdldER1cmF0aW9uKG5vZGUsICdhbmltYXRpb24tZHVyYXRpb24nKSkgfHwgMDtcbiAgICB2YXIgdGltZSA9IE1hdGgubWF4KHRyYW5zaXRpb25EdXJhdGlvbiwgYW5pbWF0aW9uRHVyYXRpb24pO1xuICAgIC8vIHNvbWV0aW1lcywgYnJvd3NlciBidWdcbiAgICBub2RlLnJjRW5kQW5pbVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIG5vZGUucmNFbmRBbmltVGltZW91dCA9IG51bGw7XG4gICAgICBpZiAobm9kZS5yY0VuZExpc3RlbmVyKSB7XG4gICAgICAgIG5vZGUucmNFbmRMaXN0ZW5lcigpO1xuICAgICAgfVxuICAgIH0sIHRpbWUgKiAxMDAwICsgMjAwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhckJyb3dzZXJCdWdUaW1lb3V0KG5vZGUpIHtcbiAgaWYgKG5vZGUucmNFbmRBbmltVGltZW91dCkge1xuICAgIGNsZWFyVGltZW91dChub2RlLnJjRW5kQW5pbVRpbWVvdXQpO1xuICAgIG5vZGUucmNFbmRBbmltVGltZW91dCA9IG51bGw7XG4gIH1cbn1cblxudmFyIGNzc0FuaW1hdGlvbiA9IGZ1bmN0aW9uIGNzc0FuaW1hdGlvbihub2RlLCB0cmFuc2l0aW9uTmFtZSwgZW5kQ2FsbGJhY2spIHtcbiAgdmFyIGNsYXNzTmFtZSA9IHRyYW5zaXRpb25OYW1lO1xuICB2YXIgYWN0aXZlQ2xhc3NOYW1lID0gY2xhc3NOYW1lICsgJy1hY3RpdmUnO1xuICB2YXIgZW5kID0gZW5kQ2FsbGJhY2s7XG4gIHZhciBzdGFydCA9IHZvaWQgMDtcbiAgdmFyIGFjdGl2ZSA9IHZvaWQgMDtcbiAgdmFyIG5vZGVDbGFzc2VzID0gKDAsIF9jb21wb25lbnRDbGFzc2VzMltcImRlZmF1bHRcIl0pKG5vZGUpO1xuXG4gIGlmIChlbmRDYWxsYmFjayAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZW5kQ2FsbGJhY2spID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIGVuZCA9IGVuZENhbGxiYWNrLmVuZDtcbiAgICBzdGFydCA9IGVuZENhbGxiYWNrLnN0YXJ0O1xuICAgIGFjdGl2ZSA9IGVuZENhbGxiYWNrLmFjdGl2ZTtcbiAgfVxuXG4gIGlmIChub2RlLnJjRW5kTGlzdGVuZXIpIHtcbiAgICBub2RlLnJjRW5kTGlzdGVuZXIoKTtcbiAgfVxuXG4gIG5vZGUucmNFbmRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUgJiYgZS50YXJnZXQgIT09IG5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5yY0FuaW1UaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQobm9kZS5yY0FuaW1UaW1lb3V0KTtcbiAgICAgIG5vZGUucmNBbmltVGltZW91dCA9IG51bGw7XG4gICAgfVxuXG4gICAgY2xlYXJCcm93c2VyQnVnVGltZW91dChub2RlKTtcblxuICAgIG5vZGVDbGFzc2VzLnJlbW92ZShjbGFzc05hbWUpO1xuICAgIG5vZGVDbGFzc2VzLnJlbW92ZShhY3RpdmVDbGFzc05hbWUpO1xuXG4gICAgX0V2ZW50MltcImRlZmF1bHRcIl0ucmVtb3ZlRW5kRXZlbnRMaXN0ZW5lcihub2RlLCBub2RlLnJjRW5kTGlzdGVuZXIpO1xuICAgIG5vZGUucmNFbmRMaXN0ZW5lciA9IG51bGw7XG5cbiAgICAvLyBVc3VhbGx5IHRoaXMgb3B0aW9uYWwgZW5kIGlzIHVzZWQgZm9yIGluZm9ybWluZyBhbiBvd25lciBvZlxuICAgIC8vIGEgbGVhdmUgYW5pbWF0aW9uIGFuZCB0ZWxsaW5nIGl0IHRvIHJlbW92ZSB0aGUgY2hpbGQuXG4gICAgaWYgKGVuZCkge1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9O1xuXG4gIF9FdmVudDJbXCJkZWZhdWx0XCJdLmFkZEVuZEV2ZW50TGlzdGVuZXIobm9kZSwgbm9kZS5yY0VuZExpc3RlbmVyKTtcblxuICBub2RlQ2xhc3Nlcy5hZGQoY2xhc3NOYW1lKTtcblxuICBpZiAoc3RhcnQpIHtcbiAgICBzdGFydCgpO1xuICB9XG5cbiAgbm9kZS5yY0FuaW1UaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgbm9kZS5yY0FuaW1UaW1lb3V0ID0gbnVsbDtcbiAgICBub2RlQ2xhc3Nlcy5hZGQoYWN0aXZlQ2xhc3NOYW1lKTtcbiAgICBpZiAoYWN0aXZlKSB7XG4gICAgICBhY3RpdmUoKTtcbiAgICB9XG4gICAgZml4QnJvd3NlckJ5VGltZW91dChub2RlKTtcbiAgfSwgMCk7XG5cbiAgcmV0dXJuIHtcbiAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgaWYgKG5vZGUucmNFbmRMaXN0ZW5lcikge1xuICAgICAgICBub2RlLnJjRW5kTGlzdGVuZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuXG5jc3NBbmltYXRpb24uc3R5bGUgPSBmdW5jdGlvbiAobm9kZSwgc3R5bGUsIGNhbGxiYWNrKSB7XG4gIGlmIChub2RlLnJjRW5kTGlzdGVuZXIpIHtcbiAgICBub2RlLnJjRW5kTGlzdGVuZXIoKTtcbiAgfVxuXG4gIG5vZGUucmNFbmRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUgJiYgZS50YXJnZXQgIT09IG5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5yY0FuaW1UaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQobm9kZS5yY0FuaW1UaW1lb3V0KTtcbiAgICAgIG5vZGUucmNBbmltVGltZW91dCA9IG51bGw7XG4gICAgfVxuXG4gICAgY2xlYXJCcm93c2VyQnVnVGltZW91dChub2RlKTtcblxuICAgIF9FdmVudDJbXCJkZWZhdWx0XCJdLnJlbW92ZUVuZEV2ZW50TGlzdGVuZXIobm9kZSwgbm9kZS5yY0VuZExpc3RlbmVyKTtcbiAgICBub2RlLnJjRW5kTGlzdGVuZXIgPSBudWxsO1xuXG4gICAgLy8gVXN1YWxseSB0aGlzIG9wdGlvbmFsIGNhbGxiYWNrIGlzIHVzZWQgZm9yIGluZm9ybWluZyBhbiBvd25lciBvZlxuICAgIC8vIGEgbGVhdmUgYW5pbWF0aW9uIGFuZCB0ZWxsaW5nIGl0IHRvIHJlbW92ZSB0aGUgY2hpbGQuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfTtcblxuICBfRXZlbnQyW1wiZGVmYXVsdFwiXS5hZGRFbmRFdmVudExpc3RlbmVyKG5vZGUsIG5vZGUucmNFbmRMaXN0ZW5lcik7XG5cbiAgbm9kZS5yY0FuaW1UaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyBpbiBzdHlsZSkge1xuICAgICAgaWYgKHN0eWxlLmhhc093blByb3BlcnR5KHMpKSB7XG4gICAgICAgIG5vZGUuc3R5bGVbc10gPSBzdHlsZVtzXTtcbiAgICAgIH1cbiAgICB9XG4gICAgbm9kZS5yY0FuaW1UaW1lb3V0ID0gbnVsbDtcbiAgICBmaXhCcm93c2VyQnlUaW1lb3V0KG5vZGUpO1xuICB9LCAwKTtcbn07XG5cbmNzc0FuaW1hdGlvbi5zZXRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKG5vZGUsIHAsIHZhbHVlKSB7XG4gIHZhciBwcm9wZXJ0eSA9IHA7XG4gIHZhciB2ID0gdmFsdWU7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdiA9IHByb3BlcnR5O1xuICAgIHByb3BlcnR5ID0gJyc7XG4gIH1cbiAgcHJvcGVydHkgPSBwcm9wZXJ0eSB8fCAnJztcbiAgY2FwaXRhbFByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgIG5vZGUuc3R5bGVbcHJlZml4ICsgJ1RyYW5zaXRpb24nICsgcHJvcGVydHldID0gdjtcbiAgfSk7XG59O1xuXG5jc3NBbmltYXRpb24uaXNDc3NBbmltYXRpb25TdXBwb3J0ZWQgPSBpc0Nzc0FuaW1hdGlvblN1cHBvcnRlZDtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBjc3NBbmltYXRpb247XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvfi9yYy10cmlnZ2VyL34vcmMtYW5pbWF0ZS9+L2Nzcy1hbmltYXRpb24vbGliL2luZGV4LmpzXG4gKiovIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnRyeSB7XG4gIHZhciBpbmRleCA9IHJlcXVpcmUoJ2luZGV4b2YnKTtcbn0gY2F0Y2ggKGVycikge1xuICB2YXIgaW5kZXggPSByZXF1aXJlKCdjb21wb25lbnQtaW5kZXhvZicpO1xufVxuXG4vKipcbiAqIFdoaXRlc3BhY2UgcmVnZXhwLlxuICovXG5cbnZhciByZSA9IC9cXHMrLztcblxuLyoqXG4gKiB0b1N0cmluZyByZWZlcmVuY2UuXG4gKi9cblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBXcmFwIGBlbGAgaW4gYSBgQ2xhc3NMaXN0YC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtDbGFzc0xpc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZWwpe1xuICByZXR1cm4gbmV3IENsYXNzTGlzdChlbCk7XG59O1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgQ2xhc3NMaXN0IGZvciBgZWxgLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIENsYXNzTGlzdChlbCkge1xuICBpZiAoIWVsIHx8ICFlbC5ub2RlVHlwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQSBET00gZWxlbWVudCByZWZlcmVuY2UgaXMgcmVxdWlyZWQnKTtcbiAgfVxuICB0aGlzLmVsID0gZWw7XG4gIHRoaXMubGlzdCA9IGVsLmNsYXNzTGlzdDtcbn1cblxuLyoqXG4gKiBBZGQgY2xhc3MgYG5hbWVgIGlmIG5vdCBhbHJlYWR5IHByZXNlbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0NsYXNzTGlzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ2xhc3NMaXN0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihuYW1lKXtcbiAgLy8gY2xhc3NMaXN0XG4gIGlmICh0aGlzLmxpc3QpIHtcbiAgICB0aGlzLmxpc3QuYWRkKG5hbWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZmFsbGJhY2tcbiAgdmFyIGFyciA9IHRoaXMuYXJyYXkoKTtcbiAgdmFyIGkgPSBpbmRleChhcnIsIG5hbWUpO1xuICBpZiAoIX5pKSBhcnIucHVzaChuYW1lKTtcbiAgdGhpcy5lbC5jbGFzc05hbWUgPSBhcnIuam9pbignICcpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGNsYXNzIGBuYW1lYCB3aGVuIHByZXNlbnQsIG9yXG4gKiBwYXNzIGEgcmVndWxhciBleHByZXNzaW9uIHRvIHJlbW92ZVxuICogYW55IHdoaWNoIG1hdGNoLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gbmFtZVxuICogQHJldHVybiB7Q2xhc3NMaXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5DbGFzc0xpc3QucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKG5hbWUpe1xuICBpZiAoJ1tvYmplY3QgUmVnRXhwXScgPT0gdG9TdHJpbmcuY2FsbChuYW1lKSkge1xuICAgIHJldHVybiB0aGlzLnJlbW92ZU1hdGNoaW5nKG5hbWUpO1xuICB9XG5cbiAgLy8gY2xhc3NMaXN0XG4gIGlmICh0aGlzLmxpc3QpIHtcbiAgICB0aGlzLmxpc3QucmVtb3ZlKG5hbWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZmFsbGJhY2tcbiAgdmFyIGFyciA9IHRoaXMuYXJyYXkoKTtcbiAgdmFyIGkgPSBpbmRleChhcnIsIG5hbWUpO1xuICBpZiAofmkpIGFyci5zcGxpY2UoaSwgMSk7XG4gIHRoaXMuZWwuY2xhc3NOYW1lID0gYXJyLmpvaW4oJyAnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgY2xhc3NlcyBtYXRjaGluZyBgcmVgLlxuICpcbiAqIEBwYXJhbSB7UmVnRXhwfSByZVxuICogQHJldHVybiB7Q2xhc3NMaXN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQ2xhc3NMaXN0LnByb3RvdHlwZS5yZW1vdmVNYXRjaGluZyA9IGZ1bmN0aW9uKHJlKXtcbiAgdmFyIGFyciA9IHRoaXMuYXJyYXkoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocmUudGVzdChhcnJbaV0pKSB7XG4gICAgICB0aGlzLnJlbW92ZShhcnJbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVG9nZ2xlIGNsYXNzIGBuYW1lYCwgY2FuIGZvcmNlIHN0YXRlIHZpYSBgZm9yY2VgLlxuICpcbiAqIEZvciBicm93c2VycyB0aGF0IHN1cHBvcnQgY2xhc3NMaXN0LCBidXQgZG8gbm90IHN1cHBvcnQgYGZvcmNlYCB5ZXQsXG4gKiB0aGUgbWlzdGFrZSB3aWxsIGJlIGRldGVjdGVkIGFuZCBjb3JyZWN0ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2VcbiAqIEByZXR1cm4ge0NsYXNzTGlzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ2xhc3NMaXN0LnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbihuYW1lLCBmb3JjZSl7XG4gIC8vIGNsYXNzTGlzdFxuICBpZiAodGhpcy5saXN0KSB7XG4gICAgaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBmb3JjZSkge1xuICAgICAgaWYgKGZvcmNlICE9PSB0aGlzLmxpc3QudG9nZ2xlKG5hbWUsIGZvcmNlKSkge1xuICAgICAgICB0aGlzLmxpc3QudG9nZ2xlKG5hbWUpOyAvLyB0b2dnbGUgYWdhaW4gdG8gY29ycmVjdFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxpc3QudG9nZ2xlKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGZhbGxiYWNrXG4gIGlmIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgZm9yY2UpIHtcbiAgICBpZiAoIWZvcmNlKSB7XG4gICAgICB0aGlzLnJlbW92ZShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGQobmFtZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0aGlzLmhhcyhuYW1lKSkge1xuICAgICAgdGhpcy5yZW1vdmUobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkKG5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYW4gYXJyYXkgb2YgY2xhc3Nlcy5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ2xhc3NMaXN0LnByb3RvdHlwZS5hcnJheSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBjbGFzc05hbWUgPSB0aGlzLmVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJztcbiAgdmFyIHN0ciA9IGNsYXNzTmFtZS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG4gIHZhciBhcnIgPSBzdHIuc3BsaXQocmUpO1xuICBpZiAoJycgPT09IGFyclswXSkgYXJyLnNoaWZ0KCk7XG4gIHJldHVybiBhcnI7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGNsYXNzIGBuYW1lYCBpcyBwcmVzZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtDbGFzc0xpc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNsYXNzTGlzdC5wcm90b3R5cGUuaGFzID1cbkNsYXNzTGlzdC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbihuYW1lKXtcbiAgcmV0dXJuIHRoaXMubGlzdFxuICAgID8gdGhpcy5saXN0LmNvbnRhaW5zKG5hbWUpXG4gICAgOiAhISB+aW5kZXgodGhpcy5hcnJheSgpLCBuYW1lKTtcbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWNhbGVuZGFyL34vcmMtY2FsZW5kYXIvfi9yYy10cmlnZ2VyL34vcmMtYW5pbWF0ZS9+L2Nzcy1hbmltYXRpb24vfi9jb21wb25lbnQtY2xhc3Nlcy9pbmRleC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX0xhenlSZW5kZXJCb3ggPSByZXF1aXJlKCcuL0xhenlSZW5kZXJCb3gnKTtcblxudmFyIF9MYXp5UmVuZGVyQm94MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0xhenlSZW5kZXJCb3gpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxudmFyIFBvcHVwSW5uZXIgPSBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUG9wdXBJbm5lcicsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgaGlkZGVuQ2xhc3NOYW1lOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBjbGFzc05hbWU6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHByZWZpeENsczogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgb25Nb3VzZUVudGVyOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Nb3VzZUxlYXZlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgY2hpbGRyZW46IF9yZWFjdC5Qcm9wVHlwZXMuYW55XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZTtcbiAgICBpZiAoIXByb3BzLnZpc2libGUpIHtcbiAgICAgIGNsYXNzTmFtZSArPSAnICcgKyBwcm9wcy5oaWRkZW5DbGFzc05hbWU7XG4gICAgfVxuICAgIHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFxuICAgICAgJ2RpdicsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgICBvbk1vdXNlRW50ZXI6IHByb3BzLm9uTW91c2VFbnRlcixcbiAgICAgICAgb25Nb3VzZUxlYXZlOiBwcm9wcy5vbk1vdXNlTGVhdmUsXG4gICAgICAgIHN0eWxlOiBwcm9wcy5zdHlsZVxuICAgICAgfSxcbiAgICAgIF9yZWFjdDJbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIF9MYXp5UmVuZGVyQm94MltcImRlZmF1bHRcIl0sXG4gICAgICAgIHsgY2xhc3NOYW1lOiBwcm9wcy5wcmVmaXhDbHMgKyAnLWNvbnRlbnQnLCB2aXNpYmxlOiBwcm9wcy52aXNpYmxlIH0sXG4gICAgICAgIHByb3BzLmNoaWxkcmVuXG4gICAgICApXG4gICAgKTtcbiAgfVxufSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUG9wdXBJbm5lcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtY2FsZW5kYXIvfi9yYy1jYWxlbmRhci9+L3JjLXRyaWdnZXIvbGliL1BvcHVwSW5uZXIuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9Ub29sdGlwJyk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS10b29sdGlwL34vcmMtdG9vbHRpcC9saWIvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3BsYWNlbWVudHMgPSByZXF1aXJlKCcuL3BsYWNlbWVudHMnKTtcblxudmFyIF9yY1RyaWdnZXIgPSByZXF1aXJlKCdyYy10cmlnZ2VyJyk7XG5cbnZhciBfcmNUcmlnZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JjVHJpZ2dlcik7XG5cbnZhciBUb29sdGlwID0gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdUb29sdGlwJyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICB0cmlnZ2VyOiBfcmVhY3QuUHJvcFR5cGVzLmFueSxcbiAgICBjaGlsZHJlbjogX3JlYWN0LlByb3BUeXBlcy5hbnksXG4gICAgZGVmYXVsdFZpc2libGU6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICB2aXNpYmxlOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgcGxhY2VtZW50OiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICB0cmFuc2l0aW9uTmFtZTogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgYW5pbWF0aW9uOiBfcmVhY3QuUHJvcFR5cGVzLmFueSxcbiAgICBvblZpc2libGVDaGFuZ2U6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBhZnRlclZpc2libGVDaGFuZ2U6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvdmVybGF5OiBfcmVhY3QuUHJvcFR5cGVzLm5vZGUuaXNSZXF1aXJlZCxcbiAgICBvdmVybGF5U3R5bGU6IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIG92ZXJsYXlDbGFzc05hbWU6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHByZWZpeENsczogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgbW91c2VFbnRlckRlbGF5OiBfcmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgICBtb3VzZUxlYXZlRGVsYXk6IF9yZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgIGdldFRvb2x0aXBDb250YWluZXI6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBkZXN0cm95VG9vbHRpcE9uSGlkZTogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGFsaWduOiBfcmVhY3QuUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgIG9mZnNldDogX3JlYWN0LlByb3BUeXBlcy5hcnJheSxcbiAgICAgIHRhcmdldE9mZnNldDogX3JlYWN0LlByb3BUeXBlcy5hcnJheVxuICAgIH0pLFxuICAgIGFycm93Q29udGVudDogX3JlYWN0LlByb3BUeXBlcy5hbnlcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHJlZml4Q2xzOiAncmMtdG9vbHRpcCcsXG4gICAgICBtb3VzZUVudGVyRGVsYXk6IDAsXG4gICAgICBkZXN0cm95VG9vbHRpcE9uSGlkZTogZmFsc2UsXG4gICAgICBtb3VzZUxlYXZlRGVsYXk6IDAuMSxcbiAgICAgIGFsaWduOiB7fSxcbiAgICAgIHBsYWNlbWVudDogJ3JpZ2h0JyxcbiAgICAgIHRyaWdnZXI6IFsnaG92ZXInXSxcbiAgICAgIGFycm93Q29udGVudDogbnVsbFxuICAgIH07XG4gIH0sXG5cbiAgZ2V0UG9wdXBFbGVtZW50OiBmdW5jdGlvbiBnZXRQb3B1cEVsZW1lbnQoKSB7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGFycm93Q29udGVudCA9IF9wcm9wcy5hcnJvd0NvbnRlbnQ7XG4gICAgdmFyIG92ZXJsYXkgPSBfcHJvcHMub3ZlcmxheTtcbiAgICB2YXIgcHJlZml4Q2xzID0gX3Byb3BzLnByZWZpeENscztcblxuICAgIHJldHVybiBbX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnZGl2JyxcbiAgICAgIHsgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLWFycm93Jywga2V5OiAnYXJyb3cnIH0sXG4gICAgICBhcnJvd0NvbnRlbnRcbiAgICApLCBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICdkaXYnLFxuICAgICAgeyBjbGFzc05hbWU6IHByZWZpeENscyArICctaW5uZXInLCBrZXk6ICdjb250ZW50JyB9LFxuICAgICAgb3ZlcmxheVxuICAgICldO1xuICB9LFxuXG4gIGdldFBvcHVwRG9tTm9kZTogZnVuY3Rpb24gZ2V0UG9wdXBEb21Ob2RlKCkge1xuICAgIHJldHVybiB0aGlzLnJlZnMudHJpZ2dlci5wb3B1cERvbU5vZGU7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF9wcm9wczIgPSB0aGlzLnByb3BzO1xuICAgIHZhciBvdmVybGF5Q2xhc3NOYW1lID0gX3Byb3BzMi5vdmVybGF5Q2xhc3NOYW1lO1xuICAgIHZhciB0cmlnZ2VyID0gX3Byb3BzMi50cmlnZ2VyO1xuICAgIHZhciBtb3VzZUVudGVyRGVsYXkgPSBfcHJvcHMyLm1vdXNlRW50ZXJEZWxheTtcbiAgICB2YXIgbW91c2VMZWF2ZURlbGF5ID0gX3Byb3BzMi5tb3VzZUxlYXZlRGVsYXk7XG4gICAgdmFyIG92ZXJsYXlTdHlsZSA9IF9wcm9wczIub3ZlcmxheVN0eWxlO1xuICAgIHZhciBwcmVmaXhDbHMgPSBfcHJvcHMyLnByZWZpeENscztcbiAgICB2YXIgY2hpbGRyZW4gPSBfcHJvcHMyLmNoaWxkcmVuO1xuICAgIHZhciBvblZpc2libGVDaGFuZ2UgPSBfcHJvcHMyLm9uVmlzaWJsZUNoYW5nZTtcbiAgICB2YXIgdHJhbnNpdGlvbk5hbWUgPSBfcHJvcHMyLnRyYW5zaXRpb25OYW1lO1xuICAgIHZhciBhbmltYXRpb24gPSBfcHJvcHMyLmFuaW1hdGlvbjtcbiAgICB2YXIgcGxhY2VtZW50ID0gX3Byb3BzMi5wbGFjZW1lbnQ7XG4gICAgdmFyIGFsaWduID0gX3Byb3BzMi5hbGlnbjtcbiAgICB2YXIgZGVzdHJveVRvb2x0aXBPbkhpZGUgPSBfcHJvcHMyLmRlc3Ryb3lUb29sdGlwT25IaWRlO1xuICAgIHZhciBkZWZhdWx0VmlzaWJsZSA9IF9wcm9wczIuZGVmYXVsdFZpc2libGU7XG4gICAgdmFyIGdldFRvb2x0aXBDb250YWluZXIgPSBfcHJvcHMyLmdldFRvb2x0aXBDb250YWluZXI7XG5cbiAgICB2YXIgcmVzdFByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wczIsIFsnb3ZlcmxheUNsYXNzTmFtZScsICd0cmlnZ2VyJywgJ21vdXNlRW50ZXJEZWxheScsICdtb3VzZUxlYXZlRGVsYXknLCAnb3ZlcmxheVN0eWxlJywgJ3ByZWZpeENscycsICdjaGlsZHJlbicsICdvblZpc2libGVDaGFuZ2UnLCAndHJhbnNpdGlvbk5hbWUnLCAnYW5pbWF0aW9uJywgJ3BsYWNlbWVudCcsICdhbGlnbicsICdkZXN0cm95VG9vbHRpcE9uSGlkZScsICdkZWZhdWx0VmlzaWJsZScsICdnZXRUb29sdGlwQ29udGFpbmVyJ10pO1xuXG4gICAgdmFyIGV4dHJhUHJvcHMgPSBfZXh0ZW5kcyh7fSwgcmVzdFByb3BzKTtcbiAgICBpZiAoJ3Zpc2libGUnIGluIHRoaXMucHJvcHMpIHtcbiAgICAgIGV4dHJhUHJvcHMucG9wdXBWaXNpYmxlID0gdGhpcy5wcm9wcy52aXNpYmxlO1xuICAgIH1cbiAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBfcmNUcmlnZ2VyMlsnZGVmYXVsdCddLFxuICAgICAgX2V4dGVuZHMoeyBwb3B1cENsYXNzTmFtZTogb3ZlcmxheUNsYXNzTmFtZSxcbiAgICAgICAgcmVmOiAndHJpZ2dlcicsXG4gICAgICAgIHByZWZpeENsczogcHJlZml4Q2xzLFxuICAgICAgICBwb3B1cDogdGhpcy5nZXRQb3B1cEVsZW1lbnQoKSxcbiAgICAgICAgYWN0aW9uOiB0cmlnZ2VyLFxuICAgICAgICBidWlsdGluUGxhY2VtZW50czogX3BsYWNlbWVudHMucGxhY2VtZW50cyxcbiAgICAgICAgcG9wdXBQbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgICAgcG9wdXBBbGlnbjogYWxpZ24sXG4gICAgICAgIGdldFBvcHVwQ29udGFpbmVyOiBnZXRUb29sdGlwQ29udGFpbmVyLFxuICAgICAgICBvblBvcHVwVmlzaWJsZUNoYW5nZTogb25WaXNpYmxlQ2hhbmdlLFxuICAgICAgICBwb3B1cFRyYW5zaXRpb25OYW1lOiB0cmFuc2l0aW9uTmFtZSxcbiAgICAgICAgcG9wdXBBbmltYXRpb246IGFuaW1hdGlvbixcbiAgICAgICAgZGVmYXVsdFBvcHVwVmlzaWJsZTogZGVmYXVsdFZpc2libGUsXG4gICAgICAgIGRlc3Ryb3lQb3B1cE9uSGlkZTogZGVzdHJveVRvb2x0aXBPbkhpZGUsXG4gICAgICAgIG1vdXNlTGVhdmVEZWxheTogbW91c2VMZWF2ZURlbGF5LFxuICAgICAgICBwb3B1cFN0eWxlOiBvdmVybGF5U3R5bGUsXG4gICAgICAgIG1vdXNlRW50ZXJEZWxheTogbW91c2VFbnRlckRlbGF5XG4gICAgICB9LCBleHRyYVByb3BzKSxcbiAgICAgIGNoaWxkcmVuXG4gICAgKTtcbiAgfVxufSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFRvb2x0aXA7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLXRvb2x0aXAvfi9yYy10b29sdGlwL2xpYi9Ub29sdGlwLmpzXG4gKiovIiwidmFyIHBTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBvYmplY3RLZXlzID0gcmVxdWlyZSgnLi9saWIva2V5cy5qcycpO1xudmFyIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9saWIvaXNfYXJndW1lbnRzLmpzJyk7XG5cbnZhciBkZWVwRXF1YWwgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhY3R1YWwsIGV4cGVjdGVkLCBvcHRzKSB7XG4gIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIERhdGUgJiYgZXhwZWN0ZWQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5nZXRUaW1lKCkgPT09IGV4cGVjdGVkLmdldFRpbWUoKTtcblxuICAvLyA3LjMuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIH0gZWxzZSBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQgfHwgdHlwZW9mIGFjdHVhbCAhPSAnb2JqZWN0JyAmJiB0eXBlb2YgZXhwZWN0ZWQgIT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gb3B0cy5zdHJpY3QgPyBhY3R1YWwgPT09IGV4cGVjdGVkIDogYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIDcuNC4gRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpc1xuICAvLyBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAvLyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5XG4gIC8vIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmpFcXVpdihhY3R1YWwsIGV4cGVjdGVkLCBvcHRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZE9yTnVsbCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKHgpIHtcbiAgaWYgKCF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgeC5sZW5ndGggIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgeC5jb3B5ICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB4LnNsaWNlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh4Lmxlbmd0aCA+IDAgJiYgdHlwZW9mIHhbMF0gIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBvcHRzKSB7XG4gIHZhciBpLCBrZXk7XG4gIGlmIChpc1VuZGVmaW5lZE9yTnVsbChhKSB8fCBpc1VuZGVmaW5lZE9yTnVsbChiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkgcmV0dXJuIGZhbHNlO1xuICAvL35+fkkndmUgbWFuYWdlZCB0byBicmVhayBPYmplY3Qua2V5cyB0aHJvdWdoIHNjcmV3eSBhcmd1bWVudHMgcGFzc2luZy5cbiAgLy8gICBDb252ZXJ0aW5nIHRvIGFycmF5IHNvbHZlcyB0aGUgcHJvYmxlbS5cbiAgaWYgKGlzQXJndW1lbnRzKGEpKSB7XG4gICAgaWYgKCFpc0FyZ3VtZW50cyhiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBkZWVwRXF1YWwoYSwgYiwgb3B0cyk7XG4gIH1cbiAgaWYgKGlzQnVmZmVyKGEpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHRyeSB7XG4gICAgdmFyIGthID0gb2JqZWN0S2V5cyhhKSxcbiAgICAgICAga2IgPSBvYmplY3RLZXlzKGIpO1xuICB9IGNhdGNoIChlKSB7Ly9oYXBwZW5zIHdoZW4gb25lIGlzIGEgc3RyaW5nIGxpdGVyYWwgYW5kIHRoZSBvdGhlciBpc24ndFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzXG4gIC8vIGhhc093blByb3BlcnR5KVxuICBpZiAoa2EubGVuZ3RoICE9IGtiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvL35+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9IGtiW2ldKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LCBhbmRcbiAgLy9+fn5wb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIG9wdHMpKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYjtcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtZm9ybS9+L2RlZXAtZXF1YWwvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfTWVudSA9IHJlcXVpcmUoJy4vTWVudScpO1xuXG52YXIgX01lbnUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWVudSk7XG5cbnZhciBfU3ViTWVudSA9IHJlcXVpcmUoJy4vU3ViTWVudScpO1xuXG52YXIgX1N1Yk1lbnUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3ViTWVudSk7XG5cbnZhciBfTWVudUl0ZW0gPSByZXF1aXJlKCcuL01lbnVJdGVtJyk7XG5cbnZhciBfTWVudUl0ZW0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWVudUl0ZW0pO1xuXG52YXIgX01lbnVJdGVtR3JvdXAgPSByZXF1aXJlKCcuL01lbnVJdGVtR3JvdXAnKTtcblxudmFyIF9NZW51SXRlbUdyb3VwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01lbnVJdGVtR3JvdXApO1xuXG52YXIgX0RpdmlkZXIgPSByZXF1aXJlKCcuL0RpdmlkZXInKTtcblxudmFyIF9EaXZpZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RpdmlkZXIpO1xuXG5leHBvcnRzLlN1Yk1lbnUgPSBfU3ViTWVudTJbJ2RlZmF1bHQnXTtcbmV4cG9ydHMuSXRlbSA9IF9NZW51SXRlbTJbJ2RlZmF1bHQnXTtcbmV4cG9ydHMuTWVudUl0ZW0gPSBfTWVudUl0ZW0yWydkZWZhdWx0J107XG5leHBvcnRzLk1lbnVJdGVtR3JvdXAgPSBfTWVudUl0ZW1Hcm91cDJbJ2RlZmF1bHQnXTtcbmV4cG9ydHMuSXRlbUdyb3VwID0gX01lbnVJdGVtR3JvdXAyWydkZWZhdWx0J107XG5leHBvcnRzLkRpdmlkZXIgPSBfRGl2aWRlcjJbJ2RlZmF1bHQnXTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IF9NZW51MlsnZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtc2VsZWN0Mi9+L3JjLXNlbGVjdC9+L3JjLW1lbnUvbGliL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfTWVudU1peGluID0gcmVxdWlyZSgnLi9NZW51TWl4aW4nKTtcblxudmFyIF9NZW51TWl4aW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWVudU1peGluKTtcblxudmFyIF9vYmplY3RBc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBfb2JqZWN0QXNzaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29iamVjdEFzc2lnbik7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgTWVudSA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnTWVudScsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgb3BlblN1Yk1lbnVPbk1vdXNlRW50ZXI6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCxcbiAgICBjbG9zZVN1Yk1lbnVPbk1vdXNlTGVhdmU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCxcbiAgICBzZWxlY3RlZEtleXM6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYXJyYXlPZihfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLnN0cmluZyksXG4gICAgZGVmYXVsdFNlbGVjdGVkS2V5czogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5hcnJheU9mKF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nKSxcbiAgICBkZWZhdWx0T3BlbktleXM6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYXJyYXlPZihfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLnN0cmluZyksXG4gICAgb3BlbktleXM6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYXJyYXlPZihfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLnN0cmluZyksXG4gICAgbW9kZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmcsXG4gICAgb25DbGljazogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLFxuICAgIG9uU2VsZWN0OiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25EZXNlbGVjdDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLFxuICAgIG9uRGVzdHJveTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLFxuICAgIG9wZW5UcmFuc2l0aW9uTmFtZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmcsXG4gICAgb3BlbkFuaW1hdGlvbjogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5vbmVPZlR5cGUoW19yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nLCBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm9iamVjdF0pLFxuICAgIGxldmVsOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm51bWJlcixcbiAgICBldmVudEtleTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmcsXG4gICAgc2VsZWN0YWJsZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLFxuICAgIGNoaWxkcmVuOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmFueVxuICB9LFxuXG4gIG1peGluczogW19NZW51TWl4aW4yWydkZWZhdWx0J11dLFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvcGVuU3ViTWVudU9uTW91c2VFbnRlcjogdHJ1ZSxcbiAgICAgIGNsb3NlU3ViTWVudU9uTW91c2VMZWF2ZTogdHJ1ZSxcbiAgICAgIHNlbGVjdGFibGU6IHRydWUsXG4gICAgICBvbkNsaWNrOiBfdXRpbC5ub29wLFxuICAgICAgb25TZWxlY3Q6IF91dGlsLm5vb3AsXG4gICAgICBvbk9wZW46IF91dGlsLm5vb3AsXG4gICAgICBvbkNsb3NlOiBfdXRpbC5ub29wLFxuICAgICAgb25EZXNlbGVjdDogX3V0aWwubm9vcCxcbiAgICAgIGRlZmF1bHRTZWxlY3RlZEtleXM6IFtdLFxuICAgICAgZGVmYXVsdE9wZW5LZXlzOiBbXVxuICAgIH07XG4gIH0sXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgc2VsZWN0ZWRLZXlzID0gcHJvcHMuZGVmYXVsdFNlbGVjdGVkS2V5cztcbiAgICB2YXIgb3BlbktleXMgPSBwcm9wcy5kZWZhdWx0T3BlbktleXM7XG4gICAgaWYgKCdzZWxlY3RlZEtleXMnIGluIHByb3BzKSB7XG4gICAgICBzZWxlY3RlZEtleXMgPSBwcm9wcy5zZWxlY3RlZEtleXMgfHwgW107XG4gICAgfVxuICAgIGlmICgnb3BlbktleXMnIGluIHByb3BzKSB7XG4gICAgICBvcGVuS2V5cyA9IHByb3BzLm9wZW5LZXlzIHx8IFtdO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc2VsZWN0ZWRLZXlzOiBzZWxlY3RlZEtleXMsIG9wZW5LZXlzOiBvcGVuS2V5c1xuICAgIH07XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICBpZiAoJ3NlbGVjdGVkS2V5cycgaW4gbmV4dFByb3BzKSB7XG4gICAgICBwcm9wcy5zZWxlY3RlZEtleXMgPSBuZXh0UHJvcHMuc2VsZWN0ZWRLZXlzO1xuICAgIH1cbiAgICBpZiAoJ29wZW5LZXlzJyBpbiBuZXh0UHJvcHMpIHtcbiAgICAgIHByb3BzLm9wZW5LZXlzID0gbmV4dFByb3BzLm9wZW5LZXlzO1xuICAgIH1cbiAgICB0aGlzLnNldFN0YXRlKHByb3BzKTtcbiAgfSxcblxuICBvbkRlc3Ryb3k6IGZ1bmN0aW9uIG9uRGVzdHJveShrZXkpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHNlbGVjdGVkS2V5cyA9IHN0YXRlLnNlbGVjdGVkS2V5cztcbiAgICB2YXIgb3BlbktleXMgPSBzdGF0ZS5vcGVuS2V5cztcbiAgICB2YXIgaW5kZXggPSBzZWxlY3RlZEtleXMuaW5kZXhPZihrZXkpO1xuICAgIGlmICghKCdzZWxlY3RlZEtleXMnIGluIHByb3BzKSAmJiBpbmRleCAhPT0gLTEpIHtcbiAgICAgIHNlbGVjdGVkS2V5cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICBpbmRleCA9IG9wZW5LZXlzLmluZGV4T2Yoa2V5KTtcbiAgICBpZiAoISgnb3BlbktleXMnIGluIHByb3BzKSAmJiBpbmRleCAhPT0gLTEpIHtcbiAgICAgIG9wZW5LZXlzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9LFxuXG4gIG9uSXRlbUhvdmVyOiBmdW5jdGlvbiBvbkl0ZW1Ib3ZlcihlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBpdGVtID0gZS5pdGVtO1xuXG4gICAgLy8gc3BlY2lhbCBmb3IgdG9wIHN1YiBtZW51XG4gICAgaWYgKHRoaXMucHJvcHMubW9kZSAhPT0gJ2lubGluZScgJiYgIXRoaXMucHJvcHMuY2xvc2VTdWJNZW51T25Nb3VzZUxlYXZlICYmIGl0ZW0uaXNTdWJNZW51KSB7XG4gICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYWN0aXZlS2V5ID0gX3RoaXMuc3RhdGUuYWN0aXZlS2V5O1xuICAgICAgICB2YXIgYWN0aXZlSXRlbSA9IF90aGlzLmdldEZsYXRJbnN0YW5jZUFycmF5KCkuZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgcmV0dXJuIGMgJiYgYy5wcm9wcy5ldmVudEtleSA9PT0gYWN0aXZlS2V5O1xuICAgICAgICB9KVswXTtcbiAgICAgICAgaWYgKGFjdGl2ZUl0ZW0gJiYgYWN0aXZlSXRlbS5wcm9wcy5vcGVuKSB7XG4gICAgICAgICAgX3RoaXMub25PcGVuQ2hhbmdlKHtcbiAgICAgICAgICAgIGtleTogaXRlbS5wcm9wcy5ldmVudEtleSxcbiAgICAgICAgICAgIGl0ZW06IGUuaXRlbSxcbiAgICAgICAgICAgIG9wZW46IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSkoKTtcbiAgICB9XG5cbiAgICB0aGlzLm9uQ29tbW9uSXRlbUhvdmVyKGUpO1xuICB9LFxuXG4gIG9uU2VsZWN0OiBmdW5jdGlvbiBvblNlbGVjdChzZWxlY3RJbmZvKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICBpZiAocHJvcHMuc2VsZWN0YWJsZSkge1xuICAgICAgLy8gcm9vdCBtZW51XG4gICAgICB2YXIgc2VsZWN0ZWRLZXlzID0gdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXM7XG4gICAgICB2YXIgc2VsZWN0ZWRLZXkgPSBzZWxlY3RJbmZvLmtleTtcbiAgICAgIGlmIChwcm9wcy5tdWx0aXBsZSkge1xuICAgICAgICBzZWxlY3RlZEtleXMgPSBzZWxlY3RlZEtleXMuY29uY2F0KFtzZWxlY3RlZEtleV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0ZWRLZXlzID0gW3NlbGVjdGVkS2V5XTtcbiAgICAgIH1cbiAgICAgIGlmICghKCdzZWxlY3RlZEtleXMnIGluIHByb3BzKSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBzZWxlY3RlZEtleXM6IHNlbGVjdGVkS2V5c1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHByb3BzLm9uU2VsZWN0KCgwLCBfb2JqZWN0QXNzaWduMlsnZGVmYXVsdCddKSh7fSwgc2VsZWN0SW5mbywge1xuICAgICAgICBzZWxlY3RlZEtleXM6IHNlbGVjdGVkS2V5c1xuICAgICAgfSkpO1xuICAgIH1cbiAgfSxcblxuICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHByb3BzLm9uQ2xpY2soZSk7XG4gIH0sXG5cbiAgb25PcGVuQ2hhbmdlOiBmdW5jdGlvbiBvbk9wZW5DaGFuZ2UoZSkge1xuICAgIHZhciBvcGVuS2V5cyA9IHRoaXMuc3RhdGUub3BlbktleXM7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgY2hhbmdlZCA9IHRydWU7XG4gICAgaWYgKGUub3Blbikge1xuICAgICAgY2hhbmdlZCA9IG9wZW5LZXlzLmluZGV4T2YoZS5rZXkpID09PSAtMTtcbiAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgIG9wZW5LZXlzID0gb3BlbktleXMuY29uY2F0KGUua2V5KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGluZGV4ID0gb3BlbktleXMuaW5kZXhPZihlLmtleSk7XG4gICAgICBjaGFuZ2VkID0gaW5kZXggIT09IC0xO1xuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgb3BlbktleXMgPSBvcGVuS2V5cy5jb25jYXQoKTtcbiAgICAgICAgb3BlbktleXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIGlmICghKCdvcGVuS2V5cycgaW4gdGhpcy5wcm9wcykpIHtcbiAgICAgICAgLy8gaGFjazogYmF0Y2ggZG9lcyBub3QgdXBkYXRlIHN0YXRlXG4gICAgICAgIHRoaXMuc3RhdGUub3BlbktleXMgPSBvcGVuS2V5cztcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IG9wZW5LZXlzOiBvcGVuS2V5cyB9KTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmZvID0gKDAsIF9vYmplY3RBc3NpZ24yWydkZWZhdWx0J10pKHsgb3BlbktleXM6IG9wZW5LZXlzIH0sIGUpO1xuICAgICAgaWYgKGUub3Blbikge1xuICAgICAgICBwcm9wcy5vbk9wZW4oaW5mbyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wcy5vbkNsb3NlKGluZm8pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBvbkRlc2VsZWN0OiBmdW5jdGlvbiBvbkRlc2VsZWN0KHNlbGVjdEluZm8pIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIGlmIChwcm9wcy5zZWxlY3RhYmxlKSB7XG4gICAgICB2YXIgc2VsZWN0ZWRLZXlzID0gdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXMuY29uY2F0KCk7XG4gICAgICB2YXIgc2VsZWN0ZWRLZXkgPSBzZWxlY3RJbmZvLmtleTtcbiAgICAgIHZhciBpbmRleCA9IHNlbGVjdGVkS2V5cy5pbmRleE9mKHNlbGVjdGVkS2V5KTtcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgc2VsZWN0ZWRLZXlzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgICBpZiAoISgnc2VsZWN0ZWRLZXlzJyBpbiBwcm9wcykpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgc2VsZWN0ZWRLZXlzOiBzZWxlY3RlZEtleXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBwcm9wcy5vbkRlc2VsZWN0KCgwLCBfb2JqZWN0QXNzaWduMlsnZGVmYXVsdCddKSh7fSwgc2VsZWN0SW5mbywge1xuICAgICAgICBzZWxlY3RlZEtleXM6IHNlbGVjdGVkS2V5c1xuICAgICAgfSkpO1xuICAgIH1cbiAgfSxcblxuICBnZXRPcGVuVHJhbnNpdGlvbk5hbWU6IGZ1bmN0aW9uIGdldE9wZW5UcmFuc2l0aW9uTmFtZSgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciB0cmFuc2l0aW9uTmFtZSA9IHByb3BzLm9wZW5UcmFuc2l0aW9uTmFtZTtcbiAgICB2YXIgYW5pbWF0aW9uTmFtZSA9IHByb3BzLm9wZW5BbmltYXRpb247XG4gICAgaWYgKCF0cmFuc2l0aW9uTmFtZSAmJiB0eXBlb2YgYW5pbWF0aW9uTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyYW5zaXRpb25OYW1lID0gcHJvcHMucHJlZml4Q2xzICsgJy1vcGVuLScgKyBhbmltYXRpb25OYW1lO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNpdGlvbk5hbWU7XG4gIH0sXG5cbiAgaXNJbmxpbmVNb2RlOiBmdW5jdGlvbiBpc0lubGluZU1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMubW9kZSA9PT0gJ2lubGluZSc7XG4gIH0sXG5cbiAgbGFzdE9wZW5TdWJNZW51OiBmdW5jdGlvbiBsYXN0T3BlblN1Yk1lbnUoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgbGFzdE9wZW4gPSBbXTtcbiAgICBpZiAodGhpcy5zdGF0ZS5vcGVuS2V5cy5sZW5ndGgpIHtcbiAgICAgIGxhc3RPcGVuID0gdGhpcy5nZXRGbGF0SW5zdGFuY2VBcnJheSgpLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYyAmJiBfdGhpczIuc3RhdGUub3BlbktleXMuaW5kZXhPZihjLnByb3BzLmV2ZW50S2V5KSAhPT0gLTE7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGxhc3RPcGVuWzBdO1xuICB9LFxuXG4gIHJlbmRlck1lbnVJdGVtOiBmdW5jdGlvbiByZW5kZXJNZW51SXRlbShjLCBpLCBzdWJJbmRleCkge1xuICAgIHZhciBrZXkgPSAoMCwgX3V0aWwuZ2V0S2V5RnJvbUNoaWxkcmVuSW5kZXgpKGMsIHRoaXMucHJvcHMuZXZlbnRLZXksIGkpO1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdmFyIGV4dHJhUHJvcHMgPSB7XG4gICAgICBvcGVuS2V5czogc3RhdGUub3BlbktleXMsXG4gICAgICBvcGVuOiBzdGF0ZS5vcGVuS2V5cy5pbmRleE9mKGtleSkgIT09IC0xLFxuICAgICAgc2VsZWN0ZWRLZXlzOiBzdGF0ZS5zZWxlY3RlZEtleXMsXG4gICAgICBzZWxlY3RlZDogc3RhdGUuc2VsZWN0ZWRLZXlzLmluZGV4T2Yoa2V5KSAhPT0gLTEsXG4gICAgICBvcGVuU3ViTWVudU9uTW91c2VFbnRlcjogdGhpcy5wcm9wcy5vcGVuU3ViTWVudU9uTW91c2VFbnRlclxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyQ29tbW9uTWVudUl0ZW0oYywgaSwgc3ViSW5kZXgsIGV4dHJhUHJvcHMpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBwcm9wcyA9ICgwLCBfb2JqZWN0QXNzaWduMlsnZGVmYXVsdCddKSh7fSwgdGhpcy5wcm9wcyk7XG4gICAgcHJvcHMuY2xhc3NOYW1lICs9ICcgJyArIHByb3BzLnByZWZpeENscyArICctcm9vdCc7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyUm9vdChwcm9wcyk7XG4gIH1cbn0pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBNZW51O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1zZWxlY3QyL34vcmMtc2VsZWN0L34vcmMtbWVudS9saWIvTWVudS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JlYWN0RG9tID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBfcmVhY3REb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3REb20pO1xuXG52YXIgX3JjVXRpbCA9IHJlcXVpcmUoJ3JjLXV0aWwnKTtcblxudmFyIF9jbGFzc25hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xuXG52YXIgX2NsYXNzbmFtZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NuYW1lcyk7XG5cbnZhciBfZG9tU2Nyb2xsSW50b1ZpZXcgPSByZXF1aXJlKCdkb20tc2Nyb2xsLWludG8tdmlldycpO1xuXG52YXIgX2RvbVNjcm9sbEludG9WaWV3MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RvbVNjcm9sbEludG9WaWV3KTtcblxudmFyIF9vYmplY3RBc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBfb2JqZWN0QXNzaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29iamVjdEFzc2lnbik7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgX0RPTVdyYXAgPSByZXF1aXJlKCcuL0RPTVdyYXAnKTtcblxudmFyIF9ET01XcmFwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RPTVdyYXApO1xuXG5mdW5jdGlvbiBhbGxEaXNhYmxlZChhcnIpIHtcbiAgaWYgKCFhcnIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGFyci5ldmVyeShmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAhIWMucHJvcHMuZGlzYWJsZWQ7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRBY3RpdmVLZXkocHJvcHMsIG9yaWdpbmFsQWN0aXZlS2V5KSB7XG4gIHZhciBhY3RpdmVLZXkgPSBvcmlnaW5hbEFjdGl2ZUtleTtcbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gIHZhciBldmVudEtleSA9IHByb3BzLmV2ZW50S2V5O1xuICBpZiAoYWN0aXZlS2V5KSB7XG4gICAgdmFyIGZvdW5kID0gdW5kZWZpbmVkO1xuICAgICgwLCBfdXRpbC5sb29wTWVudUl0ZW0pKGNoaWxkcmVuLCBmdW5jdGlvbiAoYywgaSkge1xuICAgICAgaWYgKCFjLnByb3BzLmRpc2FibGVkICYmIGFjdGl2ZUtleSA9PT0gKDAsIF91dGlsLmdldEtleUZyb21DaGlsZHJlbkluZGV4KShjLCBldmVudEtleSwgaSkpIHtcbiAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChmb3VuZCkge1xuICAgICAgcmV0dXJuIGFjdGl2ZUtleTtcbiAgICB9XG4gIH1cbiAgYWN0aXZlS2V5ID0gbnVsbDtcbiAgaWYgKHByb3BzLmRlZmF1bHRBY3RpdmVGaXJzdCkge1xuICAgICgwLCBfdXRpbC5sb29wTWVudUl0ZW0pKGNoaWxkcmVuLCBmdW5jdGlvbiAoYywgaSkge1xuICAgICAgaWYgKCFhY3RpdmVLZXkgJiYgIWMucHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgYWN0aXZlS2V5ID0gKDAsIF91dGlsLmdldEtleUZyb21DaGlsZHJlbkluZGV4KShjLCBldmVudEtleSwgaSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjdGl2ZUtleTtcbiAgfVxuICByZXR1cm4gYWN0aXZlS2V5O1xufVxuXG5mdW5jdGlvbiBzYXZlUmVmKGluZGV4LCBzdWJJbmRleCwgYykge1xuICBpZiAoYykge1xuICAgIGlmIChzdWJJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmluc3RhbmNlQXJyYXlbaW5kZXhdID0gdGhpcy5pbnN0YW5jZUFycmF5W2luZGV4XSB8fCBbXTtcbiAgICAgIHRoaXMuaW5zdGFuY2VBcnJheVtpbmRleF1bc3ViSW5kZXhdID0gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbnN0YW5jZUFycmF5W2luZGV4XSA9IGM7XG4gICAgfVxuICB9XG59XG5cbnZhciBNZW51TWl4aW4gPSB7XG4gIHByb3BUeXBlczoge1xuICAgIGZvY3VzYWJsZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLFxuICAgIG11bHRpcGxlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmJvb2wsXG4gICAgc3R5bGU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIGRlZmF1bHRBY3RpdmVGaXJzdDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLFxuICAgIHZpc2libGU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCxcbiAgICBhY3RpdmVLZXk6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHNlbGVjdGVkS2V5czogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5hcnJheU9mKF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nKSxcbiAgICBkZWZhdWx0U2VsZWN0ZWRLZXlzOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmFycmF5T2YoX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmcpLFxuICAgIGRlZmF1bHRPcGVuS2V5czogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5hcnJheU9mKF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nKSxcbiAgICBvcGVuS2V5czogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5hcnJheU9mKF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nKSxcbiAgICBjaGlsZHJlbjogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5hbnlcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHJlZml4Q2xzOiAncmMtbWVudScsXG4gICAgICBjbGFzc05hbWU6ICcnLFxuICAgICAgbW9kZTogJ3ZlcnRpY2FsJyxcbiAgICAgIGxldmVsOiAxLFxuICAgICAgaW5saW5lSW5kZW50OiAyNCxcbiAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICBmb2N1c2FibGU6IHRydWUsXG4gICAgICBzdHlsZToge31cbiAgICB9O1xuICB9LFxuXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjdGl2ZUtleTogZ2V0QWN0aXZlS2V5KHByb3BzLCBwcm9wcy5hY3RpdmVLZXkpXG4gICAgfTtcbiAgfSxcblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIHZhciBwcm9wcyA9IHVuZGVmaW5lZDtcbiAgICBpZiAoJ2FjdGl2ZUtleScgaW4gbmV4dFByb3BzKSB7XG4gICAgICBwcm9wcyA9IHtcbiAgICAgICAgYWN0aXZlS2V5OiBnZXRBY3RpdmVLZXkobmV4dFByb3BzLCBuZXh0UHJvcHMuYWN0aXZlS2V5KVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9yaWdpbmFsQWN0aXZlS2V5ID0gdGhpcy5zdGF0ZS5hY3RpdmVLZXk7XG4gICAgICB2YXIgYWN0aXZlS2V5ID0gZ2V0QWN0aXZlS2V5KG5leHRQcm9wcywgb3JpZ2luYWxBY3RpdmVLZXkpO1xuICAgICAgLy8gZml4OiB0aGlzLnNldFN0YXRlKCksIHBhcmVudC5yZW5kZXIoKSxcbiAgICAgIGlmIChhY3RpdmVLZXkgIT09IG9yaWdpbmFsQWN0aXZlS2V5KSB7XG4gICAgICAgIHByb3BzID0ge1xuICAgICAgICAgIGFjdGl2ZUtleTogYWN0aXZlS2V5XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wcykge1xuICAgICAgdGhpcy5zZXRTdGF0ZShwcm9wcyk7XG4gICAgfVxuICB9LFxuXG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24gc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcykge1xuICAgIHJldHVybiB0aGlzLnByb3BzLnZpc2libGUgfHwgbmV4dFByb3BzLnZpc2libGU7XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgdGhpcy5pbnN0YW5jZUFycmF5ID0gW107XG4gIH0sXG5cbiAgLy8gYWxsIGtleWJvYXJkIGV2ZW50cyBjYWxsYmFja3MgcnVuIGZyb20gaGVyZSBhdCBmaXJzdFxuICBvbktleURvd246IGZ1bmN0aW9uIG9uS2V5RG93bihlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBrZXlDb2RlID0gZS5rZXlDb2RlO1xuICAgIHZhciBoYW5kbGVkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZ2V0RmxhdEluc3RhbmNlQXJyYXkoKS5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIGlmIChvYmogJiYgb2JqLnByb3BzLmFjdGl2ZSkge1xuICAgICAgICBoYW5kbGVkID0gb2JqLm9uS2V5RG93bihlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoaGFuZGxlZCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHZhciBhY3RpdmVJdGVtID0gbnVsbDtcbiAgICBpZiAoa2V5Q29kZSA9PT0gX3JjVXRpbC5LZXlDb2RlLlVQIHx8IGtleUNvZGUgPT09IF9yY1V0aWwuS2V5Q29kZS5ET1dOKSB7XG4gICAgICBhY3RpdmVJdGVtID0gdGhpcy5zdGVwKGtleUNvZGUgPT09IF9yY1V0aWwuS2V5Q29kZS5VUCA/IC0xIDogMSk7XG4gICAgfVxuICAgIGlmIChhY3RpdmVJdGVtKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgYWN0aXZlS2V5OiBhY3RpdmVJdGVtLnByb3BzLmV2ZW50S2V5XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICgwLCBfZG9tU2Nyb2xsSW50b1ZpZXcyWydkZWZhdWx0J10pKF9yZWFjdERvbTJbJ2RlZmF1bHQnXS5maW5kRE9NTm9kZShhY3RpdmVJdGVtKSwgX3JlYWN0RG9tMlsnZGVmYXVsdCddLmZpbmRET01Ob2RlKF90aGlzKSwge1xuICAgICAgICAgIG9ubHlTY3JvbGxJZk5lZWRlZDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChhY3RpdmVJdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBhY3RpdmVLZXk6IG51bGxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9LFxuXG4gIG9uQ29tbW9uSXRlbUhvdmVyOiBmdW5jdGlvbiBvbkNvbW1vbkl0ZW1Ib3ZlcihlKSB7XG4gICAgdmFyIG1vZGUgPSB0aGlzLnByb3BzLm1vZGU7XG4gICAgdmFyIGtleSA9IGUua2V5O1xuICAgIHZhciBob3ZlciA9IGUuaG92ZXI7XG4gICAgdmFyIHRyaWdnZXIgPSBlLnRyaWdnZXI7XG5cbiAgICB2YXIgYWN0aXZlS2V5ID0gdGhpcy5zdGF0ZS5hY3RpdmVLZXk7XG4gICAgaWYgKCF0cmlnZ2VyIHx8IGhvdmVyIHx8IHRoaXMucHJvcHMuY2xvc2VTdWJNZW51T25Nb3VzZUxlYXZlIHx8ICFlLml0ZW0uaXNTdWJNZW51IHx8IG1vZGUgPT09ICdpbmxpbmUnKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgYWN0aXZlS2V5OiBob3ZlciA/IGtleSA6IG51bGxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7fVxuICAgIC8vIGtlZXAgYWN0aXZlIGZvciBzdWIgbWVudSBmb3IgY2xpY2sgYWN0aXZlXG4gICAgLy8gZW1wdHlcblxuICAgIC8vIGNsZWFyIGxhc3Qgb3BlbiBzdGF0dXNcbiAgICBpZiAoaG92ZXIgJiYgbW9kZSAhPT0gJ2lubGluZScpIHtcbiAgICAgIHZhciBhY3RpdmVJdGVtID0gdGhpcy5nZXRGbGF0SW5zdGFuY2VBcnJheSgpLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYyAmJiBjLnByb3BzLmV2ZW50S2V5ID09PSBhY3RpdmVLZXk7XG4gICAgICB9KVswXTtcbiAgICAgIGlmIChhY3RpdmVJdGVtICYmIGFjdGl2ZUl0ZW0uaXNTdWJNZW51ICYmIGFjdGl2ZUl0ZW0ucHJvcHMuZXZlbnRLZXkgIT09IGtleSkge1xuICAgICAgICB0aGlzLm9uT3BlbkNoYW5nZSh7XG4gICAgICAgICAgaXRlbTogYWN0aXZlSXRlbSxcbiAgICAgICAgICBrZXk6IGFjdGl2ZUl0ZW0ucHJvcHMuZXZlbnRLZXksXG4gICAgICAgICAgb3BlbjogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGdldEZsYXRJbnN0YW5jZUFycmF5OiBmdW5jdGlvbiBnZXRGbGF0SW5zdGFuY2VBcnJheSgpIHtcbiAgICB2YXIgaW5zdGFuY2VBcnJheSA9IHRoaXMuaW5zdGFuY2VBcnJheTtcbiAgICB2YXIgaGFzSW5uZXJBcnJheSA9IGluc3RhbmNlQXJyYXkuc29tZShmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYSk7XG4gICAgfSk7XG4gICAgaWYgKGhhc0lubmVyQXJyYXkpIHtcbiAgICAgIGluc3RhbmNlQXJyYXkgPSBbXTtcbiAgICAgIHRoaXMuaW5zdGFuY2VBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgICAgaW5zdGFuY2VBcnJheS5wdXNoLmFwcGx5KGluc3RhbmNlQXJyYXksIGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluc3RhbmNlQXJyYXkucHVzaChhKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmluc3RhbmNlQXJyYXkgPSBpbnN0YW5jZUFycmF5O1xuICAgIH1cbiAgICByZXR1cm4gaW5zdGFuY2VBcnJheTtcbiAgfSxcblxuICByZW5kZXJDb21tb25NZW51SXRlbTogZnVuY3Rpb24gcmVuZGVyQ29tbW9uTWVudUl0ZW0oY2hpbGQsIGksIHN1YkluZGV4LCBleHRyYVByb3BzKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBrZXkgPSAoMCwgX3V0aWwuZ2V0S2V5RnJvbUNoaWxkcmVuSW5kZXgpKGNoaWxkLCBwcm9wcy5ldmVudEtleSwgaSk7XG4gICAgdmFyIGNoaWxkUHJvcHMgPSBjaGlsZC5wcm9wcztcbiAgICB2YXIgbmV3Q2hpbGRQcm9wcyA9ICgwLCBfb2JqZWN0QXNzaWduMlsnZGVmYXVsdCddKSh7XG4gICAgICBtb2RlOiBwcm9wcy5tb2RlLFxuICAgICAgbGV2ZWw6IHByb3BzLmxldmVsLFxuICAgICAgaW5saW5lSW5kZW50OiBwcm9wcy5pbmxpbmVJbmRlbnQsXG4gICAgICByZW5kZXJNZW51SXRlbTogdGhpcy5yZW5kZXJNZW51SXRlbSxcbiAgICAgIHJvb3RQcmVmaXhDbHM6IHByb3BzLnByZWZpeENscyxcbiAgICAgIGluZGV4OiBpLFxuICAgICAgcGFyZW50TWVudTogdGhpcyxcbiAgICAgIHJlZjogY2hpbGRQcm9wcy5kaXNhYmxlZCA/IHVuZGVmaW5lZCA6ICgwLCBfcmNVdGlsLmNyZWF0ZUNoYWluZWRGdW5jdGlvbikoY2hpbGQucmVmLCBzYXZlUmVmLmJpbmQodGhpcywgaSwgc3ViSW5kZXgpKSxcbiAgICAgIGV2ZW50S2V5OiBrZXksXG4gICAgICBjbG9zZVN1Yk1lbnVPbk1vdXNlTGVhdmU6IHByb3BzLmNsb3NlU3ViTWVudU9uTW91c2VMZWF2ZSxcbiAgICAgIG9uSXRlbUhvdmVyOiB0aGlzLm9uSXRlbUhvdmVyLFxuICAgICAgYWN0aXZlOiAhY2hpbGRQcm9wcy5kaXNhYmxlZCAmJiBrZXkgPT09IHN0YXRlLmFjdGl2ZUtleSxcbiAgICAgIG11bHRpcGxlOiBwcm9wcy5tdWx0aXBsZSxcbiAgICAgIG9uQ2xpY2s6IHRoaXMub25DbGljayxcbiAgICAgIG9wZW5UcmFuc2l0aW9uTmFtZTogdGhpcy5nZXRPcGVuVHJhbnNpdGlvbk5hbWUoKSxcbiAgICAgIG9wZW5BbmltYXRpb246IHByb3BzLm9wZW5BbmltYXRpb24sXG4gICAgICBvbk9wZW5DaGFuZ2U6IHRoaXMub25PcGVuQ2hhbmdlLFxuICAgICAgb25EZXNlbGVjdDogdGhpcy5vbkRlc2VsZWN0LFxuICAgICAgb25EZXN0cm95OiB0aGlzLm9uRGVzdHJveSxcbiAgICAgIG9uU2VsZWN0OiB0aGlzLm9uU2VsZWN0XG4gICAgfSwgZXh0cmFQcm9wcyk7XG4gICAgaWYgKHByb3BzLm1vZGUgPT09ICdpbmxpbmUnKSB7XG4gICAgICBuZXdDaGlsZFByb3BzLmNsb3NlU3ViTWVudU9uTW91c2VMZWF2ZSA9IG5ld0NoaWxkUHJvcHMub3BlblN1Yk1lbnVPbk1vdXNlRW50ZXIgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jbG9uZUVsZW1lbnQoY2hpbGQsIG5ld0NoaWxkUHJvcHMpO1xuICB9LFxuXG4gIHJlbmRlclJvb3Q6IGZ1bmN0aW9uIHJlbmRlclJvb3QocHJvcHMpIHtcbiAgICB2YXIgX2NsYXNzZXM7XG5cbiAgICB0aGlzLmluc3RhbmNlQXJyYXkgPSBbXTtcbiAgICB2YXIgY2xhc3NlcyA9IChfY2xhc3NlcyA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzZXMsIHByb3BzLnByZWZpeENscywgMSksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NlcywgcHJvcHMucHJlZml4Q2xzICsgJy0nICsgcHJvcHMubW9kZSwgMSksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NlcywgcHJvcHMuY2xhc3NOYW1lLCAhIXByb3BzLmNsYXNzTmFtZSksIF9jbGFzc2VzKTtcbiAgICB2YXIgZG9tUHJvcHMgPSB7XG4gICAgICBjbGFzc05hbWU6ICgwLCBfY2xhc3NuYW1lczJbJ2RlZmF1bHQnXSkoY2xhc3NlcyksXG4gICAgICByb2xlOiAnbWVudScsXG4gICAgICAnYXJpYS1hY3RpdmVkZXNjZW5kYW50JzogJydcbiAgICB9O1xuICAgIGlmIChwcm9wcy5pZCkge1xuICAgICAgZG9tUHJvcHMuaWQgPSBwcm9wcy5pZDtcbiAgICB9XG4gICAgaWYgKHByb3BzLmZvY3VzYWJsZSkge1xuICAgICAgZG9tUHJvcHMudGFiSW5kZXggPSAnMCc7XG4gICAgICBkb21Qcm9wcy5vbktleURvd24gPSB0aGlzLm9uS2V5RG93bjtcbiAgICB9XG4gICAgcmV0dXJuKFxuICAgICAgLy8gRVNMaW50IGlzIG5vdCBzbWFydCBlbm91Z2ggdG8ga25vdyB0aGF0IHRoZSB0eXBlIG9mIGBjaGlsZHJlbmAgd2FzIGNoZWNrZWQuXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIF9ET01XcmFwMlsnZGVmYXVsdCddLFxuICAgICAgICBfZXh0ZW5kcyh7IHN0eWxlOiBwcm9wcy5zdHlsZSxcbiAgICAgICAgICB0YWc6ICd1bCcsXG4gICAgICAgICAgaGlkZGVuQ2xhc3NOYW1lOiBwcm9wcy5wcmVmaXhDbHMgKyAnLWhpZGRlbicsXG4gICAgICAgICAgdmlzaWJsZTogcHJvcHMudmlzaWJsZVxuICAgICAgICB9LCBkb21Qcm9wcyksXG4gICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5DaGlsZHJlbi5tYXAocHJvcHMuY2hpbGRyZW4sIHRoaXMucmVuZGVyTWVudUl0ZW0pXG4gICAgICApXG4gICAgICAvKmVzbGludC1lbmFibGUgKi9cblxuICAgICk7XG4gIH0sXG5cbiAgc3RlcDogZnVuY3Rpb24gc3RlcChkaXJlY3Rpb24pIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmdldEZsYXRJbnN0YW5jZUFycmF5KCk7XG4gICAgdmFyIGFjdGl2ZUtleSA9IHRoaXMuc3RhdGUuYWN0aXZlS2V5O1xuICAgIHZhciBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgaWYgKGRpcmVjdGlvbiA8IDApIHtcbiAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uY29uY2F0KCkucmV2ZXJzZSgpO1xuICAgIH1cbiAgICAvLyBmaW5kIGN1cnJlbnQgYWN0aXZlSW5kZXhcbiAgICB2YXIgYWN0aXZlSW5kZXggPSAtMTtcbiAgICBjaGlsZHJlbi5ldmVyeShmdW5jdGlvbiAoYywgY2kpIHtcbiAgICAgIGlmIChjICYmIGMucHJvcHMuZXZlbnRLZXkgPT09IGFjdGl2ZUtleSkge1xuICAgICAgICBhY3RpdmVJbmRleCA9IGNpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICBpZiAoIXRoaXMucHJvcHMuZGVmYXVsdEFjdGl2ZUZpcnN0ICYmIGFjdGl2ZUluZGV4ICE9PSAtMSkge1xuICAgICAgaWYgKGFsbERpc2FibGVkKGNoaWxkcmVuLnNsaWNlKGFjdGl2ZUluZGV4LCBsZW4gLSAxKSkpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHN0YXJ0ID0gKGFjdGl2ZUluZGV4ICsgMSkgJSBsZW47XG4gICAgdmFyIGkgPSBzdGFydDtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmICghY2hpbGQgfHwgY2hpbGQucHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgaSA9IChpICsgMSArIGxlbikgJSBsZW47XG4gICAgICAgIC8vIGNvbXBsZXRlIGEgbG9vcFxuICAgICAgICBpZiAoaSA9PT0gc3RhcnQpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gTWVudU1peGluO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1zZWxlY3QyL34vcmMtc2VsZWN0L34vcmMtbWVudS9saWIvTWVudU1peGluLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZG9tLXNjcm9sbC1pbnRvLXZpZXcnKTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLXNlbGVjdDIvfi9yYy1zZWxlY3Qvfi9kb20tc2Nyb2xsLWludG8tdmlldy9saWIvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmZ1bmN0aW9uIHNjcm9sbEludG9WaWV3KGVsZW0sIGNvbnRhaW5lciwgY29uZmlnKSB7XG4gIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgLy8gZG9jdW1lbnQg5b2S5LiA5YyW5YiwIHdpbmRvd1xuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSA5KSB7XG4gICAgY29udGFpbmVyID0gdXRpbC5nZXRXaW5kb3coY29udGFpbmVyKTtcbiAgfVxuXG4gIHZhciBhbGxvd0hvcml6b250YWxTY3JvbGwgPSBjb25maWcuYWxsb3dIb3Jpem9udGFsU2Nyb2xsO1xuICB2YXIgb25seVNjcm9sbElmTmVlZGVkID0gY29uZmlnLm9ubHlTY3JvbGxJZk5lZWRlZDtcbiAgdmFyIGFsaWduV2l0aFRvcCA9IGNvbmZpZy5hbGlnbldpdGhUb3A7XG4gIHZhciBhbGlnbldpdGhMZWZ0ID0gY29uZmlnLmFsaWduV2l0aExlZnQ7XG4gIHZhciBvZmZzZXRUb3AgPSBjb25maWcub2Zmc2V0VG9wIHx8IDA7XG4gIHZhciBvZmZzZXRMZWZ0ID0gY29uZmlnLm9mZnNldExlZnQgfHwgMDtcbiAgdmFyIG9mZnNldEJvdHRvbSA9IGNvbmZpZy5vZmZzZXRCb3R0b20gfHwgMDtcbiAgdmFyIG9mZnNldFJpZ2h0ID0gY29uZmlnLm9mZnNldFJpZ2h0IHx8IDA7XG5cbiAgYWxsb3dIb3Jpem9udGFsU2Nyb2xsID0gYWxsb3dIb3Jpem9udGFsU2Nyb2xsID09PSB1bmRlZmluZWQgPyB0cnVlIDogYWxsb3dIb3Jpem9udGFsU2Nyb2xsO1xuXG4gIHZhciBpc1dpbiA9IHV0aWwuaXNXaW5kb3coY29udGFpbmVyKTtcbiAgdmFyIGVsZW1PZmZzZXQgPSB1dGlsLm9mZnNldChlbGVtKTtcbiAgdmFyIGVoID0gdXRpbC5vdXRlckhlaWdodChlbGVtKTtcbiAgdmFyIGV3ID0gdXRpbC5vdXRlcldpZHRoKGVsZW0pO1xuICB2YXIgY29udGFpbmVyT2Zmc2V0ID0gdW5kZWZpbmVkO1xuICB2YXIgY2ggPSB1bmRlZmluZWQ7XG4gIHZhciBjdyA9IHVuZGVmaW5lZDtcbiAgdmFyIGNvbnRhaW5lclNjcm9sbCA9IHVuZGVmaW5lZDtcbiAgdmFyIGRpZmZUb3AgPSB1bmRlZmluZWQ7XG4gIHZhciBkaWZmQm90dG9tID0gdW5kZWZpbmVkO1xuICB2YXIgd2luID0gdW5kZWZpbmVkO1xuICB2YXIgd2luU2Nyb2xsID0gdW5kZWZpbmVkO1xuICB2YXIgd3cgPSB1bmRlZmluZWQ7XG4gIHZhciB3aCA9IHVuZGVmaW5lZDtcblxuICBpZiAoaXNXaW4pIHtcbiAgICB3aW4gPSBjb250YWluZXI7XG4gICAgd2ggPSB1dGlsLmhlaWdodCh3aW4pO1xuICAgIHd3ID0gdXRpbC53aWR0aCh3aW4pO1xuICAgIHdpblNjcm9sbCA9IHtcbiAgICAgIGxlZnQ6IHV0aWwuc2Nyb2xsTGVmdCh3aW4pLFxuICAgICAgdG9wOiB1dGlsLnNjcm9sbFRvcCh3aW4pXG4gICAgfTtcbiAgICAvLyBlbGVtIOebuOWvuSBjb250YWluZXIg5Y+v6KeG6KeG56qX55qE6Led56a7XG4gICAgZGlmZlRvcCA9IHtcbiAgICAgIGxlZnQ6IGVsZW1PZmZzZXQubGVmdCAtIHdpblNjcm9sbC5sZWZ0IC0gb2Zmc2V0TGVmdCxcbiAgICAgIHRvcDogZWxlbU9mZnNldC50b3AgLSB3aW5TY3JvbGwudG9wIC0gb2Zmc2V0VG9wXG4gICAgfTtcbiAgICBkaWZmQm90dG9tID0ge1xuICAgICAgbGVmdDogZWxlbU9mZnNldC5sZWZ0ICsgZXcgLSAod2luU2Nyb2xsLmxlZnQgKyB3dykgKyBvZmZzZXRSaWdodCxcbiAgICAgIHRvcDogZWxlbU9mZnNldC50b3AgKyBlaCAtICh3aW5TY3JvbGwudG9wICsgd2gpICsgb2Zmc2V0Qm90dG9tXG4gICAgfTtcbiAgICBjb250YWluZXJTY3JvbGwgPSB3aW5TY3JvbGw7XG4gIH0gZWxzZSB7XG4gICAgY29udGFpbmVyT2Zmc2V0ID0gdXRpbC5vZmZzZXQoY29udGFpbmVyKTtcbiAgICBjaCA9IGNvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG4gICAgY3cgPSBjb250YWluZXIuY2xpZW50V2lkdGg7XG4gICAgY29udGFpbmVyU2Nyb2xsID0ge1xuICAgICAgbGVmdDogY29udGFpbmVyLnNjcm9sbExlZnQsXG4gICAgICB0b3A6IGNvbnRhaW5lci5zY3JvbGxUb3BcbiAgICB9O1xuICAgIC8vIGVsZW0g55u45a+5IGNvbnRhaW5lciDlj6/op4bop4bnqpfnmoTot53nprtcbiAgICAvLyDms6jmhI/ovrnmoYYsIG9mZnNldCDmmK/ovrnmoYbliLDmoLnoioLngrlcbiAgICBkaWZmVG9wID0ge1xuICAgICAgbGVmdDogZWxlbU9mZnNldC5sZWZ0IC0gKGNvbnRhaW5lck9mZnNldC5sZWZ0ICsgKHBhcnNlRmxvYXQodXRpbC5jc3MoY29udGFpbmVyLCAnYm9yZGVyTGVmdFdpZHRoJykpIHx8IDApKSAtIG9mZnNldExlZnQsXG4gICAgICB0b3A6IGVsZW1PZmZzZXQudG9wIC0gKGNvbnRhaW5lck9mZnNldC50b3AgKyAocGFyc2VGbG9hdCh1dGlsLmNzcyhjb250YWluZXIsICdib3JkZXJUb3BXaWR0aCcpKSB8fCAwKSkgLSBvZmZzZXRUb3BcbiAgICB9O1xuICAgIGRpZmZCb3R0b20gPSB7XG4gICAgICBsZWZ0OiBlbGVtT2Zmc2V0LmxlZnQgKyBldyAtIChjb250YWluZXJPZmZzZXQubGVmdCArIGN3ICsgKHBhcnNlRmxvYXQodXRpbC5jc3MoY29udGFpbmVyLCAnYm9yZGVyUmlnaHRXaWR0aCcpKSB8fCAwKSkgKyBvZmZzZXRSaWdodCxcbiAgICAgIHRvcDogZWxlbU9mZnNldC50b3AgKyBlaCAtIChjb250YWluZXJPZmZzZXQudG9wICsgY2ggKyAocGFyc2VGbG9hdCh1dGlsLmNzcyhjb250YWluZXIsICdib3JkZXJCb3R0b21XaWR0aCcpKSB8fCAwKSkgKyBvZmZzZXRCb3R0b21cbiAgICB9O1xuICB9XG5cbiAgaWYgKGRpZmZUb3AudG9wIDwgMCB8fCBkaWZmQm90dG9tLnRvcCA+IDApIHtcbiAgICAvLyDlvLrliLblkJHkuIpcbiAgICBpZiAoYWxpZ25XaXRoVG9wID09PSB0cnVlKSB7XG4gICAgICB1dGlsLnNjcm9sbFRvcChjb250YWluZXIsIGNvbnRhaW5lclNjcm9sbC50b3AgKyBkaWZmVG9wLnRvcCk7XG4gICAgfSBlbHNlIGlmIChhbGlnbldpdGhUb3AgPT09IGZhbHNlKSB7XG4gICAgICB1dGlsLnNjcm9sbFRvcChjb250YWluZXIsIGNvbnRhaW5lclNjcm9sbC50b3AgKyBkaWZmQm90dG9tLnRvcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIOiHquWKqOiwg+aVtFxuICAgICAgaWYgKGRpZmZUb3AudG9wIDwgMCkge1xuICAgICAgICB1dGlsLnNjcm9sbFRvcChjb250YWluZXIsIGNvbnRhaW5lclNjcm9sbC50b3AgKyBkaWZmVG9wLnRvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1dGlsLnNjcm9sbFRvcChjb250YWluZXIsIGNvbnRhaW5lclNjcm9sbC50b3AgKyBkaWZmQm90dG9tLnRvcCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICghb25seVNjcm9sbElmTmVlZGVkKSB7XG4gICAgICBhbGlnbldpdGhUb3AgPSBhbGlnbldpdGhUb3AgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAhIWFsaWduV2l0aFRvcDtcbiAgICAgIGlmIChhbGlnbldpdGhUb3ApIHtcbiAgICAgICAgdXRpbC5zY3JvbGxUb3AoY29udGFpbmVyLCBjb250YWluZXJTY3JvbGwudG9wICsgZGlmZlRvcC50b3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXRpbC5zY3JvbGxUb3AoY29udGFpbmVyLCBjb250YWluZXJTY3JvbGwudG9wICsgZGlmZkJvdHRvbS50b3ApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChhbGxvd0hvcml6b250YWxTY3JvbGwpIHtcbiAgICBpZiAoZGlmZlRvcC5sZWZ0IDwgMCB8fCBkaWZmQm90dG9tLmxlZnQgPiAwKSB7XG4gICAgICAvLyDlvLrliLblkJHkuIpcbiAgICAgIGlmIChhbGlnbldpdGhMZWZ0ID09PSB0cnVlKSB7XG4gICAgICAgIHV0aWwuc2Nyb2xsTGVmdChjb250YWluZXIsIGNvbnRhaW5lclNjcm9sbC5sZWZ0ICsgZGlmZlRvcC5sZWZ0KTtcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ25XaXRoTGVmdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdXRpbC5zY3JvbGxMZWZ0KGNvbnRhaW5lciwgY29udGFpbmVyU2Nyb2xsLmxlZnQgKyBkaWZmQm90dG9tLmxlZnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8g6Ieq5Yqo6LCD5pW0XG4gICAgICAgIGlmIChkaWZmVG9wLmxlZnQgPCAwKSB7XG4gICAgICAgICAgdXRpbC5zY3JvbGxMZWZ0KGNvbnRhaW5lciwgY29udGFpbmVyU2Nyb2xsLmxlZnQgKyBkaWZmVG9wLmxlZnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHV0aWwuc2Nyb2xsTGVmdChjb250YWluZXIsIGNvbnRhaW5lclNjcm9sbC5sZWZ0ICsgZGlmZkJvdHRvbS5sZWZ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIW9ubHlTY3JvbGxJZk5lZWRlZCkge1xuICAgICAgICBhbGlnbldpdGhMZWZ0ID0gYWxpZ25XaXRoTGVmdCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICEhYWxpZ25XaXRoTGVmdDtcbiAgICAgICAgaWYgKGFsaWduV2l0aExlZnQpIHtcbiAgICAgICAgICB1dGlsLnNjcm9sbExlZnQoY29udGFpbmVyLCBjb250YWluZXJTY3JvbGwubGVmdCArIGRpZmZUb3AubGVmdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXRpbC5zY3JvbGxMZWZ0KGNvbnRhaW5lciwgY29udGFpbmVyU2Nyb2xsLmxlZnQgKyBkaWZmQm90dG9tLmxlZnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2Nyb2xsSW50b1ZpZXc7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1zZWxlY3QyL34vcmMtc2VsZWN0L34vZG9tLXNjcm9sbC1pbnRvLXZpZXcvbGliL2RvbS1zY3JvbGwtaW50by12aWV3LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfb2JqZWN0QXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgX29iamVjdEFzc2lnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vYmplY3RBc3NpZ24pO1xuXG52YXIgRE9NV3JhcCA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnRE9NV3JhcCcsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgdGFnOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLnN0cmluZ1xuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0YWc6ICdkaXYnXG4gICAgfTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgcHJvcHMgPSAoMCwgX29iamVjdEFzc2lnbjJbJ2RlZmF1bHQnXSkoe30sIHRoaXMucHJvcHMpO1xuICAgIGlmICghcHJvcHMudmlzaWJsZSkge1xuICAgICAgcHJvcHMuY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lIHx8ICcnO1xuICAgICAgcHJvcHMuY2xhc3NOYW1lICs9ICcgJyArIHByb3BzLmhpZGRlbkNsYXNzTmFtZTtcbiAgICB9XG4gICAgdmFyIFRhZyA9IHByb3BzLnRhZztcbiAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoVGFnLCBwcm9wcyk7XG4gIH1cbn0pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBET01XcmFwO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1zZWxlY3QyL34vcmMtc2VsZWN0L34vcmMtbWVudS9saWIvRE9NV3JhcC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIF9TdWJQb3B1cE1lbnUgPSByZXF1aXJlKCcuL1N1YlBvcHVwTWVudScpO1xuXG52YXIgX1N1YlBvcHVwTWVudTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TdWJQb3B1cE1lbnUpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcmNVdGlsID0gcmVxdWlyZSgncmMtdXRpbCcpO1xuXG52YXIgX2NsYXNzbmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG5cbnZhciBfY2xhc3NuYW1lczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc25hbWVzKTtcblxudmFyIF9vYmplY3RBc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBfb2JqZWN0QXNzaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29iamVjdEFzc2lnbik7XG5cbnZhciBTdWJNZW51ID0gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdTdWJNZW51JyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBwYXJlbnRNZW51OiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm9iamVjdCxcbiAgICB0aXRsZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ub2RlLFxuICAgIG9uQ2xpY2s6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbk9wZW5DaGFuZ2U6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYyxcbiAgICByb290UHJlZml4Q2xzOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLnN0cmluZyxcbiAgICBldmVudEtleTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmcsXG4gICAgbXVsdGlwbGU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCxcbiAgICBhY3RpdmU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCxcbiAgICBvcGVuOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmJvb2wsXG4gICAgb25TZWxlY3Q6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYyxcbiAgICBjbG9zZVN1Yk1lbnVPbk1vdXNlTGVhdmU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCxcbiAgICBvcGVuU3ViTWVudU9uTW91c2VFbnRlcjogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLFxuICAgIG9uRGVzZWxlY3Q6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkRlc3Ryb3k6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkl0ZW1Ib3ZlcjogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jXG4gIH0sXG5cbiAgbWl4aW5zOiBbcmVxdWlyZSgnLi9TdWJNZW51U3RhdGVNaXhpbicpXSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb25Nb3VzZUVudGVyOiBmdW5jdGlvbiBvbk1vdXNlRW50ZXIoKSB7fSxcbiAgICAgIHRpdGxlOiAnJ1xuICAgIH07XG4gIH0sXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgdGhpcy5pc1N1Yk1lbnUgPSAxO1xuICAgIHJldHVybiB7XG4gICAgICBkZWZhdWx0QWN0aXZlRmlyc3Q6IGZhbHNlXG4gICAgfTtcbiAgfSxcblxuICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICBpZiAocHJvcHMub25EZXN0cm95KSB7XG4gICAgICBwcm9wcy5vbkRlc3Ryb3kocHJvcHMuZXZlbnRLZXkpO1xuICAgIH1cbiAgfSxcblxuICBvbkRlc3Ryb3k6IGZ1bmN0aW9uIG9uRGVzdHJveShrZXkpIHtcbiAgICB0aGlzLnByb3BzLm9uRGVzdHJveShrZXkpO1xuICB9LFxuXG4gIG9uS2V5RG93bjogZnVuY3Rpb24gb25LZXlEb3duKGUpIHtcbiAgICB2YXIga2V5Q29kZSA9IGUua2V5Q29kZTtcbiAgICB2YXIgbWVudSA9IHRoaXMubWVudUluc3RhbmNlO1xuXG4gICAgaWYgKGtleUNvZGUgPT09IF9yY1V0aWwuS2V5Q29kZS5FTlRFUikge1xuICAgICAgdGhpcy5vbkNsaWNrKGUpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGRlZmF1bHRBY3RpdmVGaXJzdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoa2V5Q29kZSA9PT0gX3JjVXRpbC5LZXlDb2RlLlJJR0hUKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5vcGVuKSB7XG4gICAgICAgIG1lbnUub25LZXlEb3duKGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyT3BlbkNoYW5nZSh0cnVlKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgZGVmYXVsdEFjdGl2ZUZpcnN0OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChrZXlDb2RlID09PSBfcmNVdGlsLktleUNvZGUuTEVGVCkge1xuICAgICAgdmFyIGhhbmRsZWQgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAodGhpcy5wcm9wcy5vcGVuKSB7XG4gICAgICAgIGhhbmRsZWQgPSBtZW51Lm9uS2V5RG93bihlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoIWhhbmRsZWQpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyT3BlbkNoYW5nZShmYWxzZSk7XG4gICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhbmRsZWQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucHJvcHMub3BlbiAmJiAoa2V5Q29kZSA9PT0gX3JjVXRpbC5LZXlDb2RlLlVQIHx8IGtleUNvZGUgPT09IF9yY1V0aWwuS2V5Q29kZS5ET1dOKSkge1xuICAgICAgcmV0dXJuIG1lbnUub25LZXlEb3duKGUpO1xuICAgIH1cbiAgfSxcblxuICBvblN1YlRyZWVNb3VzZUVudGVyOiBmdW5jdGlvbiBvblN1YlRyZWVNb3VzZUVudGVyKCkge1xuICAgIGlmICh0aGlzLmxlYXZlVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmxlYXZlVGltZXIpO1xuICAgICAgdGhpcy5sZWF2ZVRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH0sXG5cbiAgb25PcGVuQ2hhbmdlOiBmdW5jdGlvbiBvbk9wZW5DaGFuZ2UoZSkge1xuICAgIHRoaXMucHJvcHMub25PcGVuQ2hhbmdlKHRoaXMuYWRkS2V5UGF0aChlKSk7XG4gIH0sXG5cbiAgb25Nb3VzZUVudGVyOiBmdW5jdGlvbiBvbk1vdXNlRW50ZXIoKSB7XG4gICAgaWYgKHRoaXMubGVhdmVUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubGVhdmVUaW1lcik7XG4gICAgICB0aGlzLmxlYXZlVGltZXIgPSBudWxsO1xuICAgIH1cbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBwYXJlbnRNZW51ID0gcHJvcHMucGFyZW50TWVudTtcbiAgICBpZiAocGFyZW50TWVudS5tZW51SXRlbU1vdXNlTGVhdmVUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHBhcmVudE1lbnUubWVudUl0ZW1Nb3VzZUxlYXZlVGltZXIpO1xuICAgICAgcGFyZW50TWVudS5tZW51SXRlbU1vdXNlTGVhdmVUaW1lciA9IG51bGw7XG4gICAgfVxuICAgIHByb3BzLm9uSXRlbUhvdmVyKHtcbiAgICAgIGtleTogdGhpcy5wcm9wcy5ldmVudEtleSxcbiAgICAgIGl0ZW06IHRoaXMsXG4gICAgICBob3ZlcjogdHJ1ZSxcbiAgICAgIHRyaWdnZXI6ICdtb3VzZWVudGVyJ1xuICAgIH0pO1xuICAgIGlmIChwcm9wcy5vcGVuU3ViTWVudU9uTW91c2VFbnRlcikge1xuICAgICAgdGhpcy50cmlnZ2VyT3BlbkNoYW5nZSh0cnVlKTtcbiAgICB9XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBkZWZhdWx0QWN0aXZlRmlyc3Q6IGZhbHNlXG4gICAgfSk7XG4gIH0sXG5cbiAgb25Nb3VzZUxlYXZlOiBmdW5jdGlvbiBvbk1vdXNlTGVhdmUoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8vIHByZXZlbnQgcG9wdXAgbWVudSBhbmQgc3VibWVudSBnYXBcbiAgICB0aGlzLmxlYXZlVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGxlYXZlIHdob2xlIHN1YiB0cmVlXG4gICAgICAvLyBzdGlsbCBhY3RpdmVcbiAgICAgIGlmIChfdGhpcy5pc01vdW50ZWQoKSAmJiBfdGhpcy5wcm9wcy5hY3RpdmUpIHtcbiAgICAgICAgX3RoaXMucHJvcHMub25JdGVtSG92ZXIoe1xuICAgICAgICAgIGtleTogX3RoaXMucHJvcHMuZXZlbnRLZXksXG4gICAgICAgICAgaXRlbTogX3RoaXMsXG4gICAgICAgICAgaG92ZXI6IGZhbHNlLFxuICAgICAgICAgIHRyaWdnZXI6ICdtb3VzZWxlYXZlJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfdGhpcy5pc01vdW50ZWQoKSAmJiBfdGhpcy5wcm9wcy5vcGVuKSB7XG4gICAgICAgIGlmIChfdGhpcy5wcm9wcy5jbG9zZVN1Yk1lbnVPbk1vdXNlTGVhdmUpIHtcbiAgICAgICAgICBfdGhpcy50cmlnZ2VyT3BlbkNoYW5nZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCAxMDApO1xuICB9LFxuXG4gIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soKSB7XG4gICAgaWYgKHRoaXMucHJvcHMub3BlblN1Yk1lbnVPbk1vdXNlRW50ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy50cmlnZ2VyT3BlbkNoYW5nZSghdGhpcy5wcm9wcy5vcGVuLCAnY2xpY2snKTtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGRlZmF1bHRBY3RpdmVGaXJzdDogZmFsc2VcbiAgICB9KTtcbiAgfSxcblxuICBvblN1Yk1lbnVDbGljazogZnVuY3Rpb24gb25TdWJNZW51Q2xpY2soaW5mbykge1xuICAgIHRoaXMucHJvcHMub25DbGljayh0aGlzLmFkZEtleVBhdGgoaW5mbykpO1xuICB9LFxuXG4gIG9uU2VsZWN0OiBmdW5jdGlvbiBvblNlbGVjdChpbmZvKSB7XG4gICAgdGhpcy5wcm9wcy5vblNlbGVjdChpbmZvKTtcbiAgfSxcblxuICBvbkRlc2VsZWN0OiBmdW5jdGlvbiBvbkRlc2VsZWN0KGluZm8pIHtcbiAgICB0aGlzLnByb3BzLm9uRGVzZWxlY3QoaW5mbyk7XG4gIH0sXG5cbiAgZ2V0UHJlZml4Q2xzOiBmdW5jdGlvbiBnZXRQcmVmaXhDbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMucm9vdFByZWZpeENscyArICctc3VibWVudSc7XG4gIH0sXG5cbiAgZ2V0QWN0aXZlQ2xhc3NOYW1lOiBmdW5jdGlvbiBnZXRBY3RpdmVDbGFzc05hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UHJlZml4Q2xzKCkgKyAnLWFjdGl2ZSc7XG4gIH0sXG5cbiAgZ2V0RGlzYWJsZWRDbGFzc05hbWU6IGZ1bmN0aW9uIGdldERpc2FibGVkQ2xhc3NOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmdldFByZWZpeENscygpICsgJy1kaXNhYmxlZCc7XG4gIH0sXG5cbiAgZ2V0T3BlbkNsYXNzTmFtZTogZnVuY3Rpb24gZ2V0T3BlbkNsYXNzTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5yb290UHJlZml4Q2xzICsgJy1zdWJtZW51LW9wZW4nO1xuICB9LFxuXG4gIHNhdmVNZW51SW5zdGFuY2U6IGZ1bmN0aW9uIHNhdmVNZW51SW5zdGFuY2UoYykge1xuICAgIHRoaXMubWVudUluc3RhbmNlID0gYztcbiAgfSxcblxuICBhZGRLZXlQYXRoOiBmdW5jdGlvbiBhZGRLZXlQYXRoKGluZm8pIHtcbiAgICByZXR1cm4gKDAsIF9vYmplY3RBc3NpZ24yWydkZWZhdWx0J10pKHt9LCBpbmZvLCB7XG4gICAgICBrZXlQYXRoOiAoaW5mby5rZXlQYXRoIHx8IFtdKS5jb25jYXQodGhpcy5wcm9wcy5ldmVudEtleSlcbiAgICB9KTtcbiAgfSxcblxuICB0cmlnZ2VyT3BlbkNoYW5nZTogZnVuY3Rpb24gdHJpZ2dlck9wZW5DaGFuZ2Uob3BlbiwgdHlwZSkge1xuICAgIHZhciBrZXkgPSB0aGlzLnByb3BzLmV2ZW50S2V5O1xuICAgIHRoaXMub25PcGVuQ2hhbmdlKHtcbiAgICAgIGtleToga2V5LFxuICAgICAgaXRlbTogdGhpcyxcbiAgICAgIHRyaWdnZXI6IHR5cGUsXG4gICAgICBvcGVuOiBvcGVuXG4gICAgfSk7XG4gIH0sXG5cbiAgcmVuZGVyQ2hpbGRyZW46IGZ1bmN0aW9uIHJlbmRlckNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgYmFzZVByb3BzID0ge1xuICAgICAgbW9kZTogcHJvcHMubW9kZSA9PT0gJ2hvcml6b250YWwnID8gJ3ZlcnRpY2FsJyA6IHByb3BzLm1vZGUsXG4gICAgICB2aXNpYmxlOiBwcm9wcy5vcGVuLFxuICAgICAgbGV2ZWw6IHByb3BzLmxldmVsICsgMSxcbiAgICAgIGlubGluZUluZGVudDogcHJvcHMuaW5saW5lSW5kZW50LFxuICAgICAgZm9jdXNhYmxlOiBmYWxzZSxcbiAgICAgIG9uQ2xpY2s6IHRoaXMub25TdWJNZW51Q2xpY2ssXG4gICAgICBvblNlbGVjdDogdGhpcy5vblNlbGVjdCxcbiAgICAgIG9uRGVzZWxlY3Q6IHRoaXMub25EZXNlbGVjdCxcbiAgICAgIG9uRGVzdHJveTogdGhpcy5vbkRlc3Ryb3ksXG4gICAgICBzZWxlY3RlZEtleXM6IHByb3BzLnNlbGVjdGVkS2V5cyxcbiAgICAgIGV2ZW50S2V5OiBwcm9wcy5ldmVudEtleSArICctbWVudS0nLFxuICAgICAgb3BlbktleXM6IHByb3BzLm9wZW5LZXlzLFxuICAgICAgb3BlblRyYW5zaXRpb25OYW1lOiBwcm9wcy5vcGVuVHJhbnNpdGlvbk5hbWUsXG4gICAgICBvcGVuQW5pbWF0aW9uOiBwcm9wcy5vcGVuQW5pbWF0aW9uLFxuICAgICAgb25PcGVuQ2hhbmdlOiB0aGlzLm9uT3BlbkNoYW5nZSxcbiAgICAgIGNsb3NlU3ViTWVudU9uTW91c2VMZWF2ZTogcHJvcHMuY2xvc2VTdWJNZW51T25Nb3VzZUxlYXZlLFxuICAgICAgZGVmYXVsdEFjdGl2ZUZpcnN0OiB0aGlzLnN0YXRlLmRlZmF1bHRBY3RpdmVGaXJzdCxcbiAgICAgIG11bHRpcGxlOiBwcm9wcy5tdWx0aXBsZSxcbiAgICAgIHByZWZpeENsczogcHJvcHMucm9vdFByZWZpeENscyxcbiAgICAgIGlkOiB0aGlzLl9tZW51SWQsXG4gICAgICByZWY6IHRoaXMuc2F2ZU1lbnVJbnN0YW5jZVxuICAgIH07XG4gICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgX1N1YlBvcHVwTWVudTJbJ2RlZmF1bHQnXSxcbiAgICAgIGJhc2VQcm9wcyxcbiAgICAgIGNoaWxkcmVuXG4gICAgKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX2NsYXNzZXM7XG5cbiAgICB0aGlzLmhhdmVPcGVuID0gdGhpcy5oYXZlT3BlbiB8fCB0aGlzLnByb3BzLm9wZW47XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcHJlZml4Q2xzID0gdGhpcy5nZXRQcmVmaXhDbHMoKTtcbiAgICB2YXIgY2xhc3NlcyA9IChfY2xhc3NlcyA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzZXMsIHByb3BzLmNsYXNzTmFtZSwgISFwcm9wcy5jbGFzc05hbWUpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzZXMsIHByZWZpeENscyArICctJyArIHByb3BzLm1vZGUsIDEpLCBfY2xhc3Nlcyk7XG5cbiAgICBjbGFzc2VzW3RoaXMuZ2V0T3BlbkNsYXNzTmFtZSgpXSA9IHRoaXMucHJvcHMub3BlbjtcbiAgICBjbGFzc2VzW3RoaXMuZ2V0QWN0aXZlQ2xhc3NOYW1lKCldID0gcHJvcHMuYWN0aXZlO1xuICAgIGNsYXNzZXNbdGhpcy5nZXREaXNhYmxlZENsYXNzTmFtZSgpXSA9IHByb3BzLmRpc2FibGVkO1xuICAgIHRoaXMuX21lbnVJZCA9IHRoaXMuX21lbnVJZCB8fCAoMCwgX3JjVXRpbC5ndWlkKSgpO1xuICAgIGNsYXNzZXNbcHJlZml4Q2xzXSA9IHRydWU7XG4gICAgY2xhc3Nlc1twcmVmaXhDbHMgKyAnLScgKyBwcm9wcy5tb2RlXSA9IDE7XG4gICAgdmFyIGNsaWNrRXZlbnRzID0ge307XG4gICAgdmFyIG1vdXNlRXZlbnRzID0ge307XG4gICAgdmFyIHRpdGxlTW91c2VFdmVudHMgPSB7fTtcbiAgICBpZiAoIXByb3BzLmRpc2FibGVkKSB7XG4gICAgICBjbGlja0V2ZW50cyA9IHtcbiAgICAgICAgb25DbGljazogdGhpcy5vbkNsaWNrXG4gICAgICB9O1xuICAgICAgbW91c2VFdmVudHMgPSB7XG4gICAgICAgIG9uTW91c2VMZWF2ZTogdGhpcy5vbk1vdXNlTGVhdmUsXG4gICAgICAgIG9uTW91c2VFbnRlcjogdGhpcy5vblN1YlRyZWVNb3VzZUVudGVyXG4gICAgICB9O1xuICAgICAgLy8gb25seSB3b3JrcyBpbiB0aXRsZSwgbm90IG91dGVyIGxpXG4gICAgICB0aXRsZU1vdXNlRXZlbnRzID0ge1xuICAgICAgICBvbk1vdXNlRW50ZXI6IHRoaXMub25Nb3VzZUVudGVyXG4gICAgICB9O1xuICAgIH1cbiAgICB2YXIgc3R5bGUgPSB7fTtcbiAgICBpZiAocHJvcHMubW9kZSA9PT0gJ2lubGluZScpIHtcbiAgICAgIHN0eWxlLnBhZGRpbmdMZWZ0ID0gcHJvcHMuaW5saW5lSW5kZW50ICogcHJvcHMubGV2ZWw7XG4gICAgfVxuICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICdsaScsXG4gICAgICBfZXh0ZW5kcyh7IGNsYXNzTmFtZTogKDAsIF9jbGFzc25hbWVzMlsnZGVmYXVsdCddKShjbGFzc2VzKSB9LCBtb3VzZUV2ZW50cyksXG4gICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIF9leHRlbmRzKHtcbiAgICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgICAgY2xhc3NOYW1lOiBwcmVmaXhDbHMgKyAnLXRpdGxlJ1xuICAgICAgICB9LCB0aXRsZU1vdXNlRXZlbnRzLCBjbGlja0V2ZW50cywge1xuICAgICAgICAgICdhcmlhLW9wZW4nOiBwcm9wcy5vcGVuLFxuICAgICAgICAgICdhcmlhLW93bnMnOiB0aGlzLl9tZW51SWQsXG4gICAgICAgICAgJ2FyaWEtaGFzcG9wdXAnOiAndHJ1ZSdcbiAgICAgICAgfSksXG4gICAgICAgIHByb3BzLnRpdGxlXG4gICAgICApLFxuICAgICAgdGhpcy5yZW5kZXJDaGlsZHJlbihwcm9wcy5jaGlsZHJlbilcbiAgICApO1xuICB9XG59KTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gU3ViTWVudTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtc2VsZWN0Mi9+L3JjLXNlbGVjdC9+L3JjLW1lbnUvbGliL1N1Yk1lbnUuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9NZW51TWl4aW4gPSByZXF1aXJlKCcuL01lbnVNaXhpbicpO1xuXG52YXIgX01lbnVNaXhpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZW51TWl4aW4pO1xuXG52YXIgX29iamVjdEFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIF9vYmplY3RBc3NpZ24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb2JqZWN0QXNzaWduKTtcblxudmFyIF91dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbnZhciBfcmNBbmltYXRlID0gcmVxdWlyZSgncmMtYW5pbWF0ZScpO1xuXG52YXIgX3JjQW5pbWF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yY0FuaW1hdGUpO1xuXG52YXIgU3ViUG9wdXBNZW51ID0gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdTdWJQb3B1cE1lbnUnLFxuXG4gIHByb3BUeXBlczoge1xuICAgIG9uU2VsZWN0OiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25DbGljazogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLFxuICAgIG9uRGVzZWxlY3Q6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbk9wZW5DaGFuZ2U6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkRlc3Ryb3k6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvcGVuVHJhbnNpdGlvbk5hbWU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9wZW5BbmltYXRpb246IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMub25lT2ZUeXBlKFtfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLnN0cmluZywgX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5vYmplY3RdKSxcbiAgICBvcGVuS2V5czogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5hcnJheU9mKF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nKSxcbiAgICBjbG9zZVN1Yk1lbnVPbk1vdXNlTGVhdmU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCxcbiAgICB2aXNpYmxlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmJvb2wsXG4gICAgY2hpbGRyZW46IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYW55XG4gIH0sXG5cbiAgbWl4aW5zOiBbX01lbnVNaXhpbjJbJ2RlZmF1bHQnXV0sXG5cbiAgb25EZXNlbGVjdDogZnVuY3Rpb24gb25EZXNlbGVjdChzZWxlY3RJbmZvKSB7XG4gICAgdGhpcy5wcm9wcy5vbkRlc2VsZWN0KHNlbGVjdEluZm8pO1xuICB9LFxuXG4gIG9uU2VsZWN0OiBmdW5jdGlvbiBvblNlbGVjdChzZWxlY3RJbmZvKSB7XG4gICAgdGhpcy5wcm9wcy5vblNlbGVjdChzZWxlY3RJbmZvKTtcbiAgfSxcblxuICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICB0aGlzLnByb3BzLm9uQ2xpY2soZSk7XG4gIH0sXG5cbiAgb25PcGVuQ2hhbmdlOiBmdW5jdGlvbiBvbk9wZW5DaGFuZ2UoZSkge1xuICAgIHRoaXMucHJvcHMub25PcGVuQ2hhbmdlKGUpO1xuICB9LFxuXG4gIG9uRGVzdHJveTogZnVuY3Rpb24gb25EZXN0cm95KGtleSkge1xuICAgIHRoaXMucHJvcHMub25EZXN0cm95KGtleSk7XG4gIH0sXG5cbiAgb25JdGVtSG92ZXI6IGZ1bmN0aW9uIG9uSXRlbUhvdmVyKGUpIHtcbiAgICB0aGlzLm9uQ29tbW9uSXRlbUhvdmVyKGUpO1xuICB9LFxuXG4gIGdldE9wZW5UcmFuc2l0aW9uTmFtZTogZnVuY3Rpb24gZ2V0T3BlblRyYW5zaXRpb25OYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLm9wZW5UcmFuc2l0aW9uTmFtZTtcbiAgfSxcblxuICByZW5kZXJNZW51SXRlbTogZnVuY3Rpb24gcmVuZGVyTWVudUl0ZW0oYywgaSwgc3ViSW5kZXgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBrZXkgPSAoMCwgX3V0aWwuZ2V0S2V5RnJvbUNoaWxkcmVuSW5kZXgpKGMsIHByb3BzLmV2ZW50S2V5LCBpKTtcbiAgICB2YXIgZXh0cmFQcm9wcyA9IHtcbiAgICAgIG9wZW5LZXlzOiBwcm9wcy5vcGVuS2V5cyxcbiAgICAgIHNlbGVjdGVkS2V5czogcHJvcHMuc2VsZWN0ZWRLZXlzLFxuICAgICAgb3BlbjogcHJvcHMub3BlbktleXMuaW5kZXhPZihrZXkpICE9PSAtMSxcbiAgICAgIHNlbGVjdGVkOiBwcm9wcy5zZWxlY3RlZEtleXMuaW5kZXhPZihrZXkpICE9PSAtMSxcbiAgICAgIG9wZW5TdWJNZW51T25Nb3VzZUVudGVyOiB0cnVlXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJDb21tb25NZW51SXRlbShjLCBpLCBzdWJJbmRleCwgZXh0cmFQcm9wcyk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHJlbmRlckZpcnN0ID0gdGhpcy5yZW5kZXJGaXJzdDtcbiAgICB0aGlzLnJlbmRlckZpcnN0ID0gMTtcbiAgICB0aGlzLmhhdmVPcGVuZWQgPSB0aGlzLmhhdmVPcGVuZWQgfHwgdGhpcy5wcm9wcy52aXNpYmxlO1xuICAgIGlmICghdGhpcy5oYXZlT3BlbmVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHRyYW5zaXRpb25BcHBlYXIgPSB0cnVlO1xuICAgIGlmICghcmVuZGVyRmlyc3QgJiYgdGhpcy5wcm9wcy52aXNpYmxlKSB7XG4gICAgICB0cmFuc2l0aW9uQXBwZWFyID0gZmFsc2U7XG4gICAgfVxuICAgIHZhciBwcm9wcyA9ICgwLCBfb2JqZWN0QXNzaWduMlsnZGVmYXVsdCddKSh7fSwgdGhpcy5wcm9wcyk7XG4gICAgcHJvcHMuY2xhc3NOYW1lICs9ICcgJyArIHByb3BzLnByZWZpeENscyArICctc3ViJztcbiAgICB2YXIgYW5pbVByb3BzID0ge307XG4gICAgaWYgKHByb3BzLm9wZW5UcmFuc2l0aW9uTmFtZSkge1xuICAgICAgYW5pbVByb3BzLnRyYW5zaXRpb25OYW1lID0gcHJvcHMub3BlblRyYW5zaXRpb25OYW1lO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb3BzLm9wZW5BbmltYXRpb24gPT09ICdvYmplY3QnKSB7XG4gICAgICBhbmltUHJvcHMuYW5pbWF0aW9uID0gKDAsIF9vYmplY3RBc3NpZ24yWydkZWZhdWx0J10pKHt9LCBwcm9wcy5vcGVuQW5pbWF0aW9uKTtcbiAgICAgIGlmICghdHJhbnNpdGlvbkFwcGVhcikge1xuICAgICAgICBkZWxldGUgYW5pbVByb3BzLmFuaW1hdGlvbi5hcHBlYXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgIF9yY0FuaW1hdGUyWydkZWZhdWx0J10sXG4gICAgICBfZXh0ZW5kcyh7fSwgYW5pbVByb3BzLCB7XG4gICAgICAgIHNob3dQcm9wOiAndmlzaWJsZScsXG4gICAgICAgIGNvbXBvbmVudDogJycsXG4gICAgICAgIHRyYW5zaXRpb25BcHBlYXI6IHRyYW5zaXRpb25BcHBlYXIgfSksXG4gICAgICB0aGlzLnJlbmRlclJvb3QocHJvcHMpXG4gICAgKTtcbiAgfVxufSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFN1YlBvcHVwTWVudTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIG5vZGVfbW9kdWxlcy91eGNvcmUtc2VsZWN0Mi9+L3JjLXNlbGVjdC9+L3JjLW1lbnUvbGliL1N1YlBvcHVwTWVudS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9yY1V0aWwgPSByZXF1aXJlKCdyYy11dGlsJyk7XG5cbnZhciBfcmNVdGlsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JjVXRpbCk7XG5cbnZhciBfcmVhY3REb20gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIF9yZWFjdERvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdERvbSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHtcbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuY29tcG9uZW50RGlkVXBkYXRlKCk7XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkVXBkYXRlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgaWYgKHRoaXMucHJvcHMubW9kZSAhPT0gJ2lubGluZScpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLm9wZW4pIHtcbiAgICAgICAgdGhpcy5iaW5kUm9vdENsb3NlSGFuZGxlcnMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudW5iaW5kUm9vdENsb3NlSGFuZGxlcnMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgaGFuZGxlRG9jdW1lbnRLZXlVcDogZnVuY3Rpb24gaGFuZGxlRG9jdW1lbnRLZXlVcChlKSB7XG4gICAgaWYgKGUua2V5Q29kZSA9PT0gX3JjVXRpbC5LZXlDb2RlLkVTQykge1xuICAgICAgdGhpcy5wcm9wcy5vbkl0ZW1Ib3Zlcih7XG4gICAgICAgIGtleTogdGhpcy5wcm9wcy5ldmVudEtleSxcbiAgICAgICAgaXRlbTogdGhpcyxcbiAgICAgICAgaG92ZXI6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgaGFuZGxlRG9jdW1lbnRDbGljazogZnVuY3Rpb24gaGFuZGxlRG9jdW1lbnRDbGljayhlKSB7XG4gICAgLy8gSWYgdGhlIGNsaWNrIG9yaWdpbmF0ZWQgZnJvbSB3aXRoaW4gdGhpcyBjb21wb25lbnRcbiAgICAvLyBkb24ndCBkbyBhbnl0aGluZy5cbiAgICBpZiAoX3JjVXRpbDJbJ2RlZmF1bHQnXS5Eb20uY29udGFpbnMoX3JlYWN0RG9tMlsnZGVmYXVsdCddLmZpbmRET01Ob2RlKHRoaXMpLCBlLnRhcmdldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICBwcm9wcy5vbkl0ZW1Ib3Zlcih7XG4gICAgICBob3ZlcjogZmFsc2UsXG4gICAgICBpdGVtOiB0aGlzLFxuICAgICAga2V5OiB0aGlzLnByb3BzLmV2ZW50S2V5XG4gICAgfSk7XG4gICAgdGhpcy50cmlnZ2VyT3BlbkNoYW5nZShmYWxzZSk7XG4gIH0sXG5cbiAgYmluZFJvb3RDbG9zZUhhbmRsZXJzOiBmdW5jdGlvbiBiaW5kUm9vdENsb3NlSGFuZGxlcnMoKSB7XG4gICAgaWYgKCF0aGlzLl9vbkRvY3VtZW50Q2xpY2tMaXN0ZW5lcikge1xuICAgICAgdGhpcy5fb25Eb2N1bWVudENsaWNrTGlzdGVuZXIgPSBfcmNVdGlsMlsnZGVmYXVsdCddLkRvbS5hZGRFdmVudExpc3RlbmVyKGRvY3VtZW50LCAnY2xpY2snLCB0aGlzLmhhbmRsZURvY3VtZW50Q2xpY2spO1xuICAgICAgdGhpcy5fb25Eb2N1bWVudEtleXVwTGlzdGVuZXIgPSBfcmNVdGlsMlsnZGVmYXVsdCddLkRvbS5hZGRFdmVudExpc3RlbmVyKGRvY3VtZW50LCAna2V5dXAnLCB0aGlzLmhhbmRsZURvY3VtZW50S2V5VXApO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmRSb290Q2xvc2VIYW5kbGVyczogZnVuY3Rpb24gdW5iaW5kUm9vdENsb3NlSGFuZGxlcnMoKSB7XG4gICAgaWYgKHRoaXMuX29uRG9jdW1lbnRDbGlja0xpc3RlbmVyKSB7XG4gICAgICB0aGlzLl9vbkRvY3VtZW50Q2xpY2tMaXN0ZW5lci5yZW1vdmUoKTtcbiAgICAgIHRoaXMuX29uRG9jdW1lbnRDbGlja0xpc3RlbmVyID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb25Eb2N1bWVudEtleXVwTGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuX29uRG9jdW1lbnRLZXl1cExpc3RlbmVyLnJlbW92ZSgpO1xuICAgICAgdGhpcy5fb25Eb2N1bWVudEtleXVwTGlzdGVuZXIgPSBudWxsO1xuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy51bmJpbmRSb290Q2xvc2VIYW5kbGVycygpO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1zZWxlY3QyL34vcmMtc2VsZWN0L34vcmMtbWVudS9saWIvU3ViTWVudVN0YXRlTWl4aW4uanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yY1V0aWwgPSByZXF1aXJlKCdyYy11dGlsJyk7XG5cbnZhciBfY2xhc3NuYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcblxudmFyIF9jbGFzc25hbWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzbmFtZXMpO1xuXG52YXIgTWVudUl0ZW0gPSBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ01lbnVJdGVtJyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICByb290UHJlZml4Q2xzOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLnN0cmluZyxcbiAgICBldmVudEtleTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmcsXG4gICAgYWN0aXZlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmJvb2wsXG4gICAgc2VsZWN0ZWQ6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCxcbiAgICBkaXNhYmxlZDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLFxuICAgIHRpdGxlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLnN0cmluZyxcbiAgICBvblNlbGVjdDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLFxuICAgIG9uQ2xpY2s6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkRlc2VsZWN0OiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmMsXG4gICAgcGFyZW50TWVudTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5vYmplY3QsXG4gICAgb25JdGVtSG92ZXI6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYyxcbiAgICBvbkRlc3Ryb3k6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuY1xuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvblNlbGVjdDogZnVuY3Rpb24gb25TZWxlY3QoKSB7fSxcbiAgICAgIG9uTW91c2VFbnRlcjogZnVuY3Rpb24gb25Nb3VzZUVudGVyKCkge31cbiAgICB9O1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIGlmIChwcm9wcy5vbkRlc3Ryb3kpIHtcbiAgICAgIHByb3BzLm9uRGVzdHJveShwcm9wcy5ldmVudEtleSk7XG4gICAgfVxuICB9LFxuXG4gIG9uS2V5RG93bjogZnVuY3Rpb24gb25LZXlEb3duKGUpIHtcbiAgICB2YXIga2V5Q29kZSA9IGUua2V5Q29kZTtcbiAgICBpZiAoa2V5Q29kZSA9PT0gX3JjVXRpbC5LZXlDb2RlLkVOVEVSKSB7XG4gICAgICB0aGlzLm9uQ2xpY2soZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgb25Nb3VzZUxlYXZlOiBmdW5jdGlvbiBvbk1vdXNlTGVhdmUoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBldmVudEtleSA9IHRoaXMucHJvcHMuZXZlbnRLZXk7XG4gICAgdmFyIHBhcmVudE1lbnUgPSB0aGlzLnByb3BzLnBhcmVudE1lbnU7XG4gICAgcGFyZW50TWVudS5tZW51SXRlbU1vdXNlTGVhdmVUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF90aGlzLmlzTW91bnRlZCgpICYmIF90aGlzLnByb3BzLmFjdGl2ZSkge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkl0ZW1Ib3Zlcih7XG4gICAgICAgICAga2V5OiBldmVudEtleSxcbiAgICAgICAgICBpdGVtOiBfdGhpcyxcbiAgICAgICAgICBob3ZlcjogZmFsc2UsXG4gICAgICAgICAgdHJpZ2dlcjogJ21vdXNlbGVhdmUnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIDMwKTtcbiAgfSxcblxuICBvbk1vdXNlRW50ZXI6IGZ1bmN0aW9uIG9uTW91c2VFbnRlcigpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBwYXJlbnRNZW51ID0gdGhpcy5wcm9wcy5wYXJlbnRNZW51O1xuICAgIGlmIChwYXJlbnRNZW51Lm1lbnVJdGVtTW91c2VMZWF2ZVRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQocGFyZW50TWVudS5tZW51SXRlbU1vdXNlTGVhdmVUaW1lcik7XG4gICAgICBwYXJlbnRNZW51Lm1lbnVJdGVtTW91c2VMZWF2ZVRpbWVyID0gbnVsbDtcbiAgICB9XG4gICAgdmFyIGV2ZW50S2V5ID0gcHJvcHMuZXZlbnRLZXk7XG4gICAgcHJvcHMub25JdGVtSG92ZXIoe1xuICAgICAga2V5OiBldmVudEtleSxcbiAgICAgIGl0ZW06IHRoaXMsXG4gICAgICBob3ZlcjogdHJ1ZSxcbiAgICAgIHRyaWdnZXI6ICdtb3VzZWVudGVyJ1xuICAgIH0pO1xuICB9LFxuXG4gIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soZSkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGV2ZW50S2V5ID0gcHJvcHMuZXZlbnRLZXk7XG4gICAgdmFyIGluZm8gPSB7XG4gICAgICBrZXk6IGV2ZW50S2V5LFxuICAgICAga2V5UGF0aDogW2V2ZW50S2V5XSxcbiAgICAgIGl0ZW06IHRoaXMsXG4gICAgICBkb21FdmVudDogZVxuICAgIH07XG4gICAgcHJvcHMub25DbGljayhpbmZvKTtcbiAgICBpZiAocHJvcHMubXVsdGlwbGUpIHtcbiAgICAgIGlmIChwcm9wcy5zZWxlY3RlZCkge1xuICAgICAgICBwcm9wcy5vbkRlc2VsZWN0KGluZm8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcHMub25TZWxlY3QoaW5mbyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghcHJvcHMuc2VsZWN0ZWQpIHtcbiAgICAgIHByb3BzLm9uU2VsZWN0KGluZm8pO1xuICAgIH1cbiAgfSxcblxuICBnZXRQcmVmaXhDbHM6IGZ1bmN0aW9uIGdldFByZWZpeENscygpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5yb290UHJlZml4Q2xzICsgJy1pdGVtJztcbiAgfSxcblxuICBnZXRBY3RpdmVDbGFzc05hbWU6IGZ1bmN0aW9uIGdldEFjdGl2ZUNsYXNzTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQcmVmaXhDbHMoKSArICctYWN0aXZlJztcbiAgfSxcblxuICBnZXRTZWxlY3RlZENsYXNzTmFtZTogZnVuY3Rpb24gZ2V0U2VsZWN0ZWRDbGFzc05hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UHJlZml4Q2xzKCkgKyAnLXNlbGVjdGVkJztcbiAgfSxcblxuICBnZXREaXNhYmxlZENsYXNzTmFtZTogZnVuY3Rpb24gZ2V0RGlzYWJsZWRDbGFzc05hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UHJlZml4Q2xzKCkgKyAnLWRpc2FibGVkJztcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBjbGFzc2VzID0ge307XG4gICAgY2xhc3Nlc1t0aGlzLmdldEFjdGl2ZUNsYXNzTmFtZSgpXSA9ICFwcm9wcy5kaXNhYmxlZCAmJiBwcm9wcy5hY3RpdmU7XG4gICAgY2xhc3Nlc1t0aGlzLmdldFNlbGVjdGVkQ2xhc3NOYW1lKCldID0gcHJvcHMuc2VsZWN0ZWQ7XG4gICAgY2xhc3Nlc1t0aGlzLmdldERpc2FibGVkQ2xhc3NOYW1lKCldID0gcHJvcHMuZGlzYWJsZWQ7XG4gICAgY2xhc3Nlc1t0aGlzLmdldFByZWZpeENscygpXSA9IHRydWU7XG4gICAgY2xhc3Nlc1twcm9wcy5jbGFzc05hbWVdID0gISFwcm9wcy5jbGFzc05hbWU7XG4gICAgdmFyIGF0dHJzID0gX2V4dGVuZHMoe30sIHByb3BzLmF0dHJpYnV0ZSwge1xuICAgICAgdGl0bGU6IHByb3BzLnRpdGxlLFxuICAgICAgY2xhc3NOYW1lOiAoMCwgX2NsYXNzbmFtZXMyWydkZWZhdWx0J10pKGNsYXNzZXMpLFxuICAgICAgcm9sZTogJ21lbnVpdGVtJyxcbiAgICAgICdhcmlhLXNlbGVjdGVkJzogcHJvcHMuc2VsZWN0ZWQsXG4gICAgICAnYXJpYS1kaXNhYmxlZCc6IHByb3BzLmRpc2FibGVkXG4gICAgfSk7XG4gICAgdmFyIG1vdXNlRXZlbnQgPSB7fTtcbiAgICBpZiAoIXByb3BzLmRpc2FibGVkKSB7XG4gICAgICBtb3VzZUV2ZW50ID0ge1xuICAgICAgICBvbkNsaWNrOiB0aGlzLm9uQ2xpY2ssXG4gICAgICAgIG9uTW91c2VMZWF2ZTogdGhpcy5vbk1vdXNlTGVhdmUsXG4gICAgICAgIG9uTW91c2VFbnRlcjogdGhpcy5vbk1vdXNlRW50ZXJcbiAgICAgIH07XG4gICAgfVxuICAgIHZhciBzdHlsZSA9IF9leHRlbmRzKHt9LCBwcm9wcy5zdHlsZSk7XG4gICAgaWYgKHByb3BzLm1vZGUgPT09ICdpbmxpbmUnKSB7XG4gICAgICBzdHlsZS5wYWRkaW5nTGVmdCA9IHByb3BzLmlubGluZUluZGVudCAqIHByb3BzLmxldmVsO1xuICAgIH1cbiAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnbGknLFxuICAgICAgX2V4dGVuZHMoeyBzdHlsZTogc3R5bGVcbiAgICAgIH0sIGF0dHJzLCBtb3VzZUV2ZW50KSxcbiAgICAgIHByb3BzLmNoaWxkcmVuXG4gICAgKTtcbiAgfVxufSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IE1lbnVJdGVtO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1zZWxlY3QyL34vcmMtc2VsZWN0L34vcmMtbWVudS9saWIvTWVudUl0ZW0uanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ3VpZDogcmVxdWlyZSgnLi9saWIvZ3VpZCcpLFxuICBjbGFzc1NldDogcmVxdWlyZSgnLi9saWIvY2xhc3NTZXQnKSxcbiAgam9pbkNsYXNzZXM6IHJlcXVpcmUoJy4vbGliL2pvaW5DbGFzc2VzJyksXG4gIEtleUNvZGU6IHJlcXVpcmUoJy4vbGliL0tleUNvZGUnKSxcbiAgUHVyZVJlbmRlck1peGluOiByZXF1aXJlKCcuL2xpYi9QdXJlUmVuZGVyTWl4aW4nKSxcbiAgc2hhbGxvd0VxdWFsOiByZXF1aXJlKCcuL2xpYi9zaGFsbG93RXF1YWwnKSxcbiAgY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uOiByZXF1aXJlKCcuL2xpYi9jcmVhdGVDaGFpbmVkRnVuY3Rpb24nKSxcbiAgRG9tOiB7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogcmVxdWlyZSgnLi9saWIvRG9tL2FkZEV2ZW50TGlzdGVuZXInKSxcbiAgICBjb250YWluczogcmVxdWlyZSgnLi9saWIvRG9tL2NvbnRhaW5zJylcbiAgfSxcbiAgQ2hpbGRyZW46IHtcbiAgICB0b0FycmF5OiByZXF1aXJlKCcuL2xpYi9DaGlsZHJlbi90b0FycmF5JyksXG4gICAgbWFwU2VsZjogcmVxdWlyZSgnLi9saWIvQ2hpbGRyZW4vbWFwU2VsZicpXG4gIH1cbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBub2RlX21vZHVsZXMvdXhjb3JlLWZvcm0vfi91eGNvcmUtY2FsZW5kYXIvfi9yYy11dGlsL2luZGV4LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDb21wb25lbnRXaXRoUHVyZVJlbmRlck1peGluXG4qL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoXCIuL3NoYWxsb3dFcXVhbFwiKTtcblxuLyoqXG4gKiBJZiB5b3VyIFJlYWN0IGNvbXBvbmVudCdzIHJlbmRlciBmdW5jdGlvbiBpcyBcInB1cmVcIiwgZS5nLiBpdCB3aWxsIHJlbmRlciB0aGVcbiAqIHNhbWUgcmVzdWx0IGdpdmVuIHRoZSBzYW1lIHByb3BzIGFuZCBzdGF0ZSwgcHJvdmlkZSB0aGlzIE1peGluIGZvciBhXG4gKiBjb25zaWRlcmFibGUgcGVyZm9ybWFuY2UgYm9vc3QuXG4gKlxuICogTW9zdCBSZWFjdCBjb21wb25lbnRzIGhhdmUgcHVyZSByZW5kZXIgZnVuY3Rpb25zLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICB2YXIgUmVhY3RDb21wb25lbnRXaXRoUHVyZVJlbmRlck1peGluID1cbiAqICAgICByZXF1aXJlKCdSZWFjdENvbXBvbmVudFdpdGhQdXJlUmVuZGVyTWl4aW4nKTtcbiAqICAgUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgIG1peGluczogW1JlYWN0Q29tcG9uZW50V2l0aFB1cmVSZW5kZXJNaXhpbl0sXG4gKlxuICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gKiAgICAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9e3RoaXMucHJvcHMuY2xhc3NOYW1lfT5mb288L2Rpdj47XG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiBOb3RlOiBUaGlzIG9ubHkgY2hlY2tzIHNoYWxsb3cgZXF1YWxpdHkgZm9yIHByb3BzIGFuZCBzdGF0ZS4gSWYgdGhlc2UgY29udGFpblxuICogY29tcGxleCBkYXRhIHN0cnVjdHVyZXMgdGhpcyBtaXhpbiBtYXkgaGF2ZSBmYWxzZS1uZWdhdGl2ZXMgZm9yIGRlZXBlclxuICogZGlmZmVyZW5jZXMuIE9ubHkgbWl4aW4gdG8gY29tcG9uZW50cyB3aGljaCBoYXZlIHNpbXBsZSBwcm9wcyBhbmQgc3RhdGUsIG9yXG4gKiB1c2UgYGZvcmNlVXBkYXRlKClgIHdoZW4geW91IGtub3cgZGVlcCBkYXRhIHN0cnVjdHVyZXMgaGF2ZSBjaGFuZ2VkLlxuICovXG52YXIgUmVhY3RDb21wb25lbnRXaXRoUHVyZVJlbmRlck1peGluID0ge1xuICBzaG91bGRDb21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uKG5leHRQcm9wcywgbmV4dFN0YXRlKSB7XG4gICAgcmV0dXJuICFzaGFsbG93RXF1YWwodGhpcy5wcm9wcywgbmV4dFByb3BzKSB8fFxuICAgICAgICAgICAhc2hhbGxvd0VxdWFsKHRoaXMuc3RhdGUsIG5leHRTdGF0ZSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb25lbnRXaXRoUHVyZVJlbmRlck1peGluO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1mb3JtL34vdXhjb3JlLWNhbGVuZGFyL34vcmMtdXRpbC9saWIvUHVyZVJlbmRlck1peGluLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX0J1dHRvbiA9IHJlcXVpcmUoJy4vQnV0dG9uJyk7XG5cbnZhciBfQnV0dG9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0J1dHRvbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9CdXR0b24yW1wiZGVmYXVsdFwiXTsgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEJ1dHRvbiBDb21wb25lbnQgZm9yIHV4Y29yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAYXV0aG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIENvcHlyaWdodCAyMDE0LTIwMTUsIFV4Y29yZSBUZWFtLCBBbGludy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3V4Y29yZS1tdWx0aS1zZWxlY3Qvfi91eGNvcmUtYnV0dG9uL2J1aWxkL2luZGV4LmpzXG4gKiovIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbENBOzs7Ozs7QUNBQTtBQUNBOzs7Ozs7Ozs7QUFTQTs7Ozs7O0FDVkE7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQVJBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTs7QUF2QkE7QUFBQTtBQUNBO0FBc0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQU5BO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQU9BO0FBUEE7QUFEQTtBQU5BO0FBQ0E7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBV0E7QUFYQTtBQWFBO0FBMUJBO0FBQ0E7QUE0QkE7QUFsSUE7QUFDQTtBQW9JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWEE7QUFDQTtBQWFBO0FBQ0E7Ozs7Ozs7QUNsTEE7Ozs7OztBQ0FBOzs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7Ozs7Ozs7O0FBU0E7Ozs7Ozs7QUNwQkE7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBakJBO0FBQ0E7QUF1QkE7QUFqQ0E7QUFDQTtBQW1DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7Ozs7OztBQ3ZGQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFEQTtBQUNBO0FBT0E7QUFqQkE7QUFDQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDN0NBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBR0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUNBO0FBSEE7QUE3REE7QUFDQTtBQW9FQTtBQXRGQTtBQUNBO0FBd0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFHQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFIQTtBQS9DQTtBQUNBO0FBc0RBO0FBbkVBO0FBQ0E7QUFxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUdBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUhBO0FBL0NBO0FBQ0E7QUFzREE7QUFuRUE7QUFDQTtBQXFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ25VQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFyQkE7QUFDQTtBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFEQTtBQVFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQURBO0FBR0E7O0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFLQTtBQUNBO0FBaEJBO0FBa0JBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFLQTtBQUNBO0FBeEJBO0FBMEJBO0FBQ0E7QUFDQTtBQTVCQTtBQThCQTtBQUNBO0FBQ0E7QUFoQ0E7QUFrQ0E7QUFDQTtBQUNBO0FBcENBO0FBc0NBO0FBQ0E7QUFDQTtBQXhDQTtBQTBDQTtBQUNBO0FBQ0E7QUE1Q0E7QUE4Q0E7QUFDQTtBQS9DQTtBQVBBO0FBeURBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBSEE7QUFPQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJBO0FBZUE7QUFHQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZEE7QUFDQTtBQWlCQTtBQUNBO0FBQ0E7QUFGQTtBQXpFQTtBQTlIQTtBQUNBO0FBNk1BOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3RSQTtBQUNBO0FBQ0E7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BO0FBbEhBOzs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFKQTs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7Ozs7Ozs7Ozs7Ozs7O0FDRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUdBO0FBSEE7QUFLQTtBQVJBO0FBVUE7QUFYQTtBQUNBO0FBYUE7QUFwQkE7QUFDQTs7Ozs7Ozs7O0FBOEJBOztBQUVBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFUQTs7Ozs7Ozs7Ozs7Ozs7O0FDbERBO0FBQ0E7QUFDQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTtBQXBhQTtBQUNBOzs7O0FBeWFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBSEE7QUFDQTs7O0FBSEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF4QkE7QUEwQkE7QUExQkE7QUFWQTtBQUNBOzs7O0FBMENBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUNBOztBQVZBO0FBZUE7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsQkE7QUFvQkE7QUFwQkE7QUFsQkE7QUFDQTtBQXlDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3ZkE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFEQTtBQUNBOztBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBRkE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7Ozs7QUFJQTtBQUpBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBCQTs7O0FBR0E7QUFDQTtBQUpBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFQQTtBQUNBO0FBU0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOUhBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBQ0E7Ozs7Ozs7Ozs7O0FBZUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7O0FBRUE7QUFGQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkJBO0FBQ0E7QUFEQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQkE7QUFDQTtBQURBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBOzs7O0FBSUE7QUFDQTtBQUxBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUErQkE7QUFDQTtBQURBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJCQTtBQUNBO0FBQ0E7QUFGQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQkE7QUFDQTtBQURBO0FBQ0E7QUFHQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4T0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQURBO0FBQ0E7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7QUFFQTtBQUNBOztBQUtBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBRkE7QUFDQTs7Ozs7Ozs7OztBQWFBO0FBQ0E7QUFEQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQTtBQUNBO0FBREE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkE7Ozs7QUFJQTtBQUpBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBCQTs7O0FBR0E7QUFDQTtBQUpBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFQQTtBQUNBO0FBU0E7Ozs7Ozs7Ozs7Ozs7O0FDM0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBREE7QUFGQTtBQUNBO0FBVUE7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBOzs7QUFEQTtBQUFBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFLQTtBQU5BO0FBMUJBO0FBQ0E7QUFtQ0E7Ozs7Ozs7O0FDNURBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBRkE7QUFUQTtBQUNBO0FBa0JBO0FBeEJBOzs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFKQTtBQUNBO0FBTUE7QUFUQTs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFMQTs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBOztBQUVBO0FBRkE7Ozs7OztBQ1JBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQVVBO0FBcEJBO0FBQ0E7QUFzQkE7Ozs7Ozs7QUMvQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFHQTtBQUNBO0FBSkE7QUFEQTtBQWNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBREE7QUFnQkE7QUE5Q0E7QUFGQTtBQUNBO0FBNERBO0FBdEVBO0FBQ0E7QUF3RUE7Ozs7Ozs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOzs7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBOUJBO0FBaUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFQQTtBQURBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFMQTtBQURBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQURBO0FBSEE7QUFSQTtBQURBO0FBa0JBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFQQTtBQURBO0FBQ0E7QUFhQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVBBO0FBQ0E7QUFrQkE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFDQTtBQVdBO0FBdEdBO0FBd0dBO0FBR0E7QUFDQTtBQUpBO0FBdEhBO0FBZ0lBO0FBaExBO0FBbEJBO0FBQ0E7QUF5TUE7Ozs7Ozs7QUNoUUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQVBBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFKQTtBQUZBO0FBU0E7QUFUQTtBQUxBO0FBaUJBO0FBbkJBO0FBQ0E7QUFxQkE7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQVhBOzs7Ozs7OztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBOzs7Ozs7Ozs7Ozs7Ozs7QUNPQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBTUE7QUFDQTtBQURBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7OztBQUdBO0FBSEE7QUFUQTtBQXBCQTtBQURBO0FBQ0E7QUFzQ0E7Ozs7Ozs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSkE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBVUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBVUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBS0E7QUFqQ0E7QUF1Q0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQURBO0FBUUE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQWNBO0FBQ0E7QUFDQTtBQUxBO0FBWUE7QUFDQTtBQUNBO0FBTEE7QUE1REE7QUFsR0E7QUFDQTtBQTRLQTs7Ozs7OztBQ3JOQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFNQTtBQUNBOztBQURBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQU5BO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBREE7QUFPQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBREE7QUFPQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQURBO0FBUUE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBbkVBO0FBMURBO0FBQ0E7QUEwSUE7Ozs7Ozs7QUN2S0E7QUFDQTs7O0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUhBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQWRBO0FBQ0E7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQUZBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBZkE7QUFGQTtBQW9CQTtBQTVCQTtBQVZBO0FBeUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQTFDQTtBQWdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQUhBO0FBS0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFZQTtBQUhBO0FBckJBO0FBOEJBO0FBL0JBO0FBQ0E7QUFxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQURBO0FBQ0E7QUFRQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBd0JBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFwR0E7QUFqREE7QUFDQTtBQWtMQTtBQXZNQTtBQUNBO0FBeU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBREE7QUFHQTs7Ozs7O0FDdFFBO0FBQ0E7OztBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBSEE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7O0FBTkE7QUFXQTtBQUNBO0FBQ0E7QUFiQTtBQUNBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFQQTtBQUZBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUdBO0FBQ0E7QUFKQTtBQU1BO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVdBO0FBSEE7QUExQkE7QUFtQ0E7QUFwQ0E7QUFDQTtBQTBDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQTVGQTtBQUZBO0FBQ0E7QUF5SEE7QUE3SUE7QUFDQTtBQStJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBREE7QUFHQTs7Ozs7O0FDM01BO0FBQ0E7OztBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQVJBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBREE7QUFGQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBUEE7QUFGQTtBQVlBO0FBcEJBO0FBWEE7QUFrQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSkE7QUFuQ0E7QUEwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBTEE7QUFPQTtBQWJBO0FBbUJBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBOUJBO0FBMENBO0FBM0NBO0FBQ0E7QUFpREE7QUFoRUE7QUEzQ0E7QUFDQTtBQXNIQTtBQXJJQTtBQUNBO0FBdUlBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BOzs7Ozs7O0FDdExBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBQ0E7QUFXQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQU5BO0FBREE7QUFVQTtBQTNCQTtBQUNBO0FBa0NBO0FBaERBO0FBckJBO0FBQ0E7QUF3RUE7Ozs7Ozs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFGQTtBQU1BO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQXJCQTtBQWdDQTs7Ozs7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFMQTtBQVZBO0FBb0JBOzs7Ozs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUpBO0FBTUE7QUFSQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFIQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUZBO0FBTUE7QUFDQTtBQUNBO0FBREE7QUFEQTtBQVZBO0FBZ0JBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUxBO0FBUkE7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQU5BO0FBREE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBQ0E7QUFEQTtBQVBBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQWpGQTtBQUNBO0FBdUZBOzs7Ozs7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFEQTtBQWFBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQVJBO0FBNUJBO0FBdUNBOzs7Ozs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF0QkE7QUF3QkE7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFGQTtBQU9BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFIQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBTUE7QUFDQTtBQURBO0FBR0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFEQTtBQU5BO0FBVUE7QUFDQTtBQURBO0FBR0E7QUFiQTtBQVpBO0FBNEJBO0FBNUJBO0FBOEJBO0FBQ0E7QUFEQTtBQTFDQTtBQThDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSkE7QUFNQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQXpDQTtBQXhGQTtBQUNBO0FBMElBOzs7Ozs7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBakJBO0FBQ0E7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQURBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQVZBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQVRBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFDQTtBQURBO0FBR0E7QUFaQTtBQWNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFIQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQU5BO0FBU0E7QUFEQTtBQUdBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFDQTtBQVNBO0FBdkJBO0FBeUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFQQTtBQUxBO0FBbUJBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQWJBO0FBM0pBO0FBQ0E7QUE2TEE7Ozs7Ozs7QUM5TkE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFuQkE7QUFDQTtBQTBCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZDQTtBQUNBOzs7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBTEE7QUFPQTtBQWpCQTtBQUNBO0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQU5BO0FBQ0E7Ozs7O0FBREE7QUFlQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFoQkE7QUFzQ0E7QUFDQTtBQUNBO0FBeENBO0FBQ0E7QUEwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFEQTtBQUlBOztBQUVBO0FBRkE7QUFKQTtBQVNBO0FBWkE7QUFDQTtBQWNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUxBO0FBUUE7QUFEQTtBQUNBO0FBR0E7QUFYQTtBQUNBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7Ozs7Ozs7Ozs7QUFKQTs7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7O0FBTEE7QUFDQTs7QUFEQTtBQVdBO0FBQ0E7O0FBWkE7QUFDQTtBQWVBO0FBaEJBO0FBa0JBO0FBakNBO0FBQ0E7QUFtQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQURBO0FBUEE7QUFDQTs7QUFZQTs7QUFFQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBSEE7QUFEQTtBQVdBO0FBMUNBO0FBQ0E7QUE0Q0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUNBO0FBS0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUpBO0FBT0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQUNBO0FBTUE7QUFDQTs7QUFkQTtBQWlCQTtBQUNBO0FBREE7QUFEQTtBQWhCQTtBQUNBO0FBc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFIQTtBQUtBO0FBUEE7QUFEQTtBQUZBO0FBY0E7QUFuQkE7QUFDQTs7Ozs7QUF5QkE7OztBQUdBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFQQTtBQUNBO0FBU0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBTkE7QUFBQTtBQVhBO0FBQ0E7Ozs7Ozs7OztBQStCQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQURBO0FBSUE7QUFDQTtBQURBOztBQUpBO0FBQUE7QUFVQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUpBO0FBTUE7QUFDQTtBQURBO0FBR0E7QUFKQTtBQU1BO0FBdENBO0FBQ0E7QUF3Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTs7O0FBTkE7QUFVQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBSEE7QUFPQTtBQWhCQTtBQUNBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFOQTtBQVFBO0FBVEE7QUFXQTtBQWJBO0FBUEE7QUFDQTtBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBREE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFEQTtBQU9BO0FBaEJBO0FBa0JBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFHQTtBQVZBO0FBWUE7QUFDQTtBQXhEQTtBQUNBO0FBMERBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdmVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUF2QkE7QUFDQTtBQTRCQTs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUhBO0FBQ0E7QUFLQTs7Ozs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFKQTtBQURBO0FBVUE7QUFaQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSkE7QUFEQTtBQURBO0FBVUE7QUFaQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUpBO0FBREE7QUFRQTtBQVZBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUpBO0FBREE7QUFVQTtBQVpBO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7OztBQUZBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU1BO0FBTkE7QUFEQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUEzQkE7Ozs7Ozs7Ozs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBVEE7QUFDQTtBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBRkE7QUFEQTtBQVpBO0FBQ0E7QUF3QkE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQURBO0FBTEE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUpBO0FBZEE7QUFDQTtBQXVCQTs7Ozs7Ozs7Ozs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBTEE7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBakJBO0FBcUJBOzs7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFMQTtBQU9BO0FBQ0E7QUFEQTtBQUdBO0FBWEE7QUFaQTtBQUNBO0FBMEJBOzs7Ozs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFEQTtBQU9BO0FBVEE7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFLQTtBQWhCQTtBQWtCQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFLQTtBQXhCQTtBQTBCQTtBQUNBO0FBQ0E7QUE1QkE7QUE4QkE7QUE5QkE7QUFnQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQXJDQTtBQTJDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQURBO0FBWEE7QUFoREE7QUFDQTtBQWdFQTs7Ozs7OztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBS0E7QUFoQkE7QUFrQkE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBS0E7QUF4QkE7QUEwQkE7QUFDQTtBQUNBO0FBNUJBO0FBOEJBO0FBOUJBO0FBZ0NBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFyQ0E7QUEyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFSQTtBQWhEQTtBQUNBO0FBK0RBOzs7Ozs7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ25TQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDM1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMzT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNsUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNuTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNyUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDMU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDdkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDNWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3BVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM5TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ25PQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDL0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQVFBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBOztBQVlBO0FBWkE7QUE3QkE7QUFIQTtBQUNBO0FBb0RBO0FBQ0E7QUFEQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZEQTs7Ozs7Ozs7Ozs7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFZQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQXJCQTtBQUNBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFIQTtBQVFBO0FBQ0E7QUFEQTtBQVJBO0FBTEE7QUFDQTtBQWtCQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBOzs7Ozs7QUMvREE7QUFDQTs7Ozs7Ozs7O0FBU0E7Ozs7OztBQ1ZBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQVRBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7Ozs7Ozs7OztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQW5FQTtBQUNBO0FBMEVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBTEE7QUFDQTtBQVVBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFKQTs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBckJBO0FBdUJBOzs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUNyQkE7QUFDQTs7Ozs7Ozs7O0FBU0E7Ozs7OztBQ1ZBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFEQTtBQURBO0FBVUE7QUFkQTtBQUNBO0FBZ0JBO0FBQ0E7QUFDQTs7QUFFQTtBQUZBO0FBSUE7QUFDQTtBQURBO0FBSkE7QUFRQTtBQVZBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBUUE7QUE5REE7QUFDQTtBQWdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBOzs7Ozs7O0FDeEdBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBS0E7QUFSQTtBQUNBO0FBZ0JBO0FBL0JBO0FBQ0E7QUFpQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBOzs7Ozs7Ozs7QUMzREE7QUFDQTs7Ozs7Ozs7O0FBU0E7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQURBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBSkE7QUFRQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFYQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQURBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7QUFGQTtBQUlBO0FBSkE7QUFDQTtBQU1BO0FBZEE7QUFnQkE7QUFsQkE7QUFIQTtBQXdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFYQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTtBQXBCQTtBQVRBO0FBZ0NBO0FBQ0E7QUFDQTtBQUZBO0FBL0dBO0FBQ0E7QUF3SEE7Ozs7Ozs7QUMzSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFNQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBT0E7QUFDQTtBQTFCQTtBQXBCQTtBQUNBO0FBd0RBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ25FQTs7Ozs7Ozs7Ozs7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUxBO0FBQ0E7QUFVQTs7Ozs7O0FDbkJBO0FBQ0E7Ozs7Ozs7OztBQVNBOzs7Ozs7QUNWQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFEQTtBQVJBO0FBRkE7QUFDQTtBQW9CQTtBQTlCQTtBQUNBO0FBZ0NBO0FBQ0E7QUFEQTtBQUNBOztBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3ZFQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFGQTtBQUNBO0FBZ0JBO0FBMUJBO0FBQ0E7QUE0QkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTs7Ozs7OztBQzlEQTtBQUNBOzs7Ozs7Ozs7QUFTQTs7Ozs7O0FDVkE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFUQTtBQUNBO0FBV0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBaENBO0FBQ0E7QUFrQ0E7QUExREE7QUFDQTtBQTREQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJBO0FBQ0E7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOzs7Ozs7QUM5SUE7QUFDQTtBQUNBOzs7Ozs7QUNGQTtBQUNBOzs7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQVBBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFUQTtBQUNBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUZBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFEQTtBQVBBO0FBZUE7QUFDQTtBQUNBO0FBREE7QUFoQkE7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBckJBO0FBMkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQURBO0FBT0E7QUFQQTtBQURBO0FBREE7QUE1QkE7QUEwQ0E7QUFDQTtBQUNBO0FBREE7QUEzQ0E7QUErQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQU5BO0FBaERBO0FBeURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQVBBO0FBMURBO0FBd0VBO0FBQ0E7QUFDQTtBQURBO0FBekVBO0FBNkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQTlFQTtBQW9GQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBckZBO0FBQ0E7QUEwRkE7QUE1R0E7QUFDQTtBQThHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFDQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0FBQ0E7QUFhQTs7Ozs7OztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUhBO0FBT0E7QUFWQTtBQUNBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBTEE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQUNBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBQ0E7QUFNQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUZBO0FBT0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFOQTtBQURBO0FBUkE7QUFDQTtBQW1CQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7O0FBRkE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQURBO0FBUkE7QUFEQTtBQVJBO0FBQ0E7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUpBO0FBREE7QUFGQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUdBOztBQTNEQTtBQWtGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBbEdBO0FBQ0E7QUF1R0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUxBO0FBTkE7QUFnQkE7QUExQkE7QUFDQTtBQTRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBUEE7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFQQTtBQUNBO0FBU0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBM1BBO0FBQ0E7QUF1UUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcFZBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQVBBO0FBYkE7QUFDQTtBQXVCQTs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFYQTtBQWNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBSkE7QUFRQTtBQUNBO0FBREE7QUFWQTtBQWNBO0FBZEE7QUFGQTtBQUNBO0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFKQTtBQVFBO0FBQ0E7QUFEQTtBQVZBO0FBY0E7QUFkQTtBQUZBO0FBQ0E7QUFtQkE7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBZ0JBO0FBaEJBO0FBQ0E7QUEwQkE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQURBO0FBaElBO0FBQ0E7QUFvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOzs7Ozs7O0FDOUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTkE7Ozs7OztBQ0ZBO0FBQ0E7Ozs7Ozs7OztBQVNBOzs7Ozs7QUNWQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFUQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTs7Ozs7OztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFkQTtBQUNBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWEE7QUFEQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFDQTtBQURBO0FBUEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFEQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQUNBO0FBREE7QUFSQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUZBO0FBT0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFIQTtBQURBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFyQkE7QUE3RkE7QUFDQTtBQStIQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6S0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFQQTtBQUNBO0FBY0E7Ozs7OztBQzNCQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDeEJBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQUNBO0FBV0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBRkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUhBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUhBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUpBO0FBQ0E7Ozs7O0FBeERBO0FBcUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUxBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUhBO0FBT0E7QUFYQTtBQUNBO0FBYUE7QUFDQTtBQURBO0FBQ0E7Ozs7Ozs7QUEvRkE7QUF5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQU9BO0FBREE7QUFQQTtBQUZBO0FBQ0E7QUFjQTtBQXZCQTtBQUNBO0FBeUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQURBO0FBVEE7QUFDQTtBQXdCQTtBQTNKQTtBQUNBOzs7QUFnS0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFDQTs7Ozs7OztBQzVOQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUpBO0FBREE7QUFGQTtBQUNBO0FBV0E7QUFyQkE7QUFDQTtBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQUNBO0FBWUE7QUFmQTtBQVJBO0FBQ0E7QUEyQkE7QUFoRUE7QUFDQTtBQWtFQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBOzs7Ozs7O0FDdEZBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBREE7QUFUQTtBQUNBO0FBY0E7QUF4QkE7QUFDQTtBQTBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBOzs7Ozs7O0FDMURBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBWEE7QUFDQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFGQTtBQUZBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRkE7QUFDQTtBQU1BO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUZBO0FBQ0E7QUFNQTtBQUNBO0FBREE7QUFDQTs7Ozs7OztBQS9DQTtBQXlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBUkE7QUFVQTs7QUFEQTtBQUlBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQU5BO0FBWEE7QUFDQTs7Ozs7O0FBekRBO0FBc0ZBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUhBOzs7O0FBSEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFMQTtBQURBO0FBU0E7QUFUQTtBQVhBO0FBQ0E7Ozs7Ozs7O0FBdEZBO0FBcUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFGQTtBQURBO0FBU0E7QUFDQTtBQUNBO0FBRkE7QUFqQkE7QUFDQTtBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQVFBO0FBQ0E7QUFEQTtBQVpBO0FBQ0E7Ozs7O0FBNUlBO0FBc0tBO0FBREE7QUFDQTs7Ozs7QUF0S0E7QUFDQTtBQThLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQVFBO0FBQ0E7QUFEQTtBQVpBO0FBQ0E7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBR0E7QUFDQTtBQUZBO0FBSEE7QUFKQTtBQUNBO0FBb0JBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBREE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBZkE7QUFDQTtBQStCQTtBQTlQQTtBQUNBO0FBZ1FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYkE7QUFDQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0FBQ0E7QUFhQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDblRBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFGQTs7Ozs7Ozs7OztBQ0pBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTs7Ozs7O0FDWkE7QUFDQTs7Ozs7QUFLQTs7Ozs7O0FDTkE7QUFDQTs7Ozs7Ozs7O0FBU0E7Ozs7OztBQ1ZBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUNBO0FBUUE7O0FBRUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQVBBO0FBREE7QUFXQTtBQURBO0FBR0E7QUFIQTtBQWRBO0FBQ0E7QUFvQkE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFOQTtBQUNBO0FBVUE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBR0E7Ozs7OztBQzlGQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUpBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUdBO0FBSEE7QUFMQTtBQVdBO0FBQ0E7QUFDQTtBQUNBOztBQUpBO0FBQ0E7O0FBREE7QUFVQTtBQUNBO0FBREE7QUFDQTtBQUlBO0FBQ0E7QUFEQTtBQUNBO0FBSUE7QUFDQTtBQURBO0FBQ0E7QUFJQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQURBO0FBR0E7QUFDQTtBQUNBOztBQUlBO0FBRkE7QUFUQTtBQXBCQTtBQUNBOztBQVZBO0FBZ0RBO0FBREE7O0FBS0E7QUFGQTtBQUNBOztBQW5EQTtBQTBEQTtBQURBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBWkE7QUFDQTs7QUE3REE7QUE4RUE7QUFEQTs7QUFLQTtBQUZBO0FBQ0E7O0FBakZBO0FBd0ZBO0FBREE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBQ0E7QUFLQTtBQWJBO0FBQ0E7Ozs7Ozs7Ozs7O0FBM0ZBO0FBcUhBO0FBQ0E7O0FBRkE7QUFLQTtBQURBO0FBQ0E7O0FBTEE7Ozs7Ozs7Ozs7Ozs7QUFzQkE7QUFiQTtBQUNBOztBQVZBOzs7Ozs7O0FBaUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFDQTs7QUEzQkE7QUF5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBOztBQXpDQTtBQUNBO0FBaURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFMQTs7QUFRQTtBQVJBO0FBSEE7QUFDQTtBQWNBO0FBbkJBO0FBQ0E7QUFxQkE7QUF4RUE7QUFDQTs7Ozs7O0FBckhBO0FBcU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUE1TUE7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDN2dEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDM2tCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN0QkE7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFSQTtBQUNBO0FBVUE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFIQTtBQUZBO0FBQ0E7QUFRQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBTkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFZQTtBQURBO0FBZEE7QUFDQTtBQXNCQTtBQTFFQTtBQUNBO0FBNEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTs7Ozs7O0FDMUdBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBUUE7QUFsQkE7QUFDQTtBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUZBO0FBSkE7QUFDQTtBQVdBO0FBckJBO0FBQ0E7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBUUE7QUFsQkE7QUFDQTtBQW9CQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQVJBO0FBQ0E7QUFVQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFUQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFGQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQVBBO0FBVEE7QUFDQTtBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFUQTtBQUNBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQVZBO0FBQ0E7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFEQTtBQU1BO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaEJBO0FBQ0E7QUFrQkE7QUFDQTtBQURBO0FBR0E7QUFEQTtBQTdCQTtBQWlDQTtBQURBO0FBT0E7QUEvQ0E7QUFDQTtBQWlEQTtBQTVLQTtBQUNBO0FBOEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BOzs7Ozs7O0FDeFNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFGQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBZkE7QUF1QkE7QUEzQkE7QUFDQTtBQTZCQTtBQXJEQTtBQUNBO0FBdURBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDM0VBO0FBQ0E7Ozs7Ozs7OztBQVNBOzs7Ozs7QUNWQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBUkE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBREE7QUFEQTtBQVNBO0FBYkE7QUFDQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQURBO0FBTkE7QUFDQTtBQVlBO0FBaERBO0FBQ0E7QUFrREE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBOzs7Ozs7O0FDakZBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBVUE7QUF6QkE7QUFDQTtBQTJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQU9BOzs7Ozs7QUN2REE7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBVEE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBTEE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFGQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUZBO0FBT0E7QUFUQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFMQTtBQVpBO0FBQ0E7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUxBO0FBU0E7QUFDQTtBQURBO0FBYkE7QUFpQkE7QUFDQTtBQURBO0FBR0E7QUF0QkE7QUFDQTtBQXdCQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFGQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBREE7QUFGQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBU0E7QUFqQkE7QUF1QkE7QUE3QkE7QUFKQTtBQUNBO0FBb0NBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBRkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBUEE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBS0E7QUFQQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFoQkE7QUFDQTtBQWtCQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBQ0E7QUFLQTtBQUNBO0FBREE7QUFDQTs7O0FBM0JBO0FBaUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUEzQ0E7QUFEQTtBQW1EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBOztBQUlBO0FBQ0E7QUFDQTtBQURBOzs7QUFEQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFGQTtBQVBBO0FBSkE7QUFIQTtBQURBO0FBeUJBO0FBM0JBO0FBaUNBO0FBeEZBO0FBQ0E7QUEwRkE7QUE1UUE7QUFDQTtBQThRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5CQTtBQUNBO0FBcUJBOzs7Ozs7QUN6VUE7QUFDQTs7Ozs7Ozs7O0FBU0E7Ozs7OztBQ1ZBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBVEE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXhCQTtBQUNBO0FBMEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5CQTtBQURBO0FBQ0E7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBZEE7QUFDQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBREE7QUFEQTtBQVBBO0FBREE7QUFDQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBSkE7QUFGQTtBQUhBO0FBQ0E7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFEQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBREE7QUFHQTtBQVZBO0FBQ0E7QUFZQTtBQUNBO0FBREE7QUFDQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBRkE7QUFSQTtBQUNBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQVRBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQURBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBTkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUZBO0FBaENBO0FBQ0E7QUF3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQWJBO0FBZUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBNUJBO0FBQ0E7QUFrQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFWQTtBQUNBO0FBY0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUhBO0FBUEE7QUFDQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRkE7QUFNQTtBQURBO0FBTkE7QUFVQTtBQWpCQTtBQUNBO0FBbUJBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQUhBO0FBS0E7QUFUQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFMQTtBQUhBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFOQTtBQVVBO0FBWkE7QUFDQTtBQWNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0FBQ0E7QUFlQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQURBO0FBTEE7QUFOQTtBQUNBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQWpCQTtBQUNBO0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFGQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBVEE7QUFZQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFPQTtBQWZBO0FBQ0E7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBR0E7QUFDQTtBQU9BO0FBakJBO0FBREE7QUFzQkE7QUFLQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBTEE7QUFTQTtBQXZFQTtBQUNBO0FBNkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQTdDQTtBQXplQTtBQUNBO0FBMmlCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlsQkE7QUFDQTs7O0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBVEE7QUFDQTtBQVdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQVJBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQVBBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBTEE7QUFEQTtBQVdBO0FBaEJBOzs7Ozs7Ozs7Ozs7Ozs7O0FDbEVBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQU5BO0FBQ0E7Ozs7O0FBREE7QUFlQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFoQkE7QUFzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBeENBO0FBQ0E7QUE2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFEQTtBQUlBOztBQUVBO0FBRkE7QUFKQTtBQVNBO0FBWkE7QUFDQTtBQWNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFKQTtBQU9BO0FBREE7QUFDQTtBQUdBO0FBVkE7QUFDQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7Ozs7Ozs7O0FBSkE7O0FBaUJBO0FBQ0E7QUFDQTtBQUNBOztBQUxBO0FBQ0E7O0FBREE7QUFXQTtBQUNBOztBQVpBO0FBQ0E7QUFlQTtBQWhCQTtBQWtCQTtBQWpDQTtBQUNBO0FBbUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBQ0E7QUFLQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBQ0E7QUFNQTtBQUNBOztBQWRBO0FBaUJBO0FBQ0E7QUFEQTtBQURBO0FBaEJBO0FBQ0E7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBS0E7QUFQQTtBQURBO0FBRkE7QUFjQTtBQW5CQTtBQUNBOzs7OztBQXlCQTs7O0FBR0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQVBBO0FBQ0E7QUFTQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFOQTtBQUFBO0FBWEE7QUFDQTs7Ozs7Ozs7O0FBK0JBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQURBO0FBSUE7QUFDQTtBQURBOztBQUpBO0FBQUE7QUFVQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQXBDQTtBQUNBO0FBc0NBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTs7QUFNQTtBQUNBO0FBQ0E7OztBQUZBO0FBTUE7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUhBO0FBT0E7QUFaQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFMQTtBQU9BO0FBakJBO0FBQ0E7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFOQTtBQVFBO0FBVEE7QUFXQTtBQVpBO0FBUEE7QUFDQTs7QUF1QkE7O0FBRUE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBTUE7QUFqQkE7QUFDQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBREE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFEQTtBQU9BO0FBZkE7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSkE7QUFNQTtBQUNBO0FBREE7QUFHQTtBQVRBO0FBREE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFKQTtBQU1BO0FBQ0E7QUFEQTtBQUdBO0FBVEE7QUFEQTtBQUNBO0FBYUE7QUFDQTtBQTdEQTs7Ozs7O0FDeFhBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU1BO0FBTkE7QUFGQTtBQUZBOzs7Ozs7Ozs7Ozs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBbkJBO0FBQ0E7QUEyQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBVEE7QUFDQTtBQWlCQTs7Ozs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUhBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFIQTtBQVRBO0FBQ0E7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFGQTtBQURBO0FBQ0E7QUFRQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBRkE7QUFDQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBTkE7QUFDQTtBQVFBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBWEE7QUFDQTtBQWFBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUdBO0FBUkE7QUFjQTtBQWhCQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU1BO0FBQ0E7QUFEQTtBQTFCQTtBQThCQTs7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQU9BO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBSkE7QUFiQTtBQTBCQTtBQUNBO0FBREE7QUFPQTtBQXZFQTtBQUNBO0FBeUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJBO0FBekJBO0FBekpBO0FBQ0E7QUFxTUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDalFBO0FBQ0E7OztBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQURBO0FBQ0E7QUFHQTs7QUFFQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRkE7QUFDQTtBQU1BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUhBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUZBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFGQTtBQVFBO0FBVEE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUxBO0FBakJBO0FBREE7QUFDQTtBQTJCQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBWkE7QUF4Q0E7QUFDQTtBQXlEQTtBQTNEQTtBQTZEQTtBQTFFQTtBQUNBO0FBNEVBO0FBQ0E7QUFEQTtBQWhIQTtBQUNBO0FBeUhBOzs7Ozs7O0FDcEpBO0FBQ0E7OztBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQVRBO0FBQ0E7QUFXQTs7Ozs7OztBQzlCQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBREE7QUFPQTtBQURBO0FBR0E7QUFEQTtBQUdBO0FBSEE7QUFaQTtBQUNBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBRkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBRkE7QUFDQTtBQVFBO0FBOUNBO0FBQ0E7QUFnREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBOzs7Ozs7QUN4RUE7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFWQTtBQUNBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUxBO0FBT0E7QUFQQTtBQUZBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUhBO0FBREE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFDQTtBQURBO0FBTEE7QUFTQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFDQTtBQURBO0FBTEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFIQTtBQU9BO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFIQTtBQVVBO0FBN0NBO0FBVEE7QUF5REE7QUFDQTtBQURBO0FBT0E7QUFQQTtBQURBO0FBekVBO0FBQ0E7QUF5RkE7QUFsSUE7QUFDQTtBQW9JQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTs7Ozs7Ozs7QUNsS0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUdBO0FBQ0E7QUFGQTtBQXBEQTtBQUNBO0FBMkRBO0FBeEVBO0FBQ0E7QUEwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFHQTtBQUNBO0FBRkE7QUF4Q0E7QUFDQTtBQStDQTtBQTVEQTtBQUNBO0FBOERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFHQTtBQUNBO0FBRkE7QUF4Q0E7QUFDQTtBQStDQTtBQTVEQTtBQUNBO0FBOERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNoU0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsQkE7QUFDQTtBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFEQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7O0FBSEE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQUNBO0FBREE7QUFOQTtBQUNBO0FBVUE7QUFDQTs7QUFEQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQURBO0FBR0E7QUFIQTtBQUtBO0FBQ0E7QUFoQkE7QUFrQkE7QUFDQTtBQURBO0FBR0E7QUFIQTtBQUtBO0FBQ0E7QUF4QkE7QUEwQkE7QUFDQTtBQUNBO0FBNUJBO0FBOEJBO0FBQ0E7QUFDQTtBQWhDQTtBQWtDQTtBQUNBO0FBQ0E7QUFwQ0E7QUFzQ0E7QUFDQTtBQUNBO0FBeENBO0FBMENBO0FBQ0E7QUFDQTtBQTVDQTtBQThDQTtBQUNBO0FBL0NBO0FBSkE7QUFDQTtBQXNEQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYkE7QUFDQTtBQWdCQTtBQUNBO0FBQ0E7QUFGQTtBQWhEQTtBQUNBO0FBcURBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUE5S0E7QUFDQTtBQW9MQTs7Ozs7Ozs7O0FDalFBOzs7Ozs7Ozs7Ozs7Ozs7QUNPQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTtBQWhCQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFKQTtBQUxBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFEQTtBQUdBO0FBVkE7QUFGQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFEQTtBQUdBO0FBWkE7QUFjQTtBQWhDQTtBQWtDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFEQTtBQUdBO0FBVEE7QUFDQTtBQVdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQWhFQTtBQUNBO0FBa0VBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQW5GQTtBQUNBO0FBcUZBO0FBQ0E7O0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFEQTtBQUxBO0FBUEE7QUFpQkE7QUFDQTtBQXpCQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0pBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFYQTtBQWFBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUdBO0FBSEE7QUFLQTtBQXJCQTtBQXVCQTtBQUVBO0FBekJBO0FBMkJBO0FBQ0E7QUFHQTtBQS9CQTtBQWlDQTtBQUdBO0FBcENBO0FBc0NBO0FBRUE7QUF4Q0E7QUEwQ0E7QUFFQTtBQTVDQTtBQThDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFwREE7Ozs7Ozs7Ozs7QUErREE7QUFDQTtBQUNBO0FBakVBO0FBbUVBO0FBdEVBO0FBQ0E7QUF3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUhBO0FBSEE7QUFTQTtBQUNBO0FBQ0E7QUFGQTtBQWRBO0FBQ0E7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFOQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUZBO0FBTUE7QUFUQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUxBO0FBU0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFsQkE7QUFDQTtBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFNQTtBQU5BO0FBREE7QUFVQTtBQVpBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQVBBO0FBU0E7QUF2QkE7QUF5QkE7QUFDQTtBQUNBO0FBRUE7QUFGQTtBQURBO0FBTUE7QUFDQTtBQURBO0FBTkE7QUFVQTtBQUNBO0FBREE7QUFHQTtBQXZDQTtBQXlDQTtBQUNBO0FBREE7QUFHQTtBQTVDQTtBQThDQTtBQUdBO0FBSEE7QUFLQTtBQW5EQTtBQXFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUZBO0FBREE7QUFRQTtBQVJBO0FBREE7QUFZQTtBQWpFQTtBQW1FQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFMQTtBQU9BO0FBMUVBO0FBNEVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUxBO0FBT0E7QUFuRkE7QUFxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFEQTtBQUdBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQU5BO0FBUUE7QUF2R0E7Ozs7Ozs7Ozs7QUFrSEE7QUFDQTtBQUNBO0FBRkE7QUFsSEE7QUF1SEE7QUFDQTtBQURBO0FBR0E7QUFoSUE7QUFDQTtBQWtJQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQURBO0FBSkE7QUFRQTtBQWhCQTtBQUNBOzs7Ozs7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBTUE7QUFUQTtBQUZBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFKQTtBQURBO0FBVUE7QUFPQTtBQUNBO0FBREE7QUFwQkE7QUFoQkE7QUFEQTtBQUNBO0FBMkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBL0RBO0FBOUJBO0FBQ0E7QUFnR0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBREE7QUFDQTs7Ozs7Ozs7QUFVQTtBQUNBO0FBREE7QUFDQTs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBTUE7QUFOQTtBQURBO0FBVUE7QUFyQkE7QUFDQTs7Ozs7Ozs7QUE4QkE7QUFDQTtBQURBO0FBakVBO0FBQ0E7QUFxRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3Z4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTkE7Ozs7Ozs7QUFBQTtBQUNBOzs7Ozs7QUFEQTtBQUNBOzs7Ozs7O0FBREE7QUFDQTtBQW1DQTtBQXBDQTtBQUNBO0FBc0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBVUE7QUFDQTs7Ozs7QUFLQTs7Ozs7QUFLQTs7Ozs7QUFLQTs7Ozs7QUFLQTs7Ozs7QUFLQTs7Ozs7QUFLQTs7Ozs7QUFLQTs7Ozs7QUFLQTs7Ozs7QUFLQTtBQUNBOzs7OztBQUtBOzs7OztBQUtBOzs7OztBQUtBO0FBQ0E7Ozs7O0FBS0E7Ozs7O0FBS0E7QUF2RkE7QUFDQTtBQXlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQU5BO0FBQ0E7QUFVQTs7O0FBR0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQVBBO0FBQ0E7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFEQTtBQUNBOzs7OztBQU9BO0FBQ0E7QUFEQTtBQUNBOzs7Ozs7Ozs7OztBQWFBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQVhBO0FBQ0E7Ozs7Ozs7Ozs7QUFzQkE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBZEE7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBckJBO0FBdUJBO0FBQ0E7QUFDQTtBQXpCQTtBQTJCQTtBQUNBO0FBNUJBO0FBOEJBO0FBOUJBO0FBZ0NBO0FBQ0E7QUFEQTtBQUdBO0FBekNBO0FBQ0E7Ozs7Ozs7O0FBa0RBO0FBQ0E7QUFEQTtBQUNBOzs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFKQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBUkE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFoREE7Ozs7QUFzREE7QUFDQTtBQUNBO0FBTkE7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7O0FBSEE7O0FBT0E7QUFDQTtBQUhBO0FBTEE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBMUVBO0FBQ0E7Ozs7OztBQWlGQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF4QkE7QUFDQTtBQTJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaENBO0FBQ0E7Ozs7Ozs7O0FBeUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBSkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRkE7QUFMQTtBQUNBOzs7QUFaQTtBQXlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBOzs7QUFGQTtBQU1BO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFiQTtBQWVBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUF6QkE7QUFIQTtBQURBOztBQWtDQTtBQUNBO0FBREE7QUFHQTs7O0FBREE7QUFLQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFaQTtBQWxDQTtBQUNBO0FBaURBO0FBbEZBO0FBQ0E7Ozs7OztBQXlGQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSkE7QUFDQTs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlGQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQUxBO0FBT0E7QUFYQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0R0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7O0FBTkE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFUQTtBQVdBO0FBWEE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQWhCQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQXJCQTtBQXVCQTtBQXZCQTtBQXlCQTtBQW5DQTtBQWJBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0QkE7QUFDQTtBQUNBO0FBREE7QUFHQTs7QUFKQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFaQTtBQWVBO0FBQ0E7QUFDQTtBQUhBOztBQU1BO0FBQ0E7QUFQQTtBQWRBO0FBQ0E7Ozs7Ozs7QUE4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7O0FBTUE7QUFDQTtBQVBBO0FBRkE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBYkE7QUFlQTtBQWZBO0FBRkE7QUFDQTs7Ozs7QUF3QkE7QUFDQTtBQURBO0FBQ0E7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFDQTs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQUNBOzs7OztBQVVBO0FBQ0E7QUFEQTtBQUNBOzs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQUNBOzs7Ozs7OztBQWFBO0FBQ0E7QUFEQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQURBOztBQUZBO0FBT0E7QUFDQTtBQUNBO0FBVEE7QUFDQTs7Ozs7Ozs7O0FBbUJBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFiQTs7Ozs7Ozs7OztBQXdCQTtBQUNBO0FBQ0E7QUFEQTtBQUdBOzs7QUFKQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBMUJBOzs7OztBQWdDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBQ0E7Ozs7Ozs7OztBQW1CQTtBQUNBO0FBREE7QUFDQTs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFLQTtBQUNBO0FBUEE7QUFwZ0NBO0FBQ0E7QUE4Z0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQXJCQTtBQURBO0FBQ0E7QUEyQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3h5Q0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJBOzs7Ozs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBREE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMkJBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBTEE7QUFEQTtBQUNBO0FBU0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6QkE7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRkE7QUFEQTtBQVFBO0FBZEE7QUFDQTtBQWdCQTs7Ozs7Ozs7Ozs7Ozs7QUNsQ0E7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7QUFwYUE7QUFDQTs7OztBQXlhQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUhBO0FBQ0E7OztBQUhBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBeEJBO0FBMEJBO0FBMUJBO0FBVkE7QUFDQTs7OztBQTBDQTtBQUNBO0FBRUE7QUFGQTtBQUNBO0FBSUE7QUFFQTtBQUZBO0FBQ0E7QUFJQTtBQUVBO0FBRkE7QUFDQTs7QUFaQTtBQWtCQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQW9CQTtBQXBCQTtBQXJCQTtBQUNBO0FBNENBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN2ZBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQURBO0FBR0E7O0FBSkE7QUFPQTtBQUVBO0FBRkE7QUFEQTs7QUFOQTtBQWNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFsQkE7QUFDQTtBQW9CQTs7Ozs7Ozs7Ozs7Ozs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFEQTtBQUhBO0FBQ0E7QUFXQTs7Ozs7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUZBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBRkE7QUFSQTs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFKQTtBQUNBO0FBTUE7QUFSQTs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBTEE7Ozs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7O0FBRUE7QUFGQTs7Ozs7O0FDTkE7QUFDQTs7O0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBRkE7QUFDQTtBQWFBO0FBdkJBO0FBQ0E7QUF5QkE7Ozs7Ozs7QUN0REE7QUFDQTs7O0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBREE7QUFXQTtBQUNBO0FBREE7QUFXQTtBQXRDQTtBQUZBO0FBQ0E7QUFvREE7QUE5REE7QUFDQTtBQWdFQTs7Ozs7OztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7Ozs7O0FDVEE7QUFDQTs7O0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUEzQkE7QUE4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQVBBO0FBREE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBSkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFSQTtBQURBO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQUNBO0FBYUE7QUFHQTtBQUNBO0FBR0E7QUFoRUE7QUFrRUE7QUFHQTtBQUNBO0FBakZBO0FBc0ZBO0FBbklBO0FBRkE7QUFDQTtBQTRJQTtBQXRKQTtBQUNBO0FBd0pBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTs7Ozs7O0FDbE5BO0FBQ0E7OztBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFGQTtBQUZBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFMQTtBQVhBO0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBS0E7QUE3QkE7QUFwQkE7QUF3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBTUE7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQU1BO0FBQ0E7QUEvQ0E7QUF6REE7QUErR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFoSEE7QUF1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUF4SEE7QUFDQTtBQStIQTtBQS9JQTtBQUNBO0FBaUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7Ozs7OztBQy9MQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBQ0E7QUFNQTtBQUNBOztBQURBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQU5BO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFEQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFQQTtBQUZBO0FBQ0E7QUFZQTtBQXJCQTtBQUNBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQXBCQTtBQXlCQTtBQTFCQTtBQUNBO0FBZ0NBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBWUE7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBZUE7QUFDQTtBQUNBO0FBeEZBO0FBQ0E7QUE2R0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFEQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQWpNQTtBQUNBO0FBdU1BOzs7Ozs7O0FDN09BO0FBQ0E7OztBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFaQTtBQUNBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFGQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQWZBO0FBRkE7QUFvQkE7QUE1QkE7QUFWQTtBQXlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQUhBO0FBS0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBV0E7QUF2QkE7QUE0QkE7QUE3QkE7QUFDQTtBQW1DQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQVlBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQWlCQTtBQUNBO0FBQ0E7QUEvRkE7QUExQ0E7QUErSkE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBaEtBO0FBQ0E7QUFzS0E7QUEzTEE7QUFDQTtBQTZMQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7Ozs7OztBQzlPQTtBQUNBOzs7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUhBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7O0FBTEE7QUFVQTtBQUNBO0FBWEE7QUFDQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBUEE7QUFGQTtBQUNBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQUNBO0FBSkE7QUFNQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFXQTtBQTdCQTtBQWtDQTtBQW5DQTtBQUNBO0FBeUNBO0FBU0E7QUFDQTtBQUNBO0FBYUE7QUFDQTtBQUNBO0FBOUZBO0FBRkE7QUFDQTtBQW9IQTtBQXRJQTtBQUNBO0FBd0lBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUdBOzs7Ozs7QUM1TEE7QUFDQTs7O0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFGQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBUkE7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFGQTtBQU1BO0FBR0E7QUFDQTtBQUNBO0FBZEE7QUFrQkE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUxBO0FBU0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUxBO0FBU0E7QUFDQTtBQUNBO0FBREE7QUFPQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBeERBO0FBQ0E7QUErREE7QUF0RUE7QUFoQkE7QUFDQTtBQXlGQTtBQW5HQTtBQUNBO0FBcUdBOzs7Ozs7O0FDcElBO0FBQ0E7OztBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBTEE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFQQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQWhCQTtBQURBO0FBQ0E7QUF5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQURBO0FBWkE7QUFDQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7O0FBTUE7QUFGQTtBQUlBO0FBWEE7QUFQQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQURBO0FBdEJBO0FBOEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBREE7QUEvQkE7QUF1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFEQTtBQXhDQTtBQWdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwRUE7QUFqREE7QUFDQTtBQTJIQTtBQWhKQTtBQUNBO0FBa0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBR0E7Ozs7OztBQzlPQTtBQUNBOzs7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBUEE7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFkQTtBQW1CQTtBQXBCQTtBQUNBO0FBMEJBO0FBOUNBO0FBRkE7QUFDQTtBQTRFQTtBQTFGQTtBQUNBO0FBNEZBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTs7Ozs7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFKQTtBQU1BO0FBUkE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJBO0FBQ0E7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQURBO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUZBO0FBRkE7QUFDQTtBQVNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFGQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBSkE7QUFEQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBTkE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUNBO0FBS0E7QUFHQTtBQUNBO0FBcEJBO0FBQ0E7QUF3QkE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFOQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBOztBQUVBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBZEE7QUF4SEE7QUFDQTtBQXlJQTs7Ozs7OztBQ3JMQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMUJBO0FBNEJBOzs7Ozs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFGQTtBQURBO0FBREE7QUFEQTtBQUNBO0FBWUE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBREE7QUFDQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0FBQ0E7QUFhQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBREE7QUFIQTtBQU9BO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFUQTtBQUNBO0FBZUE7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBREE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBOztBQUhBO0FBQUE7QUFDQTtBQU9BO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUZBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFSQTtBQUNBO0FBWUE7QUFDQTtBQUNBO0FBREE7OztBQURBO0FBQUE7QUFDQTtBQVFBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUxBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBQ0E7QUFLQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBTkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBTkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUdBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFIQTtBQXpCQTtBQUNBO0FBa0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBSkE7QUFPQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBWUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXBDQTtBQUNBO0FBeUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQURBO0FBT0E7QUEvQkE7QUFDQTtBQXFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFIQTtBQVBBO0FBREE7QUFDQTtBQWVBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFIQTtBQURBO0FBQ0E7QUFPQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQTVUQTtBQUNBO0FBZ1VBOzs7Ozs7O0FDbFlBO0FBQ0E7OztBQUVBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDYkE7QUFDQTs7O0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUZBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUpBO0FBRkE7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7O0FBREE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBSEE7QUFIQTtBQUZBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBZkE7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUF0QkE7QUE2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFGQTtBQTlCQTtBQXNDQTtBQUNBO0FBQ0E7QUFEQTtBQXZDQTtBQTJDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFSQTtBQURBO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQURBO0FBR0E7QUFIQTtBQXpCQTtBQTVDQTtBQTRFQTtBQUNBO0FBQ0E7QUFEQTtBQTdFQTtBQUNBO0FBaUZBO0FBNUZBO0FBQ0E7QUE4RkE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlKQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBREE7QUFPQTtBQVRBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWEE7QUFDQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQURBO0FBQ0E7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUpBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBQ0E7QUFEQTtBQVZBO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFQQTs7QUFBQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFIQTtBQUtBO0FBQ0E7QUFEQTtBQVJBO0FBWUE7QUFDQTtBQUNBO0FBREE7QUFEQTtBQWJBO0FBbUJBO0FBbkJBO0FBQ0E7O0FBZEE7QUFxQ0E7QUFDQTtBQURBO0FBR0E7QUFKQTtBQUNBOztBQXJDQTtBQTZDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUZBO0FBTUE7QUFEQTtBQVBBO0FBV0E7QUFEQTtBQWhCQTtBQUNBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRkE7QUFNQTtBQURBO0FBUEE7QUFXQTtBQURBO0FBaEJBO0FBckVBO0FBQ0E7QUEwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJBO0FBREE7QUFtQkE7QUFDQTtBQUNBO0FBREE7QUFPQTtBQS9CQTtBQUNBO0FBaUNBOztBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBRkE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBTUE7QUFDQTtBQUNBO0FBRkE7QUFOQTtBQUpBO0FBSkE7QUFDQTtBQXFCQTs7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUZBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTs7QUFIQTtBQU1BO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFQQTtBQUxBO0FBQ0E7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBTEE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUhBO0FBdFFBO0FBQ0E7QUE4UUE7Ozs7Ozs7QUN6VEE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBTEE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBSkE7QUFEQTtBQVVBO0FBWkE7QUFDQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUpBO0FBREE7QUFEQTtBQVVBO0FBWkE7QUFDQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFKQTtBQURBO0FBUUE7QUFWQTtBQUNBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFKQTtBQURBO0FBVUE7QUFaQTtBQUNBO0FBY0E7QUFDQTtBQUNBOzs7QUFGQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFNQTtBQU5BO0FBREE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBM0JBO0FBbkVBO0FBQ0E7QUFpR0E7Ozs7Ozs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBWEE7QUFDQTtBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFDQTtBQU1BO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBREE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFIQTtBQURBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFEQTtBQUNBO0FBT0E7QUFDQTtBQURBO0FBNURBO0FBQ0E7QUFnRUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFLQTtBQWhCQTtBQWtCQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFLQTtBQXhCQTtBQTBCQTtBQUNBO0FBQ0E7QUE1QkE7QUE4QkE7QUE5QkE7QUFnQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQXJDQTtBQUNBO0FBMkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQVRBO0FBakRBO0FBQ0E7QUErREE7Ozs7Ozs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRkE7QUFEQTtBQURBO0FBREE7QUFDQTtBQVlBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBOzs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQVRBO0FBREE7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFYQTtBQWFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUhBO0FBT0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQVRBO0FBZUE7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQURBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7O0FBSEE7QUFBQTtBQU9BO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBRkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBUkE7QUFZQTtBQUNBO0FBQ0E7QUFEQTs7O0FBREE7QUFBQTtBQVFBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFMQTtBQVNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUdBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFIQTtBQXpCQTtBQWtDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUpBO0FBT0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQVlBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTVCQTtBQWdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFEQTtBQU9BO0FBL0JBO0FBcUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFIQTtBQVBBO0FBREE7QUFlQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFEQTtBQU9BO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQTlSQTtBQUNBO0FBa1NBOzs7Ozs7O0FDN1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFLQTtBQWhCQTtBQWtCQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFLQTtBQXhCQTtBQTBCQTtBQUNBO0FBQ0E7QUE1QkE7QUE4QkE7QUE5QkE7QUFnQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQXJDQTtBQTJDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBUkE7QUFoREE7QUFDQTtBQTZEQTs7Ozs7Ozs7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBekJBO0FBMkJBOzs7Ozs7Ozs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBZkE7Ozs7OztBQ0xBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFGQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBT0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFOQTtBQVBBO0FBSEE7QUFDQTtBQXdCQTtBQWhEQTtBQUNBO0FBa0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNwRUE7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFKQTtBQU1BO0FBVEE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBRkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUZBO0FBQ0E7Ozs7OztBQUpBO0FBQ0E7QUFEQTtBQWtCQTtBQUNBO0FBREE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBT0E7QUFLQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFMQTtBQU9BO0FBUEE7QUEvQkE7QUFDQTtBQXlDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBM0RBO0FBQ0E7QUFpRUE7QUFuRUE7QUFxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUpBO0FBTUE7QUFSQTtBQURBO0FBREE7QUFDQTtBQWtCQTtBQTdGQTtBQUNBO0FBK0ZBO0FBbklBO0FBQ0E7QUFxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBOzs7Ozs7O0FDcktBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFEQTtBQU5BO0FBQ0E7QUFZQTtBQXRCQTtBQUNBO0FBd0JBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7Ozs7Ozs7QUNuREE7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFNQTtBQWRBO0FBQ0E7QUFnQkE7QUF2QkE7QUFDQTtBQXlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQURBO0FBUEE7QUFDQTtBQWFBO0FBakRBO0FBQ0E7QUFtREE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBOzs7Ozs7O0FDNUVBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBSkE7QUFDQTtBQVFBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFIQTtBQUZBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBUEE7QUFOQTtBQUNBO0FBZ0JBO0FBakVBO0FBQ0E7QUFtRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7Ozs7Ozs7QUN2RkE7QUFDQTs7Ozs7Ozs7O0FBU0E7Ozs7OztBQ1ZBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFDQTtBQUtBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBOztBQUZBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFGQTtBQUhBOzs7QUFEQTtBQVlBO0FBQ0E7QUFEQTtBQURBO0FBWEE7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFoQ0E7QUFDQTtBQWtDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQWxGQTtBQUNBO0FBb0ZBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7O0FBS0E7QUFDQTtBQUNBO0FBRkE7QUFDQTs7QUFLQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7Ozs7Ozs7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQVBBOzs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBTkE7QUFVQTtBQS9CQTtBQWlDQTs7Ozs7Ozs7QUN0Q0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFIQTtBQUZBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUpBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUpBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUNBO0FBS0E7QUFDQTtBQURBO0FBQ0E7OztBQXZCQTtBQTZCQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFLQTtBQUNBO0FBREE7QUFHQTtBQUdBO0FBQ0E7QUFGQTtBQU1BO0FBM0RBO0FBQ0E7QUE2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBVEE7QUFXQTtBQXRCQTtBQUNBO0FBNEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFOQTtBQVFBO0FBbEJBO0FBQ0E7QUF3QkE7QUE1TEE7QUFDQTtBQThMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFDQTtBQVFBOzs7Ozs7QUN6T0E7QUFDQTs7Ozs7Ozs7O0FBU0E7Ozs7OztBQ1ZBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBUEE7QUFGQTtBQUNBO0FBY0E7QUF4QkE7QUFDQTtBQTBCQTtBQUNBOzs7Ozs7QUFNQTs7OztBQUlBO0FBVkE7QUFDQTtBQVlBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBTEE7QUFIQTtBQUNBO0FBYUE7Ozs7Ozs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBTEE7QUFGQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFmQTs7Ozs7O0FDakJBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFGQTtBQUNBO0FBWUE7QUF0QkE7QUFDQTtBQXdCQTtBQUNBOzs7O0FBSUE7QUFKQTtBQU1BO0FBQ0E7QUFEQTtBQUdBOzs7Ozs7QUNwREE7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBdkJBO0FBQ0E7QUEyQkE7QUFsQ0E7QUFGQTtBQUNBO0FBMkNBO0FBckRBO0FBQ0E7QUF1REE7QUFDQTs7Ozs7Ozs7QUFRQTs7Ozs7Ozs7QUFRQTs7Ozs7Ozs7QUFRQTs7Ozs7Ozs7QUFRQTs7Ozs7Ozs7QUFRQTs7Ozs7Ozs7QUFRQTs7Ozs7Ozs7QUFRQTs7Ozs7Ozs7QUFRQTs7Ozs7Ozs7QUFRQTs7Ozs7Ozs7QUFRQTs7Ozs7Ozs7QUFRQTs7Ozs7Ozs7QUFRQTs7Ozs7Ozs7QUFRQTs7Ozs7Ozs7QUFRQTs7Ozs7Ozs7QUFRQTs7Ozs7Ozs7QUFRQTs7OztBQUlBO0FBcElBO0FBQ0E7QUFzSUE7QUFDQTtBQURBO0FBQ0E7QUFHQTs7Ozs7O0FDdE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBREE7Ozs7OztBQ0ZBO0FBQ0E7Ozs7Ozs7OztBQVNBOzs7Ozs7QUNWQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFGQTtBQUpBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBSkE7QUFRQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFKQTtBQVFBO0FBL0JBO0FBRkE7QUFvQ0E7QUFDQTtBQUNBOztBQURBO0FBSUE7OztBQURBO0FBS0E7OztBQURBO0FBS0E7QUFEQTtBQUdBO0FBSEE7QUFLQTtBQWhCQTtBQXJDQTtBQXdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUdBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBakJBO0FBekRBO0FBaUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFIQTtBQUZBO0FBbEZBO0FBK0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFIQTtBQUZBO0FBaEdBO0FBNkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBTEE7QUFPQTtBQVZBO0FBOUdBO0FBMkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUE1SEE7QUFDQTtBQXdJQTtBQXJKQTtBQUNBO0FBdUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNuTEE7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFDQTtBQVFBO0FBWkE7QUFDQTtBQWNBO0FBQ0E7QUFDQTs7Ozs7OztBQzNCQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBTkE7QUFGQTtBQUNBO0FBZUE7QUE1QkE7QUFDQTtBQThCQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7Ozs7Ozs7O0FDeERBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTtBQVpBO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMzQkE7QUFDQTs7Ozs7Ozs7O0FBU0E7Ozs7OztBQ1ZBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFSQTtBQVVBO0FBZkE7QUFDQTtBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBTkE7QUFDQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBTEE7QUFEQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFKQTtBQUNBO0FBUUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBTEE7QUFEQTtBQVZBO0FBQ0E7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQURBO0FBTkE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBSkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUxBO0FBT0E7QUFDQTtBQURBO0FBR0E7QUFWQTtBQVlBO0FBQ0E7QUFiQTtBQWVBO0FBQ0E7QUFEQTtBQUdBO0FBbEJBO0FBRkE7QUFEQTtBQUNBO0FBeUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFYQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5DQTtBQUNBO0FBc0NBO0FBL0pBO0FBQ0E7QUFpS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQWhCQTtBQWtCQTs7Ozs7O0FDeE9BO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBbkJBO0FBQ0E7QUFnQ0E7QUExQ0E7QUFDQTtBQTRDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBOzs7Ozs7QUNwRkE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBOztBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFOQTs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUpBO0FBUUE7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFkQTtBQWdCQTs7O0FBbkJBO0FBUEE7QUFEQTtBQUNBO0FBaUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBTkE7QUFRQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUhBO0FBTUE7QUFDQTs7QUFEQTs7QUFBQTtBQUFBO0FBTkE7QUFjQTtBQTFCQTtBQUZBO0FBQ0E7QUErQkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFQQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQWJBO0FBTEE7QUFDQTtBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWRBO0FBQ0E7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQURBO0FBSkE7QUFRQTtBQURBO0FBUkE7QUFZQTtBQWhCQTtBQUNBO0FBa0JBO0FBMUpBO0FBQ0E7QUE0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTs7Ozs7O0FDMU5BO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVZBO0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFUQTtBQWdCQTtBQW5CQTtBQUNBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSkE7QUFNQTtBQVJBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBREE7QUFDQTtBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFmQTtBQUNBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBRkE7QUFTQTtBQWRBO0FBQ0E7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUhBOztBQVFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBREE7QUFHQTtBQUxBO0FBSEE7QUFGQTs7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFOQTtBQWpCQTtBQUNBO0FBMEJBO0FBN0JBO0FBK0JBO0FBQ0E7QUFDQTtBQUZBO0FBdkNBO0FBQ0E7QUE0Q0E7QUEzREE7QUFDQTtBQTZEQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFEQTtBQUdBO0FBSEE7QUFQQTtBQUNBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFDQTtBQVVBO0FBQ0E7QUFDQTs7QUFGQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFyQkE7QUFDQTs7QUF0TkE7QUErT0E7QUFDQTtBQUNBOztBQWpQQTtBQW9QQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBTEE7QUFEQTtBQUNBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFIQTtBQU1BO0FBREE7QUFBQTtBQUNBOztBQU5BO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFSQTtBQUNBO0FBVUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQVZBO0FBWUE7QUExQkE7QUFDQTs7QUFKQTtBQWtDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUF2Q0E7QUF5Q0E7QUF6Q0E7QUFDQTtBQTJDQTtBQXpEQTtBQURBO0FBNkRBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTs7QUFEQTtBQUlBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFGQTtBQUpBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUxBO0FBREE7QUFTQTtBQVRBO0FBakJBO0FBREE7QUFGQTtBQVJBO0FBMkNBO0FBQ0E7QUFEQTtBQUNBOzs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQVpBO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTs7O0FBT0E7QUFDQTs7QUFKQTtBQU9BO0FBQ0E7QUFDQTtBQUNBOztBQVZBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7O0FBaEJBO0FBQ0E7O0FBREE7QUFzQkE7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFoQ0E7QUFDQTs7QUFOQTtBQTBDQTtBQTFDQTtBQUNBO0FBNENBO0FBQ0E7QUFEQTtBQTdHQTtBQUpBO0FBc0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQURBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFDQTs7QUEzY0E7QUF5ZEE7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQU5BO0FBREE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRkE7QUFDQTtBQUlBO0FBYkE7QUFEQTtBQUNBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQTFnQkE7QUFEQTs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFIQTtBQUtBO0FBVkE7QUFDQTs7Ozs7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFLQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBS0E7QUFaQTtBQUNBO0FBY0E7Ozs7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7Ozs7OztBQ0hBO0FBQ0E7Ozs7Ozs7OztBQVNBOzs7Ozs7QUNWQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFEQTtBQUNBO0FBT0E7QUFqQkE7QUFDQTtBQW1CQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMURBO0FBQ0E7Ozs7Ozs7OztBQVNBOzs7Ozs7QUNWQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFWQTtBQUNBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFaQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFIQTtBQUNBO0FBU0E7QUFmQTtBQUNBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFIQTtBQUNBO0FBU0E7QUFoQkE7QUFDQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQWhCQTtBQUNBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVUE7QUFDQTtBQWJBO0FBZUE7QUFDQTtBQWhCQTtBQURBO0FBREE7QUFDQTtBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFYQTtBQURBO0FBZUE7QUFDQTtBQUNBO0FBRkE7QUFmQTtBQUNBO0FBb0JBO0FBakRBO0FBQ0E7QUFtREE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBTkE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFMQTtBQUNBO0FBUUE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQVNBO0FBRUE7QUFEQTtBQWtCQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBS0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBekVBO0FBQ0E7QUEyRkE7QUExUEE7QUFDQTtBQTRQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYkE7QUFDQTs7O0FBaUJBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUMzVEE7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQWpCQTtBQUNBO0FBdUJBO0FBakNBO0FBQ0E7QUFtQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BOzs7Ozs7OztBQ3RGQTtBQUNBOzs7Ozs7Ozs7QUFTQTs7Ozs7O0FDVkE7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBREE7QUFHQTtBQWRBO0FBQ0E7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFSQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUZBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUErQkE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBTUE7QUFLQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBL0NBO0FBQ0E7QUFtREE7QUFHQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF2SEE7QUFDQTs7O0FBL0NBO0FBNEtBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQURBO0FBcEJBO0FBQ0E7QUF3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUZBO0FBQ0E7QUFPQTtBQWZBO0FBREE7QUFDQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFEQTtBQUNBO0FBR0E7QUFYQTtBQUNBO0FBYUE7QUFqQkE7QUFDQTtBQW1CQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBQ0E7QUFLQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBMVJBO0FBQ0E7QUE0UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWEE7QUFDQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWRBO0FBQ0E7QUFnQkE7QUFDQTs7Ozs7OztBQ3BWQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQUhBO0FBS0E7QUFqQkE7QUFDQTtBQTJCQTtBQXJDQTtBQUNBO0FBdUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBOzs7Ozs7QUN6REE7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQURBO0FBR0E7QUFiQTtBQUNBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQURBO0FBWEE7QUFEQTtBQUNBO0FBc0JBO0FBQ0E7QUFEQTtBQUNBO0FBU0E7QUFuREE7QUFDQTtBQTBEQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUhBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFGQTtBQVRBO0FBQ0E7QUFpQkE7QUE1R0E7QUFDQTtBQThHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BOzs7Ozs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWkE7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFOQTtBQVFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBUEE7QUFUQTtBQW1CQTtBQUNBOzs7Ozs7O0FDdEJBO0FBQ0E7Ozs7Ozs7OztBQVNBOzs7Ozs7QUNWQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQVJBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUZBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUpBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRkE7QUFDQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFPQTtBQUNBO0FBREE7QUFRQTtBQWxCQTtBQUNBO0FBd0JBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJBO0FBQ0E7QUFpQkE7QUFyR0E7QUFDQTtBQXVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFYQTtBQUNBOztBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQUNBO0FBWUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0pBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUZBOzs7Ozs7QUNWQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBT0E7QUFEQTtBQU9BO0FBUEE7QUFQQTtBQXNCQTtBQXRCQTtBQUNBO0FBd0JBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQXhDQTtBQUNBO0FBdURBO0FBakVBO0FBQ0E7QUFtRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BOzs7Ozs7Ozs7QUNuSEE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBT0E7QUFEQTtBQU9BO0FBUEE7QUFQQTtBQUNBO0FBc0JBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBREE7QUFMQTtBQUNBO0FBU0E7QUFPQTtBQXpEQTtBQUNBO0FBK0RBO0FBekVBO0FBQ0E7QUEyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTs7Ozs7OztBQzFIQTtBQUNBOzs7Ozs7Ozs7QUFTQTs7Ozs7O0FDVkE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFYQTtBQUNBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBYkE7QUFEQTtBQUNBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFqQkE7QUFDQTs7Ozs7O0FBREE7QUE4QkE7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFuQ0E7QUFDQTtBQXlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUpBO0FBVUE7QUFEQTtBQUdBO0FBWkE7QUFDQTtBQWNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFIQTtBQUpBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFYQTtBQUNBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQWRBO0FBbUJBO0FBREE7QUFHQTtBQUhBO0FBS0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBREE7QUFHQTtBQVpBO0FBOUJBO0FBQ0E7QUE4Q0E7QUFoTEE7QUFDQTtBQWtMQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBQ0E7O0FBV0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3BPQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBT0E7QUFQQTtBQUNBO0FBU0E7QUFDQTtBQURBO0FBR0E7QUFIQTtBQVNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBT0E7QUF6Q0E7QUFDQTtBQWtFQTtBQTVFQTtBQUNBO0FBOEVBOzs7Ozs7QUMxRkE7QUFDQTs7Ozs7Ozs7O0FBU0E7Ozs7OztBQ1ZBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFYQTtBQWFBO0FBcEJBO0FBQ0E7QUFzQkE7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBTkE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFsQkE7QUFDQTtBQW9CQTtBQUNBO0FBREE7QUFDQTs7Ozs7OztBQWpFQTtBQTJFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBREE7QUFDQTtBQU9BO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBREE7QUF0QkE7QUFDQTs7Ozs7O0FBM0VBO0FBaUhBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFIQTtBQUZBO0FBQ0E7Ozs7OztBQWpIQTtBQStIQTtBQURBO0FBQ0E7Ozs7OztBQS9IQTtBQXdJQTtBQURBO0FBQ0E7Ozs7Ozs7QUF4SUE7QUFDQTtBQWtKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFIQTtBQUZBO0FBQ0E7O0FBTEE7QUFtQkE7QUFDQTtBQUZBO0FBQ0E7O0FBbkJBO0FBeUJBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFKQTtBQUNBOztBQTNCQTtBQXFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBQ0E7O0FBdENBO0FBNkNBO0FBREE7QUFDQTtBQUdBO0FBaERBO0FBQ0E7Ozs7Ozs7QUFsSkE7QUFDQTtBQTJNQTs7QUFGQTtBQUNBOztBQURBO0FBUUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQVhBO0FBYUE7QUFiQTtBQURBO0FBTEE7QUFDQTtBQXVCQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBckNBO0FBQ0E7QUF1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFYQTtBQVBBO0FBRkE7QUF3QkE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUxBOztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFEQTtBQWpCQTtBQXBFQTtBQUNBO0FBMEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUZBO0FBQ0E7OztBQVRBO0FBc0JBO0FBREE7QUFDQTs7QUF0QkE7QUEyQkE7QUFDQTtBQUZBO0FBQ0E7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7Ozs7QUFWQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7Ozs7QUFEQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFEQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBOzs7O0FBREE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBREE7QUFDQTtBQU9BO0FBL0VBO0FBQ0E7QUFpRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBREE7QUFEQTtBQVNBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFUQTtBQURBO0FBaUJBO0FBQ0E7QUFEQTtBQXJCQTtBQUNBOzs7Ozs7OztBQXhYQTtBQUNBO0FBeVpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFGQTtBQUpBO0FBU0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQUNBO0FBTUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBTEE7QUFEQTtBQXZCQTtBQUNBO0FBaUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUhBO0FBQ0E7QUFRQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFwQkE7QUFDQTtBQXdCQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUpBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQURBO0FBTEE7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBWkE7QUFDQTtBQTRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQURBO0FBTEE7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQURBO0FBSkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUZBO0FBS0E7QUFEQTtBQUpBO0FBREE7QUFVQTs7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBTkE7QUFXQTtBQUNBO0FBQ0E7QUFGQTtBQVhBO0FBYkE7QUFDQTtBQThCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBQ0E7QUFEQTtBQUdBO0FBVkE7QUFDQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQVFBO0FBUkE7QUFOQTtBQUNBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQURBO0FBUEE7QUFjQTtBQUdBO0FBREE7QUFoQkE7QUFGQTtBQUNBO0FBeUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUpBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTs7QUFoQkE7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXBCQTtBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYkE7QUFDQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFSQTtBQUNBO0FBVUE7QUFPQTtBQURBO0FBMUZBO0FBQ0E7Ozs7Ozs7O0FBbm5CQTtBQTh0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFQQTtBQURBO0FBV0E7QUFYQTtBQWFBO0FBZkE7QUFDQTs7Ozs7O0FBOXRCQTtBQXF2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBVEE7QUFDQTs7Ozs7QUFydkJBO0FBcXdCQTtBQUNBOztBQUZBO0FBS0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQUNBO0FBVkE7QUFDQTs7Ozs7O0FBcndCQTtBQXV4QkE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTs7QUFSQTtBQVdBO0FBREE7QUFWQTtBQUNBOzs7OztBQXZ4QkE7QUEyeUJBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFIQTtBQURBO0FBT0E7QUFDQTtBQURBO0FBR0E7QUFEQTtBQVpBO0FBZ0JBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUF6QkE7QUFDQTtBQTZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBREE7QUFVQTtBQUNBO0FBREE7QUFEQTtBQVRBO0FBSkE7QUFDQTtBQW9CQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQU5BO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBREE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUF6QkE7QUFDQTs7O0FBOTFCQTtBQTgzQkE7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU1BO0FBQ0E7QUFYQTtBQUNBO0FBYUE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUhBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFIQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUpBO0FBREE7QUFEQTtBQVVBO0FBQ0E7QUFEQTtBQWRBO0FBQ0E7QUFrQkE7QUExOEJBO0FBQ0E7QUE0OEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFuQ0E7QUFDQTs7QUFzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQW5DQTtBQUNBO0FBcUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbmtDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBUkE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBSEE7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFIQTtBQUNBO0FBT0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFEQTtBQU9BO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQWxCQTtBQUNBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFJQTtBQUNBO0FBQ0E7QUFJQTtBQURBO0FBSkE7QUFTQTtBQVRBO0FBRkE7QUFjQTtBQURBO0FBN0JBO0FBQ0E7QUFrQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBRkE7QUFSQTtBQUNBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQURBO0FBR0E7QUFoQkE7QUFDQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU5BO0FBQ0E7QUFtQkE7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQWRBO0FBZ0JBO0FBaEJBO0FBQ0E7QUFzQkE7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUNBO0FBS0E7QUFHQTtBQUNBO0FBRkE7QUFqREE7QUFDQTtBQTBEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFTQTtBQURBO0FBVEE7QUFOQTtBQXFCQTtBQXJCQTtBQUZBO0FBMEJBO0FBN0JBO0FBQ0E7QUErQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFMQTtBQURBO0FBU0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQWRBO0FBZ0JBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFKQTtBQUhBO0FBVUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQWZBO0FBaUJBO0FBQ0E7QUFsQkE7QUFDQTtBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBL0RBO0FBQ0E7QUEwRUE7QUFqV0E7QUFDQTtBQW1XQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7Ozs7OztBQ25ZQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQURBO0FBR0E7QUFUQTtBQUNBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQXRCQTtBQUpBO0FBQ0E7QUFrQ0E7QUF0REE7QUFDQTtBQXdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDbkZBO0FBQ0E7Ozs7Ozs7OztBQVNBOzs7Ozs7QUNWQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFUQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNsQkE7QUFDQTs7O0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBWEE7QUFDQTtBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBZEE7QUFGQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQWJBO0FBcEJBO0FBdUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQWZBO0FBeENBO0FBMERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFKQTtBQU1BO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFqQkE7QUEzREE7QUFtRkE7QUFDQTtBQUNBO0FBREE7QUFwRkE7QUF3RkE7QUFDQTtBQUNBO0FBREE7QUF6RkE7QUE2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQTNCQTtBQTlGQTtBQTRIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFMQTtBQU9BOzs7QUFSQTtBQUFBO0FBYUE7QUFiQTtBQUNBOztBQVJBO0FBeUJBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFEQTtBQXhCQTtBQTdIQTtBQThKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBeEJBO0FBL0pBO0FBMExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQURBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBbkNBO0FBM0xBO0FBaU9BO0FBQ0E7QUFDQTtBQURBO0FBbE9BO0FBc09BO0FBQ0E7QUFDQTtBQURBO0FBdk9BO0FBMk9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUZBO0FBTUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFsQkE7QUFDQTs7QUFIQTtBQXlCQTtBQUNBO0FBQ0E7QUFEQTtBQXBRQTtBQXdRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQURBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFEQTtBQUhBO0FBV0E7QUF0QkE7QUF6UUE7QUFrU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFMQTtBQW5TQTtBQTJTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUxBO0FBNVNBO0FBb1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBZEE7QUFyVEE7QUFzVUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBdlVBO0FBNlVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQVBBO0FBOVVBO0FBd1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUZBO0FBTUE7QUFUQTtBQXpWQTtBQXFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQURBO0FBVkE7QUF0V0E7QUFxWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFMQTtBQXRYQTtBQThYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF4QkE7QUEwQkE7QUFDQTtBQURBO0FBR0E7QUFwQ0E7QUEvWEE7QUFzYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTs7QUFOQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoQkE7QUF2YUE7QUFDQTtBQThiQTtBQXZkQTtBQUNBO0FBeWRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEvQkE7QUFDQTtBQWlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7QUFDQTtBQXNCQTs7Ozs7OztBQ3ZqQkE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQWpCQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQVRBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFMQTtBQU9BO0FBUkE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUxBO0FBRkE7QUFVQTtBQVhBO0FBQ0E7QUFhQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBQ0E7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFQQTs7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBTEE7QUFGQTtBQVlBO0FBZEE7QUFDQTs7OztBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBTkE7O0FBREE7QUFXQTtBQURBO0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFGQTs7QUFIQTtBQVlBO0FBQ0E7O0FBRUE7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUpBO0FBRkE7QUFXQTs7O0FBcEJBO0FBd0JBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFMQTtBQU9BO0FBakNBO0FBbUNBO0FBOUNBO0FBYkE7QUFDQTtBQThEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQURBO0FBTkE7QUFVQTtBQUNBO0FBREE7QUFmQTtBQUNBO0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBTkE7QUFDQTs7QUFKQTtBQUNBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUZBO0FBUUE7QUFWQTtBQUNBO0FBWUE7QUFsQ0E7Ozs7OztBQ3pPQTtBQUNBOzs7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQVRBO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRkE7QUFNQTtBQUNBO0FBQ0E7QUFEQTtBQVBBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQVpBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFsQkE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQXhCQTtBQTZCQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7O0FBRUE7QUFGQTs7QUFBQTtBQVJBO0FBOUJBO0FBOENBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBSkE7QUEvQ0E7QUFzREE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQXZEQTtBQWdFQTtBQUNBOztBQUVBO0FBQ0E7QUFIQTtBQWpFQTtBQXVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBTkE7QUF4RUE7QUFpRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFQQTtBQURBO0FBSkE7QUFDQTs7QUFIQTtBQXVCQTtBQUNBO0FBQ0E7QUFEQTtBQXhHQTtBQTRHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBZkE7QUE3R0E7QUErSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQVFBO0FBcEJBO0FBaElBO0FBMkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBRkE7QUFNQTtBQUdBO0FBQ0E7QUFDQTtBQUtBO0FBREE7QUF6QkE7QUErQkE7QUE5Q0E7QUE1SkE7QUE2TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQURBO0FBSEE7O0FBYkE7QUFzQkE7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7Ozs7O0FBRkE7QUFVQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBOztBQUVBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFQQTtBQXZCQTtBQWlDQTtBQXpDQTtBQUNBO0FBZ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBSkE7QUFNQTtBQVZBO0FBQ0E7QUFZQTtBQTdHQTtBQTlNQTtBQUNBO0FBcVVBO0FBeFZBO0FBQ0E7QUEwVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQUNBO0FBU0E7QUFDQTtBQURBO0FBQ0E7QUFHQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3haQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSkE7QUFGQTtBQUNBO0FBYUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFMQTtBQVNBO0FBQ0E7QUFEQTtBQVRBO0FBZEE7QUFDQTtBQTRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFMQTtBQURBO0FBU0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQWRBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUpBO0FBSEE7QUFDQTs7QUFIQTtBQWVBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUF0QkE7QUF3QkE7QUF4QkE7QUEwQkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdEJBO0FBd0JBO0FBekJBO0FBMURBO0FBQ0E7QUF5RkE7QUE5SkE7QUFDQTtBQWdLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7Ozs7Ozs7QUMvTEE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBUkE7QUFDQTtBQVVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFEQTtBQU9BO0FBQ0E7QUFEQTtBQUdBO0FBckJBO0FBQ0E7QUF1QkE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBTkE7QUFZQTtBQWJBO0FBZUE7QUFDQTtBQUNBO0FBREE7QUFPQTtBQVRBO0FBV0E7QUFYQTtBQWpCQTtBQUhBO0FBQ0E7QUFtQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQVRBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFsQkE7QUFDQTtBQXdCQTtBQWxDQTtBQUNBO0FBb0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUdBO0FBWkE7QUFDQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBR0E7QUEzQkE7QUFEQTtBQWlDQTtBQWpDQTtBQW1DQTtBQTdDQTtBQUNBO0FBK0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUxBO0FBREE7QUFDQTtBQVNBO0FBWkE7QUFDQTtBQWNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFYQTtBQUNBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFEQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQUNBO0FBb0JBO0FBQ0E7QUFEQTs7QUF4QkE7QUFBQTtBQWxDQTtBQUNBO0FBMEVBO0FBelJBO0FBQ0E7QUEyUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7Ozs7Ozs7QUMvVEE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQVRBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUZBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUZBO0FBQ0E7QUFNQTtBQUNBO0FBREE7QUFDQTs7Ozs7QUE5Q0E7QUF1REE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFEQTtBQUhBO0FBQ0E7QUFZQTtBQW5CQTtBQURBO0FBQ0E7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUdBO0FBbEJBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFqQkE7QUFtQkE7Ozs7QUFEQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBS0E7QUFqQkE7QUFtQkE7QUFEQTtBQU9BO0FBREE7QUFHQTtBQUhBO0FBQ0E7QUFTQTtBQUNBO0FBakdBO0FBQ0E7Ozs7Ozs7QUF4R0E7QUF1TkE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBU0E7QUFDQTtBQUtBO0FBSUE7QUFEQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQXRDQTtBQUxBO0FBQ0E7QUFzREE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFIQTtBQUxBO0FBREE7QUFDQTtBQWNBO0FBNVJBO0FBQ0E7QUE4UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBOzs7Ozs7O0FDNVVBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQVJBO0FBQ0E7QUFVQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQUNBO0FBTUE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFEQTtBQUdBO0FBVEE7QUFDQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUF0QkE7QUFKQTtBQUNBO0FBa0NBO0FBaEVBO0FBQ0E7QUFrRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM3RkE7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFEQTtBQVFBO0FBWkE7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQTFCQTtBQUNBO0FBNEJBO0FBdENBO0FBQ0E7QUF3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbEVBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBVEE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBOzs7O0FBUEE7QUFDQTtBQWdCQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBRkE7QUFEQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQXpCQTtBQUNBO0FBMkJBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBREE7QUFQQTtBQUNBO0FBYUE7QUEvRkE7QUFDQTtBQWlHQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTs7Ozs7O0FDM0hBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBREE7QUFRQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUF0QkE7QUFDQTtBQTRCQTtBQXRDQTtBQUNBO0FBd0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2pFQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBTkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQURBO0FBUUE7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBeEJBO0FBQ0E7QUE4QkE7QUFqREE7QUFDQTtBQW1EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFEQTtBQVZBO0FBREE7QUFDQTtBQWdCQTs7Ozs7Ozs7Ozs7Ozs7QUNwQkE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQUNBO0FBcUJBO0FBL0JBO0FBQ0E7QUFpQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBOzs7Ozs7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBREE7QUFPQTtBQVBBO0FBREE7QUFEQTs7Ozs7O0FDRkE7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBREE7QUFPQTtBQVBBO0FBUEE7QUFDQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFQQTtBQURBO0FBQ0E7Ozs7O0FBcENBO0FBcURBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFEQTtBQURBO0FBVUE7QUFkQTtBQUNBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQURBO0FBVkE7QUFDQTtBQWdCQTtBQXRGQTtBQUNBO0FBd0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTs7Ozs7O0FDM0hBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBUkE7QUFDQTtBQVVBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFXQTtBQTFDQTtBQUNBO0FBNENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBOzs7Ozs7QUN6RUE7QUFDQTs7Ozs7Ozs7O0FBU0E7Ozs7OztBQ1ZBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFQQTtBQUNBO0FBU0E7QUFyQkE7QUFDQTtBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBOzs7Ozs7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFQQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBREE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFIQTs7QUFMQTtBQVlBO0FBQ0E7QUFEQTtBQVpBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUpBO0FBRkE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBakJBO0FBdUJBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUhBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFIQTtBQU5BO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFEQTtBQURBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBREE7QUFEQTtBQVNBO0FBdkJBO0FBeUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBSkE7QUFNQTtBQVJBOzs7Ozs7Ozs7QUFrQkE7QUFDQTs7QUFFQTtBQUhBO0FBbEJBO0FBSkE7QUFDQTtBQTZCQTtBQXhDQTtBQTBDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQVBBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBQ0E7QUFDQTtBQUNBOzs7QUFKQTtBQVFBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQWpCQTtBQU5BO0FBNkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBSkE7QUFEQTtBQVVBO0FBR0E7QUFDQTtBQUNBO0FBTEE7QUFWQTtBQURBO0FBc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQWNBO0FBQ0E7QUFDQTtBQUxBO0FBU0E7QUFDQTtBQURBO0FBR0E7QUFHQTtBQUNBO0FBSkE7QUFwRUE7QUFwTUE7QUFDQTtBQWtSQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNuVUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFaQTtBQUNBO0FBeUJBOzs7Ozs7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBREE7QUFPQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQURBO0FBR0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7O0FBdENBO0FBNENBO0FBREE7O0FBSUE7QUFDQTtBQURBO0FBSkE7QUEzQ0E7QUFvREE7QUFDQTtBQURBO0FBQ0E7O0FBS0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUhBO0FBT0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUdBO0FBQ0E7QUFGQTtBQWxCQTtBQUNBO0FBNkJBO0FBdkNBO0FBeUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFGQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQURBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBREE7QUFPQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRkE7QUFNQTtBQUNBO0FBQ0E7QUFEQTtBQUZBO0FBWkE7QUFMQTtBQXlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFTQTtBQUdBO0FBQ0E7QUFDQTtBQUxBO0FBYkE7QUFDQTtBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQUNBO0FBREE7QUFMQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBTEE7QUFlQTtBQUNBO0FBQ0E7QUFMQTtBQWpFQTtBQTVNQTtBQUNBO0FBd1NBOzs7Ozs7O0FDdlVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0FBSEE7QUFpQkE7QUF4QkE7QUFDQTtBQTBCQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUpBO0FBUUE7Ozs7OztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBREE7QUFJQTs7QUFFQTtBQUZBO0FBSkE7QUFTQTtBQVpBO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFmQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0QkE7QUFDQTs7Ozs7Ozs7O0FBU0E7Ozs7OztBQ1ZBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFSQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFDQTtBQURBO0FBREE7QUFOQTtBQUZBO0FBQ0E7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7Ozs7Ozs7O0FBL0JBO0FBNENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTkE7QUFDQTtBQVlBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRkE7QUFSQTtBQUNBO0FBbUJBO0FBakZBO0FBQ0E7QUFtRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUNBO0FBUUE7QUFDQTs7Ozs7OztBQzFIQTtBQUNBOzs7Ozs7QUFNQTs7Ozs7O0FDUEE7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUpBO0FBUUE7QUFiQTtBQUNBO0FBZUE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUpBO0FBREE7QUFGQTtBQUNBO0FBYUE7QUFDQTtBQURBO0FBQ0E7Ozs7Ozs7QUF0Q0E7QUFnREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFiQTtBQUNBOzs7OztBQWhEQTtBQW9FQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBSkE7QUFGQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU1BO0FBUkE7QUFMQTtBQWdCQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFEQTtBQXZCQTtBQUNBO0FBK0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBS0E7QUFWQTtBQUNBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFIQTtBQUtBO0FBTkE7QUFMQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFGQTtBQWJBO0FBQ0E7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFKQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQVJBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQVBBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBREE7QUF4QkE7QUFDQTtBQTRCQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFGQTtBQVJBO0FBQ0E7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBTEE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBUEE7QUFDQTtBQWNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFGQTtBQW9EQTtBQURBO0FBVUE7QUFDQTtBQURBO0FBREE7QUFPQTtBQUNBO0FBREE7QUFEQTtBQVlBO0FBREE7QUFqRkE7QUFDQTtBQTRGQTtBQXBXQTtBQUNBO0FBc1dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQ0E7QUFTQTs7Ozs7Ozs7QUN4WUE7QUFDQTtBQUNBOzs7Ozs7QUNGQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFIQTtBQURBO0FBQ0E7QUFTQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBckNBO0FBQ0E7QUF1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFGQTtBQU1BO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFyQkE7QUFDQTtBQXVCQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQVFBO0FBZEE7QUFDQTtBQTBCQTtBQWhFQTtBQUNBO0FBa0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUZBO0FBTUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQXZCQTtBQUNBO0FBeUJBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFEQTtBQU9BO0FBREE7QUFHQTtBQWpCQTtBQUNBO0FBbUJBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQWZBO0FBQ0E7QUEwQkE7QUF2RkE7QUFDQTtBQXlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTs7Ozs7Ozs7OztBQ2pQQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFEQTs7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDVEE7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQVZBO0FBeUJBO0FBekJBO0FBRkE7QUFDQTtBQThCQTtBQXhDQTtBQUNBO0FBMENBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBOzs7Ozs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQWJBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUpBO0FBRkE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBSkE7QUFGQTtBQVNBO0FBdENBO0FBd0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQVJBO0FBeERBOzs7Ozs7QUNGQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFWQTtBQUNBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBQ0E7QUFDQTtBQURBO0FBVEE7QUFDQTtBQWFBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQURBO0FBVEE7QUFDQTtBQW9CQTtBQXZEQTtBQUNBO0FBeURBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7Ozs7OztBQ2hGQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFaQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFyQkE7QUFDQTtBQTBCQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQTBDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBRkE7QUFPQTtBQVZBO0FBd0RBO0FBQ0E7QUF6REE7QUE3Q0E7QUFDQTtBQXlKQTtBQW5OQTtBQUNBO0FBcU5BO0FBQ0E7QUFEQTtBQUNBO0FBR0E7Ozs7OztBQzdPQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBYkE7QUFDQTtBQWVBO0FBQ0E7QUFEQTtBQUNBO0FBT0E7QUEzQkE7QUFDQTtBQTZCQTs7Ozs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFYQTtBQUNBO0FBc0JBO0FBQ0E7Ozs7Ozs7QUMxQkE7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBT0E7QUF6QkE7QUFDQTtBQTJCQTs7Ozs7O0FDdkNBO0FBQ0E7Ozs7Ozs7OztBQVNBOzs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUpBO0FBUUE7QUFUQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQVVBO0FBaEJBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFGQTtBQWxDQTtBQUNBO0FBeUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQWJBOzs7Ozs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFIQTtBQURBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFIQTtBQUhBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUpBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFRQTtBQUNBO0FBZEE7QUFsREE7QUFDQTtBQTJFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBUkE7QUFMQTtBQUNBO0FBbUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcklBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUhBO0FBREE7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUpBO0FBQ0E7QUFVQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQWxEQTtBQUNBO0FBd0VBOzs7Ozs7O0FDekZBO0FBQ0E7Ozs7Ozs7OztBQVNBOzs7Ozs7QUNWQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUhBO0FBQ0E7QUFPQTtBQUNBO0FBREE7QUFDQTtBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQVBBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFEQTtBQURBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUhBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBQ0E7QUFLQTtBQWxFQTtBQUNBO0FBb0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUNBO0FBUUE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFLQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUEzQ0E7QUFDQTtBQTZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUdBO0FBREE7QUFIQTtBQWlCQTtBQURBO0FBeEJBO0FBQ0E7QUErQkE7QUEzREE7QUFDQTtBQTZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQVNBO0FBREE7QUFUQTtBQWlCQTtBQURBO0FBeEJBO0FBQ0E7QUErQkE7QUEzREE7QUFDQTtBQTZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBOzs7Ozs7O0FDdFNBO0FBQ0E7Ozs7Ozs7OztBQVNBOzs7Ozs7QUNWQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUlBO0FBREE7QUFKQTtBQWFBO0FBYkE7QUFtQkE7QUFyQkE7QUFMQTtBQUNBO0FBOEJBO0FBQ0E7QUFDQTtBQUlBO0FBREE7QUFMQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQWlCQTtBQUNBO0FBQ0E7QUFEQTtBQU9BO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFsQkE7QUF5REE7QUFDQTtBQURBO0FBT0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFEQTtBQStDQTtBQS9DQTtBQTNFQTtBQXFLQTtBQTVMQTtBQUNBO0FBOExBO0FBdlFBO0FBQ0E7QUF5UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQUNBOztBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWZBO0FBQ0E7QUFpQkE7QUFDQTs7Ozs7OztBQzVVQTtBQUNBOzs7Ozs7Ozs7QUFTQTs7Ozs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFOQTs7Ozs7OztBQUFBO0FBQ0E7Ozs7OztBQURBO0FBQ0E7Ozs7Ozs7QUFEQTtBQUNBO0FBbUNBO0FBcENBO0FBQ0E7QUFzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBOzs7OztBQUtBOzs7OztBQUtBOzs7OztBQUtBOzs7OztBQUtBOzs7OztBQUtBOzs7OztBQUtBOzs7OztBQUtBOzs7OztBQUtBOzs7OztBQUtBO0FBQ0E7Ozs7O0FBS0E7Ozs7O0FBS0E7Ozs7O0FBS0E7QUFDQTs7Ozs7QUFLQTs7Ozs7QUFLQTtBQXZGQTtBQUNBO0FBeUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBTkE7QUFDQTtBQVVBOzs7QUFHQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBUEE7QUFDQTs7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQURBO0FBQ0E7Ozs7O0FBT0E7QUFDQTtBQURBO0FBQ0E7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBWEE7QUFDQTs7Ozs7Ozs7OztBQXNCQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFkQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFyQkE7QUF1QkE7QUFDQTtBQUNBO0FBekJBO0FBMkJBO0FBQ0E7QUE1QkE7QUE4QkE7QUE5QkE7QUFnQ0E7QUFDQTtBQURBO0FBR0E7QUF6Q0E7QUFDQTs7Ozs7Ozs7QUFrREE7QUFDQTtBQURBO0FBQ0E7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUpBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFSQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWhEQTs7OztBQXNEQTtBQUNBO0FBQ0E7QUFOQTs7QUFTQTtBQUNBO0FBQ0E7QUFDQTs7QUFIQTs7QUFPQTtBQUNBO0FBSEE7QUFMQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUExRUE7QUFDQTs7Ozs7O0FBaUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFwQkE7QUF1QkE7QUFDQTtBQUNBO0FBekJBO0FBQ0E7Ozs7Ozs7O0FBa0NBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBSkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRkE7QUFMQTtBQUNBOzs7QUFaQTtBQXlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBOzs7QUFGQTtBQU1BO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFiQTtBQWVBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUF6QkE7QUFIQTtBQURBOztBQWtDQTtBQUNBO0FBREE7QUFHQTs7O0FBREE7QUFLQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFWQTtBQXBDQTtBQUNBO0FBaURBO0FBbEZBO0FBQ0E7Ozs7OztBQXlGQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSkE7QUFDQTs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlGQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQUxBO0FBT0E7QUFYQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0R0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7O0FBTkE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFUQTtBQVdBO0FBWEE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQWhCQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQXJCQTtBQXVCQTtBQXZCQTtBQXlCQTtBQW5DQTtBQWJBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0QkE7QUFDQTtBQUNBO0FBREE7QUFHQTs7QUFKQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFaQTtBQWVBO0FBQ0E7QUFDQTtBQUhBOztBQU1BO0FBQ0E7QUFQQTtBQWRBO0FBQ0E7Ozs7Ozs7QUE4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7O0FBTUE7QUFDQTtBQVBBO0FBRkE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBYkE7QUFlQTtBQWZBO0FBRkE7QUFDQTs7Ozs7QUF3QkE7QUFDQTtBQURBO0FBQ0E7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFDQTs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQUNBOzs7OztBQVVBO0FBQ0E7QUFEQTtBQUNBOzs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQUNBOzs7Ozs7OztBQWFBO0FBQ0E7QUFEQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQURBOztBQUZBO0FBT0E7QUFDQTtBQUNBO0FBVEE7QUFDQTs7Ozs7Ozs7O0FBbUJBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFiQTs7Ozs7Ozs7OztBQXdCQTtBQUNBO0FBQ0E7QUFEQTtBQUdBOzs7QUFKQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBMUJBOzs7OztBQWdDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBQ0E7Ozs7Ozs7OztBQW1CQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFiQTtBQUNBOzs7Ozs7OztBQXNCQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFLQTtBQUNBO0FBUEE7QUFDQTtBQVNBOztBQUVBO0FBQ0E7QUFIQTtBQXZoQ0E7QUFDQTtBQTZoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBckJBO0FBREE7QUFDQTtBQTJCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0ekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTs7QUFFQTtBQUNBO0FBREE7QUFHQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFyQkE7QUF3QkE7QUFEQTtBQUNBO0FBR0E7QUEzQkE7QUFDQTtBQTZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQURBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFEQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUpBO0FBQ0E7QUFNQTs7QUFFQTtBQUZBO0FBQ0E7O0FBS0E7QUFDQTs7QUFEQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBREE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBbkJBO0FBcENBOzs7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBWkE7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBQ0E7QUFLQTs7Ozs7O0FDbENBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBOztBQXpCQTtBQTRCQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFUQTtBQUNBO0FBYUE7QUExQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0lBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBQ0E7Ozs7Ozs7Ozs7O0FBZUE7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBREE7QUFDQTs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBOzs7Ozs7Ozs7O0FBY0E7QUFDQTtBQURBO0FBQ0E7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUZBO0FBTUE7QUFqQkE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUNBOzs7QUFHQTtBQUNBO0FBSkE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlDQTtBQUNBO0FBQ0E7QUFFQTtBQUZBO0FBSUE7QUFOQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQThCQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFFQTtBQUZBO0FBREE7QUFNQTtBQTFCQTtBQUNBO0FBNEJBOzs7Ozs7QUMzT0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBREE7QUFHQTtBQUxBO0FBQ0E7QUFPQTs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBRkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFGQTtBQWJBO0FBQ0E7QUFzQkE7Ozs7Ozs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTs7QUFGQTtBQU9BO0FBREE7QUFOQTtBQUhBO0FBY0E7QUFDQTtBQWZBO0FBaUJBO0FBQ0E7QUFsQkE7QUFvQkE7QUFDQTtBQXJCQTtBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBVEE7QUFZQTtBQURBO0FBQ0E7O0FBWkE7O0FBa0JBO0FBRkE7QUFDQTs7QUFqQkE7QUF1QkE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRkE7QUFKQTtBQUNBOztBQXZCQTtBQWtDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBQ0E7O0FBckNBO0FBMENBO0FBREE7QUFDQTtBQUdBOzs7Ozs7QUFNQTtBQU5BO0FBQ0E7QUFRQTs7Ozs7O0FBTUE7QUFOQTtBQUNBO0FBUUE7Ozs7OztBQU1BO0FBTkE7QUEvREE7QUF6QkE7QUFrR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQU5BO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7OztBQVRBO0FBbUJBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFIQTtBQUxBO0FBQ0E7O0FBbkJBO0FBZ0NBO0FBREE7QUFDQTtBQUdBO0FBbkNBO0FBcEdBO0FBQ0E7QUEwSUE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFSQTtBQVdBO0FBQ0E7QUFEQTs7QUFJQTtBQUZBO0FBSUE7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUZBO0FBREE7QUFDQTtBQVFBO0FBQ0E7O0FBdENBO0FBeUNBO0FBQ0E7QUFGQTtBQUNBOztBQXpDQTtBQStDQTtBQURBO0FBQ0E7O0FBL0NBO0FBb0RBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUE5REE7QUFDQTtBQWdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUZBO0FBS0E7QUFEQTs7QUFJQTtBQUpBO0FBQ0E7QUFNQTtBQVhBO0FBQ0E7QUFhQTtBQUNBO0FBQ0E7O0FBRkE7QUFLQTtBQURBOztBQUlBO0FBSkE7QUFDQTtBQU1BO0FBWEE7QUFqQkE7QUFDQTtBQStCQTs7Ozs7Ozs7Ozs7Ozs7QUM3UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTtBQWhCQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUxBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFEQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFKQTtBQUxBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFEQTtBQUdBO0FBVkE7QUFGQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFEQTtBQUdBO0FBWkE7QUFjQTtBQWhDQTtBQWtDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFEQTtBQUdBO0FBVEE7QUFDQTtBQVdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQWhFQTtBQUNBO0FBa0VBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQW5GQTtBQUNBO0FBcUZBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBTkE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQUxBO0FBUEE7QUF1QkE7QUFDQTtBQXJDQTtBQUhBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBWEE7QUFhQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFsQkE7QUFvQkE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFIQTtBQUtBO0FBNUJBO0FBOEJBO0FBQ0E7QUEvQkE7QUFpQ0E7QUFDQTtBQUNBO0FBbkNBO0FBcUNBO0FBQ0E7QUF0Q0E7QUF3Q0E7QUFDQTtBQXpDQTtBQTJDQTtBQUNBO0FBNUNBO0FBOENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5EQTs7Ozs7Ozs7OztBQThEQTtBQUNBO0FBQ0E7QUFoRUE7QUFrRUE7QUFyRUE7QUFDQTtBQXVFQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFIQTtBQVFBO0FBQ0E7QUFDQTtBQUZBO0FBYkE7QUFDQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFGQTtBQU1BO0FBVkE7QUFDQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFMQTtBQVNBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBbEJBO0FBQ0E7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFNQTtBQU5BO0FBREE7QUFVQTtBQWJBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBUEE7QUFTQTtBQXpCQTtBQTJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFGQTtBQU1BO0FBQ0E7QUFDQTtBQURBO0FBUEE7QUFXQTtBQUNBO0FBREE7QUFHQTtBQTFDQTtBQTRDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBaERBO0FBa0RBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUF0REE7QUF3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUZBO0FBREE7QUFRQTtBQVJBO0FBREE7QUFZQTtBQXJFQTtBQXVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUxBO0FBT0E7QUEvRUE7QUFpRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFMQTtBQU9BO0FBekZBOztBQTRGQTtBQUNBOztBQUVBO0FBRkE7QUFJQTtBQURBO0FBR0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQVBBO0FBU0E7QUEvR0E7Ozs7Ozs7Ozs7QUEwSEE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQTNIQTtBQWdJQTtBQUNBO0FBREE7QUFHQTtBQTVJQTtBQUNBO0FBOElBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFKQTtBQVFBO0FBaEJBO0FBQ0E7Ozs7OztBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWJBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFNQTtBQVRBO0FBRkE7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBSkE7QUFEQTtBQUhBO0FBY0E7QUFDQTtBQUNBO0FBREE7QUFoQkE7QUFuQkE7QUFEQTtBQUNBO0FBMENBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUE5REE7QUE5QkE7QUFDQTtBQStGQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFEQTtBQUNBOzs7Ozs7OztBQVVBO0FBQ0E7QUFEQTtBQUNBOzs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFNQTtBQU5BO0FBREE7QUFVQTtBQXJCQTtBQUNBOzs7Ozs7OztBQThCQTtBQUNBO0FBREE7QUFqRUE7QUFDQTtBQXFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2wwQkE7QUFDQTtBQUNBOzs7Ozs7QUNGQTtBQUNBOzs7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTNCQTtBQUNBO0FBNkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsQkE7QUFEQTtBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBS0E7QUFDQTtBQURBO0FBUkE7QUFZQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBREE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQURBO0FBR0E7QUFIQTtBQUtBO0FBQ0E7QUFEQTtBQVBBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQURBO0FBTEE7QUFEQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQXhCQTtBQUNBO0FBK0JBO0FBakNBO0FBTEE7QUF5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQVJBO0FBZUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQVpBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFwQkE7QUF3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFKQTtBQVFBOztBQUVBO0FBRkE7QUFJQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQWJBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFqQkE7QUFWQTtBQWdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFOQTtBQUZBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU1BO0FBTkE7QUFMQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFIQTtBQUtBO0FBQ0E7QUFEQTtBQVBBO0FBQ0E7QUFXQTtBQXRDQTtBQTVVQTtBQUNBO0FBcVhBOzs7Ozs7O0FDMVpBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFYQTtBQUNBO0FBYUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBUkE7QUFVQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQU5BO0FBUUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVlBO0FBREE7QUFwQkE7QUE0QkE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFlQTtBQURBO0FBekVBO0FBaUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBREE7QUFUQTtBQXVCQTtBQTFCQTtBQTRCQTtBQUNBO0FBREE7QUE3S0E7QUFDQTtBQXNMQTs7Ozs7Ozs7QUN4TkE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUpBO0FBRkE7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQURBO0FBQ0E7QUFXQTtBQUNBOztBQURBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUhBO0FBSEE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFSQTtBQURBO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQURBO0FBR0E7QUFIQTtBQXpCQTtBQUNBO0FBK0JBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBRkE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQVBBO0FBU0E7QUFmQTtBQS9GQTtBQUNBO0FBaUhBOzs7Ozs7Ozs7Ozs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQVBBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFLQTtBQVBBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBWkE7O0FBQUE7O0FBQUE7O0FBQUE7QUFxQkE7O0FBckJBOztBQUFBO0FBQ0E7O0FBREE7QUE2QkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBRkE7O0FBRkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBVkE7QUFGQTtBQUNBO0FBb0JBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUZBOztBQUZBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQVZBO0FBRkE7QUFDQTs7QUF2QkE7QUE2Q0E7QUFDQTtBQUZBO0FBQ0E7OztBQTdDQTtBQUNBO0FBb0RBO0FBQ0E7O0FBdERBO0FBeURBO0FBREE7QUF4REE7QUFDQTs7QUE3QkE7QUEyRkE7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7Ozs7O0FBL0ZBO0FBdUdBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBOUdBO0FBQ0E7QUFxSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTs7Ozs7O0FDek5BO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRkE7QUFNQTtBQWhDQTtBQUNBO0FBa0NBOzs7Ozs7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFmQTs7QUFvQkE7Ozs7QUFJQTtBQUNBOztBQURBO0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQWRBO0FBZ0JBO0FBREE7QUFHQTtBQXBCQTtBQUNBOztBQW5CQTtBQTJDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQXBEQTtBQUNBO0FBc0RBOzs7Ozs7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFEQTtBQUNBOztBQVJBO0FBYUE7QUFEQTtBQUNBOztBQWJBOztBQW1CQTtBQUZBO0FBQ0E7O0FBbEJBO0FBd0JBO0FBREE7QUFDQTs7QUF4QkE7QUE2QkE7QUFEQTtBQUNBOztBQTdCQTs7QUFtQ0E7QUFGQTtBQUNBO0FBSUE7QUF0Q0E7QUFDQTtBQXdDQTs7Ozs7OztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFYQTtBQWFBO0FBQ0E7QUFDQTtBQW5CQTtBQUNBO0FBcUJBOzs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBaEJBO0FBQ0E7QUFxQkE7Ozs7Ozs7O0FDakNBO0FBQ0E7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFEQTtBQU9BO0FBVEE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFEQTtBQUNBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFKQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQUNBO0FBREE7QUFWQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUxBO0FBUUE7QUFDQTtBQURBO0FBREE7QUFLQTtBQUNBOztBQWJBOztBQUFBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFIQTtBQUtBO0FBQ0E7QUFEQTtBQVJBO0FBWUE7QUFDQTtBQUNBO0FBREE7QUFEQTtBQWJBO0FBbUJBO0FBbkJBO0FBQ0E7O0FBbkJBO0FBMENBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRkE7QUFNQTtBQURBO0FBUEE7QUFXQTtBQURBO0FBaEJBO0FBQ0E7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFGQTtBQU1BO0FBREE7QUFQQTtBQVdBO0FBREE7QUFoQkE7QUFsRUE7QUFDQTtBQXVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFEQTtBQUNBO0FBVUE7O0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFGQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7O0FBRkE7QUFLQTtBQURBO0FBR0E7QUFDQTs7QUFFQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBTUE7QUFDQTtBQUNBO0FBRkE7QUFOQTtBQUpBO0FBUkE7QUFDQTtBQXlCQTs7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUZBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7O0FBRkE7QUFLQTtBQURBO0FBR0E7O0FBUEE7QUFVQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBUEE7QUFUQTtBQUNBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFIQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaEJBO0FBREE7QUFzQkE7QUFDQTtBQUNBO0FBREE7QUFPQTtBQW5DQTtBQXBQQTtBQUNBO0FBMFJBOzs7Ozs7O0FDblVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBREE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFIQTtBQURBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFEQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFYQTtBQUNBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUZBO0FBQ0E7QUFPQTtBQUNBO0FBREE7QUE3REE7QUFDQTtBQWlFQTs7Ozs7OztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRkE7QUFNQTtBQVZBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUhBO0FBTUE7QUFDQTtBQUNBO0FBREE7QUFGQTtBQUxBO0FBREE7QUFDQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFqQkE7QUFxQkE7QUFEQTtBQXBCQTtBQUNBO0FBd0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFEQTtBQTVEQTtBQUNBO0FBb0VBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQWRBO0FBa0JBO0FBREE7QUFqQkE7QUFDQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFDQTtBQVBBO0FBN0JBO0FBQ0E7QUF1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFEQTtBQVJBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuTEE7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUNBOzs7OztBQU9BO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQURBO0FBQ0E7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBTEE7QUFDQTs7Ozs7Ozs7O0FBZUE7O0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFDQTs7QUFIQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBWkE7QUFDQTs7Ozs7Ozs7Ozs7QUF3QkE7QUFDQTtBQUNBO0FBREE7QUFDQTs7QUFGQTtBQU9BO0FBQ0E7QUFGQTtBQUNBOztBQVBBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFoQkE7QUFDQTs7Ozs7Ozs7O0FBMEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFQQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBcUJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBTEE7QUFPQTtBQVJBO0FBQ0E7O0FBSEE7QUFlQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBREE7QUFPQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBUEE7QUFDQTtBQWFBO0FBNUJBO0FBQ0E7Ozs7Ozs7O0FBcUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7Ozs7Ozs7OztBQWVBO0FBRUE7QUFEQTs7Ozs7O0FDMUxBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFOQTtBQVhBO0FBQ0E7QUFpQ0E7Ozs7Ozs7QUNsREE7QUFDQTtBQUNBOzs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBdEJBO0FBQ0E7QUF3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQURBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFnQkE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaEJBO0FBMUJBO0FBOURBO0FBQ0E7QUE4R0E7Ozs7Ozs7Ozs7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFEQTtBQUlBO0FBREE7QUFJQTtBQUNBOzs7QUFGQTtBQU1BO0FBQ0E7Ozs7Ozs7QUFGQTtBQVVBO0FBVkE7QUFYQTtBQUNBO0FBd0JBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFOQTtBQUNBO0FBUUE7QUFDQTtBQUNBOztBQUZBOzs7QUFBQTtBQVNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7QUFGQTs7QUFJQTtBQURBOzs7QUE3QkE7O0FBQUE7QUFzQ0E7O0FBdENBO0FBeUNBO0FBREE7OztBQXhDQTtBQStDQTtBQUNBO0FBRkE7QUFJQTtBQWxEQTs7Ozs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFqQkE7QUFDQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFEQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFWQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBUkE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBVkE7QUFDQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBREE7QUFMQTtBQURBO0FBQ0E7QUFlQTtBQXRCQTtBQUNBO0FBd0JBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQUNBO0FBREE7QUFkQTtBQUZBO0FBQ0E7QUFxQkE7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUZBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBUkE7QUFhQTtBQUNBOztBQUVBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFIQTtBQVBBO0FBakJBO0FBQ0E7QUErQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBQ0E7QUFEQTtBQVpBO0FBRkE7QUFDQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBUEE7QUFDQTtBQVNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFUQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQVZBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBaE9BO0FBQ0E7QUFzT0E7Ozs7Ozs7QUM3UEE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBSkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQUNBO0FBREE7QUFQQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFOQTtBQVFBO0FBeEJBO0FBQ0E7QUEwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFKQTtBQURBO0FBREE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWEE7QUFDQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFEQTtBQUNBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUZBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBQ0E7O0FBRkE7QUFLQTtBQUNBO0FBREE7QUFEQTtBQVJBO0FBY0E7QUFDQTtBQURBO0FBaEJBO0FBQ0E7QUFvQkE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFMQTtBQTNCQTtBQUNBO0FBbUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTs7Ozs7QUFQQTtBQWlCQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFEQTtBQUpBO0FBaEJBO0FBQ0E7QUE2QkE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBSEE7QUFEQTtBQU9BO0FBVEE7QUFXQTtBQWhCQTtBQUNBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7QUFzQkE7QUFDQTtBQURBO0FBR0E7QUE5QkE7QUFDQTtBQWdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7OztBQUdBO0FBR0E7QUFDQTtBQUNBO0FBSEE7OztBQUxBO0FBakJBO0FBQ0E7QUFpQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7O0FBSkE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBREE7QUFJQTtBQURBO0FBSEE7QUFPQTtBQVBBO0FBRkE7QUF2QkE7QUF6TkE7QUFDQTtBQThQQTs7Ozs7OztBQ3RWQTtBQUNBO0FBQ0E7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFEQTtBQUlBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBOztBQUpBO0FBVUE7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQWpCQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTs7O0FBSkE7QUFXQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQWhDQTtBQUNBO0FBcUNBOztBQUVBO0FBQ0E7QUFEQTtBQUdBO0FBREE7O0FBSUE7QUFDQTtBQURBO0FBR0E7QUFIQTtBQUpBO0FBSkE7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFIQTtBQUZBO0FBZkE7QUFDQTtBQXdCQTtBQUNBOztBQUVBO0FBQ0E7QUFEQTtBQUdBO0FBREE7O0FBSUE7QUFDQTtBQURBO0FBR0E7QUFIQTtBQUpBO0FBSkE7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFIQTtBQUZBO0FBZkE7QUFEQTtBQWhHQTtBQUNBO0FBMkhBOzs7Ozs7QUNoSUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBUEE7QUFiQTtBQUNBO0FBdUJBOzs7Ozs7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQUNBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFGQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUZBO0FBQ0E7QUFNQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBTEE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFKQTtBQVFBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFYQTtBQUNBO0FBYUE7QUFDQTtBQURBO0FBckNBO0FBQ0E7QUF5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBQ0E7QUFNQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFwQkE7QUFDQTtBQXdCQTtBQUNBO0FBQ0E7O0FBRkE7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBREE7QUFRQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBWEE7QUFKQTtBQUNBO0FBc0JBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFMQTtBQUNBO0FBU0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFGQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBckJBO0FBdUJBO0FBekJBO0FBQ0E7QUErQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBRkE7O0FBSkE7QUFVQTtBQURBO0FBVEE7QUFhQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBTUE7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBTkE7QUF2Q0E7QUEvT0E7QUFDQTtBQW9TQTs7Ozs7OztBQ25VQTtBQUNBOzs7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFYQTtBQUNBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQVZBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFGQTtBQU1BO0FBR0E7QUFDQTtBQUNBO0FBM0JBO0FBNURBO0FBQ0E7QUE0RkE7Ozs7Ozs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBREE7QUFEQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFEQTtBQURBO0FBQ0E7QUFTQTs7O0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFaQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQU5BO0FBQ0E7QUFXQTtBQUNBO0FBREE7QUEzREE7QUErREE7Ozs7OztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFGQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBRkE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBREE7QUFEQTtBQUxBO0FBQ0E7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQVJBO0FBQ0E7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFIQTtBQURBO0FBT0E7QUFEQTtBQWhCQTtBQUNBO0FBb0JBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFEQTtBQU9BO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFFQTtBQTdCQTtBQTlHQTtBQUNBO0FBaUpBOzs7Ozs7Ozs7QUN0S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFaQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNXQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBQ0E7QUFNQTs7Ozs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7Ozs7Ozs7OzsiLCJzb3VyY2VSb290IjoiIn0=